diff --git a/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
new file mode 100644
index 00000000000..edf0c00532e
--- /dev/null
+++ b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
@@ -0,0 +1,171 @@
+name: Sync Microsoft.Build version in analyzer template with Version.props
+on:
+  push:
+    branches:
+      - main
+    paths:
+      - 'eng/Versions.props'
+
+jobs:
+  Sync-version:
+    runs-on: ubuntu-latest
+
+    steps:
+    - name: Checkout repository
+      uses: actions/checkout@v3
+
+    - name: Set baseBranch variable
+      id: vars
+      run: echo "baseBranch=${{ github.ref_name }}" >> $GITHUB_ENV
+
+    - name: Update analyzer template version with version from Versions.props
+      shell: pwsh
+      run: |
+        try {
+            # Define the paths to your XML and JSON files
+            $xmlFilePath = "eng/Versions.props"
+            $jsonFilePath = "template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json"
+
+            # Check if the XML file exists
+            if (-Not (Test-Path -Path $xmlFilePath)) {
+                throw "Versions.props file not found: $xmlFilePath"
+            }
+
+            # Load and parse the XML content
+            [xml]$xmlContent = Get-Content -Path $xmlFilePath
+            $versionPrefix = [string]$xmlContent.Project.PropertyGroup.VersionPrefix
+            $versionPrefix = $versionPrefix.Trim()
+
+            # Validate the versionPrefix
+            if ([string]::IsNullOrWhiteSpace($versionPrefix)) {
+                throw "VersionPrefix is empty or null in the XML file: $xmlFilePath"
+            }
+
+            # Check if the JSON file exists
+            if (-Not (Test-Path -Path $jsonFilePath)) {
+                throw "Analyzer template file not found: $jsonFilePath"
+            }
+
+            # Load the JSON template
+            $jsonContent = Get-Content -Path $jsonFilePath -Raw | ConvertFrom-Json
+
+            # Check if the versionPrefix is different from the current defaultValue
+            if ($versionPrefix -ne $jsonContent.symbols.MicrosoftBuildVersion.defaultValue) {
+                # Update the defaultValue of MicrosoftBuildVersion in the JSON template
+                $jsonContent.symbols.MicrosoftBuildVersion.defaultValue = $versionPrefix
+        
+                # Convert the JSON content back to a string
+                $jsonString = $jsonContent | ConvertTo-Json -Depth 10
+        
+                # Write the updated JSON back to the file
+                Set-Content -Path $jsonFilePath -Value $jsonString
+                Write-Output "Updated MicrosoftBuildVersion to $versionPrefix"
+        
+                # Set the updateNeeded output variable to true
+                $updateNeeded = "true"
+            } else {
+                Write-Output "No update needed. MicrosoftBuildVersion is already $versionPrefix"
+        
+                # Set the updateNeeded output variable to false
+                $updateNeeded = "false"
+            }
+
+            # Set the versionPrefix and template filePath as an output
+            Add-Content -Path $env:GITHUB_ENV -Value "versionPrefix=$versionPrefix"
+            Add-Content -Path $env:GITHUB_ENV -Value "jsonFilePath=$jsonFilePath"
+            Add-Content -Path $env:GITHUB_ENV -Value "updateNeeded=$updateNeeded"
+            Write-Output "Extracted versionPrefix: $versionPrefix"
+            Write-Output "Extracted jsonFilePath: $jsonFilePath"
+            Write-Output "Update needed: $updateNeeded"
+        }
+        catch {
+            Write-Error "An error occurred: $_"
+        }
+
+    - name: Create Pull Request
+      if: env.updateNeeded == 'true'
+      uses: actions/github-script@v7
+      with:
+        script: |
+          const baseBranch = process.env.baseBranch;
+          const versionPrefix = process.env.versionPrefix;
+          const filePath = process.env.jsonFilePath;
+          const newBranch = `${baseBranch}-update-msbuild-version-for-analyzer-template`;
+          const commitMessage = `Update MicrosoftBuildVersion to ${versionPrefix}`;
+          const prBody = '[Automated] Update the MicrosoftBuildVersion defaultValue in the template.json.';
+          const prTitle = 'Update MicrosoftBuildVersion in analyzer template';
+          
+          // Main execution
+          (async () => {
+            try {
+              // Configure git
+              await configureGit();
+          
+              // Create and switch to the new branch
+              await createAndSwitchBranch(newBranch);
+          
+              // Check if the branch PR already exists on the remote
+              const shouldOpenPullRequest = await checkBranchPRExists(newBranch,baseBranch);
+          
+              // Stage and commit the changes
+              await stageAndCommitChanges(filePath, commitMessage);
+          
+              // Push the new branch to the repository
+              await pushBranch(newBranch);
+          
+              // Create the pull request if needed
+              if (shouldOpenPullRequest) {
+                await createPullRequest(baseBranch, newBranch, prTitle, prBody);
+              } else {
+                console.log("The PR already exists, skipping opening a new PR.");
+              }
+            } catch (error) {
+              core.setFailed(error);
+            }
+          })();
+          
+          async function configureGit() {
+            await exec.exec(`git config user.name "github-actions"`);
+            await exec.exec(`git config user.email "github-actions@github.com"`);
+          }
+          
+          async function createAndSwitchBranch(branch) {
+            await exec.exec('git', ['checkout', '-b', branch]);
+          }
+          
+          async function checkBranchPRExists(newBranch,baseBranch) {
+            // Check if a pull request already exists
+            const { data: pullRequests } = await github.rest.pulls.list({
+              owner: context.repo.owner,
+              repo: context.repo.repo,
+              head: newBranch,
+              base: baseBranch,
+              state: 'open',
+            });
+          
+            if (pullRequests.length === 0) {
+              return true;
+            } else {
+              return false;
+            }
+          }
+          
+          async function stageAndCommitChanges(filePath, commitMessage) {
+            await exec.exec(`git add ${filePath}`);
+            await exec.exec(`git commit -m "${commitMessage}"`);
+          }
+          
+          async function pushBranch(branch) {
+            await exec.exec(`git push --force --set-upstream origin HEAD:${branch}`);
+          }
+          
+          async function createPullRequest(baseBranch, newBranch, title, body) {
+            await github.rest.pulls.create({
+              owner: context.repo.owner,
+              repo: context.repo.repo,
+              title: title,
+              body: body,
+              head: newBranch,
+              base: baseBranch
+            });
+          }
diff --git a/documentation/High-level-overview.md b/documentation/High-level-overview.md
index 0f31a36c077..4ee9aaa9e30 100644
--- a/documentation/High-level-overview.md
+++ b/documentation/High-level-overview.md
@@ -1,39 +1,39 @@
 # What is MSBuild
 MSBuild is a build platform used mainly for .NET and Visual Studio. When referencing MSBuild technically we can divide what MSBuild is in a few main parts:
-- Programming language that uses XML semantics to define build actions and data.
+- Programming language that uses XML to define build actions and data.
 - A standard set of scripts authored in the MSBuild language (so called 'common targets') that are shipped together with the MSBuild binaries and that define what a build process means.
-- API and command line interface that interprets and manipulates the programming language.
+- API and command line interface that interprets and requests results from programs written in the programming language.
 - Build engine that executes a build based on the programming language inputs.
 
-MSBuild also contains some extensibility aspects that mostly interact with the API and engine. These are built to increase customization and interaction capability.
+MSBuild is extensible via XML and .NET plugins. These are built to increase customization and interaction capability.
 
 This document covers all parts of MSBuild in a general manner from the perspective of an MSBuild codebase maintainer. There will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit Microsoft Learn's [MSBuild documentation](https://learn.microsoft.com/visualstudio/msbuild).
 
 
 # MSBuild XML Language
-The MSBuild markup language is a subset of XML with a focus on describing a project. An advanced example of this, is our own MSBuild executable's [project here](../src/MSBuild/MSBuild.csproj).
+The MSBuild markup language is a subset of XML with a focus on describing a project. An advanced example of this is our own [MSBuild executable's project](../src/MSBuild/MSBuild.csproj).
 
-The MSBuild XML is built around representing a project's data. It uses various elements to do so:
+An MSBuild project file primarily declares a project's data. It uses various XML elements to do so:
+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used within the project.
 - [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are data enumerations, where single element is a string value with optional enumeration of key-value strings - so called `metadata`. `Items` represent project files, code files, libraries and most things that a project can depend on. Together with `Properties`, `Items` are data inputs to the build system - mostly to tasks or targets.
-- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used throughout the build.
 - [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Many tasks are defined within MSBuild itself, but tasks can also be authored by third parties by implementing the `ITask` interface.
-- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to build from.
+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to execute. Targets can be ordered relative to other targets.
 
-These attributes are defined within project files (`.csproj`, `.vbproj` etc.). The solution files (`.sln`) are not written with MSBuild XML. They are originally exclusive to Visual Studio and yet the MSBuild command-line application can parse them to find projects to build. It does so by converting the solution file to a MSBuild project file in-memory and acts upon it instead.
+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). Solution files (`.sln`) are not an MSBuild XML format. They are originally exclusive to Visual Studio, but the MSBuild command-line application can parse them to find projects to build.
 
 While the project file defines the data used for the build, the actual build instructions are generally imported from a common location through the `Import` element or [MSBuild SDKs](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk) that contain their own tasks and targets. One example that is widely used is the [`Microsoft.NET.Sdk`](https://learn.microsoft.com/dotnet/core/project-sdk/overview) from the .NET SDK.
 
 
 # Common Targets
-MSBuild has some Common Targets that adds functionalites to the build and interactictions with the XML projects. This functionality includes build management, like the creation and management of output folders and intermidiary folders, and custom task creation, etc...
+MSBuild has some Common Targets that adds baseline functionality to the build. This functionality includes build management, like the creation and management of output folders and intermediary folders, defining a project's “primary output”, implementing the [`ProjectReference` protocol](ProjectReference-Protocol.md), and so on.
 
-Visual Studio also uses common targets to change the behaviour of MSBuild through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly. Some use cases for Visual Studio also include:
-- Population of the Solution Explorer window. Which projects and files need to be added to the view of the complete solution.
-- Executing design-time builds to populate language services.
+Visual Studio also depends on the common targets to enable configuring the build through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly. Some use cases for Visual Studio also include:
+- Population of the Solution Explorer window. For each project, what files need to be added to the view of the complete solution.
+- Executing [design-time builds](https://github.com/dotnet/project-system/blob/500720852f21ac8496390827881eabe4d718c5e2/docs/design-time-builds.md) to extract more detailed information for Visual Studio components like language services.
 
 
 # MSBuild API
-The MSBuild API is .NET library with a focus on building and fetching data from MSBuild projects. It is used by Visual Studio and .NET SDK to integrate MSBuild as their project build system. This API is also available for any third parties to use.
+The MSBuild API is a .NET library that can build, fetch data from, and edit MSBuild projects. It is used by Visual Studio and the .NET SDK to integrate MSBuild as their project build system. This API is also available for any third parties to use.
 
 
 # Engine
@@ -54,7 +54,7 @@ flowchart LR
     API([API])
     end
     
-    subgraph API inputs
+    subgraph API consumers
     VS[Visual Studio] --> API
     SDK[.NET SDK] --> API
     NC[NuGet Client] --> API
@@ -67,7 +67,7 @@ flowchart LR
     EN --IPC--> WN[Worker Nodes]
     WN <--IPC--> TH[Task Host]
     L[Loggers] --> EN
-    FW[Forwarding Loggers] --> WN
+    WN --> FW[Forwarding Loggers] --> EN
 ```
 
 ## Entry points
@@ -79,9 +79,7 @@ The inputs necessary to start a build include:
  - The generated build imports (`.g.props` and `.g.targets`) from NuGet restore.
 
  ```mermaid
-flowchart TD
-    UI[User specific imports]
-    
+flowchart TD    
     UL["`User defined import logic
     _.props_ and _.targets_`"]
     
@@ -94,7 +92,6 @@ flowchart TD
     NI["`NuGet imports
     _.g.props_ and _.g.targets_`"]
 
-    UI --> PROJ
     UL --> PROJ
     IL --> PROJ
     NI --> PROJ
@@ -104,12 +101,12 @@ An example of the imported build logic is the `<Project Sdk="Microsoft.NET.Sdk">
 
 More on this in the [Restore](#restore) section below.
 
-## Evaluate operation
+## Project Evaluation
 For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).
 
-Evaluation of the build is the first step of the process. Its main objective is to collect information on the project being built. This includes checking the entry point project for imports, items, and tasks. Some API consumers, like Visual Studio project systems, extract information about which C# files, solution files and project files are relevant to a project after evaluation.
+Evaluation of a project is the first step of the process. Its main objective is to collect information on the project being built. This includes checking the entry point project for imports, items, and tasks. Some API consumers, like Visual Studio project systems, extract information about which C# files, solution files and project files are relevant to a project after evaluation.
 
-The first step of evaluation is to load the project file and the XML data it contains. There are multiple evaluation passes within the same project, each is responsible for evaluating a different type of data is required for subsequent passes. Data within the evaluation can be modified depending on the pass the build is currently executing. For example, during the pass that evaluated imports and properties, properties can be modified, but after the pass is done the properties are read-only until the execution phase.
+The first step of evaluation is to load XML project file. There are multiple evaluation passes within the same project; each is responsible for evaluating a different type of data that may be required for subsequent passes. Data within the evaluation can be modified depending on the pass the build is currently executing. For example, during the pass that evaluates imports and properties, properties can be modified, but after that pass is done the properties are read-only until the execution phase.
 
 ```mermaid
 ---
@@ -117,34 +114,34 @@ title: Evaluation passes
 ---
 flowchart LR
     PE[Project evaluation] --> 
-    EV[Environmental variables] --> 
+    EV[Environment variables] --> 
     IP[Imports and Properties 
-    outisde targets] -->
-    ID[Item definition] -->
-    IO[Items outside tagets] -->
-    UE[UsingTask elements] -->
+    outside targets] -->
+    ID[Item definitions] -->
+    IO[Items outside targets] -->
+    UE[UsingTasks] -->
     T[Targets]
 ```
 
-At this time, the restore target has run already, so all imports are files on disk and are processed as paths by the engine. Another characteristic of imports is that they are brought within the project logic, so other projects can refence the same import logic instead of having a copy of it.
+Evaluation may occur before or after NuGet restore has run. Since NuGet packages can contain build logic, the pre-restore evaluation should be used only to run restore. After restore, all imports are files on disk and are processed as paths by the engine.
 
-The evaluation stage should not have any side effect on disk, no new or deleted files. One exception is the SDK resolution phase. The built-in MSBuild SDK resolver just looks for SDKs already installed or existing on disk. But, MSBuild also has support for custom resolvers that can run arbitrary .NET Code such as referencing SDKs through a Network Share or fetching SDK packages from a remote server.
+The evaluation stage should not have any side effect on disk, no new or deleted files. One exception is the SDK resolution phase. The .NET SDK resolver looks for SDKs already installed or existing on disk. But MSBuild also has support for resolvers that can run arbitrary .NET code such as referencing SDKs through a network share or fetching SDK packages from a remote server.
 One such resolver that comes with the .NET SDK and Visual Studio is the NuGet's MSBuild SDK resolver (`Microsoft.Build.NuGetSdkResolver`) which downloads the SDK packages from NuGet repositories to local storage.
 
 ### Imports
-In MSBuild an import definition can have various forms - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports. However, when it comes to the evaluation phase in MSBuild, imports are all treated like a property plus path expansion, this includes imported NuGet packages.
+In MSBuild imports are all treated like a property plus path expansion, however they can take various forms when being defined - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports.
 
 Historically a single version of MSBuild supported multiple `ToolsVersions` that could result in differing imports for the same expression, but today an MSBuild distribution provides only the current version of `ToolsVersion` and selection between versions is expected to be done outside of MSBuild.
 
-## Execution operation
+## Project Execution
 For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).
 
-The execution phase is simply executing a request that contains a list of targets defined in the XML by the user or implicitly defined by the SDK or VS. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes. During execution, if a target that is being executed changes attributes or properties from another target, the final execution order might change due to the dependency chain changing. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).
+The execution phase starts with a request to build a list of targets defined in the project (in its own XML or an import). Those targets and their prerequisite targets will then execute. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes as it depends on more things during a build. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).
 
-Another target order issue arises when there is a project dependency. Project dependencies are dicovered during target execution, so targets can start executing in a certain order, hit a project dependency that has not been completed yet. In this case, the node that is processing the targets will be considered blocked, and will pause the current execution to start another project. Once the dependencies have been fullfilled, the original build resumes and the target execution will continue in the original order.
+Another target order issue arises when there is a project dependency. Project dependencies are expressed using the `MSBuild` task, so a project target can start executing and then hit a project dependency that has not been completed yet. In this case, the project that is processing the targets will be considered blocked, and will pause its execution (the node building it may be used to work on another project). Once the dependencies have been fullfilled, the original build can resume resume and the target execution will continue in the original order.
 
 ### Task Host
-MSBuild has an ability to run tasks out of process via the so called Task Host. That allows tasks to run in a different .NET runtime or bitness than the one used by the build engine for the build execution.
+MSBuild generally runs tasks in its own process, but has an ability to run tasks out of process via the “task host”. That allows tasks to run in a different .NET runtime or processor architecture than the one used by the build engine for the build execution.
 
 A specific task host is automatically selected when a task explicitly declares the need for a specific runtime or architecture that is different from the one used by the executing MSBuild engine. The runtime and architecture can be requested via `Runtime` and `Architecture` attributes in [`UsingTask`](https://learn.microsoft.com/visualstudio/msbuild/usingtask-element-msbuild) element defining the task or in the [`Task`](https://learn.microsoft.com/visualstudio/msbuild/task-element-msbuild) element used for task invocation.
 
@@ -162,53 +159,56 @@ There is also another Project Cache Plugin, which focuses on result cache in dis
 During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.
 
 ### Incremental Build Cache
-The build incrementality is controled by individual `Tasks` and `Targets`. Those can define their `Inputs` and `Outputs` - and if both specified, MSBuild engine will control if `Outputs` are up-to-date via checking presence of specified files and file system update timestamps (and if outputs have newer timestamps - they are considered up to date) and skip execution of such `Tasks` or/and `Targets` that are deemed up to date.
+The build incrementality is controled by individual `Tasks` and `Targets`. Targets can define their `Inputs` and `Outputs` - and if both specified, MSBuild engine will skip execution of `Targets` that are deemed up to date. Tasks may also internally implement incremental behavior.
 For this reason many `Targets` in the MSBuild SDK, that perform intermediate operations, specifies explicit `Inputs` and `Outputs` - while flushing the outputs usually into `IntermediateOutputDirectory` (AKA the 'obj' directory). This helps to follow the incrementality of the build. The `IntermediateOutputDirectory` can hence be regarded as the incremental build cache - though it's not any centraly managed cache with a single de/serialization mechanism. Each Target controls the way how it wants to create and read the intermediate files. The Targets within MSBuild SDK store only up front know data types (no type information is being stored into the cache).
 
 #### RAR Cache
-Special case of incremental build cache within the `IntermediateOutputDirectory` is a `ResolveAssemblyReference` (RAR) cache.
-[`ResolveAssemblyReference`](../../src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs) (RAR) is one of the most important tasks in the MSBuild toolset. It is responsible for obtain all references needed to build the project and resolve the full paths to the assemblies representing those references (so that the compiler task can operate on a deterministic, fully defined, input). For more information on RAR please see [the RAR documentation](../documentation/wiki/ResolveAssemblyReference.md).
-RAR stores the resolved information in the `obj` folder (pointed via `IntermediateOutputDirectory` property) in the files with configurable name with '.cache' extension. The cache content is de/serialized via MSBuild proprietary de/serialization protocol (AKA `ITranslatable`), that requires exact upfront knowledge of the types being de/serialized (means - no type information is being exchanged).
+A special case of incremental build cache within a task implementation is the `ResolveAssemblyReference` (RAR) cache.
+[`ResolveAssemblyReference`](../../src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs) (RAR) is one of the most important tasks in the MSBuild toolset. It is responsible for computing the closure of all references needed to build the project and resolving the full paths to the assemblies representing those references (so that the compiler task can operate on a fully defined input). For more information on RAR please see [the RAR documentation](../documentation/wiki/ResolveAssemblyReference.md).
+To speed subsequent runs over identical or almost-identical inputs, RAR stores assembly information in an intermediate file. The cache content is de/serialized via a custom MSBuild serialization protocol (`ITranslatable`).
 
 ## Scheduler
-The scheduler is the part of the MSBuild engine responsible for scheduling work, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a worker node (generally the in-proc node). The project's execution starts and proceeds until the whole project ends or is blocked. A project is considered blocked, when the project that it is currently building depends on another project that has not yet finished executing. Once a node is not proceeding with the current project, the scheduler then asseses if it has more work to be given to that node and assigns it.
+The scheduler is the part of the MSBuild engine responsible for scheduling work, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a worker node (generally the in-proc node). The project's execution starts and proceeds until the whole project ends or is blocked. A project is considered blocked when the project that it is currently building depends on another project that has not yet finished executing. When a node becomes free because it has completed its project or its project is blocked, the scheduler then assesses if it has more work to be given to that node and assigns it.
 
-On a project's operation end and returned result, it sends that information to the scheduler. The scheduler maintains results of all of the build's executed requests, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache.
+When a build request completes, the result is sent to the scheduler. The scheduler maintains results of all of the build's executed requests, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. This means that a project can be built only once even if referenced by many projects.
 
-If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current project, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and will eventually assign the dependency to be executed to either the current node or another one that is free.
+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current project, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and will eventually assign the dependency to be executed on either the current node or another one that is free.
 
 ```mermaid
----
-title: Build where project A depends on project B
----
 flowchart TD
-   A1[Build Request] --Project A--> S1[Scheduler]
+   A1[Build Request] --> S1[Scheduler]
+   
    S1 --> C1{Is cached}
-   C1 ---Yes1[Yes]--> Result1[Return result]
-   C1 ---No1[No]--> Build1[Build Project A]
-   Build1 --Dependency identified--> PB1[Project B]
-   PB1 --Request Build--> S1
+   C1 --Yes--> Result1[Return result]
+   C1 -- No --> Build1[Build Project]
+
+   Build1 --> HD{Has 
+   Dependency}
+   HD --No --> PF[Project Finished]
+   HD --Yes --> DI[Identify Project Dependency]
+
+   DI --Request Dependency Build--> S1
 ```
 
 ### Incremental build
 Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from build targets is persisted to disk, which becomes one big cache for MSBuild.
 
 ## Parallelism
-Parallelism for MSBuild is implemented at project level. Each project is assigned to different working nodes, which will execute the tasks at the same time, with the Scheduler organizing sequence and work division. Within project targets run sequentially, however they can have parallelism implemented independently within tasks.
+Parallelism for MSBuild is implemented at the project level. Each project is assigned to a specific worker node, and the worker nodes will execute the project build in parallel, with the Scheduler organizing sequence and work division. Within project builds, targets run sequentially and within targets, tasks run sequentially; however a task can maintain its own internal parallelism.
 
-For multi-targeted builds parallelism is a specific case with some extra work before the build. The outer build produces a list of projects to build. This list contains the same project file with a different metadata for the target framework. This list is then passed to the MSBuild execute target so it can be built in parallel.
+For multi-targeted builds parallelism between TargetFrameworks is enabled by creating distinct projects for each "inner build" from an "outer build". The outer build produces a list of projects to build. This list contains the same project file with a different global property for the target framework. This list is then passed to the MSBuild execute target so the TargetFrameworks can be built in parallel.
 
 ### Processes and nodes
 When a new build is started, MSBuild starts a process that runs some setup code and prepares itself to start a build. The process of defining the scheduler differs slightly depending on the environment the build is being executed. 
 
-In the case of a CLI build the first node becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. 
+In the case of a CLI build the process that starts the build becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. 
 
-This has been partially addressed by the long lived worker nodes feature (AKA 'nodes reuse'), where the worker nodes keeps alive and can be reused by multiple build requests. The main node (with scheduler, loggers, etc.) is still being teared down. In the case of a Visual Studio build, that uses the MSBuild API to manage the builds, this problem has been solved by having the scheduler process be separate from the Main Visual Studio (`devenv.exe`) process and keeping it very long lived. In case of CLI and experimental feature - [`MSBuild Server`](#msbuild-server) has been authored to address this gap by keeping the main node alive between build requests as well.
+This has been partially addressed by the long lived worker nodes feature (AKA 'node reuse'), where the worker nodes stay idle in the background for some time and can be reused by multiple build requests. The main node (with scheduler, loggers, etc.) is still torn down. In the case of a Visual Studio build that uses the MSBuild API to manage the builds, this problem has been solved by having the scheduler process be within the main Visual Studio process (`devenv.exe`) and keeping it very long lived. In case of CLI an experimental feature - [`MSBuild Server`](#msbuild-server) tries to address this gap by keeping the main node alive between build requests as well.
 
 
 ## IPC (Inter-Process Communication)
 In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:
- - Dealing with blocked tasks on processes: Communicating with the engine, scheduler, cache, etc...
+ - Dealing with Build Result data: Communicating with the engine, scheduler, cache, etc...
  - Communication on task execution for a task host: Task definition, task inputs, task outputs.
 
 The transport layer for messages is a [.NET named pipe](https://learn.microsoft.com/dotnet/standard/io/how-to-use-named-pipes-for-network-interprocess-communication).
@@ -220,7 +220,7 @@ A graph build changes the sequence in which MSBuild processes projects. Normally
 
 There are a couple of different modes to run graph mode in (see [the spec](../documentation/specs/static-graph.md#what-is-static-graph) for more details):
 - Standard mode (`-graph`): Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.
-- Strict / isolate mode (`-graph -isolate`): If there is a cache miss when building, the whole build is failed. This can be used when the graph of the build is fully known upfront and is not expected to change. Avoiding the need for dynamic resolution of dependencies can lead to improved scheduling and caching. Usually a first run with `-graph` is needed on initial run or on dependencies changes in order to construct/refresh the graph and to be able to consequently run in a strict mode.
+- Strict / isolate mode (`-graph -isolate`): If there is a cache miss when building, the whole build is failed.
 - Single project isolated mode: This is not directly invokable by users, instead it is used from higher order build systems to achive distributed / cached builds (in which the individual projects need to run in isolation from their dependencies - as those can be pulled from distributed cache or scheduled to run on different computation nodes).
 
 ## MSBuid Server
@@ -228,32 +228,32 @@ In normal MSBuild command-line build execution the main process exists after the
 For more information please see [the spec](../documentation/MSBuild-Server.md).
 
 # Extensibility
-MSBuild includes some extra features that are related to the build process but does not fit on the previous categories. These extensibility features are critical for the build process, but they can also be customized by third parties for their own use.
+MSBuild includes some features that are related to the build process but do not fit in the previous categories. These extensibility features are critical for the build process, but they can also be customized by third parties for their own use.
 
-## Packaging system
+## Packaging
 MSBuild interacts with external packages in almost every build. However, the MSBuild engine does not recognize external packages as third parties, and it also does not handle external dependencies. This is done by a packaging system. The supported one being NuGet. As such, it is NuGet that is responsible for finding the packages, downloading them, and providing the MSBuild engine with a package path for the build.
 
 ## Restore
-The restore operation is a built-in target, and it executed as any other target within MSBuild. The main function is to walk through the project references and `packages.config` file about all the packages that need to be restored. This process might result in new or updated files in disk, as well as new imports to the build process. The packaging system is handled by NuGet, it includes finding project references, downloading and adding packages to the right place in memory for MSBuild access.
+The restore operation is defined as a no-op in common targets, but provided by NuGet in Visual Studio and .NET SDK. It is executed as any other target within MSBuild. The restore operation walks through the project references and package references to determine information about all the packages that need to be restored. This process might result in new or updated files on disk, as well as new imports to the build process.
 
 ## Tasks
-An [msbuild task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) is a unit of executable code used by MSBuild to perform atomic build operations. There are many build-in tasks living in [`Microsoft.Build.Tasks`](../src/Tasks/README.md) package. Tasks can also be authored by third parties by implementing the `ITask` interface, please see documentation on [Task Writing](https://learn.microsoft.com/visualstudio/msbuild/task-writing).
+An [msbuild task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) is a unit of executable code used by MSBuild to perform build operations. There are many built-in tasks living in the [`Microsoft.Build.Tasks`](../src/Tasks/README.md) assembly. [Tasks can also be authored by third parties](https://learn.microsoft.com/visualstudio/msbuild/task-writing) by implementing the `ITask` interface.
 
-Implemented tasks also have additional fields that can have access to .NET functions to be executed during the task. So it is possible to do anything that is publicly available in .NET during task execution.
+Since a task can be delivered as a .NET assembly, it is possible to run arbitrary code during task execution.
 
 ### ToolTask
-Users can implement custom tasks via arbitrary .NET code, and MSBuild provides helper classes for common use cases like "build a command line for and then run a command-line tool".
+`ToolTask` is a widely-used helper class for the use case "build a command line for and then run a command-line tool".
 
 ## Diagnosability / Loggers
-Diagnosability within MSBuild went through some changes. Before we had a debugger in additional to basic logs, where you could step through the XML during the build and debug. This was discarded in favor of a log focused approach, where MSBuild has a more robust logging system that contains more data to identify what is happening during a build.
+Current diagnosability within MSBuild follows a log focused approach, where MSBuild has a more robust logging system that contains more data to identify what is happening during a build.
 
 ### General Loggers
 Logging within MSBuild consists of various integrated and third-party loggers. Both use the [`ILogger`](https://learn.microsoft.com/dotnet/api/microsoft.build.framework.ilogger) API. Built-in loggers include the Binary Logger which produces compressed `.binlog` files, the Console and Terminal loggers for interactive output, and a Text Log. Third party loggers  receive events through `ILogger`, and multiple loggers can be connected to a single build.
 
-Third-party loggers must be specified before the build begins. Because of this, build logic (and NuGet) is not able to manipulate loggers.
+Loggers must be specified before the build begins. Because of this, build logic (and NuGet) is not able to manipulate loggers.
 
 ### Binary logger
-The Binary Logger, also called binlog, is a structured log that captures all the events within a build as well as files that are critical to the build. To read a binlog, the MSBuild executable (`MSBuild.exe` in Windows, and `msbuild` in unix) can replay the events through arbitrary loggers, and third-party tooling like the [Structured Log Viewer](https://msbuildlog.com) can also read binlogs, but it is not officially supported by the MSBuild team.
+The Binary Logger, also called binlog, is a structured log that captures all the events within a build as well as files that are critical to the build. To read a binlog, the MSBuild CLI can replay the events through arbitrary loggers, and third-party tooling like the [Structured Log Viewer](https://msbuildlog.com) can also read binlogs.
 
 
 ## Project result cache plugin
@@ -266,7 +266,7 @@ BuildCheck is new MSBuild extensible and configurable linting/diagnostic feature
 For more information please see [the spec](../documentation/specs/BuildCheck/BuildCheck.md).
 
 ## Resolvers
-There are a few elements within the MSBuild XML that indicate that a call to the .NET SDK is necessary. When such interaction is necessary for a project build, the first thing that needs to be done is to figure out where the SDK is installed so MSBuild can access the content. This is solved by resolvers, which look for the SDK version that was specified, or gets the latest version.
+There are a few elements within the MSBuild XML that indicate that a call to the .NET SDK is necessary. When such interaction is necessary for a project build, the first thing that needs to be done is to figure out where the SDK is installed so MSBuild can access the content. This is solved by resolvers, which look for the SDK version that was specified, or gets the latest version by looking for them on the folder adjacent to where MSBuild is executing from.
 
 To read more about SDK resolver you can check the [Microsoft Learn page](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk#how-project-sdks-are-resolved), or see the [spec documentation](specs/sdk-resolvers-algorithm.md).
 
@@ -276,4 +276,4 @@ MSBuild has a few telemetry points, mostly through the .NET SDK. It is implement
 Visual Studio telemetry was removed once MSBuild went open source, and it was never added again.
 
 ## FileTracker
-In order to automatically detect task inputs and outputs, MSBuild can intercept Windows I/O API calls to track the dependencies. A [FileTracker](https://github.com/dotnet/msbuild/blob/main/src/Utilities/TrackedDependencies/FileTracker.cs) utility is used to accomplish this. For more information please see [the spec](../documentation/specs/static-graph.md#detours).
+In order to automatically detect task inputs and outputs, MSBuild can intercept Windows I/O API calls to track the dependencies. A [FileTracker](https://github.com/dotnet/msbuild/blob/main/src/Utilities/TrackedDependencies/FileTracker.cs) utility is used to accomplish this. It uses [Detours](https://github.com/microsoft/detours) to inject logging code when a tracked application performs filesystem operations.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 9d90c75075e..ef38fa5942e 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -28,7 +28,6 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Convert.ToString during a property evaluation uses the InvariantCulture for all types](https://github.com/dotnet/msbuild/pull/9874)
 - [Fix oversharing of build results in ResultsCache](https://github.com/dotnet/msbuild/pull/9987)
 - [Add ParameterName and PropertyName to TaskParameterEventArgs](https://github.com/dotnet/msbuild/pull/10130)
-- [Emit eval props if requested by any sink](https://github.com/dotnet/msbuild/pull/10243)
 
 ### 17.10
 - [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index c5c90d7a549..faf9f3f8ccf 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -82,7 +82,7 @@ public BuildManager_Tests(ITestOutputHelper output)
                 EnableNodeReuse = false
             };
             _buildManager = new BuildManager();
-            _projectCollection = new ProjectCollection(globalProperties: null, _parameters.Loggers, ToolsetDefinitionLocations.Default);
+            _projectCollection = new ProjectCollection();
 
             _env = TestEnvironment.Create(output);
             _inProcEnvCheckTransientEnvironmentVariable = _env.SetEnvironmentVariable("MSBUILDINPROCENVCHECK", "1");
@@ -137,8 +137,8 @@ public void SimpleBuild()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
+            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -254,8 +254,8 @@ public void SimpleGraphBuild()
             _logger.AssertLogContains("[success]");
             _logger.ProjectStartedEvents.Count.ShouldBe(1);
 
-            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
+            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
 
             properties.TryGetValue("InitialProperty1", out string propertyValue).ShouldBeTrue();
             propertyValue.ShouldBe("InitialProperty1", StringCompareShould.IgnoreCase);
@@ -571,8 +571,8 @@ public void InProcForwardPropertiesFromChild()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
+            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -611,8 +611,8 @@ public void InProcMsBuildForwardAllPropertiesFromChild()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
+            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -655,8 +655,8 @@ public void MsBuildForwardAllPropertiesFromChildLaunchChildNode()
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
 
-            ProjectEvaluationFinishedEventArgs evalFinishedEvent = _logger.EvaluationFinishedEvents[0];
-            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(evalFinishedEvent.Properties);
+            ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
+            Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
 
             Assert.True(properties.TryGetValue("InitialProperty1", out string propertyValue));
             Assert.Equal("InitialProperty1", propertyValue);
@@ -704,15 +704,7 @@ public void OutOfProcNodeForwardCertainproperties()
             var data = new BuildRequestData(project.FullPath, new Dictionary<string, string>(),
                 MSBuildDefaultToolsVersion, Array.Empty<string>(), null);
 
-            // We need to recreate build parameters to ensure proper capturing of newly set environment variables
-            BuildParameters parameters = new BuildParameters
-            {
-                ShutdownInProcNodeOnBuildFinish = true,
-                Loggers = new ILogger[] { _logger },
-                EnableNodeReuse = false
-            };
-
-            BuildResult result = _buildManager.Build(parameters, data);
+            BuildResult result = _buildManager.Build(_parameters, data);
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
             _logger.AssertLogContains("[success]");
             Assert.Single(_logger.ProjectStartedEvents);
@@ -768,21 +760,11 @@ public void OutOfProcNodeForwardCertainpropertiesAlsoGetResultsFromCache()
             _env.SetEnvironmentVariable("MsBuildForwardPropertiesFromChild", "InitialProperty3;IAMNOTREAL");
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
-            _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "0");
-
             var project = CreateProject(contents, null, _projectCollection, false);
             var data = new BuildRequestData(project.FullPath, new Dictionary<string, string>(),
                 MSBuildDefaultToolsVersion, Array.Empty<string>(), null);
 
-            // We need to recreate build parameters to ensure proper capturing of newly set environment variables
-            BuildParameters parameters = new BuildParameters
-            {
-                ShutdownInProcNodeOnBuildFinish = true,
-                Loggers = new ILogger[] { _logger },
-                EnableNodeReuse = false
-            };
-
-            BuildResult result = _buildManager.Build(parameters, data);
+            BuildResult result = _buildManager.Build(_parameters, data);
             Assert.Equal(BuildResultCode.Success, result.OverallResult);
             _logger.AssertLogContains("[success]");
             Assert.Equal(3, _logger.ProjectStartedEvents.Count);
@@ -803,8 +785,7 @@ public void OutOfProcNodeForwardCertainpropertiesAlsoGetResultsFromCache()
             Assert.Equal("InitialProperty3", propertyValue);
 
             projectStartedEvent = _logger.ProjectStartedEvents[2];
-            properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
-            (properties == null || properties.Count == 0).ShouldBeTrue();
+            Assert.Null(projectStartedEvent.Properties);
         }
 
         /// <summary>
@@ -841,7 +822,7 @@ public void ForwardNoPropertiesLaunchChildNode()
 
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
-            (properties == null || properties.Count == 0).ShouldBeTrue();
+            Assert.Null(properties);
         }
 
         /// <summary>
@@ -938,7 +919,7 @@ public void ForwardNoPropertiesLaunchChildNodeDefault()
 
             ProjectStartedEventArgs projectStartedEvent = _logger.ProjectStartedEvents[0];
             Dictionary<string, string> properties = ExtractProjectStartedPropertyList(projectStartedEvent.Properties);
-            (properties == null || properties.Count == 0).ShouldBeTrue();
+            Assert.Null(properties);
         }
 
         /// <summary>
@@ -3494,11 +3475,9 @@ private static string BuildAndCheckCache(BuildManager localBuildManager, IEnumer
         /// </summary>
         private static Dictionary<string, string> ExtractProjectStartedPropertyList(IEnumerable properties)
         {
-            Dictionary<string, string> propertiesLookup = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            Internal.Utilities.EnumerateProperties(properties, propertiesLookup,
-                static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
-
-            return propertiesLookup;
+            // Gather a sorted list of all the properties.
+            return properties?.Cast<DictionaryEntry>()
+                .ToDictionary(prop => (string)prop.Key, prop => (string)prop.Value, StringComparer.OrdinalIgnoreCase);
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index 027922a1c8a..16adcc0eb2f 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -222,21 +222,14 @@ public bool IncludeEvaluationProfile
             set { }
         }
 
-        /// <inheritdoc cref="ILoggingService.SetIncludeEvaluationPropertiesAndItemsInEvents"/>
-        public void SetIncludeEvaluationPropertiesAndItemsInEvents(bool inProjectStartedEvent,
-            bool inEvaluationFinishedEvent)
-        { }
-
-        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent"/>
-        public bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent
-        {
-            get => false;
-        }
-
-        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent"/>
-        public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
+        /// <summary>
+        /// Log properties and items on ProjectEvaluationFinishedEventArgs
+        /// instead of ProjectStartedEventArgs.
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
         {
             get => false;
+            set { }
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index c1fdc67f6a5..10859bb9ce5 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -277,7 +277,7 @@ public void ErrorMessageWithMultiplePropertiesInMessage(bool includeEvaluationPr
 
             if (includeEvaluationPropertiesAndItems)
             {
-                pc.Collection.LoggingService.SetIncludeEvaluationPropertiesAndItemsInEvents(inProjectStartedEvent: false, inEvaluationFinishedEvent: true);
+                pc.Collection.LoggingService.IncludeEvaluationPropertiesAndItems = true;
             }
 
             var project = env.CreateTestProjectWithFiles(@"
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index bbd5aa4f333..b574216a0a0 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2757,8 +2757,7 @@ private NodeConfiguration GetNodeConfiguration()
                 , new LoggingNodeConfiguration(
                     loggingService.IncludeEvaluationMetaprojects,
                     loggingService.IncludeEvaluationProfile,
-                    loggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent,
-                    loggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent,
+                    loggingService.IncludeEvaluationPropertiesAndItems,
                     loggingService.IncludeTaskInputs));
             }
 
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 104dac56f6f..ecbf7b8026b 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -206,24 +206,12 @@ bool IncludeEvaluationProfile
 
         /// <summary>
         /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
-        /// or/and <see cref="ProjectStartedEventArgs"/>?
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
         /// </summary>
-        void SetIncludeEvaluationPropertiesAndItemsInEvents(bool inProjectStartedEvent, bool inEvaluationFinishedEvent);
-
-        /// <summary>
-        /// Indicates whether properties and items should be logged on <see cref="ProjectStartedEventArgs"/>.
-        /// </summary>
-        bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent
-        {
-            get;
-        }
-
-        /// <summary>
-        /// Indicates whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>.
-        /// </summary>
-        bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
+        bool IncludeEvaluationPropertiesAndItems
         {
             get;
+            set;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index a3d5e1d18c7..f547084425d 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -201,6 +201,12 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler
         /// </summary>
         private bool? _includeEvaluationProfile;
 
+        /// <summary>
+        /// Whether properties and items should be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>.
+        /// </summary>
+        private bool? _includeEvaluationPropertiesAndItems;
+
         /// <summary>
         /// Whether to include task inputs in task events.
         /// </summary>
@@ -540,77 +546,33 @@ public bool IncludeTaskInputs
             set => _includeTaskInputs = value;
         }
 
-        /// <inheritdoc cref="ILoggingService.SetIncludeEvaluationPropertiesAndItemsInEvents"/>
-        public void SetIncludeEvaluationPropertiesAndItemsInEvents(bool inProjectStartedEvent, bool inEvaluationFinishedEvent)
-        {
-            _evalDataBehaviorSet = true;
-            IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = inEvaluationFinishedEvent;
-            IncludeEvaluationPropertiesAndItemsInProjectStartedEvent = inProjectStartedEvent;
-        }
-
-        private bool _evalDataBehaviorSet;
-        private bool _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
-        private bool _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
-        private void InferEvalDataBehavior()
+        /// <summary>
+        /// Should properties and items be logged on <see cref="ProjectEvaluationFinishedEventArgs"/>
+        /// instead of <see cref="ProjectStartedEventArgs"/>?
+        /// </summary>
+        public bool IncludeEvaluationPropertiesAndItems
         {
-            if (_evalDataBehaviorSet)
-            {
-                return;
-            }
-            // Set this right away - to prevent SO exception in case of any future refactoring
-            //  that would refer to the IncludeEvaluation... properties here
-            _evalDataBehaviorSet = true;
-
-            bool? escapeHatch = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation;
-            if (escapeHatch.HasValue)
-            {
-                IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = escapeHatch.Value;
-                IncludeEvaluationPropertiesAndItemsInProjectStartedEvent = !escapeHatch.Value;
-            }
-            else
+            get
             {
-                var sinks = _eventSinkDictionary.Values.OfType<EventSourceSink>().ToList();
-
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
-                {
-                    // If any logger requested the data - we need to emit them
-                    IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent =
-                        sinks.Any(sink => sink.IncludeEvaluationPropertiesAndItems);
-                    // If any logger didn't request the data - hence it's likely legacy logger
-                    //  - we need to populate the data in legacy way
-                    IncludeEvaluationPropertiesAndItemsInProjectStartedEvent =
-                        sinks.Any(sink => !sink.IncludeEvaluationPropertiesAndItems);
-                }
-                else
+                if (_includeEvaluationPropertiesAndItems == null)
                 {
-                    bool allSinksIncludeEvalData = sinks.Any() && sinks.All(sink => sink.IncludeEvaluationPropertiesAndItems);
-
-                    IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = allSinksIncludeEvalData;
-                    IncludeEvaluationPropertiesAndItemsInProjectStartedEvent = !allSinksIncludeEvalData;
+                    var escapeHatch = Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation;
+                    if (escapeHatch.HasValue)
+                    {
+                        _includeEvaluationPropertiesAndItems = escapeHatch.Value;
+                    }
+                    else
+                    {
+                        var sinks = _eventSinkDictionary.Values.OfType<EventSourceSink>();
+                        // .All() on an empty list defaults to true, we want to default to false
+                        _includeEvaluationPropertiesAndItems = sinks.Any() && sinks.All(sink => sink.IncludeEvaluationPropertiesAndItems);
+                    }
                 }
-            }
-        }
 
-        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent"/>
-        public bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent
-        {
-            get
-            {
-                InferEvalDataBehavior();
-                return _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
+                return _includeEvaluationPropertiesAndItems ?? false;
             }
-            private set => _includeEvaluationPropertiesAndItemsInProjectStartedEvent = value;
-        }
 
-        /// <inheritdoc cref="ILoggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent"/>
-        public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent
-        {
-            get
-            {
-                InferEvalDataBehavior();
-                return _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
-            }
-            private set => _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = value;
+            set => _includeEvaluationPropertiesAndItems = value;
         }
 
         /// <summary>
@@ -652,7 +614,6 @@ public ICollection<string> GetWarningsNotAsErrors(BuildEventContext context)
             return GetWarningsForProject(context, _warningsNotAsErrorsByProject, WarningsNotAsErrors);
         }
 
-
         /// <summary>
         /// Returns a collection of warnings to be demoted to messages for the specified build context.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 06614c42125..49a3cd48fb7 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -132,7 +132,7 @@ private static BuildEventContext CreateInitialContext(
 
             // If we are only logging critical events lets not pass back the items or properties
             if (!loggingService.OnlyLogCriticalEvents &&
-                loggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent &&
+                !loggingService.IncludeEvaluationPropertiesAndItems &&
                 (!loggingService.RunningOnRemoteNode || loggingService.SerializeAllProperties))
             {
                 if (projectProperties is null)
@@ -152,7 +152,7 @@ private static BuildEventContext CreateInitialContext(
             }
 
             if (projectProperties != null &&
-                loggingService.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent &&
+                !loggingService.IncludeEvaluationPropertiesAndItems &&
                 propertiesToSerialize?.Length > 0 &&
                 !loggingService.SerializeAllProperties)
             {
diff --git a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
index 8c6315338da..1bae5efa98b 100644
--- a/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/LoggingNodeConfiguration.cs
@@ -9,14 +9,12 @@ internal sealed class LoggingNodeConfiguration : ITranslatable
     {
         private bool _includeEvaluationMetaprojects;
         private bool _includeEvaluationProfiles;
-        private bool _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
-        private bool _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
+        private bool _includeEvaluationPropertiesAndItems;
         private bool _includeTaskInputs;
 
         public bool IncludeEvaluationMetaprojects => _includeEvaluationMetaprojects;
         public bool IncludeEvaluationProfiles => _includeEvaluationProfiles;
-        public bool IncludeEvaluationPropertiesAndItemsInProjectStartedEvent => _includeEvaluationPropertiesAndItemsInProjectStartedEvent;
-        public bool IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent => _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
+        public bool IncludeEvaluationPropertiesAndItems => _includeEvaluationPropertiesAndItems;
         public bool IncludeTaskInputs => _includeTaskInputs;
 
         public LoggingNodeConfiguration()
@@ -26,14 +24,12 @@ public LoggingNodeConfiguration()
         public LoggingNodeConfiguration(
             bool includeEvaluationMetaprojects,
             bool includeEvaluationProfiles,
-            bool includeEvaluationPropertiesAndItemsInProjectStartedEvent,
-            bool includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent,
+            bool includeEvaluationPropertiesAndItems,
             bool includeTaskInputs)
         {
             _includeEvaluationMetaprojects = includeEvaluationMetaprojects;
             _includeEvaluationProfiles = includeEvaluationProfiles;
-            _includeEvaluationPropertiesAndItemsInProjectStartedEvent = includeEvaluationPropertiesAndItemsInProjectStartedEvent;
-            _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent = includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent;
+            _includeEvaluationPropertiesAndItems = includeEvaluationPropertiesAndItems;
             _includeTaskInputs = includeTaskInputs;
         }
 
@@ -41,8 +37,7 @@ void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _includeEvaluationMetaprojects);
             translator.Translate(ref _includeEvaluationProfiles);
-            translator.Translate(ref _includeEvaluationPropertiesAndItemsInProjectStartedEvent);
-            translator.Translate(ref _includeEvaluationPropertiesAndItemsInEvaluationFinishedEvent);
+            translator.Translate(ref _includeEvaluationPropertiesAndItems);
             translator.Translate(ref _includeTaskInputs);
         }
     }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index af13beb079d..14706fc57cd 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -779,12 +779,9 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
                 _loggingService.IncludeTaskInputs = true;
             }
 
-            if (configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent)
+            if (configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItems)
             {
-                _loggingService.SetIncludeEvaluationPropertiesAndItemsInEvents(
-                    configuration.LoggingNodeConfiguration.IncludeEvaluationPropertiesAndItemsInProjectStartedEvent,
-                    configuration.LoggingNodeConfiguration
-                        .IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent);
+                _loggingService.IncludeEvaluationPropertiesAndItems = true;
             }
 
             try
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index a6443309645..641758faf4b 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -5,9 +5,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
index 84bfd2d64a0..6c2465e1578 100644
--- a/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
+++ b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
@@ -13,15 +13,17 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 // https://github.com/dotnet/msbuild/issues/9633
 // Acquisition
 //  define the data that will be passed to the acquisition module (and remoted if needed)
-internal class CheckAcquisitionData(string assemblyPath)
+internal class AnalyzerAcquisitionData(string assemblyPath, string projectPath)
 {
     public string AssemblyPath { get; init; } = assemblyPath;
+
+    public string ProjectPath { get; init; } = projectPath;
 }
 
 internal static class CheckAcquisitionDataExtensions
 {
-    public static CheckAcquisitionData ToCheckAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
-        new(eventArgs.AcquisitionPath);
+    public static AnalyzerAcquisitionData ToAnalyzerAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
+        new(eventArgs.AcquisitionPath, eventArgs.ProjectPath);
 
-    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this CheckAcquisitionData data) => new(data.AssemblyPath);
+    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this AnalyzerAcquisitionData data) => new(data.AssemblyPath, data.ProjectPath);
 }
diff --git a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index 9fdaf5af0e0..aa668e5fb6c 100644
--- a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -46,8 +46,9 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         }
 
         string? binPath, objPath;
-        context.Data.EvaluatedProperties.TryGetPathValue("OutputPath", out binPath);
-        context.Data.EvaluatedProperties.TryGetPathValue("IntermediateOutputPath", out objPath);
+
+        context.Data.EvaluatedProperties.TryGetValue("OutputPath", out binPath);
+        context.Data.EvaluatedProperties.TryGetValue("IntermediateOutputPath", out objPath);
 
         string? absoluteBinPath = CheckAndAddFullOutputPath(binPath, context);
         // Check objPath only if it is different from binPath
@@ -76,7 +77,7 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         }
 
         // Normalize the path to avoid false negatives due to different path representations.
-        path = Path.GetFullPath(path);
+        path = FileUtilities.NormalizePath(path);
 
         if (_projectsPerOutputPath.TryGetValue(path!, out string? conflictingProject))
         {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 3447cb8f875..a72bc47521d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -6,6 +6,7 @@
 using System.Linq;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
@@ -15,9 +16,9 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// </summary>
 internal sealed class BuildCheckCentralContext
 {
-    private readonly ConfigurationProvider _configurationProvider;
+    private readonly IConfigurationProvider _configurationProvider;
 
-    internal BuildCheckCentralContext(ConfigurationProvider configurationProvider)
+    internal BuildCheckCentralContext(IConfigurationProvider configurationProvider)
         => _configurationProvider = configurationProvider;
 
     private record CallbackRegistry(
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 5ab0bb84644..1f93090036a 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -12,6 +12,14 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
+/// <summary>
+/// Central logger for the build check infrastructure.
+/// Receives events from the <see cref="BuildCheckForwardingLogger"/>.
+/// Processes the events and forwards them to the <see cref="IBuildCheckManager"/> and registered analyzers.
+/// </summary>
+/// <remarks>
+/// Ensure that the consuming events are in sync with <see cref="BuildCheckForwardingLogger"/>.
+/// </remarks>
 internal sealed class BuildCheckConnectorLogger : ILogger
 {
     private readonly BuildCheckBuildEventHandler _eventHandler;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
index cef7f60b980..365785b319e 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
@@ -2,8 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Threading;
-using Microsoft.Build.Experimental.BuildCheck;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
index 6e8f969b544..02808f434a5 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
@@ -7,13 +7,62 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Framework;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.BuildCheckManagerProvider;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// Forwarding logger for the build check infrastructure.
-/// For now we jus want to forward all events, while disable verbose logging of tasks.
+/// For now we just want to forward all events that are needed for BuildCheckConnectorLogger and filter out all other.
+/// If the custom analyzer is detected, starts to unconditionally forward all events.
 /// In the future we may need more specific behavior.
 /// </summary>
-internal class BuildCheckForwardingLogger : CentralForwardingLogger
-{ }
+/// <remarks>
+/// Ensure that events filtering is in sync with <see cref="BuildCheckConnectorLogger"/>
+/// </remarks>
+internal class BuildCheckForwardingLogger : IForwardingLogger
+{
+    public IEventRedirector? BuildEventRedirector { get; set; }
+
+    public int NodeId { get; set; }
+
+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Quiet; set { return; } }
+
+    public string? Parameters { get; set; }
+
+    /// <summary>
+    /// Set of events to be forwarded to  <see cref="BuildCheckConnectorLogger"/>
+    /// </summary>
+    private HashSet<Type> _eventsToForward = new HashSet<Type>
+    {
+        typeof(EnvironmentVariableReadEventArgs),
+        typeof(ProjectEvaluationFinishedEventArgs),
+        typeof(ProjectEvaluationStartedEventArgs),
+        typeof(ProjectStartedEventArgs),
+        typeof(ProjectFinishedEventArgs),
+        typeof(BuildCheckTracingEventArgs),
+        typeof(BuildCheckAcquisitionEventArgs),
+        typeof(TaskStartedEventArgs),
+        typeof(TaskFinishedEventArgs),
+        typeof(TaskParameterEventArgs)
+    };
+
+    public void Initialize(IEventSource eventSource, int nodeCount) => Initialize(eventSource);
+
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+    }
+
+    public void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent)
+    {
+        if (_eventsToForward.Contains(buildEvent.GetType()))
+        {
+            BuildEventRedirector?.ForwardEvent(buildEvent);
+        }
+    }
+
+    public void Shutdown() { }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index fec3ebc7f26..dc9b4c593c6 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -4,9 +4,9 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Linq;
 using System.Threading;
+using System.Diagnostics;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
@@ -15,6 +15,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
@@ -33,6 +34,7 @@ internal sealed class BuildCheckManagerProvider : IBuildCheckManagerProvider
     public IBuildCheckManager Instance => GlobalInstance;
 
     public IBuildEngineDataRouter BuildEngineDataRouter => (IBuildEngineDataRouter)GlobalInstance;
+
     public static IBuildEngineDataRouter? GlobalBuildEngineDataRouter => (IBuildEngineDataRouter?)s_globalInstance;
 
     internal static IBuildComponent CreateComponent(BuildComponentType type)
@@ -68,7 +70,7 @@ public void InitializeComponent(IBuildComponentHost host)
     internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRouter
     {
         private readonly TracingReporter _tracingReporter = new TracingReporter();
-        private readonly ConfigurationProvider _configurationProvider = new ConfigurationProvider();
+        private readonly IConfigurationProvider _configurationProvider = new ConfigurationProvider();
         private readonly BuildCheckCentralContext _buildCheckCentralContext;
         private readonly List<BuildExecutionCheckFactoryContext> _checkRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
@@ -113,7 +115,7 @@ public void ProcessCheckAcquisition(
                 var checkFactories = _acquisitionModule.CreateBuildExecutionCheckFactories(acquisitionData, checkContext);
                 if (checkFactories.Count != 0)
                 {
-                    RegisterCustomCheck(BuildCheckDataSource.EventArgs, checkFactories, checkContext);
+                    RegisterCustomAnalyzer(acquisitionData.ProjectPath, BuildCheckDataSource.EventArgs, analyzersFactories, analysisContext);
                 }
                 else
                 {
@@ -165,37 +167,16 @@ private void RegisterBuiltInChecks(BuildCheckDataSource buildCheckDataSource)
             }
         }
 
-        /// <summary>
-        /// To be used by acquisition module.
-        /// Registers the custom checks, the construction of checks is deferred until the first using project is encountered.
-        /// </summary>
-        internal void RegisterCustomChecks(
-            BuildCheckDataSource buildCheckDataSource,
-            IEnumerable<BuildExecutionCheckFactory> factories,
-            string[] ruleIds,
-            bool defaultEnablement,
-            ICheckContext checkContext)
-        {
-            if (_enabledDataSources[(int)buildCheckDataSource])
-            {
-                foreach (BuildExecutionCheckFactory factory in factories)
-                {
-                    _checkRegistry.Add(new BuildExecutionCheckFactoryContext(factory, ruleIds, defaultEnablement));
-
-                    var instance = factory();
-                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckSuccessfulAcquisition", instance.FriendlyName);
-                }
-            }
-        }
-
         /// <summary>
         /// To be used by acquisition module
         /// Registers the custom check, the construction of check is needed during registration.
         /// </summary>
+        /// <param name="projectPath">The project path is used for the correct .editorconfig resolution.</param>
         /// <param name="buildCheckDataSource">Represents different data sources used in build check operations.</param>
-        /// <param name="factories">A collection of build check factories for rules instantiation.</param>
-        /// <param name="checkContext">The logging context of the build event.</param>
-        internal void RegisterCustomCheck(
+        /// <param name="factories">A collection of build analyzer factories for rules instantiation.</param>
+        /// <param name="analysisContext">The logging context of the build event.</param>
+        internal void RegisterCustomAnalyzer(
+            string projectPath,
             BuildCheckDataSource buildCheckDataSource,
             IEnumerable<BuildExecutionCheckFactory> factories,
             ICheckContext checkContext)
@@ -205,11 +186,17 @@ internal void RegisterCustomCheck(
                 foreach (var factory in factories)
                 {
                     var instance = factory();
-                    _checkRegistry.Add(new BuildExecutionCheckFactoryContext(
+                    var analyzerFactoryContext = new BuildAnalyzerFactoryContext(
                         factory,
                         instance.SupportedRules.Select(r => r.Id).ToArray(),
-                        instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
-                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckSuccessfulAcquisition", instance.FriendlyName);
+                        instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true));
+
+                    if (analyzerFactoryContext != null)
+                    {
+                        _analyzersRegistry.Add(analyzerFactoryContext);
+                        SetupSingleAnalyzer(analyzerFactoryContext, projectPath);
+                        analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
+                    }
                 }
             }
         }
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index 741019678b0..c8e71cb24d4 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -8,10 +8,11 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using System.Collections.Concurrent;
 using Microsoft.Build.Experimental.BuildCheck.Utilities;
+using Microsoft.Build.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal sealed class ConfigurationProvider
+internal sealed class ConfigurationProvider : IConfigurationProvider
 {
     private readonly EditorConfigParser _editorConfigParser = new EditorConfigParser();
 
@@ -84,7 +85,7 @@ public CustomConfigurationData GetCustomConfiguration(string projectFullPath, st
     /// <param name="ruleId"></param>
     /// <throws><see cref="BuildCheckConfigurationException"/> If CustomConfigurationData differs in a build for a same ruleId</throws>
     /// <returns></returns>
-    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
+    public void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
     {
         var configuration = GetCustomConfiguration(projectFullPath, ruleId);
         VerifyCustomConfigurationEquality(ruleId, configuration);
@@ -101,12 +102,12 @@ internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurati
         }
     }
 
-    internal BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(
+    public BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
         string projectFullPath,
         BuildExecutionCheck check)
         => FillConfiguration(projectFullPath, check.SupportedRules, GetMergedConfiguration);
 
-    internal BuildExecutionCheckConfiguration[] GetUserConfigurations(
+    public BuildAnalyzerConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
@@ -122,9 +123,9 @@ public CustomConfigurationData[] GetCustomConfigurations(
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    internal BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(
-        BuildExecutionCheckConfiguration[] userConfigs,
-        BuildExecutionCheck check)
+    public BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
+        BuildAnalyzerConfiguration[] userConfigs,
+        BuildAnalyzer analyzer)
     {
         var configurations = new BuildExecutionCheckConfigurationEffective[userConfigs.Length];
 
diff --git a/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
new file mode 100644
index 00000000000..b3d942ce93a
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
@@ -0,0 +1,28 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+internal interface IConfigurationProvider
+{
+    BuildAnalyzerConfiguration[] GetUserConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds);
+
+    BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
+        string projectFullPath,
+        BuildAnalyzer analyzer);
+
+    BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
+        BuildAnalyzerConfiguration[] userConfigs,
+        BuildAnalyzer analyzer);
+
+    CustomConfigurationData[] GetCustomConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds);
+
+    void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId);
+}
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 8e0f9318b89..33513cc27ec 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -343,7 +343,7 @@ internal static void Evaluate(
                 IEnumerable properties = null;
                 IEnumerable items = null;
 
-                if (evaluator._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItemsInEvaluationFinishedEvent)
+                if (evaluator._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
                 {
                     globalProperties = evaluator._data.GlobalPropertiesDictionary;
                     properties = Traits.LogAllEnvironmentVariables ? evaluator._data.Properties : evaluator.FilterOutEnvironmentDerivedProperties(evaluator._data.Properties);
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index c0158021881..6d2b14dfdc6 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -3569,8 +3569,14 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         try
                         {
                             // First attempt to recognize some well-known functions to avoid binding
-                            // and potential first-chance MissingMethodExceptions
+                            // and potential first-chance MissingMethodExceptions.
                             wellKnownFunctionSuccess = TryExecuteWellKnownFunction(out functionResult, objectInstance, args);
+
+                            if (!wellKnownFunctionSuccess)
+                            {
+                                // Some well-known functions need evaluated value from properties.
+                                wellKnownFunctionSuccess = TryExecuteWellKnownFunctionWithPropertiesParam(properties, out functionResult, objectInstance, args);
+                            }
                         }
                         // we need to preserve the same behavior on exceptions as the actual binder
                         catch (Exception ex)
@@ -3667,6 +3673,27 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                 }
             }
 
+            private bool TryExecuteWellKnownFunctionWithPropertiesParam(IPropertyProvider<T> properties, out object returnVal, object objectInstance, object[] args)
+            {
+                returnVal = null;
+
+                if (_receiverType == typeof(IntrinsicFunctions))
+                {
+                    if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
+                    {
+                        string projectPath = properties.GetProperty("MSBuildProjectFullPath")?.EvaluatedValue ?? string.Empty;
+                        ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
+                        if (TryGetArg(args, out string arg0))
+                        {
+                            returnVal = IntrinsicFunctions.RegisterBuildCheck(projectPath, arg0, _loggingContext);
+                            return true;
+                        }
+                    }
+                }
+
+                return false;
+            }
+
             /// <summary>
             /// Shortcut to avoid calling into binding if we recognize some most common functions.
             /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
@@ -3932,16 +3959,6 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                     }
                     else if (_receiverType == typeof(IntrinsicFunctions))
                     {
-                        if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
-                        {
-                            ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.RegisterBuildCheck(arg0, _loggingContext);
-                                return true;
-                            }
-                        }
-
                         if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.EnsureTrailingSlash), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArg(args, out string arg0))
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index bf4e56457fe..4a4a183d24f 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -693,12 +693,12 @@ public static string GetMSBuildExtensionsPath()
 
         public static bool IsRunningFromVisualStudio() => BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio;
 
-        public static bool RegisterBuildCheck(string pathToAssembly, LoggingContext loggingContext)
+        public static bool RegisterBuildCheck(string projectPath, string pathToAssembly, LoggingContext loggingContext)
         {
             pathToAssembly = FileUtilities.GetFullPathNoThrow(pathToAssembly);
             if (File.Exists(pathToAssembly))
             {
-                loggingContext.LogBuildEvent(new BuildCheckAcquisitionEventArgs(pathToAssembly));
+                loggingContext.LogBuildEvent(new BuildCheckAcquisitionEventArgs(pathToAssembly, projectPath));
 
                 return true;
             }
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
index 6759d783aae..69a919d4e7f 100644
--- a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -5,6 +5,7 @@
 using System.Linq;
 using System.Reflection;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
@@ -37,10 +38,11 @@ public BuildCheckManagerTests(ITestOutputHelper output)
     [InlineData(false, new[] { "Failed to register the custom check: 'DummyPath'." })]
     public void ProcessCheckAcquisitionTest(bool isCheckRuleExist, string[] expectedMessages)
     {
-        MockBuildCheckAcquisition(isCheckRuleExist);
+        MockConfigurationProvider();
+        MockBuildCheckAcquisition(isAnalyzerRuleExist);
         MockEnabledDataSourcesDefinition();
 
-        _testedInstance.ProcessCheckAcquisition(new CheckAcquisitionData("DummyPath"), new CheckLoggingContext(_loggingService, new BuildEventContext(1, 2, 3, 4, 5, 6, 7)));
+        _testedInstance.ProcessAnalyzerAcquisition(new AnalyzerAcquisitionData("DummyPath", "ProjectPath"), new AnalysisLoggingContext(_loggingService, new BuildEventContext(1, 2, 3, 4, 5, 6, 7)));
 
         _logger.AllBuildEvents.Where(be => be.GetType() == typeof(BuildMessageEventArgs)).Select(be => be.Message).ToArray()
             .ShouldBeEquivalentTo(expectedMessages);
@@ -50,6 +52,8 @@ public void ProcessCheckAcquisitionTest(bool isCheckRuleExist, string[] expected
 
     private void MockEnabledDataSourcesDefinition() => MockField("_enabledDataSources", new[] { true, true });
 
+    private void MockConfigurationProvider() => MockField("_configurationProvider", new ConfigurationProviderMock());
+
     private void MockField(string fieldName, object mockedValue)
     {
         var mockedField = _testedInstance.GetType().GetField(fieldName, BindingFlags.NonPublic | BindingFlags.Instance);
@@ -60,6 +64,19 @@ private void MockField(string fieldName, object mockedValue)
     }
 }
 
+internal sealed class ConfigurationProviderMock : IConfigurationProvider
+{
+    public void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId) { }
+
+    public CustomConfigurationData[] GetCustomConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
+
+    public BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(string projectFullPath, BuildAnalyzer analyzer) => [];
+
+    public BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(BuildAnalyzerConfiguration[] userConfigs, BuildAnalyzer analyzer) => [];
+
+    public BuildAnalyzerConfiguration[] GetUserConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
+}
+
 internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionModule
 {
     private readonly bool _isCheckRuleExistForTest = true;
diff --git a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
index 43fffc8e289..92c46e1c962 100644
--- a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
+++ b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
@@ -15,37 +15,7 @@ namespace Microsoft.Build.BuildCheck.UnitTests
 {
     public sealed class DoubleWritesCheck_Tests
     {
-        private sealed class MockBuildCheckRegistrationContext : IBuildCheckRegistrationContext
-        {
-            private event Action<BuildCheckDataContext<TaskInvocationCheckData>>? _taskInvocationAction;
-
-            public List<BuildCheckResult> Results { get; } = new();
-
-            public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction) => throw new NotImplementedException();
-            public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction) => throw new NotImplementedException();
-
-            public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
-                => _taskInvocationAction += taskInvocationAction;
-
-            public void TriggerTaskInvocationAction(TaskInvocationCheckData data)
-            {
-                if (_taskInvocationAction is not null)
-                {
-                    BuildCheckDataContext<TaskInvocationCheckData> context = new BuildCheckDataContext<TaskInvocationCheckData>(
-                        null!,
-                        null!,
-                        null!,
-                        ResultHandler,
-                        data);
-                    _taskInvocationAction(context);
-                }
-            }
-
-            private void ResultHandler(BuildExecutionCheckWrapper wrapper, ICheckContext context, BuildExecutionCheckConfigurationEffective[] configs, BuildCheckResult result)
-                => Results.Add(result);
-        }
-
-        private readonly DoubleWritesCheck _check;
+        private readonly DoubleWritesAnalyzer _analyzer;
 
         private readonly MockBuildCheckRegistrationContext _registrationContext;
 
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 48221d39ea7..b93f2d7d9f5 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -2,7 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
+using System.IO.Ports;
+using System.Linq;
 using System.Xml;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
@@ -15,6 +18,8 @@ namespace Microsoft.Build.BuildCheck.UnitTests;
 
 public class EndToEndTests : IDisposable
 {
+    private const string EditorConfigFileName = ".editorconfig";
+
     private readonly TestEnvironment _env;
 
     public EndToEndTests(ITestOutputHelper output)
@@ -37,7 +42,7 @@ public EndToEndTests(ITestOutputHelper output)
     [InlineData(false, false)]
     public void SampleCheckIntegrationTest_CheckOnBuild(bool buildInOutOfProcessNode, bool checkRequested)
     {
-        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile);
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
             $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
@@ -71,7 +76,7 @@ public void SampleCheckIntegrationTest_CheckOnBuild(bool buildInOutOfProcessNode
     [InlineData(false, false, "warning")]
     public void SampleCheckIntegrationTest_ReplayBinaryLogOfCheckedBuild(bool buildInOutOfProcessNode, bool checkRequested, string BC0101Severity)
     {
-        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, BC0101Severity);
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", BC0101Severity) });
 
         var projectDirectory = Path.GetDirectoryName(projectFile.Path);
         string logFile = _env.ExpectFile(".binlog").Path;
@@ -113,7 +118,7 @@ public void SampleCheckIntegrationTest_ReplayBinaryLogOfCheckedBuild(bool buildI
     [InlineData("none", null, new string[] { "BC0101"})]
     public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string expectedOutputValues, string[] unexpectedOutputValues)
     {
-        PrepareSampleProjectsAndConfig(true, out TransientTestFile projectFile, BC0101Severity);
+        PrepareSampleProjectsAndConfig(true, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", BC0101Severity) });
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
             $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check",
@@ -138,7 +143,7 @@ public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string
     [InlineData(false, false)]
     public void SampleCheckIntegrationTest_CheckOnBinaryLogReplay(bool buildInOutOfProcessNode, bool checkRequested)
     {
-        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile);
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
 
         string? projectDirectory = Path.GetDirectoryName(projectFile.Path);
         string logFile = _env.ExpectFile(".binlog").Path;
@@ -175,15 +180,15 @@ public void SampleCheckIntegrationTest_CheckOnBinaryLogReplay(bool buildInOutOfP
     [Theory]
     [InlineData("CheckCandidate", new[] { "CustomRule1", "CustomRule2" })]
     [InlineData("CheckCandidateWithMultipleChecksInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
-    public void CustomCheckTest(string checkCandidate, string[] expectedRegisteredRules, bool expectedRejectedChecks = false)
+    public void CustomCheckTest_NoEditorConfig(string checkCandidate, string[] expectedRegisteredRules, bool expectedRejectedChecks = false)
     {
         using (var env = TestEnvironment.Create())
         {
             var checkCandidatePath = Path.Combine(TestAssetsRootPath, checkCandidate);
             AddCustomDataSourceToNugetConfig(checkCandidatePath);
 
-            string projectCheckBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
-                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -check -verbosity:n",
+            string projectAnalysisBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(analysisCandidatePath, $"{analysisCandidate}.csproj")} /m:1 -nr:False -restore -analyze -verbosity:n",
                 out bool successBuild);
             successBuild.ShouldBeTrue(projectCheckBuildLog);
 
@@ -194,14 +199,35 @@ public void CustomCheckTest(string checkCandidate, string[] expectedRegisteredRu
 
             if (expectedRejectedChecks)
             {
-                projectCheckBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomCheckBaseTypeNotAssignable", "InvalidCheck", "InvalidCustomCheck, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
+                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
+                    "CustomAnalyzerBaseTypeNotAssignable",
+                    "InvalidAnalyzer",
+                    "InvalidCustomAnalyzer, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
             }
         }
     }
 
-    private void AddCustomDataSourceToNugetConfig(string checkCandidatePath)
+    [Theory]
+    [InlineData("AnalysisCandidate", "X01234", "error", "error X01234")]
+    [InlineData("AnalysisCandidateWithMultipleAnalyzersInjected", "X01234", "warning", "warning X01234")]
+    public void CustomAnalyzerTest_WithEditorConfig(string analysisCandidate, string ruleId, string severity, string expectedMessage)
     {
-        var nugetTemplatePath = Path.Combine(checkCandidatePath, "nugetTemplate.config");
+        using (var env = TestEnvironment.Create())
+        {
+            var analysisCandidatePath = Path.Combine(TestAssetsRootPath, analysisCandidate);
+            AddCustomDataSourceToNugetConfig(analysisCandidatePath);
+            File.WriteAllText(Path.Combine(analysisCandidatePath, EditorConfigFileName), ReadEditorConfig(new List<(string, string)>() { (ruleId, severity) }, analysisCandidatePath));
+
+            string projectAnalysisBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(analysisCandidatePath, $"{analysisCandidate}.csproj")} /m:1 -nr:False -restore -analyze -verbosity:n", out bool _, timeoutMilliseconds: 1200_0000);
+
+            projectAnalysisBuildLog.ShouldContain(expectedMessage);
+        }
+    }
+
+    private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
+    {
+        var nugetTemplatePath = Path.Combine(analysisCandidatePath, "nugetTemplate.config");
 
         var doc = new XmlDocument();
         doc.LoadXml(File.ReadAllText(nugetTemplatePath));
@@ -239,9 +265,9 @@ private void PopulateXmlAttribute(XmlDocument doc, XmlNode node, string attribut
     }
 
     private void PrepareSampleProjectsAndConfig(
-    bool buildInOutOfProcessNode,
-    out TransientTestFile projectFile,
-    string? BC0101Severity = null)
+        bool buildInOutOfProcessNode,
+        out TransientTestFile projectFile,
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity)
     {
         string testAssetsFolderName = "SampleCheckIntegrationTest";
         TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
@@ -253,7 +279,7 @@ private void PrepareSampleProjectsAndConfig(
         projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
         TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
 
-        CreateEditorConfig(BC0101Severity, testAssetsFolderName, workFolder);
+        _env.CreateFile(workFolder, ".editorconfig", ReadEditorConfig(ruleToSeverity, testAssetsFolderName));
 
         // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
         // This discrepancy breaks path equality checks in MSBuild checks if we pass to MSBuild full path to the initial project.
@@ -271,12 +297,18 @@ string ReadAndAdjustProjectContent(string fileName) =>
                 .Replace("WorkFolderPath", workFolder.Path);
     }
 
-    private void CreateEditorConfig(string? BC0101Severity, string testAssetsFolderName, TransientTestFolder workFolder)
+    private string ReadEditorConfig(IEnumerable<(string RuleId, string Severity)>? ruleToSeverity, string testAssetsFolderName)
     {
-        string configContent = string.IsNullOrEmpty(BC0101Severity)
-            ? File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, ".editorconfigbasic"))
-            : File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, ".editorconfigcustomised")).Replace("BC0101Severity", BC0101Severity);
+        string configContent = File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, $"{EditorConfigFileName}test"));
+
+        if (ruleToSeverity != null && ruleToSeverity.Any())
+        {
+            foreach (var rule in ruleToSeverity)
+            {
+                configContent = configContent.Replace($"build_check.{rule.RuleId}.Severity={rule.RuleId}Severity", $"build_check.{rule.RuleId}.Severity={rule.Severity}");
+            }
+        }
 
-        _ = _env.CreateFile(workFolder, ".editorconfig", configContent);
+        return configContent;
     }
 }
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 1fe02d88b2f..e22e82079af 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -44,4 +44,13 @@
     </None>
   </ItemGroup>
 
+  <ItemGroup>
+    <None Update="TestAssets\AnalysisCandidateWithMultipleAnalyzersInjected\.editorconfigtest">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+    <None Update="TestAssets\AnalysisCandidate\.editorconfigtest">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+  </ItemGroup>
+
 </Project>
diff --git a/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
new file mode 100644
index 00000000000..883bb0f188e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
@@ -0,0 +1,56 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    internal sealed class MockBuildCheckRegistrationContext : IBuildCheckRegistrationContext
+    {
+        private event Action<BuildCheckDataContext<TaskInvocationAnalysisData>>? _taskInvocationAction;
+        private event Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>? _evaluatedPropertiesAction;
+
+        public List<BuildCheckResult> Results { get; } = new();
+
+        public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+            => _evaluatedPropertiesAction += evaluatedPropertiesAction;
+        public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction) => throw new NotImplementedException();
+
+        public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
+            => _taskInvocationAction += taskInvocationAction;
+
+        public void TriggerTaskInvocationAction(TaskInvocationAnalysisData data)
+        {
+            if (_taskInvocationAction is not null)
+            {
+                BuildCheckDataContext<TaskInvocationAnalysisData> context = new BuildCheckDataContext<TaskInvocationAnalysisData>(
+                    null!,
+                    null!,
+                    null!,
+                    ResultHandler,
+                    data);
+                _taskInvocationAction(context);
+            }
+        }
+        public void TriggerEvaluatedPropertiesAction(EvaluatedPropertiesAnalysisData data)
+        {
+            if (_evaluatedPropertiesAction is not null)
+            {
+                BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context = new BuildCheckDataContext<EvaluatedPropertiesAnalysisData>(
+                    null!,
+                    null!,
+                    null!,
+                    ResultHandler,
+                    data);
+                _evaluatedPropertiesAction(context);
+            }
+        }
+
+        private void ResultHandler(BuildAnalyzerWrapper wrapper, IAnalysisContext context, BuildAnalyzerConfigurationEffective[] configs, BuildCheckResult result)
+            => Results.Add(result);
+    }
+}
+
diff --git a/src/BuildCheck.UnitTests/SharedOutputPathAnalyzer_Tests.cs b/src/BuildCheck.UnitTests/SharedOutputPathAnalyzer_Tests.cs
new file mode 100644
index 00000000000..35800db9553
--- /dev/null
+++ b/src/BuildCheck.UnitTests/SharedOutputPathAnalyzer_Tests.cs
@@ -0,0 +1,143 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Analyzers;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    public class SharedOutputPathAnalyzer_Tests
+    {
+        private readonly SharedOutputPathAnalyzer _analyzer;
+
+        private readonly MockBuildCheckRegistrationContext _registrationContext;
+
+        public SharedOutputPathAnalyzer_Tests()
+        {
+            _analyzer = new SharedOutputPathAnalyzer();
+            _registrationContext = new MockBuildCheckRegistrationContext();
+            _analyzer.RegisterActions(_registrationContext);
+        }
+
+        private EvaluatedPropertiesAnalysisData MakeEvaluatedPropertiesAction(
+            string projectFile,
+            Dictionary<string, string>? evaluatedProperties,
+            IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)>? evaluatedEnvVars)
+        {
+            return new EvaluatedPropertiesAnalysisData(
+                projectFile,
+                null,
+                evaluatedProperties ?? new Dictionary<string, string>(),
+                evaluatedEnvVars ?? new Dictionary<string, (string EnvVarValue, string File, int Line, int Column)>());
+        }
+
+        [Fact]
+        public void TestTwoProjectsWithSameRelativeOutputPath()
+        {
+            // Full output and intermediate paths are different: "C:/fake1/bin/Debug" and "C:/fake1/obj/Debug".
+            string projectFile1 = NativeMethodsShared.IsWindows ? "C:\\fake1\\project1.proj" : "/fake1/project1.proj";
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile1,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj/Debug" },
+                },
+                null));
+
+            // Full output and intermediate paths are different: "C:/fake2/bin/Debug" and "C:/fake2/obj/Debug".
+            string projectFile2 = NativeMethodsShared.IsWindows ? "C:\\fake2\\project2.proj" : "/fake2/project2.proj";
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile2,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj/Debug" },
+                },
+                null));
+
+            // Relative paths coincide but full does not. SharedOutputPathAnalyzer should not report it.
+            _registrationContext.Results.Count.ShouldBe(0);
+        }
+
+        [Fact]
+        public void TestProjectsWithDifferentPathsSeparators()
+        {
+            // Paths separators are messed up.
+            string projectFile1 = NativeMethodsShared.IsWindows ? "C:\\fake\\project1.proj" : "/fake/project1.proj";
+            string projectFile2 = NativeMethodsShared.IsWindows ? "C:\\fake\\project2.proj" : "/fake/project2.proj";
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile1,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj\\Debug" },
+                },
+                null));
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile2,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj\\Debug" },
+                },
+                null));
+
+            // 2 reports for bin and obj folders.
+            _registrationContext.Results.Count.ShouldBe(2);
+            _registrationContext.Results[0].BuildAnalyzerRule.Id.ShouldBe("BC0101");
+            _registrationContext.Results[1].BuildAnalyzerRule.Id.ShouldBe("BC0101");
+
+            // Check that paths are formed with correct paths separators
+            string wrongPathSeparator = NativeMethodsShared.IsWindows ? "/" : "\\";
+
+            foreach (string path in _registrationContext.Results[0].MessageArgs)
+            {
+                path.ShouldNotContain(wrongPathSeparator);
+            }
+            foreach (string path in _registrationContext.Results[1].MessageArgs)
+            {
+                path.ShouldNotContain(wrongPathSeparator);
+            }
+        }
+
+        [Fact]
+        public void TestThreeProjectsWithSameOutputPath()
+        {
+            string projectFolder = NativeMethodsShared.IsWindows ? "C:\\fake\\" : "/fake/";
+            string projectFile1 = $"{projectFolder}project1.proj";
+            string projectFile2 = $"{projectFolder}project2.proj";
+            string projectFile3 = $"{projectFolder}project3.proj";
+            var evaluatedProperties = new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj\\Debug" },};
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile1,
+                evaluatedProperties,
+                null));
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile2,
+                evaluatedProperties,
+                null));
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile3,
+                evaluatedProperties,
+                null));
+
+            _registrationContext.Results.Count.ShouldBe(4); // 4 reports for two pairs of project: (1, 2) and (1, 3).
+            foreach (var result in _registrationContext.Results)
+            {
+                result.BuildAnalyzerRule.Id.ShouldBe("BC0101");
+            }
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest
new file mode 100644
index 00000000000..be166e833cd
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest
@@ -0,0 +1,4 @@
+root = true
+
+[*.csproj]
+build_check.X01234.Severity=X01234Severity
diff --git a/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
new file mode 100644
index 00000000000..be166e833cd
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
@@ -0,0 +1,4 @@
+root = true
+
+[*.csproj]
+build_check.X01234.Severity=X01234Severity
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigbasic b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigcustomised
similarity index 61%
rename from src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigbasic
rename to src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigcustomised
index 0ee9a04a5ae..28ca732c908 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigbasic
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigcustomised
@@ -1,11 +1,11 @@
 root=true
 
 [*.csproj]
-build_check.BC0101.Severity=warning
+build_check.BC0101.Severity=BC0101Severity
 
 build_check.BC0102.Severity=warning
 build_check.BC0103.Severity=warning
 
 build_check.COND0543.Severity=Error
-build_check.COND0543.EvaluationCheckScope=AnalyzedProjectOnly
+build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
 build_check.COND0543.CustomSwitch=QWERTY
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigcustomised b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigcustomised
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
diff --git a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
index 7eb7895b2df..67bacf49a74 100644
--- a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
@@ -50,6 +50,30 @@ public void EventArgsCtors()
             projectStartedEvent = new ProjectStartedEventArgs(1, null, null, null, null, null, null, null, DateTime.Now);
         }
 
+        /// <summary>
+        /// Verify different Items and properties are not taken into account in the equals comparison. They should
+        /// not be considered as part of the equals evaluation
+        /// </summary>
+        [Fact]
+        public void ItemsAndPropertiesDifferentEquals()
+        {
+            ArrayList itemsList = new ArrayList();
+            ArrayList propertiesList = new ArrayList();
+            ProjectStartedEventArgs differentItemsAndProperties = new ProjectStartedEventArgs(
+                  s_baseProjectStartedEvent.ProjectId,
+                  s_baseProjectStartedEvent.Message,
+                  s_baseProjectStartedEvent.HelpKeyword,
+                  s_baseProjectStartedEvent.ProjectFile,
+                  s_baseProjectStartedEvent.TargetNames,
+                  propertiesList,
+                  itemsList,
+                  s_baseProjectStartedEvent.ParentProjectBuildEventContext,
+                  s_baseProjectStartedEvent.Timestamp);
+
+            s_baseProjectStartedEvent.Properties.ShouldNotBe(propertiesList);
+            s_baseProjectStartedEvent.Items.ShouldNotBe(itemsList);
+        }
+
         /// <summary>
         /// Create a derived class so that we can test the default constructor in order to increase code coverage and
         /// verify this code path does not cause any exceptions.
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index 135a354a526..4b4e95960c6 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -71,10 +71,10 @@ internal override void CreateFromStream(BinaryReader reader, int version)
     }
 }
 
-internal sealed class BuildCheckAcquisitionEventArgs(string acquisitionPath) : BuildCheckEventArgs
+internal sealed class BuildCheckAcquisitionEventArgs(string acquisitionPath, string projectPath) : BuildCheckEventArgs
 {
     internal BuildCheckAcquisitionEventArgs()
-        : this(string.Empty)
+        : this(string.Empty, string.Empty)
     {
     }
 
@@ -91,11 +91,14 @@ internal BuildCheckAcquisitionEventArgs()
     /// </value>
     public string AcquisitionPath { get; private set; } = acquisitionPath;
 
+    public string ProjectPath { get; private set; } = projectPath;
+
     internal override void WriteToStream(BinaryWriter writer)
     {
         base.WriteToStream(writer);
 
         writer.Write(AcquisitionPath);
+        writer.Write(ProjectPath);
     }
 
     internal override void CreateFromStream(BinaryReader reader, int version)
@@ -103,8 +106,10 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         base.CreateFromStream(reader, version);
 
         AcquisitionPath = reader.ReadString();
+        ProjectPath = reader.ReadString();
     }
 }
+
 internal sealed class BuildCheckResultWarning : BuildWarningEventArgs
 {
     public BuildCheckResultWarning(IBuildCheckResult result, string code)
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 4636850306a..cc9d14af45a 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
 using System.Runtime.Serialization;
@@ -250,9 +249,7 @@ public IDictionary<string, string>? GlobalProperties
         {
             get
             {
-                return globalProperties ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                    ? ImmutableDictionary<string, string>.Empty
-                    : null);
+                return globalProperties;
             }
 
             internal set
@@ -301,9 +298,7 @@ public IEnumerable? Properties
                 // up the live list of properties from the loaded project, which is stored in the configuration as well.
                 // By doing this, we no longer need to transmit properties using this message because they've already
                 // been transmitted as part of the BuildRequestConfiguration.
-                return properties ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                    ? Enumerable.Empty<DictionaryEntry>()
-                    : null);
+                return properties;
             }
         }
 
@@ -327,9 +322,7 @@ public IEnumerable? Items
                 // case, this access is to the live list.  For the central logger in the multi-proc case, the main node
                 // has likely not loaded this project, and therefore the live items would not be available to them, which is
                 // the same as the current functionality.
-                return items ?? (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                    ? Enumerable.Empty<DictionaryEntry>()
-                    : null);
+                return items;
             }
         }
 
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 83b48d2558c..fba9b94c7bb 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1863,15 +1863,15 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="IsAotCompatible" _locComment="" -->Indicates whether a class library is compatible with native AOT. Setting to true will enable analyzers for trimming, single file, and AOT.</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="IsWebBootstrapper" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="IsWebBootstrapper" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="JCPA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="Keyword" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="LangVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="VBRuntime" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="Prefer32Bit" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="PreferNativeArm64" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="HighEntropyVA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="LinkIncremental" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="Prefer32Bit" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="PreferNativeArm64" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="HighEntropyVA" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="LinkIncremental" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestCertificateThumbprint" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestKeyFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="MapFileExtensions" type="msb:boolean" substitutionGroup="msb:Property">
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 832ffcd8057..0eacfd24c73 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -576,26 +576,6 @@ internal static string MaybeAdjustFilePath(string value, string baseDirectory =
             return shouldAdjust ? newValue.ToString() : value;
         }
 
-        /// <summary>
-        /// Gets the path value that is associated with the specified key in a dictionary with <see cref="string"/> values.
-        /// Normalizes the value as a path.
-        /// </summary>
-        /// <param name="dictionary">The dictionary to search.</param>
-        /// <param name="key">The key to locate.</param>
-        /// <param name="value">When this method returns, the value associated with the specified key normalized as a path, if the key is found; otherwise <see langword="null"/>.</param>
-        /// <returns><see langword="true"/> if the dictionary contains an element that has the specified key; otherwise, <see langword="false"/>.</returns>
-        /// <remarks>Use this method to get paths from dictionaries of properties whose default values may contain backslashes.</remarks>
-        internal static bool TryGetPathValue<TKey>(this IReadOnlyDictionary<TKey, string> dictionary, TKey key, out string value)
-        {
-            bool result = dictionary.TryGetValue(key, out value);
-            if (result)
-            {
-                value = NormalizePath(value);
-            }
-
-            return result;
-        }
-
         /// <summary>
         /// If on Unix, convert backslashes to slashes for strings that resemble paths.
         /// This overload takes and returns ReadOnlyMemory of characters.
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index afd777eef97..08353749def 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -41,12 +41,6 @@ public MSBuildTestAssemblyFixture()
             var runningTestsField = testInfoType.GetField("s_runningTests", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
             runningTestsField.SetValue(null, true);
 
-            // Set the field in BuildEnvironmentState - as it might have been already preintialized by the data preparation of data driven tests
-            testInfoType = frameworkAssembly.GetType("Microsoft.Build.Framework.BuildEnvironmentState");
-            runningTestsField = testInfoType.GetField("s_runningTests", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
-            runningTestsField.SetValue(null, true);
-            
-
             // Note: build error files will be initialized in test environments for particular tests, also we don't have output to report error files into anyway...
             _testEnvironment = TestEnvironment.Create(output: null, ignoreBuildErrorFiles: true);
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index d881ab86b69..b7e42801af8 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2737,7 +2737,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
      <FindInvalidProjectReferences
          TargetPlatformVersion="$(TargetPlatformVersion)"
          TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
-         ProjectReferences="@(TargetPathWithTargetPlatformMoniker)">
+         ProjectReferences="@(_ProjectReferenceTargetPlatformMonikers)">
        <Output TaskParameter="InvalidReferences" ItemName="InvalidProjectReferences" />
      </FindInvalidProjectReferences>
 
@@ -2754,7 +2754,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       BuildInParallel="$(BuildInParallel)"
       ContinueOnError="!$(BuildingProject)"
       RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
-      <Output TaskParameter="TargetOutputs" ItemName="TargetPathWithTargetPlatformMoniker" />
+      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetPlatformMonikers" />
     </MSBuild>
   </Target>
 
diff --git a/src/UnitTests.Shared/MockLogger.cs b/src/UnitTests.Shared/MockLogger.cs
index b530cc538f0..782cef74d41 100644
--- a/src/UnitTests.Shared/MockLogger.cs
+++ b/src/UnitTests.Shared/MockLogger.cs
@@ -213,11 +213,6 @@ public void Initialize(IEventSource eventSource)
             {
                 _reportTelemetry = true;
             }
-
-            if (eventSource is IEventSource4 eventSource4)
-            {
-                eventSource4.IncludeEvaluationPropertiesAndItems();
-            }
         }
 
         /// <summary>
diff --git a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
index ebf080d5afa..3647f61a8dc 100644
--- a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
+++ b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
@@ -1,49 +1,49 @@
 {
-    "$schema": "http://json.schemastore.org/template",
-    "author": "Microsoft",
-    "classifications": [
-      "Common",
-      "Library"
-    ],
-    "name": "MSBuild custom check skeleton project.",
-    "generatorVersions": "[1.0.0.0-*)",
-    "description": "A project for creating a MSBuild check library that targets .NET Standard",
-    "groupIdentity": "Microsoft.CheckTemplate",
-    "identity": "Microsoft.CheckTemplate",
-    "shortName": "msbuildcheck",
-    "tags": {
-      "language": "C#",
-      "type": "project"
-    },
-    "sourceName": "Company.CheckTemplate",
-    "preferNameDirectory": true,
-    "primaryOutputs": [
-      {
-        "path": "Company.CheckTemplate.csproj"
-      }
-   ],
-   "symbols": {
+  "$schema": "http://json.schemastore.org/template",
+  "author": "Microsoft",
+  "classifications": [
+    "Common",
+    "Library"
+  ],
+  "name": "MSBuild custom check skeleton project.",
+  "generatorVersions": "[1.0.0.0-*)",
+  "description": "A project for creating a MSBuild check library that targets .NET Standard",
+  "groupIdentity": "Microsoft.CheckTemplate",
+  "identity": "Microsoft.CheckTemplate",
+  "shortName": "msbuildcheck",
+  "tags": {
+    "language": "C#",
+    "type": "project"
+  },
+  "sourceName": "Company.CheckTemplate",
+  "preferNameDirectory": true,
+  "primaryOutputs": [
+    {
+      "path": "Company.CheckTemplate.csproj"
+    }
+  ],
+  "symbols": {
     "MicrosoftBuildVersion": {
       "type": "parameter",
       "description": "Overrides the default Microsoft.Build version where check's interfaces are placed",
       "datatype": "text",
-      "defaultValue": "17.11.0",
+      "defaultValue": "17.12.0",
       "replaces": "1.0.0-MicrosoftBuildPackageVersion",
       "displayName": "Microsoft.Build default package version override"
     }
-   },
-    "postActions": [
-      {
-        "id": "restore",
-        "condition": "(!skipRestore)",
-        "description": "Restore NuGet packages required by this project.",
-        "manualInstructions": [
-          {
-            "text": "Run 'dotnet restore'"
-          }
-        ],
-        "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
-        "continueOnError": true
-      }
-    ]
-  }
+  },
+  "postActions": [
+    {
+      "id": "restore",
+      "condition": "(!skipRestore)",
+      "description": "Restore NuGet packages required by this project.",
+      "manualInstructions": [
+        {
+          "text": "Run 'dotnet restore'"
+        }
+      ],
+      "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
+      "continueOnError": true
+    }
+  ]
+}
