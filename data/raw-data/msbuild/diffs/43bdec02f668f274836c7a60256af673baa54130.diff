diff --git a/PerfViewData.etl.zip b/PerfViewData.etl.zip
new file mode 100644
index 00000000000..823543440d2
Binary files /dev/null and b/PerfViewData.etl.zip differ
diff --git a/README.md b/README.md
index c8331538f45..312ac7e70ed 100644
--- a/README.md
+++ b/README.md
@@ -6,13 +6,13 @@ For more information on MSBuild, see the [MSBuild documentation](https://docs.mi
 
 ### Build Status
 
-The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.7 and a corresponding version of the .NET Core SDK.
+The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.8 and a corresponding version of the .NET Core SDK.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=master)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=master)
 
-We have forked for MSBuild 16.6 in the branch [`vs16.6`](https://github.com/Microsoft/msbuild/tree/vs16.6). Changes to that branch need special approval.
+We have forked for MSBuild 16.7 in the branch [`vs16.7`](https://github.com/Microsoft/msbuild/tree/vs16.7). Changes to that branch need special approval.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.6)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.6)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.7)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.7)
 
 MSBuild 16.4 builds from the branch [`vs16.4`](https://github.com/Microsoft/msbuild/tree/vs16.4). Only high-priority bugfixes will be considered for servicing 16.4.
 
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index a24609db358..5e1479fa0c9 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -52,8 +52,7 @@
          need to be in a specific location that does not mesh with NuGet. To resolve this, we include the default
          PackageReference assets but will remove them from the Reference ItemGroup before RAR runs and avoid the warnings -->
     <ItemGroup>
-        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Build.Utilities.v4.0'))' == 'True'" />
-        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Build.Framework'))' == 'True'" />
+        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Build'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGet.'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Newtonsoft.Json'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGetSdkResolver'))' == 'True'" />
diff --git a/eng/Packages.props b/eng/Packages.props
index d3ac170588d..34ef37a4d0f 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -1,7 +1,7 @@
 <Project>
 
   <PropertyGroup>
-      <NuGetPackageVersion>5.4.0-rtm.6292</NuGetPackageVersion>
+      <NuGetPackageVersion>5.7.0-rtm.6710</NuGetPackageVersion>
       <NuGetBuildTasksVersion Condition="'$(NuGetBuildTasksVersion)' == ''">$(NuGetPackageVersion)</NuGetBuildTasksVersion>
       <NuGetCommandsVersion Condition="'$(NuGetCommandsVersion)' == ''">$(NuGetPackageVersion)</NuGetCommandsVersion>
       <NuGetProtocolVersion Condition="'$(NuGetProtocolVersion)' == ''">$(NuGetPackageVersion)</NuGetProtocolVersion>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 5c670906e71..ac54567c72a 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20302.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20326.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>9b71be0663493cd0e111b55536a2e1eeb272f54c</Sha>
+      <Sha>ed69753a3ffbdaa08365252c710d57a64d17f859</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index e20df56fead..dc29455da17 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -15,7 +15,7 @@
     <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
   </PropertyGroup>
   <PropertyGroup>
-    <VersionPrefix>16.7.0</VersionPrefix>
+    <VersionPrefix>16.8.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
diff --git a/eng/common/sdl/packages.config b/eng/common/sdl/packages.config
index 256ffbfb93a..968b39bef5f 100644
--- a/eng/common/sdl/packages.config
+++ b/eng/common/sdl/packages.config
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
 <packages>
-  <package id="Microsoft.Guardian.Cli" version="0.7.2"/>
+  <package id="Microsoft.Guardian.Cli.win10-x64" version="0.20.1"/>
 </packages>
diff --git a/eng/common/templates/job/execute-sdl.yml b/eng/common/templates/job/execute-sdl.yml
index 52e2ff021d7..bf09d2511c6 100644
--- a/eng/common/templates/job/execute-sdl.yml
+++ b/eng/common/templates/job/execute-sdl.yml
@@ -65,7 +65,7 @@ jobs:
       continueOnError: ${{ parameters.sdlContinueOnError }}
   - ${{ if eq(parameters.overrideParameters, '') }}:
     - powershell: eng/common/sdl/execute-all-sdl-tools.ps1
-        -GuardianPackageName Microsoft.Guardian.Cli.0.7.2
+        -GuardianPackageName Microsoft.Guardian.Cli.win10-x64.0.20.1
         -NugetPackageDirectory $(Build.SourcesDirectory)\.packages
         -AzureDevOpsAccessToken $(dn-bot-dotnet-build-rw-code-rw)
         ${{ parameters.additionalParameters }}
diff --git a/global.json b/global.json
index fc53c0de68f..0895b31ec1e 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20302.3"
+    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20326.2"
   }
 }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 7915650703a..33a72c044b2 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -1513,11 +1513,20 @@ public ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectC
         public ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) { }
         public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { }
         public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics ConstructionMetrics { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> EntryPointNodes { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> GraphRoots { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodes { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodesTopologicallySorted { get { throw null; } }
         public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>> GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) { throw null; }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public partial struct GraphConstructionMetrics
+        {
+            public GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) { throw null;}
+            public System.TimeSpan ConstructionTime { get { throw null; } }
+            public int EdgeCount { get { throw null; } }
+            public int NodeCount { get { throw null; } }
+        }
         public delegate Microsoft.Build.Execution.ProjectInstance ProjectInstanceFactoryFunc(string projectPath, System.Collections.Generic.Dictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index fb016e00783..baa28daef94 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -1507,11 +1507,20 @@ public ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectC
         public ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) { }
         public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) { }
         public ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) { }
+        public Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics ConstructionMetrics { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> EntryPointNodes { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> GraphRoots { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodes { get { throw null; } }
         public System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode> ProjectNodesTopologicallySorted { get { throw null; } }
         public System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>> GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) { throw null; }
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public partial struct GraphConstructionMetrics
+        {
+            public GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) { throw null;}
+            public System.TimeSpan ConstructionTime { get { throw null; } }
+            public int EdgeCount { get { throw null; } }
+            public int NodeCount { get { throw null; } }
+        }
         public delegate Microsoft.Build.Execution.ProjectInstance ProjectInstanceFactoryFunc(string projectPath, System.Collections.Generic.Dictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 6ba9633aab7..f85190f0854 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -3739,6 +3739,11 @@ public void GetAllGlobsShouldFindAllExcludesAndRemoves()
         new[] {"aa", "bb", "cc"},
         new[] {"b", "c"}
         )]
+        [InlineData(
+            @"<A Include=`ab*;b|c*;de*`/>",
+            new[] {"ab", "de"},
+            new[] {"bc", "b|c", "b", "c"}
+            )]
         public void GetAllGlobsShouldProduceGlobThatMatches(string itemContents, string[] stringsThatShouldMatch, string[] stringsThatShouldNotMatch)
         {
             var projectTemplate =
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 4cc129d7abd..c6f15a9b190 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -155,13 +155,14 @@ public void SolutionFilterFiltersProjects()
                     @"
                 {
                   ""solution"": {
-                    ""path"": """ + solutionFile.Path.Replace("\\", "\\\\") + @""",
+                    ""path"": """ + Path.Combine(".", "SimpleProject", "SimpleProject.sln").Replace("\\", "\\\\") + @""",
                     ""projects"": [
                       """ + Path.Combine("SimpleProject", "SimpleProject.csproj").Replace("\\", "\\\\") + @"""
                     ]
                     }
                 }
                 ");
+                Directory.GetCurrentDirectory().ShouldNotBe(Path.GetDirectoryName(filterFile.Path));
                 SolutionFile solution = SolutionFile.Parse(filterFile.Path);
                 ILoggingService mockLogger = CreateMockLoggingService();
                 ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, mockLogger);
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 2009a9b3f55..7017c33b036 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -2865,6 +2865,7 @@ public void PropertyFunctionVersionComparisons(string a, string b, int expectedS
         [InlineData("net45", ".NETFramework", "4.5")]
         [InlineData("netcoreapp3.1", ".NETCoreApp", "3.1")]
         [InlineData("netstandard2.1", ".NETStandard", "2.1")]
+        [InlineData("net5.0-ios12.0", ".NETCoreApp", "5.0")]
         [InlineData("foo", "Unsupported", "0.0")]
         public void PropertyFunctionTargetFrameworkParsing(string tfm, string expectedIdentifier, string expectedVersion)
         {
@@ -2875,8 +2876,50 @@ public void PropertyFunctionTargetFrameworkParsing(string tfm, string expectedId
             AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetFrameworkVersion('{tfm}'))");
         }
 
+        [Theory]
+        [InlineData("net45", 2, "4.5")]
+        [InlineData("net45", 3, "4.5.0")]
+        [InlineData("net472", 3, "4.7.2")]
+        public void PropertyFunctionTargetFrameworkVersionMultipartParsing(string tfm, int versionPartCount, string expectedVersion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetFrameworkVersion('{tfm}', {versionPartCount}))");
+        }
+
+        [Theory]
+        [InlineData("net5.0-windows10.1.2.3", 4, "10.1.2.3")]
+        [InlineData("net5.0-windows10.1.2.3", 2, "10.1")]
+        public void PropertyFunctionTargetPlatformVersionMultipartParsing(string tfm, int versionPartCount, string expectedVersion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetPlatformVersion('{tfm}', {versionPartCount}))");
+        }
+
+        [Theory]
+        [InlineData("net5.0-ios12.0", "ios", "12.0")]
+        [InlineData("net5.1-android1.1", "android", "1.1")]
+        [InlineData("net6.0-windows99.99", "windows", "99.99")]
+        [InlineData("net5.0-ios", "ios", "0.0")]
+        [InlineData("foo", "", "0.0")]
+        public void PropertyFunctionTargetPlatformParsing(string tfm, string expectedIdentifier, string expectedVersion)
+        {
+            var pg = new PropertyDictionary<ProjectPropertyInstance>();
+            var expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+
+            AssertSuccess(expander, expectedIdentifier, $"$([MSBuild]::GetTargetPlatformIdentifier('{tfm}'))");
+            AssertSuccess(expander, expectedVersion, $"$([MSBuild]::GetTargetPlatformVersion('{tfm}'))");
+        }
+
         [Theory]
         [InlineData("net5.0", "net5.0", true)]
+        [InlineData("net5.0-windows10.0", "net5.0-windows10.0", true)]
+        [InlineData("net5.0-ios", "net5.0-andriod", false)]
+        [InlineData("net5.0-ios12.0", "net5.0-ios11.0", true)]
+        [InlineData("net5.0-ios11.0", "net5.0-ios12.0", false)]
         [InlineData("net45", "net46", false)]
         [InlineData("net46", "net45", true)]
         [InlineData("netcoreapp3.1", "netcoreapp1.0", true)]
diff --git a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
index 8fb9ef51a22..cc00152c075 100644
--- a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
@@ -120,6 +120,43 @@ public void RemoveShouldPreserveIntermediaryReferences(string content)
             ObjectModelHelpers.AssertItems(new string[0], itemsForI2);
         }
 
+        [Fact]
+        public void RemoveRespectsItemTransform()
+        {
+            var content = @"
+                            <i Include='a;b;c' />
+
+                            <i Remove='@(i->WithMetadataValue(`Identity`, `b`))' />
+                            <i Remove='@(i->`%(Extension)`)' /> <!-- should do nothing -->";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, allItems: true);
+
+            ObjectModelHelpers.AssertItems(new[] { "a", "c" }, items);
+        }
+
+        [Fact]
+        public void UpdateRespectsItemTransform()
+        {
+            var content = @"
+                            <i Include='a;b;c' />
+
+                            <i Update='@(i->WithMetadataValue(`Identity`, `b`))'>
+                                <m1>m1_updated</m1>
+                            </i>
+                            <i Update=`@(i->'%(Extension)')`> <!-- should do nothing -->
+                                <m2>m2_updated</m2>
+                            </i>";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, allItems: true);
+
+            ObjectModelHelpers.AssertItems(new[] { "a", "b", "c" }, items,
+                new[] {
+                    new Dictionary<string, string>(),
+                    new Dictionary<string, string> { ["m1"] = "m1_updated" },
+                    new Dictionary<string, string>(),
+                });
+        }
+
         [Fact]
         public void UpdateShouldPreserveIntermediaryReferences()
         {
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
index 00dfd1bb588..c4f8ab84bea 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
@@ -148,6 +148,17 @@ public void GlobParsingShouldInitializePartialStateOnIllegalFileSpec()
             Assert.False(glob.IsMatch($"b/.../c/d.cs"));
         }
 
+        [Fact]
+        public void GlobParsingShouldDeduplicateRegexes()
+        {
+            var globRoot = NativeMethodsShared.IsWindows ? @"c:\a" : "/a";
+            var fileSpec = $"b/**/*.cs";
+            var glob1 = MSBuildGlob.Parse(globRoot, fileSpec);
+            var glob2 = MSBuildGlob.Parse(globRoot, fileSpec);
+
+            Assert.Same(glob1.TestOnlyRegex, glob2.TestOnlyRegex);
+        }
+
         [Fact]
         public void GlobIsNotUnescaped()
         {
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 7e7022e5622..45734a1188c 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -64,6 +64,21 @@ public void ConstructWithSingleNode()
             }
         }
 
+        [Fact]
+        public void ConstructionMetricsAreAvailable()
+        {
+            var graph = Helpers.CreateProjectGraph(
+                _env,
+                new Dictionary<int, int[]>()
+                {
+                    {1, new[] {2, 3}}
+                });
+
+            graph.ConstructionMetrics.ConstructionTime.Ticks.ShouldBeGreaterThan(0);
+            graph.ConstructionMetrics.NodeCount.ShouldBe(3);
+            graph.ConstructionMetrics.EdgeCount.ShouldBe(2);
+        }
+
         [Fact]
         public void ConstructWithSingleNodeWithProjectInstanceFactory()
         {
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index 0a4d92dc8e2..f6c62d77ccd 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -3,19 +3,13 @@
 
 using System;
 using System.Collections;
-using System.Collections.Specialized;
-using System.Text.RegularExpressions;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-
-
 using CommunicationsUtilities = Microsoft.Build.Internal.CommunicationsUtilities;
 using InternalUtilities = Microsoft.Build.Internal.Utilities;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using MSBuildApp = Microsoft.Build.CommandLine.MSBuildApp;
-using Project = Microsoft.Build.Evaluation.Project;
 using ProjectCollection = Microsoft.Build.Evaluation.ProjectCollection;
 
 using Toolset = Microsoft.Build.Evaluation.Toolset;
@@ -27,14 +21,21 @@
 using Xunit;
 using System.Collections.Generic;
 using System.IO;
+using Microsoft.Build.Internal;
+using Shouldly;
+using System.Linq;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
 {
     public class UtilitiesTestStandard : UtilitiesTest
     {
-        public UtilitiesTestStandard()
+        private readonly ITestOutputHelper _output;
+
+        public UtilitiesTestStandard(ITestOutputHelper output)
         {
             this.loadAsReadOnly = false;
+            _output = output;
         }
 
         [Fact]
@@ -63,6 +64,26 @@ public void GetTextFromTextNodeWithXmlComment7()
             // Should get XML; note space after x added
             Assert.Equal("<!-- bar; baz; --><!-- bar --><x />", xmlContents);
         }
+
+        [Fact]
+        public void HandshakesDiffer()
+        {
+            int numHandshakeOptions = (int)Math.Pow(2, Enum.GetNames(typeof(HandshakeOptions)).Length - 1);
+            Dictionary<long, int> handshakes = new Dictionary<long, int>();
+            for (int i = 0; i < numHandshakeOptions; i++)
+            {
+                long nextKey = CommunicationsUtilities.GetHostHandshake((HandshakeOptions)i);
+                if (handshakes.TryGetValue(nextKey, out int collision))
+                {
+                    _output.WriteLine("There was a collision between {0} and {1}.", collision, i);
+                }
+                else
+                {
+                    handshakes.Add(nextKey, i);
+                }
+            }
+            handshakes.Count.ShouldBe(numHandshakeOptions, "two or more combinations of handshake options hashed to the same value");
+        }
     }
 
     public class UtilitiesTestReadOnlyLoad : UtilitiesTest
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 9f435bb36ba..144ded7db93 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -26,7 +26,6 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
@@ -1446,6 +1445,13 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                         });
                 }
 
+                LogMessage(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                        "StaticGraphConstructionMetrics",
+                        Math.Round(projectGraph.ConstructionMetrics.ConstructionTime.TotalSeconds, 3),
+                        projectGraph.ConstructionMetrics.NodeCount,
+                        projectGraph.ConstructionMetrics.EdgeCount));
+
                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
                 var waitHandle = new AutoResetEvent(true);
@@ -2499,6 +2505,13 @@ private bool ReuseOldCaches(string[] inputCacheFiles)
             }
         }
 
+        private void LogMessage(string message)
+        {
+            var loggingService = ((IBuildComponentHost)this).LoggingService;
+
+            loggingService?.LogCommentFromText(BuildEventContext.Invalid, MessageImportance.High, message);
+        }
+
         private void LogErrorAndShutdown(string message)
         {
             var loggingService = ((IBuildComponentHost)this).LoggingService;
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index b86d476910f..36bd4e66433 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Execution
 {
@@ -395,7 +396,7 @@ public bool ResetCaches
         public bool EnableNodeReuse
         {
             get => _enableNodeReuse;
-            set => _enableNodeReuse = value;
+            set => _enableNodeReuse = Traits.Instance.DisableNodeReuse ? false : value;
         }
 
         /// <summary>
@@ -913,7 +914,7 @@ private void Initialize(PropertyDictionary<ProjectPropertyInstance> environmentP
             ResetCaches = true;
             _toolsetProvider = toolsetProvider;
 
-            if (Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1") // For example to disable node reuse within Visual Studio
+            if (Traits.Instance.DisableNodeReuse) // For example to disable node reuse within Visual Studio
             {
                 _enableNodeReuse = false;
             }
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index a1b4c7ae411..a30017ca426 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -1,24 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Text;
-using System.IO;
-using System.IO.Pipes;
-using System.Threading;
-using System.Diagnostics;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using System.Security;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.AccessControl;
-#endif
-using System.Security.Principal;
-
-using BuildParameters = Microsoft.Build.Execution.BuildParameters;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 9a658284495..8bfc4cd604e 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -2,13 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
-using System.Collections.Generic;
 using System.Globalization;
-using System.Text;
 using System.Threading;
-using System.Diagnostics;
-using System.IO;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index e94c194e33d..63ca1cadc74 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -1,15 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.AccessControl;
-#endif
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index cc8507b4645..3b69a13427a 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -10,7 +10,6 @@
 using System.Threading;
 using System.Runtime.InteropServices;
 using System.Security.Principal;
-using System.Security.Permissions;
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index e0aebf0ade8..44a2de9a749 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -3,29 +3,12 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
-using System.Text;
 using System.IO;
-using System.IO.Pipes;
 using System.Diagnostics;
 using System.Threading;
-using System.Reflection;
-using System.Runtime.InteropServices;
-using System.Security;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.AccessControl;
-#endif
-using System.Security.Principal;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 
 using Microsoft.Build.Shared;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.BackEnd
 {
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 0c74fad44a3..465f2b21122 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -5,7 +5,6 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.IO;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index b43999f8a97..5d3e7d5f5f8 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -362,9 +362,7 @@ private void ParseSolutionFilter(string solutionFilterFile)
         {
             try
             {
-                using JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile));
-                JsonElement solution = text.RootElement.GetProperty("solution");
-                _solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
+                _solutionFile = ParseSolutionFromSolutionFilter(solutionFilterFile, out JsonElement solution);
                 if (!FileSystems.Default.FileExists(_solutionFile))
                 {
                     ProjectFileErrorUtilities.ThrowInvalidProjectFile
@@ -396,6 +394,30 @@ private void ParseSolutionFilter(string solutionFilterFile)
             }
         }
 
+        internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile, out JsonElement solution)
+        {
+            try
+            {
+                JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile));
+                solution = text.RootElement.GetProperty("solution");
+                return Path.GetFullPath(Path.Combine(Path.GetDirectoryName(solutionFilterFile), solution.GetProperty("path").GetString()));
+            }
+            catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
+            {
+                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                (
+                    false, /* Just throw the exception */
+                    "SubCategoryForSolutionParsingErrors",
+                    new BuildEventFileInfo(solutionFilterFile),
+                    e,
+                    "SolutionFilterJsonParsingError",
+                    solutionFilterFile
+                );
+            }
+            solution = new JsonElement();
+            return string.Empty;
+        }
+
         /// <summary>
         /// Adds a configuration to this solution
         /// </summary>
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 5c1f51e9b9e..02bba78e5d9 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -54,6 +54,11 @@ public class Project : ILinkableObject
         /// </summary>
         private static readonly bool s_debugEvaluation = (Environment.GetEnvironmentVariable("MSBUILDDEBUGEVALUATION") != null);
 
+        /// <summary>
+        /// * and ? are invalid file name characters, but they occur in globs as wild cards.
+        /// </summary>
+        private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c!= '/' && c != '\\' && c != ':').ToArray();
+
         /// <summary>
         /// Context to log messages and events in
         /// </summary>
@@ -2501,7 +2506,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
             {
                 var includeItemspec = new EvaluationItemSpec(itemElement.Include, _data.Expander, itemElement.IncludeLocation, itemElement.ContainingProject.DirectoryPath);
 
-                ImmutableArray<ItemSpecFragment> includeGlobFragments = includeItemspec.Fragments.Where(f => f is GlobFragment).ToImmutableArray();
+                ImmutableArray<ItemSpecFragment> includeGlobFragments = includeItemspec.Fragments.Where(f => f is GlobFragment && f.TextFragment.IndexOfAny(s_invalidGlobChars) == -1).ToImmutableArray();
                 if (includeGlobFragments.Length == 0)
                 {
                     return null;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index d9eb06311f0..d06978d9b77 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -3929,6 +3929,11 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg0);
                                 return true;
                             }
+                            if (TryGetArgs(args, out string arg1, out int arg2))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetFrameworkVersion(arg1, arg2);
+                                return true;
+                            }
                         }
                         else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsTargetFrameworkCompatible), StringComparison.OrdinalIgnoreCase))
                         {
@@ -3938,6 +3943,27 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetPlatformIdentifier), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetPlatformIdentifier(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.GetTargetPlatformVersion), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg0);
+                                return true;
+                            }
+                            if (TryGetArgs(args, out string arg1, out int arg2))
+                            {
+                                returnVal = IntrinsicFunctions.GetTargetPlatformVersion(arg1, arg2);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Path))
                     {
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 55f9e185226..48965e7852d 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -485,9 +485,9 @@ internal static string GetTargetFrameworkIdentifier(string tfm)
             return NuGetFramework.Value.GetTargetFrameworkIdentifier(tfm);
         }
 
-        internal static string GetTargetFrameworkVersion(string tfm)
+        internal static string GetTargetFrameworkVersion(string tfm, int versionPartCount = 2)
         {
-            return NuGetFramework.Value.GetTargetFrameworkVersion(tfm);
+            return NuGetFramework.Value.GetTargetFrameworkVersion(tfm, versionPartCount);
         }
 
         internal static bool IsTargetFrameworkCompatible(string target, string candidate)
@@ -495,6 +495,16 @@ internal static bool IsTargetFrameworkCompatible(string target, string candidate
             return NuGetFramework.Value.IsCompatible(target, candidate);
         }
 
+        internal static string GetTargetPlatformIdentifier(string tfm)
+        {
+            return NuGetFramework.Value.GetTargetPlatformIdentifier(tfm);
+        }
+
+        internal static string GetTargetPlatformVersion(string tfm, int versionPartCount = 2)
+        {
+            return NuGetFramework.Value.GetTargetPlatformVersion(tfm, versionPartCount);
+        }
+
         public static string GetCurrentToolsDirectory()
         {
             return BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 21bdd300107..03d07264cf2 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -324,7 +324,11 @@ protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElem
                 return needToExpandMetadataForEachItem;
             }
 
-            protected static bool ItemspecContainsASingleItemReference(ItemSpec<P, I> itemSpec, string referencedItemType)
+            /// <summary>
+            /// Is this spec a single reference to a specific item?
+            /// </summary>
+            /// <returns>True if the item is a simple reference to the referenced item type.</returns>
+            protected static bool ItemspecContainsASingleBareItemReference(ItemSpec<P, I> itemSpec, string referencedItemType)
             {
                 if (itemSpec.Fragments.Count != 1)
                 {
@@ -342,6 +346,14 @@ protected static bool ItemspecContainsASingleItemReference(ItemSpec<P, I> itemSp
                     return false;
                 }
 
+                // If the itemSpec is a single call to an item function, like @(X->Something(...)), it may get this
+                // far, but shouldn't be treated as a single reference: the item function may return entirely
+                // different results from a bare reference like @(X).
+                if (itemExpressionFragment.Capture.Captures is object)
+                {
+                    return false;
+                }
+
                 return true;
             }
         }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index fe2dcf43a85..e184cd7c538 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -39,7 +39,7 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I
                     new BuildEventFileInfo(string.Empty),
                     "OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem");
 
-                if (_matchOnMetadata.IsEmpty && ItemspecContainsASingleItemReference(_itemSpec, _itemElement.ItemType))
+                if (_matchOnMetadata.IsEmpty && ItemspecContainsASingleBareItemReference(_itemSpec, _itemElement.ItemType))
                 {
                     // Perf optimization: If the Remove operation references itself (e.g. <I Remove="@(I)"/>)
                     // then all items are removed and matching is not necessary
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index 025f247cfec..b1e13d2ed83 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -46,7 +46,7 @@ protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, I
                 ItemSpecMatchesItem matchItemspec;
                 bool? needToExpandMetadataForEachItem = null;
 
-                if (ItemspecContainsASingleItemReference(_itemSpec, _itemElement.ItemType))
+                if (ItemspecContainsASingleBareItemReference(_itemSpec, _itemElement.ItemType))
                 {
                     // Perf optimization: If the Update operation references itself (e.g. <I Update="@(I)"/>)
                     // then all items are updated and matching is not necessary
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index bab387bc147..1f07b22d429 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -5,6 +5,7 @@
 using System;
 using System.IO;
 using System.Text.RegularExpressions;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Globbing
@@ -18,7 +19,7 @@ namespace Microsoft.Build.Globbing
     /// </summary>
     public class MSBuildGlob : IMSBuildGlob
     {
-        private struct GlobState
+        private readonly struct GlobState
         {
             public string GlobRoot { get; }
             public string FileSpec { get; }
@@ -44,11 +45,15 @@ public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDir
             }
         }
 
+        // Cache of Regex objects that we have created and are still alive.
+        private static WeakValueDictionary<string, Regex> s_regexCache = new WeakValueDictionary<string, Regex>();
+
         private readonly Lazy<GlobState> _state;
 
         internal string TestOnlyGlobRoot => _state.Value.GlobRoot;
         internal string TestOnlyFileSpec => _state.Value.FileSpec;
         internal bool TestOnlyNeedsRecursion => _state.Value.NeedsRecursion;
+        internal Regex TestOnlyRegex => _state.Value.Regex;
 
         /// <summary>
         ///     The fixed directory part.
@@ -198,11 +203,28 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                         return (normalizedFixedPart, wildcardDirPart, filePart);
                     });
 
-                // compile the regex since it's expected to be used multiple times
-                var regex = isLegalFileSpec
-                    ? new Regex(matchFileExpression, FileMatcher.DefaultRegexOptions | RegexOptions.Compiled)
-                    : null;
+                Regex regex = null;
+                if (isLegalFileSpec)
+                {
+                    lock (s_regexCache)
+                    {
+                        s_regexCache.TryGetValue(matchFileExpression, out regex);
+                    }
 
+                    if (regex == null)
+                    {
+                        // compile the regex since it's expected to be used multiple times
+                        Regex newRegex = new Regex(matchFileExpression, FileMatcher.DefaultRegexOptions | RegexOptions.Compiled);
+                        lock (s_regexCache)
+                        {
+                            if (!s_regexCache.TryGetValue(matchFileExpression, out regex))
+                            {
+                                s_regexCache[matchFileExpression] = newRegex;
+                            }
+                        }
+                        regex ??= newRegex;
+                    }
+                }
                 return new GlobState(globRoot, fileSpec, isLegalFileSpec, fixedDirectoryPart, wildcardDirectoryPart, filenamePart, matchFileExpression, needsRecursion, regex);
             },
             true);
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index e80b4840b18..f304a90ad46 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -12,6 +12,7 @@
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
@@ -58,6 +59,25 @@ public delegate ProjectInstance ProjectInstanceFactoryFunc(
 
         internal GraphBuilder.GraphEdges TestOnly_Edges => Edges;
 
+        public GraphConstructionMetrics ConstructionMetrics { get; private set;}
+
+        /// <summary>
+        /// Various metrics on graph construction.
+        /// </summary>
+        public readonly struct GraphConstructionMetrics
+        {
+            public GraphConstructionMetrics(TimeSpan constructionTime, int nodeCount, int edgeCount)
+            {
+                ConstructionTime = constructionTime;
+                NodeCount = nodeCount;
+                EdgeCount = edgeCount;
+            }
+
+            public TimeSpan ConstructionTime { get; }
+            public int NodeCount { get; }
+            public int EdgeCount { get; }
+        }
+
         /// <summary>
         ///     Gets the project nodes representing the entry points.
         /// </summary>
@@ -396,7 +416,9 @@ public ProjectGraph(
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
-            projectInstanceFactory = projectInstanceFactory ?? DefaultProjectInstanceFactory;
+            var measurementInfo = BeginMeasurement();
+
+            projectInstanceFactory ??= DefaultProjectInstanceFactory;
 
             var graphBuilder = new GraphBuilder(
                 entryPoints,
@@ -413,6 +435,45 @@ public ProjectGraph(
             Edges = graphBuilder.Edges;
 
             _projectNodesTopologicallySorted = new Lazy<IReadOnlyCollection<ProjectGraphNode>>(() => TopologicalSort(GraphRoots, ProjectNodes));
+
+            ConstructionMetrics = EndMeasurement();
+
+            (Stopwatch Timer, string ETWArgs) BeginMeasurement()
+            {
+                string etwArgs = null;
+
+                if (MSBuildEventSource.Log.IsEnabled())
+                {
+                    etwArgs = string.Join(";", entryPoints.Select(
+                        e =>
+                        {
+                            var globalPropertyString = e.GlobalProperties == null
+                                ? string.Empty
+                                : string.Join(", ", e.GlobalProperties.Select(kvp => $"{kvp.Key} = {kvp.Value}"));
+
+                            return $"{e.ProjectFile}({globalPropertyString})";
+                        }));
+
+                    MSBuildEventSource.Log.ProjectGraphConstructionStart(etwArgs);
+                }
+
+                return (Stopwatch.StartNew(), etwArgs);
+            }
+
+            GraphConstructionMetrics EndMeasurement()
+            {
+                if (MSBuildEventSource.Log.IsEnabled())
+                {
+                    MSBuildEventSource.Log.ProjectGraphConstructionStop(measurementInfo.ETWArgs);
+                }
+
+                measurementInfo.Timer.Stop();
+
+                return new GraphConstructionMetrics(
+                    measurementInfo.Timer.Elapsed,
+                    ProjectNodes.Count,
+                    Edges.Count);
+            }
         }
 
         internal string ToDot()
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 17b0520b4f3..cff4feb6b66 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2146,24 +2146,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, Prope
                 string solutionFile = projectFile;
                 if (FileUtilities.IsSolutionFilterFilename(projectFile))
                 {
-                    try
-                    {
-                        using JsonDocument text = JsonDocument.Parse(File.ReadAllText(projectFile));
-                        JsonElement solution = text.RootElement.GetProperty("solution");
-                        solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
-                    }
-                    catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
-                    {
-                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
-                        (
-                            false, /* Just throw the exception */
-                            "SubCategoryForSolutionParsingErrors",
-                            new BuildEventFileInfo(projectFile),
-                            e,
-                            "SolutionFilterJsonParsingError",
-                            projectFile
-                        );
-                    }
+                    solutionFile = SolutionFile.ParseSolutionFromSolutionFilter(projectFile, out _);
                 }
                 SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFile, out int solutionVersion, out int visualStudioVersion);
 
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 052ab6a9f3a..adbb3ba25c9 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -154,6 +154,7 @@ public void Initialize(IEventSource eventSource)
         private void LogInitialInfo()
         {
             LogMessage("BinLogFilePath=" + FilePath);
+            LogMessage("CurrentUICulture=" + System.Globalization.CultureInfo.CurrentUICulture.Name);
         }
 
         private void LogMessage(string text)
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 846868e1a22..113593b7d91 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1828,4 +1828,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="NuGetAssemblyNotFound" xml:space="preserve">
     <value>A required NuGet assembly was not found. Expected Path: {0}</value>
   </data>
+  <data name="StaticGraphConstructionMetrics" xml:space="preserve">
+    <value>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</value>
+  </data>
 </root>
\ No newline at end of file
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 245e60f730e..370654db138 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Požadované sestavení NuGet se nenašlo. Očekávaná cesta: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Při odebrání pomocí MatchOnMetadata je možné odkazovat jen na jeden typ položky.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata se vztahuje pouze na operace odebrání u položek.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions je platné jen při odebírání položek pomocí MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">Klíčové slovo MyClass nejde použít vně položky &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: Statický graf přijímá pouze řešení jako jediný vstupní bod. Zjištěno více vstupních bodů: {0}</target>
+        <target state="translated">MSB4261: Bylo zjištěno více vstupních bodů s řešeními: {0}. Pokud se z řešení načte statický graf, musí být toto řešení jediným vstupním bodem.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">Statický graf se načetl za {0} s: počet uzlů: {1}, počet hraničních uzlů: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index ec4322d75e3..16260f7b5f5 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Eine erforderliche NuGet-Assembly wurde nicht gefunden. Erwarteter Pfad: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Beim Entfernen mit MatchOnMetadata kann nur ein Elementtyp referenziert werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata gilt nur für Vorgänge zum Entfernen von Elementen.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions ist nur gültig, wenn Elemente mit MatchOnMetadata entfernt werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata kann nicht außerhalb eines &lt;Ziels&gt; verwendet werden.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: Ein statischer Graph akzeptiert nur eine Projektmappe als einzigen Einstiegspunkt. Es wurden mehrere Einstiegspunkte erkannt: {0}</target>
+        <target state="translated">MSB4261: Es wurden mehrere Einstiegspunkte mit Projektmappen gefunden: {0}. Wenn ein statischer Graph aus einer Projektmappe geladen wird, muss diese Projektmappe der einzige Einstiegspunkt sein.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"Statisches Diagramm in {0} Sekunden geladen: {1} Knoten, {2} Edges"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index ca1dd2da57a..aa60e39687a 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -187,6 +187,11 @@
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="new">"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 2c081aa56d0..0662b364837 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">No se encontró un ensamblado de NuGet necesario. Ruta de acceso esperada: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Solo se puede hacer referencia a un tipo de elemento al quitarlo con MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata solo se aplica a operaciones de eliminación en elementos.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions solo es válido cuando se quitan elementos mediante MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata no se puede usar fuera de un elemento &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: Un grafo estático solo acepta una solución como único punto de entrada. Se han detectado varios puntos de entrada: {0}</target>
+        <target state="translated">MSB4261: Se detectaron varios puntos de entrada con soluciones: {0}. Si el gráfico estático se carga a partir de una solución, esa solución debe ser el único punto de entrada.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"Grafo estático cargado en {0} segundos: {1} nodos, {2} bordes"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 16a7024cede..0c7c314d134 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Un assembly NuGet obligatoire est introuvable. Chemin attendu : {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Un seul type d'élément peut être référencé pour la suppression à l'aide de MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata s'applique uniquement aux opérations de suppression sur des éléments.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions est valide uniquement pour la suppression d'éléments à l'aide de MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">Impossible d'utiliser MatchOnMetadata en dehors de &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: le graphe statique n'accepte qu'une solution comme seul point d'entrée. Plusieurs points d'entrée ont été détectés : {0}</target>
+        <target state="translated">MSB4261: détection de plusieurs points d'entrée avec des solutions : {0}. Si un graphe statique est chargé à partir d'une solution, cette solution doit être le seul point d'entrée.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"Graphe statique chargé en {0} secondes : {1} nœuds, {2} arêtes"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 7cf9c7da35c..bea41fb0d0e 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Un assembly NuGet obbligatorio non è stato trovato. Percorso previsto: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Durante la rimozione con MatchOnMetadata è possibile fare riferimento a un solo tipo di elemento.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata si applica solo a operazioni Remove su elementi.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions è valido solo quando si rimuovono elementi con MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata non può essere usato all'esterno di un elemento &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: l'unico punto di ingresso accettato dal grafo statico è una soluzione. Sono stati rilevati più punti di ingresso: {0}</target>
+        <target state="translated">MSB4261: Sono stati rilevati più punti di ingresso con le soluzioni: {0}. Se il grafo statico viene caricato da una soluzione, tale soluzione deve essere l'unico punto di ingresso.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"Il grafo statico è stato caricato in {0} secondi: {1} nodi, {2} vertici"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 269832f4806..bdb2273039f 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">必要な NuGet アセンブリが見つかりませんでした。想定されるパス: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadata で削除する場合、参照できる項目の種類は 1 つだけです。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata は、項目での削除操作にのみ適用されます。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions は、MatchOnMetadata を使用して項目を削除する場合にのみ有効です。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata を &lt;Target&gt; の外で使用することはできません。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: 静的グラフでは、ソリューションを唯一のエントリ ポイントとして受け入れるのみです。複数のエントリ ポイントが検出されました: {0}</target>
+        <target state="translated">MSB4261: ソリューションが検出されたエントリ ポイントが複数あります: {0}。静的グラフがソリューションから読み込まれる場合、そのソリューションが唯一のエントリ ポイントである必要があります。</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"{0} 秒で読み込まれた静的グラフ: {1} ノード、{2} エッジ"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index d969c555020..1abe7974cd6 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">필요한 NuGet 어셈블리를 찾을 수 없습니다. 예상 경로: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadata를 사용하여 제거하는 경우 항목 종류를 하나만 참조할 수 있습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata는 항목에 대한 제거 작업에만 적용됩니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions는 MatchOnMetadata를 사용하여 항목을 제거하는 경우에만 유효합니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata는 &lt;Target&gt; 외부에 사용할 수 없습니다.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: 정적 그래프는 유일한 진입점으로 솔루션만 허용합니다. 여러 진입점이 발견되었습니다. {0}</target>
+        <target state="translated">MSB4261: 솔루션에서 여러 진입점이 검색되었습니다. {0}. 솔루션에서 정적 그래프가 로드되는 경우 해당 솔루션이 유일한 진입점이어야 합니다.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"정적 그래프가 {0}초 안에 로드됨: {1}개 노드, {2}개 에지"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 01ed823e267..5890ec6a05e 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Nie znaleziono wymaganego zestawu NuGet. Oczekiwano ścieżki {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Tylko jeden typ elementu może być przywoływany podczas usuwania przy użyciu elementu MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">Element MatchOnMetadata ma zastosowanie tylko do operacji usuwania elementów.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">Element MatchOnMetadataOptions jest prawidłowy tylko podczas usuwania elementów przy użyciu elementu MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">Nie można użyć elementu MatchOnMetadata poza elementem &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: wykres statyczny akceptuje tylko rozwiązanie jako jedyny punkt wejścia. Wykryto wiele punktów wejścia: {0}</target>
+        <target state="translated">MSB4261: Wykryto wiele punktów wejścia z rozwiązaniami: {0}. Jeśli graf statyczny jest ładowany z rozwiązania, musi ono być jedynym punktem wejścia.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">„Wykres statyczny załadowany w {0} s, węzły: {1}, krawędzie: {2}”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 1ebadba8527..12ef60ca544 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Um assembly NuGet necessário não foi encontrado. Caminho Esperado: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">Somente um tipo de item pode ser referenciado na remoção com MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata só se aplica a operações de Remoção em itens.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions é válido somente ao remover itens usando MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata não pode ser usado fora de um &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: o grafo estático aceita apenas uma solução como o único ponto de entrada. Vários pontos de entrada detectados: {0}</target>
+        <target state="translated">MSB4261: Vários pontos de entrada com soluções detectados: {0}. Se o grafo estático for carregado de uma solução, ela precisará ser o único ponto de entrada.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"Grafo estático carregado em {0} segundos: {1} nós, {2} bordas"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
@@ -211,7 +216,7 @@
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
-        <target state="translated">MSB4181: a tarefa "{0}" retornou false, mas não registrou um erro.</target>
+        <target state="translated">MSB4181: A tarefa "{0}" retornou false, mas não registrou um erro.</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 0e8728ed6ca..62e4d151553 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Не найдена обязательная сборка NuGet. Ожидаемый путь: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">При удалении с помощью MatchOnMetadata можно ссылаться только на один тип элемента.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata применяется только к операциям удаления элементов.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions может использоваться только при удалении элементов с помощью MatchOnMetadata.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata не может использоваться вне &lt;Target&gt;.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: статический граф принимает решение только в качестве единственной точки входа. Обнаружено несколько точек входа: {0}</target>
+        <target state="translated">MSB4261: обнаружено несколько точек входа с решениями: {0}. Если статический граф загружен из решения, то это решение должно быть единственной точкой входа.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"Статический граф загружен за {0} с: узлов — {1}, ребер — {2}."</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 19de9e7a29a..bda67583870 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">Gereken NuGet derlemesi bulunamadı. Beklenen Yol: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadata ile kaldırırken yalnızca bir öğe türüne başvurulabilir.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata yalnızca öğelerdeki Kaldırma işlemleri için geçerlidir.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions yalnızca MatchOnMetadata kullanılarak öğeler kaldırılırken geçerlidir.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata bir &lt;Target&gt; dışında kullanılamaz.</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: Statik graf tek giriş noktası olarak yalnızca bir çözümü kabul eder. Birden çok giriş noktası algılandı: {0}</target>
+        <target state="translated">MSB4261: Çözümlerde birden fazla giriş noktası algılandı: {0}. Statik graf bir çözümden yükleniyorsa bu çözüm tek giriş noktası olmalıdır.</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"Statik graf {0} saniye içinde yüklendi: {1} düğüm, {2} uç"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 3b1f23c2414..2c1cb8e965d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">未找到所需的 NuGet 程序集。所需路径: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">使用 MatchOnMetadata 删除时，只能引用一个项类型。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata 仅适用于对项执行删除操作。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">MatchOnMetadataOptions 仅在使用 MatchOnMetadata 删除项时才有效。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata 不能在 &lt;Target&gt; 外部使用。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: 静态图仅接受解决方案作为唯一入口点。检测到多个入口点: {0}</target>
+        <target state="translated">MSB4261: 检测到多个具有解决方案的入口点: {0}。如果静态图表是从解决方案中加载的，则该解决方案必须是唯一的入口点。</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">“静态图形已在 {0} 秒内加载: {1} 个节点、{2} 个边”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index b8349400ff0..43d0c4ce594 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -124,7 +124,7 @@
       </trans-unit>
       <trans-unit id="NuGetAssemblyNotFound">
         <source>A required NuGet assembly was not found. Expected Path: {0}</source>
-        <target state="new">A required NuGet assembly was not found. Expected Path: {0}</target>
+        <target state="translated">找不到必要的 NuGet 元件。預期的路徑: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="NullReferenceFromProjectInstanceFactory">
@@ -137,22 +137,22 @@
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataIsRestrictedToOnlyOneReferencedItem">
         <source>Only one item type may be referenced when removing with MatchOnMetadata.</source>
-        <target state="new">Only one item type may be referenced when removing with MatchOnMetadata.</target>
+        <target state="translated">使用 MatchOnMetadata 移除時，只能參考一個項目類型。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOnlyApplicableToRemoveItems">
         <source>MatchOnMetadata only applies to Remove operations on items.</source>
-        <target state="new">MatchOnMetadata only applies to Remove operations on items.</target>
+        <target state="translated">MatchOnMetadata 只可對項目執行移除作業。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_MatchOnMetadataOptionsOnlyApplicableToItemsWithMatchOnMetadata">
         <source>MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</source>
-        <target state="new">MatchOnMetadataOptions is valid only when removing items using MatchOnMetadata.</target>
+        <target state="translated">僅當使用 MatchOnMetadata 移除項目時，MatchOnMetadataOptions 才有效。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_NoMatchOnMetadataOutsideTargets">
         <source>MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</source>
-        <target state="new">MatchOnMetadata cannot be used outside of a &lt;Target&gt;.</target>
+        <target state="translated">MatchOnMetadata 無法在 &lt;目標&gt; 之外使用。</target>
         <note />
       </trans-unit>
       <trans-unit id="OM_TargetNameNullOrEmpty">
@@ -182,11 +182,16 @@
       </trans-unit>
       <trans-unit id="StaticGraphAcceptsSingleSolutionEntryPoint">
         <source>MSB4261: Multiple entry points with solutions detected: {0}. If static graph is loaded from a solution, that that solution must be the only entry point.</source>
-        <target state="needs-review-translation">MSB4261: 靜態圖表只接受解決方案作為唯一的進入點。偵測到多個進入點: {0}</target>
+        <target state="translated">MSB4261: 偵測到解決方案有多個進入點: {0}。若是從解決方案載入靜態圖表，則該解決方案只可有一個進入點。</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
     </note>
       </trans-unit>
+      <trans-unit id="StaticGraphConstructionMetrics">
+        <source>"Static graph loaded in {0} seconds: {1} nodes, {2} edges"</source>
+        <target state="translated">"在 {0} 秒內載入的靜態圖形: {1} 個節點、{2} 個邊緣"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
         <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
@@ -211,7 +216,7 @@
       </trans-unit>
       <trans-unit id="TaskReturnedFalseButDidNotLogError">
         <source>MSB4181: The "{0}" task returned false but did not log an error.</source>
-        <target state="translated">MSB4181: "{0}" 工作傳回了 false，但並未記錄錯誤。</target>
+        <target state="translated">MSB4181: "{0}" 工作傳回了 False，但未記錄錯誤。</target>
         <note>{StrBegin="MSB4181: "}</note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 117e85acd93..3f5a1bc0b61 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -21,6 +21,8 @@ internal class NuGetFrameworkWrapper
         private static object DefaultCompatibilityProvider;
         private static PropertyInfo FrameworkProperty;
         private static PropertyInfo VersionProperty;
+        private static PropertyInfo PlatformProperty;
+        private static PropertyInfo PlatformVersionProperty;
 
         public NuGetFrameworkWrapper()
         {
@@ -39,6 +41,8 @@ public NuGetFrameworkWrapper()
                 DefaultCompatibilityProvider = NuGetFrameworkDefaultCompatibilityProvider.GetMethod("get_Instance").Invoke(null, new object[] { });
                 FrameworkProperty = NuGetFramework.GetProperty("Framework");
                 VersionProperty = NuGetFramework.GetProperty("Version");
+                PlatformProperty = NuGetFramework.GetProperty("Platform");
+                PlatformVersionProperty = NuGetFramework.GetProperty("PlatformVersion");
             }
             catch
             {
@@ -56,9 +60,19 @@ public string GetTargetFrameworkIdentifier(string tfm)
             return FrameworkProperty.GetValue(Parse(tfm)) as string;
         }
 
-        public string GetTargetFrameworkVersion(string tfm)
+        public string GetTargetFrameworkVersion(string tfm, int versionPartCount)
         {
-            return (VersionProperty.GetValue(Parse(tfm)) as Version).ToString(2);
+            return (VersionProperty.GetValue(Parse(tfm)) as Version).ToString(versionPartCount);
+        }
+
+        public string GetTargetPlatformIdentifier(string tfm)
+        {
+            return PlatformProperty.GetValue(Parse(tfm)) as string;
+        }
+
+        public string GetTargetPlatformVersion(string tfm, int versionPartCount)
+        {
+            return (PlatformVersionProperty.GetValue(Parse(tfm)) as Version).ToString(versionPartCount);
         }
 
         public bool IsCompatible(string target, string candidate)
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 0942bfb3cdb..0f547aea1fc 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -1,4 +1,5 @@
 ﻿using System;
+using System.Collections.Generic;
 using System.Diagnostics.Tracing;
 using System.Runtime.InteropServices;
 using System.Threading;
@@ -398,6 +399,18 @@ public void ExecuteTaskReacquireStop(string taskName, int taskID)
         {
             WriteEvent(52, taskName, taskID);
         }
+
+        [Event(53)]
+        public void ProjectGraphConstructionStart(string graphEntryPoints)
+        {
+            WriteEvent(53, graphEntryPoints);
+        }
+
+        [Event(54)]
+        public void ProjectGraphConstructionStop(string graphEntryPoints)
+        {
+            WriteEvent(54, graphEntryPoints);
+        }
         #endregion
     }
 }
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index e3ea73f69f8..6029f16baf0 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
-using System.IO.Pipes;
-
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Internal;
 
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 31ea76ac5d5..92cfd10bbea 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2383,7 +2383,7 @@ internal static bool ProcessNodeReuseSwitch(string[] parameters)
             enableNodeReuse = false;
 #endif
 
-            if (Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1") // For example to disable node reuse in a gated checkin, without using the flag
+            if (Traits.Instance.DisableNodeReuse) // For example to disable node reuse in a gated checkin, without using the flag
             {
                 enableNodeReuse = false;
             }
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index f37149aca5d..0d9ca6d8f34 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -48,8 +48,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.7.0.0" newVersion="16.7.0.0" />
-          <codeBase version="16.7.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.8.0.0" newVersion="16.8.0.0" />
+          <codeBase version="16.8.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
         <!-- Redirects for components dropped by Visual Studio -->
@@ -59,7 +59,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="XamlBuildTask" culture="neutral" publicKeyToken="31bf3856ad364e35" />
-          <bindingRedirect oldVersion="4.0.0.0" newVersion="16.0.0.0" />
+          <bindingRedirect oldVersion="4.0.0.0-16.0.0.0" newVersion="16.0.0.0" />
         </dependentAssembly>
 
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 7e595eacfc0..07b6a964c1c 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -49,13 +49,13 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="XamlBuildTask" culture="neutral" publicKeyToken="31bf3856ad364e35" />
-          <bindingRedirect oldVersion="4.0.0.0" newVersion="16.0.0.0" />
+          <bindingRedirect oldVersion="4.0.0.0-16.0.0.0" newVersion="16.0.0.0" />
           <codeBase version="16.0.0.0" href=".\amd64\XamlBuildTask.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.7.0.0" newVersion="16.7.0.0" />
-          <codeBase version="16.7.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.8.0.0" newVersion="16.8.0.0" />
+          <codeBase version="16.8.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index 26f7c644e4f..ed4b8f3098d 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -46,6 +46,11 @@ internal class AssemblyFoldersEx : IEnumerable<AssemblyFoldersExInfo>
         /// </summary>
         private List<AssemblyFoldersExInfo> _directoryNames = new List<AssemblyFoldersExInfo>();
 
+        /// <summary>
+        /// Set of unique paths to directories found from the registry
+        /// </summary>
+        private HashSet<string> _uniqueDirectoryPaths = new HashSet<string>();
+
         /// <summary>
         /// Construct.
         /// </summary>
@@ -258,6 +263,7 @@ OpenBaseKey openBaseKey
 
                     if (null != directoryName)
                     {
+                        _uniqueDirectoryPaths.Add(directoryName);
                         _directoryNames.Add(new AssemblyFoldersExInfo(hive, view, directoryKey.RegistryKey, directoryName, directoryKey.TargetFrameworkVersion));
                     }
                 }
@@ -483,6 +489,11 @@ IEnumerator IEnumerable.GetEnumerator()
         {
             return ((IEnumerable<AssemblyFoldersExInfo>)this).GetEnumerator();
         }
+
+        internal IEnumerable<string> UniqueDirectoryPaths
+        {
+            get => _uniqueDirectoryPaths;
+        }
     }
 }
 #endif
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 35131046269..2bb61d35127 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -330,14 +330,16 @@ internal static long GetHostHandshake(HandshakeOptions nodeType)
 
             Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", nodeType={2}, FileVersionHash={3}", salt, toolsDirectory, nodeType, FileVersionHash);
 
-            //FileVersionHash (32 bits) is shifted 8 bits to avoid session ID collision
-            //nodeType (4 bits) is shifted just after the FileVersionHash
-            //nodeHandshakeSalt (32 bits) is shifted just after hostContext
-            //the most significant byte (leftmost 8 bits) will get zero'd out to avoid connecting to older builds.
-            //| masked out | nodeHandshakeSalt | hostContext |              fileVersionHash             | SessionID
-            //  0000 0000     0000 0000 0000        0000        0000 0000 0000 0000 0000 0000 0000 0000   0000 0000
-            long baseHandshake = ((long)nodeHandshakeSalt << 44) | ((long)nodeType << 40) | ((long)FileVersionHash << 8);
-            return GenerateHostHandshakeFromBase(baseHandshake);
+            // FileVersionHash (32 bits) is shifted 8 bits to avoid session ID collision
+            // HandshakeOptions (5 bits) is shifted just after the FileVersionHash
+            // remaining bits of nodeHandshakeSalt (32 bits truncated to 11) are shifted next
+            //      nodeHandshakeSalt    | HandshakeOptions |             fileVersionHash           | SessionID
+            //  0000 0000 0000 0000 000        0 0000        0000 0000 0000 0000 0000 0000 0000 0000  0000 0000
+            unchecked
+            {
+                ulong baseHandshake = ((ulong)(uint)nodeHandshakeSalt << 45) | ((ulong)(uint)nodeType << 40) | ((ulong)(uint)FileVersionHash << 8);
+                return GenerateHostHandshakeFromBase((long)baseHandshake);
+            }
         }
 
         /// <summary>
diff --git a/src/Shared/INodePacketFactory.cs b/src/Shared/INodePacketFactory.cs
index cd12cea3b3e..6b94bf0ef1c 100644
--- a/src/Shared/INodePacketFactory.cs
+++ b/src/Shared/INodePacketFactory.cs
@@ -1,10 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-using System.Text;
-using Microsoft.Build.Framework;
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
diff --git a/src/Shared/INodePacketHandler.cs b/src/Shared/INodePacketHandler.cs
index 22ac1e5a40e..2b37942271e 100644
--- a/src/Shared/INodePacketHandler.cs
+++ b/src/Shared/INodePacketHandler.cs
@@ -1,9 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
-using System.Text;
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 8f24e1c56c8..05b8ae7a4a5 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -2,22 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 #if CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Concurrent;
 #else
 using System.Collections.Concurrent;
 #endif
-using System.Globalization;
-using System.Text;
 using System.IO;
 using System.IO.Pipes;
 using System.Threading;
-using System.Diagnostics;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY
 using System.Security.AccessControl;
 #endif
diff --git a/src/Shared/NodePacketFactory.cs b/src/Shared/NodePacketFactory.cs
index e79b995a5c3..25d4851fc82 100644
--- a/src/Shared/NodePacketFactory.cs
+++ b/src/Shared/NodePacketFactory.cs
@@ -1,11 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 00a783fd1db..da68649da45 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: Soubor filtru řešení v {0} obsahuje projekt {1}, který není v souboru řešení v {2}.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: JSON v souboru filtru řešení {0} má nesprávný formát.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: Soubor filtru řešení v {0} určuje, že v {1} se bude nacházet soubor řešení, ale tento soubor neexistuje.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index e3bd8284ae0..a50d17cb12b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: Die Projektmappenfilter-Datei unter "{0}" enthält das Projekt "{1}", das in der Projektmappendatei unter "{2}" nicht enthalten ist.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: JSON in der Projektmappenfilter-Datei "{0}" ist falsch formatiert.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: Die Projektmappenfilter-Datei unter "{0}" gibt an, dass eine Projektmappendatei unter "{1}" vorhanden ist. Diese Datei ist jedoch nicht vorhanden.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 0860cf5f017..826677d1ee6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: El archivo de filtro de soluciones en "{0}" incluye el proyecto "{1}", que no está en el archivo de solución en "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: El formato JSON del archivo de filtro de soluciones "{0}" no es correcto.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: El archivo de filtro de soluciones en "{0}" especifica que habrá un archivo de solución en "{1}", pero ese archivo no existe.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index b0ee0eaf271..547f7a28e07 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: le fichier de filtre de solution sur "{0}" inclut le projet "{1}", qui ne figure pas dans le fichier solution sur "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: les données JSON du fichier de filtre de solution "{0}" sont dans un format incorrect.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: le fichier de filtre de solution sur "{0}" spécifie l'existence d'un fichier solution sur "{1}", mais ce fichier n'existe pas.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index fa13a591797..d6dd6d83bf3 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: il file di filtro della soluzione in "{0}" include il progetto "{1}" che non è presente nel file di soluzione in "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: il codice JSON nel file di filtro della soluzione "{0}" non è formattato correttamente.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: nel file di filtro della soluzione in "{0}" è indicata la presenza di un file di soluzione in "{1}", ma tale file non esiste.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index d4c5be36d60..8819383842b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -4,67 +4,47 @@
     <body>
       <trans-unit id="BuildAborted">
         <source>MSB4188: Build was canceled.</source>
-        <target state="new">MSB4188: Build was canceled.</target>
+        <target state="translated">MSB4188: ビルドが取り消されました。</target>
         <note>{StrBegin="MSB4188: "} Error when the build stops suddenly for some reason. For example, because a child node died.</note>
       </trans-unit>
       <trans-unit id="BuildEngineCallbacksInTaskHostUnsupported">
         <source>MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</source>
-        <target state="new">MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</target>
+        <target state="translated">MSB5022: MSBuild タスク ホストは、IBuildEngine コールバックを実行するタスクの実行をサポートしていません。これらの操作を実行する場合は、タスクをコア MSBuild プロセスで実行してください。UsingTask の属性として設定されている "Runtime" または "Architecture" の値、あるいはタスク呼び出しの属性として設定されている "MSBuildRuntime" または "MSBuildArchitecture" の値が MSBuild の現在のランタイムまたはアーキテクチャと一致しない場合、タスクは自動的にタスク ホストで実行されます。</target>
         <note>{StrBegin="MSB5022: "} "Runtime", "Architecture", "MSBuildRuntime", and "MSBuildArchitecture" are all attributes in the project file, and thus should not be localized.</note>
       </trans-unit>
       <trans-unit id="BuildStarted">
         <source>Build started.</source>
-        <target state="new">Build started.</target>
+        <target state="translated">ビルドを開始しました。</target>
         <note />
       </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
-        <target state="new">MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</target>
+        <target state="translated">MSB4008: タスク アセンブリ "{0}" に対して競合しているアセンブリが "{1}" で見つかりました。</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
-      <trans-unit id="DirectoryNotFound">
-        <source>Could not find directory path: {0}</source>
-        <target state="new">Could not find directory path: {0}</target>
-        <note>Directory must exist</note>
-      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
-        <target state="new">Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</target>
+        <target state="translated">イベントの種類 "{0}" は .NET シリアライザーを使用してシリアル化可能であることが想定されていましたが、シリアル化可能でなかったため無視されました。</target>
         <note />
       </trans-unit>
       <trans-unit id="FileLocation">
         <source>{0} ({1},{2})</source>
-        <target state="new">{0} ({1},{2})</target>
+        <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
-        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
-        <target state="new">When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</target>
-        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
-        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
-        <target state="new">.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
-        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
-        <target state="new">.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
-        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
-        <target state="new">Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</target>
-        <note />
+      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
+        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
+        <target state="translated">親ノードから受け取った環境をタスク ホストに適用する前に、次の変更を行っています:</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
-      <trans-unit id="InvalidLogFileFormat">
-        <source>MSB4233: There was an exception while reading the log file: {0}</source>
-        <target state="new">MSB4233: There was an exception while reading the log file: {0}</target>
-        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
+      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
+        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
+        <target state="translated">  '{0}' を親環境の値 '{2}' ではなく '{1}' に設定しています。</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
       <trans-unit id="InvalidProjectFile">
         <source>MSB4025: The project file could not be loaded. {0}</source>
-        <target state="new">MSB4025: The project file could not be loaded. {0}</target>
+        <target state="translated">MSB4025: プロジェクト ファイルを読み込めませんでした。{0}</target>
         <note>{StrBegin="MSB4025: "}UE: This message is shown when the project file given to the engine cannot be loaded because the filename/path is
     invalid, or due to lack of permissions, or incorrect XML. The project filename is not part of the message because it is
     provided separately to loggers.
@@ -72,236 +52,256 @@
       </trans-unit>
       <trans-unit id="InvalidVerbosity">
         <source>MSB4103: "{0}" is not a valid logger verbosity level.</source>
-        <target state="new">MSB4103: "{0}" is not a valid logger verbosity level.</target>
+        <target state="translated">MSB4103: "{0}" は有効なロガー詳細レベルではありません。</target>
         <note>{StrBegin="MSB4103: "}</note>
       </trans-unit>
       <trans-unit id="MissingProject">
         <source>MSBuild is expecting a valid "{0}" object.</source>
-        <target state="new">MSBuild is expecting a valid "{0}" object.</target>
+        <target state="translated">MSBuild は有効な "{0}" オブジェクトを必要としています。</target>
         <note />
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
-        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
-        <target state="new">Making the following modifications to the environment received from the parent node before applying it to the task host:</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="Shared.PathTooLong">
+        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
+        <target state="translated">パス: {0} は OS のパスの上限を越えています。完全修飾のファイル名は {1} 文字以下にする必要があります。</target>
+        <note />
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
-        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
-        <target state="new">  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="translated">MSB5028: "{0}" のソリューション フィルター ファイルには、"{2}" のソリューション ファイルにないプロジェクト "{1}" が含まれています。</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="translated">MSB5025: ソリューション フィルター ファイル "{0}" の JSON の形式が正しくありません。</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="translated">MSB5026: "{0}" のソリューション フィルター ファイルでは、"{1}" にソリューション ファイルを配置するように指定されていますが、そのファイルは存在しません。</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="UnrecognizedToolsVersion">
+        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
+        <target state="translated">MSB4132: ツール バージョン "{0}" が認識されません。使用可能なツール バージョンは {1} です。</target>
+        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
       </trans-unit>
       <trans-unit id="NameInvalid">
         <source>MSB5016: The name "{0}" contains an invalid character "{1}".</source>
-        <target state="new">MSB5016: The name "{0}" contains an invalid character "{1}".</target>
+        <target state="translated">MSB5016: 名前 "{0}" は無効な文字 "{1}" を含んでいます。</target>
         <note>{StrBegin="MSB5016: "}</note>
       </trans-unit>
-      <trans-unit id="OM_NotSupportedReadOnlyCollection">
-        <source>This collection is read-only.</source>
-        <target state="new">This collection is read-only.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
-        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
-        <target state="new">MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</target>
-        <note>{StrBegin="MSB5024: "}</note>
-      </trans-unit>
       <trans-unit id="Shared.CannotChangeItemSpecModifiers">
         <source>"{0}" is a reserved item metadata, and cannot be modified or deleted.</source>
-        <target state="new">"{0}" is a reserved item metadata, and cannot be modified or deleted.</target>
+        <target state="translated">"{0}" は予約された項目メタデータです。変更または削除することはできません。</target>
         <note>UE: Tasks and OM users are not allowed to remove or change the value of the built-in metadata on items e.g. the meta-data "FullPath", "RelativeDir", etc. are reserved.</note>
       </trans-unit>
       <trans-unit id="Shared.CannotConvertStringToBool">
         <source>The string "{0}" cannot be converted to a boolean (true/false) value.</source>
-        <target state="new">The string "{0}" cannot be converted to a boolean (true/false) value.</target>
+        <target state="translated">文字列 "{0}" をブール値 (true/false) に変換することはできません。</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.FailedCreatingTempFile">
         <source>MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</source>
-        <target state="new">MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</target>
+        <target state="translated">MSB5003: 一時ファイルを作成できませんでした。一時ファイル フォルダーがいっぱいであるか、またはそのパスが正しくありません。{0}</target>
         <note>{StrBegin="MSB5003: "}</note>
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1}</target>
+        <target state="translated">MSB5018: 一時ファイル "{0}" を削除できませんでした。{1}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
         <source>The item metadata "%({0})" cannot be applied to the path "{1}". {2}</source>
-        <target state="new">The item metadata "%({0})" cannot be applied to the path "{1}". {2}</target>
+        <target state="translated">項目メタデータ "%({0})" をパス "{1}" に適用できません。{2}</target>
         <note>UE: This message is shown when the user tries to perform path manipulations using one of the built-in item metadata e.g. %(RootDir), on an item-spec that's not a valid path. LOCALIZATION: "{2}" is a localized message from a CLR/FX exception.</note>
       </trans-unit>
-      <trans-unit id="Shared.InvalidProjectFile">
-        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
-        <target state="new">MSB5019: The project file is malformed: "{0}". {1}</target>
-        <note>{StrBegin="MSB5019: "}</note>
+      <trans-unit id="TaskNotMarshalByRef">
+        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
+        <target state="translated">MSB4077: "{0}" タスクに属性 LoadInSeparateAppDomain が設定されていますが、MarshalByRefObject から派生していません。そのタスクが MarshalByRefObject または AppDomainIsolatedTask から派生していることを確認してください。</target>
+        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
+        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
+        <target state="translated">.NET Framework のバージョン "{0}" はサポートされていません。列挙 Microsoft.Build.Utilities.TargetDotNetFrameworkVersion から値を指定してください。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
+        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
+        <target state="translated">Windows SDK を明示的にターゲットとする場合、.NET Framework のバージョン "{0}" はサポートされません。Windows SDK は、.NET 4.5 以降でのみサポートされています。列挙 Microsoft.Build.Utilities.TargetDotNetFrameworkVersion から Version45 以上の値を指定してください。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
+        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
+        <target state="translated">Visual Studio のバージョン "{0}" はサポートされていません。列挙 Microsoft.Build.Utilities.VisualStudioVersion から値を指定してください。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
+        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
+        <target state="translated">参照アセンブリ パスをパス "{0}" とフレームワーク モニカー "{1}" から生成しようとしたときに、エラーが発生しました。{2}</target>
+        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
+      </trans-unit>
+      <trans-unit id="DirectoryNotFound">
+        <source>Could not find directory path: {0}</source>
+        <target state="translated">ディレクトリ パスが見つかりませんでした: {0}</target>
+        <note>Directory must exist</note>
+      </trans-unit>
+      <trans-unit id="UnauthorizedAccess">
+        <source>You do not have access to: {0}</source>
+        <target state="translated">{0} へのアクセス権がありません</target>
+        <note>Directory must have access</note>
+      </trans-unit>
+      <trans-unit id="SubCategoryForSchemaValidationErrors">
+        <source>Schema validation</source>
+        <target state="translated">スキーマの検証</target>
+        <note>
+      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
+      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
+      "MSBUILD : Schema validation error MSB0000: This is an error."
+      LOCALIZATION: This fragment needs to be localized.
+    </note>
       </trans-unit>
       <trans-unit id="Shared.KillingProcess">
         <source>MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</source>
-        <target state="new">MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</target>
+        <target state="translated">MSB5002: 実行可能なタスク "{0}" は、指定された制限 ({1} ミリ秒) 内で完了しなかったため、終了しています。</target>
         <note>{StrBegin="MSB5002: "}</note>
       </trans-unit>
-      <trans-unit id="Shared.KillingProcessByCancellation">
-        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
-        <target state="new">MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</target>
-        <note>{StrBegin="MSB5021: "}</note>
-      </trans-unit>
       <trans-unit id="Shared.ParameterCannotBeNull">
         <source>Parameter "{0}" cannot be null.</source>
-        <target state="new">Parameter "{0}" cannot be null.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
-        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
-        <target state="new">Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</target>
+        <target state="translated">パラメーター "{0}" を null にすることはできません。</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParameterCannotHaveZeroLength">
         <source>Parameter "{0}" cannot have zero length.</source>
-        <target state="new">Parameter "{0}" cannot have zero length.</target>
+        <target state="translated">パラメーター "{0}" の長さを 0 にすることはできません。</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParametersMustHaveTheSameLength">
         <source>Parameters "{0}" and "{1}" must have the same number of elements.</source>
-        <target state="new">Parameters "{0}" and "{1}" must have the same number of elements.</target>
+        <target state="translated">パラメーター "{0}" と "{1}" の要素数は同じである必要があります。</target>
         <note />
       </trans-unit>
-      <trans-unit id="Shared.PathTooLong">
-        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
-        <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
-        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
-        <target state="new">MSB5020: Could not load the project file: "{0}". {1}</target>
-        <note>{StrBegin="MSB5020: "}</note>
-      </trans-unit>
       <trans-unit id="Shared.TaskResourceNotFound">
         <source>The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</source>
-        <target state="new">The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</target>
+        <target state="translated">"{1}" タスクのリソース文字列 "{0}" が見つかりません。リソース名 "{0}" のスペルが正しいこと、およびリソースがタスクのアセンブリ内に存在することを確認してください。</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.TaskResourcesNotRegistered">
         <source>The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</source>
-        <target state="new">The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</target>
+        <target state="translated">"{0}" タスクのリソースが登録されていません。"TaskLoggingHelper.FormatResourceString()" メソッドを使用するためには、構築時に、または "TaskResources" プロパティを通じて、このタスクのリソースを登録する必要があります。</target>
         <note>LOCALIZATION: "TaskLoggingHelper.FormatResourceString()" and "TaskResources" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="SolutionParseDuplicateProject">
         <source>MSB5004: The solution file has two projects named "{0}".</source>
-        <target state="new">MSB5004: The solution file has two projects named "{0}".</target>
+        <target state="translated">MSB5004: ソリューション ファイルには "{0}" という名前のプロジェクトが 2 つあります。</target>
         <note>{StrBegin="MSB5004: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameCharacters">
         <source>MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</source>
-        <target state="new">MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</target>
+        <target state="translated">MSB5005: プロジェクト "{0}" のプロジェクト セクションを解析中にエラーが発生しました。プロジェクトのファイル名 "{1}" に無効な文字が使用されています。</target>
         <note>{StrBegin="MSB5005: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameEmpty">
         <source>MSB5006: Error parsing project section for project "{0}". The project file name is empty.</source>
-        <target state="new">MSB5006: Error parsing project section for project "{0}". The project file name is empty.</target>
+        <target state="translated">MSB5006: プロジェクト "{0}" のプロジェクト セクションを解析中にエラーが発生しました。プロジェクトのファイル名が空です。</target>
         <note>{StrBegin="MSB5006: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectSolutionConfigurationEntry">
         <source>MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="new">MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</target>
+        <target state="translated">MSB5007: ソリューション ファイル内のプロジェクト構成セクションを解析中にエラーが発生しました。エントリ "{0}" は無効です。</target>
         <note>{StrBegin="MSB5007: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidSolutionConfigurationEntry">
         <source>MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="new">MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</target>
+        <target state="translated">MSB5008: ソリューション ファイル内のソリューション構成セクションを解析中にエラーが発生しました。エントリ "{0}" は無効です。</target>
         <note>{StrBegin="MSB5008: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
+        <target state="translated">MSB5009: ソリューション ファイル内の入れ子にされたプロジェクト セクションを解析中にエラーが発生しました。</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
         <source>MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</source>
-        <target state="new">MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</target>
+        <target state="translated">MSB5023: ソリューション ファイルの入れ子になったプロジェクト セクションを解析中にエラーが発生しました。GUID "{0}" のプロジェクトは、プロジェクト "{1}" 下に入れ子として表示されていますが、ソリューション内に存在しません。</target>
         <note>{StrBegin="MSB5023: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNoHeaderError">
         <source>MSB5010: No file format header found.</source>
-        <target state="new">MSB5010: No file format header found.</target>
+        <target state="translated">MSB5010: ファイル形式のヘッダーが見つかりませんでした。</target>
         <note>{StrBegin="MSB5010: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectDepGuidError">
         <source>MSB5011: Parent project GUID not found in "{0}" project dependency section.</source>
-        <target state="new">MSB5011: Parent project GUID not found in "{0}" project dependency section.</target>
+        <target state="translated">MSB5011: 親プロジェクト GUID が "{0}" プロジェクト依存セクションで見つかりませんでした。</target>
         <note>{StrBegin="MSB5011: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectEofError">
         <source>MSB5012: Unexpected end-of-file reached inside "{0}" project section.</source>
-        <target state="new">MSB5012: Unexpected end-of-file reached inside "{0}" project section.</target>
+        <target state="translated">MSB5012: "{0}" プロジェクト セクション内で、予期しない EOF に到達しました。</target>
         <note>{StrBegin="MSB5012: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectError">
         <source>MSB5013: Error parsing a project section.</source>
-        <target state="new">MSB5013: Error parsing a project section.</target>
+        <target state="translated">MSB5013: プロジェクト セクションを解析中にエラーが発生しました。</target>
         <note>{StrBegin="MSB5013: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseVersionMismatchError">
         <source>MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</source>
-        <target state="new">MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</target>
+        <target state="translated">MSB5014: ファイル形式のバージョンを認識できません。MSBuild で読み取ることができるのは、バージョン {0}.0 ～ {1}.0 のソリューション ファイルだけです。</target>
         <note>{StrBegin="MSB5014: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseWebProjectPropertiesError">
         <source>MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</source>
-        <target state="new">MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</target>
+        <target state="translated">MSB5015: "{0}" プロジェクトの WebsiteProperties セクションからプロパティを読み取れませんでした。</target>
         <note>{StrBegin="MSB5015: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
-      <trans-unit id="SubCategoryForSchemaValidationErrors">
-        <source>Schema validation</source>
-        <target state="new">Schema validation</target>
-        <note>
-      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
-      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
-      "MSBUILD : Schema validation error MSB0000: This is an error."
-      LOCALIZATION: This fragment needs to be localized.
-    </note>
+      <trans-unit id="UnrecognizedSolutionComment">
+        <source>Unrecognized solution version "{0}", attempting to continue.</source>
+        <target state="translated">"{0}" は認識できないソリューション バージョンです。続行を試みます。</target>
+        <note />
       </trans-unit>
       <trans-unit id="SubCategoryForSolutionParsingErrors">
         <source>Solution file</source>
-        <target state="new">Solution file</target>
+        <target state="translated">ソリューション ファイル</target>
         <note>UE: this fragment is used to describe errors found while parsing solution files. For example, if a normal error is
       displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from solution parsing would look like this:
       "MSBUILD : Solution file error MSB0000: This is an error."
       LOCALIZATION: This fragment needs to be localized.</note>
       </trans-unit>
-      <trans-unit id="TaskNotMarshalByRef">
-        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="new">MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</target>
-        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
+      <trans-unit id="Shared.InvalidProjectFile">
+        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
+        <target state="translated">MSB5019: プロジェクト ファイルの形式が正しくありません: "{0}"。{1}</target>
+        <note>{StrBegin="MSB5019: "}</note>
       </trans-unit>
-      <trans-unit id="UnauthorizedAccess">
-        <source>You do not have access to: {0}</source>
-        <target state="new">You do not have access to: {0}</target>
-        <note>Directory must have access</note>
+      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
+        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
+        <target state="translated">MSB5020: プロジェクト ファイル "{0}" を読み込めませんでした。{1}</target>
+        <note>{StrBegin="MSB5020: "}</note>
       </trans-unit>
-      <trans-unit id="UnrecognizedSolutionComment">
-        <source>Unrecognized solution version "{0}", attempting to continue.</source>
-        <target state="new">Unrecognized solution version "{0}", attempting to continue.</target>
+      <trans-unit id="Shared.KillingProcessByCancellation">
+        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
+        <target state="translated">MSB5021: ビルドが取り消されたため、実行可能なタスク "{0}" とその子プロセスを終了しています。</target>
+        <note>{StrBegin="MSB5021: "}</note>
+      </trans-unit>
+      <trans-unit id="OM_NotSupportedReadOnlyCollection">
+        <source>This collection is read-only.</source>
+        <target state="translated">このコレクションは読み取り専用です。</target>
         <note />
       </trans-unit>
-      <trans-unit id="UnrecognizedToolsVersion">
-        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
-        <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
-        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
+      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
+        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
+        <target state="translated">MSB5024: MSBuild への有効な場所が決定できませんでした。Visual Studio の開発者コマンド プロンプトからこのプロセスを実行してください。</target>
+        <note>{StrBegin="MSB5024: "}</note>
+      </trans-unit>
+      <trans-unit id="InvalidLogFileFormat">
+        <source>MSB4233: There was an exception while reading the log file: {0}</source>
+        <target state="translated">MSB4233: ログ ファイルの読み取り中に例外が発生しました: {0}</target>
+        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
+      </trans-unit>
+      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
+        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
+        <target state="translated">値 "{1}" が割り当てられたパラメーター "{0}" には、無効なパスまたは無効なファイル内の文字を指定することはできません。</target>
+        <note />
       </trans-unit>
     </body>
   </file>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 0a9784913d7..283d44b5076 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: "{0}"의 솔루션 필터 파일에 "{2}"의 솔루션 파일에 없는 "{1}" 프로젝트가 포함되어 있습니다.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: 솔루션 필터 파일 "{0}"의 Json 형식이 잘못되었습니다.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: "{0}"의 솔루션 필터 파일이 "{1}"에 솔루션 파일이 있도록 지정하지만, 해당 파일이 없습니다.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 6d6f964b8a2..394f3cca893 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: Plik filtru rozwiązania w lokalizacji „{0}” obejmuje projekt „{1}”, który nie znajduje się w pliku rozwiązania w lokalizacji „{2}”.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: Kod JSON w pliku filtru rozwiązania „{0}” jest niepoprawnie sformatowany.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: Plik filtru rozwiązania w lokalizacji „{0}” określa, że plik rozwiązania będzie się znajdował w lokalizacji „{1}”, ale ten plik nie istnieje.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index f2b419f77df..5b91a379052 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: o arquivo de filtro da solução em "{0}" inclui o projeto "{1}" que não está no arquivo da solução em "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: o JSON no arquivo de filtro da solução "{0}" está formatado incorretamente.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: o arquivo de filtro da solução em "{0}" especifica que haverá um arquivo de solução em "{1}", mas esse arquivo não existe.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 111a49830f4..0399406e0a6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: файл фильтра решения в "{0}" включает проект "{1}", который отсутствует в файле решения в "{2}".</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: код JSON в файле фильтра решения "{0}" имеет неправильный формат.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: файл фильтра решения в "{0}" указывает на то, что в "{1}" будет находиться файл решения, однако этот файл отсутствует.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index b0b741a3960..d17522e92d2 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: "{0}" konumundaki çözüm filtresi dosyası, "{2}" konumundaki çözüm dosyasında bulunmayan "{1}" projesini içeriyor.</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: "{0}" çözüm filtresi dosyasındaki JSON hatalı biçimlendirilmiş.</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: "{0}" konumundaki çözüm filtresi dosyası, "{1}" konumunda bir çözüm dosyası olacağını belirtiyor, ancak bu dosya mevcut değil.</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 398938a8677..ada4552472c 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: 位于“{0}”的解决方案筛选器文件包含“{2}”处的解决方案文件中没有的项目“{1}”。</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: 解决方案筛选器文件“{0}”中的 JSON 的格式不正确。</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: 位于“{0}”的解决方案筛选器文件指定“{1}”处将存在一个解决方案文件，但该文件不存在。</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 418a2c2a06b..93035219c43 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -67,17 +67,17 @@
       </trans-unit>
       <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
         <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <target state="translated">MSB5028: 位於 "{0}" 的解決方案篩選檔案包含專案 "{1}"，該專案不在位於 "{2}" 的解決方案檔案中。</target>
         <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterJsonParsingError">
         <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <target state="translated">MSB5025: 解決方案篩選檔案 "{0}" 中的 Json 格式不正確。</target>
         <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionFilterMissingSolutionError">
         <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <target state="translated">MSB5026: 位於 "{0}" 的解決方案篩選檔案指定將會有位於 "{1}" 的解決方案檔案，但該檔案並不存在。</target>
         <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 199d46eefb2..9f031270a1f 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -5,9 +5,6 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
-using System.Linq;
-using System.Threading;
-using System.Text;
 
 using Microsoft.Build.Shared;
 using System.Reflection;
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index f826bb92f90..d2b59ce5c80 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -94,6 +94,11 @@ public Traits()
         /// </summary>
         public readonly int LogPropertyTracking = ParseIntFromEnvironmentVariableOrDefault("MsBuildLogPropertyTracking", 0); // Default to logging nothing via the property tracker.
 
+        /// <summary>
+        /// Setting this environment variable to 1 disables the node reuse feature.
+        /// </summary>
+        public readonly bool DisableNodeReuse = Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1";
+
         private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVariable, int defaultValue)
         {
             return int.TryParse(Environment.GetEnvironmentVariable(environmentVariable), out int result)
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 62db95267d0..b7b47a4e20e 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -243,7 +243,10 @@ public static void AssertItems(string[] expectedItems, IList<TestItem> items, Di
                 expectedItems.ShouldNotBeEmpty();
             }
 
-            for (var i = 0; i < expectedItems.Length; i++)
+            // iterate to the minimum length; if the lengths don't match but there's a prefix match the count assertion below will trigger
+            int minimumLength = Math.Min(expectedItems.Length, items.Count);
+
+            for (var i = 0; i < minimumLength; i++)
             {
                 if (!normalizeSlashes)
                 {
@@ -258,7 +261,8 @@ public static void AssertItems(string[] expectedItems, IList<TestItem> items, Di
                 AssertItemHasMetadata(expectedDirectMetadataPerItem[i], items[i]);
             }
 
-            items.Count.ShouldBe(expectedItems.Length);
+            items.Count.ShouldBe(expectedItems.Length,
+                () => $"got items \"{string.Join(", ", items)}\", expected \"{string.Join(", ", expectedItems)}\"");
 
             expectedItems.Length.ShouldBe(expectedDirectMetadataPerItem.Length);
         }
@@ -422,7 +426,7 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
         {
             expected ??= new Dictionary<string, string>();
 
-            item.DirectMetadataCount.ShouldBe(expected.Keys.Count);
+            item.DirectMetadataCount.ShouldBe(expected.Keys.Count, () => $"Expected {expected.Keys.Count} metadata, ({string.Join(", ", expected.Keys)}), got {item.DirectMetadataCount}");
 
             foreach (var key in expected.Keys)
             {
diff --git a/src/Shared/WeakStringCache.Concurrent.cs b/src/Shared/WeakStringCache.Concurrent.cs
index 310964fdd2d..bf9c6ed8ca3 100644
--- a/src/Shared/WeakStringCache.Concurrent.cs
+++ b/src/Shared/WeakStringCache.Concurrent.cs
@@ -28,16 +28,12 @@ public WeakStringCache()
         /// <param name="internable">The internable describing the string we're looking for.</param>
         /// <returns>A string matching the given internable.</returns>
         /// <remarks>
-        /// This method performs one operation on the underlying ConcurrentDictionary on cache hit, and two or three operations on cache miss.
-        /// 1. It checks whether the dictionary has a matching entry. This operations is common to all code paths.
-        ///    If there is a matching entry we are done.
-        /// 2. If the dictionary doesn't have an entry for the given hash code, we make a new one and add it (the second operation).
-        ///    Note that we could do 1. and 2. together using GetOrAdd() with the valueFactory callback but it wouldn't be much faster
-        ///    and would require allocating a closure object to share data with the callback.
-        /// 3. If the dictionary has an entry for the given hash code but it doesn't match the argument because it's either already
-        ///    collected or there is a hash collision, we have to first remove the existing handle to prevent other threads from
-        ///    freeing it (second operation). Only then can it have the target set to the new string and be added back to the dictionary
-        ///    (third operation).
+        /// This method performs two operations on the underlying ConcurrentDictionary on both cache hit and cache miss.
+        /// 1. It checks whether the dictionary has a matching entry. The entry is temporarily removed from the cache so it doesn't
+        ///    race with Scavenge() freeing GC handles. This is the first operation.
+        /// 2a. If there is a matching entry, we extract the string out of it and put it back in the cache (the second operation).
+        /// 2b. If there is an entry but it doesn't match, or there is no entry for the given hash code, we extract the string from
+        ///     the internable, set it on the entry, and add the entry (back) in the cache.
         /// </remarks>
         public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IInternable
         {
@@ -47,11 +43,19 @@ public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IIn
             string result;
             bool addingNewHandle = false;
 
-            if (_stringsByHashCode.TryGetValue(hashCode, out handle))
+            // Get the existing handle from the cache and assume ownership by removing it. We can't use the simple TryGetValue() here because
+            // the Scavenge method running on another thread could free the handle from underneath us.
+            if (_stringsByHashCode.TryRemove(hashCode, out handle))
             {
                 result = handle.GetString(internable);
                 if (result != null)
                 {
+                    // We have a hit, put the handle back in the cache.
+                    if (!_stringsByHashCode.TryAdd(hashCode, handle))
+                    {
+                        // Another thread has managed to add a handle for the same hash code, so the one we got can be freed.
+                        handle.Free();
+                    }
                     cacheHit = true;
                     return result;
                 }
@@ -65,39 +69,37 @@ public string GetOrCreateEntry<T>(T internable, out bool cacheHit) where T : IIn
             // We don't have the string in the cache - create it.
             result = internable.ExpensiveConvertToString();
 
-            // If the handle is new, we have to add it to the cache. We do it after removing unused handles if our heuristic
-            // indicates that it would be productive. Note that the _capacity field accesses are not protected from races. Being
-            // atomic (as guaranteed by the 32-bit data type) is enough here.
+            // Set the handle to reference the new string and put it in the cache.
+            handle.SetString(result);
+            if (!_stringsByHashCode.TryAdd(hashCode, handle))
+            {
+                // Another thread has managed to add a handle for the same hash code, so the one we got can be freed.
+                handle.Free();
+            }
+
+            // Remove unused handles if our heuristic indicates that it would be productive. Note that the _scavengeThreshold field
+            // accesses are not protected from races. Being atomic (as guaranteed by the 32-bit data type) is enough here.
             if (addingNewHandle)
             {
                 // Prevent the dictionary from growing forever with GC handles that don't reference live strings anymore.
                 if (_stringsByHashCode.Count >= _scavengeThreshold)
                 {
-                    // Get rid of unused handles.
-                    Scavenge();
-                    // And do this again when the number of handles reaches double the current after-scavenge number.
-                    _scavengeThreshold = _stringsByHashCode.Count * 2;
-                }
-            }
-            else
-            {
-                // If the handle is already in the cache, we have to be careful because other threads may be operating on it.
-                // In particular the Scavenge method may free the handle from underneath us if we leave it in the cache.
-                if (!_stringsByHashCode.TryRemove(hashCode, out handle))
-                {
-                    // The handle is no longer in the cache so we're creating a new one after all.
-                    handle = new StringWeakHandle();
+                    // Before we start scavenging set _scavengeThreshold to a high value to effectively lock other threads from
+                    // running Scavenge at the same time (minus rare races).
+                    _scavengeThreshold = int.MaxValue;
+                    try
+                    {
+                        // Get rid of unused handles.
+                        Scavenge();
+                    }
+                    finally
+                    {
+                        // And do this again when the number of handles reaches double the current after-scavenge number.
+                        _scavengeThreshold = _stringsByHashCode.Count * 2;
+                    }
                 }
             }
 
-            // Set the handle to reference the new string and put it in the cache.
-            handle.SetString(result);
-            if (!_stringsByHashCode.TryAdd(hashCode, handle))
-            {
-                // If somebody beat us to it and the new handle has not been added, free it.
-                handle.Free();
-            }
-
             cacheHit = false;
             return result;
         }
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index dc63978daaf..f301ab38e41 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -307,11 +307,11 @@ internal AssemblyFoldersExCache(AssemblyFoldersEx assemblyFoldersEx, FileExists
             {
                 var lockobject = new Object();
 
-                Parallel.ForEach(assemblyFoldersEx, assemblyFolder =>
+                Parallel.ForEach(assemblyFoldersEx.UniqueDirectoryPaths, assemblyFolder =>
                 {
-                    if (FileUtilities.DirectoryExistsNoThrow(assemblyFolder.DirectoryPath))
+                    if (FileUtilities.DirectoryExistsNoThrow(assemblyFolder))
                     {
-                        string[] files = Directory.GetFiles(assemblyFolder.DirectoryPath, "*.*", SearchOption.TopDirectoryOnly);
+                        string[] files = Directory.GetFiles(assemblyFolder, "*.*", SearchOption.TopDirectoryOnly);
 
                         lock (lockobject)
                         {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index c52420b8e19..61e2a6a93e5 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1120,9 +1120,9 @@ quiet at the engine level.
                         if (assemblyFoldersEx != null && _showAssemblyFoldersExLocations.TryGetValue(r.SearchPath, out messageImportance))
                         {
                             Log.LogMessageFromResources(messageImportance, "ResolveAssemblyReference.AssemblyFoldersExSearchLocations", r.SearchPath);
-                            foreach (AssemblyFoldersExInfo info in assemblyFoldersEx)
+                            foreach (var path in assemblyFoldersEx.UniqueDirectoryPaths)
                             {
-                                Log.LogMessageFromResources(messageImportance, "ResolveAssemblyReference.EightSpaceIndent", info.DirectoryPath);
+                                Log.LogMessageFromResources(messageImportance, "ResolveAssemblyReference.EightSpaceIndent", path);
                             }
                         }
                     }
diff --git a/src/Tasks/BootstrapperUtil/Util.cs b/src/Tasks/BootstrapperUtil/Util.cs
index 8cdc63b3a37..5afd9397329 100644
--- a/src/Tasks/BootstrapperUtil/Util.cs
+++ b/src/Tasks/BootstrapperUtil/Util.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
+using Microsoft.Build.Shared;
 using Microsoft.Win32;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
@@ -19,6 +20,7 @@ internal static class Util
         private const string REGISTRY_DEFAULTPATH = "Path";
 
         private const string BOOTSTRAPPER_REGISTRY_ADDITIONAL_PACKAGE_PATHS_KEYNAME = "AdditionalPackagePaths";
+        private const string BOOTSTRAPPER_MSBUILD_ADDITIONAL_PACKAGES_PATH = "Microsoft\\VisualStudio\\BootstrapperPackages";
 
         private static string s_defaultPath;
         private static List<string> s_additionalPackagePaths;
@@ -182,6 +184,15 @@ public static List<string> AdditionalPackagePaths
                         }
                     }
 
+                    if (!string.IsNullOrEmpty(BuildEnvironmentHelper.Instance.MSBuildExtensionsPath))
+                    {
+                        string msbuildExtensionPackagesPath = Path.Combine(BuildEnvironmentHelper.Instance.MSBuildExtensionsPath, BOOTSTRAPPER_MSBUILD_ADDITIONAL_PACKAGES_PATH);
+                        if (Directory.Exists(msbuildExtensionPackagesPath))
+                        {
+                            additionalPackagePaths.Add(msbuildExtensionPackagesPath);
+                        }
+                    }
+
                     s_additionalPackagePaths = additionalPackagePaths;
                 }
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 9f6a5fae91d..b6afab6807b 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -123,6 +123,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
 
   <PropertyGroup>
+    <GenerateFullPaths Condition="'$(GenerateFullPaths)' == ''">true</GenerateFullPaths>
     <!-- Ensure any OutputPath has a trailing slash, so it can be concatenated -->
     <OutputPath Condition="'$(OutputPath)' != '' and !HasTrailingSlash('$(OutputPath)')">$(OutputPath)\</OutputPath>
     <AssemblyName Condition=" '$(AssemblyName)'=='' ">$(MSBuildProjectName)</AssemblyName>
@@ -4922,7 +4923,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
   <Target
        Name="IncrementalClean"
-       DependsOnTargets="_CleanGetCurrentAndPriorFileWrites">
+       DependsOnTargets="$(IncrementalCleanDependsOn);_CleanGetCurrentAndPriorFileWrites">
 
     <!-- Subtract list of files produced in prior builds from list of files produced in this build. -->
     <ItemGroup>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 69c726c62a4..44b9fbe1ba8 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1273,7 +1273,7 @@
       </trans-unit>
       <trans-unit id="GenerateResource.MainAssemblyMissingNeutralResourcesLanguage">
         <source>MSB3817: The assembly "{0}" does not have a NeutralResourcesLanguageAttribute on it. To be used in an app package, portable libraries must define a NeutralResourcesLanguageAttribute on their main assembly (ie, the one containing code, not a satellite assembly).</source>
-        <target state="translated">MSB3817: Für die Assembly "{0}" ist kein NeutralResourcesLanguageAttribute angegeben. Für die Verwendung in einem App-Paket müssen portable Bibliotheken ein NeutralResourcesLanguageAttribute für ihre Hauptassembly (die Assembly mit Code, keine Satellitenassembly) angeben.</target>
+        <target state="translated">MSB3817: Für die Assembly "{0}" ist kein NeutralResourcesLanguageAttribute angegeben. Für die Verwendung in einem App-Paket müssen portierbare Bibliotheken ein NeutralResourcesLanguageAttribute für ihre Hauptassembly (die Assembly mit Code, keine Satellitenassembly) angeben.</target>
         <note>{StrBegin="MSB3817: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.ExecuteAsToolAndExtractResWNotSupported">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 99cc118cd38..7ce334457fc 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="translated">MSB3474: l'attività "{0}" non è supportata nella versione .NET Core di MSBuild. Usare il pacchetto dello strumento Microsoft per la generazione di serializzatori XML. Per altre informazioni, vedere https://go.microsoft.com/fwlink/?linkid=858594.</target>
+        <target state="translated">MSB3474: l'attività "{0}" non è supportata nella versione .NET Core di MSBuild. Usare il pacchetto dello strumento del generatore di serializzatori XML Microsoft. Per altre informazioni, vedere https://go.microsoft.com/fwlink/?linkid=858594.</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index e209c62b2f7..52d2825682c 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1273,7 +1273,7 @@
       </trans-unit>
       <trans-unit id="GenerateResource.MainAssemblyMissingNeutralResourcesLanguage">
         <source>MSB3817: The assembly "{0}" does not have a NeutralResourcesLanguageAttribute on it. To be used in an app package, portable libraries must define a NeutralResourcesLanguageAttribute on their main assembly (ie, the one containing code, not a satellite assembly).</source>
-        <target state="translated">MSB3817: アセンブリ "{0}" には NeutralResourcesLanguageAttribute が設定されていません。アプリケーション パッケージ内で使用するには、ポータブル ライブラリでメインのアセンブリ (たとえば、サテライト アセンブリではなく、コードを含んでいるもの) に対して NeutralResourcesLanguageAttribute を定義する必要があります。</target>
+        <target state="translated">MSB3817: アセンブリ "{0}" には NeutralResourcesLanguageAttribute が設定されていません。アプリケーション パッケージ内で使用するには、移植可能なライブラリでメインのアセンブリ (たとえば、サテライト アセンブリではなく、コードを含んでいるもの) に対して NeutralResourcesLanguageAttribute を定義する必要があります。</target>
         <note>{StrBegin="MSB3817: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.ExecuteAsToolAndExtractResWNotSupported">
@@ -2295,7 +2295,7 @@
       </trans-unit>
       <trans-unit id="SGen.TaskNotSupported">
         <source>MSB3474: The task "{0}" is not supported on the .NET Core version of MSBuild. Use the Microsoft XML Serializer Generator package instead. See https://go.microsoft.com/fwlink/?linkid=858594 for more information.</source>
-        <target state="translated">MSB3474: タスク "{0}" は、MSBuild の .NET Core バージョンではサポートされていません。代わりに Microsoft XML Serializer Generator パッケージを使用してください。詳細については、https://go.microsoft.com/fwlink/?linkid=858594 をご覧ください。</target>
+        <target state="translated">MSB3474: タスク "{0}" は、MSBuild の .NET Core バージョンではサポートされていません。代わりに Microsoft XML Serializer ジェネレーター パッケージを使用してください。詳細については、https://go.microsoft.com/fwlink/?linkid=858594 をご覧ください。</target>
         <note>{StrBegin="MSB3474: "}</note>
       </trans-unit>
       <trans-unit id="SignFile.CertNotInStore">
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index a6281533708..be7d6f571f5 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -1033,6 +1033,9 @@ private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependenc
         /// <param name="correspondingOutputs">Outputs that correspond ot the sources (used for same file processing)</param>
         public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[] correspondingOutputs)
         {
+            // Cache of files that have been checked and exist.
+            Dictionary<string, bool> fileCache = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
+
             if (correspondingOutputs != null)
             {
                 ErrorUtilities.VerifyThrowArgument(source.Length == correspondingOutputs.Length, "Tracking_SourcesAndCorrespondingOutputMismatch");
@@ -1041,7 +1044,7 @@ public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[]
             // construct a combined root marker for the sources and outputs to remove from the graph
             string rootingMarker = FileTracker.FormatRootingMarker(source, correspondingOutputs);
 
-            RemoveDependenciesFromEntryIfMissing(rootingMarker);
+            RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);
 
             // Remove entries for each individual source
             for (int sourceIndex = 0; sourceIndex < source.Length; sourceIndex++)
@@ -1049,7 +1052,7 @@ public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[]
                 rootingMarker = correspondingOutputs != null
                     ? FileTracker.FormatRootingMarker(source[sourceIndex], correspondingOutputs[sourceIndex])
                     : FileTracker.FormatRootingMarker(source[sourceIndex]);
-                RemoveDependenciesFromEntryIfMissing(rootingMarker);
+                RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);
             }
         }
 
@@ -1057,7 +1060,8 @@ public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[]
         /// Remove the output graph entries for the given rooting marker
         /// </summary>
         /// <param name="rootingMarker"></param>
-        private void RemoveDependenciesFromEntryIfMissing(string rootingMarker)
+        /// <param name="fileCache">The cache used to store whether each file exists or not.</param>
+        private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictionary<string, bool> fileCache)
         {
             // In the event of incomplete tracking information (i.e. this root was not present), just continue quietly
             // as the user could have killed the tool being tracked, or another error occurred during its execution.
@@ -1070,8 +1074,19 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker)
                 {
                     if (keyIndex++ > 0)
                     {
-                        // If we are ignoring missing files, then only record those that exist
-                        if (FileUtilities.FileExistsNoThrow(file))
+                        // Record whether or not each file exists and cache it.
+                        // We do this to save time (On^2), at the expense of data O(n).
+                        bool inFileCache = fileCache.TryGetValue(file, out bool fileExists);
+
+                        // Have we cached the file yet? If not, cache whether or not it exists.
+                        if (!inFileCache)
+                        {
+                            fileExists = FileUtilities.FileExistsNoThrow(file);
+                            fileCache.Add(file, fileExists);
+                        }
+
+                        // Does the cached file exist?
+                        if (fileExists)
                         {
                             dependenciesWithoutMissingFiles.Add(file, dependencies[file]);
                         }
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 5c906de1683..7ca96f897c0 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -724,6 +724,9 @@ private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependenc
         /// <param name="correspondingOutputs">Outputs that correspond ot the sources (used for same file processing)</param>
         public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[] correspondingOutputs)
         {
+            // Cache of files and whether or not they exist.
+            Dictionary<string, bool> fileCache = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
+
             if (correspondingOutputs != null)
             {
                 ErrorUtilities.VerifyThrowArgument(source.Length == correspondingOutputs.Length, "Tracking_SourcesAndCorrespondingOutputMismatch");
@@ -732,21 +735,15 @@ public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[]
             // construct a combined root marker for the sources and outputs to remove from the graph
             string rootingMarker = FileTracker.FormatRootingMarker(source, correspondingOutputs);
 
-            RemoveDependenciesFromEntryIfMissing(rootingMarker);
+            RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);
 
             // Remove entries for each individual source
             for (int sourceIndex = 0; sourceIndex < source.Length; sourceIndex++)
             {
-                if (correspondingOutputs != null)
-                {
-                    rootingMarker = FileTracker.FormatRootingMarker(source[sourceIndex], correspondingOutputs[sourceIndex]);
-                }
-                else
-                {
-                    rootingMarker = FileTracker.FormatRootingMarker(source[sourceIndex]);
-                }
-
-                RemoveDependenciesFromEntryIfMissing(rootingMarker);
+                rootingMarker = correspondingOutputs != null
+                    ? FileTracker.FormatRootingMarker(source[sourceIndex], correspondingOutputs[sourceIndex])
+                    : FileTracker.FormatRootingMarker(source[sourceIndex]);
+                RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);
             }
         }
 
@@ -754,7 +751,8 @@ public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[]
         /// Remove the output graph entries for the given rooting marker
         /// </summary>
         /// <param name="rootingMarker"></param>
-        private void RemoveDependenciesFromEntryIfMissing(string rootingMarker)
+        /// <param name="fileCache">The cache used to store whether each file exists or not.</param>
+        private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictionary<string, bool> fileCache)
         {
             // In the event of incomplete tracking information (i.e. this root was not present), just continue quietly
             // as the user could have killed the tool being tracked, or another error occurred during its execution.
@@ -767,8 +765,19 @@ private void RemoveDependenciesFromEntryIfMissing(string rootingMarker)
                 {
                     if (keyIndex++ > 0)
                     {
-                        // If we are ignoring missing files, then only record those that exist
-                        if (FileUtilities.FileExistsNoThrow(file))
+                        // Record whether or not each file exists and cache it.
+                        // We do this to save time (On^2), at the expense of data O(n).
+                        bool inFileCache = fileCache.TryGetValue(file, out bool fileExists);
+
+                        // Have we cached the file yet? If not, cache its existence.
+                        if (!inFileCache)
+                        {
+                            fileExists = FileUtilities.FileExistsNoThrow(file);
+                            fileCache.Add(file, fileExists);
+                        }
+
+                        // Does the cached file exist?
+                        if (fileExists)
                         {
                             dependenciesWithoutMissingFiles.Add(file, dependencies[file]);
                         }
