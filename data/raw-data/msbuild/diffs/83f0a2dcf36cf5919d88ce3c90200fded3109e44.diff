diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 00000000000..2909e3ff6cd
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,80 @@
+{
+    // See https://go.microsoft.com/fwlink/?LinkId=733558
+    // for the documentation about the tasks.json format
+    "version": "2.0.0",
+    "tasks": [
+        {
+            "label": "dotnet msbuild MSBuild.Dev.slnf",
+            "command": "dotnet",
+            "type": "process",
+            "args": [
+                "msbuild",
+                // Ask MSBuild to generate full paths for file names.
+                "/property:GenerateFullPaths=true",
+                // Do not generate summary otherwise it leads to duplicate errors in Problems panel
+                "/consoleloggerparameters:NoSummary",
+                "${workspaceFolder}/MSBuild.Dev.slnf"
+            ],
+            "group": "build",
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        },
+        {
+            "label": "full build",
+            "command": "${workspaceFolder}/build.sh",
+            "type": "shell",
+            "windows": {
+                "command": "cmd.exe",
+                "type": "process",
+                "args": [
+                    "/d",
+                    "/c",
+                    "${workspaceFolder}/build.cmd"
+                ]
+            },
+            "args": [
+                "-bl",
+                "/property:CreateBootstrap=true",
+                "/property:GenerateFullPaths=true",
+                "/consoleloggerparameters:NoSummary"
+            ],
+            "group": "build",
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        },
+        {
+            "label": "build -test",
+            "command": "${workspaceFolder}/build.sh",
+            "type": "shell",
+            "windows": {
+                "command": "cmd.exe",
+                "type": "process",
+                "args": [
+                    "/d",
+                    "/c",
+                    "${workspaceFolder}/build.cmd"
+                ]
+            },
+            "args": [
+                "-test",
+                "/property:GenerateFullPaths=true",
+                "/consoleloggerparameters:NoSummary"
+            ],
+            "group": {
+                "kind": "test",
+                "isDefault": true
+            },
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        }
+    ]
+}
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index bbbf0897830..b6bfa572208 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -7,7 +7,7 @@ jobs:
 - job: BootstrapMSBuildOnFullFrameworkWindows
   displayName: "Windows Full"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
@@ -53,7 +53,7 @@ jobs:
 - job: BootstrapMSBuildOnCoreWindows
   displayName: "Windows Core"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
@@ -100,7 +100,7 @@ jobs:
 - job: FullReleaseOnWindows
   displayName: "Windows Full Release (no bootstrap)"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild.cmd
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 415fa36b412..c6ed508dfc8 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -52,7 +52,7 @@ stages:
 
   - job: Windows_NT
     pool:
-      name: VSEngSS-MicroBuild2019-1ES
+      name: VSEngSS-MicroBuild2022-1ES
       demands:
       - agent.os -equals Windows_NT
 
@@ -90,14 +90,14 @@ stages:
         signType: $(SignType)
         zipSources: false
       condition: and(succeeded(), in(variables['SignType'], 'test', 'real'))
-      
+
     - task: MicroBuildOptProfPlugin@6
       inputs:
         ProfilingInputsDropName: '$(VisualStudio.DropName)'
         ShouldSkipOptimize: true
         AccessToken: '$(System.AccessToken)'
         feedSource: 'https://devdiv.pkgs.visualstudio.com/DefaultCollection/_packaging/MicroBuildToolset/nuget/v3/index.json'
-      displayName: 'Install OptProf Plugin'      
+      displayName: 'Install OptProf Plugin'
 
     # Required by MicroBuildBuildVSBootstrapper
     - task: ms-vseng.MicroBuildTasks.32f78468-e895-4f47-962c-58a699361df8.MicroBuildSwixPlugin@1
diff --git a/documentation/Built-in-Propeties.md b/documentation/Built-in-Propeties.md
new file mode 100644
index 00000000000..01c880aeb56
--- /dev/null
+++ b/documentation/Built-in-Propeties.md
@@ -0,0 +1,21 @@
+# MSBuild's reserved and built-in properties
+
+The MSBuild engine itself sets some properties for all projects. There is normal documentation for the [reserved properties and their meanings](https://docs.microsoft.com/visualstudio/msbuild/msbuild-reserved-and-well-known-properties). This document describes the implementation of these properties in MSBuild itself.
+
+There are actually two different implementations of this functionality in MSBuild.
+
+## Built-in properties
+
+When evaluating an individual project, Pass 0 of the evaluation calls [`AddBuiltInProperties()`][addbuiltinproperties] which in turn calls [`SetBuiltInProperty()`][setbuiltinproperty] which sets the property basically as normal.
+
+However, properties set there are not available at all parts of execution, and specifically they're not available when evaluating the `.tasks` file that makes MSBuild's built-in tasks available by default to all projects.
+
+## Reserved properties
+
+Reserved properties are [set by the toolset][toolset_reservedproperties] and are available _only_ in the `.tasks` and `.overridetasks` cases. Properties set there are not available in normal project evaluation.
+
+[addbuiltinproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L609-L612
+
+[setbuiltinproperty]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L1257
+
+[toolset_reservedproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Definition/Toolset.cs#L914-L921
diff --git a/documentation/Changelog.md b/documentation/Changelog.md
index 19f97e2e2e7..be02ae3e952 100644
--- a/documentation/Changelog.md
+++ b/documentation/Changelog.md
@@ -1,5 +1,104 @@
 # MSBuild Changelog
 
+## MSBuild 17.0.0
+
+This version of MSBuild shipped with Visual Studio 2022 version 17.0.0 and .NET SDK 6.0.100.
+
+### What's new
+
+* MSBuild now reports its version as `17` and uses Visual Studio 2022 versions of tasks where appropriate.
+* MSBuild now targets .NET Framework 4.7.2 and .NET 6.0.
+* 64-bit MSBuild is now used for builds from Visual Studio.
+* Binary logs are smaller and have more information.
+* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds.
+* The method `GetType()` can no longer be called in property functions.
+
+### Detailed release notes
+
+#### Added
+
+* Intrinsic tasks now log their location (#6397). Thanks, @KirillOsenkov!
+* `TargetSkippedEventArgs` now has `TargetSkipReason` and `OriginalBuildEventContext` (#6402, #6577). Thanks, @KirillOsenkov!
+* `TaskStarted` events now log line and column (#6399). Thanks, @KirillOsenkov!
+* ETW trace events for PerformDependencyAnalysis (#6658), WriteLinesToFile (#6670), CopyUpToDate (#6661).
+* If the environment variable `MSBuildDebugEngine` is set, MSBuild will create binary logs for all operations to `MSBUILDDEBUGPATH` regardless of how it is called (#6639, #6792).
+* `ProjectReference`s can now negotiate `Platform` (#6655, #6724, #6889).
+* Tasks can now call `TaskLoggingHelper.LogsMessagesOfImportance` to determine if any attached logger would preserve a log message before constructing it (to save time in the not-being-logged case) (#6381, #6737).
+* Support referencing assemblies with generic attributes (#6735). Thanks, @davidwrighton!
+* XSD-based MSBuild IntelliSense now supports `ImplicitUsings` and `Using` items (#6755), `InternalsVisibleTo` (#6778), Windows Forms properties (#6860), `DebugType` (#6849), and `SatelliteResourceLanguages` (#6861). Thanks, @pranavkm, @DamianEdwards, @RussKie, and @drewnoakes!
+* Tasks can now call `TaskLoggingHelper.IsTaskInputLoggingEnabled` and avoid redundant logging of inputs (#6803).
+* Support extracting resource namespace from C# source that uses file-scoped namespaces (#6881).
+
+#### Changed
+
+* The on-disk format of serialized caches has changed (#6350, #6324, #6490, #6674).
+* MSBuild is now [signed with a new certificate](https://github.com/dotnet/announcements/issues/184) (#6448).
+* `BuildParameters.DisableInprocNode` now applies to more processes (#6400).
+* `VCTargetsPath` now defaults to `v170` (#6550).
+* MSBuild no longer logs `Building with tools version "Current"` (#6627). Thanks, @KirillOsenkov!
+* Text loggers now log properties and items at the end of evaluation (#6535).
+* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds (#6622, #6703).
+* MSBuild on .NET 6 has improved task-assembly-reference fallback behavior (#6558).
+* MSBuild features gated on the 16.8 changewave are now nonconfigurable (#6634).
+* The deprecated import of `$(CoreCrossTargetingTargetsPath)` was removed (#6668). Thanks, @Nirmal4G!
+* Improved error message for `MSB4213` (#6640).
+* The method `GetType()` can no longer be called in property functions (#6769).
+* MSBuild is now fully NGENed by Visual Studio setup (#6764).
+* MSBuild (and Visual Studio) now reference `System.Text.Json` 5.0.2 (#6784). Thanks, @JakeRadMSFT!
+* Default to SHA2 digest for ClickOnce manifest when certificate signing algorithm is sha256/384/512 (#6882).
+
+#### Fixed
+
+* Solution builds should work when using the secret environment variable `MSBUILDNOINPROCNODE` (#6385).
+* Solution extensions can now use `BeforeTargets="ValidateSolutionConfiguration"` (#6454).
+* Performance improvements (#6529, #6556, #6598, #6632, #6669, #6671, #6666, #6678, #6680, #6705, #6595, #6716, #6786, #6816, #6832, #6845).
+* Single-file ClickOnce publish includes file association icons (#6578).
+* Improved robustness in error handling of libraries without resources (#6546).
+* Fixed missing information in `Project`'s `DebuggerDisplay` (#6650).
+* `ResolveAssemblyReferences` output paths are now output in normalized form (#6533).
+* Improved handling of satellite assemblies in ClickOnce (#6665).
+* Roslyn code analyzers are no longer run during XAML precompilation (#6676). Thanks, @jlaanstra!
+* 64-bit API callers no longer need to set `MSBUILD_EXE_PATH` (#6683, #6746).
+* `EvaluateStop` ETW events are now automatically correlated with `EvaluateStart` (#6725).
+* Evaluation time is included in text performance traces (#6725).
+* Add PackageDescription to `Microsoft.NET.StringTools` (#6740).
+* Fixed deadlock between `ExecuteSubmission` and `LoggingService` (#6717).
+* Narrowed conditions where MSBuild would blame NuGet for SDK resolution problems (#6742).
+* `CombineTargetFrameworkInfoProperties` no longer fails on portable framework names (#6699).
+* Avoid needless builds of `GenerateBindingRedirects` (#6726).
+* The solution configuration is now passed to experimental cache plugins (#6738).
+* Clearer errors when SDK resolvers throw exceptions (#6763).
+* Improved errors from `InternableString.ExpensiveConvertToString` (#6798).
+* Binding redirects for all `System.*` assemblies updated (#6830).
+* Fixed deadlock between `BuildManager` and `LoggingService` (#6837).
+* Log message arguments for warnings and errors (#6804). Thanks, @KirillOsenkov!
+* Use static CoreClrAssemblyLoader for SDK resolvers (#6864). Thanks, @marcin-krystianc!
+* Avoid break caused by fix and workaround for AL path colliding (#6884).
+* Support private-use area Unicode characters in paths passed to `XslTransformation` (#6863, #6946). Thanks, @lanfeust69!
+* Use the correct .NET host when called from a .NET 6.0 application (#6890).
+
+#### Infrastructure
+
+* This repo now builds with Arcade 6.0 (#6143).
+* Use newer Ubuntu versions for Linux CI builds (#6488).
+* MSBuild now uses [Arcade-powered source build](https://github.com/dotnet/source-build/tree/ba0b33e9f96354b8d07317c3cdf406ce666921f8/Documentation/planning/arcade-powered-source-build) (#6387).
+* Improved repo issue templates and automation (#6557).
+* Whitespace cleanup (#6565).
+* This repo no longer needs to double-specify the SDK version (#6596).
+* Simplify references to `TargetFramework` using new intrinsics (#5799).
+* Reference the `Microsoft.DotNet.XUnitExtensions` package from Arcade instead of our fork (#6638).
+* Use [`BannedApiAnalyzers`](https://www.nuget.org/packages/Microsoft.CodeAnalysis.BannedApiAnalyzers/) (#6675).
+* Enable analyzers for the MSBuild repo with rules similar to `dotnet/runtime` (#5656). Thanks, @elachlan!
+* Improved internal OptProf training scenarios (#6758).
+* Delete Unreachable code (#6805). Thanks, @KirillOsenkov!
+* Upgrade System.Net.Http package version used in tests (#6879).
+
+#### Documentation
+
+* Use GitHub-generated Markdown tables of contents (#6760).
+* Fixed validation issues in docs build (#6744).
+* Descriptions of labels in use in this repo (#6873).
+
 ## MSBuild 16.11.0
 
 This version of MSBuild shipped with Visual Studio 2019 version 16.11.0 and .NET SDK 5.0.400.
diff --git a/eng/Packages.props b/eng/Packages.props
index 042bf70a426..494c9c064c1 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -45,12 +45,11 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
-    <GlobalPackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.0" PrivateAssets="All"/>
+    <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="$(MicrosoftCodeAnalysisBannedApiAnalyzersVersion)" />
   </ItemGroup>
 
   <ItemGroup>
     <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-    <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="$(MicrosoftCodeAnalysisBannedApiAnalyzersVersion)" />
   </ItemGroup>
 
 </Project>
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index c31ba2c3cdb..aab3620f407 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -6,7 +6,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <IsPackable>false</IsPackable>
 
     <AssemblyName>Microsoft.Build.Engine.OM.UnitTests</AssemblyName>
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index d49cc341887..106e03beaf3 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -184,8 +184,8 @@ public void CreatableByTaskFactoryMatchingIdentity()
             SetupTaskFactory(factoryIdentityParameters, false /* don't want task host */);
 
             IDictionary<string, string> taskIdentityParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            taskIdentityParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
-            taskIdentityParameters.Add(XMakeAttributes.architecture, XMakeAttributes.MSBuildArchitectureValues.any);
+            taskIdentityParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
+            taskIdentityParameters.Add(XMakeAttributes.architecture, XMakeAttributes.GetCurrentMSBuildArchitecture());
 
             Assert.True(_taskFactory.TaskNameCreatableByFactory("TaskToTestFactories", taskIdentityParameters, String.Empty, null, ElementLocation.Create(".", 1, 1)));
         }
@@ -309,7 +309,7 @@ public void VerifyMatchingTaskParametersDontLaunchTaskHost2()
             try
             {
                 IDictionary<string, string> taskParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                taskParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
+                taskParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
                 taskParameters.Add(XMakeAttributes.architecture, XMakeAttributes.GetCurrentMSBuildArchitecture());
 
                 createdTask = _taskFactory.CreateTaskInstance(ElementLocation.Create("MSBUILD"), null, new MockHost(), taskParameters,
@@ -406,7 +406,7 @@ public void VerifyMatchingParametersDontLaunchTaskHost()
             try
             {
                 IDictionary<string, string> factoryParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                factoryParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
+                factoryParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
 
                 SetupTaskFactory(factoryParameters, false /* don't want task host */);
 
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 1587123afc0..761597bd4e1 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -1598,7 +1598,7 @@ public void CancelledBuildWithDelay20()
             _logger.AssertLogDoesntContain("[errormessage]");
         }
 
-#if FEATURE_TASKHOST && !NO_MSBUILDTASKHOST
+#if !NO_MSBUILDTASKHOST
         // Run this test only if we expect MSBuildTaskHost to have been produced, which requires that MSBuildTaskHost.csproj
         // be built with full-framework MSBuild (so that it can target .NET 3.5).
 
@@ -1672,7 +1672,6 @@ public void CancelledBuildWithDelay40()
             _logger.AssertLogDoesntContain("[errormessage]");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.0 task, we should
         /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
@@ -1706,7 +1705,6 @@ public void CancelledBuildInTaskHostWithDelay40()
             // Task host should not have exited prematurely
             _logger.AssertLogDoesntContain("MSB4217");
         }
-#endif
 
         /// <summary>
         /// This test verifies that builds of the same project instance in sequence are permitted.
@@ -4360,10 +4358,8 @@ public override bool Execute()
         [Theory]
         [InlineData("", false)] // regular task host, input logging disabled
         [InlineData("", true)] // regular task host, input logging enabled
-#if NETFRAMEWORK // https://github.com/microsoft/msbuild/issues/5158
         [InlineData("TaskHostFactory", false)] // OOP task host, input logging disabled
         [InlineData("TaskHostFactory", true)] // OOP task host, input logging enabled
-#endif
         public void TaskInputLoggingIsExposedToTasks(string taskFactory, bool taskInputLoggingEnabled)
         {
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index b7d3098dd5c..2476d984cbf 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -372,12 +372,13 @@ public void PropertyOverridesContainSemicolon()
 
             // Just a normal console application project.
             ObjectModelHelpers.CreateFileInTempProjectDirectory(
-                @"bug'533'369\Sub;Dir\ConsoleApplication1\ConsoleApplication1.csproj", @"
+                @"bug'533'369\Sub;Dir\ConsoleApplication1\ConsoleApplication1.csproj", $@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                   <PropertyGroup>
                     <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                     <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                     <OutputType>Exe</OutputType>
                     <AssemblyName>ConsoleApplication1</AssemblyName>
                   </PropertyGroup>
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 486352af3f2..87152257402 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -22,6 +22,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using System.Threading;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -107,6 +108,63 @@ public void TasksNotDiscoveredWhenTaskConditionFalse()
             logger.AssertLogContains("Made it");
         }
 
+        [Fact]
+        public void CanceledTasksDoNotLogMSB4181()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_testOutput))
+            {
+                BuildManager manager = new BuildManager();
+                ProjectCollection collection = new ProjectCollection();
+
+                string contents = @"
+                    <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' ToolsVersion ='Current'>
+                     <Target Name='test'>
+                        <Exec Command='" + Helpers.GetSleepCommand(TimeSpan.FromSeconds(10)) + @"'/>
+                     </Target>
+                    </Project>";
+
+                MockLogger logger = new MockLogger(_testOutput);
+
+                var project = new Project(XmlReader.Create(new StringReader(contents)), null, MSBuildConstants.CurrentToolsVersion, collection)
+                {
+                    FullPath = env.CreateFile().Path
+                };
+
+                var _parameters = new BuildParameters
+                {
+                    ShutdownInProcNodeOnBuildFinish = true,
+                    Loggers = new ILogger[] { logger },
+                    EnableNodeReuse = false
+                };
+                ;
+
+                BuildRequestData data = new BuildRequestData(project.CreateProjectInstance(), new string[] { "test" }, collection.HostServices);
+                manager.BeginBuild(_parameters);
+                BuildSubmission asyncResult = manager.PendBuildRequest(data);
+                asyncResult.ExecuteAsync(null, null);
+                Thread.Sleep(500);
+                manager.CancelAllSubmissions();
+                asyncResult.WaitHandle.WaitOne();
+                BuildResult result = asyncResult.BuildResult;
+                manager.EndBuild();
+
+                // No errors from cancelling a build.
+                logger.ErrorCount.ShouldBe(0);
+                // Warn because the task is being cancelled.
+                // NOTE: This assertion will fail when debugging into it because "waiting on exec to cancel" warning will be logged.
+                logger.WarningCount.ShouldBe(1);
+                // Build failed because it was cancelled.
+                result.OverallResult.ShouldBe(BuildResultCode.Failure);
+                // Should log "Cmd being cancelled because build was cancelled" warning
+                logger.AssertLogContains("MSB5021");
+                // Should NOT log "exec failed without logging error"
+                logger.AssertLogDoesntContain("MSB4181");
+
+                collection.Dispose();
+                manager.Dispose();
+            }
+        }
+
         /// <summary>
         /// Verify when task outputs are overridden the override messages are correctly displayed
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 897b6a5751f..fa4146484e9 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -12,7 +12,6 @@ namespace Microsoft.Build.Engine.UnitTests.BackEnd
     public sealed class TaskHostFactory_Tests
     {
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/microsoft/msbuild/issues/5158")]
         [Trait("Category", "mono-osx-failing")]
         public void TaskNodesDieAfterBuild()
         {
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index e1ad11a9be0..edd37ea0144 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -21,6 +21,7 @@
 using ResourceUtilities = Microsoft.Build.Shared.ResourceUtilities;
 using Xunit;
 using Xunit.Abstractions;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.UnitTests.EscapingInProjects_Tests
 {
@@ -94,7 +95,6 @@ public void SemicolonInPropertyPassedIntoStringParam()
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Make sure I can define a property with escaped characters and pass it into
         /// a string parameter of a task, in this case the Message task.
@@ -117,7 +117,6 @@ public void SemicolonInPropertyPassedIntoStringParam_UsingTaskHost()
 
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
-#endif
 
 #if FEATURE_ASSEMBLY_LOCATION
         /// <summary>
@@ -588,7 +587,6 @@ public void ItemTransformContainingSemicolon()
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Do an item transform, where the transform expression contains an unescaped semicolon as well
         /// as an escaped percent sign.
@@ -616,7 +614,6 @@ public void ItemTransformContainingSemicolon_InTaskHost()
 
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
-#endif
 
         /// <summary>
         /// Tests that when we add an item and are in a directory with characters in need of escaping, and the
@@ -710,7 +707,6 @@ public void EscapedWildcardsShouldNotBeExpanded()
             }
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// If %2A (escaped '*') or %3F (escaped '?') is in an item's Include, it should be treated
         /// literally, not as a wildcard
@@ -747,7 +743,6 @@ public void EscapedWildcardsShouldNotBeExpanded_InTaskHost()
                 ObjectModelHelpers.DeleteTempProjectDirectory();
             }
         }
-#endif
 
         /// <summary>
         /// Parity with Orcas: Target names are always unescaped, and in fact, if there are two targets,
@@ -954,12 +949,13 @@ public void SemicolonInConfiguration()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1002,7 +998,6 @@ public class Class1
             logger.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\a;b'c\ClassLibrary16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: Escaping in conditionals is broken.
         /// </summary>
@@ -1019,12 +1014,13 @@ public void SemicolonInConfiguration_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1071,7 +1067,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         ///     ESCAPING: CopyBuildTarget target fails if the output assembly name contains a semicolon or single-quote
@@ -1084,12 +1079,13 @@ public void SemicolonInAssemblyName()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%3bLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1127,7 +1123,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\Class;Library16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: CopyBuildTarget target fails if the output assembly name contains a semicolon or single-quote
         /// </summary>
@@ -1144,12 +1139,13 @@ public void SemicolonInAssemblyName_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%3bLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1191,7 +1187,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         ///     ESCAPING: Conversion Issue: Properties with $(xxx) as literals are not being converted correctly
@@ -1204,12 +1199,13 @@ public void DollarSignInAssemblyName()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%24%28prop%29Library16</AssemblyName>
                     </PropertyGroup>
@@ -1247,7 +1243,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\Class$(prop)Library16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: Conversion Issue: Properties with $(xxx) as literals are not being converted correctly
         /// </summary>
@@ -1264,12 +1259,13 @@ public void DollarSignInAssemblyName_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%24%28prop%29Library16</AssemblyName>
                     </PropertyGroup>
@@ -1311,7 +1307,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         /// This is the case when one of the source code files in the project has a filename containing a semicolon.
@@ -1324,12 +1319,13 @@ public void SemicolonInSourceCodeFilename()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1367,7 +1363,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\ClassLibrary16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// This is the case when one of the source code files in the project has a filename containing a semicolon.
         /// </summary>
@@ -1384,12 +1379,13 @@ public void SemicolonInSourceCodeFilename_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1431,7 +1427,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
@@ -1599,7 +1594,6 @@ public class Class1
             Assert.True(File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe"))); //                     @"Did not find expected file Console;!@(foo)'^(Application1.exe"
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
         /// have all sorts of crazy characters in their name. There
@@ -1775,7 +1769,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
     }
 #endif
 
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index f6f733c34a9..c8c590e79cd 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1874,19 +1874,19 @@ public void TestItemSpecModiferEscaping()
         [Trait("Category", "mono-osx-failing")]
         public void TestGetPathToReferenceAssembliesAsFunction()
         {
-            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) == null)
+            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) == null)
             {
                 // if there aren't any reference assemblies installed on the machine in the first place, of course
                 // we're not going to find them. :)
                 return;
             }
 
-            string content = @"
+            string content = $@"
                 <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
 
                     <PropertyGroup>
                         <TargetFrameworkIdentifier>.NETFramework</TargetFrameworkIdentifier>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <TargetFrameworkProfile></TargetFrameworkProfile>
                         <TargetFrameworkMoniker>$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)</TargetFrameworkMoniker>
                     </PropertyGroup>
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index dc3a40ef3ce..817d408f8a1 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <IsPackable>false</IsPackable>
     <AssemblyName>Microsoft.Build.Engine.UnitTests</AssemblyName>
 
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 3efd05703f6..4a7e4b27904 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -32,11 +32,12 @@ public void TargetARM()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>arm</PlatformTarget>
@@ -134,18 +135,18 @@ public void ExplicitAnyCPULibraryProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -186,7 +187,7 @@ public void AnyCPUWinMDObjProjectIsNot32BitPreferred()
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
                     @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>" + outputPath + @"</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -241,10 +242,10 @@ public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>winmdobj</OutputType>
                         <Configuration>Debug</Configuration>
@@ -253,10 +254,10 @@ public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
                            we need to be .NET 4.5 or greater -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -298,17 +299,17 @@ public void AnyCPUExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -348,18 +349,18 @@ public void ExplicitAnyCPUExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -400,7 +401,7 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
                     @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>" + outputPath + @"</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -434,10 +435,10 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
 
         /// <summary>
         /// Check that with an explicit platformtarget of anycpu, exe type assemblies that are 
-        /// targeting .NET 4.0 do not get forced to anycpu32bitpreferred by default. 
+        /// targeting .NET 4.0+ do not get forced to anycpu32bitpreferred by default. 
         /// </summary>
         [Fact]
-        public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
+        public void ExplicitAnyCPUExeProjectIsNot32BitPreferred()
         {
             string file = null;
             string outputPath = Path.GetTempPath() + "\\" + Guid.NewGuid().ToString("N");
@@ -449,18 +450,18 @@ public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -470,7 +471,7 @@ public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
 
                 project.Build();
 
-                logger.AssertLogContains(" /platform:AnyCPU ");
+                logger.AssertLogContains("Platform=AnyCPU");
             }
             finally
             {
@@ -500,21 +501,21 @@ public void AnyCPUAppContainerExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>AppContainerExe</OutputType>
                         <Configuration>Debug</Configuration>
                       </PropertyGroup>
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
-                           we need to be .NET 4.5 or greater -->
+                           we need to be .NET 4.5 or greater, but 4.8 is on the CI machine -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -556,10 +557,10 @@ public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>AppContainerExe</OutputType>
                         <Configuration>Debug</Configuration>
@@ -568,10 +569,10 @@ public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
                            we need to be .NET 4.5 or greater -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -613,19 +614,19 @@ public void AnyCPULibraryProjectIs32BitPreferredIfPrefer32BitSet()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`Current` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <Prefer32Bit>true</Prefer32Bit>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                    </Project>
@@ -665,17 +666,17 @@ public void AnyCPUProjectWithNoExplicitOutputTypeIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                    </Project>
@@ -715,17 +716,17 @@ public void AnyCPUJupiterProjectWithNoExplicitOutputTypeIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -867,20 +868,20 @@ public void NoLinkMetadataSynthesisWhenDefinedInProject()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>true</SynthesizeLinkMetadata>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + files[0] + @"` />
-                        <None Include=`" + files[1] + @"` />
-                        <Content Include=`" + files[2] + @"` />
+                        <Compile Include=`{files[0]}` />
+                        <None Include=`{files[1]}` />
+                        <Content Include=`{files[2]}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
@@ -952,17 +953,17 @@ public void SynthesizeLinkMetadataForItemsOnWhitelist()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>true</SynthesizeLinkMetadata>
                       </PropertyGroup>
-                      <Import Project=`" + files[3] + @"` />
+                      <Import Project=`{files[3]}` />
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
                         <Message Text=`%(Compile.Identity): [%(Compile.Link)]` />
@@ -1030,17 +1031,17 @@ public void DontSynthesizeLinkMetadataIfPropertyNotSet()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>false</SynthesizeLinkMetadata>
                       </PropertyGroup>
-                      <Import Project=`" + files[3] + @"` />
+                      <Import Project=`{files[3]}` />
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
                         <Message Text=`%(Compile.Identity): [%(Compile.Link)]` />
diff --git a/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs b/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
index a8a88862e4f..a9ba7b26914 100644
--- a/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
+++ b/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
@@ -183,6 +183,12 @@ public bool Equals(ProjectItemGroupTaskItemInstance x, ProjectItemGroupTaskItemI
                 Assert.Equal(x.RemoveMetadataLocation, y.RemoveMetadataLocation, new Helpers.ElementLocationComparerIgnoringType());
                 Assert.Equal(x.ConditionLocation, y.ConditionLocation, new Helpers.ElementLocationComparerIgnoringType());
 
+                Assert.Equal(x.MatchOnMetadata, y.MatchOnMetadata);
+                Assert.Equal(x.MatchOnMetadataLocation, y.MatchOnMetadataLocation, new Helpers.ElementLocationComparerIgnoringType());
+
+                Assert.Equal(x.MatchOnMetadataOptions, y.MatchOnMetadataOptions);
+                Assert.Equal(x.MatchOnMetadataOptionsLocation, y.MatchOnMetadataOptionsLocation, new Helpers.ElementLocationComparerIgnoringType());
+
                 Assert.Equal(x.Metadata, y.Metadata, new TargetItemMetadataComparer());
 
                 return true;
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index d83d61361fa..e8ead4b2e98 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -417,6 +417,9 @@ public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
             }
         }
 
+        /// <summary>
+        /// Test that a task that returns false without logging anything reports MSB4181 as a warning.
+        /// </summary>
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue()
         {
@@ -439,6 +442,31 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue
             }
         }
 
+        /// <summary>
+        /// Test that a task that returns false after logging an error->warning does NOT also log MSB4181
+        /// </summary>
+        [Fact]
+        public void TaskReturnsFailureAndLogsError_ContinueOnError_WarnAndContinue()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""CustomLogAndReturnTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <CustomLogAndReturnTask Return=""false"" ErrorCode=""MSB1234"" ContinueOnError=""WarnAndContinue""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+
+                // The only warning should be the error->warning logged by the task.
+                logger.WarningCount.ShouldBe(1);
+                logger.AssertLogContains("MSB1234");
+            }
+        }
+
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index ddabf21013b..a07d1e40557 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -20,7 +20,6 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
@@ -31,7 +30,6 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 132cb665bb1..5f73ac08e8b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -29,12 +29,10 @@ internal class NodeEndpointOutOfProc : NodeEndpointOutOfProcBase
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         /// <param name="host">The component host.</param>
         /// <param name="enableReuse">Whether this node may be reused for a later build.</param>
         /// <param name="lowPriority">Whether this node is low priority.</param>
         internal NodeEndpointOutOfProc(
-            string pipeName, 
             IBuildComponentHost host,
             bool enableReuse,
             bool lowPriority)
@@ -44,7 +42,7 @@ internal NodeEndpointOutOfProc(
             _enableReuse = enableReuse;
             _lowPriority = lowPriority;
 
-            InternalConstruct(pipeName);
+            InternalConstruct();
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 11ea72ba505..3472c8ff01d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -76,7 +76,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
         {
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
 
-            if (_nodeContexts.Count == ComponentHost.BuildParameters.MaxNodeCount)
+            if (_nodeContexts.Count >= ComponentHost.BuildParameters.MaxNodeCount)
             {
                 ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
                 return false;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index ef21df23454..9d7adfb26a6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -355,7 +355,7 @@ private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStrea
         private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + nodeProcessId);
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(nodeProcessId);
 
             NamedPipeClientStream nodeStream = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
@@ -590,7 +590,7 @@ private static string GetCurrentHost()
 #if RUNTIME_TYPE_NETCORE || MONO
             if (CurrentHost == null)
             {
-                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, 2),
+                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
                     NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
                 if (File.Exists(dotnetExe))
                 {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 2a917d6eaee..5d6c5f8f2cc 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -372,7 +372,9 @@ internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostConte
 
                     if (s_msbuildName == null)
                     {
-                        s_msbuildName = "MSBuild.exe";
+                        s_msbuildName = (hostContext & HandshakeOptions.NET) == HandshakeOptions.NET
+                            ? "MSBuild.dll"
+                            : "MSBuild.exe";
                     }
                 }
 
@@ -498,7 +500,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
 
-            if (AvailableNodes == 0)
+            if (AvailableNodes <= 0)
             {
                 ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
                 return false;
diff --git a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
index 4e6e5be0145..57c0e51523e 100644
--- a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
@@ -121,7 +121,7 @@ public IDictionary<int, ISet<string>> WarningsAsMessagesByProject
         /// </summary>
         public void Consume(BuildEventArgs buildEvent)
         {
-            ErrorUtilities.VerifyThrow(false, "Do not use this method for the transport sink");
+            ErrorUtilities.ThrowInternalError("Do not use this method for the transport sink");
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 97b7512d14e..a393d6c36a8 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -280,7 +280,7 @@ public void Consume(BuildEventArgs buildEvent)
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unknown event args type.");
+                ErrorUtilities.ThrowInternalError("Unknown event args type.");
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 19ed313b922..117f5195448 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1417,7 +1417,7 @@ private void RouteBuildEvent(object loggingEvent)
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unknown logging item in queue:" + loggingEvent.GetType().FullName);
+                ErrorUtilities.ThrowInternalError("Unknown logging item in queue:" + loggingEvent.GetType().FullName);
             }
 
             if (buildEventArgs is BuildWarningEventArgs warningEvent)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index 3e676950ea5..3fde04be279 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -156,8 +156,7 @@ ElementLocation elementLocation
                         // to really loop here... it's just that the foreach is the only way I can
                         // figure out how to get data out of the hashtable without knowing any of the
                         // keys!
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false,
-                            elementLocation, "CannotReferenceItemMetadataWithoutItemName", unqualifiedMetadataName);
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotReferenceItemMetadataWithoutItemName", unqualifiedMetadataName);
                     }
                 }
                 else
@@ -410,7 +409,7 @@ ElementLocation elementLocation
                     }
                     catch (InvalidOperationException e)
                     {
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation,
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation,
                             "CannotEvaluateItemMetadata", metadataName, e.Message);
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index f96e90a2822..165b1f2b427 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -583,7 +583,7 @@ private List<ProjectItemInstance> FindItemsMatchingMetadataSpecification(
             ItemSpec<ProjectPropertyInstance, ProjectItemInstance> itemSpec = new ItemSpec<ProjectPropertyInstance, ProjectItemInstance>(child.Remove, expander, child.RemoveLocation, Project.Directory, true);
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
                 itemSpec.Fragments.All(f => f is ItemSpec<ProjectPropertyInstance, ProjectItemInstance>.ItemExpressionFragment),
-                new BuildEventFileInfo(string.Empty),
+                BuildEventFileInfo.Empty,
                 "OM_MatchOnMetadataIsRestrictedToReferencedItems",
                 child.RemoveLocation,
                 child.Remove);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 5fdd1a3e145..efe47bf3381 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -709,7 +709,7 @@ private void UpdateContinueOnError(ItemBucket bucket, TaskHost taskHost)
                 catch (ArgumentException e)
                 {
                     // handle errors in string-->bool conversion
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _taskNode.ContinueOnErrorLocation, "InvalidContinueOnErrorAttribute", _taskNode.Name, e.Message);
+                    ProjectErrorUtilities.ThrowInvalidProject(_taskNode.ContinueOnErrorLocation, "InvalidContinueOnErrorAttribute", _taskNode.Name, e.Message);
                 }
             }
 
@@ -740,7 +740,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
             if (!taskExecutionHost.SetTaskParameters(_taskNode.ParametersForBuild))
             {
                 // The task cannot be initialized.
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, _targetChildInstance.Location, "TaskParametersError", _taskNode.Name, String.Empty);
+                ProjectErrorUtilities.ThrowInvalidProject(_targetChildInstance.Location, "TaskParametersError", _taskNode.Name, String.Empty);
             }
             else
             {
@@ -938,8 +938,14 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                 // that is logged as an error. MSBuild tasks are an exception because
                 // errors are not logged directly from them, but the tasks spawned by them.
                 IBuildEngine be = host.TaskInstance.BuildEngine;
-                if (taskReturned && !taskResult && !taskLoggingContext.HasLoggedErrors && (be is TaskHost th ? th.BuildRequestsSucceeded : false) && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true))
+                if (taskReturned // if the task returned
+                    && !taskResult // and it returned false
+                    && !taskLoggingContext.HasLoggedErrors // and it didn't log any errors
+                    && (be is TaskHost th ? th.BuildRequestsSucceeded : false)
+                    && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true) // and it's not allowed to fail unless it logs an error
+                    && !(_cancellationToken.CanBeCanceled && _cancellationToken.IsCancellationRequested)) // and it wasn't cancelled
                 {
+                    // Then decide how to log MSB4181
                     if (_continueOnError == ContinueOnError.WarnAndContinue)
                     {
                         taskLoggingContext.LogWarning(null,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 154ace42f96..0c07dae6d6f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -455,8 +455,9 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                 {
                     e.BuildEventContext = _taskLoggingContext.BuildEventContext;
                     _taskLoggingContext.LoggingService.LogBuildEvent(e);
-                    _taskLoggingContext.HasLoggedErrors = true;
                 }
+                
+                 _taskLoggingContext.HasLoggedErrors = true;
             }
         }
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index e5c4095acb9..23c505ff896 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -47,7 +47,9 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
             else
             {
                 // Get the dictionary for the specified submission if one is already added otherwise create a new dictionary for the submission.
-                ConcurrentDictionary<string, Lazy<SdkResult>> cached = _cache.GetOrAdd(submissionId, new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default));
+                ConcurrentDictionary<string, Lazy<SdkResult>> cached = _cache.GetOrAdd(
+                    submissionId,
+                    _ => new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default));
 
                 /*
                  * Get a Lazy<SdkResult> if available, otherwise create a Lazy<SdkResult> which will resolve the SDK with the SdkResolverService.Instance.  If multiple projects are attempting to resolve
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index fba2c4925b1..ff98112817b 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -247,7 +247,9 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
             // Do not set state for resolution requests that are not associated with a valid build submission ID
             if (submissionId != BuildEventContext.InvalidSubmissionId)
             {
-                ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(submissionId, new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
+                ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(
+                    submissionId,
+                    _ => new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 9e500181510..ae59a7b50af 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -239,9 +239,8 @@ public NodeEngineShutdownReason Run(bool enableReuse, out Exception shutdownExce
         public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception shutdownException)
         {
             // Console.WriteLine("Run called at {0}", DateTime.Now);
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + Process.GetCurrentProcess().Id);
 
-            _nodeEndpoint = new NodeEndpointOutOfProc(pipeName, this, enableReuse, lowPriority);
+            _nodeEndpoint = new NodeEndpointOutOfProc(this, enableReuse, lowPriority);
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index f6a291d929c..77497354b7b 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -12,7 +12,6 @@
 #endif
 using System.Text;
 using System.Threading;
-using System.Threading.Tasks;
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
@@ -442,9 +441,8 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                 }
                 else
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject
+                    ProjectErrorUtilities.ThrowInvalidProject
                     (
-                        false,
                         parameterLocation,
                         "UnsupportedTaskParameterTypeError",
                         parameter.PropertyType.FullName,
@@ -482,9 +480,8 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
 
                 // We do not recover from a task exception while getting outputs,
                 // so do not merely set gatheredGeneratedOutputsSuccessfully = false; here
-                ProjectErrorUtilities.VerifyThrowInvalidProject
+                ProjectErrorUtilities.ThrowInvalidProject
                 (
-                    false,
                     parameterLocation,
                     "FailedToRetrieveTaskOutputs",
                     _taskName,
@@ -500,9 +497,8 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                     throw;
                 }
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject
+                ProjectErrorUtilities.ThrowInvalidProject
                 (
-                    false,
                     parameterLocation,
                     "FailedToRetrieveTaskOutputs",
                     _taskName,
@@ -1183,11 +1179,9 @@ out bool taskParameterSet
                         {
                             // We only allow a single item to be passed into a parameter of ITaskItem.
 
-                            // Some of the computation (expansion) here is expensive, so don't make the above
-                            // "if" statement directly part of the first param to VerifyThrowInvalidProject.
-                            ProjectErrorUtilities.VerifyThrowInvalidProject
+                            // Some of the computation (expansion) here is expensive, so don't switch to VerifyThrowInvalidProject.
+                            ProjectErrorUtilities.ThrowInvalidProject
                                 (
-                                false,
                                 parameterLocation,
                                 "CannotPassMultipleItemsIntoScalarParameter",
                                 _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation),
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 80d7bdaad22..c1e3f8efe62 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -8,7 +8,9 @@
 using System.Security;
 using System.Text;
 using System.Xml;
+#if !NETFRAMEWORK || MONO
 using Microsoft.Build.Shared;
+#endif
 
 using XMakeAttributes = Microsoft.Build.Shared.XMakeAttributes;
 using ProjectFileErrorUtilities = Microsoft.Build.Shared.ProjectFileErrorUtilities;
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 625352ba374..43318152844 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -1133,9 +1133,8 @@ private bool CanBuildDirectly(ProjectInstance traversalProject, ProjectInSolutio
                 {
                     if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                     {
-                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                        ProjectFileErrorUtilities.ThrowInvalidProjectFile
                             (
-                            false,
                             "SubCategoryForSolutionParsingErrors",
                             new BuildEventFileInfo(traversalProject.FullPath),
                             "SolutionParseProjectDepNotFoundError",
@@ -1206,9 +1205,8 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
             if (project.ProjectType == SolutionProjectType.WebProject)
             {
 #if !FEATURE_ASPNET_COMPILER
-                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile
                     (
-                    false,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(_solutionFile.FullPath),
                     "AspNetCompiler.UnsupportedMSBuildVersion",
@@ -1295,9 +1293,8 @@ private void AddMetaprojectReferenceItems(ProjectInstance traversalProject, Proj
             {
                 if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                 {
-                    ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile
                         (
-                        false,
                         "SubCategoryForSolutionParsingErrors",
                         new BuildEventFileInfo(traversalProject.FullPath),
                         "SolutionParseProjectDepNotFoundError",
@@ -1557,9 +1554,8 @@ private void ValidateTargetFrameworkForWebProject(ProjectInSolution project)
             }
             if (!isDotNetFramework)
             {
-                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile
                     (
-                    false,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(_solutionFile.FullPath),
                     "AspNetCompiler.InvalidTargetFrameworkMonikerNotDotNET",
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 77d32963bf6..b623fed7040 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -920,6 +920,17 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));
 
+                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,
+#if RUNTIME_TYPE_NETCORE
+                        "Core",
+#elif MONO
+                        NativeMethodsShared.IsMono ? "Mono" : "Full");
+#else
+                        "Full",
+#endif
+                        mayBeReserved: true));
+
+
                     // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the
                     // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.
                     int count = _environmentProperties.Count + reservedProperties.Count + Properties.Values.Count + _globalProperties.Count + 1;
@@ -1087,7 +1098,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
                 catch (XmlException e)
                 {
                     // handle XML errors in the default tasks file
-                    ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false, new BuildEventFileInfo(defaultTasksFile, e), taskFileError, e.Message);
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(defaultTasksFile, e), taskFileError, e.Message);
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
diff --git a/src/Build/ElementLocation/XmlAttributeWithLocation.cs b/src/Build/ElementLocation/XmlAttributeWithLocation.cs
index 25820d1d1bb..2a8ad231e60 100644
--- a/src/Build/ElementLocation/XmlAttributeWithLocation.cs
+++ b/src/Build/ElementLocation/XmlAttributeWithLocation.cs
@@ -72,7 +72,7 @@ internal ElementLocation Location
             {
                 // Caching the element location object saves significant memory
                 XmlDocumentWithLocation ownerDocumentWithLocation = (XmlDocumentWithLocation)OwnerDocument;
-                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath, StringComparison.OrdinalIgnoreCase))
+                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath ?? String.Empty, StringComparison.OrdinalIgnoreCase))
                 {
                     _elementLocation = ElementLocation.Create(ownerDocumentWithLocation.FullPath, _elementLocation.Line, _elementLocation.Column);
                 }
@@ -90,4 +90,4 @@ public bool HasLineInfo()
             return Location.Line != 0;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 15c91a6f68e..1b3de4bb5e0 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -352,24 +352,17 @@ private void DetermineWhetherToLoadReadOnly(string fullPath)
                     // Only files from Microsoft
                     if (Path.GetFileName(fullPath).StartsWith("Microsoft.", StringComparison.OrdinalIgnoreCase))
                     {
-                        // If we are loading devdiv targets, we're in razzle
-                        if (Path.GetFileName(fullPath).StartsWith("Microsoft.DevDiv", StringComparison.OrdinalIgnoreCase))
-                        {
-                            _loadAsReadOnly = true;
-                        }
-                        else // Else, only load if they're in program files or windows directories
-                        {
-                            ErrorUtilities.VerifyThrow(Path.IsPathRooted(fullPath), "should be full path");
-                            string directory = Path.GetDirectoryName(fullPath);
+                        // Load read-only if they're in program files or windows directories
+                        ErrorUtilities.VerifyThrow(Path.IsPathRooted(fullPath), "should be full path");
+                        string directory = Path.GetDirectoryName(fullPath);
 
-                            string windowsFolder = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
+                        string windowsFolder = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
 
-                            if ((!String.IsNullOrEmpty(windowsFolder) && directory.StartsWith(windowsFolder, StringComparison.OrdinalIgnoreCase)) ||
-                                (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles32) && directory.StartsWith(FrameworkLocationHelper.programFiles32, StringComparison.OrdinalIgnoreCase)) ||
-                                (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles64) && directory.StartsWith(FrameworkLocationHelper.programFiles64, StringComparison.OrdinalIgnoreCase)))
-                            {
-                                _loadAsReadOnly = true;
-                            }
+                        if ((!String.IsNullOrEmpty(windowsFolder) && directory.StartsWith(windowsFolder, StringComparison.OrdinalIgnoreCase)) ||
+                            (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles32) && directory.StartsWith(FrameworkLocationHelper.programFiles32, StringComparison.OrdinalIgnoreCase)) ||
+                            (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles64) && directory.StartsWith(FrameworkLocationHelper.programFiles64, StringComparison.OrdinalIgnoreCase)))
+                        {
+                            _loadAsReadOnly = true;
                         }
                     }
                 }
diff --git a/src/Build/ElementLocation/XmlElementWithLocation.cs b/src/Build/ElementLocation/XmlElementWithLocation.cs
index 7da601d28b2..47446943860 100644
--- a/src/Build/ElementLocation/XmlElementWithLocation.cs
+++ b/src/Build/ElementLocation/XmlElementWithLocation.cs
@@ -92,7 +92,7 @@ internal ElementLocation Location
             {
                 // Caching the element location object saves significant memory
                 XmlDocumentWithLocation ownerDocumentWithLocation = (XmlDocumentWithLocation)OwnerDocument;
-                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath, StringComparison.OrdinalIgnoreCase))
+                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath ?? String.Empty, StringComparison.OrdinalIgnoreCase))
                 {
                     _elementLocation = ElementLocation.Create(ownerDocumentWithLocation.FullPath, _elementLocation.Line, _elementLocation.Column);
                 }
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 7a1e0aa25ad..56016a76d82 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -33,7 +33,7 @@ public sealed class InternalLoggerException : Exception
         /// <exception cref="InvalidOperationException"></exception>
         public InternalLoggerException()
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(false, "InternalLoggerExceptionOnlyThrownByEngine");
+            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
         }
 
         /// <summary>
@@ -47,7 +47,7 @@ public InternalLoggerException()
         public InternalLoggerException(string message)
             : base(message)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(false, "InternalLoggerExceptionOnlyThrownByEngine");
+            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
         }
 
         /// <summary>
@@ -62,7 +62,7 @@ public InternalLoggerException(string message)
         public InternalLoggerException(string message, Exception innerException)
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(false, "InternalLoggerExceptionOnlyThrownByEngine");
+            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
         }
 
         #endregion
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index 7b3e099fb4c..69df786fb83 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -18,30 +18,34 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (LeftChild.CanBoolEvaluate(state),
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
                      "ExpressionDoesNotEvaluateToBoolean",
                      LeftChild.GetUnexpandedValue(state),
                      LeftChild.GetExpandedValue(state),
                      state.Condition);
+            }
 
-            if (!LeftChild.BoolEvaluate(state))
+            if (!leftBool)
             {
                 // Short circuit
                 return false;
             }
             else
             {
-                ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (RightChild.CanBoolEvaluate(state),
-                     state.ElementLocation,
-                     "ExpressionDoesNotEvaluateToBoolean",
-                     RightChild.GetUnexpandedValue(state),
-                     RightChild.GetExpandedValue(state),
-                     state.Condition);
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                {
+                    ProjectErrorUtilities.ThrowInvalidProject(
+                         state.ElementLocation,
+                         "ExpressionDoesNotEvaluateToBoolean",
+                         RightChild.GetUnexpandedValue(state),
+                         RightChild.GetExpandedValue(state),
+                         state.Condition);
+                }
 
-                return RightChild.BoolEvaluate(state);
+                return rightBool;
             }
         }
 
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 12547eaa3ae..d1ffa2a8248 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -90,8 +90,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // We haven't implemented any other "functions"
             else
             {
-                ProjectErrorUtilities.VerifyThrowInvalidProject(
-                    false,
+                ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "UndefinedFunctionCall",
                     state.Condition,
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index d4862fec251..c85b95e088d 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -12,12 +12,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -56,14 +53,16 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// <returns></returns>
         internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            ProjectErrorUtilities.VerifyThrowInvalidProject(
-                CanBoolEvaluate(state),
-                state.ElementLocation,
-                "ConditionNotBooleanDetail",
-                state.Condition,
-                GetExpandedValue(state));
-
-            return BoolEvaluate(state);
+            if (!TryBoolEvaluate(state, out bool boolValue))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ConditionNotBooleanDetail",
+                    state.Condition,
+                    GetExpandedValue(state));
+            }
+
+            return boolValue;
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 6a457794da3..18e1caad924 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -48,36 +48,41 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' " 
             // which is a performance advantage if @(X) is a huge item list.
-            if (LeftChild.EvaluatesToEmpty(state) || RightChild.EvaluatesToEmpty(state))
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
+            if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
 
-                return Compare(LeftChild.EvaluatesToEmpty(state), RightChild.EvaluatesToEmpty(state));
+                return Compare(leftEmpty, rightEmpty);
             }
-
-            if (LeftChild.CanNumericEvaluate(state) && RightChild.CanNumericEvaluate(state))
+            else if (LeftChild.TryNumericEvaluate(state, out double leftNumericValue) && RightChild.TryNumericEvaluate(state, out double rightNumericValue))
             {
-                return Compare(LeftChild.NumericEvaluate(state), RightChild.NumericEvaluate(state));
+                // The left child evaluating to a number and the right child not evaluating to a number
+                // is insufficient to say they are not equal because $(MSBuildToolsVersion) evaluates to
+                // the string "Current" most of the time but when doing numeric comparisons, is treated
+                // as a version and returns "17.0" (or whatever the current tools version is). This means
+                // that if '$(MSBuildToolsVersion)' is "equal" to BOTH '17.0' and 'Current' (if 'Current'
+                // is 17.0).
+                return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.CanBoolEvaluate(state) && RightChild.CanBoolEvaluate(state))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
             {
-                return Compare(LeftChild.BoolEvaluate(state), RightChild.BoolEvaluate(state));
+                return Compare(leftBoolValue, rightBoolValue);
             }
-            else // string comparison
-            {
-                string leftExpandedValue = LeftChild.GetExpandedValue(state);
-                string rightExpandedValue = RightChild.GetExpandedValue(state);
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (leftExpandedValue != null && rightExpandedValue != null,
-                     state.ElementLocation,
-                     "IllFormedCondition",
-                     state.Condition);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state);
+            string rightExpandedValue = RightChild.GetExpandedValue(state);
 
-                UpdateConditionedProperties(state);
+            ProjectErrorUtilities.VerifyThrowInvalidProject
+                (leftExpandedValue != null && rightExpandedValue != null,
+                    state.ElementLocation,
+                    "IllFormedCondition",
+                    state.Condition);
 
-                return Compare(leftExpandedValue, rightExpandedValue);
-            }
+            UpdateConditionedProperties(state);
+
+            return Compare(leftExpandedValue, rightExpandedValue);
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 0a2521feda7..2f5dd07d112 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Shared;
 using System.Diagnostics;
 
 namespace Microsoft.Build.Evaluation
@@ -17,12 +18,17 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            return !LeftChild.BoolEvaluate(state);
-        }
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ExpressionDoesNotEvaluateToBoolean",
+                    LeftChild.GetUnexpandedValue(state),
+                    LeftChild.GetExpandedValue(state),
+                    state.Condition);
+            }
 
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            return LeftChild.CanBoolEvaluate(state);
+            return !boolValue;
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index 0bd30600cbf..a86a3031bb3 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -38,46 +38,31 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            bool isLeftNum = LeftChild.CanNumericEvaluate(state);
-            bool isLeftVersion = LeftChild.CanVersionEvaluate(state);
-            bool isRightNum = RightChild.CanNumericEvaluate(state);
-            bool isRightVersion = RightChild.CanVersionEvaluate(state);
-            bool isNumeric = isLeftNum && isRightNum;
-            bool isVersion = isLeftVersion && isRightVersion;
-            bool isValidComparison = isNumeric || isVersion || (isLeftNum && isRightVersion) || (isLeftVersion && isRightNum);
+            bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
+            bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
+            bool isRightNum = RightChild.TryNumericEvaluate(state, out double rightNum);
+            bool isRightVersion = RightChild.TryVersionEvaluate(state, out Version rightVersion);
 
-            ProjectErrorUtilities.VerifyThrowInvalidProject
-                (isValidComparison,
-                 state.ElementLocation,
-                "ComparisonOnNonNumericExpression",
-                 state.Condition,
-                 /* helpfully display unexpanded token and expanded result in error message */
-                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
-
-            // If the values identify as numeric, make that comparison instead of the Version comparison since numeric has a stricter definition
-            if (isNumeric)
-            {
-                return Compare(LeftChild.NumericEvaluate(state), RightChild.NumericEvaluate(state));
-            }
-            else if (isVersion)
+            if ((!isLeftNum && !isLeftVersion) || (!isRightNum && !isRightVersion))
             {
-                return Compare(LeftChild.VersionEvaluate(state), RightChild.VersionEvaluate(state));
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ComparisonOnNonNumericExpression",
+                    state.Condition,
+                    /* helpfully display unexpanded token and expanded result in error message */
+                    isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
+                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
             }
 
-            // If the numbers are of a mixed type, call that specific Compare method
-            if (isLeftNum && isRightVersion)
+            return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
             {
-                return Compare(LeftChild.NumericEvaluate(state), RightChild.VersionEvaluate(state));
-            }
-            else if (isLeftVersion && isRightNum)
-            {
-                return Compare(LeftChild.VersionEvaluate(state), RightChild.NumericEvaluate(state));
-            }
+                (true, _, true, _) => Compare(leftNum, rightNum),
+                (_, true, _, true) => Compare(leftVersion, rightVersion),
+                (true, _, _, true) => Compare(leftNum, rightVersion),
+                (_, true, true, _) => Compare(leftVersion, rightNum),
 
-            // Throw error here as this code should be unreachable
-            ErrorUtilities.ThrowInternalErrorUnreachable();
-            return false;
+                _ => false
+            };
         }
     }
 }
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 306db6d802b..fe21a15a1ad 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -21,60 +21,20 @@ internal NumericExpressionNode(string value)
             _value = value;
         }
 
-        /// <summary>
-        /// Evaluate as boolean
-        /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            // Should be unreachable: all calls check CanBoolEvaluate() first
-            ErrorUtilities.VerifyThrow(false, "Can't evaluate a numeric expression as boolean.");
-            return false;
-        }
-
-        /// <summary>
-        /// Evaluate as numeric
-        /// </summary>
-        internal override double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            return ConversionUtilities.ConvertDecimalOrHexToDouble(_value);
-        }
-
-        /// <summary>
-        /// Evaluate as a Version
-        /// </summary>
-        internal override Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return Version.Parse(_value);
-        }
-
-        /// <summary>
-        /// Whether it can be evaluated as a boolean: never allowed for numerics
-        /// </summary>
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            // Numeric expressions are never allowed to be treated as booleans.
+            result = default;
             return false;
         }
 
-        /// <summary>
-        /// Whether it can be evaluated as numeric
-        /// </summary>
-        internal override bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
-            // It is not always possible to numerically evaluate even a numerical expression -
-            // for example, it may overflow a double. So check here.
-            return ConversionUtilities.ValidDecimalOrHexNumber(_value);
+            return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        /// <summary>
-        /// Whether it can be evaluated as a Version
-        /// </summary>
-        internal override bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
-            // Check if the value can be formatted as a Version number
-            // This is needed for nodes that identify as Numeric but can't be parsed as numbers (e.g. 8.1.1.0 vs 8.1)
-            Version unused;
-            return Version.TryParse(_value, out unused);
+            return Version.TryParse(_value, out result);
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 918e188ff85..92609fd763e 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -11,48 +10,23 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        /// <summary>
-        /// Numeric evaluation is never allowed for operators
-        /// </summary>
-        internal override double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            // Should be unreachable: all calls check CanNumericEvaluate() first
-            ErrorUtilities.VerifyThrow(false, "Cannot numeric evaluate an operator");
-            return 0.0D;
-        }
-
-        /// <summary>
-        /// Version evaluation is never allowed for operators
-        /// </summary>
-        internal override Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            ErrorUtilities.VerifyThrow(false, "Cannot version evaluate an operator");
-            return null;
-        }
-
-        /// <summary>
-        /// Whether boolean evaluation is allowed: always allowed for operators
-        /// </summary>
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
+            result = BoolEvaluate(state);
             return true;
         }
 
-        /// <summary>
-        /// Whether the node can be evaluated as a numeric: by default,
-        /// this is not allowed
-        /// </summary>
-        internal override bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
+
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
+            result = default;
             return false;
         }
 
-        /// <summary>
-        /// Whether the node can be evaluated as a version: by default,
-        /// this is not allowed
-        /// </summary>
-        internal override bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
+            result = default;
             return false;
         }
 
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index e9469f07aca..1ac1713a5aa 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -18,30 +18,34 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (LeftChild.CanBoolEvaluate(state),
-                     state.ElementLocation,
-                     "ExpressionDoesNotEvaluateToBoolean",
-                     LeftChild.GetUnexpandedValue(state),
-                     LeftChild.GetExpandedValue(state),
-                     state.Condition);
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ExpressionDoesNotEvaluateToBoolean",
+                    LeftChild.GetUnexpandedValue(state),
+                    LeftChild.GetExpandedValue(state),
+                    state.Condition);
+            }
 
-            if (LeftChild.BoolEvaluate(state))
+            if (leftBool)
             {
                 // Short circuit
                 return true;
             }
             else
             {
-                ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (RightChild.CanBoolEvaluate(state),
-                     state.ElementLocation,
-                     "ExpressionDoesNotEvaluateToBoolean",
-                     RightChild.GetUnexpandedValue(state),
-                     RightChild.GetExpandedValue(state),
-                     state.Condition);
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                {
+                    ProjectErrorUtilities.ThrowInvalidProject(
+                        state.ElementLocation,
+                        "ExpressionDoesNotEvaluateToBoolean",
+                        RightChild.GetUnexpandedValue(state),
+                        RightChild.GetExpandedValue(state),
+                        state.Condition);
+                }
 
-                return RightChild.BoolEvaluate(state);
+                return rightBool;
             }
         }
 
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index ac231b18964..292226a5ed8 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -107,13 +107,13 @@ internal GenericExpressionNode Parse(string expression, ParserOptions optionSett
             if (!_lexer.Advance())
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
             }
             GenericExpressionNode node = Expr(expression);
             if (!_lexer.IsNext(Token.TokenType.EndOfInput))
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
             }
             return node;
         }
@@ -177,7 +177,7 @@ private GenericExpressionNode BooleanTerm(string expression)
             if (node == null)
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
             }
 
             if (!_lexer.IsNext(Token.TokenType.EndOfInput))
@@ -199,7 +199,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
                 if (rhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
 
                 OperatorExpressionNode andNode = new AndExpressionNode();
@@ -221,7 +221,7 @@ private GenericExpressionNode RelationalExpr(string expression)
                 if (lhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
 
                 OperatorExpressionNode node = RelationalOperation(expression);
@@ -284,7 +284,7 @@ private GenericExpressionNode Factor(string expression)
                 if (!Same(expression, Token.TokenType.LeftParenthesis))
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", _lexer.IsNextString(), errorPosition);
                     return null;
                 }
                 var arglist = new List<GenericExpressionNode>();
@@ -292,7 +292,7 @@ private GenericExpressionNode Factor(string expression)
                 if (!Same(expression, Token.TokenType.RightParenthesis))
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                     return null;
                 }
                 return new FunctionCallExpressionNode(current.String, arglist);
@@ -305,7 +305,7 @@ private GenericExpressionNode Factor(string expression)
                 else
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
             }
             else if (Same(expression, Token.TokenType.Not))
@@ -315,7 +315,7 @@ private GenericExpressionNode Factor(string expression)
                 if (expr == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
                 notNode.LeftChild = expr;
                 return notNode;
@@ -323,7 +323,7 @@ private GenericExpressionNode Factor(string expression)
             else
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
             }
             return null;
         }
@@ -384,11 +384,11 @@ private bool Same(string expression, Token.TokenType token)
                     errorPosition = _lexer.GetErrorPosition();
                     if (_lexer.UnexpectedlyFound != null)
                     {
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
+                        ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
                     }
                     else
                     {
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, _lexer.GetErrorResource(), expression, errorPosition);
+                        ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, _lexer.GetErrorResource(), expression, errorPosition);
                     }
                 }
                 return true;
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 61eabd438fd..54afb1dc6b8 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Diagnostics;
-
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
@@ -29,60 +28,35 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        /// <summary>
-        /// Evaluate as boolean
-        /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return ConversionUtilities.ConvertStringToBool(GetExpandedValue(state));
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
         }
 
-        /// <summary>
-        /// Evaluate as numeric
-        /// </summary>
-        internal override double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
-                return ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
+                result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
+                return true;
             }
-
-            return ConversionUtilities.ConvertDecimalOrHexToDouble(GetExpandedValue(state));
-        }
-
-        internal override Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            else
             {
-                return Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
             }
-
-            return Version.Parse(GetExpandedValue(state));
         }
 
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            return ConversionUtilities.CanConvertStringToBool(GetExpandedValue(state));
-        }
-
-        internal override bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
+                result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
-
-            return ConversionUtilities.ValidDecimalOrHexNumber(GetExpandedValue(state));
-        }
-
-        internal override bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            else
             {
-                return true;
+                return Version.TryParse(GetExpandedValue(state), out result);
             }
-
-            return Version.TryParse(GetExpandedValue(state), out _);
         }
 
         /// <summary>
@@ -98,6 +72,25 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
             {
                 if (_expandable)
                 {
+                    switch (_value.Length)
+                    {
+                        case 0:
+                            _cachedExpandedValue = String.Empty;
+                            return true;
+                        // If the length is 1 or 2, it can't possibly be a property, item, or metadata, and it isn't empty.
+                        case 1:
+                        case 2:
+                            _cachedExpandedValue = _value;
+                            return false;
+                        default:
+                            if (_value[1] != '(' || (_value[0] != '$' && _value[0] != '%' && _value[0] != '@') || _value[_value.Length - 1] != ')')
+                            {
+                                // This isn't just a property, item, or metadata value, and it isn't empty.
+                                return false;
+                            }
+                            break;
+                    }
+
                     string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
 
                     if (expandBreakEarly == null)
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index ffa04158d9d..1ea8786cf67 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -110,12 +110,14 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
         {
             List<ItemExpressionCapture> subExpressions = null;
 
-            if (expression.IndexOf('@') < 0)
+            int startIndex = expression.IndexOf('@', start, end - start);
+
+            if (startIndex < 0)
             {
                 return null;
             }
 
-            for (int i = start; i < end; i++)
+            for (int i = startIndex; i < end; i++)
             {
                 int restartPoint;
                 int startPoint;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index 1db3ddfd3ce..d63e2a31c38 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -23,7 +23,7 @@ public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M
                 _matchOnMetadata = builder.MatchOnMetadata.ToImmutable();
 
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                    _matchOnMetadata.IsEmpty || _itemSpec.Fragments.All(f => f is ItemSpec<ProjectProperty, ProjectItem>.ItemExpressionFragment),
+                    _matchOnMetadata.IsEmpty || _itemSpec.Fragments.All(f => f is ItemSpec<P, I>.ItemExpressionFragment),
                     new BuildEventFileInfo(string.Empty),
                     "OM_MatchOnMetadataIsRestrictedToReferencedItems");
 
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 761ef477d6f..186ed1ddf4c 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -127,7 +127,10 @@ private void Parse()
             // XML guarantees exactly one root element
             XmlElementWithLocation element = _document.DocumentElement as XmlElementWithLocation;
 
-            ProjectErrorUtilities.VerifyThrowInvalidProject(element != null, ElementLocation.Create(_document.FullPath), "NoRootProjectElement", XMakeElements.project);
+            if (element is null)
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(ElementLocation.Create(_document.FullPath), "NoRootProjectElement", XMakeElements.project);
+            }
             ProjectErrorUtilities.VerifyThrowInvalidProject(element.Name != XMakeElements.visualStudioProject, element.Location, "ProjectUpgradeNeeded", _project.FullPath);
             ProjectErrorUtilities.VerifyThrowInvalidProject(element.LocalName == XMakeElements.project, element.Location, "UnrecognizedElement", element.Name);
 
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index 62f79e2d8a0..2ba9a93a0e4 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -459,6 +459,8 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _keepMetadataLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _removeMetadataLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _keepDuplicatesLocation, ElementLocation.FactoryForDeserialization);
+            translator.Translate(ref _matchOnMetadataLocation, ElementLocation.FactoryForDeserialization);
+            translator.Translate(ref _matchOnMetadataOptionsLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _conditionLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _metadata, ProjectItemGroupTaskMetadataInstance.FactoryForDeserialization);
         }
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 802539f6077..4596be57f52 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -282,7 +282,7 @@ string taskProjectFile
             {
                 // Exception thrown by the called code itself
                 // Log the stack, so the task vendor can fix their code
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, Environment.NewLine + e.InnerException.ToString());
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, Environment.NewLine + e.InnerException.ToString());
             }
             catch (ReflectionTypeLoadException e)
             {
@@ -295,12 +295,12 @@ string taskProjectFile
                     }
                 }
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
             catch (ArgumentNullException e)
             {
                 // taskName may be null
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
@@ -309,7 +309,7 @@ string taskProjectFile
                     throw;
                 }
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
 
             return _loadedType;
@@ -355,15 +355,12 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 
                 mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                string runtime = null;
-                string architecture = null;
-
-                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out runtime))
+                if (!mergedParameters.ContainsKey(XMakeAttributes.runtime))
                 {
-                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.MSBuildRuntimeValues.clr4;
+                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.GetCurrentMSBuildRuntime();
                 }
 
-                if (!mergedParameters.TryGetValue(XMakeAttributes.architecture, out architecture))
+                if (!mergedParameters.ContainsKey(XMakeAttributes.architecture))
                 {
                     mergedParameters[XMakeAttributes.architecture] = XMakeAttributes.GetCurrentMSBuildArchitecture();
                 }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 167a67e396e..28f1d0d9d5f 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -352,7 +352,7 @@ internal static LoggerVerbosity ImportanceToMinimumVerbosity(MessageImportance i
                     return LoggerVerbosity.Detailed;
 
                 default:
-                    ErrorUtilities.VerifyThrow(false, "Impossible");
+                    ErrorUtilities.ThrowInternalError("Impossible");
                     lightenText = false;
                     return LoggerVerbosity.Detailed;
             }
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index c64e5f2fd85..72f225241d3 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -183,7 +183,7 @@ public LoggerVerbosity Verbosity
         {
             get
             {
-                ErrorUtilities.VerifyThrow(false, "Should not be getting verbosity from distributed file logger");
+                ErrorUtilities.ThrowInternalError("Should not be getting verbosity from distributed file logger");
                 return LoggerVerbosity.Detailed;
             }
             set
diff --git a/src/Build/Logging/NullCentralLogger.cs b/src/Build/Logging/NullCentralLogger.cs
index b2101e63bc6..de64da650a1 100644
--- a/src/Build/Logging/NullCentralLogger.cs
+++ b/src/Build/Logging/NullCentralLogger.cs
@@ -53,7 +53,7 @@ public void AnyEventRaisedHandler(object sender, BuildEventArgs e)
         {
             if (!(e is BuildStartedEventArgs) && !(e is BuildFinishedEventArgs))
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(false, "Should not receive any events other than build started or finished");
+                ErrorUtilities.ThrowInvalidOperation("Should not receive any events other than build started or finished");
             }
         }
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 9deedd88b0e..4784c183001 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -702,7 +702,7 @@ private string GetCurrentlyBuildingProjectFile()
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unexpected frame type.");
+                ErrorUtilities.ThrowInternalError("Unexpected frame type.");
                 return null;
             }
         }
@@ -752,7 +752,7 @@ private void ShowDeferredMessages()
                         break;
 
                     default:
-                        ErrorUtilities.VerifyThrow(false, "Unexpected frame type.");
+                        ErrorUtilities.ThrowInternalError("Unexpected frame type.");
                         break;
                 }
             }
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 242085521c9..40347473d2a 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -236,18 +236,13 @@ internal static Func<string, bool> GetFileSpecMatchTester(IList<string> filespec
             return file => matchers.Any(m => m.Value.IsMatch(file));
         }
 
-        internal class IOCache
+        internal sealed class IOCache
         {
             private readonly Lazy<ConcurrentDictionary<string, bool>> existenceCache = new Lazy<ConcurrentDictionary<string, bool>>(() => new ConcurrentDictionary<string, bool>(), true);
 
-            public virtual bool DirectoryExists(string directory)
+            public bool DirectoryExists(string directory)
             {
-                return existenceCache.Value.GetOrAdd(directory, Directory.Exists);
-            }
-
-            public virtual bool FileExists(string file)
-            {
-                return existenceCache.Value.GetOrAdd(file, File.Exists);
+                return existenceCache.Value.GetOrAdd(directory, directory => Directory.Exists(directory));
             }
         }
     }
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index ce322f9833b..cb6fabf4c0d 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -80,7 +80,6 @@
     <DefineConstants>$(DefineConstants);FEATURE_SYSTEMPAGESIZE</DefineConstants>
     <FeatureSystemConfiguration>true</FeatureSystemConfiguration>
     <DefineConstants>$(DefineConstants);FEATURE_TASK_GENERATERESOURCES</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_TASKHOST</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_ABORT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_CULTURE</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_PRIORITY</DefineConstants>
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 17594f48d2f..08aaad0b333 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -105,6 +105,7 @@
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\NativeMethodsShared.cs">
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index c032f6978c2..6643148f7ff 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1164,9 +1164,11 @@ elementFormDefault="qualified">
       </xs:annotation>
       <xs:simpleType>
         <xs:restriction base="xs:string">
-          <xs:enumeration value="Default" />
-          <xs:enumeration value="AllEnabledByDefault" />
-          <xs:enumeration value="AllDisabledByDefault" />
+          <xs:enumeration value="none" />
+          <xs:enumeration value="default" />
+          <xs:enumeration value="minimum" />
+          <xs:enumeration value="recommended" />
+          <xs:enumeration value="all" />
         </xs:restriction>
       </xs:simpleType>
     </xs:element>
@@ -1608,7 +1610,32 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="InstallFrom" _locComment="" -->Web, Unc, or Disk</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="AnalysisLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="AnalysisLevel" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AnalysisLevel" _locComment="" -->Customizes the set of rules that are enabled by default.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="none" />
+          <xs:enumeration value="latest" />
+          <xs:enumeration value="latest-minimum" />
+          <xs:enumeration value="latest-recommended" />
+          <xs:enumeration value="latest-all" />
+          <xs:enumeration value="preview" />
+          <xs:enumeration value="preview-minimum" />
+          <xs:enumeration value="preview-recommended" />
+          <xs:enumeration value="preview-all" />
+          <xs:enumeration value="5.0" />
+          <xs:enumeration value="5.0-minimum" />
+          <xs:enumeration value="5.0-recommended" />
+          <xs:enumeration value="5.0-all" />
+          <xs:enumeration value="6.0" />
+          <xs:enumeration value="6.0-minimum" />
+          <xs:enumeration value="6.0-recommended" />
+          <xs:enumeration value="6.0-all" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
     <xs:element name="InstallUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="IsCodeSharingProject" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="IsPackable" type="msb:boolean" substitutionGroup="msb:Property">
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index a03db6f636f..1714165cad1 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -16,10 +16,9 @@ internal class NodeEndpointOutOfProcTaskHost : NodeEndpointOutOfProcBase
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
-        internal NodeEndpointOutOfProcTaskHost(string pipeName)
+        internal NodeEndpointOutOfProcTaskHost()
         {
-            InternalConstruct(pipeName);
+            InternalConstruct();
         }
 
         #endregion // Constructors and Factories
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 6dc795d6762..d4212f1d09b 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -612,9 +612,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
             // Snapshot the current environment
             _savedEnvironment = CommunicationsUtilities.GetEnvironmentVariables();
 
-            string pipeName = "MSBuild" + Process.GetCurrentProcess().Id;
-
-            _nodeEndpoint = new NodeEndpointOutOfProcTaskHost(pipeName);
+            _nodeEndpoint = new NodeEndpointOutOfProcTaskHost();
             _nodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(OnLinkStatusChanged);
             _nodeEndpoint.Listen(this);
 
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index c4408477cfa..ae95d608193 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1551,7 +1551,7 @@ private static void VerifyThrowSupportedOS()
             {
                 // If we're running on any of the unsupported OS's, fail immediately.  This way,
                 // we don't run into some obscure error down the line, totally confusing the user.
-                InitializationException.VerifyThrow(false, "UnsupportedOS");
+                InitializationException.Throw("UnsupportedOS", null, null, false);
             }
 #endif
         }
@@ -2843,7 +2843,7 @@ DirectoryGetFiles getFiles
                 // If there is more than one solution file in the current directory we have no idea which one to use
                 else if (actualSolutionFiles.Count > 1)
                 {
-                    InitializationException.VerifyThrow(false, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                    InitializationException.VerifyThrow(false, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory, false);
                 }
                 // If there is more than one project file in the current directory we may be able to figure it out
                 else if (actualProjectFiles.Count > 1)
@@ -2883,7 +2883,7 @@ DirectoryGetFiles getFiles
                          actualSolutionFiles.Count== 0 &&
                          solutionFilterFiles.Count == 0)
                 {
-                    InitializationException.VerifyThrow(false, "MissingProjectError");
+                    InitializationException.Throw("MissingProjectError", null, null, false);
                 }
                 else
                 {
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 66f5bc78f00..b26225401f6 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -108,6 +108,7 @@
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Modifiers.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\NativeMethodsShared.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 4b118f31594..3c472f898d0 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -60,7 +60,12 @@ internal enum HandshakeOptions
         /// <summary>
         /// Building with administrator privileges
         /// </summary>
-        Administrator = 32
+        Administrator = 32,
+
+        /// <summary>
+        /// Using the .NET Core/.NET 5.0+ runtime
+        /// </summary>
+        NET = 64,
     }
 
     internal readonly struct Handshake
@@ -75,7 +80,7 @@ internal readonly struct Handshake
 
         internal Handshake(HandshakeOptions nodeType)
         {
-            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
+            // We currently use 7 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
             // This indicates in the first byte that we are a modern build.
             options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
@@ -492,7 +497,23 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), "Should always have an explicit runtime when we call this method.");
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), "Should always have an explicit architecture when we call this method.");
 
-                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
+                    if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 2;
+                    } 
+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 4;
+                    }
+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.net, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 5;
+                    }
+                    else
+                    {
+                        ErrorUtilities.ThrowInternalErrorUnreachable();
+                    }
+
                     is64Bit = architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
             }
@@ -501,10 +522,26 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
             {
                 context |= HandshakeOptions.X64;
             }
-            if (clrVersion == 2)
+
+            switch (clrVersion)
             {
-                context |= HandshakeOptions.CLR2;
+                case 0:
+                    // Not a taskhost, runtime must match
+                case 4:
+                    // Default for MSBuild running on .NET Framework 4,
+                    // not represented in handshake
+                    break;
+                case 2:
+                    context |= HandshakeOptions.CLR2;
+                    break;
+                case >= 5:
+                    context |= HandshakeOptions.NET;
+                    break;
+                default:
+                    ErrorUtilities.ThrowInternalErrorUnreachable();
+                    break;
             }
+
             if (nodeReuse)
             {
                 context |= HandshakeOptions.NodeReuse;
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 6289ef54bef..9a36fc1816e 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -77,6 +77,16 @@ internal static class MSBuildConstants
         /// </summary>
         internal const string DefaultTargetsMarker = ".default";
 
+        /// <summary>
+        /// Framework version against which our test projects should be built.
+        /// </summary>
+        /// <remarks>
+        /// The targeting pack for this version of .NET Framework must be installed
+        /// on any machine that wants to run tests successfully, so this can be
+        /// periodically updated.
+        /// </remarks>
+        internal const string StandardTestTargetFrameworkVersion = "v4.8";
+
         /// <summary>
         /// Symbol used in ProjectReferenceTarget items to represent targets specified on the ProjectReference item
         /// with fallback to default targets if the ProjectReference item has no targets specified.
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 351b3b04e46..a6febc5c973 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Globalization;
 using System.Text;
-using error = Microsoft.Build.Shared.ErrorUtilities;
+using Error = Microsoft.Build.Shared.ErrorUtilities;
 
 namespace Microsoft.Build.Shared
 {
@@ -33,7 +33,7 @@ internal static bool ConvertStringToBool(string parameterValue)
             else
             {
                 // Unsupported boolean representation.
-                error.VerifyThrowArgument(false, "Shared.CannotConvertStringToBool", parameterValue);
+                Error.ThrowArgument("Shared.CannotConvertStringToBool", parameterValue);
                 return false;
             }
         }
@@ -64,6 +64,21 @@ internal static string ConvertByteArrayToHex(byte[] bytes)
             return sb.ToString();
         }
 
+        internal static bool TryConvertStringToBool(string parameterValue, out bool boolValue)
+        {
+            boolValue = false;
+            if (ValidBooleanTrue(parameterValue))
+            {
+                boolValue = true;
+                return true;
+            }
+            else if (ValidBooleanFalse(parameterValue))
+            {
+                return true;
+            }
+            return false;
+        }
+
         /// <summary>
         /// Returns true if the string can be successfully converted to a bool,
         /// such as "on" or "yes"
@@ -123,30 +138,40 @@ internal static double ConvertHexToDouble(string number)
         /// </summary>
         internal static double ConvertDecimalOrHexToDouble(string number)
         {
-            if (ConversionUtilities.ValidDecimalNumber(number))
+            if (TryConvertDecimalOrHexToDouble(number, out double result))
             {
-                return ConversionUtilities.ConvertDecimalToDouble(number);
+                return result;
             }
-            else if (ConversionUtilities.ValidHexNumber(number))
+            Error.ThrowInternalError("Cannot numeric evaluate");
+            return 0.0D;
+        }
+
+        internal static bool TryConvertDecimalOrHexToDouble(string number, out double doubleValue)
+        {
+            if (ConversionUtilities.ValidDecimalNumber(number, out doubleValue))
             {
-                return ConversionUtilities.ConvertHexToDouble(number);
+                return true;
+            }
+            else if (ConversionUtilities.ValidHexNumber(number, out int hexValue))
+            {
+                doubleValue = (double)hexValue;
+                return true;
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Cannot numeric evaluate");
-                return 0.0D;
+                return false;
             }
         }
 
         /// <summary>
         /// Returns true if the string is a valid hex number, like "0xABC"
         /// </summary>
-        private static bool ValidHexNumber(string number)
+        private static bool ValidHexNumber(string number, out int value)
         {
             bool canConvert = false;
+            value = 0;
             if (number.Length >= 3 && number[0] == '0' && (number[1] == 'x' || number[1] == 'X'))
             {
-                int value;
                 canConvert = Int32.TryParse(number.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat, out value);
             }
             return canConvert;
@@ -155,9 +180,8 @@ private static bool ValidHexNumber(string number)
         /// <summary>
         /// Returns true if the string is a valid decimal number, like "-123.456"
         /// </summary>
-        private static bool ValidDecimalNumber(string number)
+        private static bool ValidDecimalNumber(string number, out double value)
         {
-            double value;
             return Double.TryParse(number, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture.NumberFormat, out value) && !double.IsInfinity(value);
         }
 
@@ -166,7 +190,7 @@ private static bool ValidDecimalNumber(string number)
         /// </summary>
         internal static bool ValidDecimalOrHexNumber(string number)
         {
-            return ValidDecimalNumber(number) || ValidHexNumber(number);
+            return ValidDecimalNumber(number, out _) || ValidHexNumber(number, out _);
         }
     }
 }
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 9bb3502596b..05dcb114de3 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -488,7 +488,7 @@ params object[] args
         /// <param name="innerException">Can be null.</param>
         /// <param name="resourceName"></param>
         /// <param name="args"></param>
-        private static void ThrowArgument
+        internal static void ThrowArgument
         (
             Exception innerException,
             string resourceName,
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 22a9572fc82..cca9caee3b3 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -246,7 +246,7 @@ private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem
                 case FileSystemEntity.Directories: return GetAccessibleDirectories(fileSystem, path, pattern);
                 case FileSystemEntity.FilesAndDirectories: return GetAccessibleFilesAndDirectories(fileSystem, path, pattern);
                 default:
-                    ErrorUtilities.VerifyThrow(false, "Unexpected filesystem entity type.");
+                    ErrorUtilities.ThrowInternalError("Unexpected filesystem entity type.");
                     break;
             }
             return Array.Empty<string>();
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 76155b33800..952fd9963d4 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -903,7 +903,7 @@ internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSys
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryExists)
+                    ? FileExistenceCache.GetOrAdd(fullPath, fullPath => fileSystem.DirectoryExists(fullPath))
                     : fileSystem.DirectoryExists(fullPath);
             }
             catch
@@ -927,7 +927,7 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileExists)
+                    ? FileExistenceCache.GetOrAdd(fullPath, fullPath => fileSystem.FileExists(fullPath))
                     : fileSystem.FileExists(fullPath);
             }
             catch
@@ -951,7 +951,7 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileOrDirectoryExists)
+                    ? FileExistenceCache.GetOrAdd(fullPath, fullPath => fileSystem.FileOrDirectoryExists(fullPath))
                     : fileSystem.FileOrDirectoryExists(fullPath);
             }
             catch
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index afdbc7fefec..42237dde8c9 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -976,13 +976,10 @@ internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootP
 
             try
             {
-                string path = targetFrameworkRootPath;
-                path = Path.Combine(path, frameworkName.Identifier);
-                path = Path.Combine(path, "v" + frameworkName.Version.ToString());
+                string path = Path.Combine(targetFrameworkRootPath, frameworkName.Identifier, "v" + frameworkName.Version.ToString());
                 if (!String.IsNullOrEmpty(frameworkName.Profile))
                 {
-                    path = Path.Combine(path, "Profile");
-                    path = Path.Combine(path, frameworkName.Profile);
+                    path = Path.Combine(path, "Profile", frameworkName.Profile);
                 }
 
                 return Path.GetFullPath(path);
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index 1ad37579cb6..bfb564d884b 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -599,7 +599,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
-                    ErrorUtilities.VerifyThrowInvalidOperation(false, "Shared.InvalidFilespecForTransform", modifier, itemSpec, e.Message);
+                    ErrorUtilities.ThrowInvalidOperation("Shared.InvalidFilespecForTransform", modifier, itemSpec, e.Message);
                 }
 
                 return modifiedItemSpec;
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index a7f8913e7d7..e3b1341515f 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -1,15 +1,24 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
+using System.Diagnostics;
 using System.IO;
 
+#nullable enable
+
 namespace Microsoft.Build.Shared
 {
     internal static class NamedPipeUtil
     {
-        internal static string GetPipeNameOrPath(string pipeName)
+        internal static string GetPipeNameOrPath(int? processId = null)
         {
+            if (processId is null)
+            {
+                processId = Process.GetCurrentProcess().Id;
+            }
+
+            string pipeName = $"MSBuild{processId}";
+
             if (NativeMethodsShared.IsUnixLike)
             {
                 // If we're on a Unix machine then named pipes are implemented using Unix Domain Sockets.
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 3d468e23e95..4562c4309d7 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -183,11 +183,8 @@ public void SendData(INodePacket packet)
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
-        internal void InternalConstruct(string pipeName)
+        internal void InternalConstruct()
         {
-            ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
-
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
             _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
@@ -195,6 +192,8 @@ internal void InternalConstruct(string pipeName)
             _packetStream = new MemoryStream();
             _binaryWriter = new BinaryWriter(_packetStream);
 
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath();
+
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
             if (!NativeMethodsShared.IsMono)
             {
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index 540b26f71d1..b02ed0ef6c3 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -57,7 +57,7 @@ internal static void ThrowInvalidProject<T1>
             T1 arg0
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0);
         }
 
         /// <summary>
@@ -93,7 +93,7 @@ internal static void ThrowInvalidProject<T1, T2>
             T2 arg1
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0, arg1);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1);
         }
 
         /// <summary>
@@ -113,7 +113,7 @@ internal static void ThrowInvalidProject<T1, T2, T3>
             T3 arg2
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0, arg1, arg2);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1, arg2);
         }
 
         /// <summary>
@@ -135,7 +135,7 @@ internal static void ThrowInvalidProject<T1, T2, T3, T4>
             T4 arg3
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0, arg1, arg2, arg3);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1, arg2, arg3);
         }
 
         /// <summary>
@@ -396,16 +396,9 @@ params object[] args
 
             ResourceUtilities.VerifyResourceStringExists(resourceName);
 #endif
-            string errorSubCategory = null;
+            string errorSubCategory = errorSubCategoryResourceName is null ? null : AssemblyResources.GetString(errorSubCategoryResourceName);
 
-            if (errorSubCategoryResourceName != null)
-            {
-                errorSubCategory = AssemblyResources.GetString(errorSubCategoryResourceName);
-            }
-
-            string errorCode;
-            string helpKeyword;
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errorCode, out helpKeyword, resourceName, args);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, resourceName, args);
 
             throw new InvalidProjectFileException(elementLocation.File, elementLocation.Line, elementLocation.Column, 0 /* Unknown end line */, 0 /* Unknown end column */, message, errorSubCategory, errorCode, helpKeyword);
         }
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index d672e250e5f..bcc433204d0 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -29,7 +29,7 @@ internal static void ThrowInvalidProjectFile
             params object[] args
         )
         {
-            VerifyThrowInvalidProjectFile(false, null, projectFile, resourceName, args);
+            ThrowInvalidProjectFile(null, projectFile, resourceName, args);
         }
 
         /// <summary>
@@ -157,16 +157,8 @@ params object[] args
 #endif
             if (!condition)
             {
-                string errorSubCategory = null;
-
-                if (errorSubCategoryResourceName != null)
-                {
-                    errorSubCategory = AssemblyResources.GetString(errorSubCategoryResourceName);
-                }
-
-                string errorCode;
-                string helpKeyword;
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errorCode, out helpKeyword, resourceName, args);
+                string errorSubCategory = errorSubCategoryResourceName is null ? null : AssemblyResources.GetString(errorSubCategoryResourceName);
+                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, resourceName, args);
 
                 throw new InvalidProjectFileException(projectFile.File, projectFile.Line, projectFile.Column, projectFile.EndLine, projectFile.EndColumn, message, errorSubCategory, errorCode, helpKeyword, innerException);
             }
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 4ee21110651..7de1b7c8ab1 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -1435,7 +1435,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
                         }
 
                     default:
-                        ErrorUtilities.VerifyThrow(false, "Impossible canonical part.");
+                        ErrorUtilities.ThrowInternalError("Impossible canonical part.");
                         break;
                 }
             }
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index f3c58b19237..70cf960d823 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
+
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -47,35 +49,82 @@ public void TestIsNonBatchingTargetAttribute()
         public void TestRuntimeValuesMatch()
         {
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime));
+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.net));
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4));
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any));
+#if NET5_0_OR_GREATER
+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.net));
+#else
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4));
+#endif
 
+            // Never true
             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2));
+
             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2));
+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.net));
+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.net));
         }
 
-        [Fact]
-        public void TestMergeRuntimeValues()
+        [Theory]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4, true, XMakeAttributes.MSBuildRuntimeValues.clr4)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.any, true, XMakeAttributes.MSBuildRuntimeValues.clr4)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any, true, XMakeAttributes.MSBuildRuntimeValues.clr2)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2, false, null)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2, false, null)]
+        public void TestMergeRuntimeValues(string left, string right, bool success, string expected)
         {
-            string mergedRuntime;
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            XMakeAttributes.TryMergeRuntimeValues(left, right, out string mergedRuntime)
+                .ShouldBe(success);
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            mergedRuntime.ShouldBe(expected);
+        }
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr2, mergedRuntime);
+        [Fact]
+        public void TestMergeRuntimeValuesAnyAcceptsCurrent()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any,
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                out string mergedRuntime)
+                .ShouldBeTrue();
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            mergedRuntime.ShouldBe(XMakeAttributes.GetCurrentMSBuildRuntime());
+        }
 
-            Assert.False(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2, out mergedRuntime));
-            Assert.Null(mergedRuntime);
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp,
+            "Tests whether 'current' merges with 'clr4' which is true only on Framework")]
+        public void TestMergeRuntimeValuesCurrentToClr4()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.clr4,
+                out string mergedRuntime).ShouldBeTrue();
+            mergedRuntime.ShouldBe(XMakeAttributes.MSBuildRuntimeValues.clr4);
+
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.net,
+                out mergedRuntime).ShouldBeFalse();
+            mergedRuntime.ShouldBeNull();
+        }
 
-            Assert.False(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2, out mergedRuntime));
-            Assert.Null(mergedRuntime);
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework,
+            "Tests whether 'current' merges with 'net' which is true only on core")]
+        public void TestMergeRuntimeValuesCurrentToCore()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.net,
+                out string mergedRuntime).ShouldBeTrue();
+            mergedRuntime.ShouldBe(XMakeAttributes.MSBuildRuntimeValues.net);
+
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.clr4,
+                out mergedRuntime).ShouldBeFalse();
+            mergedRuntime.ShouldBeNull();
         }
 
         [Fact]
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index 461bc2ef740..d290eee6246 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Runtime.CompilerServices;
 
 namespace Microsoft.Build.Shared
 {
@@ -76,6 +77,7 @@ internal struct MSBuildRuntimeValues
             internal const string clr2 = "CLR2";
             internal const string clr4 = "CLR4";
             internal const string currentRuntime = "CurrentRuntime";
+            internal const string net = "NET";
             internal const string any = "*";
         }
 
@@ -99,7 +101,7 @@ internal struct MSBuildArchitectureValues
 
         private static readonly HashSet<string> KnownBatchingTargetAttributes = new HashSet<string> { name, condition, dependsOnTargets, beforeTargets, afterTargets };
 
-        private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.any };
+        private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.net, MSBuildRuntimeValues.any };
 
         private static readonly HashSet<string> ValidMSBuildArchitectureValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildArchitectureValues.x86, MSBuildArchitectureValues.x64, MSBuildArchitectureValues.currentArchitecture, MSBuildArchitectureValues.any };
 
@@ -179,10 +181,10 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
                 return true;
             }
 
-            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase)) ||
-                (runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))
+            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase)) ||
+                (runtimeA.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))
             {
-                // CLR4 is the current runtime, so this is also a match. 
+                // Matches the current runtime, so match.
                 return true;
             }
 
@@ -216,13 +218,15 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 runtimeB = MSBuildRuntimeValues.any;
             }
 
+            string actualCurrentRuntime = GetCurrentMSBuildRuntime();
+
             // if they're equal, then there's no problem -- just return the equivalent runtime.  
             if (runtimeA.Equals(runtimeB, StringComparison.OrdinalIgnoreCase))
             {
                 if (runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                     runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))
                 {
-                    mergedRuntime = MSBuildRuntimeValues.clr4;
+                    mergedRuntime = actualCurrentRuntime;
                 }
                 else
                 {
@@ -232,21 +236,22 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 return true;
             }
 
-            // if both A and B are one of CLR4, don't care, or current, then the end result will be CLR4 no matter what.  
+            // if both A and B are one of actual-current-runtime, don't care or current,
+            // then the end result will be current-runtime no matter what.  
             if (
                 (
-                 runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ||
+                 runtimeA.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase)
                 ) &&
                 (
-                 runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ||
+                 runtimeB.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeB.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase)
                 )
                )
             {
-                mergedRuntime = MSBuildRuntimeValues.clr4;
+                mergedRuntime = actualCurrentRuntime;
                 return true;
             }
 
@@ -320,8 +325,8 @@ internal static string GetExplicitMSBuildRuntime(string runtime)
                 MSBuildRuntimeValues.any.Equals(runtime, StringComparison.OrdinalIgnoreCase) ||
                 MSBuildRuntimeValues.currentRuntime.Equals(runtime, StringComparison.OrdinalIgnoreCase))
             {
-                // Default to CLR4.
-                return MSBuildRuntimeValues.clr4;
+                // Default to current.
+                return GetCurrentMSBuildRuntime();
             }
             else
             {
@@ -425,6 +430,18 @@ internal static string GetCurrentMSBuildArchitecture()
             return currentArchitecture;
         }
 
+        /// <summary>
+        /// Returns the MSBuildRuntime value corresponding to the current process' runtime. 
+        /// </summary>
+        internal static string GetCurrentMSBuildRuntime()
+        {
+#if NET40_OR_GREATER
+            return MSBuildRuntimeValues.clr4;
+#else
+            return MSBuildRuntimeValues.net;
+#endif
+        }
+
         /// <summary>
         /// Given an MSBuildArchitecture value that may be non-explicit -- e.g. "CurrentArchitecture" or "Any" --
         /// return the specific MSBuildArchitecture value that it would map to in this case.  If it does not map 
diff --git a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
index 88f8cf4959f..a88113e0319 100644
--- a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
+++ b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
@@ -23,9 +23,9 @@ sealed public class GetReferenceAssmeblyPath_Tests
         [Fact]
         public void TestGeneralFrameworkMonikerGood()
         {
-            string targetFrameworkMoniker = ".NetFramework, Version=v4.5";
-            MockEngine engine = new MockEngine();
-            GetReferenceAssemblyPaths getReferencePaths = new GetReferenceAssemblyPaths();
+            string targetFrameworkMoniker = ".NetFramework, Version=v4.8";
+            MockEngine engine = new();
+            GetReferenceAssemblyPaths getReferencePaths = new();
             getReferencePaths.BuildEngine = engine;
             getReferencePaths.TargetFrameworkMoniker = targetFrameworkMoniker;
             getReferencePaths.Execute();
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 05200fcfac9..04ef5ffcd1d 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -7,6 +7,7 @@
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 
@@ -350,12 +351,13 @@ public void PropertyOverridesContainSemicolon()
 
             // Just a normal console application project.
             ObjectModelHelpers.CreateFileInTempProjectDirectory(
-                Path.Combine("bug'533'369", "Sub;Dir", "ConsoleApplication1", "ConsoleApplication1.csproj"), @"
+                Path.Combine("bug'533'369", "Sub;Dir", "ConsoleApplication1", "ConsoleApplication1.csproj"), $@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                   <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                   <PropertyGroup>
                     <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
+                    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                     <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                     <OutputType>Exe</OutputType>
                     <AssemblyName>ConsoleApplication1</AssemblyName>
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 98ae00b9da8..74020be52f0 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-
     <IsPackable>false</IsPackable>
 
     <AssemblyName>Microsoft.Build.Tasks.UnitTests</AssemblyName>
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index f400cef6a24..f9aabd40908 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -52,13 +52,16 @@ public void OverrideBaseIntermediateOutputPathSucceeds()
         [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsWindows))]
         public void AssemblyAttributesLocation()
         {
-            var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.0.AssemblyAttributes.cs");
+            var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.8.AssemblyAttributes.cs");
 
             var project = ObjectModelHelpers.CreateInMemoryProject($@"
 <Project>
   <Import Project=""$(MSBuildToolsPath)\Microsoft.Common.props"" />
+  <PropertyGroup>
+    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
+  </PropertyGroup>
   <ItemGroup>
-    <Compile Include=""a.cs""/>       
+    <Compile Include=""a.cs""/>
   </ItemGroup>
   <Import Project=""$(MSBuildToolsPath)\Microsoft.CSharp.targets"" />
 
diff --git a/src/Tasks.UnitTests/RemoveDir_Tests.cs b/src/Tasks.UnitTests/RemoveDir_Tests.cs
index 7f88ef17839..0dee182082b 100644
--- a/src/Tasks.UnitTests/RemoveDir_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDir_Tests.cs
@@ -1,15 +1,25 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
+using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
 {
     sealed public class RemoveDir_Tests
     {
+        ITestOutputHelper _output;
+        public RemoveDir_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
         /*
          * Method:   AttributeForwarding
          *
@@ -23,14 +33,42 @@ public void AttributeForwarding()
             ITaskItem i = new TaskItem("MyNonExistentDirectory");
             i.SetMetadata("Locale", "en-GB");
             t.Directories = new ITaskItem[] { i };
-            t.BuildEngine = new MockEngine();
+            t.BuildEngine = new MockEngine(_output);
 
             t.Execute();
 
-            Assert.Equal("en-GB", t.RemovedDirectories[0].GetMetadata("Locale"));
+            t.RemovedDirectories[0].GetMetadata("Locale").ShouldBe("en-GB");
+            t.RemovedDirectories[0].ItemSpec.ShouldBe("MyNonExistentDirectory");
+            Directory.Exists(t.RemovedDirectories[0].ItemSpec).ShouldBeFalse();
+        }
+
+        [Fact]
+        public void SimpleDelete()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                List<TaskItem> list = new List<TaskItem>();
+
+                for (int i = 0; i < 20; i++)
+                {
+                    list.Add(new TaskItem(env.CreateFolder().Path));
+                }
+
+                RemoveDir t = new RemoveDir();
+
+                t.Directories = list.ToArray();
+                t.BuildEngine = new MockEngine(_output);
+
+                t.Execute().ShouldBeTrue();
+
+                t.RemovedDirectories.Length.ShouldBe(list.Count);
 
-            // Output ItemSpec should not be overwritten.
-            Assert.Equal("MyNonExistentDirectory", t.RemovedDirectories[0].ItemSpec);
+                for (int i = 0; i < 20; i++)
+                {
+                    Directory.Exists(list[i].ItemSpec).ShouldBeFalse();
+                }
+            }
         }
     }
 }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 6d055df7140..8ffdf31868d 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -2369,14 +2369,15 @@ public void DontLockP2PReferenceWhenResolvingSystemTypes()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", @"
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", $@"
 
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                             <AssemblyName>lib1</AssemblyName>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
                         </PropertyGroup>
@@ -2546,13 +2547,13 @@ public void ReferencedAssemblySpecifiedUsingRelativePath()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <AssemblyName>ClassLibrary20</AssemblyName>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 99e3d7066b0..3e20f81bc0f 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -2730,14 +2730,14 @@ public void DontLockP2PReferenceWhenResolvingSystemTypes()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                             <AssemblyName>lib1</AssemblyName>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
                         </PropertyGroup>
@@ -2908,13 +2908,13 @@ public void ReferencedAssemblySpecifiedUsingRelativePath()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <AssemblyName>ClassLibrary20</AssemblyName>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
diff --git a/src/Tasks/AppConfig/BindingRedirect.cs b/src/Tasks/AppConfig/BindingRedirect.cs
index 5e5404af394..8a226ede9c5 100644
--- a/src/Tasks/AppConfig/BindingRedirect.cs
+++ b/src/Tasks/AppConfig/BindingRedirect.cs
@@ -61,7 +61,7 @@ internal void Read(XmlReader reader)
                     throw;
                 }
 
-                ErrorUtilities.VerifyThrowArgument(false, e, "AppConfig.InvalidOldVersionAttribute", e.Message);
+                ErrorUtilities.ThrowArgument(e, "AppConfig.InvalidOldVersionAttribute", e.Message);
             }
 
             string newVersionAttribute = reader.GetAttribute("newVersion");
@@ -80,7 +80,7 @@ internal void Read(XmlReader reader)
                     throw;
                 }
 
-                ErrorUtilities.VerifyThrowArgument(false, e, "AppConfig.InvalidNewVersionAttribute", e.Message);
+                ErrorUtilities.ThrowArgument(e, "AppConfig.InvalidNewVersionAttribute", e.Message);
             }
         }
     }
diff --git a/src/Tasks/AppConfig/DependentAssembly.cs b/src/Tasks/AppConfig/DependentAssembly.cs
index 2337cafd376..2bbbc37e39a 100644
--- a/src/Tasks/AppConfig/DependentAssembly.cs
+++ b/src/Tasks/AppConfig/DependentAssembly.cs
@@ -96,7 +96,7 @@ internal void Read(XmlReader reader)
                     catch (System.IO.FileLoadException e)
                     {
                         // A badly formed assembly name.
-                        ErrorUtilities.VerifyThrowArgument(false, e, "AppConfig.InvalidAssemblyIdentityFields");
+                        ErrorUtilities.ThrowArgument(e, "AppConfig.InvalidAssemblyIdentityFields");
                     }
                 }
 
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 2cea34c71bb..53b19c17a62 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -3153,23 +3153,26 @@ public override bool Execute()
         {
             return Execute
             (
-                new FileExists(p => FileUtilities.FileExistsNoThrow(p)),
-                new DirectoryExists(p => FileUtilities.DirectoryExistsNoThrow(p)),
-                new GetDirectories(Directory.GetDirectories),
-                new GetAssemblyName(AssemblyNameExtension.GetAssemblyNameEx),
-                new GetAssemblyMetadata(AssemblyInformation.GetAssemblyMetadata),
+                p => FileUtilities.FileExistsNoThrow(p),
+                p => FileUtilities.DirectoryExistsNoThrow(p),
+                (p, searchPattern) => Directory.GetDirectories(p, searchPattern),
+                p => AssemblyNameExtension.GetAssemblyNameEx(p),
+                (string path, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache, out AssemblyNameExtension[] dependencies, out string[] scatterFiles, out FrameworkNameVersioning frameworkName)
+                    => AssemblyInformation.GetAssemblyMetadata(path, assemblyMetadataCache, out dependencies, out scatterFiles, out frameworkName),
 #if FEATURE_WIN32_REGISTRY
-                new GetRegistrySubKeyNames(RegistryHelper.GetSubKeyNames),
-                new GetRegistrySubKeyDefaultValue(RegistryHelper.GetDefaultValue),
+                (baseKey, subkey) => RegistryHelper.GetSubKeyNames(baseKey, subkey),
+                (baseKey, subkey) => RegistryHelper.GetDefaultValue(baseKey, subkey),
 #endif
-                new GetLastWriteTime(NativeMethodsShared.GetLastWriteFileUtcTime),
-                new GetAssemblyRuntimeVersion(AssemblyInformation.GetRuntimeVersion),
+                p => NativeMethodsShared.GetLastWriteFileUtcTime(p),
+                p => AssemblyInformation.GetRuntimeVersion(p),
 #if FEATURE_WIN32_REGISTRY
-                new OpenBaseKey(RegistryHelper.OpenBaseKey),
+                (hive, view) => RegistryHelper.OpenBaseKey(hive, view),
 #endif
-                new GetAssemblyPathInGac(GetAssemblyPathInGac),
-                new IsWinMDFile(AssemblyInformation.IsWinMDFile),
-                new ReadMachineTypeFromPEHeader(ReferenceTable.ReadMachineTypeFromPEHeader)
+                (assemblyName, targetProcessorArchitecture, getRuntimeVersion, targetedRuntimeVersion, fileExists, fullFusionName, specificVersion)
+                    => GetAssemblyPathInGac(assemblyName, targetProcessorArchitecture, getRuntimeVersion, targetedRuntimeVersion, fileExists, fullFusionName, specificVersion),
+                (string fullPath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, out string imageRuntimeVersion, out bool isManagedWinmd)
+                    => AssemblyInformation.IsWinMDFile(fullPath, getAssemblyRuntimeVersion, fileExists, out imageRuntimeVersion, out isManagedWinmd),
+                p => ReferenceTable.ReadMachineTypeFromPEHeader(p)
             );
         }
 
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index be72b128729..350f9d70f69 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -52,13 +52,13 @@ internal abstract class Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
+        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
         {
             this.searchPathElement = searchPathElement;
             this.getAssemblyName = getAssemblyName;
             this.fileExists = fileExists;
             this.getRuntimeVersion = getRuntimeVersion;
-            this.targetedRuntimeVersion = targetedRuntimeVesion;
+            this.targetedRuntimeVersion = targetedRuntimeVersion;
             this.targetProcessorArchitecture = targetedProcessorArchitecture;
             this.compareProcessorArchitecture = compareProcessorArchitecture;
         }
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index d6d3e0ae209..dfc0c4632c7 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -54,7 +54,7 @@ Dictionary<string, string> directories
                 }
                 else
                 {
-                    ErrorUtilities.VerifyThrow(false, "AssemblyFolder.AddFoldersFromRegistryKey expected a known hive.");
+                    ErrorUtilities.ThrowInternalError("AssemblyFolder.AddFoldersFromRegistryKey expected a known hive.");
                 }
 
                 if (baseKey != null)
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index c3ecc2aac73..3e7da8c94cd 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -2091,7 +2091,10 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     }
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
+                    // Skip this check if the public key attribute is "0", as this means we're expecting the public key
+                    // comparison to be skipped at install time because the file is signed by an MS trusted cert.
+                    if (publicKeyAttribute.Value.Equals("0", StringComparison.OrdinalIgnoreCase) == false &&
+                        publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
                     }
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 6c91abeaab3..1575b55d11b 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -588,8 +588,7 @@ private bool CopyParallel(
                 if (!partitionAccepted)
                 {
                     // Retail assert...
-                    ErrorUtilities.VerifyThrow(false,
-                        "Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
+                    ErrorUtilities.ThrowInternalError("Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
                 }
             }
 
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index 9837e9b1f2a..bb939b9174a 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -3,11 +3,10 @@
 
 using System;
 using System.IO;
-using System.Text;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -114,7 +113,7 @@ internal static string CreateManifestNameImpl
                 info.culture = culture;
             }
 
-            var manifestName = new StringBuilder();
+            var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
                 // Resource depends on a form. Now, get the form's class name fully 
@@ -212,7 +211,7 @@ internal static string CreateManifestNameImpl
                 }
             }
 
-            return manifestName.ToString();
+            return StringBuilderCache.GetStringAndRelease(manifestName);
         }
 
         /// <summary>
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 864450634a1..fe02c57753f 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -3,8 +3,8 @@
 
 using System;
 using System.IO;
-using System.Text;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -111,7 +111,7 @@ internal static string CreateManifestNameImpl
                 info.culture = culture;
             }
 
-            var manifestName = new StringBuilder();
+            var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
                 // Resource depends on a form. Now, get the form's class name fully 
@@ -192,7 +192,7 @@ internal static string CreateManifestNameImpl
                 }
             }
 
-            return manifestName.ToString();
+            return StringBuilderCache.GetStringAndRelease(manifestName);
         }
 
         /// <summary>
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 26967ca64e7..54d5b149d96 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -4146,7 +4146,7 @@ public Type GetType(string name, bool throwOnError, bool ignoreCase)
 
                 if (result == null && throwOnError)
                 {
-                    ErrorUtilities.VerifyThrowArgument(false, "GenerateResource.CouldNotLoadType", name);
+                    ErrorUtilities.ThrowArgument("GenerateResource.CouldNotLoadType", name);
                 }
 
                 _cachedTypes[name] = result;
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index f6b98da83af..f909cc1afe2 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -122,8 +122,9 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateLauncher"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="NET" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''  and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateTrustInfo"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -141,8 +142,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -164,8 +165,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.Touch"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.Unzip"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
diff --git a/src/Tasks/RemoveDir.cs b/src/Tasks/RemoveDir.cs
index f802cbfc70d..c19be8486f6 100644
--- a/src/Tasks/RemoveDir.cs
+++ b/src/Tasks/RemoveDir.cs
@@ -44,8 +44,6 @@ public ITaskItem[] Directories
         //-----------------------------------------------------------------------------------
         public override bool Execute()
         {
-            // Delete each directory
-            bool overallSuccess = true;
             // Our record of the directories that were removed
             var removedDirectoriesList = new List<ITaskItem>();
 
@@ -73,12 +71,6 @@ public override bool Execute()
                         }
                     }
 
-                    // The current directory was not removed successfully
-                    if (!currentSuccess)
-                    {
-                        overallSuccess = false;
-                    }
-
                     // We successfully removed the directory, so add the removed directory to our record
                     if (currentSuccess)
                     {
@@ -97,7 +89,7 @@ public override bool Execute()
             }
             // convert the list of deleted files into an array of ITaskItems
             RemovedDirectories = removedDirectoriesList.ToArray();
-            return overallSuccess;
+            return !Log.HasLoggedErrors;
         }
 
         // Core implementation of directory removal
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index a8cf11d7a56..e64e155ca4b 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -1040,7 +1040,7 @@ internal bool ResolveComClassicReference(ComReferenceInfo referenceInfo, string
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unknown wrapper type!");
+                ErrorUtilities.ThrowInternalError("Unknown wrapper type!");
             }
             referenceInfo.resolvedWrapper = wrapperInfo;
 
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 41d74bb1934..96fc22b7388 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -256,7 +256,7 @@ internal void GenerateCommandsAccordingToType(CommandLineBuilder clb, CommandLin
                     break;
                 default:
                     // should never reach this point - if it does, there's a bug somewhere.
-                    ErrorUtilities.VerifyThrow(false, "InternalError");
+                    ErrorUtilities.ThrowInternalError("InternalError");
                     break;
             }
         }
diff --git a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
index 2051aed69cf..0eea164b802 100644
--- a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
+++ b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <AssemblyName>Microsoft.Build.Utilities.UnitTests</AssemblyName>
     <IsTestProject>true</IsTestProject>
     <RootNamespace>Microsoft.Build.Utilities.UnitTests</RootNamespace>
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index b2099ce44c5..e2588de3155 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -1950,26 +1950,30 @@ public void GetPathToReferenceAssembliesDefaultLocationNullFrameworkName()
             }
            );
         }
+
         /// <summary>
-        /// Verify the method correctly returns the 4.5 reference assembly location information if .net 4.5 and
+        /// Verify the method correctly returns the 4.8 reference assembly location information if .net 4.8 and
         /// its corresponding reference assemblies are installed.
-        /// If they are not installed, the test should be ignored.
+        /// .NET 4.8 should always be installed for our tests. We cannot validly verify on Windows that by adding a check
+        /// that ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48)
+        /// returns something reasonable because later versions of the framework overwrote the current version in
+        /// place, which means it just looks for a folder starting with v4.0 in the right spot for any higher version.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
-        public void GetPathToReferenceAssembliesDefaultLocation45()
+        public void GetPathToReferenceAssembliesDefaultLocation48()
         {
-            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) != null)
+            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) != null)
             {
-                FrameworkNameVersioning frameworkName = new FrameworkNameVersioning(".NETFramework", new Version("4.5"));
+                FrameworkNameVersioning frameworkName = new(".NETFramework", new Version("4.8"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(frameworkName);
                 directories.Count.ShouldBe(1); // "Expected the method to return one path."
 
-                string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45);
+                string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48);
                 directories[0].ShouldBe(referenceAssemblyPath, StringCompareShould.IgnoreCase);
             }
             // else
-            // "Ignored because v4.5 did not seem to be installed"
+            // "Ignored because v4.8 did not seem to be installed"
         }
 
         /// <summary>
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index e34d6eef2af..6237b17f4c7 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2199,7 +2199,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
                 }
             }
 
-            return new List<string>();
+            return pathsList ?? new List<string>();
         }
 
         /// <summary>
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index e7766038d11..0818aec23b2 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -902,7 +902,7 @@ private void HandleToolNotifications(Process proc)
                             break;
 
                         default:
-                            ErrorUtilities.VerifyThrow(false, "Unknown tool notification.");
+                            ErrorUtilities.ThrowInternalError("Unknown tool notification.");
                             break;
                     }
                 }
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index ec2d396bfc5..423083dbd1b 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -1,6 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 
 using System.Collections.Generic;
@@ -13,8 +15,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
-#if FEATURE_FILE_TRACKER
-
 namespace Microsoft.Build.Utilities
 {
     /// <summary>
@@ -58,7 +58,7 @@ public enum ExecutableType
     /// </summary>
     public static class FileTracker
     {
-        #region Static Member Data
+#region Static Member Data
 
         // The default path to temp, used to create explicitly short and long paths
         private static readonly string s_tempPath = Path.GetTempPath();
@@ -101,9 +101,9 @@ public static class FileTracker
         // Static cache of the path separator character in an array for use in String.Split.
         private static readonly string pathSeparator = Path.PathSeparator.ToString();
 
-        #endregion
+#endregion
 
-        #region Static constructor
+#region Static constructor
 
         static FileTracker()
         {
@@ -128,9 +128,9 @@ static FileTracker()
             }
         }
 
-        #endregion
+#endregion
 
-        #region Native method wrappers
+#region Native method wrappers
 
         /// <summary>
         /// Stops tracking file accesses.  
@@ -195,9 +195,9 @@ public static void StartTrackingContextWithRoot(string intermediateDirectory, st
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLogs", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public static void WriteContextTLogs(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.WriteContextTLogs(intermediateDirectory, taskName);
 
-        #endregion // Native method wrappers
+#endregion // Native method wrappers
 
-        #region Methods
+#region Methods
 
         /// <summary>
         /// Test to see if the specified file is excluded from tracked dependencies
@@ -627,7 +627,7 @@ public static string TrackerArguments(string command, string arguments, string d
         public static string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName)
             => TrackerResponseFileArguments(dllName, intermediateDirectory, rootFiles, cancelEventName) + TrackerCommandArguments(command, arguments);
 
-        #region StartProcess methods
+#region StartProcess methods
 
         /// <summary>
         /// Start the process; tracking the command.  
@@ -694,7 +694,7 @@ public static Process StartProcess(string command, string arguments, ExecutableT
         public static Process StartProcess(string command, string arguments, ExecutableType toolType)
             => StartProcess(command, arguments, toolType, null, null, null, null);
 
-        #endregion // StartProcess methods
+#endregion // StartProcess methods
 
         /// <summary>
         /// Logs a message of the given importance using the specified resource string. To the specified Log.
@@ -744,7 +744,7 @@ internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, stri
             Log?.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
         }
 
-        #endregion
+#endregion
     }
 
     /// <summary>
