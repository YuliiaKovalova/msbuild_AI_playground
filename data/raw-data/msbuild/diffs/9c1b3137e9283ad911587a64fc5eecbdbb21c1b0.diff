diff --git a/.opt-prof.yml b/.opt-prof.yml
new file mode 100644
index 00000000000..93b687fd3e2
--- /dev/null
+++ b/.opt-prof.yml
@@ -0,0 +1,83 @@
+# Runs OptProf for MSBuild binaries based on an insertion build
+
+trigger: none # Prevents this pipeline from triggering on check-ins
+pr: none # don't run this on PR as well, this should only trigger off on MSBuild runs
+schedules:
+  - cron: "0 9 * * Wed,Sat"
+    displayName: Weekly OptProf Run
+    branches:
+      include:
+      - main
+    always: true
+
+resources:
+  pipelines:
+  - pipeline: ComponentBuildUnderTest
+    source: MSBuild\MSBuild # The name of the pipeline that produces the artifact
+    trigger:
+      branches:
+        - vs*
+  - pipeline: DartLab
+    project: DevDiv
+    source: DartLab
+    branch: main
+  - pipeline: DartLab.OptProf
+    source: DartLab.OptProf
+    branch: main
+  repositories:
+  - repository: DartLabTemplates
+    type: git
+    name: DartLab.Templates
+    ref: refs/heads/main
+  - repository: DartLabOptProfTemplates
+    type: git
+    name: DartLab.OptProf
+    ref: refs/heads/main
+
+stages:
+- template: \templates\stages\visual-studio\single-runsettings.yml@DartLabOptProfTemplates
+  parameters:
+    ##### Required #####
+    runSettingsURI: $(Pipeline.Workspace)\ComponentBuildUnderTest\VSSetup\Insertion\OptProf\Training.runsettings
+    visualStudioBootstrapperURI: $(VisualStudio.InstallationUnderTest.BootstrapperURL)
+    ##### Optional #####
+    name: OptProfProfilingWorkflow
+    displayName: OptProf Profiling Workflow
+    optOptimizationInputsDropName: $(OptimizationInputsDropName)
+    testLabPoolName: VS-Platform # The test lab pool to run your tests in
+    testMachineImageName: Windows-10-Enterprise-20H2
+    variables:
+    - name: branchName # The branch in the VS repo the bootstrapper was based on
+      value: $[replace(variables['resources.pipeline.ComponentBuildUnderTest.sourceBranch'],'refs/heads/','')]
+    - name: OptimizationInputsDropName # The naming convention of the OptimizationInputsDrop
+      value: OptimizationData/DotNet-msbuild-Trusted/$(branchName)/$(resources.pipeline.ComponentBuildUnderTest.runName)/$(Build.BuildId)/$(System.StageAttempt)
+    ##### Step Hooks #####
+    preTestMachineConfigurationStepList:
+    - download: ComponentBuildUnderTest
+      artifact: MicroBuildOutputs
+      patterns: '**\BootstrapperInfo.json'
+      displayName: Download Bootstrapper Information
+    - download: ComponentBuildUnderTest
+      artifact: VSSetup
+      patterns: '**\*.runsettings'
+      displayName: Download OptProf Information
+    - powershell: |
+        try {
+          $bootstrapperInfoJson = Get-Content -Raw -Path '$(Pipeline.Workspace)\ComponentBuildUnderTest\MicroBuildOutputs\BootstrapperInfo.json' | ConvertFrom-Json
+          $vsBranch = $bootstrapperInfoJson[0].VSBranch
+          Write-Host "VSBootstrapperBranch: $vsBranch"
+          Set-AzurePipelinesVariable 'VSBootstrapperBranch' $vsBranch
+        }        
+        catch {
+          Write-Host $_
+          Write-Error "Failed to set VSBootstrapperBranch pipeline variable"
+          throw
+        }
+      displayName: Set 'VSBootstrapperBranch' variable
+    - task: PowerShell@2
+      displayName: Set 'VisualStudio.InstallationUnderTest.BootstrapperURL' variable
+      inputs:
+        filePath: $(DartLab.Path)\Scripts\VisualStudio\Bootstrapper\Get-BootstrapperURL.ps1
+        arguments: -BootstrapperInfoJsonURI '$(Pipeline.Workspace)\ComponentBuildUnderTest\MicroBuildOutputs\BootstrapperInfo.json' -VSBranch '$(VSBootstrapperBranch)' -OutVariableName 'VisualStudio.InstallationUnderTest.BootstrapperURL'
+    preDeployAndRunTestsStepList:
+    - download: ComponentBuildUnderTest
\ No newline at end of file
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 9d657a62840..fe3485b6f5c 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -23,12 +23,9 @@ variables:
   - name: SourceBranch
     value: $(IbcSourceBranchName)
   # If we're not on a vs* branch, use main as our optprof collection branch
-  # NOTE: the code is temporarily fixed. For the branches that should use opt-prof from the main branch we should use the latest working Opt-Prof 20220901.6-001 collected from main 20220901.6.
   - ${{ if not(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs')) }}:
-    - name: OptProfDrop
-      value: 'OptimizationData/DotNet-msbuild-Trusted/main/20220901.6/1387996/1'
     - name: SourceBranch
-      value: ''
+      value: main
   # if OptProfDropName is set as a parameter, set OptProfDrop to the parameter and unset SourceBranch
   - ${{ if ne(parameters.OptProfDropName, 'default') }}:
     - name: OptProfDrop
@@ -39,6 +36,8 @@ variables:
     value: .NETCore
   - name: _DotNetValidationArtifactsCategory
     value: .NETCoreValidation
+  - name: Codeql.Enabled
+    value: true
 
 stages:
 - stage: build
@@ -163,6 +162,7 @@ stages:
                   -task VisualStudio.BuildIbcTrainingSettings
                   /p:VisualStudioDropName=$(VisualStudio.DropName)
                   /p:BootstrapperInfoPath=$(Build.StagingDirectory)\MicroBuild\Output\BootstrapperInfo.json
+                  /p:VisualStudioIbcTrainingSettingsPath=$(Build.SourcesDirectory)\eng\config\OptProf.runsettings
       displayName: 'OptProf - Build IBC training settings'
       condition: succeeded()
 
diff --git a/README.md b/README.md
index b26c998e241..5da6f526a8f 100644
--- a/README.md
+++ b/README.md
@@ -41,14 +41,12 @@ To get started on **Visual Studio 2022**:
 1. [Install Visual Studio 2022](https://www.visualstudio.com/vs/).  Select the following Workloads:
   - .NET desktop development
   - .NET Core cross-platform development
-2. Open a `Developer Command Prompt for VS 2022` prompt.
-3. Clone the source code: `git clone https://github.com/dotnet/msbuild`
+2. Ensure [long path support](https://learn.microsoft.com/windows/win32/fileio/maximum-file-path-limitation?tabs=registry#enable-long-paths-in-windows-10-version-1607-and-later) is enabled at the Windows level.
+3. Open a `Developer Command Prompt for VS 2022` prompt.
+4. Clone the source code: `git clone https://github.com/dotnet/msbuild`
   - You may have to [download Git](https://git-scm.com/downloads) first.
-4. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
-5. Open `MSBuild.sln` or `MSBuild.Dev.slnf` in Visual Studio 2022.
-
-Note: To create a usable MSBuild with your changes, run `.\build.cmd /p:CreateBootstrap=true`.
-To build release, add `-c Release`: `.\build.cmd -c Release /p:CreateBootstrap=true`.
+5. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
+6. Open `MSBuild.sln` or `MSBuild.Dev.slnf` in Visual Studio 2022.
 
 This newly-built MSBuild will be located at `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe`. It may not work for all scenarios, including C++ builds.
 
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index 9dc2f404fa2..f2e6b6e4753 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -138,13 +138,12 @@ In addition to the above task and target, `.vcxproj` and `.nativeproj` projects
 This means most projects will see an evaluation with no global properties defined, unless set by the user.
 
 ### How To Opt In
-First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:
+First, set the property `EnableDynamicPlatformResolution` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:
 
 ```xml
 <Project>
   <PropertyGroup>
     <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
-    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
   </PropertyGroup>
 </Project>
 ```
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index caaf9d52580..550ec068398 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -9,7 +9,7 @@ Goals:
  * structure (preserves the exact build event args that can later be replayed to reconstruct the exact events and information as if a real build was running). File logs erase structure and are harder to parse (especially for multicore /m builds). Build analyzer tools are conceivable that could benefit from the structure in a binary log. An API is available to load and query binary logs.
  * optionally collect the project files (and all imported targets files) used during the build. This can help analyzing the logs and even view preprocessed source for all projects (with all imported projects inlined).
 
-See http://msbuildlog.com for more information.
+See https://msbuildlog.com/ for more information.
 
 # Creating a binary log during a build
 
@@ -62,7 +62,7 @@ Once you have the `StructuredLogger.dll` on disk you can pass it to MSBuild like
 # Using MSBuild Structured Log Viewer
 
 You can use the MSBuild Structured Log Viewer tool to view `.binlog` files:
-http://msbuildlog.com
+https://msbuildlog.com/
 
 # Collecting binary logs from Visual Studio builds
 
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
index 7df20c12b5f..2e28b9f96c5 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
@@ -10,13 +10,13 @@ MSBuild can be successfully built on Windows, OS X 10.13, Ubuntu 14.04, and Ubun
 
 ## The easy way
 
-Install the latest .NET Core SDK from http://dot.net/core. That will ensure all prerequisites for our build are met.
+Install the latest .NET SDK from https://dotnet.microsoft.com/download. That will ensure all prerequisites for our build are met.
 
 ## Manually installing required packages for OSX & Ubuntu
 
-[.NET Core prerequisites](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md).
+[.NET Core prerequisites](https://github.com/dotnet/core/blob/main/Documentation/prereqs.md).
 
-* *OpenSSL*: MSBuild uses the .Net CLI during its build process. The CLI requires a recent OpenSSL library available in `/usr/lib`. This can be downloaded using [brew](http://brew.sh/) on OS X (`brew install openssl`) and apt-get (`apt-get install openssl`) on Ubuntu, or [building from source](https://wiki.openssl.org/index.php/Compilation_and_Installation#Mac). If you use a different package manager and see an error that says `Unable to load DLL 'System.Security.Cryptography.Native'`, `dotnet` may be looking in the wrong place for the library.
+* *OpenSSL*: MSBuild uses the .Net CLI during its build process. The CLI requires a recent OpenSSL library available in `/usr/lib`. This can be downloaded using [brew](https://brew.sh/) on OS X (`brew install openssl`) and apt-get (`apt-get install openssl`) on Ubuntu, or [building from source](https://wiki.openssl.org/index.php/Compilation_and_Installation#Mac). If you use a different package manager and see an error that says `Unable to load DLL 'System.Security.Cryptography.Native'`, `dotnet` may be looking in the wrong place for the library.
 
 ## Build
 
@@ -40,9 +40,9 @@ Set the environment variable `MSBUILDDEBUGONSTART` to `2`, then attach a debugge
 
 ### Using the repository binaries to perform builds
 
-To build projects using the MSBuild binaries from the repository, you first need to do a build (command: `build.cmd /p:CreateBootstrap=true`) which produces a bootstrap directory mimicking a Visual Studio (full framework flavor) or dotnet CLI (.net core flavor) installation.
+To build projects using the MSBuild binaries from the repository, you first need to do a build (command: `build.cmd`) which produces a bootstrap directory mimicking a Visual Studio (full framework flavor) or dotnet CLI (.net core flavor) installation.
 
-Now, just point `dotnet ./artifacts/bin/bootstrap/netcoreapp2.1/MSBuild/MSBuild.dll` at a project file.
+Now, just point `dotnet ./artifacts/bin/bootstrap/<TARGET_FRAMEWORK>/MSBuild/MSBuild.dll` at a project file. (Change <TARGET_FRAMEWORK> to current target framework, for example net7.0, net8.0) 
 
 Alternatively, if you want to test the msbuild binaries in a more realistic environment, you can overwrite the dotnet CLI msbuild binaries (found under a path like `~/dotnet/sdk/3.0.100-alpha1-009428/`) with the just-built MSBuild . You might have to kill existing `dotnet` processes before doing this. You can use [`Deploy-MSBuild.ps1 -runtime Core`](../Deploy-MSBuild.md#.NET-(Core)-SDK) to do the copy. Then, (using the previous dotnet example directory) just point `~/dotnet/dotnet build` at a project file.
 
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
index 20c962598de..b95f657d757 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
@@ -4,7 +4,7 @@ These instructions refer to working with the `master` branch.
 
 ## Required Software
 
-**Latest Microsoft Visual Studio 2022**: You can download the Visual Studio Community edition from [https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx](https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx).
+**Latest Microsoft Visual Studio 2022**: You can download the Visual Studio Community edition from [visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/).
 
 All command lines should be executed from a Visual Studio developer command prompt.
 
@@ -31,16 +31,16 @@ The CI does two builds. In the second build, it uses the binaries from the first
 
 ## Contributing
 
-Please see [Contributing Code](https://github.com/dotnet/msbuild/blob/master/documentation/wiki/Contributing-Code.md) for details on contributing changes back to the code. Please read this carefully and engage with us early to ensure work is not wasted.
+Please see [Contributing Code](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Contributing-Code.md) for details on contributing changes back to the code. Please read this carefully and engage with us early to ensure work is not wasted.
 
 ## Walkthroughs
 
 ### Using the repository binaries to perform builds
 
 To build projects using the MSBuild binaries from the repository, you first need to do a build which produces
-a "bootstrap" directory. The "bootstrap" directory mimics a Visual Studio installation by aquiring additional
+a "bootstrap" directory. The "bootstrap" directory mimics a Visual Studio installation by acquiring additional
 dependencies (Roslyn compilers, NuGet, etc.) from packages or from your local machine (e.g. props/targets
-from Visual Studio). To produce a bootstrap build, run `.\build.cmd /p:CreateBootstrap=true` from the root of your enlistment.
+from Visual Studio). This will happen by default when running `.\build.cmd`. The bootstrap can be disabled by running `.\build.cmd /p:CreateBootstrap=false`.
 
 Now, just point `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe` at a project file.
 
@@ -49,7 +49,7 @@ Now, just point `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe`
 Sometimes it's useful to patch your copy of Visual Studio in order to test or debug your local MSBuild changes from Visual Studio. You can use the [Deploy-MSBuild script](../Deploy-MSBuild.md) for copying your locally built MSBuild binaries over the MSBuild binaries shipping with Visual Studio. Example usage:
 ```
 # bootstrap build
-.\build.cmd /p:CreateBootstrap=true
+.\build.cmd
 
 # copy the bootstrap build output over the MSBuild binaries in Visual Studio
 .\scripts\Deploy-MSBuild.ps1 -destination "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin"
@@ -74,4 +74,4 @@ Like with breakpoints, you can filter which processes emit the logs by setting `
 
 ##### Dumping specific logs:
 - scheduler state: set `MSBUILDDEBUGSCHEDULER` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
-- node communication: set `MSBUILDDEBUGCOMM` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
\ No newline at end of file
+- node communication: set `MSBUILDDEBUGCOMM` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
index 859cf202824..c78f554b272 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
@@ -6,7 +6,7 @@ Mono maintains a fork of msbuild (for now) at `https://github.com/mono/msbuild/`
 
 **Required packages for OSX & Ubuntu**
 
-MSBuild requires a stable version of [Mono](http://www.mono-project.com/download/) to build itself.
+MSBuild requires a stable version of [Mono](https://www.mono-project.com/download/stable/) to build itself.
 
 ## Build process ##
 
@@ -23,9 +23,9 @@ If you encounter errors, see [Something's wrong in my build](Something's-wrong-i
 `./install-mono-prefix.sh </your/mono/prefix>`
 
 ## Getting Mono MSBuild binaries without building the code ##
-The best way to get Mono MSBuild for OSX/macOS is to get the official [Mono package](http://www.mono-project.com/download/#download-mac). After installing it, you can run `msbuild`.
+The best way to get Mono MSBuild for OSX/macOS is to get the official [Mono package](https://www.mono-project.com/download/stable/#download-mac). After installing it, you can run `msbuild`.
 <br/>
-For Linux, you can install mono and msbuild from [here](http://www.mono-project.com/download/#download-lin).
+For Linux, you can install mono and msbuild from [here](https://www.mono-project.com/download/stable/#download-lin).
 
 ## Debugging
 
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index ef4b61564e3..e6b66012eb5 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -23,6 +23,10 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ## Current Rotation of Change Waves
 
+### 17.6
+- [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
+- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
+
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
 - [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
@@ -30,19 +34,6 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
 - [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
 
-### 17.0
-- [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
-- [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
-- [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
-- [Reference assemblies are now no longer placed in the `bin` directory by default](https://github.com/dotnet/msbuild/pull/6560) (reverted [here](https://github.com/dotnet/msbuild/pull/6718) and brought back [here](https://github.com/dotnet/msbuild/pull/7075))
-- [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
-- [Fix deadlock in BuildManager vs LoggingService](https://github.com/dotnet/msbuild/pull/6837)
-- [Optimize diag level for file logger and console logger](https://github.com/dotnet/msbuild/pull/7026)
-- [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
-- [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
-- [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
-- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
-
 ## Change Waves No Longer In Rotation
 ### 16.8
 - [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
@@ -55,3 +46,16 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
 - [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
 - [Optimize glob evaluation](https://github.com/dotnet/msbuild/pull/6151)
+
+### 17.0
+- [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
+- [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
+- [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
+- [Reference assemblies are now no longer placed in the `bin` directory by default](https://github.com/dotnet/msbuild/pull/6560) (reverted [here](https://github.com/dotnet/msbuild/pull/6718) and brought back [here](https://github.com/dotnet/msbuild/pull/7075))
+- [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
+- [Fix deadlock in BuildManager vs LoggingService](https://github.com/dotnet/msbuild/pull/6837)
+- [Optimize diag level for file logger and console logger](https://github.com/dotnet/msbuild/pull/7026)
+- [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
+- [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
+- [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
+- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
\ No newline at end of file
diff --git a/documentation/wiki/Contributing-Code.md b/documentation/wiki/Contributing-Code.md
index 71db1a4961d..690cf797972 100644
--- a/documentation/wiki/Contributing-Code.md
+++ b/documentation/wiki/Contributing-Code.md
@@ -7,7 +7,7 @@ Because our focus right now is on maintaining backwards compatibility, the team
 - Only contributions referencing an approved Issue will be accepted.
 - Pull requests that do not merge easily with the tip of the master branch will be declined. The author will be asked to merge with tip and submit a new pull request.
 - Submissions must meet functional and performance expectations, including scenarios for which the team doesn't yet have open source tests. This means you may be asked to fix and resubmit your pull request against a new open test case if it fails one of these tests.
-- Submissions must follow the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md)
+- Submissions must follow the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
 
 When you are ready to proceed with making a change, get set up to [build](Home.md "See 'Building Testing and Debugging'") the code and familiarize yourself with our workflow and our coding conventions. These two blogs posts on contributing code to open source projects are good too: [Open Source Contribution Etiquette by Miguel de Icaza](https://tirania.org/blog/archive/2010/Dec-31.html) and [Don’t “Push” Your Pull Requests by Ilya Grigorik](https://www.igvita.com/2011/12/19/dont-push-your-pull-requests/).
 
@@ -33,4 +33,4 @@ Please follow these guidelines when creating new issues in the issue tracker:
 - Subscribe to notifications for the created issue in case there are any follow up questions.
 
 ### Coding Conventions
-- Use the coding style outlined in the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md)
+- Use the coding style outlined in the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
diff --git a/documentation/wiki/Contributing-Tasks.md b/documentation/wiki/Contributing-Tasks.md
index 23327755575..c77aaa7cd02 100644
--- a/documentation/wiki/Contributing-Tasks.md
+++ b/documentation/wiki/Contributing-Tasks.md
@@ -13,15 +13,15 @@ The following requirements are in place for contributed tasks:
 3. The task must have unit tests in place to prevent regressions.
 
 ## Developing a new Task
-Review the existing documentation on [Task Writing](https://docs.microsoft.com/en-us/visualstudio/msbuild/task-writing) to learn about the fundamentals.  You can also looking at existing tasks in the [Microsoft.Build.Tasks.Core assembly](https://github.com/dotnet/msbuild/tree/master/src/Tasks) for a great starting point.
+Review the existing documentation on [Task Writing](https://learn.microsoft.com/visualstudio/msbuild/task-writing) to learn about the fundamentals.  You can also looking at existing tasks in the [Microsoft.Build.Tasks.Core assembly](https://github.com/dotnet/msbuild/tree/main/src/Tasks) for a great starting point.
 
 Tasks are generally simple and should not require much effort to develop.  If you find a task becoming very complicated, consider breaking it up into smaller tasks which can be run together in a target.
 
 ## Developing unit tests
-Contributed tasks must have unit tests in place to prove they work and to prevent regressions caused by other code changes.  There are a lot of examples in the [Microsoft.Build.Tasks.UnitTests](https://github.com/dotnet/msbuild/tree/master/src/Tasks.UnitTests) project.  Please provide a reasonable amount of test coverage so ensure the quality of the product.
+Contributed tasks must have unit tests in place to prove they work and to prevent regressions caused by other code changes.  There are a lot of examples in the [Microsoft.Build.Tasks.UnitTests](https://github.com/dotnet/msbuild/tree/main/src/Tasks.UnitTests) project.  Please provide a reasonable amount of test coverage so ensure the quality of the product.
 
 ## Documentation
-You can document the new task in the [visualstudio-docs](https://github.com/MicrosoftDocs/visualstudio-docs/tree/master/docs/msbuild) repository.  This helps users discover the new functionality.  The easiest way is to copy the documentation page for an existing task as a template.
+You can document the new task in the [visualstudio-docs](https://github.com/MicrosoftDocs/visualstudio-docs/tree/main/docs/msbuild) repository.  This helps users discover the new functionality.  The easiest way is to copy the documentation page for an existing task as a template.
 
 ## Ship schedule
 MSBuild ships regularly with Visual Studio.  It also is updated in Preview releases.  Once your contribution is merged, expect it to be available in the next release.
diff --git a/documentation/wiki/Localization.md b/documentation/wiki/Localization.md
index 4bf09bf0123..919d9f4a883 100644
--- a/documentation/wiki/Localization.md
+++ b/documentation/wiki/Localization.md
@@ -6,7 +6,7 @@
 - `Strings.shared.resx` is a shared resource and gets embedded into all msbuild dlls
 - each neutral resource has a directory named `xlf` besides it which contains its localized strings in .xlf format
 - there is one language per xlf
-- the logical name for a resource is: `<Assembly Name>.<Neutral Resx File Name>.resources`. In the ResourceManager this appears as `<Assembly Name>.<Neutral Resx File Name>` (without the trailing `.resources`). For example, the `Microsoft.Build` assembly uses the `Microsoft.Build.Strings.resources` [logical resource name](https://github.com/dotnet/msbuild/blob/master/src/XMakeBuildEngine/Microsoft.Build.csproj#L659) (the resource file is `Strings.resx`), and its corresponding [ResourceManager](https://github.com/dotnet/msbuild/blob/master/src/XMakeBuildEngine/Resources/AssemblyResources.cs#L116) uses `Microsoft.Build.Strings`.
+- the logical name for a resource is: `<Assembly Name>.<Neutral Resx File Name>.resources`. In the ResourceManager this appears as `<Assembly Name>.<Neutral Resx File Name>` (without the trailing `.resources`). For example, the `Microsoft.Build` assembly uses the `Microsoft.Build.Strings.resources` [logical resource name](https://github.com/dotnet/msbuild/blob/cc3db358d34ad4cd1ec0c67e17582d7ca2a15040/src/Build/Microsoft.Build.csproj#L792) (the resource file is `Strings.resx`), and its corresponding [ResourceManager](https://github.com/dotnet/msbuild/blob/518c041f4511a6bc23eb40703b69a94ea46c65fd/src/Build/Resources/AssemblyResources.cs#L118) uses `Microsoft.Build.Strings`.
 
 ## How to edit a resource
 
diff --git a/documentation/wiki/MSBuild-Resources.md b/documentation/wiki/MSBuild-Resources.md
index 4e3f64c3dc2..506e407258d 100644
--- a/documentation/wiki/MSBuild-Resources.md
+++ b/documentation/wiki/MSBuild-Resources.md
@@ -1,21 +1,21 @@
 # General Resources
- * [MSBuild Concepts](https://msdn.microsoft.com/en-us/library/dd637714.aspx)
- * [MSBuild Reserved and Well-Known Properties](https://msdn.microsoft.com/en-us/library/ms164309.aspx)
+ * [MSBuild Concepts](https://learn.microsoft.com/visualstudio/msbuild/msbuild-concepts)
+ * [MSBuild Reserved and Well-Known Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-reserved-and-well-known-properties)
  * [MSBuild Tips & Tricks](MSBuild-Tips-&-Tricks.md)
  * [Target Maps](Target-Maps.md)
 
 # MSBuild Source Code
  * [https://github.com/dotnet/msbuild](https://github.com/dotnet/msbuild)
  * [https://source.dot.net](https://source.dot.net)
- * Use [http://referencesource.microsoft.com](http://referencesource.microsoft.com) or [http://source.roslyn.io](http://source.roslyn.io) to browse Microsoft MSBuild targets. Examples:
-   * search for "[_FindDependencies MSBuildProperty](http://referencesource.microsoft.com/#q=_FindDependencies%20MSBuildProperty)"
-   * find targets [http://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences](http://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences)
+ * Use [referencesource.microsoft.com](https://referencesource.microsoft.com) or [sourceroslyn.io/](https://sourceroslyn.io/) to browse Microsoft MSBuild targets. Examples:
+   * search for "[_FindDependencies MSBuildProperty](https://referencesource.microsoft.com/#q=_FindDependencies%20MSBuildProperty)"
+   * find targets [referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences](https://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences)
 
 # Tools
 **Note:** These are third party tools
- * [MSBuildStructuredLog](http://msbuildlog.com/)
+ * [MSBuildStructuredLog](https://msbuildlog.com/)
    * A log viewer that displays a structured representation of executed targets, tasks, property and item values.
- * [MSBuildExtensionPack](http://www.msbuildextensionpack.com)
+ * [MSBuildExtensionPack](https://github.com/mikefourie-zz/MSBuildExtensionPack) (also via [NuGet](https://www.nuget.org/packages/MSBuild.Extension.Pack))
    * Provides a large collection of MSBuild Tasks, MSBuild Loggers and MSBuild TaskFactories.
  * [MSBuilder](https://github.com/MobileEssentials/MSBuilder)
    * Reusable blocks of MSBuild helpers; MSBuilder's goal is to provide fine-grained nuget packages that can be installed when only a certain MSBuild extension (task, property, target) is needed.
@@ -34,13 +34,13 @@
    * Lets you build Visual Studio solutions and projects as well as any MSBuild file through a context menu without opening Visual Studio.
 
 # Books
- * [Inside the Microsoft Build Engine: Using MSBuild and Team Foundation Build (2nd Edition) by Sayed Hashimi, William Bartholomew](http://www.amazon.com/Inside-Microsoft-Build-Engine-Foundation/dp/0735645248)
- * [MSBuild Trickery: 99 Ways to Bend the Build Engine to Your Will, by Brian Kretzler](http://www.amazon.com/MSBuild-Trickery-Ways-Build-Engine/dp/061550907X)
+ * [Inside the Microsoft Build Engine: Using MSBuild and Team Foundation Build (2nd Edition) by Sayed Hashimi, William Bartholomew](https://www.amazon.com/Inside-Microsoft-Build-Engine-Foundation/dp/0735645248)
+ * [MSBuild Trickery: 99 Ways to Bend the Build Engine to Your Will, by Brian Kretzler](https://www.amazon.com/MSBuild-Trickery-Ways-Build-Engine/dp/061550907X)
 
 # Blogs
- * [https://blogs.msdn.microsoft.com/msbuild](https://blogs.msdn.microsoft.com/msbuild)
- * [Sayed Hashimi's blog http://sedodream.com](http://sedodream.com)
+ * [MSBuild Team Blog](https://learn.microsoft.com/archive/blogs/msbuild/) (archive)
+ * [Sayed Hashimi's blog at sedodream.com](http://sedodream.com)
  * [Mike Fourie's blog https://mikefourie.wordpress.com](https://mikefourie.wordpress.com)
 
 # MSBuild Assemblies
-![MSBuild Assemblies](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/MSBuildAssemblies.png)
+![MSBuild Assemblies](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/MSBuildAssemblies.png)
diff --git a/documentation/wiki/MSBuild-Tips-&-Tricks.md b/documentation/wiki/MSBuild-Tips-&-Tricks.md
index a66255a037e..3a833348b66 100644
--- a/documentation/wiki/MSBuild-Tips-&-Tricks.md
+++ b/documentation/wiki/MSBuild-Tips-&-Tricks.md
@@ -1,5 +1,5 @@
 # MSBuild Command-Line Switches
-See the [MSBuild Command-Line Reference](https://docs.microsoft.com/visualstudio/msbuild/msbuild-command-line-reference) for more information on switches.
+See the [MSBuild Command-Line Reference](https://learn.microsoft.com/visualstudio/msbuild/msbuild-command-line-reference) for more information on switches.
  * `MSBuild.exe -pp:<FILE>`
    * MSBuild preprocessor. Pass /pp to the command line to create a single huge XML project file with all project imports inlined in the correct order. This is useful to investigate the ordering of imports and property and target overrides during evaluation.
    * Example usage: `msbuild MyProject.csproj /pp:inlined.xml`
@@ -13,14 +13,17 @@ See the [MSBuild Command-Line Reference](https://docs.microsoft.com/visualstudio
    * Passes parameters to the file logger. If you want to attach multiple file loggers, you do so by specifying additional parameters in the switches /flp1, /flp2, /flp3, and so on.
 
 # Environment Variables
+
+ * `MSBuildDebugEngine=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
+  * Set this to cause any MSBuild invocation launched within this environment to emit binary logs and additional debugging information to `<DIRECTORY>`. Useful when debugging build or evaluation issues when you can't directly influence the MSBuild invocation, such as in Visual Studio.
  * `MSBUILDTARGETOUTPUTLOGGING=1`
-   * Set this to enable [printing all target outputs to the log](https://blogs.msdn.microsoft.com/msbuild/2010/03/31/displaying-target-output-items-using-the-console-logger).
+   * Set this to enable [printing all target outputs to the log](https://learn.microsoft.com/archive/blogs/msbuild/displaying-target-output-items-using-the-console-logger).
  * `MSBUILDLOGTASKINPUTS=1`
    * Log task inputs (not needed if there are any diagnostic loggers already).
  * `MSBUILDEMITSOLUTION=1`
    * Save the generated .proj file for the .sln that is used to build the solution.
  * `MSBUILDENABLEALLPROPERTYFUNCTIONS=1`
-   * Enable [additional property functions](https://blogs.msdn.microsoft.com/visualstudio/2010/04/02/msbuild-property-functions).
+   * Enable [additional property functions](https://devblogs.microsoft.com/visualstudio/msbuild-property-functions/).
  * `MSBUILDLOGVERBOSERARSEARCHRESULTS=1`
    * In ResolveAssemblyReference task, log verbose search results.
  * `MSBUILDLOGCODETASKFACTORYOUTPUT=1`
@@ -33,7 +36,7 @@ See the [MSBuild Command-Line Reference](https://docs.microsoft.com/visualstudio
    * Launch debugger on build start.
    * Setting the value of 2 allows for manually attaching a debugger to a process ID.
  * `MSBUILDDEBUGSCHEDULER=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
-   * Dumps scheduler state at specified directory
+   * Dumps scheduler state at specified directory (`MSBUILDDEBUGSCHEDULER` is implied by `MSBuildDebugEngine`).
 
 # TreatAsLocalProperty
 If MSBuild.exe is passed properties on the command line, such as `/p:Platform=AnyCPU` then this value overrides whatever assignments you have to that property inside property groups. For instance, `<Platform>x86</Platform>` will be ignored. To make sure your local assignment to properties overrides whatever they pass on the command line, add the following at the top of your MSBuild project file:
@@ -45,7 +48,7 @@ If MSBuild.exe is passed properties on the command line, such as `/p:Platform=An
 This will make sure that your local assignments to the `Platform` property are respected. You can specify multiple properties in `TreatAsLocalProperty` separated by semicolon.
 
 # Visual Studio Background Builds
-Set the `TRACEDESIGNTIME=true` environment variable to output design-time build logs to TEMP: read more here: https://blogs.msdn.microsoft.com/jeremykuhne/2016/06/06/vs-background-builds
+Set the `TRACEDESIGNTIME=true` environment variable to output design-time build logs to TEMP: read more here: https://learn.microsoft.com/archive/blogs/jeremykuhne/vs-background-builds
 
 # Visual Studio Design-time (IntelliSense) builds
 
@@ -56,7 +59,7 @@ Use this command-line to approximate what the design-time build does:
 ```
 
 # Extend all builds (at system-wide level)
-See https://www.simple-talk.com/dotnet/.net-tools/extending-msbuild, "Extending all builds" section. Also read about [MSBuildUserExtensionsPath](http://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,33), [CustomBeforeMicrosoftCommonProps](http://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,68), [CustomBeforeMicrosoftCommonTargets](http://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.targets,71), and CustomAfterMicrosoftCommonProps/CustomAfterMicrosoftCommonTargets.
+See https://www.simple-talk.com/dotnet/.net-tools/extending-msbuild, "Extending all builds" section. Also read about [MSBuildUserExtensionsPath](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,33), [CustomBeforeMicrosoftCommonProps](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,68), [CustomBeforeMicrosoftCommonTargets](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.targets,71), and CustomAfterMicrosoftCommonProps/CustomAfterMicrosoftCommonTargets.
 
 Example:
 Create this file (Custom.props) in `C:\Users\username\AppData\Local\Microsoft\MSBuild\Current\Microsoft.Common.targets\ImportAfter`:
diff --git a/documentation/wiki/Microsoft.Build.Framework.md b/documentation/wiki/Microsoft.Build.Framework.md
index c72abbf4578..658d8d6c57f 100644
--- a/documentation/wiki/Microsoft.Build.Framework.md
+++ b/documentation/wiki/Microsoft.Build.Framework.md
@@ -1,7 +1,7 @@
 ### Microsoft.Build.Framework
 It you have looked carefully, you might notice some odd behavior around this assembly (Microsoft.Build.Framework). We released the source here, but in some cases if you use our `BuildAndCopy.cmd` script, you will reference the one on your machine instead of the one you just built! Here's why.
 
-Microsoft.Build.Framework contains the types and interfaces for extensibility in MSBuild. If you've ever written a custom Task, you might recognize them as ITask, ITaskItem, etc. After you build your Task, let's say targeting `Microsoft.Build.Framework, Version=12.0.0.0, PublicKeyToken=b03f5f7f11d50a3a` (Visual Studio 2013), anyone with MSBuild 12.0 or later can use your Task. In later versions of MSBuild, say version 14.0, we will use a [binding redirect](https://msdn.microsoft.com/en-us/library/eftw1fys(v=vs.110).aspx) to point you to the newer version of Microsoft.Build.Framework. Assuming we did our jobs right with compatibility, your Task should run without ever knowing the difference. The crucial point of detail here is that the public key token for the Framework assembly **did not change** between version. If it does, binding redirection is not allowed.
+Microsoft.Build.Framework contains the types and interfaces for extensibility in MSBuild. If you've ever written a custom Task, you might recognize them as ITask, ITaskItem, etc. After you build your Task, let's say targeting `Microsoft.Build.Framework, Version=12.0.0.0, PublicKeyToken=b03f5f7f11d50a3a` (Visual Studio 2013), anyone with MSBuild 12.0 or later can use your Task. In later versions of MSBuild, say version 14.0, we will use a [binding redirect](https://learn.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/bindingredirect-element) to point you to the newer version of Microsoft.Build.Framework. Assuming we did our jobs right with compatibility, your Task should run without ever knowing the difference. The crucial point of detail here is that the public key token for the Framework assembly **did not change** between version. If it does, binding redirection is not allowed.
 
 ## Option 1 - Project Reference
 By default this is enabled. This means that all MSBuild code will reference Microsoft.Build.Framework as a project reference and therefore will not have the same public key token as the retail version.
@@ -25,7 +25,7 @@ This will set the property for you and create a drop of MSBuild and dependencies
 
 ## Option 3 - Test or Delay Signing
 For the advanced user, another option here is to delay sign this version of MSBuild with our public key. Since that part of the key is public, it's very easy to extract (using `Sn.exe`) and delay sign. You can get more information on that here:
- * [Delay Signing](https://blogs.msdn.microsoft.com/shawnfa/2004/03/17/delay-signing/)
- * [Test Key Signing](http://blogs.msdn.com/b/shawnfa/archive/2005/10/24/484170.aspx)
+ * [Delay Signing](https://learn.microsoft.com/archive/blogs/shawnfa/delay-signing)
+ * [Test Key Signing](https://web.archive.org/web/20101005012428/http://blogs.msdn.com/b/shawnfa/archive/2005/10/24/484170.aspx)
 
 Delay signing is the easiest, but it modifies your system to allow it to load and trust an assembly (Microsoft.Build.Framework) even when it's not signed at all, from any source. The Test Key Signing allows for a much more secure approach (as long as you keep your private key private), but is more complicated to setup. We are providing this as a reference, but please only try this if you: really want to customize Microsoft.Build.Framework and use existing custom Tasks, you feel comfortable with the security implications, and you acknowledge this is all at your own risk.
\ No newline at end of file
diff --git a/documentation/wiki/Rebuilding-when-nothing-changed.md b/documentation/wiki/Rebuilding-when-nothing-changed.md
index 9355b3a21bb..5f9fc83bd52 100644
--- a/documentation/wiki/Rebuilding-when-nothing-changed.md
+++ b/documentation/wiki/Rebuilding-when-nothing-changed.md
@@ -4,11 +4,11 @@ There is a class of problems with build where when you build twice, it still reb
 
 There are multiple tools to investigate and fix broken incrementality. Start with the blog posts below.
 
- * [https://blogs.msdn.microsoft.com/kirillosenkov/2014/08/04/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed/](https://blogs.msdn.microsoft.com/kirillosenkov/2014/08/04/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed/)
- * [https://blogs.msdn.microsoft.com/kirillosenkov/2015/05/12/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs/](https://blogs.msdn.microsoft.com/kirillosenkov/2015/05/12/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs/)
- * [http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/](http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/)
- * [MSDN: How to build incrementally](https://msdn.microsoft.com/en-us/library/ms171483.aspx)
- * [https://docs.microsoft.com/en-us/visualstudio/msbuild/incremental-builds?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/msbuild/incremental-builds?view=vs-2019)
+ * [How to investigate Rebuilding in Visual Studio when nothing has changed](https://learn.microsoft.com/archive/blogs/kirillosenkov/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed)
+ * [MSBuild: unnecessary rebuilds because of generated AssemblyAttributes.cs](https://learn.microsoft.com/archive/blogs/kirillosenkov/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs)
+ * [When Visual Studio keeps rebuilding Projects that have not changed](https://web.archive.org/web/20120321204616/http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/)
+ * [How to build incrementally](https://learn.microsoft.com/visualstudio/msbuild/how-to-build-incrementally)
+ * [Incremental builds](https://learn.microsoft.com/visualstudio/msbuild/incremental-builds)
 
 Strings to search for in the build logs:
  * `Building target "CoreCompile" completely`
@@ -16,4 +16,4 @@ Strings to search for in the build logs:
  * `out-of-date`
  * `missing`
 
-Consider using http://msbuildlog.com to help with searching through the build log.
\ No newline at end of file
+Consider using https://msbuildlog.com to help with searching through the build log.
\ No newline at end of file
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
index 27241f5dbd5..1dff452245f 100644
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ b/documentation/wiki/ResolveAssemblyReference.md
@@ -13,7 +13,7 @@ https://github.com/dotnet/msbuild/blob/a936b97e30679dcea4d99c362efa6f732c9d3587/
 This is where the RAR task is invoked in the targets file.
 
 The source code for RAR is at:
-https://github.com/dotnet/msbuild/blob/master/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+https://github.com/dotnet/msbuild/blob/main/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
 
 ## Inputs
 RAR is very detailed about logging its inputs:
diff --git a/documentation/wiki/Target-Maps.md b/documentation/wiki/Target-Maps.md
index 9f721c90075..722b28119c6 100644
--- a/documentation/wiki/Target-Maps.md
+++ b/documentation/wiki/Target-Maps.md
@@ -1,4 +1,4 @@
-[Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/BuildTargets.png)
-![Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/BuildTargets.png)
-[Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/CompileTargets.png)
-![Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/CompileTargets.png)
\ No newline at end of file
+[Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/BuildTargets.png)
+![Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/BuildTargets.png)
+[Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/CompileTargets.png)
+![Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/CompileTargets.png)
\ No newline at end of file
diff --git a/documentation/wiki/UnGAC.md b/documentation/wiki/UnGAC.md
index e0d45d729ee..a5b796f3edd 100644
--- a/documentation/wiki/UnGAC.md
+++ b/documentation/wiki/UnGAC.md
@@ -2,7 +2,7 @@
 
 ## What is the GAC?
 
-See the [public documentation](https://docs.microsoft.com/dotnet/framework/app-domains/gac). The GAC is a folder where different installations of VS on the same machine look for assemblies that are commonly used. If an assembly is in the GAC, it will be prioritized over any other assembly.
+See the [public documentation](https://learn.microsoft.com/dotnet/framework/app-domains/gac). The GAC is a folder where different installations of VS on the same machine look for assemblies that are commonly used. If an assembly is in the GAC, it will be prioritized over any other assembly.
 
 The only MSBuild assemblies you may see in the GAC are version 4.8. There is no reason any modern (15.1+) MSBuild assembly should be in the GAC today.
 
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 7b23330685f..6a795e13d4d 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -102,6 +102,7 @@
       <FreshlyBuiltBinariesx64 Include="$(X64BinPath)**\*.dll.config" />
 
       <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.Tasks.Core.dll" />
+      <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.dll" />
       <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.exe" />
       <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.tlb" />
       <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.pdb" />
diff --git a/eng/Packages.props b/eng/Packages.props
index 47af99de0a9..bce1a6ee70a 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -18,8 +18,8 @@
     <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
     <PackageReference Update="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
-    <PackageReference Update="System.Net.Http" Version="$(SystemNetHttpVersion)" />
     <PackageReference Update="System.Memory" Version="$(SystemMemoryVersion)" />
+    <PackageReference Update="System.Net.Http" Version="$(SystemNetHttpVersion)" />
     <PackageReference Update="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
     <PackageReference Update="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
diff --git a/eng/Versions.props b/eng/Versions.props
index a11441ae372..76329bb1793 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -27,6 +27,11 @@
   <PropertyGroup>
     <SystemCollectionsImmutableVersion>6.0.0</SystemCollectionsImmutableVersion>
     <SystemConfigurationConfigurationManagerVersion>6.0.0</SystemConfigurationConfigurationManagerVersion>
+    <!-- 
+        Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
+        When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+ 
+        and follow the guidelines written here (internal-link): https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/1796/How-to-add-a-Known-Issue
+    -->
     <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
     <SystemNetHttpVersion>4.3.4</SystemNetHttpVersion>
     <SystemReflectionMetadataLoadContextVersion>6.0.0</SystemReflectionMetadataLoadContextVersion>
diff --git a/eng/config/OptProf.runsettings b/eng/config/OptProf.runsettings
new file mode 100644
index 00000000000..3c5f7566a46
--- /dev/null
+++ b/eng/config/OptProf.runsettings
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RunSettings>
+  <RunConfiguration>
+    <ResultsDirectory>C:\Test\Results</ResultsDirectory>
+    <TargetPlatform>X86</TargetPlatform>
+    <MaxCpuCount>1</MaxCpuCount>
+    <BatchSize>10</BatchSize>
+    <TestSessionTimeout>21600000</TestSessionTimeout>
+    <DesignMode>False</DesignMode>
+    <InIsolation>False</InIsolation>
+    <CollectSourceInformation>False</CollectSourceInformation>
+    <DisableAppDomain>False</DisableAppDomain>
+    <DisableParallelization>False</DisableParallelization>
+    <TargetFrameworkVersion>.NETFramework,Version=v4.0</TargetFrameworkVersion>
+    <ExecutionThreadApartmentState>STA</ExecutionThreadApartmentState>
+    <TestAdaptersPaths>%SystemDrive%\Test</TestAdaptersPaths>
+    <TreatTestAdapterErrorsAsWarnings>False</TreatTestAdapterErrorsAsWarnings>
+  </RunConfiguration>
+  <SessionConfiguration>
+    <!-- Generated -->
+  </SessionConfiguration>
+  <DataCollectionRunSettings>
+    <DataCollectors>
+      <DataCollector uri="datacollector://microsoft/DevDiv/TestExtensions/ProcDumpCollector/v1" friendlyName="ProcDump Collector" enabled="True">
+        <Configuration>
+          <RootDumpDirectory>C:\Test\Dumps</RootDumpDirectory>
+          <Deployment PackageName = "Microsoft.DevDiv.TestExtensions.ProcDumpCollector" />
+        </Configuration>
+      </DataCollector>
+      <DataCollector uri="datacollector://microsoft/DevDiv/TestExtensions/LingeringProcessCollector/v1" friendlyName="Lingering Process Collector" enabled="True">
+        <Configuration>
+          <KillLingeringProcesses>true</KillLingeringProcesses>          
+          <ShutdownCommands>
+            <ShutdownCommand Process="VBCSCompiler" Command="%ProcessPath%" Arguments="-shutdown" Timeout="60000" />
+          </ShutdownCommands>
+          <LoggingBehavior>Warning</LoggingBehavior>
+          <Deployment PackageName = "Microsoft.DevDiv.TestExtensions.LingeringProcessCollector" />
+        </Configuration>
+      </DataCollector>
+      <DataCollector uri="datacollector://microsoft/DevDiv/VideoRecorder/2.0" friendlyName="Screen and Voice Recorder" enabled="True">
+        <Configuration>
+          <Deployment PackageName = "Microsoft.DevDiv.Validation.MediaRecorder" />
+        </Configuration>
+      </DataCollector>
+    </DataCollectors>
+  </DataCollectionRunSettings>
+  <InProcDataCollectionRunSettings>
+    <InProcDataCollectors>
+      <InProcDataCollector uri="datacollector://microsoft/DevDiv/TestExtensions/OptProfDataCollector/v2" assemblyQualifiedName="Microsoft.DevDiv.TestExtensions.OptProfDataCollector, Microsoft.DevDiv.TestExtensions.OptProfDataCollector, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null" friendlyName="OptProf Data Collector" enabled="True" codebase="C:\Test\Extensions\Microsoft.DevDiv.TestExtensions.OptProfDataCollector\lib\net461\Microsoft.DevDiv.TestExtensions.OptProfDataCollector.dll">
+        <Configuration>
+          <WorkingDirectory>C:\OptProf</WorkingDirectory>
+          <ProfilesDirectory>C:\Profiles</ProfilesDirectory>
+          <IgnoreProfileNotGeneratedExceptions>true</IgnoreProfileNotGeneratedExceptions>
+          <Deployment PackageName="Microsoft.DevDiv.TestExtensions.OptProfDataCollector" />
+        </Configuration>
+      </InProcDataCollector>
+    </InProcDataCollectors>
+  </InProcDataCollectionRunSettings>
+  <TestRunParameters />
+  <LoggerRunSettings>
+    <Loggers />
+  </LoggerRunSettings>
+  <VisualStudioConfiguration>
+    <!-- MSBuild-OptProf specific VS configuration element -->
+    <InstallationUnderTest>
+      <Components All="false">
+        <Include ID="Microsoft.VisualStudio.Component.VC.CLI.Support" />
+        <Include ID="Microsoft.VisualStudio.Component.Windows81SDK" />
+        <Include ID="Microsoft.VisualStudio.ComponentGroup.UWP.VC" />
+        <Include ID="Microsoft.VisualStudio.Component.VC.ATLMFC" />
+        <Include ID="Microsoft.VisualStudio.Component.Windows10SDK.15063.Desktop" />
+        <Include ID="Microsoft.VisualStudio.Component.Windows10SDK.16299" />
+        <Include ID="Microsoft.VisualStudio.Component.Windows10SDK.16299.UWP" />
+        <Include ID="Microsoft.Net.ComponentGroup.4.7.2.DeveloperTools" />
+        <Exclude ID="Component.Incredibuild" />
+        <Exclude ID="Component.JavaJDK" />
+        <Exclude ID="Microsoft.VisualStudio.Component.AspNet45" />
+      </Components>
+      <Workloads All="false" IncludeComponents="Required,Recommended">
+        <Include ID="Microsoft.VisualStudio.Workload.CoreEditor" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.ManagedDesktop" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.NativeCrossPlat" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.NativeDesktop" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.NetWeb" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.Office" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.Universal" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.VisualStudioExtension" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.Webcrossplat" IncludeComponents="Required" />
+      </Workloads>
+    </InstallationUnderTest>
+  </VisualStudioConfiguration>
+</RunSettings>
\ No newline at end of file
diff --git a/global.json b/global.json
index d2f82b5445e..5a7064183af 100644
--- a/global.json
+++ b/global.json
@@ -5,9 +5,9 @@
   "tools": {
     "dotnet": "7.0.100",
     "vs": {
-      "version": "17.2.1"
+      "version": "17.3.1"
     },
-    "xcopy-msbuild": "17.2.1"
+    "xcopy-msbuild": "17.3.1"
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index ba0defea01b..7cbbae8a85a 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -21,6 +21,7 @@
 using ProjectCollection = Microsoft.Build.Evaluation.ProjectCollection;
 using Shouldly;
 using Xunit;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -1853,6 +1854,10 @@ public void ReloadCanOverwriteUnsavedChanges()
         public void ReloadDoesNotLeakCachedXmlDocuments()
         {
             using var env = TestEnvironment.Create();
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
             var testFiles = env.CreateTestProjectWithFiles("", new[] { "build.proj" });
             var projectFile = testFiles.CreatedFiles.First();
 
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 4d856fb153d..beb78eec2ae 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -654,9 +654,7 @@ public void TransformsUseCorrectDirectory_Basic()
                 project.ReevaluateIfNecessary();
 
                 project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(
-                    NativeMethodsShared.IsWindows
-                        ? Path.Combine(Path.GetTempPath(), @"obj\i386\foo.dll")
-                        : Path.Combine(Path.GetTempPath(), @"obj/i386/foo.dll"));
+                        Path.Combine(FileUtilities.TempFileDirectory, "obj", "i386", "foo.dll"));
             }
             finally
             {
@@ -721,8 +719,8 @@ public void TransformsUseCorrectDirectory_DirectoryTransform()
                 Project project = new Project(xml);
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
-                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
-                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory, "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory, "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
             }
             finally
             {
@@ -756,8 +754,8 @@ public void TransformsUseCorrectDirectory_DirectoryItemFunction()
                 Project project = new Project(xml);
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
-                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
-                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath(), "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory, "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory, "obj", "i386").Substring(RootPrefixLength) + Path.DirectorySeparatorChar);
             }
             finally
             {
@@ -794,8 +792,8 @@ public void TransformsUseCorrectDirectory_DirectoryNameItemFunction()
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
                 // Should be the full path to the directory
-                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
-                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(Path.GetTempPath() /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
             }
             finally
             {
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 7d42cfe8206..dc3d33b9784 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -424,7 +424,7 @@ public void TestCache()
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         [Trait("Category", "mono-osx-failing")]
-        public void TestCache2()
+        public void WorksCorrectlyWithCurlyBraces()
         {
             string projectBody = ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
@@ -471,11 +471,13 @@ public void TestCache2()
 
             try
             {
-                string problematicTmpPath = @"C:\Users\}\blabla\temp";
+                // Check if } do not cause it to crash due to usage of String.Format or such on code path
+                string problematicTmpPath = Path.Combine(originalTmp,  "}", "blabla", "temp");
                 Environment.SetEnvironmentVariable("TMP", problematicTmpPath);
                 Environment.SetEnvironmentVariable("TEMP", problematicTmpPath);
 
                 FileUtilities.ClearCacheDirectoryPath();
+                FileUtilities.ClearTempFileDirectory();
                 string cacheFilePath = configuration.GetCacheFile();
                 Assert.StartsWith(problematicTmpPath, cacheFilePath);
             }
@@ -484,6 +486,7 @@ public void TestCache2()
                 Environment.SetEnvironmentVariable("TMP", originalTmp);
                 Environment.SetEnvironmentVariable("TEMP", originalTemp);
                 FileUtilities.ClearCacheDirectoryPath();
+                FileUtilities.ClearTempFileDirectory();
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs b/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs
index 351d86a0d6a..0419a840a6c 100644
--- a/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs
+++ b/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs
@@ -24,7 +24,7 @@ public void DumpExceptionToFileShouldWriteInTempPathByDefault()
             try
             {
                 ExceptionHandling.DumpExceptionToFile(new Exception("hello world"));
-                exceptionFiles = Directory.GetFiles(Path.GetTempPath(), "MSBuild_*failure.txt");
+                exceptionFiles = Directory.GetFiles(FileUtilities.TempFileDirectory, "MSBuild_*failure.txt");
             }
             finally
             {
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index 164bbd71800..bc8849c9dfe 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -583,6 +583,7 @@ public void ErrorWhenTaskFailsWithoutLoggingErrorEscapeHatch(string failureRespo
             else
             {
                 logger.ErrorCount.ShouldBe(0);
+                logger.AssertLogContains( String.Format(MockLogger.GetString("TaskReturnedFalseButDidNotLogError"), "FailingTask") );
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index a90afeabc38..f2abb27be9c 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -990,7 +990,7 @@ private void SimpleSymlinkInputCheck(DateTime symlinkWriteTime, DateTime targetW
                 _testOutputHelper.WriteLine($"Created input file {inputTarget}");
                 File.SetLastWriteTime(inputTarget, targetWriteTime);
 
-                inputSymlink = FileUtilities.GetTemporaryFile(null, ".linkin", createFile: false);
+                inputSymlink = FileUtilities.GetTemporaryFile(null, null, ".linkin", createFile: false);
 
                 if (!CreateSymbolicLink(inputSymlink, inputTarget, 0))
                 {
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index d2ab15a93eb..16c1c196883 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -141,7 +141,7 @@ public void ParseFirstProjectLine_InvalidProject()
         [Fact]
         public void ParseEtpProject()
         {
-            string proj1Path = Path.Combine(Path.GetTempPath(), "someproj.etp");
+            string proj1Path = Path.Combine(FileUtilities.TempFileDirectory, "someproj.etp");
             try
             {
                 // Create the first .etp project file
@@ -192,8 +192,8 @@ public void ParseEtpProject()
         [Fact]
         public void CanBeMSBuildFile()
         {
-            string proj1Path = Path.Combine(Path.GetTempPath(), "someproj.etp");
-            string proj2Path = Path.Combine(Path.GetTempPath(), "someproja.proj");
+            string proj1Path = Path.Combine(FileUtilities.TempFileDirectory, "someproj.etp");
+            string proj2Path = Path.Combine(FileUtilities.TempFileDirectory, "someproja.proj");
             try
             {
                 // Create the first .etp project file
@@ -317,8 +317,8 @@ public void CanBeMSBuildFileRejectsMSBuildLikeFiles()
         [Fact]
         public void ParseNestedEtpProjectSingleLevel()
         {
-            string proj1Path = Path.Combine(Path.GetTempPath(), "someproj.etp");
-            string proj2Path = Path.Combine(Path.GetTempPath(), "someproj2.etp");
+            string proj1Path = Path.Combine(FileUtilities.TempFileDirectory, "someproj.etp");
+            string proj2Path = Path.Combine(FileUtilities.TempFileDirectory, "someproj2.etp");
             try
             {
                 // Create the first .etp project file
@@ -513,9 +513,9 @@ public void TestVSAndSolutionVersionParsing()
         [Trait("Category", "netcore-linux-failing")]
         public void ParseNestedEtpProjectMultipleLevel()
         {
-            string proj1Path = Path.Combine(Path.GetTempPath(), "someproj.etp");
-            string proj2Path = Path.Combine(Path.GetTempPath(), "someproj2.etp");
-            string proj3Path = Path.Combine(Path.GetTempPath(), "ETPProjUpgradeTest", "someproj3.etp");
+            string proj1Path = Path.Combine(FileUtilities.TempFileDirectory, "someproj.etp");
+            string proj2Path = Path.Combine(FileUtilities.TempFileDirectory, "someproj2.etp");
+            string proj3Path = Path.Combine(FileUtilities.TempFileDirectory, "ETPProjUpgradeTest", "someproj3.etp");
             try
             {
                 // Create the first .etp project file
@@ -567,7 +567,7 @@ public void ParseNestedEtpProjectMultipleLevel()
                     </GENERAL>
                 </EFPROJECT>";
                 // Create the directory for the third project
-                Directory.CreateDirectory(Path.Combine(Path.GetTempPath(), "ETPProjUpgradeTest"));
+                Directory.CreateDirectory(Path.Combine(FileUtilities.TempFileDirectory, "ETPProjUpgradeTest"));
                 File.WriteAllText(proj3Path, etpProjContent);
 
                 // Create the SolutionFile object
@@ -602,7 +602,7 @@ public void ParseNestedEtpProjectMultipleLevel()
         [Fact]
         public void MalformedEtpProjFile()
         {
-            string proj1Path = Path.Combine(Path.GetTempPath(), "someproj.etp");
+            string proj1Path = Path.Combine(FileUtilities.TempFileDirectory, "someproj.etp");
             try
             {
                 // Create the .etp project file
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 780b83ffa0b..6c726a5476d 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -850,7 +850,7 @@ public void SolutionConfigurationWithDependencies()
   <ProjectConfiguration Project=`{{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}}` AbsolutePath=`##temp##{Path.Combine("Project1", "A.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
   <ProjectConfiguration Project=`{{881C1674-4ECA-451D-85B6-D7C59B7F16FA}}` AbsolutePath=`##temp##{Path.Combine("Project2", "B.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU<ProjectDependency Project=`{{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}}` /></ProjectConfiguration>
   <ProjectConfiguration Project=`{{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}}` AbsolutePath=`##temp##{Path.Combine("Project3", "C.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
-</SolutionConfiguration>".Replace("`", "\"").Replace("##temp##", Path.GetTempPath());
+</SolutionConfiguration>".Replace("`", "\"").Replace("##temp##", FileUtilities.TempFileDirectory);
 
             Helpers.VerifyAssertLineByLine(expected, solutionConfigurationContents);
         }
@@ -1090,14 +1090,14 @@ public void TestAddPropertyGroupForSolutionConfiguration()
             msbuildProject.ReevaluateIfNecessary();
 
             string solutionConfigurationContents = msbuildProject.GetPropertyValue("CurrentSolutionConfigurationContents");
-            string tempProjectPath = Path.Combine(Path.GetTempPath(), "ClassLibrary1", "ClassLibrary1.csproj");
+            string tempProjectPath = Path.Combine(FileUtilities.TempFileDirectory, "ClassLibrary1", "ClassLibrary1.csproj");
 
             Assert.Contains("{6185CC21-BE89-448A-B3C0-D1C27112E595}", solutionConfigurationContents);
             tempProjectPath = Path.GetFullPath(tempProjectPath);
             Assert.True(solutionConfigurationContents.IndexOf(tempProjectPath, StringComparison.OrdinalIgnoreCase) > 0);
             Assert.Contains("CSConfig1|AnyCPU", solutionConfigurationContents);
 
-            tempProjectPath = Path.Combine(Path.GetTempPath(), "MainApp", "MainApp.vcxproj");
+            tempProjectPath = Path.Combine(FileUtilities.TempFileDirectory, "MainApp", "MainApp.vcxproj");
             tempProjectPath = Path.GetFullPath(tempProjectPath);
             Assert.Contains("{A6F99D27-47B9-4EA4-BFC9-25157CBDC281}", solutionConfigurationContents);
             Assert.True(solutionConfigurationContents.IndexOf(tempProjectPath, StringComparison.OrdinalIgnoreCase) > 0);
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 51d649107b5..16d14863873 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -1618,7 +1618,7 @@ public void ItemPredecessorToItemViaTransform()
                           <h Include='h1'>
                             <m>1</m>
                           </h>
-                          <i Include=""@(h->'%(identity))"">
+                          <i Include=""@(h->'%(identity)')"">
                             <m>2;%(m)</m>
                           </i>
                         </ItemGroup>
@@ -1628,8 +1628,8 @@ public void ItemPredecessorToItemViaTransform()
 
             ProjectMetadata metadatum = project.GetItems("i").ElementAt(0).GetMetadata("m");
 
-            Assert.Equal("2;", metadatum.EvaluatedValue);
-            Assert.Null(metadatum.Predecessor);
+            Assert.Equal("2;1", metadatum.EvaluatedValue);
+            Assert.Equal("1", metadatum.Predecessor.EvaluatedValue);
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index e77a47e5ef4..8501b7297f9 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3052,7 +3052,7 @@ public void PropertyFunctionStaticMethodEnumArgument()
         [Fact]
         public void PropertyFunctionStaticMethodDirectoryNameOfFileAbove()
         {
-            string tempPath = Path.GetTempPath();
+            string tempPath = FileUtilities.TempFileDirectory;
             string tempFile = Path.GetFileName(FileUtilities.GetTemporaryFile());
 
             try
@@ -3090,7 +3090,7 @@ public void PropertyFunctionStaticMethodGetPathOfFileAbove()
             //
             MockElementLocation mockElementLocation = new MockElementLocation(Path.Combine(ObjectModelHelpers.TempProjectDir, "one", "two", "three", "four", "five", Path.GetRandomFileName()));
 
-            string fileToFind = FileUtilities.GetTemporaryFile(ObjectModelHelpers.TempProjectDir, ".tmp");
+            string fileToFind = FileUtilities.GetTemporaryFile(ObjectModelHelpers.TempProjectDir, null, ".tmp");
 
             try
             {
diff --git a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
index ab9bfe05035..397e67fbecc 100644
--- a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
@@ -6,6 +6,7 @@
 using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
 
@@ -27,7 +28,13 @@ public class ProjectStringCache_Tests
         [Trait("Category", "netcore-linux-failing")]
         public void ContentIsSameAcrossInstances()
         {
-            string content = ObjectModelHelpers.CleanupFileContents(@"
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                string content = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                         <ItemGroup>
                            Item group content
@@ -35,38 +42,39 @@ Item group content
                     </Project>
                     ");
 
-            string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFile();
 
-            try
-            {
-                File.WriteAllText(path, content);
+                try
+                {
+                    File.WriteAllText(path, content);
 
-                ProjectStringCache cache = new ProjectStringCache();
-                XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                document1.StringCache = cache;
-                document1.Load(path);
+                    ProjectStringCache cache = new ProjectStringCache();
+                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
+                    document1.StringCache = cache;
+                    document1.Load(path);
 
-                XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                document2.StringCache = cache;
-                document2.Load(path);
+                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
+                    document2.StringCache = cache;
+                    document2.Load(path);
 
-                XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
 
-                Assert.Equal(1, nodes1.Count);
-                Assert.Equal(1, nodes2.Count);
+                    Assert.Equal(1, nodes1.Count);
+                    Assert.Equal(1, nodes2.Count);
 
-                XmlNode node1 = nodes1[0].FirstChild;
-                XmlNode node2 = nodes2[0].FirstChild;
+                    XmlNode node1 = nodes1[0].FirstChild;
+                    XmlNode node2 = nodes2[0].FirstChild;
 
-                Assert.NotNull(node1);
-                Assert.NotNull(node2);
-                Assert.NotSame(node1, node2);
-                Assert.Same(node1.Value, node2.Value);
-            }
-            finally
-            {
-                File.Delete(path);
+                    Assert.NotNull(node1);
+                    Assert.NotNull(node2);
+                    Assert.NotSame(node1, node2);
+                    Assert.Same(node1.Value, node2.Value);
+                }
+                finally
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -78,7 +86,13 @@ Item group content
         [Trait("Category", "netcore-linux-failing")]
         public void ContentCanBeModified()
         {
-            string content = ObjectModelHelpers.CleanupFileContents(@"
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                string content = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                         <ItemGroup attr1='attr1value'>
                            Item group content
@@ -86,57 +100,58 @@ Item group content
                     </Project>
                     ");
 
-            string path = FileUtilities.GetTemporaryFile();
-
-            try
-            {
-                File.WriteAllText(path, content);
-                ProjectStringCache cache = new ProjectStringCache();
-                XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                document1.StringCache = cache;
-                document1.Load(path);
-
-                XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                document2.StringCache = cache;
-                document2.Load(path);
-
-                string outerXml1 = document1.OuterXml;
-                string outerXml2 = document2.OuterXml;
-                Assert.Equal(outerXml1, outerXml2);
-
-                XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
-
-                Assert.Equal(1, nodes1.Count);
-                Assert.Equal(1, nodes2.Count);
-
-                XmlNode node1 = nodes1[0];
-                XmlNode node2 = nodes2[0];
-                Assert.NotNull(node1);
-                Assert.NotNull(node2);
-                Assert.NotSame(node1, node2);
-                Assert.Single(node1.Attributes);
-                Assert.Single(node2.Attributes);
-                Assert.Same(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                node2.Attributes[0].Value = "attr1value";
-                Assert.Equal(node1.Attributes[0].Value, node2.Attributes[0].Value);
-                Assert.NotSame(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                node1 = nodes1[0].FirstChild;
-                node2 = nodes2[0].FirstChild;
-                Assert.NotSame(node1, node2);
-                Assert.Same(node1.Value, node2.Value);
-
-                XmlText newText = document2.CreateTextNode("New Value");
-                XmlNode parent = node2.ParentNode;
-                parent.ReplaceChild(newText, node2);
-
-                Assert.NotEqual(outerXml1, document2.OuterXml);
-            }
-            finally
-            {
-                File.Delete(path);
+                string path = FileUtilities.GetTemporaryFile();
+
+                try
+                {
+                    File.WriteAllText(path, content);
+                    ProjectStringCache cache = new ProjectStringCache();
+                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
+                    document1.StringCache = cache;
+                    document1.Load(path);
+
+                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
+                    document2.StringCache = cache;
+                    document2.Load(path);
+
+                    string outerXml1 = document1.OuterXml;
+                    string outerXml2 = document2.OuterXml;
+                    Assert.Equal(outerXml1, outerXml2);
+
+                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
+
+                    Assert.Equal(1, nodes1.Count);
+                    Assert.Equal(1, nodes2.Count);
+
+                    XmlNode node1 = nodes1[0];
+                    XmlNode node2 = nodes2[0];
+                    Assert.NotNull(node1);
+                    Assert.NotNull(node2);
+                    Assert.NotSame(node1, node2);
+                    Assert.Single(node1.Attributes);
+                    Assert.Single(node2.Attributes);
+                    Assert.Same(node1.Attributes[0].Value, node2.Attributes[0].Value);
+
+                    node2.Attributes[0].Value = "attr1value";
+                    Assert.Equal(node1.Attributes[0].Value, node2.Attributes[0].Value);
+                    Assert.NotSame(node1.Attributes[0].Value, node2.Attributes[0].Value);
+
+                    node1 = nodes1[0].FirstChild;
+                    node2 = nodes2[0].FirstChild;
+                    Assert.NotSame(node1, node2);
+                    Assert.Same(node1.Value, node2.Value);
+
+                    XmlText newText = document2.CreateTextNode("New Value");
+                    XmlNode parent = node2.ParentNode;
+                    parent.ReplaceChild(newText, node2);
+
+                    Assert.NotEqual(outerXml1, document2.OuterXml);
+                }
+                finally
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -149,74 +164,81 @@ Item group content
         [Trait("Category", "netcore-linux-failing")]
         public void RemovingFilesRemovesEntries()
         {
-            string content = ObjectModelHelpers.CleanupFileContents(@"
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                string content = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                         <ItemGroup>Content</ItemGroup>
                     </Project>
                     ");
 
-            string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFile();
 
-            try
-            {
-                File.WriteAllText(path, content);
+                try
+                {
+                    File.WriteAllText(path, content);
 
-                ProjectStringCache cache = new ProjectStringCache();
-                ProjectCollection collection = new ProjectCollection();
-                int entryCount;
+                    ProjectStringCache cache = new ProjectStringCache();
+                    ProjectCollection collection = new ProjectCollection();
+                    int entryCount;
 
-                ProjectRootElement pre1 = ProjectRootElement.Create(collection);
-                pre1.XmlDocument.StringCache = cache;
-                pre1.FullPath = path;
-                pre1.XmlDocument.Load(path);
+                    ProjectRootElement pre1 = ProjectRootElement.Create(collection);
+                    pre1.XmlDocument.StringCache = cache;
+                    pre1.FullPath = path;
+                    pre1.XmlDocument.Load(path);
 
-                entryCount = cache.Count;
-                Assert.True(entryCount > 0);
+                    entryCount = cache.Count;
+                    Assert.True(entryCount > 0);
 
-                ProjectRootElement pre2 = ProjectRootElement.Create(collection);
-                pre2.XmlDocument.StringCache = cache;
-                pre2.FullPath = path;
-                pre2.XmlDocument.Load(path);
+                    ProjectRootElement pre2 = ProjectRootElement.Create(collection);
+                    pre2.XmlDocument.StringCache = cache;
+                    pre2.FullPath = path;
+                    pre2.XmlDocument.Load(path);
 
-                // Entry count should not have changed
-                Assert.Equal(entryCount, cache.Count);
+                    // Entry count should not have changed
+                    Assert.Equal(entryCount, cache.Count);
 
-                string itemGroupContent = cache.Get("Content");
-                Assert.NotNull(itemGroupContent);
+                    string itemGroupContent = cache.Get("Content");
+                    Assert.NotNull(itemGroupContent);
 
-                XmlNodeList nodes1 = pre1.XmlDocument.GetElementsByTagName("ItemGroup");
-                XmlNodeList nodes2 = pre2.XmlDocument.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes1 = pre1.XmlDocument.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes2 = pre2.XmlDocument.GetElementsByTagName("ItemGroup");
 
-                Assert.Equal(1, nodes1.Count);
-                Assert.Equal(1, nodes2.Count);
+                    Assert.Equal(1, nodes1.Count);
+                    Assert.Equal(1, nodes2.Count);
 
-                XmlNode node1 = nodes1[0];
-                XmlNode node2 = nodes2[0];
-                Assert.NotNull(node1);
-                Assert.NotNull(node2);
-                Assert.NotSame(node1, node2);
-                Assert.Same(node1.Value, node2.Value);
+                    XmlNode node1 = nodes1[0];
+                    XmlNode node2 = nodes2[0];
+                    Assert.NotNull(node1);
+                    Assert.NotNull(node2);
+                    Assert.NotSame(node1, node2);
+                    Assert.Same(node1.Value, node2.Value);
 
-                // Now remove one document
-                collection.UnloadProject(pre1);
+                    // Now remove one document
+                    collection.UnloadProject(pre1);
 
-                // We should still be able to get Content
-                itemGroupContent = cache.Get("Content");
-                Assert.NotNull(itemGroupContent);
+                    // We should still be able to get Content
+                    itemGroupContent = cache.Get("Content");
+                    Assert.NotNull(itemGroupContent);
 
-                // Now remove the second document
-                collection.UnloadProject(pre2);
+                    // Now remove the second document
+                    collection.UnloadProject(pre2);
 
-                // Now we should not be able to get Content
-                itemGroupContent = cache.Get("Content");
-                Assert.Null(itemGroupContent);
+                    // Now we should not be able to get Content
+                    itemGroupContent = cache.Get("Content");
+                    Assert.Null(itemGroupContent);
 
-                // And there should be no entries
-                Assert.Equal(0, cache.Count);
-            }
-            finally
-            {
-                File.Delete(path);
+                    // And there should be no entries
+                    Assert.Equal(0, cache.Count);
+                }
+                finally
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -227,32 +249,39 @@ public void RemovingFilesRemovesEntries()
         [Fact]
         public void AddReturnsSameInstanceForSameDocument()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                ProjectStringCache cache = new ProjectStringCache();
 
-            XmlDocument document = new XmlDocument();
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            string return1 = cache.Add(stringToAdd, document);
+                string stringToAdd = "Test1";
+                string return1 = cache.Add(stringToAdd, document);
 
-            // Content of string should be the same.
-            Assert.Equal(1, cache.Count);
-            Assert.Equal(stringToAdd, return1);
+                // Content of string should be the same.
+                Assert.Equal(1, cache.Count);
+                Assert.Equal(stringToAdd, return1);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('1');
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('1');
 
-            string return2 = cache.Add(builder.ToString(), document);
+                string return2 = cache.Add(builder.ToString(), document);
 
-            // Content of string should be the same.            
-            Assert.Equal(builder.ToString(), return2);
+                // Content of string should be the same.            
+                Assert.Equal(builder.ToString(), return2);
 
-            // Returned references should be the same
-            Assert.Same(return1, return2);
+                // Returned references should be the same
+                Assert.Same(return1, return2);
 
-            // Should not have added any new string instances to the cache.
-            Assert.Equal(1, cache.Count);
+                // Should not have added any new string instances to the cache.
+                Assert.Equal(1, cache.Count);
+            }
         }
 
         /// <summary>
@@ -262,32 +291,39 @@ public void AddReturnsSameInstanceForSameDocument()
         [Fact]
         public void AddReturnsSameInstanceForDifferentDocument()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                ProjectStringCache cache = new ProjectStringCache();
 
-            XmlDocument document = new XmlDocument();
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            string return1 = cache.Add(stringToAdd, document);
+                string stringToAdd = "Test1";
+                string return1 = cache.Add(stringToAdd, document);
 
-            // Content of string should be the same.
-            Assert.Equal(stringToAdd, return1);
+                // Content of string should be the same.
+                Assert.Equal(stringToAdd, return1);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('1');
-            XmlDocument document2 = new XmlDocument();
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('1');
+                XmlDocument document2 = new XmlDocument();
 
-            string return2 = cache.Add(builder.ToString(), document2);
+                string return2 = cache.Add(builder.ToString(), document2);
 
-            // Content of string should be the same.
-            Assert.Equal(builder.ToString(), return2);
+                // Content of string should be the same.
+                Assert.Equal(builder.ToString(), return2);
 
-            // Returned references should be the same
-            Assert.Same(return1, return2);
+                // Returned references should be the same
+                Assert.Same(return1, return2);
 
-            // Should not have added any new string instances to the cache.
-            Assert.Equal(1, cache.Count);
+                // Should not have added any new string instances to the cache.
+                Assert.Equal(1, cache.Count);
+            }
         }
 
         /// <summary>
@@ -302,28 +338,35 @@ public void AddReturnsSameInstanceForDifferentDocument()
         [Fact]
         public void RemoveLastInstanceDeallocatesEntry()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            XmlDocument document = new XmlDocument();
+                ProjectStringCache cache = new ProjectStringCache();
+
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            string return1 = cache.Add(stringToAdd, document);
+                string stringToAdd = "Test1";
+                string return1 = cache.Add(stringToAdd, document);
 
-            cache.Clear(document);
+                cache.Clear(document);
 
-            // Should be no instances left.
-            Assert.Equal(0, cache.Count);
+                // Should be no instances left.
+                Assert.Equal(0, cache.Count);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('1');
-            XmlDocument document2 = new XmlDocument();
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('1');
+                XmlDocument document2 = new XmlDocument();
 
-            string return2 = cache.Add(builder.ToString(), document2);
+                string return2 = cache.Add(builder.ToString(), document2);
 
-            // Returned references should NOT be the same
-            Assert.NotSame(return1, return2);
+                // Returned references should NOT be the same
+                Assert.NotSame(return1, return2);
+            }
         }
 
         /// <summary>
@@ -334,36 +377,43 @@ public void RemoveLastInstanceDeallocatesEntry()
         [Fact]
         public void RemoveOneInstance()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            XmlDocument document = new XmlDocument();
+                ProjectStringCache cache = new ProjectStringCache();
+
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            string return1 = cache.Add(stringToAdd, document);
-            Assert.Equal(1, cache.Count);
+                string stringToAdd = "Test1";
+                string return1 = cache.Add(stringToAdd, document);
+                Assert.Equal(1, cache.Count);
 
-            XmlDocument document2 = new XmlDocument();
-            cache.Add(stringToAdd, document2);
-            Assert.Equal(1, cache.Count);
+                XmlDocument document2 = new XmlDocument();
+                cache.Add(stringToAdd, document2);
+                Assert.Equal(1, cache.Count);
 
-            cache.Clear(document2);
+                cache.Clear(document2);
 
-            // Since there is still one document referencing the string, it should remain.
-            Assert.Equal(1, cache.Count);
+                // Since there is still one document referencing the string, it should remain.
+                Assert.Equal(1, cache.Count);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('1');
-            XmlDocument document3 = new XmlDocument();
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('1');
+                XmlDocument document3 = new XmlDocument();
 
-            string return3 = cache.Add(builder.ToString(), document3);
+                string return3 = cache.Add(builder.ToString(), document3);
 
-            // Returned references should be the same
-            Assert.Same(return1, return3);
+                // Returned references should be the same
+                Assert.Same(return1, return3);
 
-            // Still should only be one cached instance.
-            Assert.Equal(1, cache.Count);
+                // Still should only be one cached instance.
+                Assert.Equal(1, cache.Count);
+            }
         }
 
         /// <summary>
@@ -372,31 +422,38 @@ public void RemoveOneInstance()
         [Fact]
         public void DifferentStringsSameDocument()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                ProjectStringCache cache = new ProjectStringCache();
 
-            XmlDocument document = new XmlDocument();
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            cache.Add(stringToAdd, document);
-            Assert.Equal(1, cache.Count);
+                string stringToAdd = "Test1";
+                cache.Add(stringToAdd, document);
+                Assert.Equal(1, cache.Count);
 
-            stringToAdd = "Test2";
-            string return2 = cache.Add(stringToAdd, document);
+                stringToAdd = "Test2";
+                string return2 = cache.Add(stringToAdd, document);
 
-            // The second string gets its own instance.
-            Assert.Equal(2, cache.Count);
+                // The second string gets its own instance.
+                Assert.Equal(2, cache.Count);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('2');
-            string return3 = cache.Add(builder.ToString(), document);
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('2');
+                string return3 = cache.Add(builder.ToString(), document);
 
-            // The new string should be the same as the other one already in the collection.
-            Assert.Same(return2, return3);
+                // The new string should be the same as the other one already in the collection.
+                Assert.Same(return2, return3);
 
-            // No new instances for string with the same content.
-            Assert.Equal(2, cache.Count);
+                // No new instances for string with the same content.
+                Assert.Equal(2, cache.Count);
+            }
         }
 
         /// <summary>
@@ -405,33 +462,40 @@ public void DifferentStringsSameDocument()
         [Fact]
         public void DifferentStringsDifferentDocuments()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            XmlDocument document = new XmlDocument();
+                ProjectStringCache cache = new ProjectStringCache();
 
-            string stringToAdd = "Test1";
-            cache.Add(stringToAdd, document);
-            Assert.Equal(1, cache.Count);
+                XmlDocument document = new XmlDocument();
 
-            stringToAdd = "Test2";
-            XmlDocument document2 = new XmlDocument();
-            string return2 = cache.Add(stringToAdd, document2);
+                string stringToAdd = "Test1";
+                cache.Add(stringToAdd, document);
+                Assert.Equal(1, cache.Count);
 
-            // The second string gets its own instance.
-            Assert.Equal(2, cache.Count);
+                stringToAdd = "Test2";
+                XmlDocument document2 = new XmlDocument();
+                string return2 = cache.Add(stringToAdd, document2);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('2');
-            XmlDocument document3 = new XmlDocument();
-            string return3 = cache.Add(builder.ToString(), document3);
+                // The second string gets its own instance.
+                Assert.Equal(2, cache.Count);
 
-            // The new string should be the same as the other one already in the collection.
-            Assert.Same(return2, return3);
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('2');
+                XmlDocument document3 = new XmlDocument();
+                string return3 = cache.Add(builder.ToString(), document3);
 
-            // No new instances for string with the same content.
-            Assert.Equal(2, cache.Count);
+                // The new string should be the same as the other one already in the collection.
+                Assert.Same(return2, return3);
+
+                // No new instances for string with the same content.
+                Assert.Equal(2, cache.Count);
+            }
         }
     }
 }
diff --git a/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs b/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
index 55f05760f31..3bb784def3e 100644
--- a/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
@@ -213,9 +213,9 @@ public static void Equals_Other_ReturnsExpected(object version1Object, object ve
 
         public static IEnumerable<object[]> Parse_Valid_TestData()
         {
-            foreach (var prefix in new[] { "", "v",  "V"})
+            foreach (var prefix in new[] { "", "v", "V", " ", "\t", "\tv" })
             {
-                foreach (var suffix in new[] { "", "-pre", "-pre+metadata", "+metadata"})
+                foreach (var suffix in new[] { "", "-pre", "-pre+metadata", "+metadata", " ", "\n", "-pre \r\n" })
                 {
                     yield return new object[] { $"{prefix}1{suffix}", new SimpleVersion(1) };
                     yield return new object[] { $"{prefix}1.2{suffix}", new SimpleVersion(1, 2) };
@@ -257,7 +257,7 @@ public static IEnumerable<object[]> Parse_Invalid_TestData()
             yield return new object[] { "1.2.2147483648.4", typeof(FormatException) }; // Input contains a value > int.MaxValue
             yield return new object[] { "1.2.3.2147483648", typeof(FormatException) }; // Input contains a value > int.MaxValue
 
-            // System.Version allows whitespace around components, but we don't
+            // System.Version allows whitespace around components, but we only allow it at the beginning and end of the string.
             yield return new object[] { "2  .3.    4.  \t\r\n15  ", typeof(FormatException) };
             yield return new object[] { "   2  .3.    4.  \t\r\n15  ", typeof(FormatException) };
 
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 7c278ef5d8e..2a17d2e97d0 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -775,28 +775,6 @@ public void GetTargetListsNullEntryTargets()
             }
         }
 
-        [Fact]
-        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()
-        {
-            using (var env = TestEnvironment.Create())
-            {
-                var root1 = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: new Dictionary<string, string[]> {{"A", new[] {"B"}}}, defaultTargets: "A").Path;
-                var root2 = CreateProjectFile(env: env, projectNumber: 2, projectReferences: new[] {3}, projectReferenceTargets: new Dictionary<string, string[]> {{"B", new[] {"C"}}, {"X", new[] {"Y"}}}, defaultTargets: "X").Path;
-                CreateProjectFile(env: env, projectNumber: 3);
-
-
-                var projectGraph = new ProjectGraph(new []{root1, root2});
-                projectGraph.ProjectNodes.Count.ShouldBe(3);
-
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);
-
-                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "B" });
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { "C" });
-            }
-        }
-
         [Fact]
         public void GetTargetsListReturnsEmptyTargetsForNodeIfNoTargetsPropagatedToIt()
         {
@@ -1299,6 +1277,19 @@ public void GetTargetsListProjectReferenceTargetsOrDefaultComplexPropagation()
             }
         }
 
+        [Fact]
+        public void ReferencedMultitargetingEntryPointNodeTargetListContainsDefaultTarget()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                TransientTestFile entryProject1 = CreateProjectFile(env, 1, projectReferences: new[] { 2 }, defaultTargets: "A", extraContent: ProjectReferenceTargetsWithMultitargeting);
+                TransientTestFile entryProject2 = CreateProjectFile(env, 2, defaultTargets: "A", extraContent: OuterBuildSpecificationWithProjectReferenceTargets);
+                var graph = new ProjectGraph(new HashSet<string> { entryProject1.Path, entryProject2.Path });
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(null);
+                targetLists[key: GetOuterBuild(graph, 2)].ShouldBe(expected: OuterBuildTargets.Prepend("A"));
+            }
+        }
+
         public static IEnumerable<object[]> Graphs
         {
             get
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 56126bfbffa..405f2716d21 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -1035,7 +1035,7 @@ public void MultiplePlugins()
 ");
             var mockCache = new InstanceMockCache();
 
-            var buildParameters =  new BuildParameters
+            var buildParameters = new BuildParameters
             {
                 ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache),
             };
@@ -1047,7 +1047,7 @@ public void MultiplePlugins()
                 logger = buildSession.Logger;
                 graphResult = buildSession.BuildGraph(graph);
             }
-            
+
             graphResult.ShouldHaveSucceeded();
         }
 
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index f683529b74d..5771471c8f9 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -409,6 +409,14 @@ public DeferredBuildMessage(string text, MessageImportance importance)
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
         public void BeginBuild(BuildParameters parameters, IEnumerable<DeferredBuildMessage> deferredBuildMessages)
         {
+            // TEMP can be modified from the environment. Most of Traits is lasts for the duration of the process (with a manual reset for tests)
+            // and environment variables we use as properties are stored in a dictionary at the beginning of the build, so they also cannot be
+            // changed during a build. Some of our older stuff uses live environment variable checks. The TEMP directory previously used a live
+            // environment variable check, but it now uses a cached value. Nevertheless, we should support changing it between builds, so reset
+            // it here in case the user is using Visual Studio or the MSBuild server, as those each last for multiple builds without changing
+            // BuildManager.
+            FileUtilities.ClearTempFileDirectory();
+
             // deferredBuildMessages cannot be an optional parameter on a single BeginBuild method because it would break binary compatibility.
             _deferredBuildMessages = deferredBuildMessages;
             BeginBuild(parameters);
@@ -904,10 +912,7 @@ public void EndBuild()
                 // but the top level exception handler there should catch everything and have forwarded it to the
                 // OnThreadException method in this class already.
                 _workQueue.Complete();
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-                {
-                    _workQueue.Completion.Wait();
-                }
+                _workQueue.Completion.Wait();
 
                 Task projectCacheDispose = _projectCacheService.DisposeAsync().AsTask();
 
@@ -957,10 +962,10 @@ public void EndBuild()
 
                 if (e is AggregateException ae && ae.InnerExceptions.Count == 1)
                 {
-                    e = ae.InnerExceptions.First();
+                    ExceptionDispatchInfo.Capture(ae.InnerExceptions[0]).Throw();
                 }
 
-                throw e;
+                throw;
             }
             finally
             {
@@ -1846,8 +1851,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
 
             if (submission.BuildRequestData.GraphBuildOptions.Build)
             {
-                // Kick off project cache initialization frontloading
-                Task.Run(() => _projectCacheService.InitializePluginsForGraph(projectGraph, _executionCancellationTokenSource.Token));
+                _projectCacheService.InitializePluginsForGraph(projectGraph, _executionCancellationTokenSource.Token);
 
                 var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
@@ -2738,14 +2742,7 @@ private void OnThreadException(Exception e)
         /// </summary>
         private void OnLoggingThreadException(Exception e)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                _workQueue.Post(() => OnThreadException(e));
-            }
-            else
-            {
-                OnThreadException(e);
-            }
+            _workQueue.Post(() => OnThreadException(e));
         }
 
         /// <summary>
@@ -2753,16 +2750,7 @@ private void OnLoggingThreadException(Exception e)
         /// </summary>
         private void OnProjectFinished(object sender, ProjectFinishedEventArgs e)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                _workQueue.Post(() => OnProjectFinishedBody(e));
-            }
-            else
-            {
-                OnProjectFinishedBody(e);
-            }
-
-            void OnProjectFinishedBody(ProjectFinishedEventArgs e)
+            _workQueue.Post(() =>
             {
                 lock (_syncLock)
                 {
@@ -2779,7 +2767,7 @@ void OnProjectFinishedBody(ProjectFinishedEventArgs e)
                         }
                     }
                 }
-            }
+            });
         }
 
         /// <summary>
@@ -2787,16 +2775,7 @@ void OnProjectFinishedBody(ProjectFinishedEventArgs e)
         /// </summary>
         private void OnProjectStarted(object sender, ProjectStartedEventArgs e)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                _workQueue.Post(() => OnProjectStartedBody(e));
-            }
-            else
-            {
-                OnProjectStartedBody(e);
-            }
-
-            void OnProjectStartedBody(ProjectStartedEventArgs e)
+            _workQueue.Post(() =>
             {
                 lock (_syncLock)
                 {
@@ -2805,7 +2784,7 @@ void OnProjectStartedBody(ProjectStartedEventArgs e)
                         _projectStartedEvents[e.BuildEventContext.SubmissionId] = e;
                     }
                 }
-            }
+            });
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index fca7476b2d5..5bc3111c107 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -630,8 +630,16 @@ public bool ShutdownInProcNodeOnBuildFinish
 
         /// <summary>
         /// Gets the startup directory.
+        /// It is current directory from which MSBuild command line was recently invoked.
+        /// It is communicated to working nodes as part of NodeConfiguration deserialization once the node manager acquires a particular node.
+        /// This deserialization assign this value to static backing field making it accessible from rest of build thread.
+        /// In MSBuild server node, this value is set once <see cref="ServerNodeBuildCommand"></see> is received.
         /// </summary>
-        internal static string StartupDirectory => s_startupDirectory;
+        internal static string StartupDirectory
+        {
+            get { return s_startupDirectory; }
+            set { s_startupDirectory = value; }
+        }
 
         /// <summary>
         /// Indicates whether the build plan is enabled or not.
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 3bb58aa36ab..6618dc945c8 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -120,14 +120,12 @@ internal class BuildRequestEngine : IBuildRequestEngine, IBuildComponent
         internal BuildRequestEngine()
         {
             _debugDumpState = Traits.Instance.DebugScheduler;
-            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? DebugUtils.DebugPath
-                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            _debugDumpPath = DebugUtils.DebugPath;
             _debugForceCaching = Environment.GetEnvironmentVariable("MSBUILDDEBUGFORCECACHING") == "1";
 
             if (String.IsNullOrEmpty(_debugDumpPath))
             {
-                _debugDumpPath = Path.GetTempPath();
+                _debugDumpPath = FileUtilities.TempFileDirectory;
             }
 
             _status = BuildRequestEngineStatus.Uninitialized;
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
index 3423453f19c..48a847b60ce 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
@@ -127,13 +127,8 @@ private static WorkUnitResult CreateWorkUnitResult(BuildResultCode resultCode)
 
         private static ProjectItemInstance.TaskItem CreateTaskItem(ITaskItem2 taskItemInterface)
         {
-            var taskItem = new ProjectItemInstance.TaskItem(taskItemInterface.EvaluatedIncludeEscaped, null);
-
-            foreach (string metadataName in taskItemInterface.MetadataNames)
-            {
-                taskItem.SetMetadata(metadataName, taskItemInterface.GetMetadataValueEscaped(metadataName));
-            }
-
+            var taskItem = new ProjectItemInstance.TaskItem(taskItemInterface.EvaluatedIncludeEscaped, definingFileEscaped: null);
+            taskItemInterface.CopyMetadataTo(taskItem);
             return taskItem;
         }
     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 924b3abb698..8679287cd8a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -961,11 +961,15 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     && !taskResult // and it returned false
                     && !taskLoggingContext.HasLoggedErrors // and it didn't log any errors
                     && (be is TaskHost th ? th.BuildRequestsSucceeded : false)
-                    && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true) // and it's not allowed to fail unless it logs an error
                     && !(_cancellationToken.CanBeCanceled && _cancellationToken.IsCancellationRequested)) // and it wasn't cancelled
                 {
                     // Then decide how to log MSB4181
-                    if (_continueOnError == ContinueOnError.WarnAndContinue)
+                    if (be is IBuildEngine7 be7 && be7.AllowFailureWithoutError)
+                    {
+                        // If it's allowed to fail without error, log as a message
+                        taskLoggingContext.LogComment(MessageImportance.Normal, "TaskReturnedFalseButDidNotLogError", _taskNode.Name);
+                    }
+                    else if (_continueOnError == ContinueOnError.WarnAndContinue)
                     {
                         taskLoggingContext.LogWarning(null,
                             new BuildEventFileInfo(_targetChildInstance.Location),
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 2b55265cd9a..4ee0c78cae4 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -123,9 +123,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
             _continueOnError = false;
             _activeProxy = true;
             _callbackMonitor = new object();
-            _disableInprocNode = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? Traits.Instance.InProcNodeDisabled || host.BuildParameters.DisableInProcNode
-                : Traits.Instance.InProcNodeDisabled;
+            _disableInprocNode = Traits.Instance.InProcNodeDisabled || host.BuildParameters.DisableInProcNode;
             EngineServices = new EngineServicesImpl(this);
         }
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 44f487998b8..de7bd580e4a 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -144,9 +144,7 @@ internal class Scheduler : IScheduler
         /// Flag used for debugging by forcing all scheduling to go out-of-proc.
         /// </summary>
         internal bool ForceAffinityOutOfProc
-            => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? Traits.Instance.InProcNodeDisabled || _componentHost.BuildParameters.DisableInProcNode
-                : Traits.Instance.InProcNodeDisabled;
+            => Traits.Instance.InProcNodeDisabled || _componentHost.BuildParameters.DisableInProcNode;
 
         /// <summary>
         /// The path into which debug files will be written.
@@ -183,9 +181,7 @@ public Scheduler()
         {
             // Be careful moving these to Traits, changing the timing of reading environment variables has a breaking potential.
             _debugDumpState = Traits.Instance.DebugScheduler;
-            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? DebugUtils.DebugPath
-                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            _debugDumpPath = DebugUtils.DebugPath;
             _schedulingUnlimitedVariable = Environment.GetEnvironmentVariable("MSBUILDSCHEDULINGUNLIMITED");
             _nodeLimitOffset = 0;
 
@@ -228,7 +224,7 @@ public Scheduler()
 
             if (String.IsNullOrEmpty(_debugDumpPath))
             {
-                _debugDumpPath = Path.GetTempPath();
+                _debugDumpPath = FileUtilities.TempFileDirectory;
             }
 
             Reset();
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 2901298ed0a..18297977aaa 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -361,6 +361,10 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)
             Thread.CurrentThread.CurrentCulture = command.Culture;
             Thread.CurrentThread.CurrentUICulture = command.UICulture;
 
+            // Reconfigure static BuildParameters.StartupDirectory to have this value
+            // same as startup directory of msbuild entry client or dotnet CLI.
+            BuildParameters.StartupDirectory = command.StartupDirectory;
+
             // Configure console configuration so Loggers can change their behavior based on Target (client) Console properties.
             ConsoleConfiguration.Provider = command.ConsoleConfiguration;
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 254d11158b4..0ba22cdf4e7 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -56,7 +56,7 @@ public class Project : ILinkableObject
         /// <summary>
         /// * and ? are invalid file name characters, but they occur in globs as wild cards.
         /// </summary>
-        private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c!= '/' && c != '\\' && c != ':').ToArray();
+        private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c != '/' && c != '\\' && c != ':').ToArray();
 
         /// <summary>
         /// Context to log messages and events in.
@@ -2782,12 +2782,13 @@ private List<ProvenanceResult> GetItemProvenance(string itemToMatch, IEnumerable
                     return new List<ProvenanceResult>();
                 }
 
-                return
-                    projectItemElements
+                return projectItemElements
                     .AsParallel()
-                    .AsOrdered()
-                    .Select(i => ComputeProvenanceResult(itemToMatch, i))
-                    .Where(r => r != null)
+                    .Select((item, index) => (Result: ComputeProvenanceResult(itemToMatch, item), Index: index))
+                    .Where(pair => pair.Result != null)
+                    .AsSequential()
+                    .OrderBy(pair => pair.Index)
+                    .Select(pair => pair.Result)
                     .ToList();
             }
 
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 8d8f3251768..caae6ee03a0 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -262,14 +262,7 @@ private Dictionary<string, ProjectImportPathMatch> ComputeDistinctListOfSearchPa
         /// </summary>
         private static Configuration ReadApplicationConfiguration()
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                return s_configurationCache.Value;
-            }
-            else
-            {
-                return ReadOpenMappedExeConfiguration();
-            }
+            return s_configurationCache.Value;
         }
 
         private static Configuration ReadOpenMappedExeConfiguration()
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
index ee61fc8fd4d..92d0f42062e 100644
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ b/src/Build/Evaluation/ProjectStringCache.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -84,6 +85,13 @@ internal int DocumentCount
         /// </summary>
         public string Add(string key, XmlDocument document)
         {
+            // Remove string interning in ChangeWave 17.6
+            // Note: When ready to remove the ChangeWaves under 17.6, please delete this entire class and all references to it. (See the PR https://github.com/dotnet/msbuild/pull/7952).
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+            {
+                return key;
+            }
+
             if (key.Length == 0)
             {
                 return String.Empty;
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index ce624d60323..d9843d908e9 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -212,16 +212,10 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                         RegexOptions regexOptions = FileMatcher.DefaultRegexOptions;
                         // compile the regex since it's expected to be used multiple times
                         // For the kind of regexes used here, compilation on .NET Framework tends to be expensive and not worth the small
-                        // run-time boost so it's enabled only on .NET Core by default.
+                        // run-time boost so it's enabled only on .NET Core.
 #if RUNTIME_TYPE_NETCORE
-                        bool compileRegex = true;
-#else
-                        bool compileRegex = !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);
+                        regexOptions |= RegexOptions.Compiled;
 #endif
-                        if (compileRegex)
-                        {
-                            regexOptions |= RegexOptions.Compiled;
-                        }
                         Regex newRegex = new Regex(matchFileExpression, regexOptions);
                         lock (s_regexCache)
                         {
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index e8a6624faf2..b64b17cee58 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -588,9 +588,8 @@ private static IReadOnlyCollection<ProjectGraphNode> TopologicalSort(
         ///     This method uses the ProjectReferenceTargets items to determine the targets to run per node. The results can then
         ///     be used to start building each project individually, assuming a given project is built after its references.
         /// </remarks>
-        /// <param name="entryProjectTargets">
-        ///     The target list for the <see cref="GraphRoots" />. May be null or empty, in which case the entry projects' default
-        ///     targets will be used.
+        /// <param name="entryProjectTargets">The target list for the entry project. May be null or empty, in which case the entry
+        /// projects' default targets will be used.
         /// </param>
         /// <returns>
         ///     A dictionary containing the target list for each node. If a node's target list is empty, then no targets were
@@ -606,8 +605,7 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();
             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();
 
-            // Initial state for the graph roots
-            foreach (var entryPointNode in GraphRoots)
+            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
             {
                 var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0
                     ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 3d184b648f1..62d277bbdb2 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1364,50 +1364,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
             lock (_lockObject)
             {
                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;
-
-                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-                {
-                    // The string may contain new lines, treat each new line as a different string to format and send to the console
-                    string[] nonNullMessages = SplitStringOnNewLines(message);
-                    for (int i = 0; i < nonNullMessages.Length; i++)
-                    {
-                        string nonNullMessage = nonNullMessages[i];
-                        // Take into account the new line char which will be added to the end or each reformatted string
-                        int bufferWidthMinusNewLine = _bufferWidth - 1;
-
-                        // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. 
-                        // If there is not enough room just print the message out and let the console do the formatting
-                        bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;
-                        bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;
-                        if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)
-                        {
-                            // Our message may have embedded tab characters, so expand those to their space
-                            // equivalent so that wrapping works as expected.
-                            nonNullMessage = nonNullMessage.Replace("\t", consoleTab);
-
-                            // If the message and the prefix are too large for one line in the console, split the string to fit
-                            int index = 0;
-                            int messageLength = nonNullMessage.Length;
-                            // Loop until all the string has been sent to the console
-                            while (index < messageLength)
-                            {
-                                // Calculate how many chars will fit on the console buffer
-                                int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
-                                WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);
-                                index += amountToCopy;
-                            }
-                        }
-                        else
-                        {
-                            // there is not enough room just print the message out and let the console do the formatting
-                            WriteBasedOnPrefix(nonNullMessage, prefixAlreadyWritten, adjustedPrefixWidth);
-                        }
-                    }
-                }
-                else
-                {
-                    WriteHandler(_consoleOutputAligner.AlignConsoleOutput(message, prefixAlreadyWritten, adjustedPrefixWidth));
-                }
+                WriteHandler(_consoleOutputAligner.AlignConsoleOutput(message, prefixAlreadyWritten, adjustedPrefixWidth));
             }
         }
 
@@ -1793,7 +1750,6 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
         private bool _forceNoAlign;
         private bool _showEventId;
         // According to the documentation for ENABLE_PROCESSED_OUTPUT tab width for the console is 8 characters
-        private const string consoleTab = "        ";
         #endregion
 
         #region Per-build Members
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index 052add40c0a..dd665af000e 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -22,9 +22,11 @@ namespace Microsoft.Build.Utilities
     ///
     /// Treats unspecified components as 0 (e.g. x == x.0 == x.0.0 == x.0.0.0).
     ///
-    /// Unlike System.Version, does not tolerate whitespace, and '+' is ignored as
-    /// semver metadata as described above, not tolerated as positive sign of integer
-    /// component.
+    /// Ignores leading and trailing whitespace, but does not tolerate whitespace
+    /// between components, unlike System.Version.
+    /// 
+    /// Also unlike System.Version, '+' is ignored as semver metadata as described
+    /// above, not tolerated as positive sign of integer component.
     /// </summary>
     /// <remarks>
     /// Tolerating leading 'v' allows using $(TargetFrameworkVersion) directly.
@@ -127,22 +129,23 @@ public static SimpleVersion Parse(string input)
 
         private static ReadOnlySpan<char> RemoveTrivia(string input)
         {
-            int startIndex = 0;
-            int endIndex = input.Length;
+            // Ignore leading/trailing whitespace in input.
+            ReadOnlySpan<char> span = input.AsSpan().Trim();
 
-            if (input.Length > 0 && (input[0] == 'v' || input[0] == 'V'))
+            // Ignore a leading "v".
+            if (span.Length > 0 && (span[0] == 'v' || span[0] == 'V'))
             {
-                startIndex = 1;
+                span = span.Slice(1);
             }
 
-            int separatorIndex = input.IndexOfAny(s_semverSeparators, startIndex);
-
+            // Ignore semver separator and anything after.
+            int separatorIndex = span.IndexOfAny(s_semverSeparators);
             if (separatorIndex >= 0)
             {
-                endIndex = separatorIndex;
+                span = span.Slice(0, separatorIndex);
             }
 
-            return input.AsSpan().Slice(startIndex, endIndex - startIndex);
+            return span;
         }
 
         private static bool ParseComponent(ref ReadOnlySpan<char> span, out int value)
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index ee0ec04823f..e3020e9de14 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -81,7 +81,7 @@
   </PropertyGroup>
 
   <!-- Produce ONLY reference assemblies and SKIP roslyn analyzers for netstandard2.0 builds. -->
-  <PropertyGroup Condition="'$(TargetFramework)' == 'netstandard2.0' and '$(MSBuildProjectFile)' != 'PortableTask.csproj'">
+  <PropertyGroup Condition="'$(TargetFramework)' == 'netstandard2.0' and '$(MSBuildProjectFile)' != 'PortableTask.csproj' and '$(MSBuildProjectFile)' != 'StringTools.csproj'">
     <!-- ProduceOnlyReferenceAssembly and ProduceReferenceAssembly are mutually exclusive compiler flags. -->
     <ProduceOnlyReferenceAssembly>true</ProduceOnlyReferenceAssembly>
     <ProduceReferenceAssembly>false</ProduceReferenceAssembly>
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index deff3e26750..91acdc9bc59 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -24,10 +24,10 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves-Dev.md
     internal class ChangeWaves
     {
-        internal static readonly Version Wave17_0 = new Version(17, 0);
         internal static readonly Version Wave17_2 = new Version(17, 2);
         internal static readonly Version Wave17_4 = new Version(17, 4);
-        internal static readonly Version[] AllWaves = { Wave17_0, Wave17_2, Wave17_4 };
+        internal static readonly Version Wave17_6 = new Version(17, 6);
+        internal static readonly Version[] AllWaves = { Wave17_2, Wave17_4, Wave17_6 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index be193fff3ed..daaf0387950 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -648,6 +648,7 @@ internal static bool IsUnixLike
     /// <summary>
     /// Gets a flag indicating if we are running under Linux
     /// </summary>
+    [SupportedOSPlatformGuard("linux")]
     internal static bool IsLinux
     {
 #if CLR2COMPATIBILITY
@@ -1047,7 +1048,7 @@ internal static MemoryStatus GetMemoryStatus()
     internal static DateTime GetLastWriteFileUtcTime(string fullPath)
     {
 #if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-        if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+        if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)
         {
             return LastWriteFileUtcTime(fullPath);
         }
@@ -1463,9 +1464,16 @@ internal static void VerifyThrowWin32Result(int result)
         }
     }
 
-#endregion
+    #endregion
+
+    #region PInvoke
+    [SupportedOSPlatform("linux")]
+    [DllImport("libc", SetLastError = true)]
+    internal static extern int chmod(string pathname, int mode);
 
-#region PInvoke
+    [SupportedOSPlatform("linux")]
+    [DllImport("libc", SetLastError = true)]
+    internal static extern int mkdir(string path, int mode);
 
     /// <summary>
     /// Gets the current OEM code page which is used by console apps
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index 44e1b3a9c67..e211fc36115 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -281,6 +281,44 @@ public void ServerShouldNotStartWhenBuildIsInteractive()
             pidOfInitialProcess.ShouldBe(pidOfServerProcess, "We started a server node even when build is interactive.");
         }
 
+        [Fact]
+        public void PropertyMSBuildStartupDirectoryOnServer()
+        {
+            string reportMSBuildStartupDirectoryProperty = @$"
+<Project>
+    <UsingTask TaskName=""ProcessIdTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
+	<Target Name=""DisplayMessages"">
+        <ProcessIdTask>
+            <Output PropertyName=""PID"" TaskParameter=""Pid"" />
+        </ProcessIdTask>
+        <Message Text=""Server ID is $(PID)"" Importance=""High"" />
+		<Message Text="":MSBuildStartupDirectory:$(MSBuildStartupDirectory):"" Importance=""high"" />
+	</Target> 
+</Project>";
+
+            TransientTestFile project = _env.CreateFile("testProject.proj", reportMSBuildStartupDirectoryProperty);
+            _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+
+            // Start on current working directory
+            string output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, $"/t:DisplayMessages {project.Path}", out bool success, false, _output);
+            success.ShouldBeTrue();
+            int pidOfServerProcess = ParseNumber(output, "Server ID is ");
+            _env.WithTransientProcess(pidOfServerProcess);
+            output.ShouldContain($@":MSBuildStartupDirectory:{Environment.CurrentDirectory}:");
+
+            // Start on transient project directory
+            _env.SetCurrentDirectory(Path.GetDirectoryName(project.Path));
+            output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, $"/t:DisplayMessages {project.Path}", out success, false, _output);
+            int pidOfNewServerProcess = ParseNumber(output, "Server ID is ");
+            if (pidOfServerProcess != pidOfNewServerProcess)
+            {
+                // Register process to clean up (be killed) after tests ends.
+                _env.WithTransientProcess(pidOfNewServerProcess);
+            }
+            pidOfNewServerProcess.ShouldBe(pidOfServerProcess);
+            output.ShouldContain($@":MSBuildStartupDirectory:{Environment.CurrentDirectory}:");
+        }
+
         private int ParseNumber(string searchString, string toFind)
         {
             Regex regex = new(@$"{toFind}(\d+)");
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 2fd51da537c..0ef742fdc22 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -241,8 +241,10 @@
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
   </ItemGroup>
 
+  <!-- Xsds are not TF or arch-specific so copy once them in the outer build -->
   <Target Name="CopyXsds"
-          BeforeTargets="AfterBuild">
+          BeforeTargets="Build"
+          Condition="'$(IsInnerBuild)' != 'true'">
     <Copy SourceFiles="@(XsdsForVS)"
           DestinationFiles="@(XsdsForVS->'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')"
           SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 9ec5f525074..629d9141a93 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -792,7 +792,7 @@ private NodeEngineShutdownReason HandleShutdown()
 
             if (_debugCommunications)
             {
-                using (StreamWriter writer = File.CreateText(String.Format(CultureInfo.CurrentCulture, Path.Combine(Path.GetTempPath(), @"MSBuild_NodeShutdown_{0}.txt"), Process.GetCurrentProcess().Id)))
+                using (StreamWriter writer = File.CreateText(String.Format(CultureInfo.CurrentCulture, Path.Combine(FileUtilities.TempFileDirectory, @"MSBuild_NodeShutdown_{0}.txt"), Process.GetCurrentProcess().Id)))
                 {
                     writer.WriteLine("Node shutting down with reason {0}.", _shutdownReason);
                 }
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index f001f9d07ca..9e4f47ac424 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -6,6 +6,7 @@ package name=Microsoft.Build.Arm64
         vs.package.language=neutral
 
 vs.relatedProcessFiles
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\arm64\Microsoft.Build.dll"
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\arm64\Microsoft.Build.Tasks.Core.dll"
 
 folder InstallDir:\MSBuild\Current\Bin\arm64
@@ -13,6 +14,7 @@ folder InstallDir:\MSBuild\Current\Bin\arm64
   file source=$(Arm64BinPath)MSBuild.exe.config
 
   file source=$(FrameworkBinPath)x64\Microsoft.Build.Framework.tlb
+  file source=$(Arm64BinPath)Microsoft.Build.dll vs.file.ngenArchitecture=arm64
   file source=$(Arm64BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=arm64
   file source=$(Arm64BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(Arm64BinPath)Microsoft.Common.CrossTargeting.targets
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index f8106579fb7..8f4916ab502 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -686,14 +686,12 @@ internal static void Trace(int nodeId, string format, params object[] args)
 #if CLR2COMPATIBILITY
                         Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
-                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                            ? DebugUtils.DebugPath
-                            : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                        DebugUtils.DebugPath;
 #endif
 
                         if (String.IsNullOrEmpty(s_debugDumpPath))
                         {
-                            s_debugDumpPath = Path.GetTempPath();
+                            s_debugDumpPath = FileUtilities.TempFileDirectory;
                         }
                         else
                         {
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
index 74a3a7b9e79..3ae6cf16891 100644
--- a/src/Shared/Debugging/DebugUtils.cs
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -38,7 +38,7 @@ static DebugUtils()
                 }
                 else
                 {
-                    debugDirectory = Path.Combine(Path.GetTempPath(), "MSBuild_Logs");
+                    debugDirectory = Path.Combine(FileUtilities.TempFileDirectory, "MSBuild_Logs");
                 }
 
                 // Out of proc nodes do not know the startup directory so set the environment variable for them.
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index 2d91a466fbf..8752511e6b8 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -47,14 +47,12 @@ private static string GetDebugDumpPath()
 #if CLR2COMPATIBILITY || MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
                         Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
-                ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                    ? DebugUtils.DebugPath
-                    : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                DebugUtils.DebugPath;
 #endif
 
             return !string.IsNullOrEmpty(debugPath)
                     ? debugPath
-                    : Path.GetTempPath();
+                    : FileUtilities.TempFileDirectory;
         }
 
         /// <summary>
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 894249cbd64..6edc65786a8 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -24,7 +24,7 @@ private static bool ShouldUseMicrosoftIO
             get
             {
 #if !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-                return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0) && NativeMethodsShared.IsWindows;
+                return NativeMethodsShared.IsWindows;
 #else
                 // We need to mock usage of ChangeWaves class,
                 // because Microsoft.Build.Engine.OM.UnitTests should not have access to internals of Microsoft.Build.Framework.
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 175360edf93..63025199472 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -45,6 +45,10 @@ internal static partial class FileUtilities
         /// </summary>
         internal static string cacheDirectory = null;
 
+#if CLR2COMPATIBILITY
+        internal static string TempFileDirectory => Path.GetTempPath();
+#endif
+
         /// <summary>
         /// FOR UNIT TESTS ONLY
         /// Clear out the static variable used for the cache directory so that tests that
@@ -124,7 +128,7 @@ internal static string GetCacheDirectory()
         {
             if (cacheDirectory == null)
             {
-                cacheDirectory = Path.Combine(Path.GetTempPath(), String.Format(CultureInfo.CurrentUICulture, "MSBuild{0}-{1}", Process.GetCurrentProcess().Id, AppDomain.CurrentDomain.Id));
+                cacheDirectory = Path.Combine(TempFileDirectory, String.Format(CultureInfo.CurrentUICulture, "MSBuild{0}-{1}", Process.GetCurrentProcess().Id, AppDomain.CurrentDomain.Id));
             }
 
             return cacheDirectory;
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index dfc76317e84..4927b87103d 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -30,7 +30,13 @@ internal static string GetPlatformSpecificPipeName(string pipeName)
                 // can be quite long, leaving very little room for the actual pipe name. Fortunately,
                 // '/tmp' is mandated by POSIX to always be a valid temp directory, so we can use that
                 // instead.
+#if !CLR2COMPATIBILITY
                 return Path.Combine("/tmp", pipeName);
+#else
+                // We should never get here. This would be a net35 task host running on unix.
+                ErrorUtilities.ThrowInternalError("Task host used on unix in retrieving the pipe name.");
+                return string.Empty;
+#endif
             }
             else
             {
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 4c5a3357063..aefd4aaebb2 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -232,7 +232,11 @@ internal void InternalConstruct(string pipeName = null)
                     PipeDirection.InOut,
                     1, // Only allow one connection at a time.
                     PipeTransmissionMode.Byte,
-                    PipeOptions.Asynchronous | PipeOptions.WriteThrough,
+                    PipeOptions.Asynchronous | PipeOptions.WriteThrough
+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                    | PipeOptions.CurrentUserOnly
+#endif
+                    ,
                     PipeBufferSize, // Default input buffer
                     PipeBufferSize,  // Default output buffer
                     security,
@@ -248,7 +252,11 @@ internal void InternalConstruct(string pipeName = null)
                     PipeDirection.InOut,
                     1, // Only allow one connection at a time.
                     PipeTransmissionMode.Byte,
-                    PipeOptions.Asynchronous | PipeOptions.WriteThrough,
+                    PipeOptions.Asynchronous | PipeOptions.WriteThrough
+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                    | PipeOptions.CurrentUserOnly
+#endif
+                    ,
                     PipeBufferSize, // Default input buffer
                     PipeBufferSize  // Default output buffer
                 );
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index d8102f69f4e..0e0e2913faf 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -77,6 +77,13 @@ internal static string GetNearestPlatform(string referencedProjectPlatform, stri
                     // Platform/PlatformTarget when this is the case.
                     log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
                 }
+                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
+                // If we're about to tell the reference to build using its default platform, don't pass it as a global property.
+                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(buildProjectReferenceAs, StringComparison.OrdinalIgnoreCase))
+                {
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
+                    buildProjectReferenceAs = string.Empty;
+                }
             return buildProjectReferenceAs;
         }
         internal static Dictionary<string, string>? ExtractLookupTable(string stringTable, TaskLoggingHelper? log = null)
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index f3bffb9d425..c0583acb483 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -16,6 +16,57 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal static partial class FileUtilities
     {
+        // For the current user, these correspond to read, write, and execute permissions.
+        // Lower order bits correspond to the same for "group" or "other" users.
+        private const int userRWX = 0x100 | 0x80 | 0x40;
+        private static string tempFileDirectory = null;
+        internal static string TempFileDirectory
+        {
+            get
+            {
+                return tempFileDirectory ??= CreateFolderUnderTemp();
+            }
+        }
+
+        internal static void ClearTempFileDirectory()
+        {
+            tempFileDirectory = null;
+        }
+
+        // For all native calls, directly check their return values to prevent bad actors from getting in between checking if a directory exists and returning it.
+        private static string CreateFolderUnderTemp()
+        {
+            string basePath = Path.Combine(Path.GetTempPath(), $"MSBuildTemp{Environment.UserName}");
+
+            if (NativeMethodsShared.IsLinux && NativeMethodsShared.mkdir(basePath, userRWX) != 0)
+            {
+                if (NativeMethodsShared.chmod(basePath, userRWX) == 0)
+                {
+                    // Current user owns this file; we can read and write to it. It is reasonable here to assume it was created properly by MSBuild and can be used
+                    // for temporary files.
+                }
+                else
+                {
+                    // Another user created a folder pretending to be us! Find a folder we can actually use.
+                    int extraBits = 0;
+                    string pathToCheck = basePath + extraBits;
+                    while (NativeMethodsShared.mkdir(pathToCheck, userRWX) != 0 && NativeMethodsShared.chmod(pathToCheck, userRWX) != 0)
+                    {
+                        extraBits++;
+                        pathToCheck = basePath + extraBits;
+                    }
+
+                    basePath = pathToCheck;
+                }
+            }
+            else
+            {
+                Directory.CreateDirectory(basePath);
+            }
+
+            return FileUtilities.EnsureTrailingSlash(basePath);
+        }
+
         /// <summary>
         /// Generates a unique directory name in the temporary folder.
         /// Caller must delete when finished.
@@ -24,7 +75,7 @@ internal static partial class FileUtilities
         /// <param name="subfolder"></param>
         internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)
         {
-            string temporaryDirectory = Path.Combine(Path.GetTempPath(), "Temporary" + Guid.NewGuid().ToString("N"), subfolder ?? string.Empty);
+            string temporaryDirectory = Path.Combine(TempFileDirectory, "Temporary" + Guid.NewGuid().ToString("N"), subfolder ?? string.Empty);
 
             if (createDirectory)
             {
@@ -43,7 +94,7 @@ internal static string GetTemporaryDirectory(bool createDirectory = true, string
         /// </summary>
         internal static string GetTemporaryFileName(string extension)
         {
-            return GetTemporaryFile(null, extension, false);
+            return GetTemporaryFile(null, null, extension, false);
         }
 
         /// <summary>
@@ -57,6 +108,16 @@ internal static string GetTemporaryFile()
             return GetTemporaryFile(".tmp");
         }
 
+        /// <summary>
+        /// Generates a unique temporary file name with a given extension in the temporary folder.
+        /// File is guaranteed to be unique.
+        /// Caller must delete it when finished.
+        /// </summary>
+        internal static string GetTemporaryFile(string fileName, string extension, bool createFile)
+        {
+            return GetTemporaryFile(null, fileName, extension, createFile);
+        }
+
         /// <summary>
         /// Generates a unique temporary file name with a given extension in the temporary folder.
         /// File is guaranteed to be unique.
@@ -66,7 +127,7 @@ internal static string GetTemporaryFile()
         /// </summary>
         internal static string GetTemporaryFile(string extension)
         {
-            return GetTemporaryFile(null, extension);
+            return GetTemporaryFile(null, null, extension);
         }
 
         /// <summary>
@@ -77,23 +138,33 @@ internal static string GetTemporaryFile(string extension)
         /// Caller must delete it when finished.
         /// May throw IOException.
         /// </summary>
-        internal static string GetTemporaryFile(string directory, string extension, bool createFile = true)
+        internal static string GetTemporaryFile(string directory, string fileName, string extension, bool createFile = true)
         {
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(directory, nameof(directory));
-            ErrorUtilities.VerifyThrowArgumentLength(extension, nameof(extension));
-
-            if (extension[0] != '.')
-            {
-                extension = '.' + extension;
-            }
 
             try
             {
-                directory ??= Path.GetTempPath();
+                directory ??= TempFileDirectory;
+
+                // If the extension needs a dot prepended, do so.
+                if (extension is null)
+                {
+                    extension = string.Empty;
+                }
+                else if (extension.Length > 0 && extension[0] != '.')
+                {
+                    extension = '.' + extension;
+                }
+
+                // If the fileName is null, use tmp{Guid}; otherwise use fileName.
+                if (string.IsNullOrEmpty(fileName))
+                {
+                    fileName = $"tmp{Guid.NewGuid():N}";
+                }
 
                 Directory.CreateDirectory(directory);
 
-                string file = Path.Combine(directory, $"tmp{Guid.NewGuid():N}{extension}");
+                string file = Path.Combine(directory, $"{fileName}{extension}");
 
                 ErrorUtilities.VerifyThrow(!FileSystems.Default.FileExists(file), "Guid should be unique");
 
@@ -131,11 +202,15 @@ public class TempWorkingDirectory : IDisposable
         {
             public string Path { get; }
 
-            public TempWorkingDirectory(string sourcePath, [CallerMemberName] string name = null)
+            public TempWorkingDirectory(string sourcePath,
+#if !CLR2COMPATIBILITY
+                [CallerMemberName]
+#endif
+            string name = null)
             {
                 Path = name == null
                     ? GetTemporaryDirectory()
-                    : System.IO.Path.Combine(System.IO.Path.GetTempPath(), name);
+                    : System.IO.Path.Combine(TempFileDirectory, name);
 
                 if (FileSystems.Default.DirectoryExists(Path))
                 {
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 3e96ab7c6cb..1111b257726 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -31,32 +31,25 @@ internal static class ToolsetConfigurationReaderHelpers
 
         internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Configuration configuration)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+            if (configuration == null)
             {
-                if (configuration == null)
-                {
-                    return null;
-                }
+                return null;
+            }
 
-                lock (s_syncLock)
+            lock (s_syncLock)
+            {
+                // Cache 1st requested configuration section. In unit tests, different Configuration is provided for particular test cases.
+                // During runtime, however, only MSBuild exe configuration file is provided to read toolset configuration from,
+                //   and modifying MSBuild exe configuration during lifetime of msbuild nodes is neither expected nor supported.
+                if (s_toolsetConfigurationSectionCache == null)
                 {
-                    // Cache 1st requested configuration section. In unit tests, different Configuration is provided for particular test cases.
-                    // During runtime, however, only MSBuild exe configuration file is provided to read toolset configuration from,
-                    //   and modifying MSBuild exe configuration during lifetime of msbuild nodes is neither expected nor supported.
-                    if (s_toolsetConfigurationSectionCache == null)
-                    {
-                        s_toolsetConfigurationSectionCache = GetToolsetConfigurationSection(configuration);
-                        s_configurationOfCachedSection = configuration;
-                    }
-
-                    return s_configurationOfCachedSection == configuration ?
-                        s_toolsetConfigurationSectionCache :
-                        GetToolsetConfigurationSection(configuration);
+                    s_toolsetConfigurationSectionCache = GetToolsetConfigurationSection(configuration);
+                    s_configurationOfCachedSection = configuration;
                 }
-            }
-            else
-            {
-                return GetToolsetConfigurationSection(configuration);
+
+                return s_configurationOfCachedSection == configuration ?
+                    s_toolsetConfigurationSectionCache :
+                    GetToolsetConfigurationSection(configuration);
             }
         }
 
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index e29d3e3a89c..7f6d55178ac 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -1268,27 +1268,6 @@ public void IllegalPaths()
             ValidateIllegal("http://www.website.com");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // Nothing's too long for Unix
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
-        public void IllegalTooLongPathOptOutWave17_0()
-        {
-            using (var env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_0.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string longString = new string('X', 500) + "*"; // need a wildcard to do anything
-                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString).FileList;
-
-                Assert.Equal(longString, result[0]); // Does not throw
-                ChangeWaves.ResetStateForTests();
-            }
-            // Not checking that GetFileSpecMatchInfo returns the illegal-path flag,
-            // not certain that won't break something; this fix is merely to avoid a crash.
-        }
-
         [Fact]
         public void SplitFileSpec()
         {
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 3f9c53f3a68..7e87e2217af 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -851,7 +851,7 @@ public void GenerateTempFileNameWithDirectoryAndExtension()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile(directory, ".bat");
+                path = FileUtilities.GetTemporaryFile(directory, null, ".bat");
 
                 Assert.EndsWith(".bat", path);
                 Assert.True(File.Exists(path));
@@ -902,18 +902,6 @@ public void GenerateTempBatchFileWithBadExtension()
            );
         }
         /// <summary>
-        /// No extension is given
-        /// </summary>
-        [Fact]
-        public void GenerateTempBatchFileWithEmptyExtension()
-        {
-            Assert.Throws<ArgumentException>(() =>
-            {
-                FileUtilities.GetTemporaryFile(String.Empty);
-            }
-           );
-        }
-        /// <summary>
         /// Directory is invalid
         /// </summary>
         [Fact]
@@ -924,7 +912,7 @@ public void GenerateTempBatchFileWithBadDirectory()
         {
             Assert.Throws<IOException>(() =>
             {
-                FileUtilities.GetTemporaryFile("|", ".tmp");
+                FileUtilities.GetTemporaryFile("|", null, ".tmp");
             }
            );
         }
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index c97b575d88c..51ea0482d88 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -594,14 +594,14 @@ public TransientTestFile(string extension, bool createFile, bool expectedAsOutpu
         {
             _createFile = createFile;
             _expectedAsOutput = expectedAsOutput;
-            Path = FileUtilities.GetTemporaryFile(null, extension, createFile);
+            Path = FileUtilities.GetTemporaryFile(null, null, extension, createFile);
         }
 
         public TransientTestFile(string rootPath, string extension, bool createFile, bool expectedAsOutput)
         {
             _createFile = createFile;
             _expectedAsOutput = expectedAsOutput;
-            Path = FileUtilities.GetTemporaryFile(rootPath, extension, createFile);
+            Path = FileUtilities.GetTemporaryFile(rootPath, null, extension, createFile);
         }
 
         public TransientTestFile(string rootPath, string fileName, string contents = null)
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index 1dff7e28c37..3f51a4c8233 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -132,7 +132,7 @@ public void TestMergeRuntimeValuesCurrentToCore()
         [Fact]
         public void TestArchitectureValuesMatch()
         {
-            string currentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x64 : XMakeAttributes.MSBuildArchitectureValues.x86;
+            string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
             string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             Assert.True(XMakeAttributes.ArchitectureValuesMatch(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.currentArchitecture));
@@ -147,7 +147,7 @@ public void TestArchitectureValuesMatch()
         [Fact]
         public void TestMergeArchitectureValues()
         {
-            string currentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x64 : XMakeAttributes.MSBuildArchitectureValues.x86;
+            string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
             string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             string mergedArchitecture;
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index e44f8b3b641..2f0f43eb5c7 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -14,13 +14,26 @@
 
     <AssemblyName>Microsoft.NET.StringTools</AssemblyName>
     <PackageDescription>This package contains the $(AssemblyName) assembly which implements common string-related functionality such as weak interning.</PackageDescription>
+    
+    <IncludeBuildOutput Condition="'$(TargetFramework)' == 'net35'">false</IncludeBuildOutput>
+    <!-- Don't publish the reference assembly if the build output isn't included. -->
+    <TargetsForTfmSpecificBuildOutput Condition="'$(IncludeBuildOutput)' == 'false'" />
+    <!-- NU5128: Add lib or ref assemblies for the net35 target framework. -->
+    <NoWarn>$(NoWarn);NU5128</NoWarn>
+  </PropertyGroup>
+
+  <PropertyGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
+    <!-- Place the netstandard2.0 ref assembly to /ref instead of /lib to work around a NuGet pack misbehavior. -->
+    <!-- Without this customization both the ref and implementation assembly would go to /lib, creating a conflict. -->
+    <TargetsForTfmSpecificBuildOutput />
+    <TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);PackRefAssembly</TargetsForTfmSpecificContentInPackage>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(TargetFramework)' == 'net35'">
     <AssemblyName>Microsoft.NET.StringTools.net35</AssemblyName>
   </PropertyGroup>
 
-  <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
+  <ItemGroup Condition="'$(TargetFramework)' != 'net35' AND '$(TargetFrameworkIdentifier)' != '.NETCoreApp'">
     <PackageReference Include="System.Memory" />
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
   </ItemGroup>
@@ -35,4 +48,10 @@
     <Compile Remove="InternableString.Simple.cs" />
     <Compile Remove="WeakStringCache.Locking.cs" />
   </ItemGroup>
+
+  <Target Name="PackRefAssembly">
+      <ItemGroup>
+        <TfmSpecificPackageFile Include="$(TargetRefPath);@(FinalDocFile)" PackagePath="ref/$(TargetFramework)" />
+      </ItemGroup>
+  </Target>
 </Project>
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 12705101c88..c2d3c0925a1 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -537,8 +537,8 @@ public void DoCopyOverCopiedFile(bool skipUnchangedFiles)
         {
             using (var env = TestEnvironment.Create())
             {
-                var sourceFile = FileUtilities.GetTemporaryFile(env.DefaultTestDirectory.Path, "src", false);
-                var destinationFile = FileUtilities.GetTemporaryFile(env.DefaultTestDirectory.Path, "dst", false);
+                var sourceFile = FileUtilities.GetTemporaryFile(env.DefaultTestDirectory.Path, null, "src", false);
+                var destinationFile = FileUtilities.GetTemporaryFile(env.DefaultTestDirectory.Path, null, "dst", false);
 
                 File.WriteAllText(sourceFile, "This is a source temp file.");
 
@@ -2397,77 +2397,63 @@ public CopySymbolicLink_Tests(ITestOutputHelper testOutputHelper)
         [Fact]
         public void CopyToDestinationFolderWithSymbolicLinkCheck()
         {
-            var isPrivileged = true;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                if (!new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(new SecurityIdentifier(WellKnownSidType.BuiltinAdministratorsSid, null)))
-                {
-                    isPrivileged = false;
-                    Assert.True(true, "It seems that you don't have the permission to create symbolic links. Try to run this test again with higher privileges");
-                }
-            }
-
-            if (isPrivileged)
+            string sourceFile = FileUtilities.GetTemporaryFile();
+            string temp = Path.GetTempPath();
+            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
+            string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
+            try
             {
-                string sourceFile = FileUtilities.GetTemporaryFile();
-                string temp = Path.GetTempPath();
-                string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
-                string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
-                try
-                {
-                    File.WriteAllText(sourceFile, "This is a source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
-
-                    // Don't create the dest folder, let task do that
+                File.WriteAllText(sourceFile, "This is a source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
 
-                    ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                // Don't create the dest folder, let task do that
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
 
-                    var me = new MockEngine(true);
-                    var t = new Copy
-                    {
-                        RetryDelayMilliseconds = 1,  // speed up tests!
-                        BuildEngine = me,
-                        SourceFiles = sourceFiles,
-                        DestinationFolder = new TaskItem(destFolder),
-                        SkipUnchangedFiles = true,
-                        UseSymboliclinksIfPossible = true
-                    };
+                var me = new MockEngine(true);
+                var t = new Copy
+                {
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = me,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destFolder),
+                    SkipUnchangedFiles = true,
+                    UseSymboliclinksIfPossible = true
+                };
 
-                    bool success = t.Execute();
+                bool success = t.Execute();
 
-                    Assert.True(success); // "success"
-                    Assert.True(File.Exists(destFile)); // "destination exists"
+                Assert.True(success); // "success"
+                Assert.True(File.Exists(destFile)); // "destination exists"
+                Assert.True((File.GetAttributes(destFile) & FileAttributes.ReparsePoint) != 0, "File was copied but is not a symlink");
 
-                    MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
+                MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
 
-                    me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.SymbolicLinkComment", sourceFile, destFile);
+                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.SymbolicLinkComment", sourceFile, destFile);
 
-                    string destinationFileContents = File.ReadAllText(destFile);
-                    Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination symbolic linked file to contain the contents of source file."
+                string destinationFileContents = File.ReadAllText(destFile);
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination symbolic linked file to contain the contents of source file."
 
-                    Assert.Single(t.DestinationFiles);
-                    Assert.Single(t.CopiedFiles);
-                    Assert.Equal(destFile, t.DestinationFiles[0].ItemSpec);
-                    Assert.Equal(destFile, t.CopiedFiles[0].ItemSpec);
+                Assert.Single(t.DestinationFiles);
+                Assert.Single(t.CopiedFiles);
+                Assert.Equal(destFile, t.DestinationFiles[0].ItemSpec);
+                Assert.Equal(destFile, t.CopiedFiles[0].ItemSpec);
 
-                    // Now we will write new content to the source file
-                    // we'll then check that the destination file automatically
-                    // has the same content (i.e. it's been hard linked)
+                // Now we will write new content to the source file
+                // we'll then check that the destination file automatically
+                // has the same content (i.e. it's been hard linked)
 
-                    File.WriteAllText(sourceFile, "This is another source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
+                File.WriteAllText(sourceFile, "This is another source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
 
-                    // Read the destination file (it should have the same modified content as the source)
-                    destinationFileContents = File.ReadAllText(destFile);
-                    Assert.Equal("This is another source temp file.", destinationFileContents); // "Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
+                // Read the destination file (it should have the same modified content as the source)
+                destinationFileContents = File.ReadAllText(destFile);
+                Assert.Equal("This is another source temp file.", destinationFileContents); // "Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
 
-                    ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3891"); // Didn't do retries
-                }
-                finally
-                {
-                    File.Delete(sourceFile);
-                    File.Delete(destFile);
-                    FileUtilities.DeleteWithoutTrailingBackslash(destFolder, true);
-                }
+                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3891"); // Didn't do retries
+            }
+            finally
+            {
+                File.Delete(sourceFile);
+                File.Delete(destFile);
+                FileUtilities.DeleteWithoutTrailingBackslash(destFolder, true);
             }
         }
 
diff --git a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
index 620cb08680b..d65901d9ccb 100644
--- a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
+++ b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
@@ -84,6 +84,28 @@ public void ResolvesViaAnyCPUDefault()
 
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("AnyCPU");
         }
+        
+        [Fact]
+        public void ResolvesViaAnyCPUDefaultWithDefaultPlatformEnabled()
+        {
+            // No valid mapping via the lookup table, should default to AnyCPU when the current project
+            // and ProjectReference platforms don't match.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;AnyCPU");
+            projectReference.SetMetadata("Platform", "AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "AnyCPU=x64", 
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+        }
 
         [Fact]
         public void ResolvesViaSamePlatform()
@@ -226,5 +248,28 @@ public void PlatformIsChosenAsDefault(string referencedPlatforms, string referen
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
             task.Log.HasLoggedErrors.ShouldBeFalse();
         }
+        
+        // When `Platform` is retrieved in "GetTargetFrameworks" and that platform matches what the task has decided the project should be built as
+        // through negotiation. build that project _without_ a global property for Platform.
+        [Fact]
+        public void ChosenPlatformMatchesDefault()
+        {
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "AnyCPU;x64");
+            projectReference.SetMetadata("Platform", "AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "", // invalid format
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            task.Log.HasLoggedErrors.ShouldBeFalse();
+        }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 4cb1e0d2a63..ccda4006e43 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -409,7 +409,7 @@ internal void AddReference(AssemblyNameExtension assemblyName, Reference referen
                 }
             }
 
-            if (reference.FullPath.Length > 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+            if (reference.FullPath.Length > 0)
             {
                 // Saves effort and makes deduplication possible downstream
                 reference.NormalizeFullPath();
@@ -1340,16 +1340,7 @@ out userRequestedSpecificFile
             // If the path was resolved, then specify the full path on the reference.
             if (resolvedPath != null)
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-                {
-                    resolvedPath = FileUtilities.NormalizePath(resolvedPath);
-                }
-                else if (!Path.IsPathRooted(resolvedPath))
-                {
-                    resolvedPath = Path.GetFullPath(resolvedPath);
-                }
-
-                reference.FullPath = resolvedPath;
+                reference.FullPath = FileUtilities.NormalizePath(resolvedPath);
                 reference.ResolvedSearchPath = resolvedSearchPath;
                 reference.UserRequestedSpecificFile = userRequestedSpecificFile;
             }
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 77c8c929879..e3fd34e9fc6 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -811,19 +811,13 @@ private Assembly CompileInMemoryAssembly()
                 var fullSpec = new FullTaskSpecification(finalReferencedAssemblies, fullCode);
                 if (!s_compiledTaskCache.TryGetValue(fullSpec, out Assembly existingAssembly))
                 {
-                    // Invokes compilation. 
-
-                    // Note: CompileAssemblyFromSource uses Path.GetTempPath() directory, but will not create it. In some cases 
-                    // this will throw inside CompileAssemblyFromSource. To work around this, ensure the temp directory exists. 
-                    // See: https://github.com/dotnet/msbuild/issues/328
-                    Directory.CreateDirectory(Path.GetTempPath());
-
+                    // Invokes compilation.
                     CompilerResults compilerResults = provider.CompileAssemblyFromSource(compilerParameters, fullCode);
 
                     string outputPath = null;
                     if (compilerResults.Errors.Count > 0 || Environment.GetEnvironmentVariable("MSBUILDLOGCODETASKFACTORYOUTPUT") != null)
                     {
-                        string tempDirectory = Path.GetTempPath();
+                        string tempDirectory = FileUtilities.TempFileDirectory;
                         string fileName = Guid.NewGuid().ToString() + ".txt";
                         outputPath = Path.Combine(tempDirectory, fileName);
                         File.WriteAllText(outputPath, fullCode);
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 87e92685ed8..a9e46233824 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -1974,7 +1974,6 @@ private bool NeedSeparateAppDomainBasedOnSerializedType(XmlReader reader)
             // Return true to err on the side of caution. Error will appear later.
             return true;
         }
-#endif
 
         /// <summary>
         /// Deserializes a base64 block from a resx in order to figure out if its type is in the GAC.
@@ -1995,6 +1994,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
                 return result != null;
             }
         }
+#endif
 
         /// <summary>
         /// Chars that should be ignored in the nicely justified block of base64
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 1af05538af3..64afe2300aa 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -81,7 +81,7 @@ public class GetSDKReferenceFiles : TaskExtension
         /// <summary>
         /// Folder where the cache files are written to
         /// </summary>
-        private string _cacheFilePath = Path.GetTempPath();
+        private string _cacheFilePath = FileUtilities.TempFileDirectory;
 
         #region Properties
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index b5938447b1d..69b7c661777 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -5717,7 +5717,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <RemoveDir
         Directories="$(ClickOncePublishDir)"
-        Condition="Exists('$(ClickOncePublishDir)')"/>
+        Condition="'$(ClickOncePublishDir)'=='$(OutputPath)app.publish\' and Exists('$(ClickOncePublishDir)')"/>
 
   </Target>
 
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 7ea9782cedb..0d789b07af4 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -517,7 +517,8 @@ internal struct PROCESS_INFORMATION
     internal enum SymbolicLink
     {
         File = 0,
-        Directory = 1
+        Directory = 1,
+        AllowUnprivilegedCreate = 2,
     }
 
     /// <summary>
@@ -833,7 +834,14 @@ internal static bool MakeSymbolicLink(string newFileName, string exitingFileName
             bool symbolicLinkCreated;
             if (NativeMethodsShared.IsWindows)
             {
-                symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, SymbolicLink.File);
+                Version osVersion = Environment.OSVersion.Version;
+                SymbolicLink flags = SymbolicLink.File;
+                if (osVersion.Major >= 11 || (osVersion.Major == 10 && osVersion.Build >= 14972))
+                {
+                    flags |= SymbolicLink.AllowUnprivilegedCreate;
+                }
+
+                symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, flags);
                 errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
             }
             else
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index a128fd658e2..9122233026b 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2832,6 +2832,9 @@
   <data name="Unzip.DidNotUnzipBecauseOfFilter">
     <value>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</value>
   </data>
+  <data name="Unzip.ZipSlipExploit">
+    <value>Entry is outside the target directory: "{0}"</value>
+  </data>
   <data name="Unzip.FileComment">
     <value>Unzipping file "{0}" to "{1}".</value>
   </data>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 8814629bec1..5743aba8243 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">Soubor {0} se rozzipovává do {1}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: {1} je neplatná hodnota parametru {0}.  Platné hodnoty jsou : {2}.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 34a490ed1d1..598e1c3242c 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">Die Datei "{0}" wird in "{1}" entzippt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" ist ein ungültiger Wert für den Parameter "{0}". Gültige Werte sind: {2}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index f8474cd8820..c03523f1d9f 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">Descomprimiendo el archivo "{0}" en "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" no es un valor válido para el parámetro "{0}".  Los valores válidos son: {2}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index fb4965cc9e3..392d4604e5c 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">Décompression du fichier "{0}" dans "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" n'est pas une valeur valide pour le paramètre "{0}". Les valeurs valides sont : {2}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index a00f3a2e2de..a0968718b66 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">Decompressione del file "{0}" in "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" è un valore non valido per il parametro "{0}". I valori validi sono: {2}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index b4dd3d4c9e0..69d151699f4 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">ファイル "{0}" を "{1}" に解凍しています。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" は "{0}" パラメーターに対して無効な値です。有効な値は {2} です。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 90b1ad0ff3b..7a9db6e2f9e 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">파일 "{0}"의 압축을 "{1}"에 푸는 중입니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}"은(는) "{0}" 매개 변수에 사용할 수 없는 값입니다.  유효한 값은 {2}입니다.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 57e040f6e97..349c4e416b2 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">Rozpakowywanie pliku „{0}” do pliku „{1}”.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: „{1}” jest nieprawidłową wartością parametru „{0}”.  Prawidłowe wartości: {2}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 5f825ffffa4..b1c778ab53e 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">Descompactando o arquivo "{0}" em "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" é um nome inválido para o parâmetro "{0}".  Os valores válidos são: {2}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 0c7a66933a5..50ec23852a4 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">Распаковка файла "{0}" в"{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" — недопустимое значение для параметра "{0}".  Допустимые значения: {2}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 077758b4edd..2609f32cebe 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">"{0}" dosyasının sıkıştırması "{1}" hedefine açılıyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" değeri, "{0}" parametresi için geçersiz.  Geçerli değerler şunlardır: {2}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 26b89d23285..4fd7f38107e 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">将文件“{0}”解压缩到“{1}”。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: “{1}”是无效的“{0}”参数值。有效值为: {2}</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index ad011ed8d31..ee19e35935d 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -2590,6 +2590,11 @@
         <target state="translated">正在將檔案 "{0}" 解壓縮到 "{1}"。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" 是 "{0}" 參數的無效值。有效值為: {2}</target>
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index f9fbcadfcae..abeba2b2791 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -677,8 +677,8 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
 
             // The source code cannot actually be compiled "in memory" so instead the source code is written to disk in
             // the temp folder as well as the assembly.  After compilation, the source code and assembly are deleted.
-            string sourceCodePath = Path.GetTempFileName();
-            string assemblyPath = Path.Combine(Path.GetTempPath(), $"{Path.GetRandomFileName()}.dll");
+            string sourceCodePath = FileUtilities.GetTemporaryFileName(".tmp");
+            string assemblyPath = FileUtilities.GetTemporaryFileName(".dll");
 
             // Delete the code file unless compilation failed or the environment variable MSBUILDLOGCODETASKFACTORYOUTPUT
             // is set (which allows for debugging problems)
diff --git a/src/Tasks/TlbReference.cs b/src/Tasks/TlbReference.cs
index 7350cee5080..f08ae5f4d27 100644
--- a/src/Tasks/TlbReference.cs
+++ b/src/Tasks/TlbReference.cs
@@ -75,7 +75,7 @@ internal TlbReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComRefe
         /// <summary>
         /// directory we should write the wrapper to
         /// </summary>
-        protected override string OutputDirectory => (HasTemporaryWrapper) ? Path.GetTempPath() : base.OutputDirectory;
+        protected override string OutputDirectory => (HasTemporaryWrapper) ? FileUtilities.TempFileDirectory : base.OutputDirectory;
 
         private readonly bool _noClassMembers;
         private readonly string _targetProcessorArchitecture;
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 40a6acd512b..eff8d18aec5 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -156,6 +156,8 @@ public override bool Execute()
         /// <param name="destinationDirectory">The <see cref="DirectoryInfo"/> to extract files to.</param>
         private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)
         {
+            string fullDestinationDirectoryPath = Path.GetFullPath(FileUtilities.EnsureTrailingSlash(destinationDirectory.FullName));
+
             foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
             {
                 if (ShouldSkipEntry(zipArchiveEntry))
@@ -164,7 +166,10 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
                     continue;
                 }
 
-                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));
+                string fullDestinationPath = Path.GetFullPath(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));
+                ErrorUtilities.VerifyThrowInvalidOperation(fullDestinationPath.StartsWith(fullDestinationDirectoryPath, FileUtilities.PathComparison), "Unzip.ZipSlipExploit", fullDestinationPath);
+
+                FileInfo destinationPath = new(fullDestinationPath);
 
                 // Zip archives can have directory entries listed explicitly.
                 // If this entry is a directory we should create it and move to the next entry.
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 26325de8241..5088a0ff87e 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -109,7 +109,7 @@ public override bool Execute()
                     OutputFile = new TaskItem(Path.Combine(OutputDirectory.ItemSpec, OutputFile.ItemSpec));
                 }
 
-                OutputFile ??= new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, extension));
+                OutputFile ??= new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, null, extension));
 
                 File.WriteAllText(OutputFile.ItemSpec, code); // Overwrites file if it already exists (and can be overwritten)
             }
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index 7eb6306f4a1..a6fa201acc7 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -73,7 +73,7 @@ public static class FileTracker
 #region Static Member Data
 
         // The default path to temp, used to create explicitly short and long paths
-        private static readonly string s_tempPath = Path.GetTempPath();
+        private static readonly string s_tempPath = FileUtilities.TempFileDirectory;
 
         // The short path to temp
         private static readonly string s_tempShortPath = FileUtilities.EnsureTrailingSlash(NativeMethodsShared.GetShortFilePath(s_tempPath).ToUpperInvariant());
