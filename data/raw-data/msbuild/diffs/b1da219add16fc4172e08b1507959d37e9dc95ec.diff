diff --git a/documentation/Built-in-Properties.md b/documentation/Built-in-Properties.md
deleted file mode 100644
index 01c880aeb56..00000000000
--- a/documentation/Built-in-Properties.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild's reserved and built-in properties
-
-The MSBuild engine itself sets some properties for all projects. There is normal documentation for the [reserved properties and their meanings](https://docs.microsoft.com/visualstudio/msbuild/msbuild-reserved-and-well-known-properties). This document describes the implementation of these properties in MSBuild itself.
-
-There are actually two different implementations of this functionality in MSBuild.
-
-## Built-in properties
-
-When evaluating an individual project, Pass 0 of the evaluation calls [`AddBuiltInProperties()`][addbuiltinproperties] which in turn calls [`SetBuiltInProperty()`][setbuiltinproperty] which sets the property basically as normal.
-
-However, properties set there are not available at all parts of execution, and specifically they're not available when evaluating the `.tasks` file that makes MSBuild's built-in tasks available by default to all projects.
-
-## Reserved properties
-
-Reserved properties are [set by the toolset][toolset_reservedproperties] and are available _only_ in the `.tasks` and `.overridetasks` cases. Properties set there are not available in normal project evaluation.
-
-[addbuiltinproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L609-L612
-
-[setbuiltinproperty]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L1257
-
-[toolset_reservedproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Definition/Toolset.cs#L914-L921
diff --git a/documentation/Changelog.md b/documentation/Changelog.md
deleted file mode 100644
index be02ae3e952..00000000000
--- a/documentation/Changelog.md
+++ /dev/null
@@ -1,348 +0,0 @@
-# MSBuild Changelog
-
-## MSBuild 17.0.0
-
-This version of MSBuild shipped with Visual Studio 2022 version 17.0.0 and .NET SDK 6.0.100.
-
-### What's new
-
-* MSBuild now reports its version as `17` and uses Visual Studio 2022 versions of tasks where appropriate.
-* MSBuild now targets .NET Framework 4.7.2 and .NET 6.0.
-* 64-bit MSBuild is now used for builds from Visual Studio.
-* Binary logs are smaller and have more information.
-* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds.
-* The method `GetType()` can no longer be called in property functions.
-
-### Detailed release notes
-
-#### Added
-
-* Intrinsic tasks now log their location (#6397). Thanks, @KirillOsenkov!
-* `TargetSkippedEventArgs` now has `TargetSkipReason` and `OriginalBuildEventContext` (#6402, #6577). Thanks, @KirillOsenkov!
-* `TaskStarted` events now log line and column (#6399). Thanks, @KirillOsenkov!
-* ETW trace events for PerformDependencyAnalysis (#6658), WriteLinesToFile (#6670), CopyUpToDate (#6661).
-* If the environment variable `MSBuildDebugEngine` is set, MSBuild will create binary logs for all operations to `MSBUILDDEBUGPATH` regardless of how it is called (#6639, #6792).
-* `ProjectReference`s can now negotiate `Platform` (#6655, #6724, #6889).
-* Tasks can now call `TaskLoggingHelper.LogsMessagesOfImportance` to determine if any attached logger would preserve a log message before constructing it (to save time in the not-being-logged case) (#6381, #6737).
-* Support referencing assemblies with generic attributes (#6735). Thanks, @davidwrighton!
-* XSD-based MSBuild IntelliSense now supports `ImplicitUsings` and `Using` items (#6755), `InternalsVisibleTo` (#6778), Windows Forms properties (#6860), `DebugType` (#6849), and `SatelliteResourceLanguages` (#6861). Thanks, @pranavkm, @DamianEdwards, @RussKie, and @drewnoakes!
-* Tasks can now call `TaskLoggingHelper.IsTaskInputLoggingEnabled` and avoid redundant logging of inputs (#6803).
-* Support extracting resource namespace from C# source that uses file-scoped namespaces (#6881).
-
-#### Changed
-
-* The on-disk format of serialized caches has changed (#6350, #6324, #6490, #6674).
-* MSBuild is now [signed with a new certificate](https://github.com/dotnet/announcements/issues/184) (#6448).
-* `BuildParameters.DisableInprocNode` now applies to more processes (#6400).
-* `VCTargetsPath` now defaults to `v170` (#6550).
-* MSBuild no longer logs `Building with tools version "Current"` (#6627). Thanks, @KirillOsenkov!
-* Text loggers now log properties and items at the end of evaluation (#6535).
-* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds (#6622, #6703).
-* MSBuild on .NET 6 has improved task-assembly-reference fallback behavior (#6558).
-* MSBuild features gated on the 16.8 changewave are now nonconfigurable (#6634).
-* The deprecated import of `$(CoreCrossTargetingTargetsPath)` was removed (#6668). Thanks, @Nirmal4G!
-* Improved error message for `MSB4213` (#6640).
-* The method `GetType()` can no longer be called in property functions (#6769).
-* MSBuild is now fully NGENed by Visual Studio setup (#6764).
-* MSBuild (and Visual Studio) now reference `System.Text.Json` 5.0.2 (#6784). Thanks, @JakeRadMSFT!
-* Default to SHA2 digest for ClickOnce manifest when certificate signing algorithm is sha256/384/512 (#6882).
-
-#### Fixed
-
-* Solution builds should work when using the secret environment variable `MSBUILDNOINPROCNODE` (#6385).
-* Solution extensions can now use `BeforeTargets="ValidateSolutionConfiguration"` (#6454).
-* Performance improvements (#6529, #6556, #6598, #6632, #6669, #6671, #6666, #6678, #6680, #6705, #6595, #6716, #6786, #6816, #6832, #6845).
-* Single-file ClickOnce publish includes file association icons (#6578).
-* Improved robustness in error handling of libraries without resources (#6546).
-* Fixed missing information in `Project`'s `DebuggerDisplay` (#6650).
-* `ResolveAssemblyReferences` output paths are now output in normalized form (#6533).
-* Improved handling of satellite assemblies in ClickOnce (#6665).
-* Roslyn code analyzers are no longer run during XAML precompilation (#6676). Thanks, @jlaanstra!
-* 64-bit API callers no longer need to set `MSBUILD_EXE_PATH` (#6683, #6746).
-* `EvaluateStop` ETW events are now automatically correlated with `EvaluateStart` (#6725).
-* Evaluation time is included in text performance traces (#6725).
-* Add PackageDescription to `Microsoft.NET.StringTools` (#6740).
-* Fixed deadlock between `ExecuteSubmission` and `LoggingService` (#6717).
-* Narrowed conditions where MSBuild would blame NuGet for SDK resolution problems (#6742).
-* `CombineTargetFrameworkInfoProperties` no longer fails on portable framework names (#6699).
-* Avoid needless builds of `GenerateBindingRedirects` (#6726).
-* The solution configuration is now passed to experimental cache plugins (#6738).
-* Clearer errors when SDK resolvers throw exceptions (#6763).
-* Improved errors from `InternableString.ExpensiveConvertToString` (#6798).
-* Binding redirects for all `System.*` assemblies updated (#6830).
-* Fixed deadlock between `BuildManager` and `LoggingService` (#6837).
-* Log message arguments for warnings and errors (#6804). Thanks, @KirillOsenkov!
-* Use static CoreClrAssemblyLoader for SDK resolvers (#6864). Thanks, @marcin-krystianc!
-* Avoid break caused by fix and workaround for AL path colliding (#6884).
-* Support private-use area Unicode characters in paths passed to `XslTransformation` (#6863, #6946). Thanks, @lanfeust69!
-* Use the correct .NET host when called from a .NET 6.0 application (#6890).
-
-#### Infrastructure
-
-* This repo now builds with Arcade 6.0 (#6143).
-* Use newer Ubuntu versions for Linux CI builds (#6488).
-* MSBuild now uses [Arcade-powered source build](https://github.com/dotnet/source-build/tree/ba0b33e9f96354b8d07317c3cdf406ce666921f8/Documentation/planning/arcade-powered-source-build) (#6387).
-* Improved repo issue templates and automation (#6557).
-* Whitespace cleanup (#6565).
-* This repo no longer needs to double-specify the SDK version (#6596).
-* Simplify references to `TargetFramework` using new intrinsics (#5799).
-* Reference the `Microsoft.DotNet.XUnitExtensions` package from Arcade instead of our fork (#6638).
-* Use [`BannedApiAnalyzers`](https://www.nuget.org/packages/Microsoft.CodeAnalysis.BannedApiAnalyzers/) (#6675).
-* Enable analyzers for the MSBuild repo with rules similar to `dotnet/runtime` (#5656). Thanks, @elachlan!
-* Improved internal OptProf training scenarios (#6758).
-* Delete Unreachable code (#6805). Thanks, @KirillOsenkov!
-* Upgrade System.Net.Http package version used in tests (#6879).
-
-#### Documentation
-
-* Use GitHub-generated Markdown tables of contents (#6760).
-* Fixed validation issues in docs build (#6744).
-* Descriptions of labels in use in this repo (#6873).
-
-## MSBuild 16.11.0
-
-This version of MSBuild shipped with Visual Studio 2019 version 16.11.0 and .NET SDK 5.0.400.
-
-### What's new
-
-* MSBuild now supports long paths in the 64-bit `amd64\MSBuild.exe` executable.
-* New version properties `MSBuildFileVersion` (4-part, matches file version) and `MSBuildSemanticVersion` (matches package versions) are now available for use (#6534).
-
-### Detailed release notes
-
-#### Added
-
-* Additional properties documented and available for completion in Visual Studio (#6500, #6530).
-* The `SignFile` task is now available in MSBuild on .NET 5.0 (#6509). Thanks, @Zastai!
-* New version properties `MSBuildFileVersion` (4-part, matches file version) and `MSBuildSemanticVersion` (matches package versions) are now available for use (#6534).
-#### Changed
-
-* When using the experimental cache API, schedule proxy builds to the in-proc node for performance (#6386).
-* Experimental cache queries are now executed in parallel (#6468).
-* The ETW events generated in `ResolveAssemblyReference` now include an approximation of the "size" of the RAR request (#6410).
-
-#### Fixed
-
-* Fixed memory leak in `ProjectRootElement.Reload` (#6457).
-* Added locking to avoid race conditions in `BuildManager` (#6412).
-* Allow `ResolveAssemblyReferences` precomputed cache files to be in read-only locations (#6393).
-* 64-bit `al.exe` is used when targeting 64-bit architectures (for real this time) (#6484).
-* Builds with `ProduceOnlyReferenceAssembly` no longer expect debug symbols to be produced (#6511). Thanks, @Zastai!
-* 64-bit `MSBuild.exe` supports long paths (and other .NET default behaviors) (#6562).
-* Non-graph builds no longer crash in the experimental project cache (#6568).
-* The experimental project cache is initialized only once (#6569).
-* The experimental project cache no longer tries to schedule proxy builds to the in-proc node (#6635).
-
-#### Infrastructure
-
-* Use a packaged C# compiler to avoid changes in reference assembly generation caused by compiler changes (#6431).
-* Use more resilient test-result upload patterns (#6489).
-* Conditional compilation for .NET Core within our repo now includes new .NET 5.0+ runtimes (#6538).
-* Switched to OneLocBuild for localization PRs (#6561).
-* Moved to latest Ubuntu image for PR test legs (#6573).
-
-## MSBuild 16.10.2
-
-This version of MSBuild shipped with Visual Studio 2019 version 16.10.2 and will ship with .NET SDK 5.0.302.
-
-#### Fixed
-
-* Fixed a regression in the `MakeRelative` property function that dropped trailing slashes (#6513). Thanks, @dsparkplug and @pmisik!
-* Fixed a regression in glob matching where files without extensions were erroneously not matched (#6531).
-* Fixed a change in logging that caused crashes in Azure DevOps loggers (#6520).
-
-## MSBuild 16.10.2
-
-This version of MSBuild shipped with Visual Studio 2019 version 16.10.2 and will ship with .NET SDK 5.0.302.
-
-#### Fixed
-
-* Fixed a regression in the `MakeRelative` property function that dropped trailing slashes (#6513). Thanks, @dsparkplug and @pmisik!
-* Fixed a regression in glob matching where files without extensions were erroneously not matched (#6531).
-* Fixed a change in logging that caused crashes in Azure DevOps loggers (#6520).
-
-## MSBuild 16.10.1
-
-This version of MSBuild shipped with Visual Studio 2019 version 16.10.1 and .NET SDK 5.0.301.
-
-#### Fixed
-
-* Restore support for building individual project(s) within solutions by specifying `-t:Project` (#6465).
-
-## MSBuild 16.9.2
-
-This version of MSBuild shipped with Visual Studio 2019 version 16.9.7.
-
-#### Fixed
-
-* Fixed MSB0001 error when building large solutions (#6437).
-
-## MSBuild 16.10.0
-
-This version of MSBuild shipped with Visual Studio 2019 version 16.10.0 and .NET SDK 5.0.300.
-
-### What's new
-
-* MSBuild now targets .NET 5.0 and .NET Framework 4.7.2.
-* MSBuild is faster and uses less memory.
-* Binary logs are smaller and have less performance overhead.
-* Tasks can now opt into resource management to improve parallelism in large builds.
-* It's now possible to optionally embed arbitrary files in a binary log.
-
-### Detailed release notes
-
-#### Added
-
-* Projects can now specify `AdditionalTargetFrameworkInfoProperty` items to indicate that referencing projects should get those properties exposed as `AdditionalPropertiesFromProject` metadata on resolved reference items. (#5994).
-* The `Unzip` task now accepts `Include` and `Exclude` arguments to filter what is extracted from the zip file (#6018). Thanks, @IvanLieckens!
-* The `-graph:noBuild` command line argument can be used to validate that a graph is buildable without actually building it (#6016).
-* `TaskParameterEventArgs` allow logging task parameters and values in a compact, structured way (#6155). Thanks, @KirillOsenkov!
-* ClickOnce publish now supports Ready To Run (#6244).
-* .NET 5.0 applications may now specify a toolset configuration file (#6220).
-* `ResolveAssemblyReferences` can now consume information about assemblies distributed as part of the SDK (#6017).
-* Allow constructing a `ProjectInstance` from a `ProjectLink` (#6262).
-* Introduce cross-process resource management for tasks (#5859).
-* `ProjectEvaluationFinished` now has fields for properties and items (#6287). Thanks, @KirillOsenkov!
-* `WriteCodeFragment` can now write assembly attributes of specified types, and infers some common types (#6285). Thanks, @reduckted!
-* The `-detailedSummary` option now accepts a boolean argument, preventing dumping details to the console logger when building with `-bl -ds:false` (#6338). Thanks, @KirillOsenkov!
-* Binary logs now include files listed in the item `EmbedInBinlog` as well as MSBuild projects (#6339). Thanks, @KirillOsenkov!
-* The `FindInvalidProjectReferences` task is now available in .NET Core/5.0+ scenarios (#6365).
-
-#### Changed
-
-* String deduplication is now much more sophisticated, reducing memory usage (#5663).
-* Refactoring and performance improvements in `ResolveAssemblyReferences` (#5929, #6094).
-* Binary logs now store strings only once, dramatically reducing log size (#6017, #6326). Thanks, @KirillOsenkov!
-* Refactoring and code cleanup (#6120, #6159, #6158, #6282). Thanks, @Nirmal4G!
-* `Span<T>`-based methods are used on .NET Framework MSBuild as well as .NET 5.0 (#6130).
-* Improved `MSB4064` error to include information about the loaded task that didn't have the argument (#5945). Thanks, @BartoszKlonowski!
-* Performance improvements in inter-node communication (#6023). Thanks, @KirillOsenkov!
-* Performance improvements in matching items based on metadata (#6035), property expansion (#6128), glob evaluation (#6151), enumerating files (#6227).
-* When evaluated with `IgnoreInvalidImports`, _empty_ imports are also allowed (#6222).
-* `Log.HasLoggedError` now respects `MSBuildWarningsAsErrors` (#6174).
-* `TargetPath` metadata is now respected on items that copy to output directories, and takes precedence over `Link` (#6237).
-* The `Restore` operation now fails when SDKs are unresolvable (#6312).
-* `MSBuild.exe.config` now has explicit binding redirects for all assemblies in the MSBuild VSIX (#6334).
-
-#### Fixed
-
-* Inconsistencies between `XamlPreCompile` and the `CoreCompile` C## compiler invocation (#6093). Thanks, @huoyaoyuan!
-* Wait for child nodes to exit before exiting the entry-point node in VSTest scenarios (#6053). Thanks, @tmds!
-* Fix bad plugin EndBuild exception handling during graph builds (#6110).
-* Allow specifying `UseUtf8Encoding` in `ToolTask`s (#6188).
-* Failures on big-endian systems (#6204). Thanks, @uweigand!
-* 64-bit `al.exe` is used when targeting 64-bit architectures (#6207).
-* Improved error messages when encountering a `BadImageReferenceException` in `ResolveAssemblyReferences` (#6240, #6270). Thanks, @FiniteReality!
-* Escape special characters in `Exec`’s generated batch files, allowing builds as users with some special characters in their Windows username (#6233).
-* Permit comments and trailing commas in solution filter files (#6346).
-* Exceptions thrown from experimental cache plugins are now handled and logged better (#6345, #6368).
-* Source generators with configuration files can now be used in XamlPreCompile (#6438).
-* Large builds no longer crash with an exception in `LogProjectStarted` (#6437).
-
-#### Infrastructure
-
-* Update to Arcade 5.0 and .NET 5.0 (#5836).
-* The primary development branch is now named `main`.
-* Test robustness improvements (#6055, #6336, #6337, #6332). Thanks, @tmds and @KirillOsenkov!
-* Remove unnecessary NuGet package references (#6036). Thanks, @teo-tsirpanis!
-* Correctly mark .NET Framework 3.5 reference assembly package dependency as private (#6214).
-* Our own builds opt into text-based performance logging (#6274).
-* Update to Arcade publishing v3 (#6349).
-* Use OneLocBuild localization process (#6378).
-
-#### Documentation
-
-* Updates to static graph documentation (#6043).
-* Short doc on the threading model (#6042).
-* Update help text to indicate that `--` is a valid argument prefix (#6205). Thanks, @BartoszKlonowski!
-* API documentation improvements (#6246, #6284).
-* Details about interactions with the Global Assembly Cache (#6173).
-
-## MSBuild 16.9.0.2116703
-
-⚠ This release should have been versioned `16.9.1` but was erroneously released as 16.9.0.
-
-This version of MSBuild shipped with Visual Studio 2019 version 16.9.3.
-
-#### Fixed
-
-* Restore support for building solutions with web site projects (#6238).
-
-## MSBuild 16.9.0
-
-This version of MSBuild shipped with Visual Studio 2019 version 16.9.0 and .NET SDK 5.0.200.
-
-### What's new
-
-* `MSB3277` warnings now include information about the assembly identities involved, instead of saying to rerun under higher verbosity.
-* It's now possible to opt out of culture-name detection of `EmbeddedResource`s, for instance to have a resource named `a.cs.template`.
-* Common targets now support `$(BaseOutputPath)`, with the default value `bin`.
-* Item `Update`s are no longer case-sensitive, fixing a regression in MSBuild 16.6 (#5888).
-* `ParentBuildEventContext` now includes a parent `MSBuild` task if relevant, enabling proper nesting in GUI viewers.
-* Builds that fail because a warning was elevated to an error now report overall failure in the `MSBuild.exe` exit code.
-
-### Detailed release notes
-
-#### Added
-
-* The `MSB4006` error has been enhanced to describe the cycle when possible (#5711). Thanks, @haiyuzhu!.
-* More information is logged under `MSBUILDDEBUGCOMM` (#5759).
-* The command line parser now accepts arguments with double hyphens (`--argument`) as well as single hyphens (`-argument`) and forward slashes (`/argument`) (#5786). Thanks, @BartoszKlonowski!
-* MSBuild now participates in the .NET CLI text performance log system on an opt-in basis (#5861).
-* Common targets now support `$(BaseOutputPath)`, with the default value `bin` (#5238). Thanks, @Nirmal4G!
-* `Microsoft.Build.Exceptions.CircularDependencyException` is now public (#5988). Thanks, @tflynt91!
-* `EvaluationId` is now preserved in the `ProjectStarted` event, allowing disambiguating related project start events (#5997). Thanks, @KirillOsenkov!
-* The `ResolveAssemblyReference` task can now optionally emit items describing unresolved assembly conflicts (#5990).
-* Experimental `ProjectCache` API to enable higher-order build systems (#5936).
-
-#### Changed
-
-* Warnings suppressed via `$(NoWarn)` (which formerly applied only to targets that opted in like the C## compiler) are now treated as `$(MSBuildWarningsAsMessages)` (#5671).
-* Warnings elevated via `$(WarningsAsErrors )` (which formerly applied only to targets that opted in like the C## compiler) are now treated as `$(MSBuildWarningsAsErrors)` (#5774).
-* Improved error message when using an old .NET (Core) SDK and targeting .NET 5.0 (#5826).
-* Trailing spaces in property expressions inside conditionals now emit an error instead of silently expanding to the empty string (#5672, #5868). Thanks, @mfkl!
-* `MSB3277` warnings now include information about the assembly identities involved, instead of saying to rerun under higher verbosity (#5798).
-* `MSB5009` errors now indicate the project in the solution that is causing the nesting error (#5835). Thanks, @BartoszKlonowski!
-* Avoid spawning a process to determine processor architecture (#5897). Thanks, @tmds!
-* It's now possible to opt out of culture-name detection of `EmbeddedResource`s, for instance to have a resource named `a.cs.template` (#5824).
-* `ProjectInSolution.AbsolutePath` returns a normalized full path when possible (#5949).
-* Evaluation pass-stop events now include information about the "size" (number of properties/items/imports) of the project (#5978). Thanks, @arkalyanms!
-
-#### Fixed
-
-* `AllowFailureWithoutError` now does what it said it would do (#5743).
-* The solution parser now no longer skips projects that are missing an EndProject line (#5808). Thanks, @BartoszKlonowski!
-* `ProjectReference`s to `.vcxproj` projects from multi-targeted .NET projects no longer overbuild (#5838).
-* Removed unused `InternalsVisibleTo` to obsolete test assemblies (#5914). Thanks, @SingleAccretion!
-* Respect conditions when removing all items from an existing list at evaluation time (#5927).
-* Common targets should no longer break if the environment variable `OS` is set (#5916).
-* Some internal errors will now be reported as errors instead of hanging the build (#5917).
-* Item `Update`s are no longer case-sensitive, fixing a regression in MSBuild 16.6 (#5888).
-* Use lazy string formatting in more places (#5924).
-* Redundant references to MSBuild assemblies no longer fail in 64 MSBuild inline tasks (#5975).
-* The `Exec` task will now no longer emit the expanded `Command` to the log on failure (#5962). Thanks, @tmds!
-* Tasks generated with `RoslynCodeTaskFactory` now no longer rebuild for every use, even with identical inputs (#5988). Thanks, @KirillOsenkov!
-* `ParentBuildEventContext` now includes a parent `MSBuild` task if relevant (#5966). Thanks, @KirillOsenkov!
-* Builds that fail because a warning was elevated to an error now report overall failure in the `MSBuild.exe` exit code (#6006).
-* Performance of projects with large numbers of consecutive item updates without wildcards improved (#5853).
-* Performance improvements in `ResolveAssemblyReferences` (#5973).
-* PackageReferences that are marked as development dependencies are removed from the ClickOnce manifest (#6037).
-* Stop overfiltering .NET Core assemblies from the ClickOnce manifest (#6080).
-
-#### Infrastructure
-
-* The MSBuild codebase now warns for unused `using` statements (#5761).
-* The MSBuild codebase is now indexed for [Rich Code Navigation](https://visualstudio.microsoft.com/services/rich-code-navigation/) on CI build (#5790). Thanks, @jepetty!
-* The 64-bit bootstrap directory is more usable (#5825).
-* Test robustness improvements (#5827, #5944, #5995).
-* Make non-shipping NuGet packages compliant (#5823).
-* Use [Darc](https://github.com/dotnet/arcade/blob/main/Documentation/Darc.md) to keep bootstrap dependencies up to date (#5909).
-* Replace MSBuild.Dev.sln and MSBuild.SourceBuild.sln with solution filters (#6010).
-* Minimize and update NuGet feeds (#6019, #6136).
-
-#### Documentation
-
-* Improvements to MSBuild-internal Change Wave docs (#5770, #5851).
-* High-level documentation for static graph functionality added (#5741).
-* Instructions on testing private bits (#5818, #5831).
-* XML doc comments updated to match public-ready API docs pages (#6028). Thanks, @ghogen!
diff --git a/documentation/Contributions/MSBuild-overview.md b/documentation/Contributions/MSBuild-overview.md
deleted file mode 100644
index 73e6079d632..00000000000
--- a/documentation/Contributions/MSBuild-overview.md
+++ /dev/null
@@ -1,60 +0,0 @@
-- [Quick intro](#quick-intro)
-- [Language interpretation parts](#language-interpretation-parts)
-- [MSBuild APIs and components](#msbuild-apis-and-components)
-- [MSBuild execution modes](#msbuild-execution-modes)
-
-# Quick intro
-MSBuild implements an actual language (... MSBuildian?). For syntax it uses XML. The XML elements and attributes represent keywords, variable names, and expressions in the language. The language is interpreted.
-
-MSBuild has two data structures:
-- [properties](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-properties): single valued, scalars. Like `string foo` in C#
-- [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items): multi valued, arrays. Like `string[] foo` in C#. Except that each array has a name called an `item-type`, and each element may not only have a value, but also have associated key-value pairs known as metadata.
-
-Typewise, everything is a string in MSBuild.
-
-Executing logic is grouped in [Targets](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets). They are like functions in C#. Targets can contain a single type of statement, [Tasks](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks). Targets form dependencies between themselves and are executed via a stack, similar to stack based function execution in other languages.
-
-Data structures (properties and items) can be declared either inside or outside targets. There is a single scope in MSBuild, you could call it the static scope. There's no automatic "target scopes". So if you declare a property or an item inside a target, it's still static and visible to the rest of the targets.
-
-# Language interpretation parts 
-
-The parser, which produces the AST: [ProjectParser](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Evaluation/ProjectParser.cs#L125). The AST top node is the [ProjectRootElement](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/Construction/ProjectRootElement.cs#L44)
-
-Interpretation happens in two big separate phases.
-
-The first interpretation phase is called **project evaluation**. It's done by the msbuild [Evaluator](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/Evaluator.cs#L52). The result of evaluation is an object tree similar (but different) to the symbol trees done by [compilers](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/get-started/semantic-analysis#understanding-compilations-and-symbols). The semantic top nodes are `ProjectInstance` and `Project`. You can sort of think of the `ProjectRootElement` as the syntax API and the `Project` / `ProjectInstance` as the semantic API. The big difference in MSBuild is that `ProjectInstance`/`Project` also contain the actual interpretation results of MSBuild's state (properties and items) that sits outside targets.
-
-Evaluation does not execute the targets in a project. It only interprets and stores the results of logic outside targets.
-
-The second phase of msbuild interpretation is target execution. This happens in the [TargetBuilder](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs#L100). The `TargetBuilder` uses a stack to execute targets. The initial state is the state contained inside a given `ProjectInstance`. So targets execute in a stack based manner and mutate the global state inside a `ProjectInstance`.
-
-What's the difference between `Project` and `ProjectInstance`? While both represent evaluated projects, they are intended for different use cases. `Project` objects are specialized in introspecting / analyzing MSBuild code and also in providing high level project editing operations. `ProjectInstance` objects are  read only. So the objects in the `Project` tree point back to their corresponding `ProjectRootElement` AST elements. The objects in the `ProjectInstance` tree do not point back to the `ProjectRootElement` elements (so they have a much smaller memory footprint). For example, the `Project` tree is used by Visual Studio to analyze msbuild projects, and to reflect UI changes all the way down to the XML elements. The `TargetBuilder` only works with the lighter weight `ProjectInstance` tree, since it only needs to read state.
-
-# MSBuild APIs and components
-- `Project` / `ProjectInstance`: entrypoint APIs for working with MSBuild evaluations.
-- `BuildManager`: entrypoint API for executing targets in MSBuild.
-  - - Project build stack: RequestBuilder -> TargetBuilder -> TaskBuilder. The RequestBuilder is responsible for evaluating and running targets on a project. The TargetBuilder is responsible for running the target execution stack. The TaskBuilder is responsible for running individual tasks.
-- MSBuild nodes
-  - MSBuild distributes work across multiple processes.
-  - All processes live on the same machine.
-  - Types of nodes:
-    - A main node, called the "BuildManager node" or the "Scheduler node". It contains BuildManager instances and its main role is to coordinate the entire build. It's a big state machine that decides when to create other nodes and on which nodes to build projects.
-    - Multiple worker nodes whose single responsibility is to build projects. A worker node builds only one project at a time (99% true).
-  - The process hosting the single BuildManager node can also host one worker node (called the "inproc node"). This is done for perf reasons, to avoid serialization costs. When the BuildManager node decides to spawn a new Worker node, it creates a new process for it. These are called out of process nodes, or "oop nodes". So Worker nodes can either be inproc nodes (a single one), or oop nodes (multiple).
-
-# MSBuild execution modes
-- Building from cmdline (type msbuild.exe)
-    - MSBuild is responsible for discovering project dependencies, and building them in a depth first search manner
-    - There is no static graph of project dependencies. MSBuild does not know ahead of time what work it needs to do. It does a Just In Time DFS descent over the project references.
-    - references form a DAG. A -> {B, C}, B -> {C, D}
-    - there's a convention on how to declare and build references
-      - documented here: https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md
-      - mostly implemented here: https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CurrentVersion.targets
-- Building from Visual Studio (VS) (pressing ctrl+shift+B, or the context menu `Build -> Build Solution`)
-    - VS implements an object model for an MSBuild dependency graph
-    - VS takes over the responsibility of handling the graph dependencies and constructs its own graph
-    - It bypasses MSBuild's scheduler and "orders" MSBuild to build a single project at a time, ignoring its references
-    - It builds the graph bottom up in reverse toposort order (starting from nodes without references and going up).
-    - Fast up to date checks:  VS hardcodes relevant project file inputs for each language SDK. (for example it knows that C# projects read global.json). It uses these hardcoded rules to skip building projects. (whereas quickbuild does this in a generic non hardcoded way by observing actual IO inputs and outputs)
-- Build from commandline with static graph (type msbuild.exe /graph)
-  - this works just like QB and VS: MSBuild uses its [static graph library](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md) to find the dependency graph then builds each project node from the graph in toposort order. Unlike QB, it does neither multi machine distribution nor caching
\ No newline at end of file
diff --git a/documentation/Contributions/README.md b/documentation/Contributions/README.md
deleted file mode 100644
index 08307044761..00000000000
--- a/documentation/Contributions/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-# Contributed documentation
-
-This directory has documentation that was contributed by developers or users that hasn't been fully vetted for accuracy and correctness.
-
-Explanations in this folder may be slightly or subtly wrong, but can still be very informative for developing an understanding of MSBuild or a specific problem.
diff --git a/documentation/Contributions/solution-parser.md b/documentation/Contributions/solution-parser.md
deleted file mode 100644
index fa22407e66c..00000000000
--- a/documentation/Contributions/solution-parser.md
+++ /dev/null
@@ -1,59 +0,0 @@
-# Solution Parser
-
-## Expander
-
-The `Expander` class is used to expand a value from an expression, which can be a function invocation. These expressions (or embedded properties) have the form "$(Property)".
-
-`Expander` handles intrinsic functions, which is a list of built-in functions.
-
-MSBuild defines an initial set of properties like `MSBuildFrameworkToolsPath32`, `MSBuildFrameworkToolsPath`, etc.
-
-Tools configuration can come from configuration file, registry and current exe path.
-
-## Building
-
-Function `BeginBuild` prepares `BuildManager` to receive build requests, which:
-- Attaches debugger;
-- Checks that the current build manager's state is idle;
-- Initializes the logging service;
-- Initializes caches;
-- Registers packet handlers.
-
-After this setup, `MSBuild` creates build request data from project files or project instances. Data for build requests are stored in `BuildRequestData` objects.
-
-After build data for a request have been prepared, `MSBuild` executes the build. It may execute restore and/or a graph build instead depending on the configuration. It executes the build in the `ExecuteBuild` function, which pends the build request, creating an instance of `BuildSubmission` that represents the build submission.
-
-All build submissions are stored in a dictionary in the `BuildManager` class. Then they are added to the work queue.
-
-## Execution
-
-The work queue dispatches build submissions. Function `IssueBuildSubmissionToSchedulerImpl`
-creates `BuildRequestBlocker` (blocker) that’s handled in the `HandleNewRequest` function that handles new requests coming from nodes. This function iterates over all build requests in blocker and, for a solution build, loads the solution to the configuration.
-
-### Solution file parser
-
-Later, it parses the solution file to generate a solution wrapper using methods from the `SolutionFile` class. First, the parser parses the file header, which should only contain solution file format version.
-
-After that, it parses all remaining lines. Each such line should start with one of the following strings:
-- `Project(` - calls `ParseProject`
-- `GlobalSection(NestedProject)` - calls `ParseNestedProjects`
-- `GlobalSection(SolutionConfigurationPlatforms)` - calls `ParseSolutionConfiguration`
-- `GlobalSection(ProjectConfigurationPlatforms)` - calls `ProjectConfigurationPlatforms`
-- `VisualStudioVersion` - calls `ParseVisualStudioVersion`
-
-`ParseProject` parses the first line containing the Project Type GUID, Project name, Relative Path, and Project GUID. Each project type is hardcoded (as defined in `SolutionFile`). Then it parses all project dependencies. After a project has been parsed, it’s added to the list of parsed projects.
-
-`GlobalSection(SolutionConfigurationPlatforms)` parses the global configuration, such as `Debug|Any CPU = Debug|Any CPU`. It adds these configurations to the solution configuration list.
-
-`GlobalSection(ProjectConfigurationPlatforms)` works pretty much the same as `GlobalSection(ProjectConfigurationPlatforms)`, but it's the global configuration for projects. It adds these configurations to the raw project configuration list.
-
-`GlobalSection(NestedProjects)` finds parent projects for each given project. It stores the parent GUID in nested projects.
-
-After parsing the solution file, MSBuild processes the project configuration section, updating the project configuration section parsed from a previous solution file.
-
-### Solution project generation
-
-Then `MSBuild` generates an MSBuild project file from the list of projects and dependencies collected from the solution file.
-
-While generating the MSBuild wrapper project for a solution file, `MSBuild` first collects an ordered list of actual projects then creates a traversal project instance and adds some XML to it. Then it emits a solution metaproject (if it was specified) from that traversal project. It does not write this project to disk unless specified. Finally, it builds the metaproject.
-
diff --git a/documentation/Deploy-MSBuild.md b/documentation/Deploy-MSBuild.md
deleted file mode 100644
index 80e1e7d2b84..00000000000
--- a/documentation/Deploy-MSBuild.md
+++ /dev/null
@@ -1,24 +0,0 @@
-# Deploying Just-Built MSBuild
-
-## Visual Studio
-
-[Deploy-MSBuild](https://github.com/dotnet/msbuild/blob/deploy-msbuild/scripts/Deploy-MSBuild.ps1) is a way to conveniently take private bits and install them into Visual Studio (VS) for testing. To use it:
-
-- If you haven't already, clone [MSBuild](https://github.com/dotnet/msbuild) and make the changes you want.
-- Build MSBuild with the changes you want using `build.cmd /p:CreateBootstrap=true`.
-- In an administrator powershell window, navigate to the msbuild folder.
-- Run `scripts\Deploy-MSBuild.ps1 -destination {destination} -configuration {configuration}`.
-  - Specify the Bin folder of MSBuild in your VS install as the destination. This is somewhere like `"C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin"`.
-  - Make sure the `{configuration}` you pass to the deploy script matches the one you gave to `build.cmd` (this is `Debug` by default).
-
-The Deploy-MSBuild script creates backups of the relevant MSBuild binaries, then copies the new binaries in their place.
-
-⚠ CAUTION: If you overwrite the MSBuild in Visual Studio you can break Visual Studio. That in turn can prevent you from building MSBuild to fix your bug! The deploy script makes backups by default which you may need to manually copy back over.
-
-### Crossing machines
-
-If you cannot build or cannot deploy MSBuild on the same machine on which you wish to use the updated version of VS, build and deploy to an empty folder instead. Then, manually make a backup of the files in that folder and overwrite them in the VS install of choice.
-
-## .NET (Core) SDK
-
-Deploy-MSBuild can also patch a .NET (Core) SDK installation. Pass the `-runtime Core` argument to `Deploy-MSBuild.ps1` to ensure that it selects .NET Core MSBuild.
diff --git a/documentation/MSBuild-Server.md b/documentation/MSBuild-Server.md
deleted file mode 100644
index 9337295dac6..00000000000
--- a/documentation/MSBuild-Server.md
+++ /dev/null
@@ -1,60 +0,0 @@
-# MSBuild Server
-
-MSBuild Server nodes accept build requests from clients and use worker nodes in the current fashion to build projects. The main purpose of the server node is to preserve caches between builds and avoid expensive MSBuild process start operations during build from tools like the .NET SDK.
-
-## Usage
-
-The primary ways to use MSBuild are via Visual Studio and via the CLI using the `dotnet build`/`dotnet msbuild` commands. MSBuild Server is not supported in Visual Studio because Visual Studio itself works like MSBuild Server. For the CLI, the server functionality is enabled by default and can be disabled by setting the `DOTNET_CLI_DO_NOT_USE_MSBUILD_SERVER` environment variable to value `1`.
-To re-enable MSBuild Server, remove the variable or set its value to `0`.
-
-## Communication protocol
-
-The server node uses same IPC approach as current worker nodes - named pipes. This solution allows to reuse existing code. When process starts, pipe with deterministic name is opened and waiting for commands. Client has following worfklow:
-
-1. Try to connect to server
-   - If server is not running, start new instance
-   - If server is busy or the connection is broken, fall back to previous build behavior
-2. Initiate handshake
-2. Issue build command with `ServerNodeBuildCommand` packet
-3. Read packets from pipe
-   - Write content to the appropriate output stream (respecting coloring) with the `ServerNodeConsoleWrite` packet
-   - After the build completes, the `ServerNodeBuildResult` packet indicates the exit code
-
-### Pipe name convention & handshake
-
-There might be multiple server processes started with different architecture, associated user, MSBuild version and another options. To quickly identify the appropriate one, server uses convention that includes these options in the name of the pipe. Name has format `MSBuildServer-{hash}` where `{hash}` is a SHA256 hashed value identifying these options.
-
-Handshake is a procedure ensuring that client is connecting to a compatible server instance. It uses same logic and security guarantees as current connection between entry node and worker nodes. Hash in the pipe name is basically hash of the handshake object.
-
-### Packets for client-server communication
-
-Server requires to introduce new packet types for IPC.
-
-`ServerNodeBuildCommand` contains all of the information necessary for a server to run a build.
-
-| Property name            | Type                         | Description |
-|---|---|---|
-| CommandLine              | String                       | The MSBuild command line with arguments for build |
-| StartupDirectory         | String                       | The startup directory path |
-| BuildProcessEnvironment  | IDictionary<String, String>  | Environment variables for current build |
-| Culture                  | CultureInfo                  | The culture value for current build |
-| UICulture                | CultureInfo                  | The UI culture value for current build |
-| ConsoleConfiguration     | TargetConsoleConfiguration   | Console configuration of target Console at which the output will be rendered |
-
-`ServerNodeConsoleWrite` contains information for console output.
-
-| Property name            | Type          | Description |
-|---|---|---|
-| Text                     | String        | The text that is written to the output stream. It includes ANSI escape codes for formatting. |
-| OutputType               | Byte          | Identification of the output stream (1 = standard output, 2 = error output) |
-
-`ServerNodeBuildResult` indicates how the build finished.
-
-| Property name            | Type          | Description |
-|---|---|---|
-| ExitCode                 | Int32         | The exit code of the build |
-| ExitType                 | String        | The exit type of the build |
-
-`ServerNodeBuildCancel` cancels the current build.
-
-This type is intentionally empty and properties for build cancelation could be added in future.
diff --git a/documentation/NETFramework-NGEN.md b/documentation/NETFramework-NGEN.md
deleted file mode 100644
index b117cacd6c0..00000000000
--- a/documentation/NETFramework-NGEN.md
+++ /dev/null
@@ -1,121 +0,0 @@
-# .NET Framework NGEN Considerations
-
-NGEN is the name of the legacy native AOT technology used in .NET Framework. Compared to its modern .NET counter-part,
-NGEN has the following key characteristics:
-- Native code is always stored in separate images located in a machine-wide cache.
-- Native images are generated on user machines, typically during app installation, by an elevated process.
-- Native images are specific for a given IL image (its identity, *not* its location) and its exact dependencies as they are bound to at run-time.
-
-Check the [Ngen.exe (Native Image Generator)](https://learn.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator) Microsoft Learn article for an overview of how NGEN works.
-
-## NGEN in Visual Studio
-
-Visual Studio use NGEN for almost everything that ships in the box. The sheer amount of code which needs to be
-compiled makes it impractical for native image generation to occur synchronously during installation. Instead,
-VS installer queues up assemblies for deferred compilation by the NGEN service, which typically happens when the
-machine is idle. To force native images to be generated, one can execute the following command in an elevated
-terminal window:
-
-```
-C:\Windows\Microsoft.NET\Framework64\v4.0.30319\ngen eqi
-```
-
-The .NET Framework build of MSBuild is inserted into VS and it registers itself for NGEN by including `vs.file.ngenApplications`
-in the relevant [files.swr](https://github.com/dotnet/msbuild/blob/main/src/Package/MSBuild.VSSetup/files.swr) entries. MSBuild
-is hosted in several processes, most notably the stand-alone command line tool `MSBuild.exe` and the main IDE process `devenv.exe`.
-Because each process runs with slightly different dependencies - `MSBuild.exe` loads most of them from `[VS install dir]\MSBuild\Current\Bin`
-or `[VS install dir]\MSBuild\Current\Bin\[arch]` while `devenv.exe` has its own set loaded from other parts of the VS installation -
-we NGEN our code twice. This is encoded by multiple `vs.file.ngenApplications` entries for a single file in `files.swr`.
-The special `[installDir]\Common7\IDE\vsn.exe` entry represents devenv.
-
-The bad thing about this is that the system is fragile and adding a dependency often results in having to tweak `files.swr` or
-`devenv.exe.config`, the latter of which is generated from the file named `devenv.urt.config.tt` in the VS source tree. The good
-thing is that regressions, be it a failure to compile an NGEN image or a failure to use an NGEN image, are reliably detected
-by the VS PR gates so they are fixed before MSBuild is inserted into the product.
-
-## NGEN image loading rules
-
-The Common Language Runtime can be finicky about allowing a native image to load. We usually speak of "NGEN rejections" where a native
-image has successfully been created but it cannot be used at run-time. When it happens, the CLR falls back to loading the IL assembly
-and JITting code on demand, leading to sub-optimal performance.
-
-One major reason why a native image is rejected is loading into the LoadFrom context. The rules are excruciatingly complex, but suffice
-it to say that when an assembly is loaded by `Assembly.LoadFrom`, it is automatically disqualified from having its native image used.
-This is bad news for any app with an add-in system where extension assemblies are loaded by path.
-
-## SDK resolvers
-
-One class of assemblies loaded by MSBuild by path are SDK resolvers. MSBuild scans the `SdkResolvers` subdirectory to discover
-the set of resolvers to use when evaluating projects. Extensible in theory, though in reality only a couple of resolvers actually
-exist. Because resolvers ship as part of VS, it is not difficult to make sure their assemblies are properly NGENed. The hard part is
-loading them with the regular `Assembly.Load` so the native images can be used. MSBuild cannot simply extend its probing path to
-include the relevant subdirectories of `SdkResolvers` because 1) It is outside of the app directory cone for amd64 and arm64 versions
-of `MSBuild.exe` and 2) Not all resolvers actually live under this directory; the system allows them to be placed anywhere.
-It is unfortunately also not straightforward to add a binding redirect with a [`codeBase`](https://learn.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/codebase-element)
-entry pointing to the right assemblies, because this requires knowing the exact assembly versions. 
-
-### Microsoft.DotNet.MSBuildSdkResolver
-
-This is the most-commonly-used resolver, capable of resolving "in-box" SDKs that ship with the .NET SDK and .NET SDK workloads. Since the resolver assembly
-is located at a known path relative to MSBuild and has very few dependencies, none of which are used anywhere else, we have decided to
-freeze the version of the resolver plus dependencies, so that their full names can be specified in `MSBuild.exe.config`, e.g.
-
-```xml
-    <dependentAssembly>
-      <assemblyIdentity name="Microsoft.DotNet.MSBuildSdkResolver" culture="neutral" publicKeyToken="adb9793829ddae60" />
-      <codeBase version="8.0.100.0" href=".\SdkResolvers\Microsoft.DotNet.MSBuildSdkResolver\Microsoft.DotNet.MSBuildSdkResolver.dll" />
-    </dependentAssembly>
-```
-
-Additionally, `MSBuild.exe.config` has the following entry, which enables us to refer to the resolver by simple name.
-
-```xml
-<qualifyAssembly partialName="Microsoft.DotNet.MSBuildSdkResolver" fullName="Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60" />
-```
-
-This has a small advantage compared to hardcoding `Microsoft.DotNet.MSBuildSdkResolver, Version=8.0.100.0, Culture=neutral, PublicKeyToken=adb9793829ddae60`
-directly in the code, as it can be modified to work in non-standard environments just by editing the app config appropriately.
-
-The resolver loading logic in MSBuild [has been updated](https://github.com/dotnet/msbuild/pull/9439) to call `Assembly.Load(AssemblyName)` where the `AssemblyName` specifies the
-simple name of the assembly, e.g. `Microsoft.DotNet.MSBuildSdkResolver`, as well as its `CodeBase` (file path). This way the CLR assembly
-loader will try to load the assembly into the default context first - a necessary condition for the native image to be used - and fall back
-to LoadFrom if the simple name wasn't resolved.
-
-### Microsoft.Build.NuGetSdkResolver
-
-The NuGet resolver has many dependencies and its version is frequently changing, so the technique used for `Microsoft.DotNet.MSBuildSdkResolver`
-does not apply in its current state. However, the NuGet team is [looking to address this](https://github.com/NuGet/Home/issues/11441) by:
-
-1) ILMerge'ing the resolver with its dependencies into a single assembly.
-2) Freezing the version of the assembly.
-
-When this happens, the cost of JITting `Microsoft.Build.NuGetSdkResolver` will be eliminated as well.
-
-## NuGet.Frameworks
-
-When evaluating certain property functions, MSBuild requires functionality from `NuGet.Frameworks.dll`, which is not part of MSBuild proper.
-The assembly is loaded lazily from a path calculated based on the environment where MSBuild is running and the functionality is invoked
-via reflection. Similar to the NuGet resolver, the version is changing and it is not easy to know it statically at MSBuild's build time.
-But, since there are only a handful of APIs used by MSBuild and they take simple types such as strings and versions, this has been
-addressed by loading the assembly into a separate AppDomain. The AppDomain's config file is created in memory on the fly to contain the
-right binding redirects, allowing MSBuild to use `Assembly.Load` and get the native image loaded if it exists.
-
-This approach has some small startup cost (building the config, creating AppDomain & a `MarshalByRefObject`) and a small run-time overhead
-of cross-domain calls. The former is orders of magnitude smaller that the startup hit of JITting and the latter is negligible as long as
-the types moved across the AppDomain boundary do not require expensive marshaling. Additionally, the requirement to execute code in multiple
-AppDomains necessitates the use of `LoaderOptimization.MultiDomain` for loading all assemblies domain-neutral. This may come with run-time
-cost for certain code patterns, although none has been measured in MSBuild scenarios.
-
-## Task assemblies
-
-This is the proverbial elephant in the room. MSBuild learns about tasks dynamically as it parses project files. The `UsingTask`
-element tends to specify the `AssemblyFile` attribute, pointing to the task assembly by path. Consequently MSBuild uses
-`Assembly.LoadFrom` and no native images are loaded. Even task assemblies located in the SDK are problematic because MSBuild is
-paired with an SDK on users machine at run-time. Unlike SDK resolvers and NuGet.Frameworks, which are part of the same installation
-unit, this is a true dynamic inter-product dependency. Additionally, the task API is complex and involves a lot of functionality
-provided to tasks via callbacks (e.g. logging) so the overhead of cross-domain calls may be significant. And that's assuming that
-suitable native images exist in the first place, something that both VS and SDK installers would need to handle (task assemblies
-in each installed SDK would need to be NGENed against each installed version of VS).
-
-Hosting task assemblies in separate AppDomains looks like a major piece of work with uncertain outcome. We haven't tried it yet
-and most task code is JITted.
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
deleted file mode 100644
index 2497ff6eb37..00000000000
--- a/documentation/ProjectReference-Protocol.md
+++ /dev/null
@@ -1,189 +0,0 @@
-# The `ProjectReference` Protocol
-
-The MSBuild engine doesn't have a notion of a “project reference”—it only provides the [`MSBuild` task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task) to allow cross-project communication.
-
-That's a powerful tool, but no one would want to have to specify how to build every single reference in every single project. The common targets introduce an item, `ProjectReference`, and a default process for building references declared via that item.
-
-Default protocol implementation:
-- https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CurrentVersion.targets
-- https://github.com/dotnet/msbuild/blob/main/src/Tasks/Microsoft.Common.CrossTargeting.targets
-
-## Projects that have references
-
-In its simplest form, a project need only specify the path to another project in a `ProjectReference` item. For example,
-
-```csproj
-<ItemGroup>
-  <ProjectReference Include="..\..\some\other\project.csproj" />
-</ItemGroup>
-```
-
-Importing `Microsoft.Common.targets` includes logic that consumes these items and transforms them into compile-time references before the compiler runs. 
-
-## Who this document is for
-
-This document describes that process, including what is required of a project to be referenceable through a `ProjectReference`. It is intended for MSBuild SDK maintainers, and those who have created a completely custom project type that needs to interoperate with other projects. It may also be of interest if you'd like to see the implementation details of references. Understanding the details should not be necessary to _use_ `ProjectReferences` in your project.
-
-## Targets related to consuming a reference
-
-The bulk of the work of transforming `ProjectReference` items into something suitable to feed the compiler is done by tasks listed in the `ResolveReferencesDependsOn` property defined in `Microsoft.Common.CurrentVersion.targets`.
-
-There are empty hooks in the default targets for
-
-* `BeforeResolveReferences`—run before the primary work of resolving references.
-* `AfterResolveReferences`—run after the primary work of resolving references.
-
-`AssignProjectConfiguration` runs when building in a solution context, and ensures that the right `Configuration` and `Platform` are assigned to each reference. For example, if a solution specifies (using the Solution Build Manager) that for a given solution configuration, a project should always be built `Release`, that is applied inside MSBuild in this target.
-
-`PrepareProjectReferences` then runs, ensuring that each referenced project exists (creating the item `@(_MSBuildProjectReferenceExistent)`).
-
-`_ComputeProjectReferenceTargetFrameworkMatches` calls `GetTargetFrameworks` in existent ProjectReferences and determines the parameters needed to produce a compatible build by calling the `AssignReferenceProperties` task for each reference that multitargets.
-
-`ResolveProjectReferences` does the bulk of the work, building the referenced projects and collecting their outputs.
-
-After the compiler is invoked, `GetCopyToOutputDirectoryItems` pulls child-project outputs into the current project to be copied to its output directory.
-
-When `Clean`ing the output of a project, `CleanReferencedProjects` ensures that referenced projects also clean.
-
-## Targets required to be referenceable
-
-These targets should exist in a project to be compatible with the common targets' `ProjectReference` (unless [marked with the `SkipNonexistentTargets='true'` metadatum](#targets-marked-with-skipnonexistenttargetstrue-metadatum)). Some are called only conditionally.
-
-These targets are all defined in `Microsoft.Common.targets` and are defined in Microsoft SDKs. You should only have to implement them yourself if you require custom behavior or are authoring a project that doesn't import the common targets.
-
-If implementing a project with an “outer” (determine what properties to pass to the real build) and “inner” (fully specified) build, only `GetTargetFrameworks` is required in the “outer” build. The other targets listed can be “inner” build only.
-
-* `GetTargetFrameworks` tells referencing projects what options are available to the build.
-  * It returns an item with the following metadata:
-    * `TargetFrameworks` indicating what TargetFrameworks are available in the project
-    * `TargetFrameworkMonikers` and `TargetPlatformMonikers` indicating what framework / platform the `TargetFrameworks` map to.  This is to support implicitly setting the target platform version (for example inferring that `net5.0-windows` means the same as `net5.0-windows7.0`) as well as treating the `TargetFramework` values [as aliases](https://github.com/NuGet/Home/issues/5154)
-    * Boolean metadata for `HasSingleTargetFramework` and `IsRidAgnostic`.
-    * `Platforms` indicating what platforms are available for the project to build as, and boolean metadata `IsVcxOrNativeProj` (used for [SetPlatform Negotiation](#setplatform-negotiation))
-  * The `GetReferenceNearestTargetFrameworkTask` (provided by NuGet) is responsible for selecting the best matching `TargetFramework` of the referenced project
-  * This target is _optional_. If not present, the reference will be built with no additional properties.
-  * **New** in MSBuild 15.5.  (`TargetFrameworkMonikers` and `TargetPlatformMonikers` metadata is new in MSBuild 16.8)
-  * It is possible to gather additional information from referenced projects.  See the below section on "Getting additional properties from referenced projects" for more information
-* `GetTargetFrameworkProperties` determines what properties should be passed to the “main” target for a given `ReferringTargetFramework`.
-  * **Deprecated** in MSBuild 15.5.
-  * New for MSBuild 15/Visual Studio 2017. Supports the cross-targeting feature allowing a project to have multiple `TargetFrameworks`.
-  * **Conditions**: only when metadata `SkipGetTargetFrameworkProperties` for each reference is not true.
-  * Skipped for `*.vcxproj` by default.
-  * This should return either
-    * a string of the form `TargetFramework=$(NearestTargetFramework);ProjectHasSingleTargetFramework=$(_HasSingleTargetFramework);ProjectIsRidAgnostic=$(_IsRidAgnostic)`, where the value of `NearestTargetFramework` will be used to formulate `TargetFramework` for the following calls and the other two properties are booleans, or
-    * an item with metadata `DesiredTargetFrameworkProperties` (key-value pairs of the form `TargetFramework=net46`), `HasSingleTargetFramework` (boolean), and `IsRidAgnostic` (boolean).
-* `GetTargetPath` should return the path of the project's output, but _not_ build that output.
-  * **Conditions**: this is used for builds inside Visual Studio, but not on the command line.
-  * It's also used when the property `BuildProjectReferences` is `false`, manually indicating that all `ProjectReferences` are up to date and shouldn't be (re)built.
-  * This should return a single item that is the primary output of the project, with metadata describing that output. See [`TargetPathWithTargetPlatformMoniker`](https://github.com/dotnet/msbuild/blob/080ef976a428f6ff7bf53ca5dd4ee637b3fe949c/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1834-L1842) for the default metadata.
-* **Default** targets should do the full build and return an assembly to be referenced.
-  * **Conditions**: this is _not_ called when building inside Visual Studio. Instead, Visual Studio builds each project in isolation but in order, so the path returned from `GetTargetPath` can be assumed to exist at consumption time.
-  * If the `ProjectReference` defines the `Targets` metadata, it is used. If not, no target is passed, and the default target of the reference (usually `Build`) is built.
-  * The return value of this target should be identical to that of `GetTargetPath`.
-* `GetNativeManifest` should return a manifest suitable for passing to the `ResolveNativeReferences` target.
-  * As of 15.7, this is _optional_. If a project does not contain a `GetNativeManifest` target, it will not be referencable by native projects but will not fail the build.
-* `GetCopyToOutputDirectoryItems` should return the outputs of a project that should be copied to the output of a referencing project.
-  * As of 15.7, this is _optional_. If a project does not contain a `GetCopyToOutputDirectoryItems` target, projects that reference it will not copy any of its outputs to their own output folders, but the build can succeed.
-* `Clean` should delete all outputs of the project.
-  * It is not called during a normal build, only during "Clean" and "Rebuild".
-
-### Targets Marked With `SkipNonexistentTargets='true'` Metadatum
-`GetTargetFrameworks` and `GetTargetFrameworksWithPlatformForSingleTargetFramework` are skippable if nonexistent since some project types (for example, `wixproj` projects) may not define them. See [this comment](https://github.com/dotnet/msbuild/blob/cc55017f88688cbe3f9aa810cdf44273adea76ea/src/Tasks/Microsoft.Managed.After.targets#L74-L77) for more details.
-
-## Other protocol requirements
-
-As with all MSBuild logic, targets can be added to do other work with `ProjectReference`s.
-
-In particular, NuGet depends on being able to identify referenced projects' package dependencies, and calls some targets that are imported through `Microsoft.Common.targets` to do so. At the time of writing this this is in [`NuGet.targets`](https://github.com/NuGet/NuGet.Client/blob/79264a74262354c1a8f899c2c9ddcaff58afaf62/src/NuGet.Core/NuGet.Build.Tasks/NuGet.targets).
-
-`Microsoft.AppxPackage.targets` adds a dependency on the target `GetPackagingOutputs`.
-
-## Getting additional properties from referenced projects
-
-As of MSBuild 16.10, it is possible to gather additional properties from referenced projects.  To do this, the referenced project should declare an `AdditionalTargetFrameworkInfoProperty` item for each property that should be gathered for referencing projects.  For example:
-
-```xml
-  <ItemGroup>
-    <AdditionalTargetFrameworkInfoProperty Include="SelfContained"/>
-    <AdditionalTargetFrameworkInfoProperty Include="_IsExecutable"/>
-  </ItemGroup>
-```
-
-These properties will then be gathered via the `GetTargetFrameworks` call.  They will be available to the referencing project via the `AdditionalPropertiesFromProject` metadata on the `_MSBuildProjectReferenceExistent` item.  The `AdditionalPropertiesFromProject` value will be an XML string which contains the values of the properties for each `TargetFramework` in the referenced project.  For example:
-
-> :warning: This format is being changed. Soon, the schema will replace `<net5.0>` with `<TargetFramework Name="net5.0">`. You can opt into that behavior early by setting the `_UseAttributeForTargetFrameworkInfoPropertyNames` property to true. This property will have no effect after the transition is complete.
-
-```xml
-<AdditionalProjectProperties>
-  <net5.0>
-    <SelfContained>true</SelfContained>
-    <_IsExecutable>true</_IsExecutable>
-  </net5.0>
-  <net5.0-windows>
-    <SelfContained>false</SelfContained>
-    <_IsExecutable>true</_IsExecutable>
-  </net5.0-windows>
-</AdditionalProjectProperties>
-```
-
-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.
-
-## SetPlatform Negotiation
-As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. This includes a new target and task to determine what the `SetPlatform` metadata should be, or whether to undefine the platform so the referenced project builds with its default platform.
-
-* `_GetProjectReferenceTargetFrameworkProperties` target performs the majority of the work for assigning `SetPlatform` metadata to project references.
-  * Calls the `GetCompatiblePlatform` task, which is responsible for negotiating between the current project's platform and the platforms of the referenced project to assign a `NearestPlatform` metadata to the item.
-  * Sets or undefines `SetPlatform` based on the `NearestPlatform` assignment from `GetCompatiblePlatform`
-  * This target explicitly runs after `_GetProjectReferenceTargetFrameworkProperties` because it needs to use the `IsVcxOrNativeProj` and `Platforms` properties returned by the `GetTargetFrameworks` call.
-
-Note: If a `ProjectReference` has `SetPlatform` metadata defined already, the negotiation logic is skipped over.
-### Impact on the build
-In addition to the above task and target, `.vcxproj` and `.nativeproj` projects will receive an extra MSBuild call to the `GetTargetFrameworks` target. Previously, TargetFramework negotiation skipped over these projects because they could not multi-target in the first place. Because SetPlatform negotiation needs information given from the `GetTargetFrameworks` target, it is required that the `_GetProjectReferenceTargetFrameworkProperties` target calls the MSBuild task on the ProjectReference.
-
-This means most projects will see an evaluation with no global properties defined, unless set by the user.
-
-### How To Opt In
-First, set the property `EnableDynamicPlatformResolution` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:
-
-```xml
-<Project>
-  <PropertyGroup>
-    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
-  </PropertyGroup>
-</Project>
-```
-
-If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.
-
-Next, every referenced project is required to define a `Platforms` property, where `Platforms` is a semicolon-delimited list of platforms that project could build as. For `.vcxproj` or `.nativeproj` projects, `Platforms` is constructed from the `ProjectConfiguration` items that already exist in the project. For managed SDK projects, the default is `AnyCPU`. Managed non-SDK projects need to define this manually.
-
-Lastly, a `PlatformLookupTable` may need to be defined for more complex scenarios. A `PlatformLookupTable` is a semicolon-delimited list of mappings between platforms. `<PlatformLookupTable>Win32=x86</PlatformLookupTable>`, for example. This means that when the current project is building as `Win32`, it will attempt to build the referenced project as x86. This property is **required** when a managed AnyCPU project references an unmanaged project because `AnyCPU` does not directly map to an architecture-specific platform. You can define the table in two ways:
-
-1. A standard property within the current project, in a Directory.Build.props/targets
-2. Metadata on the `ProjectReference` item. This option takes priority over the first to allow customizations per `ProjectReference`.
-
-### References between managed and unmanaged projects
-Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as. References between managed and unmanaged projects also get a default lookup table that can be opted out of by setting the property `UseDefaultPlatformLookupTables` to false. See the table below for details.
-
-Note: Defining a `PlatformLookupTable` overrides the default mapping.
-| Project Reference Type | `PlatformLookupTable` Required? | Notes |
-| :--  | :-: | :-: |
-| Unmanaged -> Unmanaged | No |  |
-| Managed -> Managed | No |  |
-| Unmanaged -> Managed | Optional | Uses default mapping: `Win32=x86` |
-| Managed -> Unmanaged | **Yes** when the project is AnyCPU | Uses default mapping: `x86=Win32` |
-
-Example:
-Project A: Managed, building as `AnyCPU`, has a `ProjectReference` on Project B.
-Project B: Unmanaged, has `$(Platforms)` constructed from its `Platform` metadata from its `ProjectConfiguration` items, defined as `x64;Win32`.
-
-Because `AnyCPU` does not map to anything architecture-specific, a custom mapping must be defined. Project A can either:
-1. Define `PlatformLookupTable` in its project or a Directory.Build.props as `AnyCPU=x64` or `AnyCPU=Win32`.
-2. Define `PlatformLookupTable` as metadata on the `ProjectReference` item, which would take priority over a lookup table defined elsewhere.
-     *  When only one mapping is valid, you could also directly define `SetPlatform` metadata as `Platform=foo`. This would skip over most negotiation logic.
-
-Example of project A defining a lookup table directly on the `ProjectReference`:
-```xml
-<ItemGroup>
-  <ProjectReference Include="B.csproj" PlatformLookupTable="AnyCPU=Win32">
-</ItemGroup>
-```
diff --git a/documentation/README.md b/documentation/README.md
deleted file mode 100644
index 199be8361fb..00000000000
--- a/documentation/README.md
+++ /dev/null
@@ -1,92 +0,0 @@
-Welcome to MSBuild docs!
-
-The folder contains collection of docs and references for MSBuild, detailed information on how to work with this repo, and covers in-depth technical topics related to implementation.
-
-## Getting Started
-
-* [What is MSBuild?](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild)
-* Building Testing and Debugging
-  * [Full Framework MSBuild](wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md)
-  * [.Net Core MSBuild](wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md)
-  * [macOS](wiki/Mac-Debugging.md)
-
-* [MSBuild resources](wiki/MSBuild-Resources.md)
-* [MSBuild tips & tricks](wiki/MSBuild-Tips-&-Tricks.md)
-
-## NuGet packages
-
-* [General information](consuming-nuget-package.md)
-
-## Release information
-
-* [Changelog](Changelog.md)
-* [Release process](release.md)
-* [Change waves](wiki/ChangeWaves.md)
-* [Interactions with the internal repository](wiki/Interactions-with-the-internal-repository.md)
-
-## Development and contributing
-
-* [Providing binary logs for investigation](wiki/Providing-Binary-Logs.md)
-* [Contributing code](wiki/Contributing-Code.md)
-   * [Contributing tasks](wiki/Contributing-Tasks.md)
-* [Error codes](assigning-msb-error-code.md)
-* [Deploying built MSBuild](Deploy-MSBuild.md)
-* [Events emitted by MSBuild](specs/event-source.md)
-* [Change waves (for developers)](wiki/ChangeWaves-Dev.md)
-* [GitHub labels](wiki/Labels.md)
-* [Localization](wiki/Localization.md)
-
-### Problems?
-
-* [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)
-* [Controling References Behavior](wiki/Controlling-Dependencies-Behavior.md)
-* [Something's wrong in my build](wiki/Something's-wrong-in-my-build.md)
-* [Some gotchas around the Microsoft.Build.Framework project/assembly](wiki/Microsoft.Build.Framework.md)
-* [GAC and MSBuild](wiki/UnGAC.md)
-* [When globbing returns original filespec](WhenGlobbingReturnsOriginalFilespec.md)
-
-## In-depth tech topics
-
-* [Reserved and built-in properties](Built-in-Propeties.md)
-* [`ProjectReference`](ProjectReference-Protocol.md)
-* [MSBuild Server](MSBuild-Server.md)
-* [Low priority nodes](specs/low-priority-switch.md)
-* [Threading in MSBuild worker nodes](specs/threading.md)
-* [Nodes orchestration](wiki/Nodes-Orchestration.md)
-* [Project cache plugin](specs/project-cache.md)
-* [Support for remote host objects](specs/remote-host-object.md)
-* [Static graph](specs/static-graph.md)
-* [Single project isolated builds: implementation details](specs/single-project-isolated-builds.md)
-* [Task isolation](specs/task-isolation-and-dependencies.md)
-* [Target maps](wiki/Target-Maps.md)
-* [Managing parallelism in MSBuild](specs/resource-management.md)
-* [SDK resolution](specs/sdk-resolvers-algorithm.md)
-* [RAR core scenarios](specs/rar-core-scenarios.md)
-
-### Tasks
-
-* [`ResolveAssemblyReference`](wiki/ResolveAssemblyReference.md)
-
-### Evaluation
-
-* [Evaluation profiling](evaluation-profiling.md)
-
-### Logging
-
-* [Binary log](wiki/Binary-Log.md)
-* [Terminal logger: how to opt in](terminallogger/Opt-In-Mechanism.md)
-
-## Archived Designs
-* [Resolve Assembly Reference as a service](specs/rar-as-service.md)
-   * Prototype: https://github.com/dotnet/msbuild/issues/6193
-
-## Proposed Designs
-* [Packages Sourcing](specs/proposed/interactive-package-references.md)
-* [Secrets Metadata](specs/proposed/security-metadata.md)
-
-## Community contributions
-
-* [MSBuild overview](Contributions/MSBuild-overview.md)
-* [Solution parser](Contributions/solution-parser.md)
-
-Note: community contributions has documentation that was contributed by developers or users, but it might not been fully vetted for accuracy and correctness. Explanations in this folder may not be fully accurate, but can still be very informative for developing an understanding of MSBuild or a specific problem.
\ No newline at end of file
diff --git a/documentation/WhenGlobbingReturnsOriginalFilespec.md b/documentation/WhenGlobbingReturnsOriginalFilespec.md
deleted file mode 100644
index d824eeeddcc..00000000000
--- a/documentation/WhenGlobbingReturnsOriginalFilespec.md
+++ /dev/null
@@ -1,12 +0,0 @@
-# When globbing returns original filespec
-
-Original itemspec is returned when:
-- illegal filespec contains
-	- both wildcards and escaped wildcards (`%2a`, `%3f`)
-	- illegal file chars
-	- `...`
-	- a `:` anywhere but the second character
-	- a `..` after a wildcard
-	- a path fragment which contains `**` and other characters (e.g. `/**f/`)
-- Any IO related exception is thrown during file walking: https://github.com/dotnet/msbuild/blob/c1d949558b4808ca9381d09af384b66b31cde2b2/src/Shared/ExceptionHandling.cs#L125-L140
-  - System.UnauthorizedAccessException and System.Security.SecurityException from directory enumeration (Directory.EnumerateFileSystemEntries) are ignored, and the files / directories which cause it are excluded from the results.
diff --git a/documentation/assigning-msb-error-code.md b/documentation/assigning-msb-error-code.md
deleted file mode 100644
index 2801df217ed..00000000000
--- a/documentation/assigning-msb-error-code.md
+++ /dev/null
@@ -1,85 +0,0 @@
-# MSBuild error codes
-
-User-facing errors encountered in MSBuild should have an error code in the form of a four-digit number prefixed by `MSB`, for example `MSB3021: Unable to copy file`.
-
-Errors that should not be user-facing (because they're a result of a problem internal to MSBuild like an `InternalErrorException`) do not need an error code.
-
-This code is defined in the `.resx` file that includes the string representation of the error. For example, [MSB3021 is defined as](https://github.com/dotnet/msbuild/blob/ea30bf10ad0d7ab37ea54ab9d98fe39a5d97bfb0/src/Tasks/Resources/Strings.resx#L234-L237):
-
-```xml
-  <data name="Copy.Error">
-    <value>MSB3021: Unable to copy file "{0}" to "{1}". {2}</value>
-    <comment>{StrBegin="MSB3021: "}</comment>
-  </data>
-```
-
-This is consumed with a method that extracts the error code from the string and ensures that the appropriate metadata is applied to the error event:
-
-```c#
-Log.LogErrorWithCodeFromResources("Copy.Error", SourceFiles[i].ItemSpec, DestinationFolder.ItemSpec, e.Message);
-```
-
-MSBuild error codes must be unique (ideally across all versions of MSBuild).
-
-## Error code ranges
-
-MSBuild error codes are divided into ranges referred to as buckets. The initial digit of the code is the coarsest bucket:
-
-* **`MSB1xxx` errors** are problems encountered when handling the MSBuild command line.
-* **`MSB2xxx` errors** are problems encountered in the (deprecated) `Microsoft.Build.Conversion` process.
-* **`MSB3xxx` errors** are problems encountered in tasks shipped as part of `Microsoft.Build.Tasks.Core.dll`.
-* **`MSB4xxx` errors** are problems encountered in the MSBuild engine.
-* **`MSB5xxx` errors** are problems encountered in code that is shared between multiple MSBuild assemblies.
-* **`MSB6xxx` errors** are problems encountered in `Microsoft.Build.Utilities`.
-
-## Creating a new error code
-
-To create a new error code, first find the `Strings.resx` file for the assembly in which you plan to produce the error.
-
-A comment at the bottom of the `.resx` will have an index of the error codes it contains and possibly a list of retired error codes, for example
-
-```text
-The engine message bucket is: MSB4001 - MSB4999
-
-MSB4128 is being used in FileLogger.cs (can't be added here yet as strings are currently frozen)
-MSB4129 is used by Shared\XmlUtilities.cs (can't be added here yet as strings are currently frozen)
-
-Next message code should be MSB4259.
-
-Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
-    <none>
-
-Retired codes, which have already shipped, but are no longer needed and should not be re-used:
-MSB4056
-MSB4005
-...
-
-Don't forget to update this comment after using a new code.
-```
-
-### Finding a code number
-
-You should select the next message code mentioned in the comment, after doing a repo-wide search to make sure it's not already in use. If it is, increment the number in the comment and try again.
-
-The MSB3xxx bucket for Tasks is subdivided into buckets for each individual task. If a bucket is exhausted, allocate another bucket range for that task with the comment `Task: {whatever} overflow` and allocate a new code within that range.
-
-### Adding a new error
-
-After finding a not-in-use-or-retired error number, add a new resource with a meaningful name whose string begins with that error, a colon, and a space. Add this in the resx file in numeric order.
-
-```xml
-  <data name="FeatureArea.DescriptiveName">
-    <value>MSBxxxx: User-facing description of the error. Use {0} specifiers if you will need to fill in values at runtime.</value>
-    <!-- Only if necessary:
-    <comment>LOCALIZATION: Notes to translators. Mention the nature of {} blocks, and any key words or phrases that might get mistranslated.</comment>
-     -->
-  </data>
-```
-
-Then use the new resource's name in code when throwing or logging the error.
-
-### Localization
-
-Error _codes_ are never localized, but the text in the error resource will be localized into many languages. After adding a new error resource (as with any resource change), run a full build to generate placeholder localizations in `*.xlf` files. The strings will be translated by a localization team.
-
-This follows the overall repo [localization](wiki/Localization.md) process.
diff --git a/documentation/consuming-nuget-package.md b/documentation/consuming-nuget-package.md
deleted file mode 100644
index 71712556105..00000000000
--- a/documentation/consuming-nuget-package.md
+++ /dev/null
@@ -1,52 +0,0 @@
-# Consuming MSBuild NuGet packages
-
-The MSBuild team currently publishes five NuGet packages.  Our packages are published to NuGet.org
-
-| Package ID    | URL      | Latest Version   |
-| ------------- |-------------| -----|
-| Microsoft.Build.Framework      | https://www.nuget.org/Packages/Microsoft.Build.Framework | [![Microsoft.Build.Framework package](https://img.shields.io/nuget/vpre/Microsoft.Build.Framework.svg)](https://www.nuget.org/Packages/Microsoft.Build.Framework) |
-| Microsoft.Build.Utilities.Core      | https://www.nuget.org/Packages/Microsoft.Build.Utilities.Core | [![Microsoft.Build.Utilities.Core package](https://img.shields.io/nuget/vpre/Microsoft.Build.Utilities.Core.svg)](https://www.nuget.org/Packages/Microsoft.Build.Utilities.Core) |
-| Microsoft.Build.Tasks.Core      | https://www.nuget.org/Packages/Microsoft.Build.Tasks.Core | [![Microsoft.Build.Tasks.Core package](https://img.shields.io/nuget/vpre/Microsoft.Build.Tasks.Core.svg)](https://www.nuget.org/Packages/Microsoft.Build.Tasks.Core) |
-| Microsoft.Build      | https://www.nuget.org/Packages/Microsoft.Build | [![Microsoft.Build package](https://img.shields.io/nuget/vpre/Microsoft.Build.svg)](https://www.nuget.org/Packages/Microsoft.Build) |
-| Microsoft.Build.Runtime      | https://www.nuget.org/Packages/Microsoft.Build.Runtime | [![Microsoft.Build.Runtime package](https://img.shields.io/nuget/vpre/Microsoft.Build.Runtime.svg)](https://www.nuget.org/Packages/Microsoft.Build.Runtime) |
-
-## Microsoft.Build.Framework
-
-This package contains `Microsoft.Build.Framework.dll`, which defines [fundamental types](https://docs.microsoft.com/dotnet/api/microsoft.build.framework) used in MSBuild's API and extensibility model.
-
-## Microsoft.Build.Utilities.Core
-
-This package contains the `Microsoft.Build.Utilities.Core.dll` assembly which makes available items in the [Microsoft.Build.Utilities](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities) namespace.
-
-## Microsoft.Build.Tasks.Core
-
-This package contains implementations of [commonly-used MSBuild
-tasks](https://docs.microsoft.com/visualstudio/msbuild/msbuild-task-reference)
-that ship with MSBuild itself.
-
-Most developers do not need to reference this package. We recommend that MSBuild
-task developers reference the `Microsoft.Build.Utilities.Core` package and
-implement the abstract class
-[`Task`](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities.task)
-or
-[`ToolTask`](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities.tooltask).
-
-## Microsoft.Build
-
-This package contains the `Microsoft.Build.dll` assembly which makes available items in the [Microsoft.Build.Construction](https://msdn.microsoft.com/library/microsoft.build.construction.aspx),
-[Microsoft.Build.Evaluation](https://msdn.microsoft.com/library/microsoft.build.evaluation.aspx), and [Microsoft.Build.Execution](https://msdn.microsoft.com/library/microsoft.build.execution.aspx) namespaces.
-
-Developers should reference this package to create, edit, evaluate, or build MSBuild projects.
-
-## Microsoft.Build.Runtime
-
-This package delivers a complete executable copy of MSBuild. Reference this
-package only if your application needs to load projects or execute in-process
-builds without requiring installation of MSBuild. Successfully evaluating
-projects using this package requires aggregating additional components (like the
-compilers) into an application directory.
-
-🗒️ NOTE: if you are building an application that wants to use MSBuild to
-evaluate or build projects, you will generally not need this package. Instead,
-use [MSBuildLocator](https://aka.ms/msbuild/locator) to use a complete toolset
-provided by the .NET SDK or Visual Studio.
diff --git a/documentation/deprecated/Building-Testing-and-Debugging-on-Mono-MSBuild.md b/documentation/deprecated/Building-Testing-and-Debugging-on-Mono-MSBuild.md
deleted file mode 100644
index c78f554b272..00000000000
--- a/documentation/deprecated/Building-Testing-and-Debugging-on-Mono-MSBuild.md
+++ /dev/null
@@ -1,32 +0,0 @@
-MSBuild can be successfully built on Windows, OS X 10.11, Ubuntu 14.04, and Ubuntu 16.04.
-
-Mono maintains a fork of msbuild (for now) at `https://github.com/mono/msbuild/`. You can clone that and use the `xplat-master` branch or `mono-2018-04` for the next release branch.
-
-# Unix #
-
-**Required packages for OSX & Ubuntu**
-
-MSBuild requires a stable version of [Mono](https://www.mono-project.com/download/stable/) to build itself.
-
-## Build process ##
-
-```make```
-
-If you encounter errors, see [Something's wrong in my build](Something's-wrong-in-my-build.md)
-
-## Tests ##
-
-```make test-mono```
-
-## Installing ##
-
-`./install-mono-prefix.sh </your/mono/prefix>`
-
-## Getting Mono MSBuild binaries without building the code ##
-The best way to get Mono MSBuild for OSX/macOS is to get the official [Mono package](https://www.mono-project.com/download/stable/#download-mac). After installing it, you can run `msbuild`.
-<br/>
-For Linux, you can install mono and msbuild from [here](https://www.mono-project.com/download/stable/#download-lin).
-
-## Debugging
-
-See debugging options [here](./Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#Debugging-MSBuild).
\ No newline at end of file
diff --git a/documentation/evaluation-profiling.md b/documentation/evaluation-profiling.md
deleted file mode 100644
index d1064fc42eb..00000000000
--- a/documentation/evaluation-profiling.md
+++ /dev/null
@@ -1,40 +0,0 @@
-# MSBuild evaluation profiling
-
-MSBuild 15.6 and higher contains an evaluation profiler, which can help analyze which parts of a project (and any .targets/etc that it imports) are taking the most time to evaluate.
-
-The profiler is enabled when passing `/profileevaluation:<filename>` as a command-line argument to MSBuild. After the build, the specified file will contain a profiler report. If the specified filename does not end in `.md`, it will be a tab-separated value (TSV) table suitable for loading into a spreadsheet. If the filename ends in `.md`, it will be a Markdown file that looks like the following:
-
-Pass|File|Line #|Expression|Inc (ms)|Inc (%)|Exc (ms)|Exc (%)|#|Bug
----|---|---:|---|---:|---:|---:|---:|---:|---
-Total Evaluation||||650|100%|17|2.7%|1|
-Initial Properties (Pass 0)||||5|0.8%|5|0.8%|1|
-Properties (Pass 1)||||360|55.4%|3|0.4%|1|
-ItemDefinitionGroup (Pass 2)||||9|1.4%|0|0%|1|
-Items (Pass 3)||||63|9.7%|1|0.2%|1|
-Lazy Items (Pass 3.1)||||173|26.6%|29|4.5%|1|
-UsingTasks (Pass 4)||||8|1.2%|8|1.2%|1|
-Targets (Pass 5)||||15|2.3%|1|0.2%|1|
-Properties (Pass 1)|MVC.csproj|0|`<Import Project="Sdk.props" Sdk="Microsoft.NET.Sdk.Web" />`|351|54%|76|11.7%|1|
-Items (Pass 3)|Microsoft.NETCore.App.props|8|`<PackageConflictPlatformManifests Include="$(MSBuildThisFileDirectory)Microsoft.NETCore.App.Platform...`|37|5.7%|37|5.7%|1|
-Properties (Pass 1)|Microsoft.Common.CurrentVersion.targets|83|`<FrameworkPathOverride Condition="'$(FrameworkPathOverride)' == ''" >$([Microsoft.Build.Utilities.To...`|32|4.9%|32|4.9%|1|
-Lazy Items (Pass 3.1)|Microsoft.NET.Sdk.DefaultItems.props|26|`<Compile Include="**/*$(DefaultLanguageSourceExtension)" Exclude="$(DefaultItemExcludes);$(DefaultEx...`|31|4.7%|31|4.7%|1|
-Properties (Pass 1)|Microsoft.Common.targets|114|`<Import Project="$(CommonTargetsPath)"  />`|95|14.6%|23|3.5%|1|
-Lazy Items (Pass 3.1)|Microsoft.NET.Sdk.Web.ProjectSystem.props|29|`<Content Include="wwwroot\**" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExcludes...`|17|2.6%|17|2.6%|1|
-Properties (Pass 1)|Microsoft.Common.CurrentVersion.targets|92|`<TargetPlatformSdkPath Condition="'$(TargetPlatformSdkPath)' == ''" >$([Microsoft.Build.Utilities.To...`|15|2.3%|15|2.3%|1|
-Lazy Items (Pass 3.1)|Microsoft.NET.Sdk.DefaultItems.targets|156|`Condition="'%(LinkBase)' != ''")`|12|1.9%|12|1.9%|1|
-Properties (Pass 1)|Microsoft.Common.props|15|`Condition="'$(ImportByWildcardBeforeMicrosoftCommonProps)' == ''")`|12|1.9%|12|1.9%|1|
-Properties (Pass 1)|Microsoft.Common.props|63|`<Import Project="$(MSBuildProjectExtensionsPath)$(MSBuildProjectFile).*.props" Condition="'$(ImportP...`|18|2.8%|12|1.8%|1|
-Properties (Pass 1)|Microsoft.CSharp.targets|168|`<Import Project="$(CSharpTargetsPath)"  />`|164|25.2%|11|1.7%|1|
-Properties (Pass 1)|MVC.csproj.nuget.g.targets|7|`<Import Project="$(NuGetPackageRoot)netstandard.library\2.0.0\build\netstandard2.0\NETStandard.Libra...`|14|2.2%|11|1.7%|1|
-Lazy Items (Pass 3.1)|Microsoft.NET.Sdk.DefaultItems.props|30|`<None Include="**/*" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)"  />`|10|1.6%|10|1.6%|1|
-Properties (Pass 1)|Sdk.props|29|`<Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props"  />`|56|8.6%|10|1.5%|1|
-Items (Pass 3)|Microsoft.Common.CurrentVersion.targets|368|`Condition="'$(OutputType)' != 'winmdobj' and '@(_DebugSymbolsIntermediatePath)' == ''")`|9|1.4%|9|1.4%|1|
-ItemDefinitionGroup (Pass 2)|Microsoft.Common.CurrentVersion.targets|1661|`<ProjectReference ><!-- Target to build in the project reference; by default, this property is blank...`|8|1.3%|8|1.3%|1|
-Lazy Items (Pass 3.1)|Microsoft.Common.CurrentVersion.targets|369|`<_DebugSymbolsOutputPath Include="@(_DebugSymbolsIntermediatePath-&gt;'$(OutDir)%(Filename)%(Extensi...`|8|1.2%|8|1.2%|1|
-Lazy Items (Pass 3.1)|Microsoft.NET.Sdk.Web.ProjectSystem.props|32|`<Content Include="**\*.json" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExcludes)...`|8|1.2%|8|1.2%|1|
-Properties (Pass 1)|MVC.csproj.nuget.g.targets|9|`<Import Project="C:\Program Files\dotnet\sdk\NuGetFallbackFolder\microsoft.extensions.configuration....`|8|1.2%|7|1.1%|1|
-Lazy Items (Pass 3.1)|Microsoft.NET.Sdk.Web.ProjectSystem.props|39|`<Compile Remove="wwwroot\**"  />`|7|1.1%|7|1.1%|1|
-Lazy Items (Pass 3.1)|Microsoft.NET.Sdk.Web.ProjectSystem.props|31|`<Content Include="**\*.cshtml" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExclude...`|7|1.1%|7|1.1%|1|
-Lazy Items (Pass 3.1)|Microsoft.NET.Sdk.Web.ProjectSystem.props|30|`<Content Include="**\*.config" CopyToPublishDirectory="PreserveNewest" Exclude="$(DefaultItemExclude...`|7|1.1%|7|1.1%|1|
-Lazy Items (Pass 3.1)|Microsoft.NET.Sdk.DefaultItems.props|27|`<EmbeddedResource Include="**/*.resx" Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFold...`|7|1.1%|7|1.1%|1|
-Properties (Pass 1)|Sdk.targets|41|`<Import Project="$(LanguageTargets)"  />`|171|26.2%|7|1%|1|
diff --git a/documentation/release.md b/documentation/release.md
deleted file mode 100644
index 7ef016408f5..00000000000
--- a/documentation/release.md
+++ /dev/null
@@ -1,19 +0,0 @@
-# MSBuild release process
-
-This is a description of the steps required to release MSBuild. It is **incomplete**; when something not present here is discovered to be required it should be added.
-
-## Final branding/versioning
-
-To produce packages without a `-prerelease` suffix, we need to specify `<DotNetFinalVersionKind>release</DotNetFinalVersionKind>` (see the [Arcade versioning docs]). This is ideally done on the same line as the version specification so that it causes a Git merge conflict when merging to the next release's branch. See [#6902](https://github.com/dotnet/msbuild/pull/6902) for an example.
-
-[Arcade versioning docs]: https://github.com/dotnet/arcade/blob/31cecde14e1512ecf60d2d8afb71fd240919f4a8/Documentation/CorePackages/Versioning.md
-
-## Public API
-
-As of [#7018](https://github.com/dotnet/msbuild/pull/7018), MSBuild uses a Roslyn analyzer to ensure compatibility with assemblies compiled against older versions of MSBuild. The workflow of the analyzer is:
-
-1. The analyzer keeps the `PublicAPI.Unshipped.txt` files updated.
-2. New API surface goes into `PublicAPI.Unshipped.txt`.
-3. At release time, we must manually promote the `Unshipped` public API to `Shipped`.
-
-That is a new step in our release process for each formal release (including patch releases if they change API surface).
diff --git a/documentation/specs/archive/rar-as-service.md b/documentation/specs/archive/rar-as-service.md
deleted file mode 100644
index 83d2a0d1b2f..00000000000
--- a/documentation/specs/archive/rar-as-service.md
+++ /dev/null
@@ -1,111 +0,0 @@
-# Resolve Assembly Reference as Service Design
-
-This document describes Resolve Assembly Reference as a Service
-
-# Background
-
-[MSBuild](https://docs.microsoft.com/visualstudio/msbuild/msbuild?view=vs-2019) is a universal build engine, used for building pretty much everything in the Microsoft world. It is available on command line (msbuild, [dotnet build](https://docs.microsoft.com/dotnet/core/tools/dotnet-build)), runs under the covers when building projects and solutions in Visual Studio, and is used as the local build engine in "higher-order" distributed build systems. Essentially all .NET applications use MSBuild as their primary build engine.
-
-RAR is the acronym behind ResolveAssemblyReference (an MSBuild task) and ResolveAssemblyReferences (an MSBuild target). RAR is used in all .NET builds. Quoting the official documentation, RAR "_Determines all assemblies that depend on the specified assemblies, including second and nth-order dependencies._"
-
-The RAR task has become very complex and slow over the years. It tends to rank high on the list of MSBuild's performance bottlenecks. There is an inherent cost to walking the assembly reference graph and computing the dependency closure, especially in terms of I/O operations. To address this, the task internally maintains caches, both in-memory and on disk. While it alleviates the problem somewhat, it is still a suboptimal solution because
-
-1. The task runs in build nodes which are generally created as separate processes, one per logical CPU, so the in-memory state is duplicated.
-2. Build nodes have limited lifetime and the in-memory state is lost when they die.
-3. No state exists when the task runs for the given project for the first time.
-
-    *NOTE:* This is tracked by issue [#5247](https://github.com/dotnet/msbuild/issues/5247).
-
-There was already an attempt to introduce RAR as a service to MSBuild ([#3914](https://github.com/dotnet/msbuild/pull/3914)). This PR was not completed mainly because of discontinued development of Bond, which is in that PR used as method of communication between nodes.
-
-# Design
-
-![](assets/rar-lifetime.png)
-
-_Figure 1 Rough diagram of lifetime of service_
-
-## Lifetime of service
-
-### Connect to RAR node
-
-Connecting to the RAR node will not require any discovery of processes on computer. The algorithm will follow these steps:
-
-1. Get expected node name, which will be based on the current setting of node. The name format is described in `Start new node`.
-2. Setup named pipe. The construction of named pipe may differ between platforms (usage of different API for construction of the pipe object).
-3. Try to connect to the node.
-
-If the connection is successful, we can use this connection for execution of RAR task. The node is guaranteed to have all required properties since they must be encoded in name of the RAR node.
-
-### Start new node
-
-This step will create new process which will act as RAR node. It will also pass necessary information to the node to know what its settings are (reusable, ...). Node will be another instance of the MSBuild.exe which will have set parameter **nodeMode** to some specific value (it should be `/nodeMode:3`). 
-
-We will use named-pipe exclusivity to ensure we don't create multiple RAR nodes at once. Its name must encode whether it is the user's only RAR node, including user name, administrator privileges, and some initial settings for the node. Such a name could be: `MSBuild.RAR.ostorc.7`, where **MSBuild.RAR** is its prefix, **ostorc** is the user who called MSBuild, and **7** represents encoded settings (flag enum).
-
-RAR Node will adopt existing MSBuild infrastructure code, NodeProviderOutOfProcTaskHost and related, used for invoking tasks out of process.
-
-This code already solved many aspect of 'Out of process task invocation':
-- serialization of task inputs and outputs
-- distributed logging
-- environmental variables
-- current directory path
-- current culture
-- cancellation
-- etc...
-
-### Execute RAR task
-
-Execution should be the same as it is now.
-
-There is already some layer of separation between Task interface and actual execution method. We will leverage this, and put the decision logic if to run locally or not into the "wrapper" method and so we will not have to modify this and in server-side execution we will directly call the internal execution method.
-
-#### RAR Concurrency
-
-There is one big concern and that is how to handle multiple requests at once. As right now, RAR task is not prepared for multi-thread use.
-
-One of the biggest challenges with RAR as service, is to make execution and caching of RAR task thread-safe, since in most cases there will be multiple clients requesting data from it at once.
-
-So far, we have identified following areas that have to be addressed to allow concurrent execution of RAR tasks:
-
-- thread safety (static variables, shared data structures, caching, ...)
-- environmental variables virtualization
-- current directory virtualization
-- current culture isolation
-
-### Shutdown RAR node
-
-If the user does not want the node to be reused, we have the ensure that node will be killed after the build ends. This should be done after the main MSBuild node finishes building.
-
-The RAR node, also has to support accepting of already established commands for MSBuild nodes (for example Shutdown command). This will be done by creating two pipes inside node, one will be for communication about RAR commands and second one for the servicing communication.
-
-### Execute task in MSBuild node
-
-User opted out of using the RAR nodes so we will execute the RAR task in the MSBuild node (as it is right now).
-
-### Other
-
-The new RAR node will not count toward total maximum CPU count specified by _/maxCpuCount_ switch, since the RAR task is taxing on IO operations not so much on CPU time. If we took one node from each instance of MSBuild it would lead to drastic decrease in performance.
-
-The RAR task will be affected by the _/m_ switch. When we run in single node mode, it will implicitly say that we want to run the task inside current process. User would have to explicitly say that they want to use the RAR node.
-
-__NOTE:__ The behavior described above depend on fact that the feature is opt-out (is active by default). If not, the paragraph above is meaningless. This has to be yet decided/clarified.
-
-## Communication
-
-The communication between nodes should be same as current cross node communication. RAR service will allow multiple net-pipe clients, each client session handled in separate thread.
-
-## RAR service instrumentation
-
-RAR will use same instrumentation infrastructure leveraged by standard MSBuild nodes. We will make sure we log all important events needed to measure, maintain and troubleshoot RAR service.
-
-Instrumentation of RAR task execution will not change and will be handled by Out of process task infrastructure.
-
-# Non-Goals
-
-- File watchers: using them would decrease required IO operations when checking disc changes
-- Aggressive pre-computation of results
-- Improved caching of requests
-- Providing verbosity to RAR task:
-    As mentioned in original [PR](https://github.com/dotnet/msbuild/pull/3914), there should be some way to determine what thing we should log (by severity), and pass back to the original node.
-
-    Providing the verbosity level to the task should not probably be part of this project, but the RAR node should be able to accept the required verbosity on its input. This verbosity level should be introduced into the RAR task by [#2700](https://github.com/dotnet/msbuild/issues/2700).
diff --git a/documentation/specs/assets/rar-lifetime.png b/documentation/specs/assets/rar-lifetime.png
deleted file mode 100644
index a02bd3d0d87..00000000000
Binary files a/documentation/specs/assets/rar-lifetime.png and /dev/null differ
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
deleted file mode 100644
index 4eef03f279b..00000000000
--- a/documentation/specs/event-source.md
+++ /dev/null
@@ -1,52 +0,0 @@
-# EventSource
-
-[EventSource](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventsource?view=netframework-4.8) is the tool that allows Event Tracing for Windows (ETW) used in MSBuild. Among its useful features, functions with names ending in "start" and "stop" correlate between calls such that it can automatically record how long the event between the two calls took. It also provides an easy way to cheaply opt in or out, log auxiliary messages in addition to time, and add progress updates in the middle of an event as needed.
-
-## EventSource in MSBuild
-EventSource is primarily used to profile code. For MSBuild specifically, a major goal is to reduce the time it takes to run, as measured (among other metrics) by the Regression Prevention System (RPS), i.e., running specific scenarios. To find which code segments were likely candidates for improvement, EventSources were added around a mix of code segments. Larger segments that encompass several steps within a build occur nearly every time MSBuild is run and take a long time. They generally run relatively few times. Smaller methods with well-defined purposes may occur numerous times. Profiling both types of events provides both broad strokes to identify large code segments that underperform and, more specifically, which parts of them. Profiled functions include:
-
-| Event | Description |
-| ------| ------------|
-| ApplyLazyItemOperations | Collects a set of items, mutates them in a specified way, and saves the results in a lazy way. |
-| Build | Sets up a BuildManager to receive build requests. |
-| BuildProject | Builds a project file. |
-| CachedSdkResolverServiceResolveSdk | The caching SDK resolver service is resolving an SDK. |
-| CreateLoadedType | Creates a LoadedType object from an assembly loaded via MetadataLoadContext. |
-| CopyUpToDate | Checks whether the Copy task needs to execute. |
-| Evaluate | Evaluates a project, running several other parts of MSBuild in the process. |
-| EvaluateCondition | Checks whether a condition is true and removes false conditionals. |
-| ExecuteTask | Executes a task. |
-| ExecuteTaskReacquire | Requests to reacquire the node, often after the task has completed other work. |
-| ExecuteTaskYield | Requests to yield the node, often while the task completes other work. |
-| ExpandGlob | Identifies a list of files that correspond to an item, potentially with a wildcard. |
-| GenerateResourceOverall | Uses resource APIs to transform resource files into strongly-typed resource classes. |
-| LoadDocument | Loads an XMLDocumentWithLocation from a path.
-| MSBuildExe | Executes MSBuild from the command line. |
-| MSBuildServerBuild | Executes a build from the MSBuildServer node. |
-| PacketReadSize | Reports the size of a packet sent between nodes. Note that this does not include time information. |
-| Parse | Parses an XML document into a ProjectRootElement. |
-| ProjectGraphConstruction | Constructs a dependency graph among projects. |
-| RarComputeClosure | Resolves references from, for example, properties to explicit values. Used in resolving assembly references (RAR). |
-| RarLogResults | Logs the results from having resolved assembly references (RAR). |
-| RarOverall | Initiates the process of resolving assembly references (RAR). |
-| RarRemoveReferencesMarkedForExclusion | Removes denylisted references from the reference table, putting primary and dependency references in invalid file lists. |
-| RequestThreadProc | A function to requesting a new builder thread. |
-| ReusableStringBuilderFactory | Uses and resizes (if necessary) of ReusableStringBuilders. |
-| ReusableStringBuilderFactoryUnbalanced | Identifies improper usage from multiple threads or buggy code: multiple Gets were called without a Relase. |
-| Save | Saves a project to the file system if dirty, creating directories as necessary. |
-| SdkResolverResolveSdk | A single SDK resolver is called. |
-| SdkResolverServiceFindResolversManifests | Find all resolvers manifests. (Only appear under Changewave 17.4.) |
-| SdkResolverServiceInitialize | Initializes SDK resolvers. (Only appear before Changewave 17.4.) |
-| SdkResolverServiceLoadResolvers | Load resolvers given a resolver manifest. (Only appear under Changewave 17.4.) |
-| SdkResolverEvent | An SDK resolver logs an event. |
-| Target | Executes a target. |
-| TargetUpToDate | Checks whether a particular target needs to run or is up-to-date. |
-| WriteLinesToFile | Checks whether the WriteLinesToFile task needs to execute. |
-
-One can run MSBuild with eventing using the following command:
-
-`PerfView /OnlyProviders=*Microsoft-Build run MSBuild.exe <project to build>`
-
-For example, if PerfView is one level up from my current directory (which has MSBuild.exe), and I want to build MSBuild.sln on Windows, I would use the following command:
-
-`..\PerfView /OnlyProviders=*Microsoft-Build run .\MSBuild.exe .\MSBuild.sln`
diff --git a/documentation/specs/low-priority-switch.md b/documentation/specs/low-priority-switch.md
deleted file mode 100644
index ba33826a89e..00000000000
--- a/documentation/specs/low-priority-switch.md
+++ /dev/null
@@ -1,35 +0,0 @@
-
-# Low Priority Nodes in MSBuild and Visual Studio
-
-## Problem Summary
-
-When doing other work, it can be useful for builds (which often take a long time and consume a lot of resources) to happen in the background, allowing other work to happen in the interim. This is true for both command line builds and builds within Visual Studio.
-
-Visual Studio, on the other hand, should always run at normal priority. This ensures that users can continue to interact with its other features, most notably editing code and seeing intellisense and autocomplete pop up.
-
-## High Level Design
-
-### Requirements
-
-1. A long-lived process can execute a series of builds divided between Normal and BelowNormal priority.
-2. Transitions between a build at Normal priority and one at BelowNormal priority (and vice versa) are fairly efficient, at least on Windows but ideally on all operating systems.
-3. NodeReuse is still possible. That is, another process can (often) use nodes from the long-lived process if NodeReuse is true.
-4. Any reused nodes are at the priority they themselves specify. Normal priority nodes are actually at normal priority, and low priority nodes are actually at BelowNormal priority.
-5. All nodes are at the priority they should be when being used to build even if a normal priority process had connected to them as normal priority worker nodes, and they are now executing a low priority build.
-
-
-## Non-goals
-
-Perfect parity between windows and mac or linux. Windows permits processes to raise their own priority or that of another process, whereas other operating systems do not. This is very efficient, so we should use it. As we expect this feature to be used in Visual Studio, we anticipate it being less used on mac and linux, hence not being as high priority to make it just as efficient.
-
-## Details
-
-Each node (including worker nodes) initially takes its priority from its parent process. Since we now need the priority to align with what it is passed instead of its parent, attempt to adjust priority afterwards if necessary as part of node startup.
-
-BuildManager.cs remembers the priority of the previous build it had executed. If that was set to a value that differs from the priority of the current build:
-1. On windows or when decreasing the priority: lowers the priority of all connected nodes
-2. On linux and mac when increasing the priority: disconnects from all nodes.
-
-When a worker node disconnects from the entrypoint node, it should ensure that it is the priority that would be expected by nodes that successfully connect to it. That means that it should be normal priority if lowPriority is false and BelowNormal priority otherwise.
-
-For this reason, if we intend to reuse a node, we check its priority and adjust it to the expected value if possible. If it proves impossible to adjust to the correct priority, the node shuts down.
diff --git a/documentation/specs/project-cache.md b/documentation/specs/project-cache.md
deleted file mode 100644
index b0ce961313d..00000000000
--- a/documentation/specs/project-cache.md
+++ /dev/null
@@ -1,198 +0,0 @@
-# Summary
-
-Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](static-graph.md#weakness-of-the-old-model-caching-and-distributability).
-
-# Motivation
-
-As the introduction to [static graph](static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
-
-Visual Studio is one beneficiary. This plugin inverts dependencies among build systems: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild calls into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.
-
-This change also simplifies and unifies user experiences. MSBuild works the same from Visual Studio or the command line without dramatically changing how it works.
-
-# Plugin requirements
-
-- The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:
-  - it makes the filesystem look as if the project built
-  - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.
-
-# High-level design
-
-Conceptually, there are two parts of caching: "cache get" and "cache add". "Cache get" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. "Cache add" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.
-
-The "cache get" functionality was introduced in 16.9, while "cache add" was added in 17.8.
-
-## Plugin discovery
-
-- Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).
-  - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.
-  - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.
-```xml
-<ItemGroup>
-  <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll" />
-</ItemGroup>
-```
-- Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.
-
-## Plugin lifetime
-
-- Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.
-- `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a "fire-and-forget" call at this point. The first query on the plugin will wait for plugin initialization.
-  - `BeginBuildAsync` may be called with or without a `ProjectGraph`, depending on MSBuild has one to provide. When it is not provided, hints about the graph entry points are provided with which the plugin may decide to construct the `ProjectGraph` itself, if desired.
-- `BuildManager.EndBuild` calls `ProjectCacheBase.EndBuildAsync` on all discovered plugins. This allows plugins to perform any required cleanup work. This is a blocking call which will be awaited before the build can complete.
-- The plugin instance will get called in reverse topological sort order (from referenced projects up towards referencing projects). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.
-- Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that projects which are not well-described in the graph (e.g. using `<MSBuild>` tasks directly) will not benefit from the cache.
-
-## Cache get scenario
-
-- For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.
-  
-  - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.
-- If the plugin decides to build, then MSBuild proceeds building the project as usual.
-- If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets ("proxy targets").
-  - MSBuild injects the `BuildResult` into its Scheduler, so that future projects that need to call into the skipped project have the target results they need served directly from MSBuild's internal cache.
-  - Plugins have three options:
-    - Worst: plugins fake the build results for each target based on assumptions about how the target executes. We consider this brittle since the plugins will have to be updated whenever the build logic changes.
-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the `Build` target). See the [ProjectReference protocol](/documentation/ProjectReference-Protocol.md) for more details.
-      - Proxy target assumptions:
-        - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).
-        - They do not mutate state (file system, environment variables, etc).
-        - They do not MSBuild task call into other projects.
-      - The BuildManager schedules the proxy targets to build on the in-proc node to avoid `ProjectInstance` serialization costs.
-    - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.
-      - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.
-
-## Cache add scenario
-
-- Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.
-- MSBuild uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. To facilitate the plugin being able to handle future builds, it forwards this information as well as the build result to the plugin for it to use as desired, for example to add to a cache.
-  - This functionality has some implementation restrictions so will require additional opt-in. Specifically, the `/ReportFileAccesses` command-line flag or by setting `BuildParameters.ReportFileAccesses` for programmatic use of `BuildManager`. If this is not set, no file accesses will be reported to the plugin, however the plugin will still be notified of the build result.
-  - The in-proc node is disabled since MSBuild is unable to use Detours on the currently running process. It also would not want to capture the file accesses of the plugins themselves.
-  - Detours adds some overhead to file accesses. Based on initial experimentation, it's around 10-15%. There's the overhead of the plugin adding to the cache. Caching becomes valuable if it can save more than the overhead on average.
-- Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`), only for the x64 flavor (not x86 or arm64), and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.
-- As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.
-
-# APIs and calling patterns
-
-## Plugin API
-[ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass.
-
-See the [Plugin implementation guidance and simple example design](#plugin-implementation-guidance-and-simple-example-design) section for guidance for plugin implementations.
-
-## Configuring plugins
-
-Plugins may need configuration options provided by the user. This can be done via metadata on the `ProjectCachePlugin` item:
-
-```xml
-<ItemGroup>
-  <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll">
-    <PluginSetting1>$(PluginSetting1)</PluginSetting1>
-    <PluginSetting2>$(PluginSetting2)</PluginSetting2>
-    <PluginSetting3>$(PluginSetting3)</PluginSetting3>
-  </ProjectCachePlugin>
-</ItemGroup>
-```
-
-This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via `CacheContext.PluginSettings`.
-
-Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.
-
-## Enabling from command line
-
-- Requires `/graph` to light up cache get scenarios.
-- Requires `/reportfileaccesses` to light up cache add scenarios.
-- The static graph has all the project instances in the same process, making it easy to find and keep plugin instances in one process.
-- MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.
-
-## Enabling from Visual Studio, a temporary workaround
-
-- Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.
-- The workaround logic activates only when MSBuild detects that it's running under VS.
-- When VS evaluates projects via `new Project(..)` (it does this on all the solution projects on solution load), the evaluator will search for and store all detected plugins in a static field on the `BuildManager`.
-- The first build request will check the static state for the presence of plugins. If there's a plugin, it will initialize it at that point.
-- Plugins will be given the graph entry points instead of the entire graph in this scenario.
-- There is currently no way to enable cache add scenarios in Visual Studio.
-
-# Detours (cache add scenario)
-
-In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will emit events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.
-
-Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.
-
-## Pipe synchronization
-
-Because the Detours implementation being used communicates over a pipe, and nodes communicate over a pipe as well, and pipes are async, there is some coordination required to ensure that file accesses are associated with the proper build request. For example, if a "project finished" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.
-
-To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler node receives as "project finished" event over the node communication pipe, it will wait to determine that the project is actually finished until it also receives the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler determines the project is finished and schedules new work to the worker node (which would trigger new file accesses).
-
-# Plugin implementation guidance and simple example design
-
-The following will describe a very basic (and not very correct) plugin implementation.
-
-In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build ("if Tuesday copy this file"), but if considered caching would be quite infeasible.
-
-## Fingerprinting
-
-A "fingerprint" describes each unique input which went into the building a build request. The more granular the fingerprint, the more "correct" the caching is, as described above.
-
-In this example, we will only consider the following as inputs, and thus part of the fingerprint:
-- The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)
-- The content hash of the project file
-- The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`
-- The fingerprint of referenced projects
-
-Again, this is for illustrative purposes and a real implementation will want to use additional state for fingerprinting depending on the environment in which it runs and the correctness requirements.
-
-It can make sense for a fingerprint to be a hash of its inputs, so effectively is a byte array which can be represented by a string.
-
-At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.
-
-## Cache storage
-
-Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.
-
-For illustration purposes, consider our cache implementation is based on a simple filesystem with a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.
-
-## First build (cache population)
-
-In the very first build there will be no cache hits so the "cache add" scenario will be most relevant here.
-
-For a given project, `GetCacheResultAsync` will be invoked, but will end up returning a cache miss since the cache is empty.
-
-MSBuild will then build the project normally but under a detoured worker node. Because of this, the plugin will recieve `HandleFileAccess` and `HandleProcess` events. In this example implementation we will ignore `HandleProcess`. For `HandleFileAccess`, the plugin will simply store all `FileAccessData`s for a `FileAccessContext` to build up a list of all file accesses during the build. The plugin may decide to avoid storing the entire `FileAccessData` and instead just peel off the data it finds relevant (eg. paths, whether it was a read or write, etc).
-
-Once MSBuild is done building the project, it will call the plugin's `HandleProjectFinishedAsync`. Now the plugin knows the project is done and can process the results and add them to a cache. In general it's only useful to cache successful results, so the plugin should filter out non-success results. The `FileAccessContext` provided can then be used to retrieve the list of `FileAccessData` the plugin recieved. These `FileAccessData` can be processed to understand which files were read and written as part of the build.
-
-In our example, we can use the read files to construct a fingerprint for the build request. We can then add the files written during the build ("outputs") to some cache implementation.
-
-The plugin would then create some metadata describing the outputs (eg. the paths and hashes) and the serialized `BuildResult`, and associate it with the fingerprint and put that assocation in the cache.
-
-To illustrate this, consider a project with fingerprint `F` which wrote a single file `O` with hash `H` and had `BuildResult R`. The plugin could create a metadata file `M` which describes the outputs of the build (the path and hash of `O`) as well as the serialized `R`. Using the cache implementation described above, the plugin would write the following two files to the cache:
- - `metadata/F -> M:"{outputs: [{path: 'path/to/O', hash: H}], result: R}"`
- - `content/H -> O`
-
-This can then be used for future builds.
-
- ## Second Build (cache hits)
- 
- In the second build we have a populated cache and so it could be possible to get cache hits.
-
- For a given project, `GetCacheResultAsync` will be invoked. The plugin can fingerprint the request and use that fingerprint to look up in its cache. If the cache entry exists, it can declare a cache hit.
-
-In the example above, if all inputs are the same as in the first build, we should end up with a fingerprint `F`. We look up in the metadata part of the cache (file `metadata/F`) and find that it exists. This means we have a cache hit. We can fetch that metadata `M` from the cache and find that it describes the output with path `O` and hash `H`. The plugin would then copy `content/H` to `O` and return the deserialized `BuildResult R` contained in `M` to MSBuild.
-
-If the inputs were not the same as in the first build, for example if a `Compile` item (a .cs file) changed, the fingerprint would be something else besides `F` and so would not have corresponding cache entries for it, indicating a cache miss. This will then go through the "cache add" scenario described above to populate the cache with the new fingerprint.
-
-# Caveats
-- Without the "cache add" scenario enabled, the content which powers "cache get" must be populated by some external entity, for example some higher-order build engine.
-- Absolute paths circulating through the saved build results
-  - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.
-  - Plugins can attempt to normalize well-known paths, like the repo root, but this can be brittle and there may be unknown path types.
-- Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.
-- Inferring what targets to run on each node when using /graph
-  - Msbuild /graph requires that the [target inference protocol](static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
-- Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.
-
-# Potential future work of dubious value
-- Enable plugins to work with the just-in-time top down msbuild traversal that msbuild natively does when it's not using `/graph`.
-- Extend the project cache API to allow skipping individual targets or tasks instead of entire projects. This would allow for smaller specialized plugins, like plugins that only know to distribute, cache, and skip CSC.exe calls.
diff --git a/documentation/specs/proposed/interactive-package-references.md b/documentation/specs/proposed/interactive-package-references.md
deleted file mode 100644
index b01805575d6..00000000000
--- a/documentation/specs/proposed/interactive-package-references.md
+++ /dev/null
@@ -1,217 +0,0 @@
-# Packages Sourcing
-
-The feature is meant to simplify the process of fixing, testing and contributing changes in projects published as nugets.
-
-It is inspired by the golang modules design - where a standalone dependency (module) has a pointer to it's source location as a first-class citizen within the ecosystem (go.mod) and the relation between the source codes and runtime dependecy is unambigously guaranteed by the compiler.
-
-# North Star / Longer-term vision
-
-We envision the 'packages sourcing' to be a first-class-citizen within nuget client (and hence [`dotnet restore`](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-restore)). Via denoting specific metadata on `PackageReference` it would be possible to perform specific mode of restore operation for the particular package reference - by pointing to a local sources, or letting the command to figure out and fetch apropriate sources:
-
-```xml
-<Project Sdk="Microsoft.NET.Sdk">
-  <ItemGroup>
-    <PackageReference Include="Newtonsoft.Json" ResolveAsSources="true" />
-    <PackageReference Include="Contoso.CommonPackage" ResolveAsSources="true" SourcesLocation="$(MSBuildProjectDirectory)/../CommonPackage/src/CommonPackage.csproj" />
-  </ItemGroup>
-</Project>
-```
-
-```
-dotnet restore MyProj.csproj  
-```
-
-The command would resolve and fetch remote sources of proper revision (unless explicitly pointed to local sources with active changes), build the dependency and add it to `project.assets.json` indicating the sources expansion.
-
-There would need to be special treatment for some aspect of behavior of `PackageReference` that diverges or are not defined for source code references (`ProjectReference`), listed in https://github.com/dotnet/msbuild/issues/8507.
-
-A special metadata (possibly within the nuget package, optionaly within the source repo) might be needed to ensure the proper infering of the build in more involved scenarios (or to disallow package sourcing for particular package).
-
-One of the goals of the initial iteration is to identify the limitations of automatic infering of the build and turining the `PackageReference` to `ProjectReference`. 
-
-# Scope of initial iteration
-
-The initial proof of concept of the feature is envisioned to be facilitated via [`SourceLink`](https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink) repository metadata, [`PE headers`](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.portableexecutable.peheaders?view=net-7.0) and pdb metadata ([`MetadataReader`](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.metadata.metadatareader)), in-memory or persistent switching between `PackageReference` and `ProjectReference` and possibly verification of proper outputs (for `deterministic build` enabled projects).
-
-## In scope
-* Standalone dotnet tool for initiating the `Package Sourcing` of particular nuget(s) via locating and fetching sources, infering the build and flipping `PackageReference` to `ProjectReference`
-
-## Out of scope
- * **Patching the package/binary dependencies in a deployable way**. The interaction is ment to be used only on developer machine and not survive beyond repository push, external environment deployment etc.
- * **Survival of patches accross `PackageReference` updates**.
- * **Supporting nuget packages that are not `SourceLink` enabled**. As a fallback we might use `SourceLink` stamped symbols, but unless the `SourceLink` information is to be found either within the nuget package or published matching symbols, this feature will not be enabled.
- * **Custom pre-build prerequisities**. First version of the feature will make several assumptions on common ways to build packages from source repository (attempt to build just the project with `dotnet build`, attempt to locate `*.sln` or `build.<cmd|sh|ps1>` script or existence of reproducible build compiler flags)
-
-# User scenarios
-
-## OSS package reference
-* Alice is referencing FooBar nuget in her project and she is using automated PRs (e.g. dependabot) to consume the latest available version
-* A new version of FooBar nuget is published, automated PR into Alice project is created to update the `PackageReference` and the PR is failing
-* Alice is investigating the issue and suspecting problem in FooBar library. If the package was properly SourceLink-ed and symbols published, Alice can debug into the code and diagnose the issue
-* Alice would like to try to fix the issue, test the fix and contribute back to the OSS. She can achieve this with `Packages Sourcing` feature
-
-## Internal corp package flows
-* Bob is working in Contoso co. Contoso co. has dozens of internal repositories and internal package feed used to publish and consume the artifacts of individual repositories
-* Bob is working on component that is consuming another component - BarBaz - as a nuget package.
-* Bob wants to contribute an improvement to component BarBaz, that would be leveraged by his component. He wants to first test the improvement with his component before contributing back to the BarBaz. He can achieve this with `Packages Sourcing` feature
-
-## (Out of scope) Source as package reference
-* Bob from previous scenario needs to work on couple of components that interact with each other and which reference themselves via `PackageReference`s.
-* To simplify his work, Bob wants to include locations with components source code as reference locations for resolving `PackageReference`s, while he'd expect the build to properly interpret the components sources as packages (provided those can be successfuly build and packed)
-* Alteration of this sceanrio is referencing a reference via git repo link and commit hash (analogously to go modules).
-
-# Design proposal
-
-![control flow proposal](packagessourcing-control-flow.jpg)
-
- ## Subproblems
-
- * Opting-in mechanism - to request switch to local sources
- * Preserving the info about swtich to local sources
- * Opting-out mechanism - to switch back to regular package reference
- * Local storage of sources - submodule vs standalone checkout
- * Indication mechanism informing the user about usage of local sources (especially in case where local patch is applied)
- * Locating and fetching proper source codes
- * Infering the proper 'build recipe' for the binary and verifying the result (in case of determinictic build)
- * Verifying that the locally build package is correct - leveraging deterministic build; signature stripping etc.
- * Converting `PackageReference` to `ProjectReference`
- * Allowing to quickly consume local code patches (via edit and continue/ hot reload mechanism)
-
- Some of those problems might be eliminated by simplifying the workflow and e.g. providing a command that prepares a project and edits the original MSBuild file to replace `PackageReference` with `ProjectReference` - the consuming of code patches and indicating the altered reference to user would not be needed.
- 
- ## Possible Implementations
-
- Following sections discuss possible implementations of individual [subproblems outlined above](#subproblems).
-
- ### Opting-in
-
- For simplified and isolated rollout of this feature we propose CLI-only interface (no VS or other tooling integration):
-
-```cmd
-> dotnet tool install Microsoft.Build.PackageSourcing
-> dotnet package-to-sources --project MySolution.sln --packages: FooBar.Baz, Newtonsoft.Json
-
-FooBar.Baz:
-Sources located: github.com/FooBar/Baz@0abcb66
-Local checkout: C:\Users\jankrivanek\.nuget\sources\FooBar\6.5.4\
-Build instructions located: FooBar-package-sourcing.proj
-Build reconstructed: OK
-Reference replaced: OK
-
-Newtonsoft.Json:
-...
-
-Sourced packages are ready to use.
-
->
-```
-
-This as well solves the question of preserving the info about packages sourcing.
-
-### Opting-out
-
-This can be achieved via adding a metadata to mofdified MSBuild files, storing the info about original `PackageReference`s and then reverting those via another CLI command:
-
-```cmd
-> dotnet package-to-sources --revert --project MySolution.sln --packages: FooBar.Baz, Newtonsoft.Json
-
-Successfuly reverted packages sourcing for: FooBar.Baz, Newtonsoft.Json.
->
-```
-
-### Local storage of sources
-
-To be decided (nuget cache?, Submodules of the current git context?, sibling folder of current project git root?, the `.vs` folder (for vs-centric solution)?, `%temp%`? ...)
-
-We can take inspiration from VS debugger decompilation features:
-
-![vs decompiled sources](https://learn.microsoft.com/en-us/visualstudio/debugger/media/decompilation-solution-explorer.png?view=vs-2022)
-
-![vs nuget source](https://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2021/08/word-image-17.png)
-
- ### Locating proper sources
- * Most preferable way is via `SourceLink` metadata within the nuget package itself ([documentation](https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink), [reading the metadata](https://learn.microsoft.com/en-us/nuget/reference/nuget-client-sdk#get-package-metadata))
- * Fallback to `SourceLink` metadata within symbol files ([documentation](https://learn.microsoft.com/en-us/cpp/build/reference/sourcelink?view=msvc-170), [Portable PDB format spec](https://github.com/dotnet/runtime/blob/main/docs/design/specs/PortablePdb-Metadata.md), [reading source locations metadata](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/tests/Metadata/PortablePdb/DocumentNameTests.cs))
- * We should consider ability to specify/pass-in a custom location of sources - this would facilitate portion of the 'Source as package reference' scenario (possibly something that might be usable for our 'source build' or 'VMR build').
-
- ### Infering the 'build recipe'
- This is the most challenging part of the story - as .NET ecosystem currently doesn't enforce custom build pre-requisities standards nor conventions and hence it is not possible to replicate the package build process without possible manual steps. This part will hence be 'best efforts' with sensible communication of issues to user. 
- 
- We envision multiple options to achieve this goal (with possibility of fallback/combination of multiple approaches):
- * Option A: Using Pdb info/ Roslyn to extract information from PE/Pdbs and reconstruct the compilation ([roslyn experimental code](https://github.com/dotnet/roslyn/blob/main/src/Tools/BuildValidator/Program.cs#L268), [NugetPackageExplorer SymbolValidator](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer/blob/main/Core/SymbolValidation/SymbolValidator.cs#L145)). Access to symbol files (whether published as .snupkg on nuget.org or on microsoft or corporate symbols servers) is crucial for this method. As well as usage of particualr compiler toolchain used to generate the inspected package ([sdk 5.0.3 or MSBuild 16.10](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer/commit/a272c8c314257dfa99c6befd2cfeff39b8a6ecbe)). Prototyping task: https://github.com/dotnet/msbuild/issues/8511
- * Option B: Attempt to run build (`dotnet build`) on `.sln` in repo root or `src` folder, or fallback to discovery of most common build scripts in repo root (`build.<extension>` for few most common script types based on current OS). Prototyping task: https://github.com/dotnet/msbuild/issues/8512
- * Option C: Sources crawling and finding project by name/assembly name; build; compare results.
- * Option D: Working backwards from the nuget (finding pack script or msbuild properties indicating nuget creation ...); build; compare results
- * Option E: Seting up convention for explicit description of build prerequisites and package build. Inspiration for this can be `.proj` files describing external dependencies build recipe in dotnet source build ([sample build descriptions](https://github.com/dotnet/source-build-externals/tree/main/repos)) or [`git dependencies`](https://fsprojects.github.io/Paket/git-dependencies.html) project for Paket
-
-
-**Gotchas:**
- * The `Option A` above infers the 'compile recipe', but not the 'build recipe' - which means some checked out files would not have their standard expected functionality (they would be completely ignored) - resource files (`.resx`), templates for code generators (`.tt`, `.aspx`, `.xaml`, etc.) and most importantly the project file itself (`.csproj`/`.fsproj`/`.vbproj`/...).
-
-   Possible solutions: 
-    * (short term) Mark such files read-only, add explicit pre-compilation check throwing error if hash of such a file changes 
-    * (long term) For code generators we can extend SourceLink to add info to symbol file what code generator was used and store it on symbols server (or in Executable Image Search Path location)
-    * project files - ??? (though one)
-
-  * The `Option B` might not have acceptable success rate - it is still very appealing option if combined with other approach. 
-
- * Discrepancies between the `PackageReference` and `ProjectReference` configurability and behavior (different metadata support, different behavior for some of the same metadata, different layout of the the bin outputs yielding some assumptions breaks, nuget support for packaged props/targets, etc.). Probably the biggest problem will be the usage of build features - build.props and build.targets (as those are placed during the project build, but couldn't be identicaly consumed during the same build as for the package reference)
-
-    Possible solutions: 
-      * Those differences needs to be researched/catalogued and categorized first, then we can decide what to consolidate and what will not be explicitly supported. Investigation item: https://github.com/dotnet/msbuild/issues/8507
-      * It might be beneficial to perform analysis of usage prevalence of the individual metadata. Investigation task: https://github.com/dotnet/msbuild/issues/8521
- 
- * Running a build script on a local machine is possible security risk - user should be properly warned and informed.
- * Verifying the binary identity might add unnecesary high cost to the operation at unwanted time - the rebuild is likely needed only after user want to make a change. But the verification might stll be agood idea - especially for cases where we attempt to run a build script (and we might e.g. be running `build.sh` due to being on Unix, while official nuget was published from Windows build).
- 
-   Possible solution: We might hold on until user makes a change and wants to test run it (we can then compare it with the version that was originaly downloaded - to perform a build verifying the binary identity of the original nuget binary and local reconstructed binary). In the ideal case the experience would be very seamless - user steps into the code during debugging (or via decompilation) and is allowed to perform change - if they perform change they are first asked to confirm that action and to acknowledge this will lead to running the component build on their machine. The current environment might even decide which of the build reconstruction techniques will be fastest based on the change the user made (e.g. single code file vs change to .resx etc.)
-
- * Building the package on different SDK might lead to slightly different results - this we'll likely need to accept as limitation
- * Global properties propagate nto the `ProjectReference`, wherease `PackageReference` is already built (example: `Debug` configuration can get propagated into `ProjectReference`, while the consumed `PackageReference` was build in `Release` mode).
- 
-    Possible solution: Add 'Remove All Global Properties' feature for a project build.
-
-**_Extensive research needed for this subproblem._**
-
- ### Verifying identity of local package with the feed one
-
- In case deterministic build was opted-out, this would be very challenging and nearly impossible - so not supported.
- For signed assemblies we'll need to strip signatures ([`ImageRemoveCertificate`](https://learn.microsoft.com/en-us/windows/win32/api/imagehlp/nf-imagehlp-imageremovecertificate)). Removing signature might nullify checksum bytes in PE header - so binary comparison to the locally built assembly might not match (solution is to temporarily remove the PE header checksum from the local binary as well - to facilitate binary equality).
-
- ### Converting `PackageReference` to `ProjectReference`
-
- [To Be Investigated]
- There might be possible inconsitencies between [`PackageReference`](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) and [`ProjectReference`](https://learn.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference) items metadata (and even behavior with same metadata - e.g. https://github.com/dotnet/msbuild/issues/4371).
- So there needs to be some decision of what's supported and what not and what's the behavior for attempt to translate `PackageReference` using untranslatable metadata.
-
- ### Allowing to quickly consume local code patches
-
- To be decided.
- But likely this will be no-op for the initial version - standard usage scenarios for project references will kick in.
-
- # Security considerations
-
- [Under construction]
- * The build verification mode (out of scope) needs proper design of handling of symbols embedded files and pointers to any sources outside of expected repository root. (otherwise intruder with access to the production build can infect not only the binary, but the symbol file as well)
- * MIM for the symbol server (offering crafted symbol file with pointers to custom sources that can allow execution of intruder code on the developer machine)
- * Possible licensing considerations - there can be packages with different redistribution requirements for packages and originating sources, but allowing user to switch from package reference to source references we are technically making it easier for the user to miss and fail license agreement.
-
- # Cross team dependencies considerations
-
- * **Nuget - possible dependency** - the proposal doesn't evision changes to the nuget client nor server contracts. However it might be beneficial to consolidate behavior of `ProjectReference` and `PackageReference` items and its metadata - coorfination with nuget team would be helpful here.
- * **Visual Studio, Project System - No dependency in initial version** - the proposal envision exposing functionality via CLI (and API) only, after the whole concept is constructed and alive, we should start reaching out to those teams to consider exposing the functionality via GUI - e.g.:
- ![vs context menu proposal](sourcing-vs-context.png)
- * **SDK - No dependency** - the initial version would be delivered as standalone (optional) dotnet tool
- * **Roslyn - Consultation and engineering** - ideally packing and exporting the [BuildValidator](https://github.com/dotnet/roslyn/tree/main/src/Tools/BuildValidator) and mainly [Rebuild](https://github.com/dotnet/roslyn/tree/main/src/Compilers/Core/Rebuild). MSBuild team should fund this effort
- * **MSBuild - Likely no dependency** - There migh need to be some support for allowing storing info about link between original PackageReference and injected ProjectReference - however current MSBuild constructs should suffice here. There might be some work needed to bring `PackageReference` and `ProjectReference` functionaly closer together (as outlined [above](#converting-packagereference-to-projectreference))
-
- There can be possible leverage of the work by other teams:
- * Nuget - [NugetPackageExplorrer](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer) - as it currently heavily uses custom code to extract information from PE/Pdb metadata.
- * Source Build / VMR - to validate buildability of 3rd party components and low touch process of enlisting new 3rd party dependencies into source build
-
- # Links:
-  * https://github.com/NuGetPackageExplorer/NuGetPackageExplorer
-  * https://devblogs.microsoft.com/visualstudio/debugging-external-sources-with-visual-studio/
-  * https://devblogs.microsoft.com/visualstudio/decompilation-of-c-code-made-easy-with-visual-studio/
-  * https://learn.microsoft.com/en-us/visualstudio/debugger/decompilation?view=vs-2022
-  * https://fsprojects.github.io/Paket/git-dependencies.html
diff --git a/documentation/specs/proposed/packagessourcing-control-flow.jpg b/documentation/specs/proposed/packagessourcing-control-flow.jpg
deleted file mode 100644
index aff34456469..00000000000
Binary files a/documentation/specs/proposed/packagessourcing-control-flow.jpg and /dev/null differ
diff --git a/documentation/specs/proposed/security-metadata.md b/documentation/specs/proposed/security-metadata.md
deleted file mode 100644
index e2ed58050b6..00000000000
--- a/documentation/specs/proposed/security-metadata.md
+++ /dev/null
@@ -1,253 +0,0 @@
-
-# Security Metadata
-
-The feature is meant to improve the security of builds executed via MSBuild, by reducing the chances of spilling secrets (and possibly other sensitive data) from otherwise secured or/and inaccessible build environments.
-
-It builds upon the other efforts reducing the cases accidentaly logging secrets - ['not logging unused environemnt variables'](https://github.com/dotnet/msbuild/pull/7484), 'redacting known secret patterns' (internal, by @michaelcfanning). Distinction here is that we want to give users option how to configure their build scripts and build data so that they can indicate what contains secret/sensitive data and shouldn't get output into logs.
-
-The feature is envisioned to be delivered in multiple interations, while first itearation will be facilitated via global items and/or properties that will be indicating masking logging of specific types of data in log entries (hence no syntactic changes will be imposed for now).
-
-# North Star / Longer-term vision
-
-We envision MSBuild to have a first-class-citisen type system for it's data and tasks. 'Secret' would be one of the data types - allowable to be passed only to other variables or task inputs denoted as 'secret' (so e.g. it would not be possible to pass secrets to [`WriteLinesToFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/writelinestofile-task)) and vice versa 'secret' task input or data type could be initialized/evaluated only from other 'secrets' or predefined external sources of data - environment variables, commandline arguments, files, apropriately denoted task output parameters.
-
-Such a strong typing would allow to hold to stronger guarantees of not spilling properly denoted sensitive data and redact them with minimal impact on build performance (as opposed to intermediate attempts that will need to perform string inspections).
-
-**Ilustrative sample:**
-
-```xml
-<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <Secrets>
-    <!-- initialize from command line -->
-    <GH_token />
-    <!-- initialize from env -->
-    <ACR_login>$(ACR_login)</ACR_login>
-    <!-- initialize by task -->
-    <ACR_password />
-	</Secrets>
-
-  <UsingTask TaskName="ReadCreadentialFromValut" AssemblyFile="$(MSBuildProjectDirectory)/Tasks/ACR-Tasks.dll" />
-  <UsingTask TaskName="PushImageToACR" AssemblyFile="$(MSBuildProjectDirectory)/Tasks/ACR-Tasks.dll" />
-	
-  <Target Name='PushImage'> 
-    <Message Text="Pushin image to ACR" />
-    <ReadCreadentialFromValut 
-      Key="$(ACR_password_key)"
-    >
-      <Output TaskParameter="Value" PropertyName="ACR_password"/>
-    </ReadCreadentialFromValut>
-    <PushImageToACR 
-      Login="$(ACR_login)"
-      Password="$(ACR_password)"
-    />
-  </Target>
-</Project>
-```
-
-```cs
-ReadCreadentialFromValut : Task
-{
-  /// <summary>
-  /// Key to be fetched
-  /// </summary>
-  public string Key { get; set; }
-
-  /// <summary>
-  /// Fetched value
-  /// </summary>
-  [Output]
-  [Secret]
-  public string Value { get; set; }
-
-  // ... Execute() ...
-}
-```
-
-```cs
-PushImageToACR : Task
-{
-  /// <summary>
-  /// Azure Container Registry Login
-  /// </summary>
-  public Secret Login { get; set; }
-
-  /// <summary>
-  /// Azure Container Registry Password
-  /// </summary>
-  public Secret Password { get; set; }
-
-  // ... Execute() ...
-}
-```
-
-An opt-out mechanism would allow usage of properly denoted tasks with plain string input data (and vice versa) - to allow smoother gradual onboarding to the new type system, without the need to rework the entire build script suite at one shot.
-
-
-# Scope of initial iteration
-
-## In scope
- * Following data can be opted-in for redacting:
-    * property values
-    * item values
-    * item metadata values
-    * all item metadata
-    * any combination of above
-    * task input parameters (to denote that task is requiring sensitive data and only such can be passed in)
-    * task OutputItems (This can be handy in cases similar to [`ReadLinesFromFile` task](https://learn.microsoft.com/en-us/visualstudio/msbuild/readlinesfromfile-task))
- * Redacting the above will happen in all log events before they are being sent to subscribed loggers. 
- * Redacting will apply to data initializations and passing:
-    * task input parameters
-    * task OutputItems
-    * transfering value to other properties/items via evaluation, transforms, flattening, [Property functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/property-functions), [Item functions](https://learn.microsoft.com/en-us/visualstudio/msbuild/item-functions)
-    * initialization from environemnt variables or command line
- * Redacting **will NOT** occure on:
-    * log events emited from tasks (this might be added as extra opt-in option - but would lead to significant build performance degradation).
-    * any other alternative output of tasks (direct writes to file system, network connections etc.)
-
-## Out of scope
-  * Redacting **will NOT** occure on:
-    * Log events emited from tasks (this might be added as extra opt-in option - but would lead to significant build performance degradation).
-    * Any other alternative output of tasks (direct writes to file system, network connections etc.)
-    * MSBuild xml nodes (elements/attributes) names. (Sensitive data within MSBuild script itself is strongly discouraged)
-    * Passing values to task and there embedding into additional text and passing out as output parameter - unless such is explicitly marked as containing sensitive data.
-    * Encrypting/securing data in memory during therun of the build.
- 
-
-# User interaction
-
-There needs to be a way how user specifies which data should be redacted from logs. We have several options:
-
- * New data type - this is part of the [North Star vision](#north-star--longer-term-vision), but is out of scope for the initial iteration.
- * [Not recomended] Denoting those via some metadata on a definition of the data to be redacted - this has two main drawbacks - a) For some data types (properties, metadata) we'd need new constructs how to attach additional info (property metadata; item meta-metadata). b) some data can be defined implicitly or dynamicaly
- * Property with global scope - e.g. 
-   ```xml
-   <DataToRedactFromLogs>Foo;Bar;Baz->SomeMetadata;MyItem->*</DataToRedactFromLogs>
-   ```
-   single property might look bit cryptic for denoting different data types. On the other hand it might be more efficient in simple redacting scenarios (pointing to a set of regexes; single sustom redactor etc.) and would allow limiting the log events pre-buffering needs.
-
- * Item with global scope - e.g. 
-   ```xml
-   <ItemGroup>
-     <!-- Redacting property content based on the name of the property (or environment variable) -->
-     <DataToRedactFromLogs Include="Foo" Type="Property">
-     </DataToRedactFromLogs>
-     <!-- Redacting item content based on the name of the item. Metadat are not redacted -->
-     <DataToRedactFromLogs Include="Bar" Type="Item" RedactValue=True>
-     </DataToRedactFromLogs>
-     <!-- Redacting item metadata content based on the name. -->
-     <DataToRedactFromLogs Include="Baz" Type="Item" RedactValue=False Metadata="SomeMetadata">
-     </DataToRedactFromLogs>
-     <!-- Redacting all metadata content of specific item based on the name of the item. -->
-     <DataToRedactFromLogs Include="MyItem" Type="Item" RedactValue=False Metadata="*" />
-     <!-- Redacting property content passed from the task. At the same time requiring that the data receiving the output of the task are denoted as secret as well. -->
-     <DataToRedactFromLogs Include="OutputA" Type="TaskOutput" TaskName="TaskX" />
-     <!-- Redacting task parameter value. At the same time requiring that the data passed to the parameter of the task are denoted as secret as well. -->
-     <DataToRedactFromLogs Include="ParamA" Type="TaskParameter" TaskName="TaskX" />
-     </DataToRedactFromLogs>
-   </ItemGroup>
-   ```
-   This can offer a more chatty, but better understandable (and possibly beter script generatable) way of denoting the redacting intent.
- * A regex on *value* to redact above discused data types based on their content - e.g.:
-    ```xml
-   <ItemGroup>
-     <!-- Redact GH tokens based on https://github.blog/changelog/2021-03-31-authentication-token-format-updates-are-generally-available -->
-     <DataToRedactFromLogs Include="ghp_[A-Za-z0-9_]" Type="ValueRegex">
-     </DataToRedactFromLogs>
-   </ItemGroup>
-   ```
-   This way we can give build architects a tool to define common `.props` files opting-in for redacting specific types strings known to be tokens/secrets/sensitive data, without the need to guess under which properties or items they would show within the build
-* A custom plugin flagging values for redaction. e.g.:
-    ```xml
-   <ItemGroup>
-     <DataToRedactFromLogs Include="MySecretsClassifier.dll,Contoso.Secrets.Classifier.ClassifySecrets" Type="ValueClassifierPlugin">
-     </DataToRedactFromLogs>
-   </ItemGroup>
-   ```
-
-   where:
-
-   ```csharp
-   Contoso.Secrets;
-
-   public class Classifier: IValueClassifier
-   {
-      public ISet<string>? GetPartsToRedact(string value) {/* Logic goes here */}
-   }
-   ```
-   This option has additional security considerations, but allows most versatile secrets redaction.
-
-   The last option can possibly be allowed to be injected via other means, that MSBuild currently uses for injecting pluggable fnctionality (command line argument; environment variable; binary placed in a specific search location)
-* A built in redacting plugin - to be opted-in via env var or command line. Plugin will use same extension point as custom plugins - with extended interface allowing to provide redaction values as well:
-   ```csharp
-
-   public interface IValueRedactor
-   {
-      public ISet<Tuple<string, string>>? GetPartsToRedact(string value);
-   }
-   ```
-   This plugin will allow for no-touch redacting of most comon secret patterns by various providers. The default plugin is going to be provided as contribution by 1ES (by @michaelcfanning) and is currently out of scope of this document.
-
-
-First presented option is not to be used. All the other options will likely be supported.
-
-# Special considerations
-
-* There should be no (or very minimal) performance impact to cases where redacting is not opted-in and/or to cases where there is lower/minimal level of logging. In another words - we should not spend cycles detecting and redacting secrets on log events that are not going to be loged (todo: second case might be more problematic - as loggers can decide their level of logging).
-* Order of processing and imports is important here - if we indicate secret metadata in items, the properties are processed first and hence we can miss preanalyzing (or even redacting) some data. Same applies for order of processing of the properties.
-* Considering above two facts - we need a opt-in commandline switch or environemnt variable (or combination) to indicate that secrets metadata might be used - in which case we'll need to buffer build/log events before we have processed all the metadata indicating what needs to be redacted. Extra care will need to be given to sending command line args via EventSource ([source](https://github.com/dotnet/msbuild/blob/main/src/MSBuild/XMake.cs#L655))
-* There are no global items today - this can be simulated by putting those to directory.props
-* Even seemingly innocent tasks with seemingly innocent logging can spill possibly sensitive data (e.g. think the RAR task, logging all the inputs, while those are just reference related info - those can contain paths that might already by itself be sensitive info). Related: [#8493](https://github.com/dotnet/msbuild/issues/8493) 
-* `MSBuild` task can pose a boundary for some context passing (e.g. properties/items).
-* Properties/items can occure dynamically after the initial processing of the script - e.g. [`CreateProperty task`](https://learn.microsoft.com/en-us/visualstudio/msbuild/createproperty-task). That should not be a problem, but we should keep it in mind (as additional entrypoint of external data into internal data holders).
-* Task authors and consumers are posibly different personas with disconected codebases. For this reason we want to support ability to indicate that task input/output is meant to be a secret. A user of the task should follow the contract and denote the data to be mounted to the task appropriately (otherwise a build warning/error will be issued).
-
-# Suggested Implementation
-
-* Need for explicit opt-in - command line switch or environment variable.
-* On detection of opt in, all build events for loggers need to be buffered for a deffered dispatch to loggers (similarly as we have ['DeferredBuildMessage'](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L400) and [`LogDeferredMessages`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs#L2890)), until the full pass through the build script (including all imports and `.props` and `.targets` files) so that properties initialization and items initialization is fully performed - as only then we know the full extent of requested redacting.
-  * In the future version - with first-class citizen type for secrets, we can possibly frontload single pass through the script just for detection of the secret redaction declarations and avoid the buffering and post-process need.
-* Buffered events need to be post-processed in respect with the redaction requests, only then dispatched.
-* We'll maintain lookup of elements requested for redaction - those explicitly requested by the name of property/item and those identified as sensitive by value or by transfer of value from other sensitive element.
-* We'll intercept assigments of value to property ([`TrackPropertyWrite`](https://github.com/dotnet/msbuild/blob/main/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs#L223)), item and task parameter
-  * If value is assigned to a task parameter and such is indicated by user as sensitive, the holder of the value (the R-value - parameter/item being assigned to the task input) needs to be as well tracked as sensitive, otherwise build waring/error will be issued.
-  * If value is assigned to a task parameter and such is not indicated by user as sensitive, but the holder of the value (the R-value - parameter/item being assigned to the task input) is tracked as sensitive (either because it was explicitly denoted by name, or it was later marked by MSBuild due to holding value matching a sensitivity value regex or callback) - a build warning/error will be issued.
-  * If value is assigned to property/item from a task output and such is indicated by user as sensitive, the L-value holder of the value (the property/item being assigned to) need to be as well tracked as sensitive, otherwise build waring/error will be issued.
-  * If value is being assigned to property or item
-    * and such is indicated by user as sensitive, the generated build event needs to be redacted.
-    * and such is not indicated by user as sensitive, but the R-value is indicated as sensitive - the data holder (property/item) is marked as holding sensitive data and treated accordingly.
-    * and such is not indicated by user as sensitive, the value is passed to sensitivity indicating regex or callback (in case any of those are configured by user) and if matched - the data holder (property/item) is marked as holding sensitive data and treated accordingly.
-* No other redacting of log events will be performed. This is not a strong requirement - we can introduce another opt-in level of strict inspection of all log events. The gain is very questionable though, while the performance impact is severe (internal experiments by @michaelcfanning measured by @rokonec indicate 4-times slow-down on mid-size build). Additionally to being perf-expensive, it can possibly get easily confused - e.g.:
-
-```xml
-<ItemGroup>
-  <DataToRedactFromLogs>MySecret</DataToRedactFromLogs>
-  <MySecret>a</MySecret>
-  <MyInnocentData>hahaha</MyInnocentData>
-  <SomeProp></SomeProp>
-</ItemGroup>
-
-<Target Name="Test">
-  <MyTask FirstInput="MySecret" SecondInput="MyInnocentData">
-    <Output PropertyName="SomeProp" TaskParameter="Result">
-  </MyTask>
-  <!-- Might log: 
-       Result from task: h<redacted>h<redacted>h<redacted>
-  -->
-  <Message Text="Result from task: $(SomeProp)">
-</Target>
-```
-
-In case we'd want to redact all occurences of value of `MySecret` from the task result - we might get a lot of false positives and very confusing results.
-
-# Open questions
- * What to use as a replacement of the data to be redacted? (Randomized hash, fixed token, etc.) - *very likely just a static pattern ('******'). The built-in redactor plugin will be allowed to provide custom replacements*
- * Do we want to allow to supply custom replacement value for injectable redaction functionality? There would need to be very strong compeling reason, as this is easily suspectible to [log forging attack](https://owasp.org/www-community/attacks/Log_Injection) - *most likely no.*
- * Balancing performance and accuracy - can we afford to not support arbitrary output of tasks? Otherwise we'd need to process all log events (similar experiments indicate 4 times slowdown of the build of mid-size project (Orchard)). On the other with explicit 'secret metadata' feature users might expect 100% correctness. Should we make this configurable as well (input data only vs all log entries)? Plus this might be suspectible to false positives (see above).
-
-
-# Links
- * Nightfall data redaction syntax: https://docs.nightfall.ai/docs/redacting-sensitive-data-in-4-lines-of-code
- * `spark.redaction.regex`: https://people.apache.org/~pwendell/spark-releases/latest/configuration.html
- * Redacting secrets in k8s logs in ops tool `Komodor`: https://docs.komodor.com/Learn/Sensitive-Information-Redaction.html
- * MSBuild opt-in functionality for properties/items/metadata logging disabling: https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs#L1199
-
diff --git a/documentation/specs/proposed/sourcing-vs-context.png b/documentation/specs/proposed/sourcing-vs-context.png
deleted file mode 100644
index 20a852205d7..00000000000
Binary files a/documentation/specs/proposed/sourcing-vs-context.png and /dev/null differ
diff --git a/documentation/specs/rar-core-scenarios.md b/documentation/specs/rar-core-scenarios.md
deleted file mode 100644
index 3fb19ad7846..00000000000
--- a/documentation/specs/rar-core-scenarios.md
+++ /dev/null
@@ -1,200 +0,0 @@
-# Resolve Assembly Reference core scenarios
-
-This document aims to capture the core functionality provided by the ResolveAssemblyReference task when building .NET (_Core_ - pun intended) projects.
-The goal is to rationalize and optimize the task, ultimately achieving substantially better performance and crossing out RAR from the list of notoriously
-slow build tasks.
-
-## Overview
-
-RAR is the Swiss army knife of assembly resolution. Very extensible and universal, exposing over 50 documented parameters and supporting 10 different
-locations where it searches for assemblies. Please see the [official documentation](https://learn.microsoft.com/visualstudio/msbuild/resolveassemblyreference-task) and
-the [ResolveAssemblyReference page](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ResolveAssemblyReference.md) for a detailed description
-of its features.
-
-While all of RAR's functionality has to be supported for backward compatibility, some parts are more relevant for modern builds than others. For example,
-if we focus only on building .NET Core / .NET 5+ projects, resolving assemblies in the Global Assembly Cache (GAC) is not supported. In fact, most of
-the "resolvers", internal classes implementing various resolution strategies, are not used in modern scenarios.
-
-## Requirements
-
-Looking at the RAR contract at a high-level, it is effectively transforming one string array to another. It is passed an array of strings specifying the
-assemblies required for the build, and returns an array of strings specifying full paths to assembly files on disk. Not necessarily a 1:1 mapping because
-assemblies are transitively probed for dependencies, thus the output array may be larger than input. Additionally, if an input assembly cannot be resolved,
-RAR issues a warning and otherwise ignores the assembly. This may lead to the output array being smaller than input.
-
-### Inputs
-
-In a typical build targeting modern .NET (*not* .NET Framework), RAR inputs come from three sources.
-
-1. SDK reference assemblies. These are full paths to assemblies distributed with the SDK. The SDK may get the list of assemblies for example by parsing the
-corresponding `FrameworkList.xml`. Reference assemblies are passed to RAR with the `ExternallyResolved` metadatum set, which means that they are
-transitively closed with respect to their dependencies. In other words, all dependencies, including transitive dependencies, of these assemblies are
-guaranteed to be passed in.
-
-1. NuGet references. These are again full paths to assemblies pre-resolved by the NuGet system. The `ExternallyResolved` metadatum is set for these as well,
-signalling to RAR that it doesn't have to open the assembly files to read their AssemblyRef tables.
-
-1. Project references. When a project depends on another project, the output file of the dependency is passed to RAR. Alternatively, a project may directly
-reference a random file o disk, resulting in the same code path. Unlike SDK and NuGet, these references are not pre-resolved and RAR must open the assembly
-files and use a .NET metadata reader to enumerate the AssemblyRef table to get the list of dependent assembly names. The dependent assembly names are
-resolved to assembly files and newly discovered assembly files are again scanned for AssemblyRef's. This process repeats itself until a closure is
-established.
-
-The above sums up the functionality required from RAR in a nutshell. For extra clarity, note that RAR is invoked only once during build, and is passed the
-combined SDK, NuGet, and project references in one input array.
-
-## Design
-
-To meet the requirements, RAR must internally be able to do the following.
-
-- For each input reference passed as a file path, it must verify that the file path exists. If the file does not exist, RAR issues a warning and ignores
-the reference.
-
-- For each input reference passed as a file path, it must know what its assembly name is. For example, for a reference given as
-`C:\_nugetpackages\microsoft.netcore.app.ref\7.0.2\ref\net7.0\Microsoft.VisualBasic.Core.dll`, RAR must figure out the assembly name to be
-`Microsoft.VisualBasic.Core, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a` so it can map it back to the reference when it sees
-such an AssemblyRef in another assembly.
-
-- For project references (reference given as a path to an assembly file that is not guaranteed to have its dependencies resolved), RAR must be able to look
-up dependencies. If a dependency is not found in the assembly name -> file path map, RAR first searches the directory where the primary reference is located.
-Failing that, it then uses pre-defined strategies, four of which are enabled by default when building modern projects: `CandidateAssemblyFiles`, `HintPathFromItem`,
-`TargetFrameworkDirectory`, and `RawFileName`. Of these, only `CandidateAssemblyFiles` tends to actually be of potential use. `CandidateAssemblyFiles` is
-configured to use all `Content` and `None` items defined in the build. Given an AssemblyRef found in a project reference, for example `MyLibrary, Version=1.0.0.0`,
-if `Content` or `None` contains `MyLibrary.dll`, RAR will get its assembly name and see if there is a match.
-
-## Scale
-
-The typical total number of references processed by RAR when building one project is in the order of hundreds. Even if the project referenced everything
-that comes with the .NET SDK, consumed a large number of NuGet packages, and was part of a large solution, it would likely reach only low thousands of references.
-In the OrchardCore solution, for example, the median number of references passed to and from RAR is 317 and the maximum is 629.
-
-While CPU optimizations can definitely make a difference, at this scale I/O is far more concerning. Building upon the design notes above, here is where RAR
-has to touch the disk.
-
-- **File existence checks**. RAR tends to invoke its resolvers sequentially with the first-one-wins semantics. It returns the first suitable file that actually
-exists. As a special case, if RAR is given a full path, it checks if the file exists before returning it.
-- Assembly name extraction. Given a file on disk, RAR needs to know its assembly name, i.e. version, culture, public key token, ... This requires opening the
-file with a .NET metadata reader.
-- **AssemblyRef extraction**. For references that are not marked with `ExternallyResolved`, RAR needs enumerate their dependencies. This, again, requires opening
-the file with a .NET metadata reader.
-
-## Optimizations
-
-RAR optimizations tend to revolve around caching of information that is expensive to calculate.
-
-### Existing caching
-
-Over the years RAR has implemented several layers of caches, both in-memory and on-disk. An inventory follows.
-
-#### **Per invocation in-memory cache**
-
-Not surprisingly, RAR caches the result of I/O operations in a cache in memory. The lifetime of this cache is one RAR invocation because generally we cannot
-assume that files on disk don't change between builds. It is implemented inside `SystemState` as several dictionaries keyed off of the absolute file path.
-One issue with this cache is that the key is not normalized so a file specified as `C:\dir\file` will use a different cache entry than the same file specified as
-`C:/dir/file`.
-
-#### **Per process in-memory cache**
-
-This comes in multiple forms. `SystemState` has its own process-wide cache which maps file paths to data we need - assembly name, dependencies (AssemblyRef's), last
-modification time (time stamp). It uses the time stamp to filter out invalid entries, i.e if the last modification time stamp changes, the cache contents is no longer
-considered valid.
-
-Another form of such a process-wide cache is a low-level cache of timestamps of immutable files, as implemented in `NativeMethods.GetLastWriteFileUtcTime`
-and `FileClassifier`. The idea is that some files are not expected to be updated or deleted during inner loop development. For instance, a reference assembly that
-comes with the SDK should never change and may get deleted only by uninstalling the SDK. The problem with this cache is that the file path-based classification is
-more or less a heuristic and doesn't seem to work in all cases. Currently it is failing to recognize SDK reference assemblies under paths like
-`C:\_nugetpackages\microsoft.aspnetcore.app.ref\7.0.2\ref\net7.0`, for example.
-
-#### **Per project disk cache**
-
-To help in cold build scenarios where RAR has not seen the project yet and the in-memory caches are empty or not relevant, RAR supports an on-disk cache using the
-`StateFile` parameter. If specified, RAR will attempt to populate `SystemState` by deserializing the file before it starts. If `SystemState` has been modified
-during RAR execution, its new contents will be serialized back to the file after RAR is done. This is somewhat non-deterministic because the cache being written
-back is a union of what was read from the disk and what's in the memory, the latter depending on what other projects have been built by the current MSBuild process.
-Building the exact same project with the exact same disk state will sometimes write the cache, sometimes it will not.
-
-From performance point of view, while helping when RAR is cold, reading the cache unnecessarily slows down the execution when RAR is hot, because the cache contents
-already is in memory so there is nothing to gain from reading it again. Of note here is the fact that as of _On disk cache serialization (#6094)_, RAR uses a custom
-hand-optimized serializer for the cache file. It has better peformance than the previously used `BinaryFormatter`, not to mention being considered more secure.
-
-#### **SDK disk pre-cache**
-
-The observation that if there is no per project disk cache and RAR is cold, it has to read information about many SDK assemblies, led to the advent of the global
-pre-cache. The idea is that the pre-cache is created as part of building the SDK and distributed with it. I.e. it is the SDK vendor's responsibility to create the
-file, make it available on developer machines, and pass it to RAR in the `AssemblyInformationCachePaths` parameter when building relevant projects.
-
-The pre-cache functionality is generic and available to any SDK vendor. The .NET SDK currently builds and distributes a file named `SDKPrecomputedAssemblyReferences.cache`
-but it is not passed to RAR by default. Only a couple of projects in the dotnet organization are explicitly opted into consuming the pre-cache at the moment.
-
-The downside of the current pre-cache design is that the full pre-cache ends up being written to each per project cache file upon completing the first RAR invocation.
-For the .NET SDK the pre-cache contains more than 3000 assemblies. All of them stay in memory in the per process cache and all of them become part of the
-per-project cache file, meaning that they will be read back from disk on each subsequent hot invocation. Not only does it hurt build performance, but it is also
-wasteful to duplicate >2 MB worth of serialized assembly information in each project's intermediate directory.
-
-## Proposed design
-
-Completely rewriting RAR doesn't appear to be worthwhile. The requirements described above are for a typical build, not necessarily for all builds. RAR is highly
-configurable and customizable, thus the bar for backward compatibility is very high. There are definitely opportunities for micro-optimizations without any functional
-effect. Be it eliminating allocations, simplifying tight loops, reordering cases in hot switches, ..., there is a lot of low-hanging fruit. This by itself won't help
-address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.
-
-For regular project references the system works as about as efficient as possible.
-- In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.
-- In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the
-corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.
-- In a hot scenario, where there is state in memory, the only I/O on the happy path is the timestamp check to verify that the file hasn't changed since last time.
-
-There is a chance that the timestamp check can be replaced with something faster, although historically we haven't been able to come up with anything solid.
-File watchers, for example, while tempting to use because the validity check in the happy case would cost literally nothing, suffer from an inherent race
-condition. When a watched file is modified, the file watcher routine is not guaranteed to run by the time we need to reliably know whether the file is unchanged.
-The exact time the routine is executed depends on the latency of the asynchronous OS callback, on thread pool availability, CPU scheduling, and more.
-
-The focus of the following paragraphs is instead on SDK and NuGet references, because there are typically one to two orders of magnitude more of them than project
-references, so optimizing them has the best bang for the buck.
-
-### Obtain assembly names from the SDK
-
-The SDK is currently already passing relevant metadata such as `AssemblyVersion` and `PublicKeyToken`, so there is no need for RAR to open the file and parse its
-.NET metadata tables to get this information. This, together with the fact that SDK references are marked with `ExternallyResolved` so they cannot have dependencies
-outside of the primary set, means that there is no need to cache anything about these assemblies. Everything RAR needs comes (or can come if it's not there already)
-from the `Assemblies` parameter, explicitly provided on each invocation. Note, it may make sense to keep a cache in memory but it definitely doesn't make sense
-to save it to disk.
-
-If we do this, then in the warm and hot scenarios where the per project disk cache exists, we use it only to cache data about NuGet references and project references,
-significantly reducing its size. By eliminating per-reference I/O for most references, RAR would see a significant performance boost.
-
-This is assuming we trust the SDK that it passes correct data and we trust the user that they don't delete or overwrite their SDK files. If this assumption is not
-valid, the mitigation would be to store and check the timestamp of each individual file. We would still benefit from smaller on disk caches, being able to store only
-the timestamp and not assembly name for intact SDK references, but the hot scenario wouldn't get any faster than today.
-
-### Treat NuGet references as immutable [shelved]
-
-NuGet references live in the NuGet cache which is conceptually immutable. If RAR takes advantage of this, it can eliminate timestamp checks for NuGet references as
-well. The risk is higher than for SDK references because overwriting files in the NuGet cache is commonly used as a cut-the-corner workaround. The benefit is smaller
-because the number of NuGet references is typically lower. The proposal is to shelve this opportunity for now due to the unfavorable risk-benefit ratio.
-
-### Don't load the per project disk cache when not needed
-
-As described above, the on disk cache is not adding any value in the hot scenario because its contents already lives in the in-memory cache. The proposal is to
-load it lazily only when (and if) RAR runs into an assembly that does not have a record in the in-memory cache. In developer inner loop, when the same solution is
-built over and over again, the cache would typically not be loaded at all, unless the developer makes a change that actually changes the dependency graph.
-
-### Save only relevant data to the per project disk cache
-
-As for saving the per-project cache, we would guarantee that after RAR is done, the cache contains exactly the data needed for this specific project. This would
-be done by keeping track of the items used during RAR execution, and writing those and only those to the cache. Having a cache that's guaranteed to have certain
-well-defined content after each build is a very good property to have. For instance, in dev box scenarios it would otherwise be hard to reliably "prime" a repo
-enlistment - the system may prime by building the full solution and then the developer uses the box to build a specific project that happens to have an incomplete
-cache and get sub-optimal first-time build performance.
-
-Saving of the per-project disk cache may be further optimized by
-- Keeping the timestamp of the cache file in memory and skipping the save if the relevant cache items haven't become dirty (i.e. the dependencies have not changed)
-*and* the timestamp of the cache file hasn't changed since the last save. In hot inner loop scenarios this would reduce the save to a timestamp check.
-- Saving the file asynchronously, i.e. not blocking the build on completing the save operation.
-
-### Don't use the SDK disk pre-cache
-
-The idea of pre-generated on-disk cache is sound. For the `ExternallyResolved` SDK assemblies specifically, though, it effectively duplicates the information already
-present in `FrameworkList.xml`. That is, it maps assembly paths to assembly names. If the need arises we may want to re-design the pre-cache to remove the major
-drawback that it duplicates itself into all per-project caches. Cold RAR would load both caches and combine their contents (currently it's either or). Until then,
-it should be OK to leave it unchanged and unused.
diff --git a/documentation/specs/remote-host-object.md b/documentation/specs/remote-host-object.md
deleted file mode 100644
index 536535637d2..00000000000
--- a/documentation/specs/remote-host-object.md
+++ /dev/null
@@ -1,31 +0,0 @@
-# Support for remote host object
-
-A remote host object must be registered in the [Running Object Table (ROT)](https://docs.microsoft.com/en-us/windows/desktop/api/objidl/nn-objidl-irunningobjecttable) before calling `RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName)`. In the out-of-process node, MSBuild will call [`IRunningObjectTable::GetObject`](https://docs.microsoft.com/en-us/windows/desktop/api/objidl/nf-objidl-irunningobjecttable-getobject) to get the host object by the monikerName that was registered via `RegisterHostObject`.
-
-[The registration of interfaces](https://docs.microsoft.com/en-us/dotnet/framework/interop/how-to-register-primary-interop-assemblies) is the only thing interop with COM that need extra care. There are 3 interfaces involved in out-of-proc tasks work: `IVsMSBuildTaskFileManager`, `IPersistFileCheckSum` and `ITaskHost`. `IVsMSBuildTaskFileManager` and `IPersistFileCheckSum` are registered globally in Windows registry by VS existing setup. `ITaskHost` is also configured in VS using registration-free. So the only work is to configure it using registration-free in **MSBuild**. That results the change in msbuild.exe.manifest file and the change to generate tlb file for ITaskHost.
-
-## Annotated additions to the msbuild.exe.manifest file.
-```
-<file name="Microsoft.Build.Framework.tlb"> -- Location of the tlb, it should be in the same directory as msbuild.exe
-    <typelib
-        tlbid="{D8A9BA71-4724-481D-9CA7-0DA23A1D615C}" -- matches what is embedded in the tlb with ITaskHost
-        version="15.1" -- matches the version in tlb
-        helpdir=""/>
-</file>
-
-<comInterfaceExternalProxyStub
-    iid="{9049A481-D0E9-414f-8F92-D4F67A0359A6}" -- iid of type ITaskHost for COM
-    name="ITaskHost" -- does not have to match
-    tlbid="{D8A9BA71-4724-481D-9CA7-0DA23A1D615C}" -- tlb id, so it can link to previous session
-    proxyStubClsid32="{00020424-0000-0000-C000-000000000046}" /> -- universal marshaler built in Windows
-```
-
-## Bigger context
-
-If is part of the work for [allowing out-of-proc tasks to access unsaved changes](https://github.com/dotnet/project-system/issues/4406)
-
-## More reference:
-
-[RegFree COM Walkthrough](https://msdn.microsoft.com/library/ms973913.aspx)
-
-[RegFree COM with .NET Framework](https://docs.microsoft.com/dotnet/framework/interop/configure-net-framework-based-com-components-for-reg)
diff --git a/documentation/specs/resource-management.md b/documentation/specs/resource-management.md
deleted file mode 100644
index 92343be73a4..00000000000
--- a/documentation/specs/resource-management.md
+++ /dev/null
@@ -1,41 +0,0 @@
-# Managing tools with their own parallelism in MSBuild
-
-MSBuild supports building projects in parallel using multiple processes. Most users opt into `Environment.ProcessorCount` parallelism at the MSBuild layer.
-
-In addition, tools sometimes support parallel execution. The Visual C++ compiler `cl.exe` supports `/MP[n]`, which parallelizes compilation at the translation-unit (file) level. If a number isn't specified, it defaults to `NUM_PROCS`.
-
-When used in combination, `NUM_PROCS * NUM_PROCS` compiler processes can be launched, all of which would like to do file I/O and intense computation. This generally overwhelms the operating system's scheduler and causes thrashing and terrible build times.
-
-As a result, the standard guidance is to use only one multiproc option: MSBuild's _or_ `cl.exe`'s. But that leaves the machine underloaded when things could be happening in parallel.
-
-## Design
-
-`IBuildEngine` will be extended to allow a task to indicate to MSBuild that it would like to consume more than one CPU core (`RequestCores`). These will be advisory only — a task can still do as much work as it desires with as many threads and processes as it desires.
-
-A cooperating task would limit its own parallelism to the number of CPU cores MSBuild can reserve for the requesting task.
-
-`RequestCores(int requestedCores)` will always return a positive value, possibly less than the parameter if that many cores are not available. If no cores are available at the moment, the call blocks until at least one becomes available. The first `RequestCores` call made by a task is guaranteed to be non-blocking, though, as at minimum it will return the "implicit" core allocated to the task itself. This leads to two conceptual ways of adopting the API. Either the task calls `RequestCores` once, passing the desired number of cores, and then limiting its parallelism to whatever the call returns. Or the task makes additional calls throughout its execution, perhaps as it discovers more work to do. In this second scenario the task must be OK with waiting for additional cores for a long time or even forever if the sum of allocated cores has exceeded the limit defined by the policy.
-
-All resources acquired by a task will be automatically returned when the task's `Execute()` method returns, and a task can optionally return a subset by calling `ReleaseCores`. Additionally, all resources will be returned when the task calls `Reacquire` as this call is a signal to the scheduler that external tools have finished their work and the task can continue running. It does not matter when the resources where allocated - whether it was before or after calling `Yield` - they will all be released. Depending on the scheduling policy, freeing resources on `Reacquire` may prevent deadlocks.
-
-The exact core reservation policy and its interaction with task execution scheduling is still TBD. The pool of resources explicitly allocated by tasks may be completely separate, i.e. MSBuild will not wait until a resource is freed before starting execution of new tasks. Or it may be partially or fully shared to prevent oversubscribing the machine. In general, `ReleaseCores` may cause a transition of a waiting task to a Ready state. And vice-versa, completing a task or calling `Yield` may unblock a pending `RequestCores` call issued by a task.
-
-## Example 1
-
-In a 16-process build of a solution with 30 projects, 16 worker nodes are launched and begin executing work. Most block on dependencies to projects `A`, `B`, `C`, `D`, and `E`, so they don't have tasks running holding resources.
-
-Task `Work` is called in project `A` with 25 inputs. It would like to run as many as possible in parallel. It calls
-
-```C#
-int allowedParallelism = BuildEngine8.RequestCores(Inputs.Count); // Inputs.Count == 25
-```
-
-and gets up to `16`--the number of cores available to the build overall.
-
-While `A` runs `Work`, projects `B` and `C` run another task `Work2` that also calls `RequestCores` with a high value. Since `Work` in `A` has reserved all cores, the calls in `B` and `C` may return only 1, indicating that the task should not be doing parallel work. Subsequent `RequestCores` may block, waiting on `Work` to release cores (or return).
-
-When `Work` returns, MSBuild automatically returns all resources reserved by the task to the pool. At that time blocked `RequestCores` calls in `Work2` may unblock.
-
-## Implementation
-
-The `RequestCores` and `ReleaseCores` calls are marshaled back to the scheduler via newly introduced `INodePacket` implementations. The scheduler, having full view of the state of the system - i.e. number of build requests running, waiting, yielding, ..., number of cores explicitly allocated by individual tasks using the new API - is free to implement an arbitrary core allocation policy. In the initial implementation the policy will be controlled by a couple of environment variables to make it easy to test different settings.
diff --git a/documentation/specs/sdk-resolvers-algorithm.md b/documentation/specs/sdk-resolvers-algorithm.md
deleted file mode 100644
index e5cd05a0dd3..00000000000
--- a/documentation/specs/sdk-resolvers-algorithm.md
+++ /dev/null
@@ -1,59 +0,0 @@
-## SDK Resolution Algorithm
-In 17.3 under ChangeWave 17.4 the sdk resolution algorithm is changed.
-
-### Reason for change
-Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavior in 17.3 under ChangeWave 17.4.
-
-### New SDK Resolution Algorithm
-Under ChangeWave 17.4 all the resolvers divides into two groups:
-- Specific resolvers, i.e. resolvers with specified sdk name pattern `ResolvableSdkPattern`
-- General resolvers, i.e. resolvers without specified sdk name pattern `ResolvableSdkPattern`
-
-The resolving algorithm works in two passes. 
-- On the first pass all the specific resolvers that match the given sdk name would be loaded, ordered by priority and tried one after one. 
-- If the sdk is not found, on the second pass all general resolvers would be loaded, ordered by priority and tried one after one.
-
-By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `ResolvableSdkPattern` using C# regex format:
-```
-<SdkResolver>
-  <Path>MySdkResolver.dll</Path>
-  <ResolvableSdkPattern>MySdk.*</ResolvableSdkPattern>
-</SdkResolver>
-```
-
-Note, that the manifest file, if exists, from ChangeWave 17.4 would have preference over the dll.
-The sdk discovery works according to the following algorithm:
-- First try locate the manifest file and use it. 
-- If it is not found, we try to locate the dll in the resolver's folder. 
-Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
-
-### Failed SDK Resolution
-
-> 🚧 Note
->
-> This page is a work in progress.
-
-SDK resolvers previously attempted to continue when one critically fails (throws an unhandled exception). This lead to misleading error messages such as:
-
-```
-warning MSB4242: The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed to run. 's' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8.
-error MSB4236: The SDK 'Microsoft.NET.SDK.WorkloadAutoImportPropsLocator' specified could not be found. [C:\foo\bar.csproj]
-```
-
-`MSB4236` is a red herring while `MSB4242` is the real error despite being logged as a warning. Because of this, SDK resolvers now fail the build _immediately_ upon unhandled exceptions. These exceptions are propogated as `SdkResolverException`s, and `MSB4242` has been promoted to an error code. The new error message appears like so:
-
-```
-C:\src\temp\8-18>"C:\foo\dotnet-sdk-6.0.100-preview.7.21379.14-win-x64\dotnet.exe" build    
-Microsoft (R) Build Engine version 17.0.0-dev-21420-01+5df152759 for .NET
-Copyright (C) Microsoft Corporation. All rights reserved.
-
-C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
-
-Build FAILED.
-
-C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
-    0 Warning(s)
-    1 Error(s)
-
-Time Elapsed 00:00:00.15
-```
\ No newline at end of file
diff --git a/documentation/specs/single-project-isolated-builds.md b/documentation/specs/single-project-isolated-builds.md
deleted file mode 100644
index 75b15fc5b82..00000000000
--- a/documentation/specs/single-project-isolated-builds.md
+++ /dev/null
@@ -1,43 +0,0 @@
-# Single Project Isolated Builds: Implementation Details
-
-<!-- workflow -->
-Single project isolated builds can be achieved by providing MSBuild with input and output cache files.
-
-The input cache files contain the cached `TargetResult`s of all targets that a project calls on its references. When a project builds without isolation, it builds its references via [MSBuild task](aka.ms/msbuild_tasks) calls. In isolated builds, the engine, instead of executing these tasks, serves their results from the provided input caches. In an isolated project build, only the top level project (built via the `BuildManager` APIs) should build targets; Any referenced projects by the top level project should be provided from the input caches.
-
-The output cache file tells MSBuild where to serialize the `TargetResult`s for a project's built targets and becomes an input cache for dependent projects.
-
-The presence of either input or output caches turns on [isolated build constraints](static-graph.md##single-project-isolated-builds).
-
-## Input / Output Cache Implementation
-<!-- cache structure -->
-The cache files contain the serialized state of MSBuild's [`ConfigCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [`ResultsCache`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs), which have been traditionally used by the engine to cache build results. They ensure that a target is only built once per build submission. `ConfigCache` entries are instances of [`BuildRequestConfiguration`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25)s (a `(project path, global properties)` tuple), and `ResultsCache` entries are instances of [`BuildResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34)s, which contain [`TargetResult`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22)s. The `ConfigCache` entries and `ResultsCache` entries form a [bijection](https://en.wikipedia.org/wiki/Bijection).
-
-<!-- cache lifetime -->
-In a build, the input and output cache files have the same lifetime as the `ConfigCache` and  `ResultsCache`. The `ConfigCache` and  `ResultsCache` are owned by the [`BuildManager`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/BuildManager/BuildManager.cs), and their lifetimes are one `BuildManager.BeginBuild` / `BuildManager.EndBuild` session. On command-line builds, the cache lifetime is the same as the entire process lifetime since `MSBuild.exe` uses one `BuildManager` with one `BeginBuild` / `EndBuild` session. When other processes (e.g. Visual Studio's `devenv.exe`) perform MSBuild builds via the `BuildManager` APIs, there can be multiple build sessions in the same process.
-
-<!-- constraints -->
-
-When loading input cache files, MSBuild merges incoming instances of `ConfigCache`s and `ResultsCache`s into one instance of each with the help of the [`CacheAggregator`](https://github.com/dotnet/msbuild/blob/51df47643a8ee2715ac67fab8d652b25be070cd2/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L15), which enforces the following constraints:
-- No duplicate cache entries
-- Bijection:
-   - `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
-   - `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`
-
-Note that the output cache file contains a single `BuildResult` with the `TargetResult`s from the project specified to be built in the `BeginBuild` / `EndBuild` session, as any `BuildResult`s obtained through isolation exemption are excluded to prevent potential duplicate input cache entries; Entries from input caches are not transferred to the output cache.
-
-<!-- How input / output cache entries are separated with the override caches -->
-Input cache entries are separated from output cache entries with the composite caches [`ConfigCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [`ResultsCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). Each composite cache contains two underlying caches: a cache where input caches files are loaded into (the override cache), and a cache where new results are written into (the current cache).* In the `ConfigCacheWithOverride`, these caches are instances of `ConfigCache`s and, in the `ResultsCacheWithOverride`, these caches are instances of `ResultsCache`s. A query for a cache entry is first attempted from the override cache and, if unsatisfied, a second attempt is made from the current cache. Writes are only written to the current cache, never into the override cache.* It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache query.
-
-## Isolation Implementation
-
-[Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the `Scheduler` and  `TaskBuilder`. [`TaskBuilder.ExecuteInstantiatedTask`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in a `ProjectReference` item. [`Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
-
-### Isolation Exemption
-The `Scheduler` [skips isolation constraints](static-graph.md#exempting-references-from-isolation-constraints) on project references via the:
-
-* `GraphIsolationExemptReference` item. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of a `BuildRequest` to `true` if the `RequestBuilder` matches it against a `GraphIsolationExemptReference` item defined in the calling project. Additionally, the `RequestBuilder` marks the `BuildRequest`'s corresponding `BuildRequestConfiguration` as exempt to allow the `TaskBuilder` to verify exemption from isolation constraints.
-
-* `isolate:MessageUponIsolationViolation` switch. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of _every_ `BuildRequest` to `true`. The `TaskBuilder` verifies exemption from isolation constraints just by the switch value.
-
-\* Except in the following scenario when a `ProjectReference` is exempted from isolation constraints: a dependency project A outputs a cache file F containing a `BuildResult` with `TargetResult`s T<sub>cached</sub> for targets t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>m</sub> and a dependent project B uses F as an input cache file but builds and obtains the `TargetResult`s T<sub>new</sub> for targets t<sub>m + 1</sub>, t<sub>m + 2</sub>, ..., t<sub>n</sub> such that 0 < m < n. In this case, T<sub>new</sub> will be placed into the `ResultsCache` containing T<sub>cached</sub> to enforce no overlap between the override and current caches in the `ConfigCacheWithOverride`.
\ No newline at end of file
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
deleted file mode 100644
index 49acebe57fe..00000000000
--- a/documentation/specs/static-graph.md
+++ /dev/null
@@ -1,531 +0,0 @@
-# Static Graph
-
-## What is static graph for?
-
-As a repo gets bigger and more complex, weaknesses in MSBuild's scheduling and incrementality models become more apparent. MSBuild's static graph features are intended to ameliorate these weaknesses while remaining as compatible as possible with existing projects and SDKs.
-
-MSBuild projects can refer to other projects by using the `MSBuild` task to execute targets in another project and return values. In `Microsoft.Common.targets`, `ProjectReference` items are transformed into `MSBuild` task executions in order to provide a user-friendly interface: "reference the output of these projects".
-
-### Weakness of the old model: project-level scheduling
-
-Because references to other projects aren't known until a target in the referencing project calls the `MSBuild` task, the MSBuild engine cannot start working on building referenced projects until the referencing project yields. For example, if project `A` depended on `B`, `C`, and `D` and was being built with more-than-3 way parallelism, an ideal build would run `B`, `C`, and `D` in parallel with the parts of `A` that could execute before the references were available.
-
-Today, the order of operations of this build are:
-
-1. `A` completes evaluation and starts building, doing isolated work until it gets to `ResolveProjectReferences`.
-1. In parallel, `B`, `C`, and `D` run the requested targets.
-1. `A` resumes building and completes.
-
-With graph-aware scheduling, this becomes:
-
-1. `A`, `B`, `C`, and `D` evaluate in parallel.
-1. `B`, `C`, and `D` build to completion in parallel.
-1. `A` builds, and instantly gets cached results for the `MSBuild` task calls in `ResolveProjectReferences`
-
-### Weakness of the old model: incrementality
-
-[Incremental build](https://docs.microsoft.com/visualstudio/msbuild/incremental-builds) (that is, "redo only the parts of the build that would produce different outputs compared to the last build") is the most powerful tool to reduce build times and increase developer inner-loop speed.
-
-MSBuild supports incremental builds by allowing a target to be skipped if the target's outputs are up to date with its inputs. This allows tools like the compiler to be skipped when possible. But since the incrementality is at the target level, MSBuild must fully evaluate the project and walk through all targets, running those that are out of date or that don't specify inputs and outputs.
-
-Consider a simple solution with a library and an application that depends on the library. Suppose you build, then make a change in the application's source code, then build again.
-
-The second build will:
-
-1. Build the library project, skipping all targets that define inputs and outputs.
-1. Build the application project.
-
-But using higher-level knowledge, we can see a more-optimal build:
-
-1. Skip everything involving the library project, because _none_ of its inputs have changed.
-1. Build only the application project.
-
-Visual Studio offers a ["fast up-to-date check"](https://github.com/dotnet/project-system/blob/cd275918ef9f181f6efab96715a91db7aabec832/docs/up-to-date-check.md) system that gets closer to the latter, but MSBuild itself does not.
-
-### Weakness of the old model: caching and distributability
-
-For very large builds, including many Microsoft products, the fact that MSBuild can build in parallel only on a single machine is a major impediment, even if incrementality is addressed.
-
-Ideally, a build could span multiple computers, and each could use results generated on another machine as inputs to its own build projects. In addition, if all of a project's inputs remain unchanged, the system would ideally reuse the outputs of the project, even if they were built long ago on another computer.
-
-Microsoft has an internal build system, [CloudBuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), that supports this and has proven that it is effective, but is heuristic-based and requires maintenance.
-
-MSBuild static graph features make it easier to implement a system like CloudBuild by building operations like graph construction and output caching into MSBuild itself.
-
-## What is static graph?
-
-MSBuild's static graph extends the MSBuild engine and APIs with new functionality to improve on these weaknesses:
-
-- The ability to [construct a directed acyclic graph of MSBuild projects](#project-graph) given an entry point (solution or project).
-- The ability to consider that graph when scheduling projects for build.
-- The ability to cache MSBuild's internal build results (metadata about outputs, not the outputs themselves) across build invocations.
-- The ability to [enforce restrictions on builds](#isolated-builds) to ensure that the graph is correct and complete.
-
-Static graph functionality can be used in three ways:
-
-- On the command line with `-graph` (and equivalent API).
-  - This gets the scheduling improvements for well-specified projects, but allows underspecified projects to complete without error.
-- On the command line with `-graph -isolate` (and equivalent API).
-  - This gets the scheduling improvements and also enforces that the graph is correct and complete. In this mode, MSBuild will produce an error if there is an `MSBuild` task invocation that was not known to the graph ahead of time.
-- As part of a higher-order build system that uses [single project isolated builds](#single-project-isolated-builds) to provide caching and/or distribution on top of the built-in functionality. The only known implementation of this system is Microsoft-internal currently.
-
-"Correct and complete" here means that the static graph can be used to accurately predict all targets that need to be built for all projects in the graph, and all of the references between projects. This is required for the higher-order build system scenario, because an unknown reference couldn't be satisfied at runtime (as it is in regular MSBuild and `-graph` with no `-isolate` scenarios).
-
-## Design documentation
-
-### Design goals
-
-- Stock projects can build with "project-level build" and if clean onboard to MS internal build engines with cache/distribution
-- Stock projects will be "project-level build" clean.
-- Add determinism to MSBuild w.r.t. project dependencies. Today MSBuild discovers projects just in time, as it finds MSBuild tasks. This means there’s no guarantee that the same graph is produced two executions in a row, other than hopefully sane project files. With the static graph, you’d know the shape of the build graph before the build starts.
-- Potential perf gain in graph scheduling
-- Increase perf of interaction between MSBuild and higher-order build engines (eg. MS internal build engines) - reuse evaluation and MSBuild nodes
-- **Existing functionality must still work. This new behavior is opt-in only.**
-
-## Project Graph
-
-### Constructing the project graph
-Calculating the project graph will be very similar to the MS internal build engine's existing Traversal logic. For a given evaluated project, all project references will be identified and recursively evaluated (with deduping).
-Project references are identified via the `ProjectReference` item.
-
-A node in the graph is a tuple of the project file and global properties. Each (project, global properties) combo can be evaluated in parallel.
-
-Transitive project references are opt-in per project. Once a project opts-in, transitivity is applied for all ProjectReference items.
-A project opt-ins by setting the property `AddTransitiveProjectReferencesInStaticGraph` to true.
-
-### Build dimensions
-
-Build dimensions can be thought of as different ways to build a particular project. For example, a project can be built Debug or Retail, x86 or x64, for .NET Framework 4.7.1 or .NET Core 2.0.
-
-Because we are using ProjectReferences to determine the graph, we will need to duplicate the mapping of ProjectReference metadata to global properties given to the MSBuild task. This means that we need to couple the engine to the common MSBuild targets, which means that whenever we change those targets we need to update the project graph construction code as well.
-
-**OPEN ISSUE:** What about MSBuild calls which pass in global properties not on the ProjectReference? Worse, if the global properties are computed at runtime? The sfproj SDK does this with PublishDir, which tells the project where to put its outputs so the referencing sfproj can consume them. We may need to work with sfproj folks and other SDK owners, which may not be necessarily a bad thing since already the sfproj SDK requires 2 complete builds of dependencies (normal ProjectReference build + this PublishDir thing) and can be optimized. A possible short term fix: Add nodes to graph to special case these kinds of SDKs. This is only really a problem for isolated builds.
-
-The graph also supports multiple entry points, so this enables scenarios where projects build with different platforms in one build. For example, one entry point could be a project with global properties of `Platform=x64` and another entry point might be that same project with `Platform=x86`. Because the project graph understands the metadata on project references as well, including `GlobalPropertiesToRemove`, this also enables the notion of "platform agnostic projects" which should only build once regardless of the platform. Note that multiple entry points will not be useable from the command-line due to the inability to express it concisely, and so programmatic access must be used in that case.
-
-For example, if project A had a project reference to project B with `GlobalPropertiesToRemove=Platform`, and we wanted to build project A for x86 and x64 so used both as entry points, the graph would consist of 3 nodes: project A with `Platform=x86`, project A with `Platform=x64`, and project B with no global properties set.
-
-#### Multitargeting
-
-<!-- definition and TF example-->
-Multitargeting refers to projects that specify multiple build dimensions applicable to themselves. For example, `Microsoft.Net.Sdk` based projects can target multiple target frameworks (e.g. `<TargetFrameworks>net472;netcoreapp2.2</TargetFrameworks>`). As discussed, build dimensions are expressed as global properties. Let's call the global properties that define the multitargeting set as the multitargeting global properties.
-
-<!-- how it works: outer builds and inner builds -->
-Multitargeting is implemented by having a project reference itself multiple times, once for each combination of multitargeting global properties. This leads to multiple evaluations of the same project, with different global properties. These evaluations can be classified in two groups
-1.  Multiple inner builds. Each inner build is evaluated with one set of multitargeting global properties (e.g. the `TargetFramework=net472` inner build, or the `TargetFramework=netcoreapp2.2` inner build).
-2.  One outer build. This evaluation does not have any multitargeting global properties set. It can be viewed as a proxy for the inner builds. Other projects query the outer build in order to learn the set of valid multitargeting global properties (the set of valid inner builds). When the outer build is also the root of the project to project graph, the outer build multicasts the entry target (i.e. `Build`, `Clean`, etc) to all inner builds.
-
-<!-- contract with the graph -->
-
-In order for the graph to represent inner and outer builds as nodes, it imposes a contract on what multitargeting means, and requires the multitargeting supporting SDKs to implement this contract.
-
-Multitargeting supporting SDKs MUST implement the following properties and semantics:
-- `InnerBuildProperty`. It contains the property name that defines the multitargeting build dimension.
-- `InnerBuildPropertyValues`. It contains the property name that holds the possible values for the `InnerBuildProperty`.
-- Project classification:
-  - *Outer build*, when `$($(InnerBuildProperty))` is empty AND  `$($(InnerBuildPropertyValues))` is not empty.
-  - *Dependent inner build*, when both `$($(InnerBuildProperty))` and  `$($(InnerBuildPropertyValues))` are non empty. These are inner builds that were generated from an outer build.
-  - *Standalone inner build*, when `$($(InnerBuildProperty))` is not empty and `$($(InnerBuildPropertyValues))` is empty. These are inner builds that were not generated from an outer build.
-  - *Non multitargeting build*, when both `$($(InnerBuildProperty))` and  `$($(InnerBuildPropertyValues))` are empty.
-- Node edges
-  - When project A references multitargeting project B, and B is identified as an outer build, the graph node for project A will reference both the outer build of B, and **all the inner builds of B**. The edges to the inner builds are **speculative**, as at build time only one inner build gets referenced. However, the graph cannot know at evaluation time which inner build will get chosen.
-  - When multitargeting project B is a root, then the outer build node for B will reference **all the inner builds of B**.
-  - For multitargeting projects, the `ProjectReference` item gets applied only to inner builds. An outer build cannot have its own distinct `ProjectReference`s, it is the inner builds that reference other project files, not the outer build. This constraint might get relaxed in the future via additional configuration, to allow outer build specific references.
-
-These specific rules represent the minimal rules required to represent multitargeting in `Microsoft.Net.Sdk`. As we adopt SDKs whose multitargeting complexity that cannot be expressed with the above rules, we'll extend the rules.
-For example, `InnerBuildProperty` could become `InnerBuildProperties` for SDKs where there's multiple multitargeting global properties.
-
-For example, here is a trimmed down `Microsoft.Net.Sdk` multitargeting project:
-```xml
-<Project Sdk="Microsoft.Net.Sdk">
-  <!-- This property group is defined in the sdk -->
-  <PropertyGroup>
-    <InnerBuildProperty>TargetFramework</InnerBuildProperty>
-    <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
-  </PropertyGroup>
-
-  <!-- This property group is defined in the project file-->
-  <PropertyGroup>
-    <TargetFrameworks>net472;netcoreapp2.2</TargetFrameworks>
-  </PropertyGroup>
-</Project>
-```
-
-To summarize, there are two main patterns for specifying build dimensions:
-1. Multitargeting based. A multitargeting project self describes supported build dimensions. In this case the SDK needs to specify the multitargeting build dimensions. The graph then extracts innerbuilds from a given outer build. For example, the `TargetFramework` build dimension gets specified this way.
-2. Global Property based: A top level set of global properties get applied to the graph entrypoints and get propagated downward through the graph. For example, the `Configuration` and `Platform` build dimensions get specified this way.
-
-Why does an outerbuild need to generate speculative edges to all of its innerbuilds? Why can't it use nuget to prune the speculative edges down to the compatible set?
-- One big design constraint we imposed on static graph was to keep it agnostic of SDK implementation details. So the graph must not know about particular details of one language's SDK. We wanted a generic design that all language SDKs can leverage. We considered that calling nuget to get the compatible TargetFramework values breaks this rule, as both the concept of "nuget" and the concept of "TargetFramework" are implementation details of the .net SDK. If someone were to write a Java SDK, would "calling nuget to get the compatible TargetFramework" still be relevant? A solution to this is to allow SDKs to configure the graph with an extension point on "how to collapse multiple speculative innerbuild edges into a smaller compatible set", but we didn't have the time to design it yet.
-- There is a conflicting need between build everything or just building a "TF slice" through the graph. Outer loop builds (CI builds) that publish binaries need to build all the packages for all the supported TFs, so they need the graph to express all possible combinations. Inner loop builds (dev-at-work) can be sliced down to only the TF that the dev is working on in order to reduce build times. Again, we didn't have time to design how to express these two things so we went with "express everything" because that allows both scenarios to work.
-
-### Executing targets on a graph
-When building a graph, project references should be built before the projects that reference them, as opposed to the existing msbuild scheduler which builds projects just in time.
-
-For example if project A depends on project B, then project B should build first, then project A. Existing msbuild scheduling would start building project A, reach an MSBuild task for project B, yield project A, build project B, then resume project A once unblocked.
-
-Building in this way should make better use of parallelism as all CPU cores can be saturated immediately, rather than waiting for projects to get to the phase in their execution where they build their project references. More subtly, less execution state needs to be held in memory at any given time as there are no paused builds waiting to be unblocked. Knowing the shape of the graph may be able to better inform the scheduler to prevent scheduling projects that could run in parallel onto the same node.
-
-Note that graph cycles are disallowed, even if they're using disconnected targets. This is a breaking change, as today you can have two projects where each project depends on a target from the other project, but that target doesn't depend on the default target or anything in its target graph.
-
-#### Command line
-`msbuild /graph` - msbuild will create a static graph from the entry point project and build it in topological order with the specified targets. Targets to call on each node are inferred via the rules in [this section](#inferring-which-targets-to-run-for-a-project-within-the-graph).
-
-#### APIs
-
-[BuildManager.PendBuildRequest(GraphBuildRequestData requestData)](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/BuildManager.cs#L676)
-
-### Inferring which targets to run for a project within the graph
-In the classic MSBuild build (i.e. execution of targets), the referencing project chooses which targets to call on the referenced projects and may call into a project multiple times with different target lists and global properties (examples in [project reference protocol](../ProjectReference-Protocol.md)). This is a top-down traversal of dependencies. These calls are made via the [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task?view=vs-2019). When building a graph, projects are built before the projects that reference them. This is a bottom-up traversal. Therefore the graph needs to determine the list of targets to execute on a specific project `B` **before** building the referencing projects that reference `B`.
-
-The static graph contains the structural information on which reference projects a referencing project depends on. But it does not contain information on what "depends" means. At build time "depends" means that a referencing evaluated project will call a subset of reference evaluations with some targets. Subset because the static graph is an inferred graph, therefore there are ambiguities during graph construction, and thus it needs to be conservative and represent a superset of the "runtime graph". The "runtime graph" is the actual graph that gets executed during a real build. We cannot know the runtime graph because that would require us to analyze msbuild xml code inside of targets in order to find the `MSBuild task` invocations. This means doing heavy program analysis, like symbolic execution. That would make things very complicated, slower, and would probably introduce even more ambiguity, so a larger superset conservative graph. So we kept it simple and only looked at evaluation time msbuild xml code (i.e. msbuild xml code outside of `<Target>` elements).
-To summarize, the static graph does not have insights into the `MSBuild task` callsites. It does not know callsite specific information such as the `Targets="Foo;Bar"` or `Properties="Foo=Bar"` `MSBuild task` attributes.
-Since the graph does not have access to MSBuild task callsites, it does not know what targets will get called for a given graph edge. 
-
-To infer target information we use a flow analysis to propagate target information down the graph. The flow analysis uses the `ProjectReferenceTargets` protocol (described further down) to infer how one incoming target on a graph node (e.g. `Build`) generates multiple outgoing targets to its referenced nodes (e.g. `GetTargetFrameworks`, `GetNativeManifest`, `Build`).
-SDKs **must** explicitly describe the project-to-project calling patterns via the `ProjectReferenceTargets` protocol in such a way that a graph based build can correctly infer the entry targets for a graph node.
-
-Each project needs to specify the project reference protocol targets it supports, in the form of a target mapping: `incoming target -> outgoing target list`. The `incoming target` represents the project reference entry target, and the `outgoing target list` represents the list of targets that `incoming target` ends up calling on each referenced project.
-
-For example, a simple recursive rule would be `A -> A`, which says that a project called with target `A` will call target `A` on its referenced projects. Here's an example execution with two nodes:
-
-```
-Execute target A+-->Proj1   A->A
-                    +
-                    |
-                    | A
-                    |
-                    v
-                    Proj2   A->A
-```
-
-Proj1 depends on Proj2, and we want to build the graph with target `A`. Proj1 gets inspected for the project reference protocol for target `A` (represented to the right of Proj1). The protocol says the referenced projects will be called with `A`. Therefore Proj2 gets called with target `A`. After Proj2 builds, Proj1 then also builds with `A` because Proj1 is an entry point and `A` is what was requested by the user.
-
-A project reference protocol may contain multiple targets, for example `A -> B, A`. This means that building `A` on the referencing project will lead to `B` and `A` getting called on the referenced projects. If all nodes in the graph repeat the same rule, then the rule is repeated recursively on all nodes. However, a project can choose to implement the protocol differently. In the following example, the entry targets are:
-- Proj4 is called with targets `B, A, C, D`. On multiple references, the incoming targets get concatenated. The order of these target lists does not matter, as MSBuild has non-deterministic p2p ordering, however the order within the target lists does. IE. `B, A, C, D` and `C, D, B, A` are valid, while `A, B, C, D` is not.
-- Proj3 and Proj2 get called with `B, A`, as specified by the rule in Proj1.
-- Proj1 builds with `A`, because it's the root of the graph.
-
-```
-            A+-->Proj1   A->B, A
-                 /    \
-           B, A /      \ B, A
-               /        \
-              v          v
-  A->B, A   Proj3      Proj2   A->C, D
-             \            /
-        B, A  \          /  C, D
-               \        /
-                \      /
-                 v    v
-                 Proj4   A->B, A
-```
-
-The common project reference protocols (Build, Rebuild, Restore, Clean) will be specified by the common props and targets file in the msbuild repository. Other SDKs can implement their own protocols (e.g. ASPNET implementing Publish).
-
-For this section and the remainder of this spec, a project's default target(s) (what it would execute if no other targets are specified, so often Build but configurable via DefaultTargets) will be referred to as `.default`. That is also how it is used in MSBuild code.
-
-Here are the rules for the common protocols:
-
-`Build -> GetTargetFrameworks, .default, GetNativeManifest, GetCopyToOutputDirectoryItems`
-
-`.default` is resolved for each project.
-
-`Clean -> GetTargetFrameworks, Clean`
-
-`Rebuild -> GetTargetFrameworks, Clean, .default, GetNativeManifest, GetCopyToOutputDirectoryItems`
-
-`Rebuild` actually calls `Clean` and `Build`, which in turn uses the concatenation of the `Clean` and `Build` mappings. `GetTargetFrameworks` is repeated so only the first call to it remains in the final target list.
-
-Restore is a composition of two rules:
-- `Restore -> _IsProjectRestoreSupported, _GenerateRestoreProjectPathWalk, _GenerateRestoreGraphProjectEntry`
-- `_GenerateRestoreProjectPathWalk -> _IsProjectRestoreSupported, _GenerateRestoreProjectPathWalk, _GenerateRestoreGraphProjectEntry`
-
-**Open Issue:** Restore is a bit complicated, and we may need new concepts to represent it. The root project calls the recursive `_GenerateRestoreProjectPathWalk` on itself to collect the referenced projects closure, and then after the recursion call returns (after having walked the graph), it calls the other targets on each returned referenced project in a non-recursive manner. So the above protocol is not a truthful representation of what happens, but it correctly captures all targets called on each node in the graph.
-
-We'll represent the project reference protocols as `ProjectReferenceTargets` items in MSBuild. For extensibility, the target list for the core mappings will be stored as properties so that users can append to it, but the `ProjectReferenceTargets` item ultimately is what will actually be read by the ProjectGraph.
-
-```xml
-<PropertyGroup>
-  <ProjectReferenceTargetsForClean>GetTargetFrameworks;Clean</ProjectReferenceTargetsForClean>
-</PropertyGroup>
-
-<ItemGroup>
-  <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)"/>
-</ItemGroup>
-```
-
-#### Multitargeting details
-
-A multitargeting project can get called with different targets for the outer build and the inner builds. In this case, the `ProjectReferenceTargets` items containing targets for the outer build are marked with the `OuterBuild=true` metadata. Here are the rules for how targets from `ProjectReferenceTargets` get assigned to different project types:
-  - *Outer build*: targets with `OuterBuild=true` metadata
-  - *Dependent inner build*: targets without `OuterBuild=true` metadata
-  - *Standalone inner build*: the same as non multitargeting builds.
-  - *Non multitargeting build*: concatenation of targets with `OuterBuild=true` metadata and targets without `OuterBuild=true` metadata
-
-**OPEN ISSUE:** Current implementation does not disambiguate between the two types of inner builds, leading to overbuilding certain targets by conservatively treating both inner build types as standalone inner builds.
-
-For example, consider the graph of `A (non multitargeting) -> B (multitargeting with 2 innerbuilds) -> C (standalone inner build)`, with the following target propagation rules:
-```
-A -> Ao when OuterBuild=true
-A -> Ai, A
-```
-
-According to the graph construction rules defined in the [multitargeting section](#multitargeting), we get the following graph, annotated with the target propagation for target `A`.
-
-```
-                   A+-->ProjA
-                      /   |   \
-                     /    |    \
-                    /     |     \
-                Ao /      |      \ Ai, A
-                  /       |       \
-                 /  Ai, A |        \
-                v         v         v
-       ProjB(outer)  ProjB(inner1)  ProjB(inner2)
-                          |         /
-                          |        /
-                          |       /
-                Ao, Ai, A |      / Ao, Ai, A
-                          |     /
-                          |    /
-                          v   v
-                          projC
-```
-
-### Underspecified graphs
-The intention is that the project graph and the target lists for each node be exactly correct, however MSBuild is quite flexible and particular projects or project types may not adequately describe these for the project graph.
-
-If a project calls into another project which either isn't represented in the graph or with a target list which isn't represented by the graph, it will fall back to classical MSBuild behavior and execute that target on the project reference just-in-time. This has the consequence of still requiring all project state be kept in memory in case any arbitrary project wants to execute targets on any other arbitrary project.
-
-To enable further optimizations (and strictness), graph builds can run [isolated](#isolated-builds) which enforces that the graph be entirely accurate.
-
-### Public API
-This is a proposal for what the public API for ProjectGraph may look like:
-
-```csharp
-namespace Microsoft.Build.Experimental.Graph
-{
-    public class ProjectGraph
-    {
-        // Creates a graph starting at the given project file.
-        public ProjectGraph(string projectFile) { }
-        public ProjectGraph(string entryProjectFile, IDictionary<string, string> globalProperties) { }
-
-        // Creates a graph starting at the given project files.
-        public ProjectGraph(IEnumerable<string> projectFiles) { }
-        public ProjectGraph(IEnumerable<string> entryProjectFiles, IDictionary<string, string> globalProperties) { }
-
-        // Creates a graph starting at the given entry point(s). An entry point is a (project file, global properties) pair.
-        public ProjectGraph(ProjectGraphEntryPoint entryPoint) { }
-        public ProjectGraph(IEnumerable<ProjectGraphEntryPoint> entryPoints) { }
-
-        /* Also various constructor overloads which take a ProjectCollection */
-
-        // Nodes for the provided entry points
-        IReadOnlyCollection<ProjectGraphNode> EntryPointNodes { get; }
-
-        // All project nodes in the graph.
-        IReadOnlyCollection<ProjectGraphNode> ProjectNodes { get; }
-    }
-
-    public struct ProjectGraphEntryPoint
-    {
-        public ProjectGraphEntryPoint(string projectFile) { }
-
-        public ProjectGraphEntryPoint(string projectFile, IDictionary<string, string> globalProperties) { }
-
-        // The project file to use for this entry point
-        public string ProjectFile { get; }
-
-        // The global properties to use for this entry point
-        public IDictionary<string, string> GlobalProperties { get; }
-    }
-
-    public class ProjectGraphNode
-    {
-        // No public creation.
-        internal ProjectGraphNode() { }
-
-        // Projects which this project references.
-        IReadOnlyCollection<ProjectGraphNode> ProjectReferences { get; }
-
-        // Projects which reference this project.
-        IReadOnlyCollection<ProjectGraphNode> ReferencingProjects { get; }
-
-        // The evaluated project
-        Project Project { get; }
-    }
-}
-```
-
-## Isolated builds
-Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any `BuildResult` objects for project references must be precomputed and somehow provided as inputs to the referencing project.
-
-If a project uses the MSBuild task, the build result must be in MSBuild's build result cache instead of just-in-time executing targets on that referenced project. If it is not in the build result cache, an error will be logged and the build will fail. If the project is calling into itself either via `CallTarget` or the MSBuild task with a different set of global properties, this will be allowed to support multitargeting and other build dimensions implemented in a similar way.
-
-Because referenced projects and their entry targets are guaranteed to be in the cache, they will not build again. Therefore we do not need to set `/p:BuildProjectReferences=false` or any other gesture that tells SDKs to not do recursive operations.
-
-### Isolated graph builds
-When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.
-
-Furthermore, running in this mode enforces that each `(project, global properties)` pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
-
-This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.
-
-### Single project isolated builds
-When building a single project in isolation, all project references' build results must be provided to the project externally. Specifically, the results will need to be [deserialized](#deserialization) from files and loaded into the build result cache in memory.
-
-When MSBuild runs in isolation mode, it fails the build when it detects:
-1. `MSBuild` task calls which cannot be served from the cache. Cache misses are illegal.
-2. `MSBuild` task calls to project files which were not defined in the `ProjectReference` item.
-
-Because of this, single project isolated builds is quite restrictive and is not intended to be used directly by end-users. Instead the scenario is intended for higher-order build engines which support caching and [distribution](#distribution).
-
-There is also the possibility for these higher-order build engines and even Visual Studio to enable faster incremental builds for a project. For example, when a project's references' build results are provided via file caches (and validated as up to date by that higher-order build engine), there is no need to evaluate or execute any targets for any reference.
-
-These incremental builds could be extended to the entire graph by keeping a project graph in memory as well as the last build result cache files for each node and whether a node's results are up to date. The higher-order build engine can then itself traverse the graph and do single project isolated builds only for projects which are not currently up to date.
-
-Details on how isolation and cache files are implemented in MSBuild can be found [here](./static-graph-implementation-details.md).
-
-#### APIs
-Cache file information is provided via [`BuildParameters`](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one `BuildManager` `BeginBuild`/`EndBuild` session.
-
-Isolation constraints are turned on via [`BuildParameters.IsolateProjects`](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used, except when the `isolate:MessageUponIsolationViolation` switch is used.
-
-#### Command line
-Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
-Isolation constraints are turned on via `/isolate` (they are also implicitly activated when either input or output caches are used).
-
-#### Exempting references from isolation constraints
-In certain situations one may want to exempt a reference from isolation constraints. A few potential cases:
-- debugging / onboarding to isolation constraints
-- exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)
-- relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)
-
-A project may be exempt from isolation constraints in two ways:
-
-<!-- List is encoded in HTML since XML code block
-and its following text won't be indented properly. -->
-<ul>
-<li>its full path is added to the <code>GraphIsolationExemptReference</code> item. For example, if project <code>A.csproj</code> references project <code>B.csproj</code>, the following snippet exempts <code>B.csproj</code> from isolation constraints while <code>A.csproj</code> is built:
-<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
-  <span class="hljs-tag">&lt;<span class="hljs-name">GraphIsolationExemptReference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"/Full/Path/To/B.csproj"</span> /&gt;</span>
-<span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>
-</code></pre>
-If multiple projects need to exempt the same reference, all of them need to add the reference to <code>GraphIsolationExemptReference</code>.
-</li>
-<li> via the <code>isolate:MessageUponIsolationViolation</code> switch
-</li>
-</ul>
-
-For now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.
-
-## I/O Tracking
-To help facilitate caching of build outputs by a higher-order build engine, MSBuild needs to track all I/O that happens as part of a build.
-
-**OPEN ISSUE:** This isn't actually true in most scenarios. Today the MS internal build engine can wrap any arbitrary process to track the I/O that happens as part of its execution as well as its children. That's sufficient for all scenarios except compiler servers or an MSBuild server (see below). Additionally, if the MS internal build engine supports any other build type besides MSBuild (or older versions of MSBuild), it will still need to be able to detour the process itself anyway.
-
-**NOTE**: Based on the complexity and challenges involved, the feature of I/O tracking in MSBuild is currently on hold and not scheduled to be implemented. This section intends to describe these challenges and be a dump of the current thinking on the subject.
-
-### Detours
-[Detours](https://github.com/microsoft/detours) will be used to intercept Windows API calls to track I/O. This is the same technology that [FileTracker](../../src/Utilities/TrackedDependencies/FileTracker.cs) and [FullTracking](../../src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs) use as well as what the MS internal build engine ("BuildXL Tracker") uses to track I/O.
-
-Today FileTracker and FullTracking are currently a bit specific to generating tlogs, and do not collect all the I/O operations we would want to collect like directory enumerations and probes. Additionally, the BuildXL Tracker implementation does not currently have the ability to attach to the currently running process.
-
-Either existing implementation would require some work to fit this scenario. Because FileTracker/FullTracking aren't actively being improved unlike BuildXL Tracker, we will likely be adding the necessary functionality to BuildXL Tracker.
-
-Elsewhere in this spec the final Detours-based file tracking implementation will simply be referred to as "Tracker".
-
-### Isolation requirement
-I/O Tracking will only be available when running isolated builds, as the current implementation of project yielding in MSBuild makes it exceedingly difficult to attribute any observed I/O to the correct project. Isolated builds make this feasible since each MSBuild node will be building exactly one project configuration at any given moment and each project configuration has a concrete start and stop time. This allows us to turn on I/O tracking for the MSBuild process and start and stop tracking with the project start and stop.
-
-**OPEN ISSUE:** For graph-based isolated builds, project evaluation happens in parallel on the main node. Any I/O that happens as part of evaluation should be reported for that specific project, but there's no good way to do that here.
-
-### Tool servers
-Tool servers are long-lived processes which can be reused multiple times across builds. This causes problems for Tracker, as that long-lived process is not a child process of MSBuild, so many I/O operations would be missed.
-
-For example, when `SharedCompilation=true`, the Roslyn compiler (csc.exe) will launch in server mode. This causes the `Csc` task to connect to any existing csc.exe process and pass the compilation request over a named pipe.
-
-To support this scenario, a new MSBuild Task API could be introduced which allows build tasks which interact with tool servers to manually report I/O. In the Roslyn example above, it would report reads to all assemblies passed via `/reference` parameters, all source files, analyzers passed by `/analyzer`, and report writes to the assembly output file, pdb, and xml, and any other reads and writes which can happen as part of the tool. Effectively, the task will be responsible for reporting what file operations the tool server may perform for the request it makes to it. Note that the tool server may cache file reads internally, but the task should still report the I/O as if the internal cache was empty.
-
-**OPEN ISSUE:** Analyzers are just arbitrary C# code, so there's no guarantees as to what I/O it may do, leading to possibly incorrect tracking.
-
-Similarly for a theoretical server mode for MSBuild, MSBuild would need to report its own I/O rather than the higher-order build engine detouring the process externally. For example, if the higher-order build engine connected to an existing running MSBuild process to make build requests, it could not detour that process and so MSBuild would need to report all I/O done as part of a particular build request.
-
-**OPEN ISSUE:** As described above in an open issue, tool servers are the only scenario which would not be supportable by just externally detouring the MSBuild process. The amount of investment required to enable tool servers is quite high and spans across multiple codebases: MSBuild needs to detour itself, MSBuild need to expose a new Tasks API, the `Csc` task needs to opt into that API, and the higher-order build engine needs to opt-in to MSBuild reporting its own I/O, as well as detecting that the feature is supported in the version of MSBuild it's using. Tool servers may add substantial performance gain, but the investment is also substantial.
-
-## Examples
-
-To illustrate the difference between `-graph` and `-graph -isolate`, consider these two projects, which are minimal except for a new target in the referenced project that is consumed in the referencing project.
-
-`Referenced\Referenced.csproj`:
-
-```xml
-<Project Sdk="Microsoft.NET.Sdk">
-
-  <PropertyGroup>
-    <TargetFramework>netcoreapp3.1</TargetFramework>
-    <UnusualOutput>Configuration\Unusual.txt</UnusualOutput>
-  </PropertyGroup>
-
-  <Target Name="UnusualThing" Returns="$(UnusualOutput)" />
-</Project>
-```
-
-`Referencing\Referencing.csproj`:
-
-```xml
-<Project Sdk="Microsoft.NET.Sdk">
-
-  <PropertyGroup>
-    <TargetFramework>netcoreapp3.1</TargetFramework>
-  </PropertyGroup>
-
-  <ItemGroup>
-    <ProjectReference Include="..\Referenced\Referenced.csproj" />
-  </ItemGroup>
-
-  <Target Name="GetUnusualThing" BeforeTargets="BeforeBuild">
-    <MSBuild Projects="..\Referenced\Referenced.csproj"
-             Targets="UnusualThing">
-      <Output TaskParameter="TargetOutputs"
-              ItemName="Content" />
-    </MSBuild>
-  </Target>
-</Project>
-```
-
-This project can successfully build with `-graph`
-
-```sh-session
-$ dotnet msbuild Referencing\Referencing.csproj -graph
-"Static graph loaded in 0.253 seconds: 2 nodes, 1 edges"
-  Referenced -> S:\Referenced\bin\Debug\netcoreapp3.1\Referenced.dll
-  Referencing -> S:\Referencing\bin\Debug\netcoreapp3.1\Referencing.dll
-```
-
-But fails with `-graph -isolate`
-
-```sh-session
-$ dotnet msbuild Referencing\Referencing.csproj -graph -isolate
-"Static graph loaded in 0.255 seconds: 2 nodes, 1 edges"
-  Referenced -> S:\Referenced\bin\Debug\netcoreapp3.1\Referenced.dll
-S:\Referencing\Referencing.csproj(12,5): error : MSB4252: Project "S:\Referencing\Referencing.csproj" with global properties
-S:\Referencing\Referencing.csproj(12,5): error :     (IsGraphBuild=true)
-S:\Referencing\Referencing.csproj(12,5): error :     is building project "S:\Referenced\Referenced.csproj" with global properties
-S:\Referencing\Referencing.csproj(12,5): error :     (IsGraphBuild=true)
-S:\Referencing\Referencing.csproj(12,5): error :     with the (UnusualThing) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
-S:\Referencing\Referencing.csproj(12,5): error :     - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "S:\Referencing\Referencing.csproj"
-S:\Referencing\Referencing.csproj(12,5): error :     - the reference was called with global properties that do not match the static graph inferred nodes
-S:\Referencing\Referencing.csproj(12,5): error :     - the reference was not explicitly specified as a ProjectReference item in project "S:\Referencing\Referencing.csproj"
-S:\Referencing\Referencing.csproj(12,5): error :
-```
-
-This part of the error is the problem here:
-
-> the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "S:\Referencing\Referencing.csproj"
-
-This is unacceptable in an isolated build because it means that the cached outputs of `Referenced.csproj` will be incomplete: they won't have the results of the `GetUnusualThing` target, because it's nonstandandard (and thus not one of the "well understood to be called on `ProjectReference`s targets that are handled by default).
-
-TODO: write docs for SDK authors/build engineers on how to teach the graph about this sort of thing.
diff --git a/documentation/specs/task-isolation-and-dependencies.md b/documentation/specs/task-isolation-and-dependencies.md
deleted file mode 100644
index 2ec96c8eb18..00000000000
--- a/documentation/specs/task-isolation-and-dependencies.md
+++ /dev/null
@@ -1,39 +0,0 @@
-# Task isolation
-## Problem definition
-Tasks in MSBuild are dynamically loaded assemblies with potentially separate and colliding dependency trees. Currently MSBuild on .NET Core has no isolation between tasks and as such only one version of any given assembly can be loaded. Prime example of this is Newtonsoft.Json which has multiple versions, but all the tasks must agree on it to work.
-This problem is also described in #1754.
-
-## Solution
-Use [`AssemblyLoadContext`](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-2.2) (ALC) to provide binding isolation for task assemblies. Each task assembly would be loaded into its own ALC instance.
-* The ALC would resolve all dependencies of the task assemblies (see dependency resolution below)
-* ALC would fallback to the Default for dependencies which the assembly doesn't carry with itself (frameworks and so on)
-* ALC would probably have to forcefully fallback for MSBuild assemblies since it's possible that tasks will carry these, but the system requires for the MSBuild assemblies to be shared.
-
-We also want to load groups of tasks which belong together into the same ALC (for example based on their location on disk) to improve performance. This will need some care as there's no guarantee that two random tasks have compatible dependency trees. As implemented, each task assembly is loaded into its own ALC.
-
-## Potential risks
-* Has some small probability of causing breaks. Currently all assemblies from all tasks are loaded into the default context and thus are "visible" to everybody. Tasks with following properties might not work:
-  * Task has a dependency on an assembly, but it doesn't declare this dependency in its .deps.json and this dependency gets loaded through some other task. This is mostly fixable by implementing probing similar to today's behavior.
-  * Two tasks from different assemblies which somehow rely on sharing certain types. If the new system decides to load these in isolation they won't share types anymore and might not work.
-* Performance - task isolation inherently (and by design) leads to loading certain assemblies multiple times. This increases memory pressure and causes additional JITing and other related work.
-
-## Additional consideration
-* None of these changes would have any effect on MSBuild on .NET Framework
-* Task isolation alone could be achieved on existing MSBuild
-
-# Task dependency resolution
-## Problem definition
-Tasks with complex and specifically platform specific dependencies don't work out of the box. For example if a task uses [`LibGit2Sharp`](https://www.nuget.org/packages/LibGit2Sharp) package it will not work as is. `LibGit2Sharp` has native dependencies which are platform specific. While the package carries all of them, there's no built in support for the task to load the right ones. For example [source link](https://github.com/dotnet/sourcelink/blob/29b3197e824c05d03427c05d56700e4c704233e4/src/Microsoft.Build.Tasks.Git/GitLoaderContext.cs) runs into this problem.
-
-## Solution
-.NET Core uses `.deps.json` files to describe dependencies of components. It would be natural to treat task assemblies as components and use associated .deps.json file to determine their dependencies. This would make the system work nicely end to end with the .NET Core CLI/SDK and VS integration.
-In .NET Core 3 there's a new type [`AssemblyDependencyResolver`](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyDependencyResolver.cs) which implements parsing and processing of a `.deps.json` for a component (or assembly). The usage is to create an instance of the resolver pointing to the assembly (in MSBuild case the task assembly). The resolver parses the `.deps.json` and stores the information. It exposes two methods to resolve managed and native dependencies.
-It was designed to be used as the underlying piece to implement custom ALC. So it would work nicely with task isolation above.
-
-## Potential risks
-* Small probability of breaking tasks which have `.deps.json` with them and those are not correct. With this change the file would suddenly be used and could cause either load failures or different versions of assemblies to get loaded.
-
-## Additional consideration
-* Task dependency resolution requires APIs which are only available in .NET Core 3.0 (no plan to backport), as such MSBuild will have to target netcoreapp3.0 to use these APIs.
-
-We decided not to implement `AssemblyDependencyResolver` in the .NET Core 3.x timeframe because of the uncertain impact of the change. We should reconsider in the .NET 5 timeframe.
diff --git a/documentation/specs/test-target.md b/documentation/specs/test-target.md
deleted file mode 100644
index 7726f1f6971..00000000000
--- a/documentation/specs/test-target.md
+++ /dev/null
@@ -1,62 +0,0 @@
-## MSBuild Test Target and Task 
-See: [MSBuild Test Target](https://github.com/dotnet/msbuild/pull/9193)
-
-### Motivation
-The primary motivation of the MSBuild Test Target is to offer a convienent and standardardized way for executing tests within the msbuild environment. This is inspired by the simplicity of the `dotnet test` command. The proposed command for initiating test within MSBuild would be `msbuild /t:Test`
-
-Another significatnt benefit of integrating this target is to faciliatet the caching of test executions, using MSBuild project caching capabilities. This enhancement will optimize the testing process by reducing test runs which could significantly reduce time spent building and testing, as tests would only execute, (after the initial run) if there are changes to those tests. As an example running with [MSBuildCache](https://github.com/microsoft/MSBuildCache) we can cache both build and test executions. Functionally, this means skipping test executions that have been determined to have not changed.
-Example usage:
-`msbuild /graph /restore:false /m /nr:false /reportfileaccesses /t:"Build;Test"`
-
-### Design Overview
-The 'Microsoft.Common.Test.targets' file contains a stub test target.
-```
-<Project>
-    <Target Name="Test"></Target>
-</Project>
-```
-This target serves a placeholder and entry point for test target implementations.
-
-#### Conditional Import
-* This stub target is conditionally imported, determined by a condition named 
-`$(UseMSBuildTestInfrastructure)`.
-* This condition allows for users to opt-in to this test target, which helps to prevent breaking changes, with respect the the target name, since there are likely 'Test' targets that exist in the wild already.
-
-The 'Microsoft.Common.CurrentVersion.targets' file contains.
-```
-  <PropertyGroup>
-    <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
-  </PropertyGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.Common.Test.targets" Condition="'$(UseMSBuildTestInfrastructure)' == 'true'"/>
-
-```
-#### Extensibility for Test Runners
-* Test runner implemenations can hook into the provided stub using the `AfterTargets` property.
-* This approach enables different test runners to extend the basic funcionarlity of the test target.
-
-For instance, an implementation for running VSTest would look like:
-```
-<Target Name="RunVSTest" AfterTargets="Test">
-  <!-- Implementation details here -->
-</Target>
-```
-
-#### Usage Scenario
-* Users who wish to utilize this target will set the `$(UseMSBuildTestInfrastructure)` condition in their project file, rsp or via the command line.
-* By executing `msbuild /t:Test`, the MSBuild engine will envoke the `Test` taget, which in turn triggers any test runner targets defined to run after it.
-
-### Default Task Implementation
-See: [MSBuild Test Task](https://github.com/microsoft/MSBuildSdks/pull/473)
-
-#### Nuget package for default implementaion
-* The default implementation will be provided through a nuget package.
-* This package will contain an MSBuild Task deigned to execute `vstest.console.exe`.
-
-#### MSBuild Task Functionality
-* The core of this implemenation is an MSBuild task that interfaces with `vstest.console.exe`.
-* This task will accept arguments as properties and pass them directly into the command line test runner.
-
-#### Using The Default Implementation
-* Users would install the provided Nuget Package to incorporate it into their projects.
-* Add the package to their GlobalPackageReferences or specific projects.
-* Once integrated, executing `msbuild /t:Test` would trigger the MSBuild Task, ultimately executing `vstest.console.exe`.
diff --git a/documentation/specs/threading.md b/documentation/specs/threading.md
deleted file mode 100644
index 935e96cf141..00000000000
--- a/documentation/specs/threading.md
+++ /dev/null
@@ -1,17 +0,0 @@
-# Threading in MSBuild Worker Nodes
-
-MSBuild can build multiple projects in parallel with the `-m` switch. This launches many worker processes (**nodes**) and assigns work to them. Each is generally dedicated to building a single project at a time.
-
-Projects can have dependencies on other projects. This is often represented with `@(ProjectReference)` items, but can be more complex--a dependency is created when a task calls the `IBuildEngine.BuildProjectFile` method or an equivalent. When this happens, the project is _blocked_: it cannot progress until the request it generated is built.
-
-While a project is blocked, the node that was building it can do work on other projects. The build engine will save project-specific state like environment variables and current working directory and then do something else (if the scheduler has work to assign to it).
-
-This is logically single-threaded, via a continuation model: a node is building a single chain of things, which may be suspended and continued after building another project in the same thread. The thread used to do this work is named `RequestBuilder thread`. It is not the main thread of the process because some other work goes on in parallel, like inter-process communication.
-
-It is sometimes useful to be able to do computational work within one project while *also* freeing up the node to do work on another project. When this is desired, a task can call `IBuildEngine3.Yield()` to indicate that the node can do other work until it calls `IBuildEngine3.Reacquire()`.
-
-When a project is _yielded_, the node is also yielded. The scheduler may then decide to assign additional work to the node. If it does so, the node will start a new RequestBuilder thread to do the new work, because the original thread will still be running the task code between `Yield()` and `Reacquire()`.
-
-The scheduler limits the amount of total work being done, including both executing and yielded nodes, to attempt to avoid starting too much parallel work and bogging down the operating system. As a result, it's rare for a single node to have more than two or three RequestBuilder threads, though there is no hard bound on the number of threads in a single node.
-
-If multiple RequestBuilder threads have been started and are idle in a single worker node, any of them may be used when a request is assigned to that node (or unblocked).
diff --git a/documentation/terminallogger/Opt-In-Mechanism.md b/documentation/terminallogger/Opt-In-Mechanism.md
deleted file mode 100644
index f6d63e7f4ac..00000000000
--- a/documentation/terminallogger/Opt-In-Mechanism.md
+++ /dev/null
@@ -1,38 +0,0 @@
-# TerminalLogger Opt-in
-
-## When should we use TerminalLogger
-
-The TerminalLogger presents the user with the build's most relevant information at the time, automatically hiding all the information that is no longer relevant (as to prevent huge log outputs). However, many users might find this not very useful (or even counterproductive) such as those using a terminal without proper ANSI support or when redirecting the output to a file. For that reason, the users must be able to turn this feature on/off at will.
-
-## Proposal
-
-### Enabling for a single build
-
-Using the `/terminallogger` or `/tl` command line switches, users are able to opt-in and use the TerminalLogger, EXCEPT when:
-
-- The terminal does not support ANSI codes or color
-- Output is redirected to a file or pipe
-
-### Enabling for all builds
-
-Users can set the `MSBUILDTERMINALLOGGER` environment variable to enable TerminalLogger without adding a swtich to all build invocations.
-
-### TerminalLogger parameters
-
-Both methods accept parameters:
-
-- `true` forces TerminalLogger to be used even wwhen it would be disabled
-- `false` forces TerminalLogger to not be used even when it would be enabled
-- `auto` enables TerminalLogger when the terminal supports it and the session doesn't have redirected stdout/stderr
-
-In cases where the TerminalLogger should not be enabled, the default ConsoleLogger should be used instead.
-
-## Considerations
-
-### Should TerminalLogger be used with other loggers (eg, BinaryLogger, FileLogger, custom loggers)?
-
-TerminalLogger should only replace the current ConsoleLogger for the aforementioned cases. Additionally, other loggers can be used in conjunction.
-
-### Should output be ignored with the `/noconsolelogger` flag enabled?
-
-TerminalLogger serves as a replacement for ConsoleLogger, so it should behave similarly. When attaching the `/noconsolelogger` flag, it should not output anything.
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
deleted file mode 100644
index d9bb101159f..00000000000
--- a/documentation/wiki/Binary-Log.md
+++ /dev/null
@@ -1,191 +0,0 @@
-# MSBuild binary log overview
-
-Starting with MSBuild 15.3 a new binary log format is introduced, to complement the existing file and console loggers.
-
-Goals:
- * completeness (more information than the most detailed file log)
- * build speed (doesn't slow the build down nearly as much as the diagnostic-level file log)
- * smaller disk size (10-20x more compact than a file log)
- * structure (preserves the exact build event args that can later be replayed to reconstruct the exact events and information as if a real build was running). File logs erase structure and are harder to parse (especially for multicore /m builds). Build analyzer tools are conceivable that could benefit from the structure in a binary log. An API is available to load and query binary logs.
- * optionally collect the project files (and all imported targets files) used during the build. This can help analyzing the logs and even view preprocessed source for all projects (with all imported projects inlined).
-
-See https://msbuildlog.com/ for more information.
-
-# Creating a binary log during a build
-
-Use the new `/bl` switch to enable the binary logger:
-```
-> msbuild.exe MySolution.sln /bl
-```
-
-By default the binary log file is named `msbuild.binlog` and it is written to the current directory. To specify a custom log file name and/or path, pass it after a colon:
-```
-> msbuild.exe MySolution.sln /bl:out.binlog
-```
-
-You can use the binary logger simultaneously with other loggers, such as text file (/fl) and console loggers. They are independent and having a binary log side-by-side with other logs may be beneficial (for sending a log to other people or running automatic build analysis tools that rely on the exact build event structure without having to parse text logs).
-
-When using the binary logger all other log formats are technically redundant since you can later reconstruct all the other logs from the binary log. To turn off console logging, pass the `/noconlog` switch. Builds will usually be much faster if you don't pass the console and file loggers.
-
-# Collecting projects and imports source files
-
-By default the binary logger will collect the source code of all project files and all imported project/targets files used during the build. You can control this behavior:
- * `/bl:ProjectImports=None` (do not collect project and imports files)
- * `/bl:ProjectImports=Embed` (default - embed in the `.binlog` file)
- * `/bl:ProjectImports=ZipFile` (produce a separate `.ProjectImports.zip` file next to the log file that contains the files)
-
-Note that only `*.csproj`, `*.targets` and other MSBuild project formats are collected. No other source files (`*.cs`, `*.cpp` etc) are collected.
-
-If the binary log contains the projects/imports files the MSBuild Structured Log Viewer will display all the files contained in the log, let you search through them and even display preprocessed view for any project where all imported projects are inlined (similar to `msbuild /pp` switch).
-
-# Logging all environment variables
-
-By default, MSBuild logs only the environment variables that are used to influence MSBuild, which is a subset of what is set in the environment. This reduces, but does not eliminate, the likelihood of leaking sensitive information through logs. This behavior can be changed to log the full environment by setting the environment variable `MSBUILDLOGALLENVIRONMENTVARIABLES=1`.
-
-# Replaying a binary log
-
-Instead of passing the project/solution to MSBuild.exe you can now pass a binary log to "build". This will replay all events to all other loggers (just the console by default). Here's an example of replaying a `.binlog` file to the diagnostic verbosity text log:
-
-```
-> msbuild.exe msbuild.binlog /noconlog /flp:v=diag;logfile=diag.log
-```
-
-# Creating a binary log with older MSBuild versions
-
-It is also possible to use the BinaryLogger with older MSBuild versions, such as MSBuild 14.0. For this you'll need the StructuredLogger.dll available here:
-https://github.com/KirillOsenkov/MSBuildStructuredLog/releases/download/v1.0.130/StructuredLogger.dll
-
-Alternatively you can download/install the https://www.nuget.org/packages/Microsoft.Build.Logging.StructuredLogger NuGet package and use the `StructuredLogger.dll` provided by it.
-
-Once you have the `StructuredLogger.dll` on disk you can pass it to MSBuild like this:
-
-```
-> msbuild.exe /logger:BinaryLogger,"path\to\StructuredLogger.dll";msbuild.binlog
-```
-
-# Using MSBuild Structured Log Viewer
-
-You can use the MSBuild Structured Log Viewer tool to view `.binlog` files:
-https://msbuildlog.com/
-
-# Collecting binary logs from Visual Studio builds
-
-[see more details](Providing-Binary-Logs.md#capturing-binary-logs-through-visual-studio)
-
-# Binary log file format
-
-The implementation of the binary logger is here:
-https://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BinaryLogger.cs
-https://github.com/dotnet/msbuild/blob/main/src/Build/Logging/BinaryLogger/BinaryLogger.cs
-
-It is a `GZipStream`-compressed binary stream of serialized `BuildEventArgs` objects. The event args objects are serialized and deserialized using:
- * https://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
- * https://source.dot.net/#Microsoft.Build/Logging/BinaryLogger/BuildEventArgsReader.cs
-
-## Incrementing the file format
-
-Every .binlog file has the first four bytes that indicate the file version. The current file format is indicated in [`BinaryLogger.cs`](/src/Build/Logging/BinaryLogger/BinaryLogger.cs).
-
-When incrementing the file format, keep this in mind:
- * Increment the version and add a summary of the changes: https://github.com/dotnet/msbuild/blob/main/src/Build/Logging/BinaryLogger/BinaryLogger.cs#L22
- * In BuildEventArgsWriter.cs, just add fields, etc. without worrying. 
- * In BuildEventArgsReader.cs, add exactly the same changes, but wrapped in an `if`-statement like this: `if (fileFormatVersion > version where the field was introduced)
- * Open an issue over at https://github.com/KirillOsenkov/MSBuildStructuredLog/issues/new so I can adapt the Structured Log Viewer to these changes.
-
-The format is backwards compatible, i.e. MSBuild will be able to play back .binlog files created with an older version of MSBuild. The Viewer will also be able to open files of any older version. Since the viewer updates automatically and I can push out updates easily, we can consider the Viewer is always able to read all .binlogs.
-
-## Forward compatibility reading
-
-From version 18, the binlog contains as well the minimum version of reader that can interpret it (stored in bytes 4 to 8). Support for best effort forward compatibility is added by this version. It is “best effort” only because the binlog format is not self-describing, i.e. it doesn't carry its schema around for performance and compactness reasons.
-
-This is not of a high importance for users of the Viewer because Viewer is always up-to-date (there isn't an "old version" of the Viewer unless people go to great lengths to prevent it from auto-updating).
-
-## Reading API
-
-We recommend usage of `BinaryLogReplayEventSource`. It provides simplified helpers for creating and configuring `BuildEventArgsReader` and subscribing to the events.
-
-```csharp
-var logReader = new BinaryLogReplayEventSource()
-{
-    AllowForwardCompatibility = true
-};
-
-// Handling of the structured events contained within the log
-logReader.AnyEventRaised += (_, e) =>
-{
-    if (e is BuildErrorEventArgs error)
-    {
-        //...
-    }
-
-    // ...
-};
-
-// Starts the synchronous log reading loop.
-logReader.Replay(path_to_binlog_file);
-
-```
-
-### Handling the recoverable reading errors
-
-In compatibility mode (default for `BinaryLogReplayEventSource`. Only supported for binlogs of version 18 and higher) reader is capable of skipping unknown event types and unknown parts of known events (`BuildEventArgsReader` can configure the behavior via 2 separate properties - `SkipUnknownEvents` and `SkipUnknownEventParts`).
-
-The unknown events and event parts are regarded as recoverable errors, since the reader is able to continue reading subsequent records in the binlog. However the specific user logic should have the last call in deciding whether errors are really recoverable (e.g. is presence of unrecognized or unparseable event ok? It might be fine when searching only for specific events - e.g. errors but not acceptable when trying to provide definitive overview of the built).
-
-To allow the calling code to decide - based on the type of error, type of events getting the error, or the number of errors - the `RecoverableReadError` event is exposed (from both `BinaryLogReplayEventSource` and `BuildEventArgsReader`).
-
-```csharp
-/// <summary>
-/// An event args for <see cref="IBinaryLogReaderErrors.RecoverableReadError"/> event.
-/// </summary>
-public sealed class BinaryLogReaderErrorEventArgs : EventArgs
-{
-    /// <summary>
-    /// Type of the error that occurred during reading.
-    /// </summary>
-    public ReaderErrorType ErrorType { get; }
-
-    /// <summary>
-    /// Kind of the record that encountered the error.
-    /// </summary>
-    public BinaryLogRecordKind RecordKind { get; }
-
-    /// <summary>
-    /// Materializes the error message.
-    /// Until it's called the error message is not materialized and no string allocations are made.
-    /// </summary>
-    /// <returns>The error message.</returns>
-    public string GetFormattedMessage() => _formatErrorMessage();
-}
-
-/// <summary>
-/// Receives recoverable errors during reading.
-/// Communicates type of the error, kind of the record that encountered the error and the message detailing the error.
-/// In case of <see cref="ReaderErrorType.UnknownEventData"/> this is raised before returning the structured representation of a build event
-/// that has some extra unknown data in the binlog. In case of other error types this event is raised and the offending build event is skipped and not returned.
-/// </summary>
-event Action<BinaryLogReaderErrorEventArgs>? RecoverableReadError;
-```
-
-Our sample usage of the [Reading API](#reading-api) can be enhanced with recoverable errors handling e.g. as such:
-
-```csharp
-
-// Those can be raised only during forward compatibility reading mode.
-logReader.RecoverableReadError += errorEventArgs =>
-{
-    // ...
-
-    // e.g. we can decide to ignore the error and continue reading or break reading
-    //  based on the type of the error or/and type of the record or/and the frequency of the error
-
-    // Would we decide to completely ignore some errors - we can aid better performance by not materializing the actual error message.
-    // Otherwise the error message can be materialized via the provided method on the event argument:
-    Console.WriteLine($"Recoverable reader error: {errorEventArgs.GetFormattedMessage()}");
-};
-
-```
-
-When authoring changes to the specific BuildEventArg types - it is always strongly recommended to **prefer append-only changes**. 
-
-This prevents the possibility of collision where some fields are removed in one version and then different fields with same binary size are added in future version. Such a sequence of format changes might not be caught by the decoder and might lead to unnoticed corrupt interpretation of data. For this reason the author of specific OM changes should always check whether there is a possibility of unrecognizable format collision (same binary size, different representation) within binlog versions of a same [minimum reader version support](#forward-compatibility-reading). If this is possible, the [minimum reader version support](#forward-compatibility-reading) should be incremented.
\ No newline at end of file
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
deleted file mode 100644
index 6410b01cb11..00000000000
--- a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
+++ /dev/null
@@ -1,53 +0,0 @@
-MSBuild can be successfully built on Windows, OS X 10.13, Ubuntu 14.04, and Ubuntu 16.04.
-
-# Windows
-
-## Build
-
-`build.cmd -msbuildEngine dotnet`
-
-## Tests
-
-Follow [Running Unit Tests](Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#running-unit-tests) section of the developer guide chapter for .NET Framework
-
-# Unix
-
-## The easy way
-
-Install the latest .NET SDK from https://dotnet.microsoft.com/download. That will ensure all prerequisites for our build are met.
-
-## Manually installing required packages for OSX & Ubuntu
-
-[.NET Core prerequisites](https://github.com/dotnet/core/blob/main/Documentation/prereqs.md).
-
-* *OpenSSL*: MSBuild uses the .Net CLI during its build process. The CLI requires a recent OpenSSL library available in `/usr/lib`. This can be downloaded using [brew](https://brew.sh/) on OS X (`brew install openssl`) and apt-get (`apt-get install openssl`) on Ubuntu, or [building from source](https://wiki.openssl.org/index.php/Compilation_and_Installation#Mac). If you use a different package manager and see an error that says `Unable to load DLL 'System.Security.Cryptography.Native'`, `dotnet` may be looking in the wrong place for the library.
-
-## Build
-
-`./build.sh`
-
-If you encounter errors, see [Something's wrong in my build](Something's-wrong-in-my-build.md)
-
-## Tests
-
-`./build.sh --test`
-
-# Getting .Net Core MSBuild binaries without building the code
-
-The best way to get .NET Core MSBuild is by installing the [.NET Core SDK](https://github.com/dotnet/core-sdk), which redistributes us. This will get you the latest released version of MSBuild for .NET Core. After installing it, you can use MSBuild through `dotnet build` or by manual invocation of the `MSBuild.dll` in the dotnet distribution.
-
-# Debugging
-
-## Wait in Main
-
-Set the environment variable `MSBUILDDEBUGONSTART` to `2`, then attach a debugger to the process manually after it starts.
-
-## Using the repository binaries to perform builds
-
-To build projects using the MSBuild binaries from the repository, you first need to do a build (command: `build.cmd`) which produces a bootstrap directory mimicking a Visual Studio (full framework flavor) or dotnet CLI (.net core flavor) installation.
-
-Now, just point `dotnet ./artifacts/bin/bootstrap/<TARGET_FRAMEWORK>/MSBuild/MSBuild.dll` at a project file. (Change <TARGET_FRAMEWORK> to current target framework, for example net7.0, net8.0) 
-
-Alternatively, if you want to test the msbuild binaries in a more realistic environment, you can overwrite the dotnet CLI msbuild binaries (found under a path like `~/dotnet/sdk/3.0.100-alpha1-009428/`) with the just-built MSBuild . You might have to kill existing `dotnet` processes before doing this. You can use [`Deploy-MSBuild.ps1 -runtime Core`](../Deploy-MSBuild.md#.NET-(Core)-SDK) to do the copy. Then, (using the previous dotnet example directory) just point `~/dotnet/dotnet build` at a project file.
-
-See other debugging options [here](./Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#Debugging-MSBuild).
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
deleted file mode 100644
index 43134c57c3b..00000000000
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
+++ /dev/null
@@ -1,100 +0,0 @@
-# Building MSBuild for the .NET Framework
-
-These instructions refer to working with the `main` branch.
-
-## Required Software
-
-**Latest Microsoft Visual Studio 2022**: You can download the Visual Studio Community edition from [visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/).
-
-All command lines should be executed from a Visual Studio developer command prompt.
-
-## Getting the code
-
-1. Clone the repo: `git clone https://github.com/dotnet/msbuild`
-2. Build on the command line: `.\build.cmd`
-   1. If you encounter errors, see [Something's wrong in my build](Something's-wrong-in-my-build.md).
-3. Open the solution file in Visual Studio (`MSBuild.Dev.slnf`).
-
-## Running Unit Tests
-
-To run the unit tests from Visual Studio:
-
-1. Open the MSBuild solution file (`MSBuild.Dev.slnf`) in Visual Studio.
-2. Open the Test menu -> Windows -> Test Explorer.
-3. Click Run All.
-
-To build MSBuild and run all unit tests from the command line, use `.\build.cmd -test`.
-
-Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:
-* Enable [Development Mode](https://learn.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development) on your machine.
-* Or run those tests elevated
-
-To mimic our CI job use `eng\CIBuild.cmd`. Be aware that this command may delete your local NuGet cache.
-
-The CI does two builds. In the second build, it uses the binaries from the first build to build the repository again.
-
-### Unit testing inside virtualized environment 
-
-In case you develop on Windows OS, but need to run/debug tests on other platforms - unit tests can be run and debugged on a local virtualized environment supported by [Visual Studio Remote Testing](https://learn.microsoft.com/en-us/visualstudio/test/remote-testing?view=vs-2022).
-Initial configurations have been added for `WSL` and net 7.0 linux docker via [`testenvironments.json`](../../testenvironments.json).
-Upon opening the Tests Explorer the advanced environments are available in the GUI: 
-
-![TestExplorrerEnvironments](TestExplorerEnvironments.png)
-
-This readme will not discuss definitive list of details for proper setup of the environments instead we defer reader to the following information sources and warn about particular gotchas:
-
- * WSL runs
-   * Install [WSL](https://learn.microsoft.com/en-us/windows/wsl/about).
-   * Install the [distribution](https://aka.ms/wslstore) of your choice.
-   * [Install .NET Runtime](https://learn.microsoft.com/en-us/dotnet/core/install/linux-ubuntu)
- * Docker runs
-   * Install [Docker Desktop](https://www.docker.com/products/docker-desktop/)
-   * First run of docker scenario might need elevation ([Test project does not reference any .NET NuGet adapter](https://developercommunity.visualstudio.com/t/test-project-does-not-reference-any-net-nuget-adap/1311698) error)  
- * Third party test runners might not support this feature. Use [Visual Studio Test Explorer](https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer).
-
-## Contributing
-
-Please see [Contributing Code](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Contributing-Code.md) for details on contributing changes back to the code. Please read this carefully and engage with us early to ensure work is not wasted.
-
-## Walkthroughs
-
-### Using the repository binaries to perform builds
-
-To build projects using the MSBuild binaries from the repository, you first need to do a build which produces
-a "bootstrap" directory. The "bootstrap" directory mimics a Visual Studio installation by acquiring additional
-dependencies (Roslyn compilers, NuGet, etc.) from packages or from your local machine (e.g. props/targets
-from Visual Studio). This will happen by default when running `.\build.cmd`. The bootstrap can be disabled by running `.\build.cmd /p:CreateBootstrap=false`.
-
-Now, just point `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe` at a project file.
-
-### Patching Visual Studio with repository binaries
-
-Sometimes it's useful to patch your copy of Visual Studio in order to test or debug your local MSBuild changes from Visual Studio. You can use the [Deploy-MSBuild script](../Deploy-MSBuild.md) for copying your locally built MSBuild binaries over the MSBuild binaries shipping with Visual Studio. Example usage:
-```
-# bootstrap build
-.\build.cmd
-
-# copy the bootstrap build output over the MSBuild binaries in Visual Studio
-.\scripts\Deploy-MSBuild.ps1 -destination "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin"
-```
-
-### Debugging MSBuild
-
-#### Breakpoints
-To break into the [main method](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/MSBuild/XMake.cs#L493-L506) of MSBuild.exe: set the environment variable `MSBUILDDEBUGONSTART` to 1 (uses `Debugger.Launch()`) or 2 (waits until debugger is attached).
-
-To break into MSBuild's [BuildManager.BeginBuild](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/BuildManager/BuildManager.cs#L414) set the environment variable `MSBuildDebugBuildManagerOnStart` to 1 (uses `Debugger.Launch()`) or 2 (waits until debugger is attached).
-This is useful for debugging MSBuild when it is called from other apps that use its APIs instead of its executable (for example Visual Studio). You can also filter which processes trigger the breakpoint by setting `MSBuildDebugProcessName` to a substring of the process name. For example, to trigger the breakpoint only under Visual Studio's top level process you would set `MSBuildDebugProcessName` to the value `devenv`.
-
-#### Logs
-You can set the environment variable `MSBuildDebugEngine` to 1 to have MSBuild dump all of its possible debugging logs (for example, scheduler state, node communication).
-
-It also injects a binary log during [BuildManager.BeginBuild](https://github.com/dotnet/msbuild/blob/bd00d6cba24d41efd6f54699c3fdbefb9f5034a1/src/Build/BackEnd/BuildManager/BuildManager.cs#L491), which is incredibly useful when MSBuild is being called through its APIs from other apps that inhibit or filter MSBuild's event messages. For example, Visual Studio heavily filters build event messages when doing normal builds and inhibits build events when it's performing [design time builds](https://github.com/dotnet/project-system/blob/04474df00ebd742e05d31f8e487d6ed4ac83763e/docs/design-time-builds.md). `MSBuildDebugEngine` allows retrieving a full binary log for both real builds and all design time builds.
-
-By default these logs get saved into an `MSBuild_Logs` directory under the current working directory. You can override this default by setting `MSBUILDDEBUGPATH`.
-
-Like with breakpoints, you can filter which processes emit the logs by setting `MSBuildDebugProcessName` to a substring of the desired process name.
-
-##### Dumping specific logs:
-- scheduler state: set `MSBUILDDEBUGSCHEDULER` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
-- node communication: set `MSBUILDDEBUGCOMM` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
diff --git a/documentation/wiki/ChangeWaves-Dev.md b/documentation/wiki/ChangeWaves-Dev.md
deleted file mode 100644
index 7c0c0e86cf4..00000000000
--- a/documentation/wiki/ChangeWaves-Dev.md
+++ /dev/null
@@ -1,102 +0,0 @@
-⚠ This doc is intended for internal teams. For information about how to deal with MSBuild Change Waves as an MSBuild _user_, see [ChangeWaves.md](ChangeWaves.md).
-
-# What are Change Waves?
-A Change Wave is a set of risky features developed under the same opt-out flag. The purpose of this is to warn developers of risky changes that will become standard functionality down the line. If there's something we think is worth the risk, we found that Change Waves were a good middle ground between making necessary changes and warning customers of what will soon be permanent.
-
-## Why Opt-Out vs. Opt-In?
-Opt-out is a better approach for us because we'd likely get limited feedback when a feature impacts customer builds. When a feature does impact a customer negatively, it's a quick switch to disable and allows time to adapt. The key aspect to Change Waves is that it smooths the transition for customers adapting to risky changes that the MSBuild team feels strongly enough to take.
-
-## How do They Work?
-The opt-out comes in the form of setting the environment variable `MSBUILDDISABLEFEATURESFROMVERSION` to the Change Wave (or version) that contains the feature you want **disabled**. This version happens to be the version of MSBuild that the features were developed for. See the mapping of change waves to features below.
-
-## Choosing a Change Wave for a New Feature
-This is determined on a case by case basis and should be discussed with the MSBuild team. A safe bet would be to check our [currently active Change Waves](ChangeWaves.md#change-waves-&-associated-features) and pick the version after the latest MSBuild version. This version corresponds to the latest version of Visual Studio.
-
-### Change Wave Versioning
-Change Wave features should match the LTS version of VS they were released with. Any feature requiring a changewave during a non-LTS release of VS should use the **NEXT** version number.
-
-# Developing With Change Waves in Mind
-For the purpose of providing an example, the rest of this document assumes we're developing a feature for MSBuild version **17.3**.
-
-The Process:
-1. Develop your feature.
-2. [Create the Change Wave](#creating-a-change-wave) (if necessary)
-3. [Condition your feature on that Change Wave](#condition-your-feature-on-a-change-wave)
-4. [Test your feature](#test-your-feature)
-5. [Document it](ChangeWaves.md#change-wave-features)
-6. [Delete the wave as it cycles out](#change-wave-'end-of-lifespan'-procedure)
-
-## Creating a Change Wave
-1. In the `Microsoft.Build.Framework` project, open `ChangeWaves.cs`.
-2. Add a static readonly Version to identify the new wave, following the format:
-```c#
-public static readonly Version Wave17_4 = new Version(17, 4);
-```
-3. You may need to delete the lowest wave as new waves get added.
-4. Update the AllWaves array appropriately.
-```c#
-public static readonly Version[] AllWaves = { Wave17_0, Wave17_2, Wave17_4 };
-```
-
-## Condition Your Feature On A Change Wave
-Surround your feature with the following:
-```c#
-    // If you pass an incorrectly formatted change wave, this will throw.
-    // Use the readonly Version that was created in the previous step.
-    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-    {
-        <your feature>
-    }
-```
-
-If you need to condition a Task or Target, use the built in `AreFeaturesEnabled` function.
-```xml
-<Target Name="SomeRiskyChange" Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">
-<!-- Where '17.4' is the change wave assigned to your feature. -->
-```
-
-## Test Your Feature
-Create tests as you normally would. Include one test with environment variable `MSBUILDDISABLEFEATURESFROMVERSION` set to `ChangeWaves.Wave17_4`. Set this like so:
-```c#
-using TestEnvironment env = TestEnvironment.Create();
-
-ChangeWaves.ResetStateForTests();
-// Important: use the version here
-env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
-BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-```
-
-**Important!** If you need to build a project to test your feature (say, for tasks or targets), build via `ProjectCollection` in your test.
-
-Example:
-```c#
-using (TestEnvironment env = TestEnvironment.Create())
-{
-    ChangeWaves.ResetStateForTests();
-    env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
-    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-    string projectFile = @"
-        <Project>
-            <Target Name='HelloWorld' Condition=""$([MSBuild]::AreFeaturesEnabled('17.4'))"">
-                <Message Text='Hello World!'/>
-            </Target>
-        </Project>";
-
-    TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
-
-    ProjectCollection collection = new ProjectCollection();
-    MockLogger log = new MockLogger();
-    collection.RegisterLogger(log);
-
-    collection.LoadProject(file.Path).Build().ShouldBeTrue();
-    log.AssertLogContains("Hello World!");
-}
-```
-
-## Change Wave 'End-of-Lifespan' Procedure
-These features will eventually become standard functionality. When a change wave rotates out, do the following:
-1. Start by deleting the readonly `Wave17_4` that was created in [Creating a Change Wave](#creating-a-change-wave).
-2. Remove `ChangeWave.AreFeaturesEnabled` or `[MSBuild]::AreFeaturesEnabled` conditions surrounding features that were assigned that change wave.
-3. Remove tests associated with ensuring features would not run if this wave were set.
-4. Clear all other issues that arose from deleting the version.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
deleted file mode 100644
index b7508160ef6..00000000000
--- a/documentation/wiki/ChangeWaves.md
+++ /dev/null
@@ -1,85 +0,0 @@
-# What are Change Waves?
-A Change Wave is a set of risky features developed under the same opt-out flag. The purpose of this is to warn developers of "risky" changes that will become standard functionality down the line. If there's something we think is worth the risk, we found that Change Waves were a good middle ground between making necessary changes and warning customers of what will soon be permanent.
-
-## Why Opt-Out vs. Opt-In?
-Opt-out is a better approach for us because we'd likely get limited feedback when a feature impacts customer builds. When a feature does impact a customer negatively, it's a quick switch to disable and allows time to adapt. The key aspect to Change Waves is that it smooths the transition for customers adapting to risky changes that the MSBuild team feels strongly enough to take.
-
-## How do they work?
-The opt-out comes in the form of setting the environment variable `MSBUILDDISABLEFEATURESFROMVERSION` to the Change Wave (or version) that contains the feature you want **disabled**. This version happens to be the version of MSBuild that the features were developed for. See the mapping of change waves to features below.
-
-## When do they become permanent?
-A wave of features is set to "rotate out" (i.e. become standard functionality) two bands after its release. For example, wave 16.8 stayed opt-out through wave 16.10, becoming standard functionality when wave 17.0 is introduced.
-
-## MSBUILDDISABLEFEATURESFROMVERSION Values & Outcomes
-| `MSBUILDDISABLEFEATURESFROMVERSION` Value                         | Result        | Receive Warning? |
-| :-------------                                                    | :----------   | :----------: |
-| Unset                                                             | All Change Waves will be enabled, meaning all features behind each Change Wave will be enabled.               | No   |
-| Any valid & current Change Wave (Ex: `16.8`)                      | All features behind Change Wave `16.8` and higher will be disabled.                                           | No   |
-| Invalid Value (Ex: `16.9` when valid waves are `16.8` and `16.10`)| Default to the closest valid value (ascending). Ex: Setting `16.9` will default you to `16.10`.               | No   |
-| Out of Rotation (Ex: `17.1` when the highest wave is `17.0`)      | Clamp to the closest valid value. Ex: `17.1` clamps to `17.0`, and `16.5` clamps to `16.8`                    | Yes  |
-| Invalid Format (Ex: `16x8`, `17_0`, `garbage`)                    | All Change Waves will be enabled, meaning all features behind each Change Wave will be enabled.               | Yes  |
-
-# Change Waves & Associated Features
-
-## Current Rotation of Change Waves
-
-### 17.10
-- [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
-- [Warning on serialization custom events by default in .NET framework](https://github.com/dotnet/msbuild/pull/9318)
-- [Cache SDK resolver data process-wide](https://github.com/dotnet/msbuild/pull/9335)
-- [Target parameters will be unquoted](https://github.com/dotnet/msbuild/pull/9452), meaning  the ';' symbol in the parameter target name will always be treated as separator
-- [Add Link metadata to Resources in AssignLinkMetadata target](https://github.com/dotnet/msbuild/pull/9464)
-- [Change Version switch output to finish with a newline](https://github.com/dotnet/msbuild/pull/9485)
-- [Load Microsoft.DotNet.MSBuildSdkResolver into default load context (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9439)
-- [Load NuGet.Frameworks into secondary AppDomain (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9446)
-- [Update Traits when environment has been changed](https://github.com/dotnet/msbuild/pull/9655)
-- [Exec task does not trim leading whitespaces for ConsoleOutput](https://github.com/dotnet/msbuild/pull/9722)
-
-
-### 17.8
-- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
-- [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
-- [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
-- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
-
-
-### 17.6
-- [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
-- [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
-- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
-- [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
-- [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
-- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
-
-### 17.4
-- [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
-- [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
-- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
-- [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
-- [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
-
-## Change Waves No Longer In Rotation
-### 16.8
-- [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
-- [Truncate Target/Task skipped log messages to 1024 chars](https://github.com/dotnet/msbuild/pull/5553)
-- [Don't expand full drive globs with false condition](https://github.com/dotnet/msbuild/pull/5669)
-
-### 16.10
-- [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
-- [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
-- [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
-- [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
-- [Optimize glob evaluation](https://github.com/dotnet/msbuild/pull/6151)
-
-### 17.0
-- [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
-- [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
-- [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
-- [Reference assemblies are now no longer placed in the `bin` directory by default](https://github.com/dotnet/msbuild/pull/6560) (reverted [here](https://github.com/dotnet/msbuild/pull/6718) and brought back [here](https://github.com/dotnet/msbuild/pull/7075))
-- [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
-- [Fix deadlock in BuildManager vs LoggingService](https://github.com/dotnet/msbuild/pull/6837)
-- [Optimize diag level for file logger and console logger](https://github.com/dotnet/msbuild/pull/7026)
-- [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
-- [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
-- [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
-- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
diff --git a/documentation/wiki/Contributing-Code.md b/documentation/wiki/Contributing-Code.md
deleted file mode 100644
index 6e6e8b40c62..00000000000
--- a/documentation/wiki/Contributing-Code.md
+++ /dev/null
@@ -1,37 +0,0 @@
-### Contributing Code
-Before submitting a feature or substantial code contribution please discuss it with the team and ensure it follows the product roadmap. The team rigorously reviews and tests all code submissions. The submissions must meet an extremely high bar for quality, design, backwards compatibility, and roadmap appropriateness.
-
-Because our focus right now is on maintaining backwards compatibility, the team has set the following limits on pull requests:
-
-- Contributions must be discussed with the team first, or they will likely be declined. As our process matures and our experience grows, the team expects to take larger contributions.
-- Only contributions referencing an approved Issue will be accepted.
-- Pull requests that do not merge easily with the tip of the main branch will be declined. The author will be asked to merge with tip and submit a new pull request.
-- Submissions must meet functional and performance expectations, including scenarios for which the team doesn't yet have open source tests. This means you may be asked to fix and resubmit your pull request against a new open test case if it fails one of these tests.
-- Submissions must follow the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
-- For any changed or newly introduced test cases usage of Shouldly assertion framework is preferable.
-
-When you are ready to proceed with making a change, get set up to [build](Home.md "See 'Building Testing and Debugging'") the code and familiarize yourself with our workflow and our coding conventions. These two blogs posts on contributing code to open source projects are good too: [Open Source Contribution Etiquette by Miguel de Icaza](https://tirania.org/blog/archive/2010/Dec-31.html) and [Don’t “Push” Your Pull Requests by Ilya Grigorik](https://www.igvita.com/2011/12/19/dont-push-your-pull-requests/).
-
-You will have to sign a Contributor License Agreement (CLA) before we can accept your pull request. To complete the CLA, submit a pull request and a bot will comment with a link where you can electronically sign the CLA. You need to complete the CLA only once to cover all Microsoft Open Technologies OSS projects.
-
-### Developer Workflow
-
-1. Work item is assigned to a developer during the triage process
-2. Both Microsoft and external contributors are expected to do their work in a local fork and submit code for consideration via a pull request.
-3. When the pull request process deems the change ready it will be merged directly into the tree. 
-
-### Creating New Issues
-
-Please follow these guidelines when creating new issues in the issue tracker:
-
-- Use a descriptive title that identifies the issue to be addressed or the requested feature. For example when describing an issue where the compiler is not behaving as expected, write your bug title in terms of what the product should do rather than what it is doing – “MSBuild should report CS1234 when Xyz is used in Abcd.”
-- Do not set any bug fields other than Impact.
-- Specify a detailed description of the issue or requested feature.
-- For bug reports, please also:
-    - Describe the expected behavior and the actual behavior. If it is not self-evident such as in the case of a crash, provide an explanation for why the expected behavior is expected.
-    - Provide example code that reproduces the issue.
-    - Specify any relevant exception messages and stack traces.
-- Subscribe to notifications for the created issue in case there are any follow up questions.
-
-### Coding Conventions
-- Use the coding style outlined in the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
diff --git a/documentation/wiki/Contributing-Tasks.md b/documentation/wiki/Contributing-Tasks.md
deleted file mode 100644
index c77aaa7cd02..00000000000
--- a/documentation/wiki/Contributing-Tasks.md
+++ /dev/null
@@ -1,29 +0,0 @@
-# Contributing Tasks
-
-MSBuild tasks are units of executable code used to perform atomic build operations.  There are many tasks already in MSBuild but there is always a need for more.  We encourage you to contribute useful tasks directory to MSBuild.
-
-## Getting Started
-Please [open an issue](https://github.com/dotnet/msbuild/issues/new) to propose a new task.  This gives the community a chance to provide feedback and make suggestions.  Once there is consensus that the task is needed and the below requirements are met, fork the repository and begin development.
-
-## Requirements
-The following requirements are in place for contributed tasks:
-
-1. The task must not introduce the need to ship any third-party assemblies.
-2. The task should work on .NET Framework and .NET Core if possible.  It can be confusing to users if a task only works on certain platforms.
-3. The task must have unit tests in place to prevent regressions.
-
-## Developing a new Task
-Review the existing documentation on [Task Writing](https://learn.microsoft.com/visualstudio/msbuild/task-writing) to learn about the fundamentals.  You can also looking at existing tasks in the [Microsoft.Build.Tasks.Core assembly](https://github.com/dotnet/msbuild/tree/main/src/Tasks) for a great starting point.
-
-Tasks are generally simple and should not require much effort to develop.  If you find a task becoming very complicated, consider breaking it up into smaller tasks which can be run together in a target.
-
-## Developing unit tests
-Contributed tasks must have unit tests in place to prove they work and to prevent regressions caused by other code changes.  There are a lot of examples in the [Microsoft.Build.Tasks.UnitTests](https://github.com/dotnet/msbuild/tree/main/src/Tasks.UnitTests) project.  Please provide a reasonable amount of test coverage so ensure the quality of the product.
-
-## Documentation
-You can document the new task in the [visualstudio-docs](https://github.com/MicrosoftDocs/visualstudio-docs/tree/main/docs/msbuild) repository.  This helps users discover the new functionality.  The easiest way is to copy the documentation page for an existing task as a template.
-
-## Ship schedule
-MSBuild ships regularly with Visual Studio.  It also is updated in Preview releases.  Once your contribution is merged, expect it to be available in the next release.
-
-
diff --git a/documentation/wiki/Controlling-Dependencies-Behavior.md b/documentation/wiki/Controlling-Dependencies-Behavior.md
deleted file mode 100644
index 0465364346a..00000000000
--- a/documentation/wiki/Controlling-Dependencies-Behavior.md
+++ /dev/null
@@ -1,288 +0,0 @@
-# Controlling references behavior
-
-MSBuild recognizes a [few types of references](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items) (here we are mainly interested in `ProjectReference`, `PackageReference`, `Reference` aka assembly reference) and offers optional mechanisms to tailor some aspects of the references workings - transitive references resolution, multitargeted references resolution, copying references to output directory.
-
-## Access to transitive dependencies
-
-Following sections will describe details of transitive dependencies accessibility for `ProjectReference`, `PackageReference` and `Reference`. To summarize the content: Projects requiring access to particular dependency (project, package or assembly) should always explicitly declare the required dependency (via the appropriate item). 
-
-The possibility of the transitive access should however be acknowledged and wherever the strict separation of architectural layers is required - a dedicated metadata (`DisableTransitiveProjectReferences` or `PrivateAssets`) should be used.
-
-## .NET SDK projects and access to transitive references
-
-[.NET SDK projects](https://learn.microsoft.com/dotnet/core/project-sdk/overview) by default make all transitive references accessible as if they were direct references.
-
-This is provided for the compiler and analyzers to be able to properly inspect the whole dependency or/and inheritance chain of types when deciding about particular checks.
-
-It is facilitated via `project.assets.json` file created by NuGet client during the restore operation. This file captures the whole transitive closure of the project dependency tree.
-
-SDK build tasks require existence of this file (hence the infamous `Assets file <path>\project.assets.json not found` if the MSBuild.exe is run without prior restore operation). It is used to reconstruct the `ProjectReference`s and create `Reference` items for the content of `PackageReference`s for the project and make them available to the rest of the build. For this reason MSBuild and compiler by default sees those transitive references as if they were direct references.
-
-## Access to transitive project references
-
-Above described behavior can lead to easy unintentional breaking out of layering architecture separation. 
-
-This behavior can be opted-out for `ProjectReference`s via `DisableTransitiveProjectReferences` property on the referencing project.
-
-<a name="OnionArchSample"></a>*Example*:
-
-Let's imagine an `Onion Architecture` design:
-
-```mermaid
-flowchart LR
-    Service[Service Layer] --> Repository
-    Repository[Repository Layer] --> Domain[Domain Layer]
-```
-
-Service Layer definition:
-
-```xml
-<Project Sdk="Microsoft.NET.Sdk">
-  <ItemGroup>
-    <ProjectReference Include="..\Repository\Repository.csproj" />
-  </ItemGroup>
-
-  <PropertyGroup>
-    <TargetFramework>net48</TargetFramework>
-    <LangVersion>10</LangVersion>
-    <!-- This prevents referencing types from transitive project references. -->
-    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
-  </PropertyGroup>
-</Project>
-```
-
-```csharp
-namespace Service;
-	
-public class PersonsAccessor
-{
-    private Repository.Persona _persona;
-    // This is allowed unless DisableTransitiveProjectReferences=true is passed into build.
-    // private Domain.PersonTable _tbl;
-}
-```
-
-## Access to transitive package references
-
-The transitive access to references works by default for package references as well. This can be opted out for referencing projects via `PrivateAssets=compile` on the `PackageReference` of the concern. (More details on [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets)).
-
-When using this metadatum - the access to the package, its dirrect and transitive dependencies is **not** restricted for the project declaring the refenerence on the package in its `Project` element. It is restricted for the projects referencing the project (or package) that specified the `PackageRegerence` with the `PrivateAssets` metadatum.
-
-*Example*:
-
-In our previous example let's have `Repository Layer` reference `newtonsoft.json`:
-
-```mermaid
-flowchart LR
-    Service[Service Layer] --> Repository
-    Repository[Repository Layer] --> newtonsoft.json[newtonsoft.json]
-```
-
-We are not able to influence access to `newtonsoft.json` and its dependencies (would there be any) in the `Repository Layer`, but we can prevent it from propagating to `Service Layer`.
-
-`Repository Layer`:
-
-```xml
-<ItemGroup>
-  <PackageReference Include="newtonsoft.json" Version="13.0.1">
-    <!-- This prevents the reference to be available to referencing types. -->
-    <PrivateAssets>compile</PrivateAssets>
-  </PackageReference>
-</ItemGroup>
-```
-
-Unless opted out via `PrivateAssets=compile`, our `Service Layer` would have access to `newtonsoft.json`:
-
-```csharp
-namespace Service;
-//This is allowed unless PrivateAssets=compile is set on the PackageDependency in Repository.
-//using Newtonsoft.Json;
-	
-public class PersonsAccessor
-{
-    private Repository.Persona _persona;
-}
-```
-
-**Notes:**
-   `PrivateAssets` metadatum (and it's counterparts `IncludeAssets` and `ExcludeAssets`) is applicable to `PackageReference` and controls exposure of dependencies to the consuming projects, not the current project. It is currently not possible to prevent access to package references from within directly referencing project - this is purely decision of the package itself (as it can define it's dependencies as `PrivateAssets`).
-
-## Access to transitive assembly references
-
-`Reference` (AKA assembly reference) referenced by a project is not transitively accessible from projects referencing the said directly referencing project:
-
-```xml
-<ItemGroup>
-  <!-- This reference will only be accessible from the current project.
-       Projects referencing this project won't be able to access it. -->
-  <Reference Include="SomeAssemblyReference">
-    <HintPath>path\to\SomeAssemblyReference.dll</HintPath>
-  </Reference>
-</ItemGroup>
-```
-
-As described in [Access to transitive project references](#access-to-transitive-project-references) - access to transitive references can lead to breaking architectural layering and hence the lack of the transitive access is desired.
-
-All the projects requiring access to some particular assembly reference should explicitly declare such dependency via the `Reference` item.
-
-## Not copying dependencies to output
-
-By default the above mentioned dependency types are copied to the build output directory during the build. There can be various scenarios where this behavior is not desired (examples: dependency is compile time only or contains a logic for build; component is plugin to a main app and there is a desire not to duplicate common dependencies in output).
-
-Overriding this logic depends on the type of the dependency.
-
-### Not copying Assembly Reference
-
-Copying can be opted out via [Private metadata on the Reference item](https://learn.microsoft.com/previous-versions/visualstudio/visual-studio-2015/msbuild/common-msbuild-project-items?view=vs-2015#reference) (which corresponds to the `Copy Local` property of the reference in the Visual Studio properties dialog for the reference):
-
-```xml
-<ItemGroup>
-  <Reference Include="mydll">
-    <HintPath>..\somepath\mydll.dll</HintPath>
-    <!-- This indicates that the reference should not be copied to output folder. -->
-    <Private>false</Private>
-  </Reference>
-</ItemGroup>
-```
-
-### Not copying PackageReference
-
-Detailed options description can be found in [Controlling package dependency assets](https://learn.microsoft.com/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets). Here we'll offer three artifical examples:
-
-**Not copying package dependency to the immediate output folder:**
-
-```xml
-<ItemGroup>
-  <PackageReference Include="newtonsoft.json" Version="13.0.1">
-    <!-- This allows compiling against the dependency, but prevents it's copying to output folder or flow to downstream dependant projects. -->
-    <IncludeAssets>compile</IncludeAssets>
-  </PackageReference>
-</ItemGroup>
-```
-
-**Not copying package dependency to the downstream dependants output folder:**
-
-```xml
-<ItemGroup>
-  <PackageReference Include="newtonsoft.json" Version="13.0.1">
-    <!-- The dependency is copied to output folder in current referencing project, 
-           but it's not copied to output folder of projects referencing current project. -->
-    <PrivateAssets>all</PrivateAssets>
-  </PackageReference>
-</ItemGroup>
-```
-
-**Not copying package dependency from the upstream dependencies:**
-
-```xml
-<ItemGroup>
-  <ProjectReference Include="../somepath/MyProj.csproj">
-    <!-- This prevents PackageReferences from MyProj.csproj to be copied to output of current project. -->
-    <ExcludeAssets>all</ExcludeAssets>
-  </ProjectReference>
-</ItemGroup>
-```
-
-### Not copying ProjectReference
-
-The opt-out mechanism is analogous to [Assembly Reference copy opt-out](#not-copying-assembly-reference):
-
-```xml
-<ItemGroup>
-  <ProjectReference Include="../somepath/MyProj.csproj">
-    <!-- This indicates that the referenced project output should not be copied to output folder. -->
-    <Private>false</Private>
-  </ProjectReference>
-</ItemGroup>
-```
-
-Same metadata and logic applies here as it is being inherited from the `Reference` Item definition and the logic treats it identicaly. 
-
-## ProjectReference without accessibility and copying to output
-
-In a specific scenarios we might want to indicate that specific project should be built prior our project but said project should not be reference accessible nor its output copied to current project output. This can be helpful for build time only dependencies - projects defining behavior that is going to be used as build step of a current project.
-
-Such a behavior can be achived with [`ReferenceOutputAssembly` metadata](https://learn.microsoft.com/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference):
-
-```xml
-<ItemGroup>
-  <ProjectReference Include="../somepath/MyProj.csproj">
-    <!-- This indicates that the referenced project should not be referenced in code and output should not be copied to output folder. 
-         This way we basically only indicate the build order.
-    -->
-    <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-  </ProjectReference>
-</ItemGroup>
-```
-
-**Note:** This technique has possibly unexpected behavior when referencing project with executable output type (`<OutputType>Exe</OutputType>`) - in such case the output assembly (`.dll`) is still not copied and referenced (as the metadatum name implies) and hence the types defined within the project cannot be referenced, however other supplementary output (added as `content` or `none`) is copied to the current project output folder (for .NET Core this includes `deps.json`, `runtimeconfig.json` and mainly `<app>.exe`). In that case we can combine (or replace) the `ReferenceOutputAssembly` metadata with `Private` metadata - [as described above](#not-copying-projectreference). More details on this case [here](https://github.com/dotnet/msbuild/issues/4795#issuecomment-1442390297)
-
-## Forcing TargetFramework of a referenced multitargeted project
-
-Consider agaoin our previous [Onion architecture example](#OnionArchSample), but now the individual projects will be [multitargeted](https://learn.microsoft.com/nuget/create-packages/multiple-target-frameworks-project-file). 
-
-Repository Layer:
-
-```xml
-<Project Sdk="Microsoft.NET.Sdk">
-  <PropertyGroup>
-    <TargetFrameworks>netstandard2.0;net48</TargetFrameworks>
-  </PropertyGroup>
-
-  <ItemGroup Condition="'$(TargetFramework)' == 'net48'">
-    <ProjectReference Include="..\Domain-net48\Domain-net48.csproj" />
-    <PackageReference Include="System.Text.Json" Version="7.0.2" />
-  </ItemGroup>
-
-  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
-    <ProjectReference Include="..\Domain-netstd20\Domain-netstd20.csproj" />
-    <PackageReference Include="newtonsoft.json" Version="13.0.1">
-  </ItemGroup>
-</Project>
-```
-
-And it's going to be referenced by Service Layer:
-
-
-```xml
-<Project Sdk="Microsoft.NET.Sdk">
-  <PropertyGroup>
-    <OutputType>Exe</OutputType>
-    <TargetFrameworks>net48;netstandard2.0</TargetFrameworks>
-  </PropertyGroup>
-
-  <ItemGroup>
-    <ProjectReference Include="..\Repository\Repository.csproj"  />
-  </ItemGroup>
-</Project>
-```
-
-Building the Service Layer will create output folders for `net7` and `net48`:
-
-```
-net48
- |---- Repository.dll (targeted for net48)
- |---- Domain-net48.dll
- |---- System.Text.Json.dll
-
-net7
- |---- Repository.dll (targeted for netstandard2.0)
- |---- Domain-netstd20.dll
- |---- Newtonsoft.Json.dll 
-```
-
-Should we want to reference the netstandard version of the Repository Layer in our Service Layer - we can force the reference chain via `SetTargetFramework` metadata on `ProjectReference` item:
-
-```xml
-  <ItemGroup>
-    <ProjectReference Include="..\Repository\Repository.csproj" SetTargetFramework="TargetFramework=netstandard2.0" />
-  </ItemGroup>
-```
-
-**Notes:** 
-
-`SetTargetFramework` is currently not honored by the NuGet client([nuget issue #12436](https://github.com/NuGet/Home/issues/12436)), so the output folder will contain binaries from nuget packages as if this metadata was not used. To workaround this the apropriate nuget needs to be directly referenced from the project enforcing reference framework via `SetTargetFramework`, or copied to output/publish folder via different means.
-
-
-`SetTargetFramework` will properly enforce the framework for the `ProjectReference` chain. Once the `TargetFramework` overriding is encountered it is passed down the reference chain and the `ProjectReference`s respect it during the `TargetFramework` resolution. Due to the nature of handling of [transitive references in .NET-SDK style projects](#net-sdk-projects-and-access-to-transitive-references) and the fact that NuGet client doesn't honor `SetTargetFramework`, the transitive references can get resolved and built for multiple `TargetFramework`s. This means the output folder will contain proper version of the direct dependency - Repository Layer. The transitive references might overbuild, and output folder of current project (Service Layer) might contain both versions of the transitive project dependency (Domain-net48.dll and Domain-netstd20.dll). This limitation can be workarounded by switching of the transitive project references via `DisableTransitiveProjectReferences` (same as shown in [Access to transitive project references](#access-to-transitive-project-references))
-
diff --git a/documentation/wiki/Interactions-with-the-internal-repository.md b/documentation/wiki/Interactions-with-the-internal-repository.md
deleted file mode 100644
index 916ac2bd78d..00000000000
--- a/documentation/wiki/Interactions-with-the-internal-repository.md
+++ /dev/null
@@ -1,10 +0,0 @@
-# Interactions with the internal repository
-
-MSbuild got forked from an internal Microsoft repository. Although the Github repository is the official one, where development takes place, there are still some left-over connections to the internal one. This page attempts to document these.
-
-Changes to these files need to be migrated back into the internal repo because that's where they are localized:
-- [src/XMakeCommandLine/Microsoft.Build.Core.xsd](https://github.com/dotnet/msbuild/blob/main/src/XMakeCommandLine/Microsoft.Build.Core.xsd)
-- [src/XMakeCommandLine/Microsoft.Build.CommonTypes.xsd](https://github.com/dotnet/msbuild/blob/main/src/XMakeCommandLine/Microsoft.Build.CommonTypes.xsd)
-
-There should be no changes to the following files. They are shipped from the internal repo. The github ones are stale.
-- [all XamlRules](https://github.com/dotnet/msbuild/tree/main/src/XMakeTasks/XamlRules)
\ No newline at end of file
diff --git a/documentation/wiki/Labels.md b/documentation/wiki/Labels.md
deleted file mode 100644
index 0ede6a53483..00000000000
--- a/documentation/wiki/Labels.md
+++ /dev/null
@@ -1,12 +0,0 @@
-# MSBuild Labels
-Here's a brief explanation on the labels most often used by the MSBuild team excluding hopefully self-evident ones such as `bug`.
-
-| Label             | Applied When | Notes |
-|-------------------|--------------|-------|
-| `needs-triage`    | Team has yet to determine what area/prioritization applies to the issue. | This is the primary label queried during a regular bug triage meeting. Automatically removed when `needs-more-info` is applied. |
-| `needs-attention` | An issue requires the team look at it during bug triage. | Automatically applied when a stale issue receives a comment. |
-| `needs-more-info` | Team asked for info needed to continue an investigation. | If no response is given within 7 days, the `stale` label is applied. |
-| `initial-investigation` | A member of the team does a "first pass" investigation. | `needs-triage` is applied and team member and unassigns themselves after the initial investigation is complete. |
-| `stale` | An issue marked with `needs-more-info` is inactive for 7 days. | The issue will be closed after 30 days of inactivity while the `stale` label is applied. |
-| `For consideration` | An issue should get higher prioritization when planning the next set of features. | |
-| `help wanted` | Anyone can take ownership over this issue. | If a contributor wants to take the issue on, they should ask that it be assigned to them BEFORE doing development work.  |
diff --git a/documentation/wiki/Localization.md b/documentation/wiki/Localization.md
deleted file mode 100644
index 5ea4d4cf835..00000000000
--- a/documentation/wiki/Localization.md
+++ /dev/null
@@ -1,42 +0,0 @@
-# Localizing MSBuild
-
-## Localizable resource structure
-
-- Neutral resources: [*resx](https://github.com/search?utf8=%E2%9C%93&q=repo%3AMicrosoft%2Fmsbuild+extension%3Aresx&type=Code&ref=advsearch&l=&l=)
-- `Strings.shared.resx` is a shared resource and gets embedded into all msbuild dlls
-- each neutral resource has a directory named `xlf` besides it which contains its localized strings in .xlf format
-- there is one language per xlf
-- the logical name for a resource is: `<Assembly Name>.<Neutral Resx File Name>.resources`. In the ResourceManager this appears as `<Assembly Name>.<Neutral Resx File Name>` (without the trailing `.resources`). For example, the `Microsoft.Build` assembly uses the `Microsoft.Build.Strings.resources` [logical resource name](https://github.com/dotnet/msbuild/blob/cc3db358d34ad4cd1ec0c67e17582d7ca2a15040/src/Build/Microsoft.Build.csproj#L792) (the resource file is `Strings.resx`), and its corresponding [ResourceManager](https://github.com/dotnet/msbuild/blob/518c041f4511a6bc23eb40703b69a94ea46c65fd/src/Build/Resources/AssemblyResources.cs#L118) uses `Microsoft.Build.Strings`.
-
-## How to edit a resource
-
-- if you need to add / remove / update a resource, only do so in the neutral resx files. xlf files get automatically updated during localized builds.
-
-## What a localized build does
-
-- converts xlf files to localized resx files
-- the localized resx files are generated into the `$(IntermediaryOutputPath)`
-- produces satellite assemblies for each language
-- satellite assemblies are used even on English machines. This is for testing purposes, to ensure that English builds are not different than non English builds
-
-## Process for interacting with the localization team
-
-- 3 weeks cadence for main, initiated by loc team
-- on demand for main / release branches, initiated by msbuild team
-
-## Contributing a better translation
-
-- send a PR with an updated `<target>` element of the xlf resource (do not include other non-localization changes)
-- we will notify the localization team, which will then take over and review the PR
-
-## Localizing XSD "IntelliSense"
-
-Code completion ("IntelliSense") for MSBuild project files is provided minimally in Visual Studio by XML Schema files like [`Microsoft.Build.CommonTypes.xsd`](https://github.com/dotnet/msbuild/blob/ba9a1d64a7abf15a8505827c00413156a3eb7f62/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd). These files are English-only in the GitHub repo; their localization is managed in the Microsoft-internal `VS` repo.
-
-### If there is a bug in XSD localization
-
-File XSD localization bugs in this repo. The MSBuild team will coordinate with the Visual Studio localization team to redirect it appropriately.
-
-### When an XSD has been updated
-
-After updating an XSD in the GitHub repo, the MSBuild-to-VS-repo insertion process automatically updates the canonical Visual Studio copy of the XSD.
diff --git a/documentation/wiki/MSBuild-Environment-Variables.md b/documentation/wiki/MSBuild-Environment-Variables.md
deleted file mode 100644
index 01c8b7fb66c..00000000000
--- a/documentation/wiki/MSBuild-Environment-Variables.md
+++ /dev/null
@@ -1,12 +0,0 @@
-# MSBuild environment variables
-
-- [MsBuildSkipEagerWildCardEvaluationRegexes](#msbuildskipeagerwildcardevaluationregexes)
-
-
-### MsBuildSkipEagerWildCardEvaluationRegexes
-
-If specified, overrides the default behavior of glob expansion. 
-
-During glob expansion, if the path with wildcards that is being processed matches one of the regular expressions provided in the [environment variable](#msbuildskipeagerwildcardevaluationregexes), the path is not processed (expanded). 
-
-The value of the envvironment variable is a list of regular expressions, separated by semilcon (;).
\ No newline at end of file
diff --git a/documentation/wiki/MSBuild-Resources.md b/documentation/wiki/MSBuild-Resources.md
deleted file mode 100644
index 506e407258d..00000000000
--- a/documentation/wiki/MSBuild-Resources.md
+++ /dev/null
@@ -1,46 +0,0 @@
-# General Resources
- * [MSBuild Concepts](https://learn.microsoft.com/visualstudio/msbuild/msbuild-concepts)
- * [MSBuild Reserved and Well-Known Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-reserved-and-well-known-properties)
- * [MSBuild Tips & Tricks](MSBuild-Tips-&-Tricks.md)
- * [Target Maps](Target-Maps.md)
-
-# MSBuild Source Code
- * [https://github.com/dotnet/msbuild](https://github.com/dotnet/msbuild)
- * [https://source.dot.net](https://source.dot.net)
- * Use [referencesource.microsoft.com](https://referencesource.microsoft.com) or [sourceroslyn.io/](https://sourceroslyn.io/) to browse Microsoft MSBuild targets. Examples:
-   * search for "[_FindDependencies MSBuildProperty](https://referencesource.microsoft.com/#q=_FindDependencies%20MSBuildProperty)"
-   * find targets [referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences](https://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences)
-
-# Tools
-**Note:** These are third party tools
- * [MSBuildStructuredLog](https://msbuildlog.com/)
-   * A log viewer that displays a structured representation of executed targets, tasks, property and item values.
- * [MSBuildExtensionPack](https://github.com/mikefourie-zz/MSBuildExtensionPack) (also via [NuGet](https://www.nuget.org/packages/MSBuild.Extension.Pack))
-   * Provides a large collection of MSBuild Tasks, MSBuild Loggers and MSBuild TaskFactories.
- * [MSBuilder](https://github.com/MobileEssentials/MSBuilder)
-   * Reusable blocks of MSBuild helpers; MSBuilder's goal is to provide fine-grained nuget packages that can be installed when only a certain MSBuild extension (task, property, target) is needed.
- * [MSBuildExplorer](https://github.com/mikefourie/MSBuildExplorer)
-   * Use MSBuild Explorer to help you find your way around the make-up of your build file(s).
- * [MSBuild Sidekick](http://attrice.info/msbuild)
-   * MSBuild Sidekick allows you to view, edit, build and debug Visual Studio projects and solution files as well as custom MSBuild projects.
- * [MSBuildDumper](https://github.com/KirillOsenkov/MSBuildTools)
-     * Very quick tool to dump properties and items of a project without building it.
-     * Install from Chocolatey `cinst MSBuildDumper`.
- * [MSBuild Profiler](https://msbuildprofiler.codeplex.com/)
-   * A performance measurement tool for MSBuild scripts. MSBuild Profiler shows a graphical performance output for all your MSBuild scripts.
- * [MsBuildPipeLogger](https://msbuildpipelogger.netlify.com/) ([GitHub](https://github.com/daveaglick/MsBuildPipeLogger))
-   * A logger for MSBuild that sends event data over anonymous or named pipes.
- * [MSBuild Shell Extension](https://msbuildshellex.codeplex.com/) Note: Not supported on Windows 10.
-   * Lets you build Visual Studio solutions and projects as well as any MSBuild file through a context menu without opening Visual Studio.
-
-# Books
- * [Inside the Microsoft Build Engine: Using MSBuild and Team Foundation Build (2nd Edition) by Sayed Hashimi, William Bartholomew](https://www.amazon.com/Inside-Microsoft-Build-Engine-Foundation/dp/0735645248)
- * [MSBuild Trickery: 99 Ways to Bend the Build Engine to Your Will, by Brian Kretzler](https://www.amazon.com/MSBuild-Trickery-Ways-Build-Engine/dp/061550907X)
-
-# Blogs
- * [MSBuild Team Blog](https://learn.microsoft.com/archive/blogs/msbuild/) (archive)
- * [Sayed Hashimi's blog at sedodream.com](http://sedodream.com)
- * [Mike Fourie's blog https://mikefourie.wordpress.com](https://mikefourie.wordpress.com)
-
-# MSBuild Assemblies
-![MSBuild Assemblies](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/MSBuildAssemblies.png)
diff --git a/documentation/wiki/MSBuild-Tips-&-Tricks.md b/documentation/wiki/MSBuild-Tips-&-Tricks.md
deleted file mode 100644
index 94b9ec2f91b..00000000000
--- a/documentation/wiki/MSBuild-Tips-&-Tricks.md
+++ /dev/null
@@ -1,137 +0,0 @@
-# MSBuild Command-Line Switches
-See the [MSBuild Command-Line Reference](https://learn.microsoft.com/visualstudio/msbuild/msbuild-command-line-reference) for more information on switches.
- * `MSBuild.exe -pp:<FILE>`
-   * MSBuild preprocessor. Pass /pp to the command line to create a single huge XML project file with all project imports inlined in the correct order. This is useful to investigate the ordering of imports and property and target overrides during evaluation.
-   * Example usage: `msbuild MyProject.csproj /pp:inlined.xml`
- * `MSBuild.exe -nr:false`
-   * Disable node reuse (`/nodeReuse:false`). Don't leave MSBuild.exe processes hanging around (and possibly locking files) after the build completes. See more details in MSBuild command line help (/?). See also `MSBUILDDISABLENODEREUSE=1` below. Note that using this when building repeatedly will cause slower builds.
- * `MSBuild.exe -bl`
-   * Records all build events to a structured binary log file. The [MSBuildStructuredLog](https://github.com/KirillOsenkov/MSBuildStructuredLog) tool can be used to analyze this file.
- * `MSBuild.exe -noconlog`
-   * Used to suppress the usage of the console logger, which is otherwise always attached.
- * `MSBuild.exe -flp:v=diag`
-   * Passes parameters to the file logger. If you want to attach multiple file loggers, you do so by specifying additional parameters in the switches /flp1, /flp2, /flp3, and so on.
-
-# Environment Variables
-
- * `MSBuildDebugEngine=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
-  * Set this to cause any MSBuild invocation launched within this environment to emit binary logs and additional debugging information to `<DIRECTORY>`. Useful when debugging build or evaluation issues when you can't directly influence the MSBuild invocation, such as in Visual Studio.
- * `MSBUILDTARGETOUTPUTLOGGING=1`
-   * Set this to enable [printing all target outputs to the log](https://learn.microsoft.com/archive/blogs/msbuild/displaying-target-output-items-using-the-console-logger).
- * `MSBUILDLOGTASKINPUTS=1`
-   * Log task inputs (not needed if there are any diagnostic loggers already).
- * `MSBUILDEMITSOLUTION=1`
-   * Save the generated .proj file for the .sln that is used to build the solution.
- * `MSBUILDENABLEALLPROPERTYFUNCTIONS=1`
-   * Enable [additional property functions](https://devblogs.microsoft.com/visualstudio/msbuild-property-functions/).
- * `MSBUILDLOGVERBOSERARSEARCHRESULTS=1`
-   * In ResolveAssemblyReference task, log verbose search results.
- * `MSBUILDLOGCODETASKFACTORYOUTPUT=1`
-   * Dump generated code for task to a <GUID>.txt file in the TEMP directory
- * `MSBUILDDISABLENODEREUSE=1`
-   * Set this to not leave MSBuild processes behind (see `/nr:false` above, but the environment variable is useful to also set this for Visual Studio for example).
- * `MSBUILDLOGASYNC=1`
-   * Enable asynchronous logging.
- * `MSBUILDDEBUGONSTART=1`
-   * Launch debugger on build start.
-   * Setting the value of 2 allows for manually attaching a debugger to a process ID.
- * `MSBUILDDEBUGSCHEDULER=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
-   * Dumps scheduler state at specified directory (`MSBUILDDEBUGSCHEDULER` is implied by `MSBuildDebugEngine`).
-
-# TreatAsLocalProperty
-If MSBuild.exe is passed properties on the command line, such as `/p:Platform=AnyCPU` then this value overrides whatever assignments you have to that property inside property groups. For instance, `<Platform>x86</Platform>` will be ignored. To make sure your local assignment to properties overrides whatever they pass on the command line, add the following at the top of your MSBuild project file:
-
-```
-<Project TreatAsLocalProperty="Platform" DefaultTargets="Build">
-```
-
-This will make sure that your local assignments to the `Platform` property are respected. You can specify multiple properties in `TreatAsLocalProperty` separated by semicolon.
-
-# Visual Studio Background Builds
-Set the `TRACEDESIGNTIME=true` environment variable to output design-time build logs to TEMP: read more here: https://learn.microsoft.com/archive/blogs/jeremykuhne/vs-background-builds
-
-# Visual Studio Design-time (IntelliSense) builds
-
-Use this command-line to approximate what the design-time build does:
-
-```
-/t:CollectResolvedSDKReferencesDesignTime;DebugSymbolsProjectOutputGroup;CollectPackageReferences;ResolveComReferencesDesignTime;ContentFilesProjectOutputGroup;DocumentationProjectOutputGroupDependencies;SGenFilesOutputGroup;ResolveProjectReferencesDesignTime;SourceFilesProjectOutputGroup;DebugSymbolsProjectOutputGroupDependencies;SatelliteDllsProjectOutputGroup;BuiltProjectOutputGroup;SGenFilesOutputGroupDependencies;ResolveAssemblyReferencesDesignTime;CollectAnalyzersDesignTime;CollectSDKReferencesDesignTime;DocumentationProjectOutputGroup;PriFilesOutputGroup;BuiltProjectOutputGroupDependencies;ResolvePackageDependenciesDesignTime;SatelliteDllsProjectOutputGroupDependencies;SDKRedistOutputGroup;CompileDesignTime /p:SkipCompilerExecution=true /p:ProvideCommandLineArgs=true /p:BuildingInsideVisualStudio=true /p:DesignTimeBuild=true
-```
-
-# Diagnose WPF temporary assembly compilation issues
-
-Set the property `GenerateTemporaryTargetAssemblyDebuggingInformation` on the `GenerateTemporaryTargetAssembly` task:
-https://referencesource.microsoft.com/#PresentationBuildTasks/BuildTasks/Microsoft/Build/Tasks/Windows/GenerateTemporaryTargetAssembly.cs,4571677f19ba0d24,references
-
-If the property `$(GenerateTemporaryTargetAssemblyDebuggingInformation)` is set, the temporary project generated during XAML project build will not be deleted and will be available for inspection. This is only available in the recent versions of .NET Framework, so check if your `Microsoft.WinFX.targets` file has it.
-
-Also the name of the project was renamed from `*.tmp_proj` to `*_wpftmp.csproj` so the file extension is now C#: `WpfApp1_jzmidb3d_wpftmp.csproj`
-
-# Extending builds
-
-See the "Extending All Builds" section from [this article](https://www.red-gate.com/simple-talk/development/dotnet-development/extending-msbuild/). Also read about [`CustomBeforeMicrosoftCommonProps`](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,68), [`CustomBeforeMicrosoftCommonTargets`](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.targets,71), and `CustomAfterMicrosoftCommonProps`/`CustomAfterMicrosoftCommonTargets`. And don't miss the explainer below.
-
-Create a file, say `Custom.props`, with the following contents:
-
-```
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-    <MyCustomProperty>Value!</MyCustomProperty>
-  </PropertyGroup>
-</Project>
-```
-
-and place it in one of the locations described below, then build any project. It will have `MyCustomProperty` set to `Value!`.
-
-## User-wide level (`MSBuildUserExtensionsPath`)
-
-In one of the following locations (`%LOCALAPPDATA%` evaluating to something like `C:\Users\username\AppData\Local`):
-
-* `%LOCALAPPDATA%\Microsoft\MSBuild\Current\Imports\Microsoft.Common.props\ImportBefore`
-  * aka: `$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore`
-* `%LOCALAPPDATA%\Microsoft\MSBuild\Current\Imports\Microsoft.Common.props\ImportAfter`
-  * aka: `$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter`
-* `%LOCALAPPDATA%\Microsoft\MSBuild\Current\Microsoft.Common.targets\ImportBefore`
-  * aka: `$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore`
-* `%LOCALAPPDATA%\Microsoft\MSBuild\Current\Microsoft.Common.targets\ImportAfter`
-  * aka: `$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter`
-
-**Note:** the above locations are in the order in which they are imported by `Microsoft.Common.props` and `Microsoft.Common.targets` respectively. Setting your properties later, overwrites previous values. And mind the additional directory level `Imports\` for the files imported by `Microsoft.Common.props`.
-
-**Also note:** [`$(MSBuildUserExtensionsPath)`](https://learn.microsoft.com/visualstudio/msbuild/customize-your-local-build#msbuildextensionspath-and-msbuilduserextensionspath) is equal to `%LOCALAPPDATA%\Microsoft\MSBuild`.
-
-## MSBuild-wide level (`MSBuildExtensionsPath`)
-
-There is another MSBuild-wide location imported by `Microsoft.Common.props` from underneath `$(MSBuildToolsRoot)`, the installation directory of MSBuild, - which, when using it from modern Visual Studio versions, would often equal `$(VsInstallRoot)\MSBuild`. It goes by the name [`MSBuildExtensionsPath`](https://learn.microsoft.com/visualstudio/msbuild/customize-your-local-build#msbuildextensionspath-and-msbuilduserextensionspath).
-
-* `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportBefore`
-* `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter`
-* `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportBefore`
-* `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter`
-
-The principle is the same, drop a valid MSBuild file into one of these locations to extend your build according to whatever you put into the respective MSBuild file.
-
-**Note:** The value of `$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props` after evaluation would be something like `C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Imports\Microsoft.Common.Props`.
-
-**Also note:** technically the imports happen from `Microsoft.Common.CurrentVersion.targets` where the above directories say `Microsoft.Common.targets`.
-
-## Explainer: the underlying extension mechanisms and related mechanisms
-
-The above explanations are only half the truth, though.
-
-* The file extension of the file doesn't matter - it's a convention. Any file conforming to the MSBuild XML schema in that location should get picked up and imported.
-* `Microsoft.Common.props` and `Microsoft.Common.targets` conditionally imports from the locations mentioned throughout this section, you can use properties to suppress this extension mechanism, say from the command line:
-  * For user-wide locations set these properties to something else than `true` respectively:
-    * `ImportUserLocationsByWildcardBeforeMicrosoftCommonProps`
-    * `ImportUserLocationsByWildcardAfterMicrosoftCommonProps`
-    * `ImportUserLocationsByWildcardBeforeMicrosoftCommonTargets`
-    * `ImportUserLocationsByWildcardAfterMicrosoftCommonTargets`
-  * For MSBuild-wide locations set these properties to something else than `true` respectively:
-    * `ImportByWildcardBeforeMicrosoftCommonProps`
-    * `ImportByWildcardAfterMicrosoftCommonProps`
-    * `ImportByWildcardBeforeMicrosoftCommonTargets`
-    * `ImportByWildcardAfterMicrosoftCommonTargets`
-* The `Directory.*.props`, `Directory.*.targets` et. al. also offer ways to extend your build. They are fairly well-known and documented:
-  * [`Directory.Build.props` and `Directory.Build.targets`](https://learn.microsoft.com/visualstudio/msbuild/customize-by-directory)
-  * [`Directory.Solution.props` and `Directory.Solution.targets`](https://learn.microsoft.com/visualstudio/msbuild/customize-solution-build) as well as `before.{solutionname}.sln.targets` and `after.{solutionname}.sln.targets` can be used to inject properties, item definitions, items and targets into your build
diff --git a/documentation/wiki/Mac-Debugging.md b/documentation/wiki/Mac-Debugging.md
deleted file mode 100644
index fedab4908d6..00000000000
--- a/documentation/wiki/Mac-Debugging.md
+++ /dev/null
@@ -1,42 +0,0 @@
-# Debugging with MacOS
-* Open terminal 
-  * Hit command-space, type terminal, hit enter. Alternatively, hit magnifying glass (spotlight) in upper-right corner and search for terminal.
-* Build and run tests
-  * Navigation in terminal is similar to command prompt (cd), although you type `ls` in place of `dir`.
-  * **Use `./build.sh -test` instead of `.\build.cmd -test`.**
-  * If tests fail, they will appear twice in red: once when the test fails and once after all tests have run. As an example, it might say `XUnit : error : Tests failed: /Users/forgind/Desktop/code/msbuild/artifacts/TestResults/Debug/Microsoft.Build.Utilities.UnitTests_netcoreapp2.1_x64.html [netcoreapp2.1|x64] [/Users/forgind/Desktop/code/msbuild/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj]` near the end.
-  * Successful tests appear in white and only once like this: `Tests succeeded: /Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.CommandLine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.CommandLine.UnitTests.dll [netcoreapp2.1|x64]`
-* Choose a set of tests to analyze.
-  * From the previous example, one sample would be `Microsoft.Build.UnitTests_netcoreapp2.1_x64`, that is, the part immediately preceding `.html`.
-* Run `find . -name Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.log`
-  * Note the addition of the extension `.log` in place of `.html`.
-  * This should print out a path (from your current working directory) to the relevant log file.
-* Type `tail -n 1 <path from previous step>`
-  * This prints out the last line of that file.
-  * You can also just open it normally from a finder window.
-  * This file contains the standard output from the last run.
-  * You may notice that the line printed by this command is a single (long) command line statement.
-* Copy the command line statement from the previous step. Remove the portion after the redirection (`>` character not preceded by 2) including that character. You may notice that part redirects output to the file you’re viewing.
-  * The last part (`2>&1`) redirects standard error (using `2>`) to the same place as where standard out is going (`&1`), in this case this log file.
-  * If you would like to rerun all tests from a given class (rather than just a specific method), you can append `-class` and the class's fully qualified name. To run all tests from `TaskBuilder_Tests`, for instance, you would add `-class Microsoft.Build.UnitTests.BackEnd.TaskBuilder_Tests` and run the statement without the following steps. Note that in the example below, standard output is redirected to `/dev/null`, thus only printing the errors.
-* Prepend `./build.sh &&` to the truncated command line statement.
-* Append `-method ` and the name of the method you want to test to the end.
-  * You can find the failing method by opening the html file  (`/Users/forgind/Desktop/code/msbuild/artifacts/TestResults/Debug/Microsoft.Build.Utilities.UnitTests_netcoreapp2.1_x64.html` from the above case) in a web browser of choice. You will need to prepend `file://` if you use Safari.
-  * This will show a list of failing methods including why they failed.
-*	Running this statement will run just the one test (after building) and print out both the error and the Console.WriteLine() statements you added to the test/what it calls.
-
-
-Sample statements with outputs below and changes to the output of the second command **bolded** (note that additionally, the last two lines and one character of the second output were deleted):
-
-<pre><code>
-$ find . -name Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.log
-./artifacts/log/Debug/Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.log
-
-$ tail -n 1 ./artifacts/log/Debug/Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.log
-"/Users/forgind/Desktop/code/msbuild/.dotnet/dotnet" exec --depsfile "/Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.Engine.UnitTests.deps.json" --runtimeconfig "/Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.Engine.UnitTests.runtimeconfig.json"  "/Users/forgind/.nuget/packages/xunit.runner.console/2.4.1/tools/netcoreapp2.0/xunit.console.dll" "/Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.Engine.UnitTests.dll" -noautoreporters -xml "/Users/forgind/Desktop/code/msbuild/artifacts/TestResults/Debug/Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.xml" -html "/Users/forgind/Desktop/code/msbuild/artifacts/TestResults/Debug/Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.html" -notrait category=nonosxtests -notrait category=netcore-osx-failing -notrait category=nonnetcoreapptests -notrait category=failing > "/Users/forgind/Desktop/code/msbuild/artifacts/log/Debug/Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.log" 2>&1
-
-$ "/Users/forgind/Desktop/code/msbuild/.dotnet/dotnet" exec --depsfile "/Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.Engine.UnitTests.deps.json" --runtimeconfig "/Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.Engine.UnitTests.runtimeconfig.json"  "/Users/forgind/.nuget/packages/xunit.runner.console/2.4.1/tools/netcoreapp2.0/xunit.console.dll" "/Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.Engine.UnitTests.dll" -noautoreporters -xml "/Users/forgind/Desktop/code/msbuild/artifacts/TestResults/Debug/Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.xml" -html "/Users/forgind/Desktop/code/msbuild/artifacts/TestResults/Debug/Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.html" -notrait category=nonosxtests -notrait category=netcore-osx-failing -notrait category=nonnetcoreapptests -notrait category=failing -class Microsoft.Build.UnitTests.BackEnd.TaskBuilder_Tests > /dev/null
-Microsoft.Build.UnitTests.BackEnd.TaskBuilder_Tests.NullMetadataOnLegacyOutputItems [FAIL]
-
-$ <b>./build.sh &&</b> "/Users/forgind/Desktop/code/msbuild/.dotnet/dotnet" exec --depsfile "/Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.Engine.UnitTests.deps.json" --runtimeconfig "/Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.Engine.UnitTests.runtimeconfig.json"  "/Users/forgind/.nuget/packages/xunit.runner.console/2.4.1/tools/netcoreapp2.0/xunit.console.dll" "/Users/forgind/Desktop/code/msbuild/artifacts/bin/Microsoft.Build.Engine.UnitTests/Debug/netcoreapp2.1/Microsoft.Build.Engine.UnitTests.dll" -noautoreporters -xml "/Users/forgind/Desktop/code/msbuild/artifacts/TestResults/Debug/Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.xml" -html "/Users/forgind/Desktop/code/msbuild/artifacts/TestResults/Debug/Microsoft.Build.Engine.UnitTests_netcoreapp2.1_x64.html" -notrait category=nonosxtests -notrait category=netcore-osx-failing -notrait category=nonnetcoreapptests -notrait category=failing <b>-method Microsoft.Build.UnitTests.BackEnd.TaskBuilder_Tests.NullMetadataOnLegacyOutputItems</b>
-</code></pre>
diff --git a/documentation/wiki/Microsoft.Build.Framework.md b/documentation/wiki/Microsoft.Build.Framework.md
deleted file mode 100644
index 658d8d6c57f..00000000000
--- a/documentation/wiki/Microsoft.Build.Framework.md
+++ /dev/null
@@ -1,31 +0,0 @@
-### Microsoft.Build.Framework
-It you have looked carefully, you might notice some odd behavior around this assembly (Microsoft.Build.Framework). We released the source here, but in some cases if you use our `BuildAndCopy.cmd` script, you will reference the one on your machine instead of the one you just built! Here's why.
-
-Microsoft.Build.Framework contains the types and interfaces for extensibility in MSBuild. If you've ever written a custom Task, you might recognize them as ITask, ITaskItem, etc. After you build your Task, let's say targeting `Microsoft.Build.Framework, Version=12.0.0.0, PublicKeyToken=b03f5f7f11d50a3a` (Visual Studio 2013), anyone with MSBuild 12.0 or later can use your Task. In later versions of MSBuild, say version 14.0, we will use a [binding redirect](https://learn.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/bindingredirect-element) to point you to the newer version of Microsoft.Build.Framework. Assuming we did our jobs right with compatibility, your Task should run without ever knowing the difference. The crucial point of detail here is that the public key token for the Framework assembly **did not change** between version. If it does, binding redirection is not allowed.
-
-## Option 1 - Project Reference
-By default this is enabled. This means that all MSBuild code will reference Microsoft.Build.Framework as a project reference and therefore will not have the same public key token as the retail version.
-
-| Pros  | Cons  |
-|:-:|:-:|
-| You can customize/change Microsoft.Build.Framework as much as you want. Change the types, base implementation, interfaces, it's up to you. | You can not build anything that uses a custom task **unless** that custom task references your Microsoft.Build.Framework (or more precisely, one with the same public key token) |
-
-## Option 2 - Retail Assembly Reference
-If you set the `TargetRetailBuildFramework` property to `true`, this behavior will occur. You are now referencing the public retail assembly version 14.0.0.0 (Visual Studio 2015).
-
-| Pros  | Cons  |
-|:-:|:-:|
-| You can build projects that use custom tasks. | You cannot make any changes to the Framework project. If you do, they won't be used. |
-
-To make this a little bit easier, use: 
-```
-BuildAndCopy.cmd <path> true
-```
-This will set the property for you and create a drop of MSBuild and dependencies needed to build other project.
-
-## Option 3 - Test or Delay Signing
-For the advanced user, another option here is to delay sign this version of MSBuild with our public key. Since that part of the key is public, it's very easy to extract (using `Sn.exe`) and delay sign. You can get more information on that here:
- * [Delay Signing](https://learn.microsoft.com/archive/blogs/shawnfa/delay-signing)
- * [Test Key Signing](https://web.archive.org/web/20101005012428/http://blogs.msdn.com/b/shawnfa/archive/2005/10/24/484170.aspx)
-
-Delay signing is the easiest, but it modifies your system to allow it to load and trust an assembly (Microsoft.Build.Framework) even when it's not signed at all, from any source. The Test Key Signing allows for a much more secure approach (as long as you keep your private key private), but is more complicated to setup. We are providing this as a reference, but please only try this if you: really want to customize Microsoft.Build.Framework and use existing custom Tasks, you feel comfortable with the security implications, and you acknowledge this is all at your own risk.
\ No newline at end of file
diff --git a/documentation/wiki/Nodes-Orchestration.md b/documentation/wiki/Nodes-Orchestration.md
deleted file mode 100644
index e4038dbcd40..00000000000
--- a/documentation/wiki/Nodes-Orchestration.md
+++ /dev/null
@@ -1,72 +0,0 @@
-Transcript of a talk with Rainer - [internal link] [recording](https://msit.microsoftstream.com/video/fde00840-98dc-ba75-0ebd-f1ed9ca0e097)
-
-## Need for multiple processes
-MSBuild is multiprocess system today.
-Multiple processes are used in few scenarios:
-
-1) **TaskHost** - allowing to run back compatible tasks and MSBuild plugins requiring different runtime.
-Task declares (in [UsingTask](https://learn.microsoft.com/en-us/visualstudio/msbuild/usingtask-element-msbuild)) what environment it expects, and if it's not compatible with current configuration (today for VS that's x64 net4) - it'll be isolated.
-
-    [GenerateResource](https://learn.microsoft.com/en-us/visualstudio/msbuild/generateresource-task) task uses this (used to use this).
-
-   `TaskHost` is supported so far, but performance is not closely watched.
-
-   Currently, [MSBuild running on .NET Core cannot run tasks compiled against the full desktop .NET environment](https://github.com/dotnet/msbuild/issues/711). Analogously, [.NET core tasks cannot be run from Visual Studio](https://github.com/dotnet/msbuild/issues/4834).
-
-2) **Parallel builds** - needed since tasks can access process wide state - namely current working dir, environment vars. Those can change between projects (especially [`Compile Include`](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-items) often contains relative path, without specifying `$MSBuildProjectDirectory` - so it relies on current directory being the location of the project file). For this reason node in parallel build can run only one task at a time.
-
-
-## Communication
-In a presence of multiple processes we need interprocess communication.
-
-### Messages (de)serialization
-
-Communication messages should deriver from [`ITranslatable`](https://github.com/dotnet/msbuild/blob/main/src/Shared/ITranslatable.cs) - it dictates the both direction of serialization via single method - [`void Translate(ITranslator translate)`](https://github.com/dotnet/msbuild/blob/main/src/Shared/ITranslatable.cs#L16)
-
-Majority of translations use custom binary serialization, there is though backfall to [`TranslateDoteNet`](https://github.com/dotnet/msbuild/blob/main/src/Shared/ITranslator.cs#L257) method that uses `BinaryFormatter`.
-
-Event args use different type of serialization - a `CreateFromStream` and `WriteToStream` methods are discovered via reflection and used to serialize type (with few exceptions explicitly translated within [`LogMessagePacketBase`](https://github.com/dotnet/msbuild/blob/main/src/Shared/LogMessagePacketBase.cs)).
-
-### Transport
-
-Endpoints (nodes) communicate via named pipes (Windows or named pipes API implementation on other plaforms). Communication is facilitated via [`NodeProviderOutOfProcBase`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs)
-
-The validation of transport is done via [proprietary handshake](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs#L501-L508).
-
-
-## Orchestration
-
-MSBuild consist of nodes. First spun is so called **entrypoint node**. It runs a **scheduler**. Then there are **worker nodes** - those can only execute projects. Nodes are spun by [`NodeLauncher`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Communications/NodeLauncher.cs) - this is being called from [`NodeProviderOutOfProcBase.GetNodes`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs#L186) (which can decide to reuse existing node or start a new process), that is ultimately called by [`NodeManger`](https://github.com/dotnet/msbuild/blob/main/src/Deprecated/Engine/Engine/NodeManager.cs).
-
-`NodeManager` is a build component (`IBuildComponent`) - so it can be retrieved from build engine (via `IBuildComponentHost.GetComponent`).
-
-Node is described by [`NodeInfo`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Communications/NodeInfo.cs).
-
-MSBuild can be started from existing process via API, or via MSBuild.exe - in both cases this process becomes a `scheduler node` and may or may not run other work in-process. By default the main process has as well a `worker node` (project build node). This can be tweaked by API and/or [environment variables](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-environment-variables#configure-msbuild-in-the-net-cli).
-
-When MSBuild start building a project it can eventually start processing MSBuild task that has [`BuildInParallel`](https://learn.microsoft.com/en-us/visualstudio/msbuild/building-multiple-projects-in-parallel-with-msbuild?view=vs-2022) set to `true` (which is a default) and multiple projects to build (e.g. a project with multiple `ProjectReference` elements) at that point `scheduler` orchestrates multiple `worker nodes` via `NodeManager` (upper limited via maximum parallelization - configurable via API or CLI (`-maxcpucount|-m`)) .
-
-Bugs in node communication layer can manifest as a slow build - otherwise fully functional. As `NodeManager` is trying to setup new nodes (and failing) and `scheduler` is working with only a single (in-proc) node that it has.
-
-Work unit for nodes is a `project instance` - a project together with set of glabal properties that make the project unique.
-
-----
-**Example:** 
-
-Multitargeted project (`TargetFrameworks=x;Y`) - this will generate 'outer-build' - a project with no global properties set; and 'inner build' for each `TargetFramework` (so one instance with `TargetFramework=X`, `TargetFramework=Y`). All those are distinct - so can be scheduled on separate nodes (in practice the outer build is scheduled on a node, hits the `ResolveProjectReferences` that will produce the two projects for particular `TargetFramework` - one is scheduled on the same node, other one waits for a different node to be available/spun).
-
-----
-
-MSBuild scheduler maintains a list of projects that are eligible to run (not blocked) and list of free worker nodes (plus knows a mapping of projects already mapped to particular nodes) and maps the work. [It performs some heuristics](https://github.com/dotnet/msbuild/blob/7cfb36cb90d1c9cc34bc4e0910d0c9ef42ee47b6/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L776-L783) prioritizing work that is likely to request more work (e.g. dir.proj files).
-
-## Scheduler assumptions
-
-Node in parallel build can run only one task at a time (task can explicitly temporarily vacate the node via `IBuildEngine.Yield`, or this can implicitly happen when MSBuild discovers dependencies on tasks that have not run yet)
-
-Once a `project instance` is assigned to a worker node - it is locked to that node (and cannot be run on another one). Above 2 facts can lead to scheduling issues (priorities inversions, blocking).
-
-Scheduler can (opt-in) dump a graph of dependencies from last build into a text file and then use it in the next build (with option of [various scheduling algorithms](https://github.com/dotnet/msbuild/blob/7cfb36cb90d1c9cc34bc4e0910d0c9ef42ee47b6/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L833))
-
-Another mode of building is `graph build` - where project is build only once all its dependencies are resolved (so the build graph needs to be known and unchanged upfront).
-
-
diff --git a/documentation/wiki/Providing-Binary-Logs.md b/documentation/wiki/Providing-Binary-Logs.md
deleted file mode 100644
index 37e541136d8..00000000000
--- a/documentation/wiki/Providing-Binary-Logs.md
+++ /dev/null
@@ -1,56 +0,0 @@
-# Providing MSBuild Binary Logs for investigation
-
-MSBuild has the ability to capture a detailed binary log file.  If you are having a build issue and are able to provide a binary log, this can be very helpful for investigating the issue.
-
-However, you should be aware what type of information is captured in the binary log to make sure you are not inadvertently sharing more than you intend.  The binary log captures almost everything your build does, including the contents of your project files and any files (such as .props and .targets) that they import, all tasks that are run during the build as well as the input and output, as well as all environment variables used by the build logic.  It generally doesn't include the contents of the source files that are compiled, but it does capture their full names and paths.
-
-⚠ NOTE: some build environments make secrets available using environment variables. Before sharing a binary log, make sure it does not expose API tokens or other important secrets.
-
-## Capturing Binary Logs for command-line builds
-
-You can create a binary log by passing the `-bl` parameter to MSBuild (`MSBuild.exe` or `dotnet build`). You can explore the contents of the generated .binlog file using [MSBuild Structured Log Viewer](http://msbuildlog.com/) or in your browser using [Live Structured Log Viewer](https://live.msbuildlog.com). Note: We don't capture any data from binary logs viewed on your browser.
-
-Examples:
-
-```sh
-dotnet build -bl
-dotnet build -bl:SpecificStep.binlog
-MSBuild.exe -bl:ServiceRelease.binlog -p:Configuration=Release
-```
-
-[More details about binary logs](Binary-Log.md)
-
-## Capturing Binary Logs Through Visual Studio
-
-### Capturing logs for all MSBuild invocations
-
-Set `MSBUILDDEBUGENGINE` environment variable to `'1'` and (optionally) set `MSBUILDDEBUGPATH` to an existing destination folder to store the captured logs. Then start Visual Studio from the same shell to inherit the environment:
-
-`cmd:`
-
-```batch
-> SET MSBUILDDEBUGENGINE=1
-> SET MSBUILDDEBUGPATH=C:\MSBuildReproLogs
-> devenv.exe MySolution.sln
-```
-
-`PowerShell:`
-
-```powershell
-> $env:MSBUILDDEBUGENGINE = 1
-> $env:MSBUILDDEBUGPATH="C:\MSBuildReproLogs"
-> & "devenv.exe" MySolution.sln
-```
-
-MSBuild binary logs are then captured to a location specified via `MSBUILDDEBUGPATH` environment variable (or defaults to `MSBuild_Logs` subfolder of a current folder or `%temp%`, based on access rights).
-
-⚠ NOTE: logs are being recorded for each MSBuild invocation (including design time builds) and kept in the folder without removing older ones - so the number of log files can grow quickly. It is recommended to set the opt-in environment variable only for the short duration of reproducing the issue to be investigated (though it is understandable that some nondeterministic issues might need multiple reproduction attempts)
-
-Further reading:
-
-* [More technical info](Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#logs)
-* [Design time builds logs](https://github.com/dotnet/project-system/blob/main/docs/repo/debugging/design-time-builds.md#gathering-full-fidelity-binlogs)
-
-### Capturing specific logs for chosen build invocations
-
-See [this guide](https://github.com/dotnet/project-system-tools) in the Project System Tools repo for capturing binlogs through Visual Studio.
diff --git a/documentation/wiki/Rebuilding-when-nothing-changed.md b/documentation/wiki/Rebuilding-when-nothing-changed.md
deleted file mode 100644
index 5f9fc83bd52..00000000000
--- a/documentation/wiki/Rebuilding-when-nothing-changed.md
+++ /dev/null
@@ -1,19 +0,0 @@
-# How to investigate rebuilding when nothing has changed
-
-There is a class of problems with build where when you build twice, it still rebuilds fully the second time even though nothing has changed. This is called build incrementality issues. They can happen in MSBuild or in Visual Studio (in which case the VS project system's up-to-date-check decides to rebuild the project).
-
-There are multiple tools to investigate and fix broken incrementality. Start with the blog posts below.
-
- * [How to investigate Rebuilding in Visual Studio when nothing has changed](https://learn.microsoft.com/archive/blogs/kirillosenkov/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed)
- * [MSBuild: unnecessary rebuilds because of generated AssemblyAttributes.cs](https://learn.microsoft.com/archive/blogs/kirillosenkov/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs)
- * [When Visual Studio keeps rebuilding Projects that have not changed](https://web.archive.org/web/20120321204616/http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/)
- * [How to build incrementally](https://learn.microsoft.com/visualstudio/msbuild/how-to-build-incrementally)
- * [Incremental builds](https://learn.microsoft.com/visualstudio/msbuild/incremental-builds)
-
-Strings to search for in the build logs:
- * `Building target "CoreCompile" completely`
- * `is newer than output`
- * `out-of-date`
- * `missing`
-
-Consider using https://msbuildlog.com to help with searching through the build log.
\ No newline at end of file
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
deleted file mode 100644
index 1dff452245f..00000000000
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ /dev/null
@@ -1,167 +0,0 @@
-One of the most important tasks in the MSBuild toolset is `ResolveAssemblyReference` (RAR). Its purpose is to take all the references specified in .csproj files (or elsewhere) via the `<Reference>` item and map them to paths to assembly files on disk. The compiler only can accept a .dll path on disk as a reference, so `ResolveAssemblyReference` converts strings like `mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089` to paths like `C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.6.1\mscorlib.dll` which are then passed to the compiler via the /r switch.
-
-Additionally RAR determines a closure of all .dll/exe references recursively, and for each of them determines whether it should be copied to the build output directory or not. It doesn't do the actual copying (that is handled later, after the actual compile step), but it prepares an item list of files to copy.
-
-RAR is invoked from the `ResolveAssemblyReferences` target:
-![image](https://cloud.githubusercontent.com/assets/679326/21276536/ca861968-c386-11e6-9a06-a3d74532ed15.png)
-
-If you notice the ordering, ResolveAssemblyReferences is happening before Compile, and CopyFilesToOutputDirectory happens after Compile (obviously).
-
-## Source Code
-You can browse Microsoft's MSBuild targets online at:
-https://github.com/dotnet/msbuild/blob/a936b97e30679dcea4d99c362efa6f732c9d3587/src/Tasks/Microsoft.Common.CurrentVersion.targets#L1991-L2140
-This is where the RAR task is invoked in the targets file.
-
-The source code for RAR is at:
-https://github.com/dotnet/msbuild/blob/main/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
-
-## Inputs
-RAR is very detailed about logging its inputs:
-![image](https://cloud.githubusercontent.com/assets/679326/21276697/76ea6830-c387-11e6-94f7-cd523c19064e.png)
-The Parameters node is standard for all tasks, but additionally RAR logs its own set of information under Inputs (which is basically the same as under Parameters but structured differently). RAR logs this information in a method called LogInputs():
-https://github.com/dotnet/msbuild/blob/xplat/src/XMakeTasks/AssemblyDependency/ResolveAssemblyReference.cs#L1249
-
-The most important inputs are Assemblies and AssemblyFiles:
-
-```
-    <ResolveAssemblyReference
-        Assemblies="@(Reference)"
-        AssemblyFiles="@(_ResolvedProjectReferencePaths);@(_ExplicitReference)"
-```
-
-http://source.roslyn.io/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.CurrentVersion.targets,1820
-
-`Assemblies` is just using the contents of the `Reference` MSBuild item at the moment when RAR is invoked for the project. All the metadata/assembly references, including your NuGet references, go here. Each reference has a rich set of metadata attached to it:
-![image](https://cloud.githubusercontent.com/assets/679326/21276904/5ef66a3e-c388-11e6-8c6f-500169d9b79d.png)
-
-`AssemblyFiles` comes from `ResolveProjectReference` target's output item called `_ResolvedProjectReferencePaths`. `ResolveProjectReference` runs before RAR and it converts `<ProjectReference>` items to paths of built assemblies on disk. So the `AssemblyFiles` will contain the assemblies built by all referenced projects of the current project:
-![image](https://cloud.githubusercontent.com/assets/679326/21276978/e67ee99a-c388-11e6-9796-33e75caa2dc6.png)
-
-Another useful input is the boolean `FindDependencies` parameter which takes its value from the `_FindDependencies` property:
-```
-FindDependencies="$(_FindDependencies)"
-```
-
-You can set this property to false in your build to turn off analyzing transitive dependency assemblies.
-
-## Execution
-
-The source code of the main `Execute()` method can be found in MSBuild source code on GitHub:
-https://github.com/dotnet/msbuild/blob/xplat/src/XMakeTasks/AssemblyDependency/ResolveAssemblyReference.cs#L1877
-
-The algorithm simplified is:
-```
-...
-Line 1923: LogInputs();
-...
-// useful environment variable to set to crank up detailed search result logging
-Line 1930: _logVerboseSearchResults = Environment.GetEnvironmentVariable("MSBUILDLOGVERBOSERARSEARCHRESULTS") != null;
-...
-Line 2087: ReferenceTable dependencyTable = new ReferenceTable(...) // main data structure
-...
-Line 2052: ReadStateFile(); // read the cache file from the `obj` directory if present
-...
-Line 2182: dependencyTable.ComputeClosure(allRemappedAssemblies, _assemblyFiles, _assemblyNames, generalResolutionExceptions);
-...
-Line 2213: // Build the output tables.
-           dependencyTable.GetReferenceItems
-           (
-               out _resolvedFiles,
-               out _resolvedDependencyFiles,
-               out _relatedFiles,
-               out _satelliteFiles,
-               out _serializationAssemblyFiles,
-               out _scatterFiles,
-               out _copyLocalFiles
-           );
-...
-Line 2274: WriteStateFile(); // write the cache file to the `obj` directory
-...
-Line 2284: LogResults();
-...
-```
-
-Very simplified, the way it works is it takes the input list of assemblies (both from metadata and project references), retrieves the list of references for each assembly it processes (by reading metadata) and builds a transitive closure of all referenced assemblies, and resolves them from various locations (including the GAC, AssemblyFoldersEx, etc.).
-
-It builds a ReferenceTable:
-https://github.com/dotnet/msbuild/blob/xplat/src/XMakeTasks/AssemblyDependency/ReferenceTable.cs
-
-Referenced assemblies are added to the closure iteratively until no more new references are added. Then the algorithm stops.
-
-Direct references that we started with are called Primary references. Indirect assemblies that were added to closure because of a transitive reference are called Dependency. Each indirect assembly remembers all the primary ("root") items that led to its inclusion and their corresponding metadata.
-
-## Results
-
-RAR is just as rich at logging results as it is for inputs:
-![image](https://cloud.githubusercontent.com/assets/679326/21277329/ab52e9aa-c38a-11e6-9037-c98efbee0055.png)
-
-Resolved assemblies are divided into two categories: Primary references and Dependencies. Primary references were specified explicitly as references of the project being built. Dependencies were inferred from references of references transitively.
-
-**Important note:** RAR reads assembly metadata to determine the references of a given assembly. When the C# compiler emits an assembly it only adds references to assemblies that are actually needed. So it may happen that when compiling a certain project the project may specify a unneeded reference that won't be baked into the assembly. It is OK to add references to project that are not needed; they are just ignored.
-
-## CopyLocal item metadata
-
-References can also have the `CopyLocal` metadata or not. If the reference has `CopyLocal = true`, it will later be copied to the output directory by the `CopyFilesToOutputDirectory` target. In this example, DataFlow is CopyLocal while Immutable is not:
-![image](https://cloud.githubusercontent.com/assets/679326/21277638/3dde6d16-c38c-11e6-8997-547ab51152aa.png)
-
-If the CopyLocal metadata is missing entirely, it is assumed to be true by default. So RAR by default tries to copy dependencies to output unless it finds a reason not to. RAR is quite detailed about the reasons why it chose a particular reference to be CopyLocal or not.
-
-All possible reasons for CopyLocal decision are enumerated here:
-https://github.com/dotnet/msbuild/blob/main/src/Tasks/AssemblyDependency/CopyLocalState.cs
-It is useful to know these strings to be able to search for them in build logs.
-
-## Private item metadata
-An important part of determining CopyLocal is the Private metadata on all primary references. Each reference (primary or dependency) has a list of all primary references (source items) that have contributed to that reference being added to the closure.
-
- 1. If none of the source items specify `Private` metadata, `CopyLocal` is set to `True` (or not set, which defaults to `True`)
- 2. If any of the source items specify `Private=true`, `CopyLocal` is set to `True`
- 3. If none of the source assemblies specify `Private=true` and at least one specifies `Private=false`, `CopyLocal` is set to `False`
-
-Here's the source code:
-https://github.com/dotnet/msbuild/blob/main/src/Tasks/AssemblyDependency/Reference.cs#L1243
-
-## Which reference set Private to false?
-
-The last point is an often used reason for CopyLocal being set to false:
-`This reference is not "CopyLocal" because at least one source item had "Private" set to "false" and no source items had "Private" set to "true".`
-
-Unfortunately MSBuild doesn't tell us _which_ reference has set Private to false. I've filed an issue on MSBuild to improve logging: https://github.com/dotnet/msbuild/issues/1485
-
-For now, MSBuildStructuredLog offers an enhancement. It adds Private metadata to the items that had it specified above:
-![image](https://cloud.githubusercontent.com/assets/679326/21278154/733b5f80-c38e-11e6-9eda-ef213b0e233c.png)
-
-This greatly simplifies investigations and tells you exactly which reference caused the dependency in question to be CopyLocal=false.
-
-Here's a special analyzer that was added to MSBuild Structured Log Viewer to add this information:
-https://github.com/KirillOsenkov/MSBuildStructuredLog/blob/65f57afb858280effd4b56c59ef8d78de861241d/src/StructuredLogViewer/Analyzers/ResolveAssemblyReferenceAnalyzer/CopyLocalAnalyzer.cs
-
-## GAC
-The Global Assembly Cache plays an important role in determining whether to copy references to output. This is unfortunate because the GAC contents is machine specific and this results in problems for reproducible builds (where the behavior differs on different machine dependent on machine state, such as the GAC).
-
-There were recent fixes made to RAR to alleviate the situation. You can control the behavior by these two new inputs to RAR:
-
-```
-    CopyLocalDependenciesWhenParentReferenceInGac="$(CopyLocalDependenciesWhenParentReferenceInGac)"
-    DoNotCopyLocalIfInGac="$(DoNotCopyLocalIfInGac)"
-```
-
-## AssemblySearchPaths
-There are two ways to customize the list of paths RAR will search in attempting to locate an assembly. To fully customize the list, the property `AssemblySearchPaths` can be set ahead of time. Note that the order matters; if an assembly is in two locations, RAR will stop after it finds it at the first location.
-
-By default, there are ten locations RAR will search (four if using the .NET SDK), and each can be disabled by setting the relevant flag to false:
-1. Searching files from the current project is disabled by setting the `AssemblySearchPath_UseCandidateAssemblyFiles` property to false.
-2. Searching the reference path property (from a .user file) is disabled by setting the `AssemblySearchPath_UseReferencePath` property to false.
-3. Using the hint path from the item is disabled by setting the `AssemblySearchPath_UseHintPathFromItem` property to false.
-4. Using the directory with MSBuild's target runtime is disabled by setting the `AssemblySearchPath_UseTargetFrameworkDirectory` property to false.
-5. Searching assembly folders from AssemblyFolders.config is disabled by setting the `AssemblySearchPath_UseAssemblyFoldersConfigFileSearchPath` property to false.
-6. Searching the registry is disabled by setting the `AssemblySearchPath_UseRegistry` property to false.
-7. Searching legacy registered assembly folders is disabled by setting the `AssemblySearchPath_UseAssemblyFolders` property to false.
-8. Looking in the GAC is disabled by setting the `AssemblySearchPath_UseGAC` property to false.
-9. Treating the reference's Include as a real file name is disabled by setting the `AssemblySearchPath_UseRawFileName` property to false.
-10. Checking the application's output folder is disabled by setting the `AssemblySearchPath_UseOutDir` property to false.
-
-## There was a conflict
-
-A common situation is MSBuild gives a warning about different versions of the same assembly being used by different references. The solution often involves adding a binding redirect to the app.config file.
-
-A useful way to investigate these conflicts is to search in MSBuild Structured Log Viewer for "There was a conflict". It will show you detailed information about which references needed which versions of the assembly in question.
diff --git a/documentation/wiki/Something's-wrong-in-my-build.md b/documentation/wiki/Something's-wrong-in-my-build.md
deleted file mode 100644
index c9073d37e9c..00000000000
--- a/documentation/wiki/Something's-wrong-in-my-build.md
+++ /dev/null
@@ -1,34 +0,0 @@
-📝 This is incomplete, put here in the spirit of "something is better than nothing".
-
-## Debugging Issues With a Build
-
-To debug a tricky problem with your build, try these tools in order:
-
-1. Diagnostic-level logs show you project state changes and inputs to all tasks
-2. The MSBuild preprocessor `msbuild /pp:out.xml` shows you the full logic of the project in a single file (so you can easily grep around for "what uses this property?" and "where is this target defined?")
-3. Add a target to debug project state of specific interest at specific times:
-```xml
-<Target Name="PrintfDebugger" BeforeTargets="Something">
-  <Message Importance="High" Text="PropOfInterest: $(PropOfInterest)" />
-  <Message Importance="High" Text="ItemOfInterest: @(ItemOfInterest)" />
-</Target>
-```
-
-## "Unable to locate the .NET Core SDK"
-When building via Visual Studio or the command line, you may encounter an error resembling:
-```
-error : Unable to locate the .NET Core SDK. Check that it is installed and that the version specified in global.json (if any) matches the installed version.
-error MSB4236: The SDK 'Microsoft.NET.Sdk' specified could not be found.
-```
-It's possible that this is because MSBuild is using a .NET Core SDK preview. Users on release versions of Visual Studio must opt into using these previews.
-
-First, verify the `global.json` file in your repository is using a preview version of .NET Core SDK such as `"3.0.100-preview5-011568"`. Next, open Visual Studio and navigate to Tools -> Options -> Preview Features and check the `Use previews of the .NET Core SDK` box.
-
-![](https://user-images.githubusercontent.com/3347530/59614580-a795c900-90e6-11e9-8981-0fdbd08d42bd.png)
-
-## Tools
-Many debugging tools listed [here](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/MSBuild-Resources.md#tools).
-
-[MSBuildStructuredLog](https://github.com/KirillOsenkov/MSBuildStructuredLog) can be used to get a clearer idea of what's going on in your build. MSBuildStructuredLog is graphical interface over MSBuild binary logs that visualizes a structured representation of executed targets, tasks, properties, and item values. It can be easier to look though than the diagnostic log.
-
-![](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/Screenshot1.png)
diff --git a/documentation/wiki/Target-Maps.md b/documentation/wiki/Target-Maps.md
deleted file mode 100644
index 722b28119c6..00000000000
--- a/documentation/wiki/Target-Maps.md
+++ /dev/null
@@ -1,4 +0,0 @@
-[Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/BuildTargets.png)
-![Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/BuildTargets.png)
-[Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/CompileTargets.png)
-![Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/CompileTargets.png)
\ No newline at end of file
diff --git a/documentation/wiki/TestExplorerEnvironments.png b/documentation/wiki/TestExplorerEnvironments.png
deleted file mode 100644
index 36a852dda07..00000000000
Binary files a/documentation/wiki/TestExplorerEnvironments.png and /dev/null differ
diff --git a/documentation/wiki/UnGAC.md b/documentation/wiki/UnGAC.md
deleted file mode 100644
index a5b796f3edd..00000000000
--- a/documentation/wiki/UnGAC.md
+++ /dev/null
@@ -1,34 +0,0 @@
-# MSBuild, the Global Assembly Cache (GAC), and You
-
-## What is the GAC?
-
-See the [public documentation](https://learn.microsoft.com/dotnet/framework/app-domains/gac). The GAC is a folder where different installations of VS on the same machine look for assemblies that are commonly used. If an assembly is in the GAC, it will be prioritized over any other assembly.
-
-The only MSBuild assemblies you may see in the GAC are version 4.8. There is no reason any modern (15.1+) MSBuild assembly should be in the GAC today.
-
-## What MSBuild Assemblies are installed on my Machine?
-Run the [EnumerateMSBuild powershell script](https://github.com/dotnet/msbuild/blob/main/scripts/EnumerateMSBuild.ps1) from our repo. It will output a `msbuild_versions.txt` file that lists MSBuild assemblies in their common folders along with their versions.
-
-## How to Remove MSBuild Assemblies from the GAC
-1. If on Visual Studio 16.8 or higher, repair your installation.
-2. Run these commands on a developer command prompt with admin privileges. Match the versions as necessary.
-    ```
-    gacutil /u "MSBuild, Version=15.1.0.0"
-    gacutil /u "Microsoft.Build.Conversion.Core, Version=15.1.0.0"
-    gacutil /u "Microsoft.Build, Version=15.1.0.0"
-    gacutil /u "Microsoft.Build.Engine, Version=15.1.0.0"
-    gacutil /u "Microsoft.Build.Tasks.Core, Version=15.1.0.0"
-    gacutil /u "Microsoft.Build.Utilities.Core, Version=15.1.0.0"
-    gacutil /u "Microsoft.Build.Framework, Version=15.1.0.0"
-    ```
-3. If you want to do this 'safely', move the folder out of the GAC and return it if it doesn't resolve the issue.
-
-## Related GAC issues
-https://developercommunity.visualstudio.com/content/problem/311136/update-to-1580-projects-wont-load.html
-
-https://developercommunity.visualstudio.com/content/problem/953754/after-update-to-1650-no-longer-able-to-loadcreate.html
-
-https://developercommunity.visualstudio.com/content/problem/208631/unable-to-create-or-open-solution.html
-
-## Other assemblies
-We have an issue [tracking other assemblies](https://github.com/dotnet/msbuild/issues/5955) that can cause problems when in the GAC. If one of these assemblies is causing issues for you, refer to [How to Remove MSBuild Assemblies from the GAC](#how-to-remove-msbuild-assemblies-from-the-gac) while changing the assembly name and version.
