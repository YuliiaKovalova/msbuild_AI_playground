diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index e340aaacdc6..6514cf47d46 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -192,7 +192,7 @@ private void SimpleP2PBuild(BuildParameters buildParameters)
                 buildParameters,
                 new BuildRequestData(
                     graph.GraphRoots.FirstOrDefault()
-                        .ProjectInstance.FullPath,
+                        .ProjectInstanceSnapshot.FullPath,
                     new Dictionary<string, string>(),
                     MSBuildConstants.CurrentToolsVersion,
                     Array.Empty<string>(),
@@ -4197,11 +4197,11 @@ public void GraphBuildValid()
             GraphBuildResult result = _buildManager.Build(_parameters, data);
             result.OverallResult.ShouldBe(BuildResultCode.Success);
 
-            var node1 = graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.Equals(project1, StringComparison.OrdinalIgnoreCase));
+            var node1 = graph.ProjectNodes.First(node => node.ProjectInstanceSnapshot.FullPath.Equals(project1, StringComparison.OrdinalIgnoreCase));
             result.ResultsByNode.ContainsKey(node1).ShouldBeTrue();
             result.ResultsByNode[node1].OverallResult.ShouldBe(BuildResultCode.Success);
 
-            var node2 = graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.Equals(project2, StringComparison.OrdinalIgnoreCase));
+            var node2 = graph.ProjectNodes.First(node => node.ProjectInstanceSnapshot.FullPath.Equals(project2, StringComparison.OrdinalIgnoreCase));
             result.ResultsByNode.ContainsKey(node2).ShouldBeTrue();
             result.ResultsByNode[node2].OverallResult.ShouldBe(BuildResultCode.Success);
         }
@@ -4282,11 +4282,11 @@ public void GraphBuildFail()
             GraphBuildResult result = _buildManager.Build(_parameters, data);
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
 
-            var node1 = graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.Equals(project1, StringComparison.OrdinalIgnoreCase));
+            var node1 = graph.ProjectNodes.First(node => node.ProjectInstanceSnapshot.FullPath.Equals(project1, StringComparison.OrdinalIgnoreCase));
             result.ResultsByNode.ContainsKey(node1).ShouldBeTrue();
             result.ResultsByNode[node1].OverallResult.ShouldBe(BuildResultCode.Failure);
 
-            var node2 = graph.ProjectNodes.First(node => node.ProjectInstance.FullPath.Equals(project2, StringComparison.OrdinalIgnoreCase));
+            var node2 = graph.ProjectNodes.First(node => node.ProjectInstanceSnapshot.FullPath.Equals(project2, StringComparison.OrdinalIgnoreCase));
             result.ResultsByNode.ContainsKey(node2).ShouldBeTrue();
             result.ResultsByNode[node2].OverallResult.ShouldBe(BuildResultCode.Failure);
         }
@@ -4339,7 +4339,7 @@ public void GraphBuildShouldBeAbleToConstructGraphButSkipBuild()
             {
                 var graphResult = buildSession.BuildGraphSubmission(
                     new GraphBuildRequestData(
-                        projectGraphEntryPoints: new[] { new ProjectGraphEntryPoint(graph.GraphRoots.First().ProjectInstance.FullPath) },
+                        projectGraphEntryPoints: new[] { new ProjectGraphEntryPoint(graph.GraphRoots.First().ProjectInstanceSnapshot.FullPath) },
                         targetsToBuild: Array.Empty<string>(),
                         hostServices: null,
                         flags: BuildRequestDataFlags.None,
diff --git a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
index 400c3f6af52..b80e9ffd560 100644
--- a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
@@ -128,7 +128,7 @@ public void SolutionFilterFiltersProjects(bool graphBuild)
                     ProjectGraph graphFromSolution = new(entryPoint, projectCollection);
                     logger.AssertNoErrors();
                     graphFromSolution.ProjectNodes.ShouldHaveSingleItem();
-                    graphFromSolution.ProjectNodes.Single().ProjectInstance.ProjectFileLocation.LocationString.ShouldBe(simpleProject.Path);
+                    graphFromSolution.ProjectNodes.Single().ProjectInstanceSnapshot.ProjectFileLocation.LocationString.ShouldBe(simpleProject.Path);
                 }
                 else
                 {
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
index b941649ad74..f1556761eb9 100644
--- a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -57,7 +57,7 @@ public void ValidateGlobalPropertyCopyByValueNotReference()
                                                     </Project>");
 
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
-                GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+                GetFirstNodeWithProjectNumber(graph, 1).ProjectInstanceSnapshot.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
             }
         }
 
@@ -97,8 +97,8 @@ public void ValidateSetPlatformOverride()
 
 
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
-                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x86");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x86");
             }
         }
 
@@ -139,8 +139,8 @@ public void ValidateNegotiationOverride()
 
 
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
-                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstanceSnapshot.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x86");
             }
         }
 
@@ -179,8 +179,8 @@ public void ResolvesMultipleReferencesToSameProject()
 
 
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
-                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("AnyCPU");
                 graph.ProjectNodes.Count.ShouldBe(3);
             }
         }
@@ -208,7 +208,7 @@ public void ResolvesViaPlatformLookupTable()
                                                     </Project>");
 
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x64");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x64");
             }
         }
 
@@ -236,7 +236,7 @@ public void ResolvesViaProjectReferencesPlatformLookupTable()
                                                     </Project>");
 
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x86");
             }
         }
 
@@ -263,7 +263,7 @@ public void ResolvesViaAnyCPUDefault()
                                                     </Project>");
 
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("AnyCPU");
             }
         }
 
@@ -291,7 +291,7 @@ public void ResolvesViaSamePlatform()
                                                     </Project>");
 
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x86");
             }
         }
 
@@ -321,7 +321,7 @@ public void FailsToResolve()
                 // Here we are checking if platform is defined. in this case it should not be since Platorm would be set to the value this project defaults as
                 // in order to avoid dual build errors we remove platform in order to avoid the edge case where a project has global platform set and does not have global platform set
                 // yet still default to the same platform.
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstanceSnapshot.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
             }
         }
 
@@ -348,7 +348,7 @@ public void PlatformIsChosenAsDefault()
                                                     </Project>");
 
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GetPropertyValue("Platform").ShouldBe(GetFirstNodeWithProjectNumber(graph, 1).ProjectInstance.GetPropertyValue("Platform"));
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstanceSnapshot.GetPropertyValue("Platform").ShouldBe(GetFirstNodeWithProjectNumber(graph, 1).ProjectInstanceSnapshot.GetPropertyValue("Platform"));
             }
         }
 
@@ -444,8 +444,8 @@ public void SolutionWithoutAllConfigurations()
                 // We want to make sure negotiation respects configuration if defined but negotiates if not.
                 ProjectGraph graphFromSolution = new(entryPoint, projectCollection);
                 logger.AssertNoErrors();
-                GetFirstNodeWithProjectNumber(graphFromSolution, 2).ProjectInstance.GetPropertyValue("Platform").ShouldBe("AnyCPU", "Project2 should have followed the sln config to AnyCPU");
-                GetFirstNodeWithProjectNumber(graphFromSolution, 3).ProjectInstance.GetPropertyValue("Platform").ShouldBe("x64", "Project3 isn't in the solution so it should have negotiated to x64 to match Project1");
+                GetFirstNodeWithProjectNumber(graphFromSolution, 2).ProjectInstanceSnapshot.GetPropertyValue("Platform").ShouldBe("AnyCPU", "Project2 should have followed the sln config to AnyCPU");
+                GetFirstNodeWithProjectNumber(graphFromSolution, 3).ProjectInstanceSnapshot.GetPropertyValue("Platform").ShouldBe("x64", "Project3 isn't in the solution so it should have negotiated to x64 to match Project1");
             }
         }
     }
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 431ea412875..30839e4a1d8 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -635,12 +635,12 @@ public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()
             GetInnerBuilds(graph, 3).SelectMany(n => GetIncomingEdgeItemsToNode(n, edges)).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));
             GetInnerBuilds(graph, 3).SelectMany(n => GetOutgoingEdgeItemsFromNode(n, edges)).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));
 
-            IEnumerable<ProjectItemInstance> GetOutgoingEdgeItemsFromNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> edgeInfos)
+            IEnumerable<ProjectItemInstanceSnapshot> GetOutgoingEdgeItemsFromNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstanceSnapshot> edgeInfos)
             {
                 return edgeInfos.Where(e => e.Key.Item1.Equals(node.ToConfigurationMetadata())).Select(e => e.Value);
             }
 
-            IEnumerable<ProjectItemInstance> GetIncomingEdgeItemsToNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> edgeInfos)
+            IEnumerable<ProjectItemInstanceSnapshot> GetIncomingEdgeItemsToNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstanceSnapshot> edgeInfos)
             {
                 return edgeInfos.Where(e => e.Key.Item2.Equals(node.ToConfigurationMetadata())).Select(e => e.Value);
             }
@@ -668,7 +668,7 @@ public void GraphConstructionShouldThrowOnMissingSolutionDependencies()
             exception.Message.ShouldContain("but a project with this GUID was not found in the .SLN file");
         }
 
-        private static bool IsSolutionItemReference(ProjectItemInstance edgeItem)
+        private static bool IsSolutionItemReference(ProjectItemInstanceSnapshot edgeItem)
         {
             return edgeItem.ItemType == GraphBuilder.SolutionItemReference;
         }
@@ -736,12 +736,12 @@ private void AssertSolutionBasedGraph(
 
         private static string GetConfiguration(ProjectGraphNode node)
         {
-            return node.ProjectInstance.GlobalProperties["Configuration"];
+            return node.ProjectInstanceSnapshot.GlobalProperties["Configuration"];
         }
 
         private static string GetPlatform(ProjectGraphNode node)
         {
-            return node.ProjectInstance.GlobalProperties["Platform"];
+            return node.ProjectInstanceSnapshot.GlobalProperties["Platform"];
         }
 
         public void Dispose()
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index 6b415681733..96fca8713e2 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -54,18 +54,18 @@ public static void AssertOuterBuild(
             {
                 AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
 
-                ProjectItemInstance edge = graph.TestOnly_Edges[(outerBuild, innerBuild)];
+                var edge = graph.TestOnly_Edges[(outerBuild, innerBuild)];
                 edge.DirectMetadataCount.ShouldBe(1);
 
-                string expectedPropertiesMetadata = $"{InnerBuildPropertyName}={innerBuild.ProjectInstance.GlobalProperties[InnerBuildPropertyName]}";
-                edge.GetMetadata("Properties").EvaluatedValue.ShouldBe(expectedPropertiesMetadata);
+                string expectedPropertiesMetadata = $"{InnerBuildPropertyName}={innerBuild.ProjectInstanceSnapshot.GlobalProperties[InnerBuildPropertyName]}";
+                edge.GetMetadataValue("Properties").ShouldBe(expectedPropertiesMetadata);
             }
 
             // Ensure edges were added directly to the inner builds
             foreach (ProjectGraphNode outerBuildReferencer in outerBuild.ReferencingProjects)
             {
                 ProjectGraphNode[] innerBuilds = outerBuildReferencer.ProjectReferences
-                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath)
+                    .Where(p => IsInnerBuild(p) && p.ProjectInstanceSnapshot.FullPath == outerBuild.ProjectInstanceSnapshot.FullPath)
                     .ToArray();
 
                 innerBuilds.Length.ShouldBe(expectedInnerBuildCount);
@@ -79,8 +79,8 @@ public static void AssertOuterBuild(
 
                     graph.TestOnly_Edges.HasEdge((outerBuild, innerBuild)).ShouldBeTrue();
 
-                    ProjectItemInstance edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
-                    ProjectItemInstance edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
+                    var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
+                    var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
 
                     edgeToOuterBuild.ShouldBe(edgeToInnerBuild);
                 }
@@ -92,8 +92,8 @@ public static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary
             additionalGlobalProperties ??= new Dictionary<string, string>();
 
             IsNotMultitargeting(node).ShouldBeTrue();
-            node.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
-            node.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
+            node.ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+            node.ProjectInstanceSnapshot.GetPropertyValue(InnerBuildPropertyName).ShouldBeNullOrEmpty();
         }
 
         public static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)
@@ -103,8 +103,8 @@ public static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dicti
             IsOuterBuild(outerBuild).ShouldBeTrue();
             IsInnerBuild(outerBuild).ShouldBeFalse();
 
-            outerBuild.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
-            outerBuild.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+            outerBuild.ProjectInstanceSnapshot.GetPropertyValue(InnerBuildPropertyName).ShouldBeNullOrEmpty();
+            outerBuild.ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
         }
 
         public static void AssertInnerBuildEvaluation(
@@ -117,13 +117,13 @@ public static void AssertInnerBuildEvaluation(
             IsOuterBuild(innerBuild).ShouldBeFalse();
             IsInnerBuild(innerBuild).ShouldBeTrue();
 
-            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildPropertyName);
+            var innerBuildPropertyValue = innerBuild.ProjectInstanceSnapshot.GetPropertyValue(InnerBuildPropertyName);
 
             innerBuildPropertyValue.ShouldNotBeNullOrEmpty();
 
             if (InnerBuildPropertyIsSetViaGlobalProperty)
             {
-                innerBuild.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(
+                innerBuild.ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(
                     EmptyGlobalProperties
                         .Add(InnerBuildPropertyName, innerBuildPropertyValue)
                         .AddRange(additionalGlobalProperties));
@@ -132,17 +132,17 @@ public static void AssertInnerBuildEvaluation(
 
         internal static bool IsOuterBuild(ProjectGraphNode project)
         {
-            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;
+            return project.ProjectInstanceSnapshot.ProjectType == ProjectInterpretation.ProjectType.OuterBuild;
         }
 
         internal static bool IsInnerBuild(ProjectGraphNode project)
         {
-            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;
+            return project.ProjectInstanceSnapshot.ProjectType == ProjectInterpretation.ProjectType.InnerBuild;
         }
 
         internal static bool IsNotMultitargeting(ProjectGraphNode project)
         {
-            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;
+            return project.ProjectInstanceSnapshot.ProjectType == ProjectInterpretation.ProjectType.NonMultitargeting;
         }
 
         internal static ProjectGraphNode GetFirstNodeWithProjectNumber(ProjectGraph graph, int projectNum)
@@ -152,7 +152,7 @@ internal static ProjectGraphNode GetFirstNodeWithProjectNumber(ProjectGraph grap
 
         internal static IEnumerable<ProjectGraphNode> GetNodesWithProjectNumber(ProjectGraph graph, int projectNum)
         {
-            return graph.ProjectNodes.Where(node => node.ProjectInstance.FullPath.EndsWith(projectNum + ".proj"));
+            return graph.ProjectNodes.Where(node => node.ProjectInstanceSnapshot.FullPath.EndsWith(projectNum + ".proj"));
         }
 
         internal static ProjectGraphNode GetOuterBuild(ProjectGraph graph, int projectNumber)
@@ -171,7 +171,7 @@ internal static IReadOnlyCollection<ProjectGraphNode> GetInnerBuilds(ProjectGrap
             else
             {
                 var innerBuilds = GetNodesWithProjectNumber(graph, projectNumber)
-                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath.Equals(outerBuild.ProjectInstance.FullPath))
+                    .Where(p => IsInnerBuild(p) && p.ProjectInstanceSnapshot.FullPath.Equals(outerBuild.ProjectInstanceSnapshot.FullPath))
                     .ToArray();
 
                 innerBuilds.ShouldNotBeEmpty();
@@ -183,7 +183,7 @@ internal static IReadOnlyCollection<ProjectGraphNode> GetInnerBuilds(ProjectGrap
         internal static string GetProjectFileName(ProjectGraphNode node)
         {
             node.ShouldNotBeNull();
-            return Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);
+            return Path.GetFileNameWithoutExtension(node.ProjectInstanceSnapshot.FullPath);
         }
 
         internal static string GetProjectFileName(ConfigurationMetadata config)
@@ -207,7 +207,7 @@ internal static int GetProjectNumber(ConfigurationMetadata config)
         internal static string GetProjectPath(ProjectGraphNode node)
         {
             node.ShouldNotBeNull();
-            return node.ProjectInstance.FullPath;
+            return node.ProjectInstanceSnapshot.FullPath;
         }
 
         internal static TransientTestFile CreateProjectFile(
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 932c3c8e439..019a00de96d 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -63,7 +63,7 @@ public void ConstructWithSingleNode()
                 TransientTestFile entryProject = CreateProjectFile(env, 1);
                 var projectGraph = new ProjectGraph(entryProject.Path);
                 projectGraph.ProjectNodes.Count.ShouldBe(1);
-                projectGraph.ProjectNodes.First().ProjectInstance.FullPath.ShouldBe(entryProject.Path);
+                projectGraph.ProjectNodes.First().ProjectInstanceSnapshot.FullPath.ShouldBe(entryProject.Path);
             }
         }
 
@@ -113,7 +113,7 @@ public void ConstructWithSingleNodeWithProjectInstanceFactory()
                             projectCollection);
                     });
                 projectGraph.ProjectNodes.Count.ShouldBe(1);
-                projectGraph.ProjectNodes.First().ProjectInstance.FullPath.ShouldBe(entryProject.Path);
+                projectGraph.ProjectNodes.First().ProjectInstanceSnapshot.FullPath.ShouldBe(entryProject.Path);
                 factoryCalled.ShouldBeTrue();
             }
         }
@@ -121,7 +121,7 @@ public void ConstructWithSingleNodeWithProjectInstanceFactory()
         [Fact]
         public void ProjectGraphNodeConstructorNoNullArguments()
         {
-            Assert.Throws<InternalErrorException>(() => new ProjectGraphNode(null));
+            Assert.Throws<InternalErrorException>(() => new ProjectGraphNode(null, false));
         }
 
         [Fact]
@@ -130,12 +130,12 @@ public void UpdatingReferencesIsBidirectional()
             using (var env = TestEnvironment.Create())
             {
                 var projectInstance = new Project().CreateProjectInstance();
-                var node = new ProjectGraphNode(projectInstance);
-                var reference1 = new ProjectGraphNode(projectInstance);
-                var referenceItem1 = new ProjectItemInstance(projectInstance, "Ref1", "path1", "file1");
+                var node = new ProjectGraphNode(projectInstance, false);
+                var reference1 = new ProjectGraphNode(projectInstance, false);
+                var referenceItem1 = new ProjectItemInstanceSnapshot(new ProjectItemInstance(projectInstance, "Ref1", "path1", "file1"));
 
-                var reference2 = new ProjectGraphNode(projectInstance);
-                var referenceItem2 = new ProjectItemInstance(projectInstance, "Ref2", "path2", "file2");
+                var reference2 = new ProjectGraphNode(projectInstance, false);
+                var referenceItem2 = new ProjectItemInstanceSnapshot(new ProjectItemInstance(projectInstance, "Ref2", "path2", "file2"));
 
                 var edges = new GraphBuilder.GraphEdges();
 
@@ -177,10 +177,10 @@ public void FirstEdgeWinsWhenMultipleEdgesPointToSameReference()
             using (var env = TestEnvironment.Create())
             {
                 var projectInstance = new Project().CreateProjectInstance();
-                var node = new ProjectGraphNode(projectInstance);
-                var reference1 = new ProjectGraphNode(projectInstance);
-                var referenceItem1 = new ProjectItemInstance(projectInstance, "Ref1", "path1", "file1");
-                var referenceItem2 = new ProjectItemInstance(projectInstance, "Ref2", "path1", "file1");
+                var node = new ProjectGraphNode(projectInstance, false);
+                var reference1 = new ProjectGraphNode(projectInstance, false);
+                var referenceItem1 = new ProjectItemInstanceSnapshot(new ProjectItemInstance(projectInstance, "Ref1", "path1", "file1"));
+                var referenceItem2 = new ProjectItemInstanceSnapshot(new ProjectItemInstance(projectInstance, "Ref2", "path1", "file1"));
 
                 var edges = new GraphBuilder.GraphEdges();
 
@@ -367,16 +367,16 @@ public void ProjectCollectionShouldNotInfluenceGlobalProperties()
             var root1 = GetFirstNodeWithProjectNumber(graph, 1);
             var globalPropertiesFor1 = new Dictionary<string, string> { ["B"] = "EntryPointB", ["C"] = "EntryPointC", ["IsGraphBuild"] = "true" };
 
-            root1.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
-            root1.ProjectReferences.First(r => GetProjectNumber(r) == 3).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
-            root1.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
+            root1.ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
+            root1.ProjectReferences.First(r => GetProjectNumber(r) == 3).ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
+            root1.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor1);
 
             var root2 = GetFirstNodeWithProjectNumber(graph, 2);
             var globalPropertiesFor2 = new Dictionary<string, string> { ["IsGraphBuild"] = "true" };
 
-            root2.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
-            root2.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
-            root2.ProjectReferences.First(r => GetProjectNumber(r) == 5).ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
+            root2.ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
+            root2.ProjectReferences.First(r => GetProjectNumber(r) == 4).ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
+            root2.ProjectReferences.First(r => GetProjectNumber(r) == 5).ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(globalPropertiesFor2);
         }
 
         [Fact]
@@ -405,10 +405,10 @@ public void ConstructWithDifferentGlobalProperties()
 
                 // Projects 2 and 3 both reference project 4, but with different properties, so they should not point to the same node.
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ShouldNotBe(GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First());
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties);
-                GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("4.proj");
-                GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstance.GlobalProperties.Count.ShouldBeGreaterThan(1);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstanceSnapshot.FullPath.ShouldEndWith("4.proj");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties);
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstanceSnapshot.FullPath.ShouldEndWith("4.proj");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First().ProjectInstanceSnapshot.GlobalProperties.Count.ShouldBeGreaterThan(1);
             }
         }
 
@@ -427,7 +427,7 @@ public void TestGlobalPropertiesInProjectReferences()
                 CreateProjectFile(env, 3);
                 ProjectGraph graph = new ProjectGraph(entryProject.Path);
                 graph.ProjectNodes.Count.ShouldBe(3);
-                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["A"].ShouldBe("B");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstanceSnapshot.GlobalProperties["A"].ShouldBe("B");
             }
         }
 
@@ -534,13 +534,13 @@ public void ConstructWithCaseDifferences()
 
                 // Property names are case-insensitive, so projects 2 and 3 point to the same project 5 node.
                 GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ShouldBe(GetFirstNodeWithProjectNumber(graph, 3).ProjectReferences.First());
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("5.proj");
-                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstance.GlobalProperties["FoO"].ShouldBe("bar");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstanceSnapshot.FullPath.ShouldEndWith("5.proj");
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First().ProjectInstanceSnapshot.GlobalProperties["FoO"].ShouldBe("bar");
 
                 // Property values are case-sensitive, so project 4 points to a different project 5 node than proejcts 2 and 3
                 GetFirstNodeWithProjectNumber(graph, 4).ProjectReferences.First().ShouldNotBe(GetFirstNodeWithProjectNumber(graph, 2).ProjectReferences.First());
-                GetFirstNodeWithProjectNumber(graph, 4).ProjectReferences.First().ProjectInstance.FullPath.ShouldEndWith("5.proj");
-                GetFirstNodeWithProjectNumber(graph, 4).ProjectReferences.First().ProjectInstance.GlobalProperties["FoO"].ShouldBe("BAR");
+                GetFirstNodeWithProjectNumber(graph, 4).ProjectReferences.First().ProjectInstanceSnapshot.FullPath.ShouldEndWith("5.proj");
+                GetFirstNodeWithProjectNumber(graph, 4).ProjectReferences.First().ProjectInstanceSnapshot.GlobalProperties["FoO"].ShouldBe("BAR");
             }
         }
 
@@ -606,17 +606,17 @@ public void ConstructWithMultipleEntryPointsWithDifferentGlobalProperties()
 
                 // The entry points should not be the same node, but should point to the same project
                 entryPointNode1.ShouldNotBe(entryPointNode2);
-                entryPointNode1.ProjectInstance.FullPath.ShouldBe(entryPointNode2.ProjectInstance.FullPath);
-                entryPointNode1.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
-                entryPointNode2.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x64");
+                entryPointNode1.ProjectInstanceSnapshot.FullPath.ShouldBe(entryPointNode2.ProjectInstanceSnapshot.FullPath);
+                entryPointNode1.ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x86");
+                entryPointNode2.ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x64");
 
                 // The entry points should not have the same project reference, but should point to the same project reference file
                 entryPointNode1.ProjectReferences.Count.ShouldBe(1);
                 entryPointNode2.ProjectReferences.Count.ShouldBe(1);
                 entryPointNode1.ProjectReferences.First().ShouldNotBe(entryPointNode2.ProjectReferences.First());
-                entryPointNode1.ProjectReferences.First().ProjectInstance.FullPath.ShouldBe(entryPointNode2.ProjectReferences.First().ProjectInstance.FullPath);
-                entryPointNode1.ProjectReferences.First().ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
-                entryPointNode2.ProjectReferences.First().ProjectInstance.GlobalProperties["Platform"].ShouldBe("x64");
+                entryPointNode1.ProjectReferences.First().ProjectInstanceSnapshot.FullPath.ShouldBe(entryPointNode2.ProjectReferences.First().ProjectInstanceSnapshot.FullPath);
+                entryPointNode1.ProjectReferences.First().ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x86");
+                entryPointNode2.ProjectReferences.First().ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x64");
             }
         }
 
@@ -645,15 +645,15 @@ public void ConstructWithMultipleEntryPointsWithDifferentGlobalPropertiesConverg
 
                 // The entry points should not be the same node, but should point to the same project
                 entryPointNode1.ShouldNotBe(entryPointNode2);
-                entryPointNode1.ProjectInstance.FullPath.ShouldBe(entryPointNode2.ProjectInstance.FullPath);
-                entryPointNode1.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
-                entryPointNode2.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x64");
+                entryPointNode1.ProjectInstanceSnapshot.FullPath.ShouldBe(entryPointNode2.ProjectInstanceSnapshot.FullPath);
+                entryPointNode1.ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x86");
+                entryPointNode2.ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x64");
 
                 // The entry points should have the same project reference since they're platform-agnostic
                 entryPointNode1.ProjectReferences.Count.ShouldBe(1);
                 entryPointNode2.ProjectReferences.Count.ShouldBe(1);
                 entryPointNode1.ProjectReferences.First().ShouldBe(entryPointNode2.ProjectReferences.First());
-                entryPointNode1.ProjectReferences.First().ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+                entryPointNode1.ProjectReferences.First().ProjectInstanceSnapshot.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
             }
         }
 
@@ -797,34 +797,34 @@ public void ConstructGraphWithSolution()
                 var projectGraph = new ProjectGraph(slnFile.Path);
                 projectGraph.EntryPointNodes.Count.ShouldBe(3);
                 projectGraph.GraphRoots.Count.ShouldBe(1);
-                projectGraph.GraphRoots.First().ProjectInstance.FullPath.ShouldBe(project1Path);
+                projectGraph.GraphRoots.First().ProjectInstanceSnapshot.FullPath.ShouldBe(project1Path);
                 projectGraph.ProjectNodes.Count.ShouldBe(5);
 
-                ProjectGraphNode project1Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project1Path);
-                project1Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
-                project1Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("x86");
+                ProjectGraphNode project1Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstanceSnapshot.FullPath == project1Path);
+                project1Node.ProjectInstanceSnapshot.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project1Node.ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("x86");
                 project1Node.ProjectReferences.Count.ShouldBe(2);
 
-                ProjectGraphNode project2Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project2Path);
-                project2Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
-                project2Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                ProjectGraphNode project2Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstanceSnapshot.FullPath == project2Path);
+                project2Node.ProjectInstanceSnapshot.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project2Node.ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("Win32");
                 project2Node.ProjectReferences.Count.ShouldBe(1);
 
-                ProjectGraphNode project3Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project3Path);
-                project3Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
-                project3Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                ProjectGraphNode project3Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstanceSnapshot.FullPath == project3Path);
+                project3Node.ProjectInstanceSnapshot.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project3Node.ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("Win32");
                 project3Node.ProjectReferences.Count.ShouldBe(1);
 
                 // Configuration and Platform get unset
-                ProjectGraphNode project4Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project4Path);
-                project4Node.ProjectInstance.GlobalProperties.ContainsKey("Configuration").ShouldBeFalse();
-                project4Node.ProjectInstance.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
+                ProjectGraphNode project4Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstanceSnapshot.FullPath == project4Path);
+                project4Node.ProjectInstanceSnapshot.GlobalProperties.ContainsKey("Configuration").ShouldBeFalse();
+                project4Node.ProjectInstanceSnapshot.GlobalProperties.ContainsKey("Platform").ShouldBeFalse();
                 project4Node.ProjectReferences.Count.ShouldBe(0);
 
                 // Configuration and Platform are inherited from the referencing project
-                ProjectGraphNode project5Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstance.FullPath == project5Path);
-                project5Node.ProjectInstance.GlobalProperties["Configuration"].ShouldBe("Debug");
-                project5Node.ProjectInstance.GlobalProperties["Platform"].ShouldBe("Win32");
+                ProjectGraphNode project5Node = projectGraph.ProjectNodes.Single(node => node.ProjectInstanceSnapshot.FullPath == project5Path);
+                project5Node.ProjectInstanceSnapshot.GlobalProperties["Configuration"].ShouldBe("Debug");
+                project5Node.ProjectInstanceSnapshot.GlobalProperties["Platform"].ShouldBe("Win32");
                 project5Node.ProjectReferences.Count.ShouldBe(0);
             }
         }
@@ -1775,7 +1775,7 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
                 var targets = string.Join(".*", targetsPerNode[node]);
                 targets.ShouldNotBeNullOrEmpty();
 
-                foreach (var globalProperty in node.ProjectInstance.GlobalProperties)
+                foreach (var globalProperty in node.ProjectInstanceSnapshot.GlobalProperties)
                 {
                     dot.ShouldMatch($@"{nodeId}\s*\[.*{targets}.*{globalProperty.Key}.*{globalProperty.Value}.*\]");
                 }
@@ -2020,16 +2020,16 @@ public void InnerBuildsCanHaveSeparateReferences()
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 5));
 
-            var innerBuildWithCommonReferences = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GlobalProperties.TryGetValue(InnerBuildPropertyName, out string p) && p == "a");
+            var innerBuildWithCommonReferences = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstanceSnapshot.GlobalProperties.TryGetValue(InnerBuildPropertyName, out string p) && p == "a");
 
             innerBuildWithCommonReferences.ProjectReferences.Count.ShouldBe(4);
-            var referenceNumbersSet = innerBuildWithCommonReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
+            var referenceNumbersSet = innerBuildWithCommonReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstanceSnapshot.FullPath)).ToHashSet();
             referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string> { "2", "3" });
 
-            var innerBuildWithAdditionalReferences = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GlobalProperties.TryGetValue(InnerBuildPropertyName, out string p) && p == "b");
+            var innerBuildWithAdditionalReferences = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstanceSnapshot.GlobalProperties.TryGetValue(InnerBuildPropertyName, out string p) && p == "b");
 
             innerBuildWithAdditionalReferences.ProjectReferences.Count.ShouldBe(8);
-            referenceNumbersSet = innerBuildWithAdditionalReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstance.FullPath)).ToHashSet();
+            referenceNumbersSet = innerBuildWithAdditionalReferences.ProjectReferences.Select(r => Path.GetFileNameWithoutExtension(r.ProjectInstanceSnapshot.FullPath)).ToHashSet();
             referenceNumbersSet.ShouldBeSameIgnoringOrder(new HashSet<string> { "2", "3", "4", "5" });
         }
 
@@ -2058,7 +2058,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
             AssertOuterBuild(outerBuild, graph, additionalGlobalProperties);
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2), additionalGlobalProperties);
 
-            var referencedInnerBuild = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GetPropertyValue(InnerBuildPropertyName) == "a");
+            var referencedInnerBuild = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstanceSnapshot.GetPropertyValue(InnerBuildPropertyName) == "a");
 
             var two = GetFirstNodeWithProjectNumber(graph, 2);
 
@@ -2135,7 +2135,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
 
             AssertOuterBuild(outerBuild1, graph, additionalGlobalProperties);
 
-            var innerBuild1WithReferenceToInnerBuild2 = outerBuild1.ProjectReferences.FirstOrDefault(n => IsInnerBuild(n) && n.ProjectInstance.GlobalProperties[InnerBuildPropertyName] == "a");
+            var innerBuild1WithReferenceToInnerBuild2 = outerBuild1.ProjectReferences.FirstOrDefault(n => IsInnerBuild(n) && n.ProjectInstanceSnapshot.GlobalProperties[InnerBuildPropertyName] == "a");
             innerBuild1WithReferenceToInnerBuild2.ShouldNotBeNull();
 
             var outerBuild2 = GetOuterBuild(graph, 2);
@@ -2144,7 +2144,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
             var innerBuild2 = GetInnerBuilds(graph, 2).FirstOrDefault();
             innerBuild2.ShouldNotBeNull();
 
-            innerBuild2.ProjectInstance.GlobalProperties[InnerBuildPropertyName].ShouldBe("a");
+            innerBuild2.ProjectInstanceSnapshot.GlobalProperties[InnerBuildPropertyName].ShouldBe("a");
 
             // project 2 has two nodes: the outer build and the referenced inner build
             // the outer build is necessary as the referencing inner build can still call targets on it
@@ -2251,7 +2251,7 @@ public void AllNodesShouldHaveGraphBuildGlobalProperty(Dictionary<int, int[]> ed
 
                 foreach (var node in projectGraph.ProjectNodes)
                 {
-                    node.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(expectedGlobalProperties);
+                    node.ProjectInstanceSnapshot.GlobalProperties.ShouldBeSameIgnoringOrder(expectedGlobalProperties);
                 }
             }
         }
@@ -2266,7 +2266,7 @@ public void UserValuesForIsGraphBuildGlobalPropertyShouldBePreserved()
                     new Dictionary<int, int[]> { { 1, null } },
                     new Dictionary<string, string> { { PropertyNames.IsGraphBuild, "xyz" } });
 
-                projectGraph.ProjectNodes.First().ProjectInstance.GlobalProperties[PropertyNames.IsGraphBuild].ShouldBe("xyz");
+                projectGraph.ProjectNodes.First().ProjectInstanceSnapshot.GlobalProperties[PropertyNames.IsGraphBuild].ShouldBe("xyz");
             }
         }
 
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index 65ab4706791..31db235bcd0 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -307,7 +307,7 @@ public void BuildProjectGraphUsingCaches(Dictionary<int, int[]> edges)
             foreach (var node in topoSortedNodes)
             {
                 var project = Project.FromFile(
-                    node.ProjectInstance.FullPath,
+                    node.ProjectInstanceSnapshot.FullPath,
                     new ProjectOptions
                     {
                         ProjectCollection = collection
@@ -347,7 +347,7 @@ public void OutputCacheShouldNotContainInformationFromInputCaches()
 
             BuildUsingCaches(_env, topoSortedNodes, expectedOutput, outputCaches, generateCacheFiles: true);
 
-            var rootNode = topoSortedNodes.First(n => Path.GetFileNameWithoutExtension(n.ProjectInstance.FullPath) == "1");
+            var rootNode = topoSortedNodes.First(n => Path.GetFileNameWithoutExtension(n.ProjectInstanceSnapshot.FullPath) == "1");
             var outputCache = outputCaches[rootNode];
 
             outputCache.ShouldNotBeNull();
@@ -468,10 +468,10 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
                 buildParameters.Loggers = new[] { logger };
 
                 var result = BuildProjectFileUsingBuildManager(
-                    node.ProjectInstance.FullPath,
+                    node.ProjectInstanceSnapshot.FullPath,
                     null,
                     buildParameters,
-                    targetListsPerNode?[node] != null ? targetListsPerNode?[node] : node.ProjectInstance.DefaultTargets);
+                    targetListsPerNode?[node] != null ? targetListsPerNode?[node] : node.ProjectInstanceSnapshot.DefaultTargets);
 
                 results[ProjectNumber(node)] = (result, logger);
 
@@ -507,7 +507,7 @@ string[] ExpectedBuildOutputForNode(ProjectGraphNode node)
             }
         }
 
-        private static string ProjectNumber(ProjectGraphNode node) => Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);
+        private static string ProjectNumber(ProjectGraphNode node) => Path.GetFileNameWithoutExtension(node.ProjectInstanceSnapshot.FullPath);
 
         private static TransientTestFile CreateProjectFileWrapper(TestEnvironment env, int projectNumber, int[] projectReferences, Dictionary<string, string[]> projectReferenceTargets, string defaultTargets, string extraContent)
         {
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 6debe82528e..b7614ea7789 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -499,7 +499,7 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
 
                 foreach (var node in graph.ProjectNodesTopologicallySorted)
                 {
-                    var buildResult = buildSession.BuildProjectFile(node.ProjectInstance.FullPath);
+                    var buildResult = buildSession.BuildProjectFile(node.ProjectInstanceSnapshot.FullPath);
 
                     buildResult.ShouldHaveSucceeded();
 
@@ -535,8 +535,8 @@ public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
 
             (MockLogger logger, ProjectGraph graph, _) = BuildGraphVsScenario(testData, assertBuildResults: false);
 
-            logger.FullLog.ShouldNotContain($"EntryPoint: {graph.GraphRoots.First().ProjectInstance.FullPath}");
-            logger.FullLog.ShouldContain($"EntryPoint: {graph.GraphRoots.First().ProjectReferences.First().ProjectInstance.FullPath}");
+            logger.FullLog.ShouldNotContain($"EntryPoint: {graph.GraphRoots.First().ProjectInstanceSnapshot.FullPath}");
+            logger.FullLog.ShouldContain($"EntryPoint: {graph.GraphRoots.First().ProjectReferences.First().ProjectInstanceSnapshot.FullPath}");
         }
 
         private (MockLogger logger, ProjectGraph projectGraph, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) BuildGraphVsScenario(
@@ -581,7 +581,7 @@ public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
                     foreach (var node in graph.ProjectNodesTopologicallySorted)
                     {
                         BuildResult buildResult = buildSession.BuildProjectFile(
-                            node.ProjectInstance.FullPath,
+                            node.ProjectInstanceSnapshot.FullPath,
                             globalProperties:
                                 new Dictionary<string, string>
                                 {
@@ -602,7 +602,7 @@ public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
                 {
                     foreach (var node in graph.ProjectNodes)
                     {
-                        var projectPath = node.ProjectInstance.FullPath;
+                        var projectPath = node.ProjectInstanceSnapshot.FullPath;
                         var projectName = Path.GetFileNameWithoutExtension(projectPath);
 
                         // Ensure MSBuild passes config / platform information set by VS.
@@ -632,15 +632,15 @@ private static string CreateSolutionConfigurationProperty(IReadOnlyCollection<Pr
 
             foreach (var node in projectNodes)
             {
-                var projectPath = node.ProjectInstance.FullPath;
+                var projectPath = node.ProjectInstanceSnapshot.FullPath;
                 var projectName = Path.GetFileNameWithoutExtension(projectPath);
 
-                var buildProjectInSolutionValue = node.ProjectInstance.GetPropertyValue("BuildProjectInSolution");
+                var buildProjectInSolutionValue = node.ProjectInstanceSnapshot.GetPropertyValue("BuildProjectInSolution");
                 var buildProjectInSolutionAttribute = string.IsNullOrWhiteSpace(buildProjectInSolutionValue)
                     ? string.Empty
                     : $"BuildProjectInSolution=\"{buildProjectInSolutionValue}\"";
 
-                var projectDependencyValue = node.ProjectInstance.GetPropertyValue("ProjectDependency");
+                var projectDependencyValue = node.ProjectInstanceSnapshot.GetPropertyValue("ProjectDependency");
                 var projectDependencyElement = string.IsNullOrWhiteSpace(projectDependencyValue)
                     ? string.Empty
                     : $"<ProjectDependency Project=\"{projectDependencyValue}\" />";
@@ -693,7 +693,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
 
                     // Build references in parallel.
                     var referenceBuildTasks = rootNode.ProjectReferences.Select(
-                        r => buildSession.BuildProjectFileAsync(r.ProjectInstance.FullPath, globalProperties: globalProperties));
+                        r => buildSession.BuildProjectFileAsync(r.ProjectInstanceSnapshot.FullPath, globalProperties: globalProperties));
 
                     foreach (var task in referenceBuildTasks)
                     {
@@ -702,7 +702,7 @@ public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
                     }
 
                     buildSession
-                        .BuildProjectFile(rootNode.ProjectInstance.FullPath, globalProperties: globalProperties)
+                        .BuildProjectFile(rootNode.ProjectInstanceSnapshot.FullPath, globalProperties: globalProperties)
                         .ShouldHaveSucceeded();
                 }
 
@@ -791,22 +791,22 @@ private void AssertCacheBuild(
             {
                 if (string.IsNullOrEmpty(targets))
                 {
-                    mockLogger.FullLog.ShouldContain(string.Format(ResourceUtilities.GetResourceString("ProjectCacheQueryStartedWithDefaultTargets"), node.ProjectInstance.FullPath));
+                    mockLogger.FullLog.ShouldContain(string.Format(ResourceUtilities.GetResourceString("ProjectCacheQueryStartedWithDefaultTargets"), node.ProjectInstanceSnapshot.FullPath));
                 }
                 else
                 {
-                    mockLogger.FullLog.ShouldContain(string.Format(ResourceUtilities.GetResourceString("ProjectCacheQueryStartedWithTargetNames"), node.ProjectInstance.FullPath, targets));
+                    mockLogger.FullLog.ShouldContain(string.Format(ResourceUtilities.GetResourceString("ProjectCacheQueryStartedWithTargetNames"), node.ProjectInstanceSnapshot.FullPath, targets));
                 }
 
                 if (instanceMockCache != null)
                 {
-                    instanceMockCache.Requests.ShouldContain(r => r.ProjectFullPath.Equals(node.ProjectInstance.FullPath));
+                    instanceMockCache.Requests.ShouldContain(r => r.ProjectFullPath.Equals(node.ProjectInstanceSnapshot.FullPath));
 
                     var expectedCacheResponse = testData.GetExpectedCacheResultForNode(node);
                     switch (expectedCacheResponse.ResultType)
                     {
                         case CacheResultType.CacheHit:
-                            AssertBuildResultForCacheHit(node.ProjectInstance.FullPath, projectPathToBuildResults[node], expectedCacheResponse);
+                            AssertBuildResultForCacheHit(node.ProjectInstanceSnapshot.FullPath, projectPathToBuildResults[node], expectedCacheResponse);
                             break;
                         case CacheResultType.CacheMiss:
                             break;
@@ -820,14 +820,14 @@ private void AssertCacheBuild(
                 }
                 else
                 {
-                    mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: GetCacheResultAsync for {node.ProjectInstance.FullPath}");
+                    mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: GetCacheResultAsync for {node.ProjectInstanceSnapshot.FullPath}");
 
                     // Too complicated, not worth it to send expected results to the assembly plugin, so skip checking the build results.
                 }
             }
         }
 
-        private static int GetProjectNumber(ProjectGraphNode node) => GetProjectNumber(node.ProjectInstance.FullPath);
+        private static int GetProjectNumber(ProjectGraphNode node) => GetProjectNumber(node.ProjectInstanceSnapshot.FullPath);
 
         private static int GetProjectNumber(string projectPath) => int.Parse(Path.GetFileNameWithoutExtension(projectPath));
 
@@ -1422,7 +1422,7 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
 
             Task<BuildResult> BuildProjectFileAsync(int projectNumber)
             {
-                return buildSession.BuildProjectFileAsync(graph.ProjectNodes.First(n => GetProjectNumber(n) == projectNumber).ProjectInstance.FullPath);
+                return buildSession.BuildProjectFileAsync(graph.ProjectNodes.First(n => GetProjectNumber(n) == projectNumber).ProjectInstanceSnapshot.FullPath);
             }
         }
 
@@ -1476,7 +1476,7 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                     foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
                     {
                         Task<BuildResult> buildResultTask = buildSession.BuildProjectFileAsync(
-                            node.ProjectInstance.FullPath,
+                            node.ProjectInstanceSnapshot.FullPath,
                             globalProperties:
                             new Dictionary<string, string>
                             {
@@ -1491,7 +1491,7 @@ public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool dis
                         buildResultTask.Result.ShouldHaveSucceeded();
                     }
 
-                    buildSession.BuildProjectFile(graph.GraphRoots.First().ProjectInstance.FullPath).ShouldHaveSucceeded();
+                    buildSession.BuildProjectFile(graph.GraphRoots.First().ProjectInstanceSnapshot.FullPath).ShouldHaveSucceeded();
                 }
 
                 StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
diff --git a/src/Build.UnitTests/SolutionFileBuilder.cs b/src/Build.UnitTests/SolutionFileBuilder.cs
index 73774529835..5a8c06b4f19 100644
--- a/src/Build.UnitTests/SolutionFileBuilder.cs
+++ b/src/Build.UnitTests/SolutionFileBuilder.cs
@@ -93,7 +93,7 @@ public static SolutionFileBuilder FromGraph(
             {
                 Projects = graph.ProjectNodes.ToDictionary(
                     n => GraphTestingUtilities.GetProjectNumber((ProjectGraphNode)n).ToString(),
-                    n => n.ProjectInstance.FullPath),
+                    n => n.ProjectInstanceSnapshot.FullPath),
                 ProjectConfigurations = projectConfigurations,
                 SolutionDependencies = solutionDependencies,
                 SolutionDependenciesProjectNameToGuids = solutionDependenciesProjectNameToGuids
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 66e67c82d3c..f7c18f5c7cd 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1878,7 +1878,8 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                             SdkResolverService,
                             submission.SubmissionId,
                             projectLoadSettings);
-                    });
+                    },
+                    keepProjectInstance: false);
             }
 
             LogMessage(
@@ -1888,6 +1889,9 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     projectGraph.ConstructionMetrics.NodeCount,
                     projectGraph.ConstructionMetrics.EdgeCount));
 
+            GC.Collect();
+            LogMessage($"GraphBuild GC: {GC.GetTotalMemory(false)} bytes *new*");
+
             Dictionary<ProjectGraphNode, BuildResult> resultsPerNode = null;
 
             if (submission.BuildRequestData.GraphBuildOptions.Build)
@@ -1973,7 +1977,9 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
                         }
 
                         var request = new BuildRequestData(
-                            node.ProjectInstance,
+                            node.ProjectInstanceSnapshot.FullPath,
+                            node.ProjectInstanceSnapshot.GlobalProperties,
+                            node.ProjectInstanceSnapshot.ToolsVersion,
                             targetList.ToArray(),
                             graphBuildRequestData.HostServices,
                             graphBuildRequestData.Flags);
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index e34e70cca44..5ea67b01f26 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -43,6 +43,8 @@ internal sealed class ProjectCacheService : IAsyncDisposable
 
         private bool _isDisposed;
 
+        private bool _graph_initialized;
+
         private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);
 
         /// <summary>
@@ -80,11 +82,12 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
                 s_parallelOptions,
                 node =>
                 {
-                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
+                    foreach (ProjectCacheDescriptor projectCacheDescriptor in node.ProjectInstanceSnapshot.ProjectCacheDescriptors)
                     {
                         // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
                         _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
                             .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                        _graph_initialized = true;
                     }
                 });
         }
@@ -300,6 +303,11 @@ public bool ShouldUseCache(BuildRequestConfiguration buildRequestConfiguration)
                 return true;
             }
 
+            if (_graph_initialized)
+            {
+                return true;
+            }
+
             // If the project isn't loaded, don't force it to be just to check if it's cacheable as this may not be very performant.
             if (!buildRequestConfiguration.IsLoaded)
             {
diff --git a/src/Build/Graph/GraphBuildSubmission.cs b/src/Build/Graph/GraphBuildSubmission.cs
index 9c00b5bb0e4..8f2f07d0750 100644
--- a/src/Build/Graph/GraphBuildSubmission.cs
+++ b/src/Build/Graph/GraphBuildSubmission.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Graph
     /// A callback used to receive notification that a build has completed.
     /// </summary>
     /// <remarks>
-    /// When this delegate is invoked, the WaitHandle on the BuildSubmission will have been be signalled and the OverallBuildResult will be valid.
+    /// When this delegate is invoked, the WaitHandle on the BuildSubmission will have been be signaled and the OverallBuildResult will be valid.
     /// </remarks>
     public delegate void GraphBuildSubmissionCompleteCallback(GraphBuildSubmission submission);
 
@@ -74,7 +74,7 @@ internal GraphBuildSubmission(BuildManager buildManager, int submissionId, Graph
         public Object AsyncContext { get; private set; }
 
         /// <summary>
-        /// A <see cref="System.Threading.WaitHandle"/> which will be signalled when the build is complete.  Valid after <see cref="BuildSubmission.Execute()"/> or <see cref="BuildSubmission.ExecuteAsync(BuildSubmissionCompleteCallback, object)"/> returns, otherwise null.
+        /// A <see cref="System.Threading.WaitHandle"/> which will be signaled when the build is complete.  Valid after <see cref="BuildSubmission.Execute()"/> or <see cref="BuildSubmission.ExecuteAsync(BuildSubmissionCompleteCallback, object)"/> returns, otherwise null.
         /// </summary>
         public WaitHandle WaitHandle => _completionEvent;
 
@@ -84,7 +84,7 @@ internal GraphBuildSubmission(BuildManager buildManager, int submissionId, Graph
         public bool IsCompleted => WaitHandle.WaitOne(new TimeSpan(0));
 
         /// <summary>
-        /// The results of the build per graph node.  Valid only after WaitHandle has become signalled.
+        /// The results of the build per graph node.  Valid only after WaitHandle has become signaled.
         /// </summary>
         public GraphBuildResult BuildResult { get; internal set; }
 
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index a92da0f73f9..76bf8376f6e 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -48,6 +48,7 @@ internal class GraphBuilder
 
         private readonly ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory;
         private IReadOnlyDictionary<string, IReadOnlyCollection<string>> _solutionDependencies;
+        internal bool KeepProjectInstance { get; set; }
 
         public GraphBuilder(
             IEnumerable<ProjectGraphEntryPoint> entryPoints,
@@ -60,7 +61,6 @@ public GraphBuilder(
             var (actualEntryPoints, solutionDependencies) = ExpandSolutionIfPresent(entryPoints.ToImmutableArray());
 
             _solutionDependencies = solutionDependencies;
-
             _entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(actualEntryPoints);
 
             IEqualityComparer<ConfigurationMetadata> configComparer = EqualityComparer<ConfigurationMetadata>.Default;
@@ -133,7 +133,7 @@ private void AddEdgesFromProjectReferenceItems(Dictionary<ConfigurationMetadata,
             {
                 var currentNode = parsedProject.Value.GraphNode;
 
-                var requiresTransitiveProjectReferences = _projectInterpretation.RequiresTransitiveProjectReferences(currentNode.ProjectInstance);
+                var requiresTransitiveProjectReferences = _projectInterpretation.RequiresTransitiveProjectReferences(currentNode.ProjectInstanceSnapshot);
 
                 foreach (var referenceInfo in parsedProject.Value.ReferenceInfos)
                 {
@@ -148,14 +148,16 @@ private void AddEdgesFromProjectReferenceItems(Dictionary<ConfigurationMetadata,
                     {
                         foreach (var transitiveProjectReference in GetTransitiveProjectReferencesExcludingSelf(allParsedProjects[referenceInfo.ReferenceConfiguration]))
                         {
+                            var projectRefSnapshot = new ProjectItemInstanceSnapshot(new List<(string Name, string Value)>(0))
+                            {
+                                ItemType = ProjectInterpretation.TransitiveReferenceItemName,
+                                EvaluatedInclude = referenceInfo.ReferenceConfiguration.ProjectFullPath,
+                                FullPath = referenceInfo.ReferenceConfiguration.ProjectFullPath,
+                            };
+
                             currentNode.AddProjectReference(
                                 transitiveProjectReference,
-                                new ProjectItemInstance(
-                                    project: currentNode.ProjectInstance,
-                                    itemType: ProjectInterpretation.TransitiveReferenceItemName,
-                                    includeEscaped: referenceInfo.ReferenceConfiguration.ProjectFullPath,
-                                    directMetadata: null,
-                                    definingFileEscaped: currentNode.ProjectInstance.FullPath),
+                                projectRefSnapshot,
                                 edges);
                         }
                     }
@@ -197,7 +199,7 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
 
             foreach (var project in allParsedProjects)
             {
-                var projectPath = project.Value.GraphNode.ProjectInstance.FullPath;
+                var projectPath = project.Value.GraphNode.ProjectInstanceSnapshot.FullPath;
 
                 if (projectsByPath.ContainsKey(projectPath))
                 {
@@ -226,13 +228,13 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
                 {
                     foreach (var referencedNode in referencedNodes)
                     {
-                        var stubItem = new ProjectItemInstance(
-                            referencingNode.ProjectInstance,
-                            SolutionItemReference,
-                            referencedNode.ProjectInstance.FullPath,
-                            referencingNode.ProjectInstance.FullPath);
-
-                        referencingNode.AddProjectReference(referencedNode, stubItem, edges);
+                        var projectRefSnapshot = new ProjectItemInstanceSnapshot(new List<(string Name, string Value)>(0))
+                        {
+                            ItemType = SolutionItemReference,
+                            EvaluatedInclude = referencedNode.ProjectInstanceSnapshot.FullPath,
+                            FullPath = referencedNode.ProjectInstanceSnapshot.FullPath,
+                        };
+                        referencingNode.AddProjectReference(referencedNode, projectRefSnapshot, edges);
                     }
                 }
             }
@@ -479,7 +481,7 @@ private void DetectCycles(
                             {
                                 // the project being evaluated has a reference to itself
                                 var selfReferencingProjectString =
-                                    FormatCircularDependencyError(new List<string> { node.ProjectInstance.FullPath, node.ProjectInstance.FullPath });
+                                    FormatCircularDependencyError(new List<string> { node.ProjectInstanceSnapshot.FullPath, node.ProjectInstanceSnapshot.FullPath });
                                 throw new CircularDependencyException(
                                     string.Format(
                                         ResourceUtilities.GetResourceString("CircularDependencyInProjectGraph"),
@@ -488,7 +490,7 @@ private void DetectCycles(
 
                             // the project being evaluated has a circular dependency involving multiple projects
                             // add this project to the list of projects involved in cycle 
-                            var projectsInCycle = new List<string> { referenceNode.ProjectInstance.FullPath };
+                            var projectsInCycle = new List<string> { referenceNode.ProjectInstanceSnapshot.FullPath };
                             return (false, projectsInCycle);
                         }
                     }
@@ -498,11 +500,11 @@ private void DetectCycles(
                         var loadReference = VisitNode(referenceNode, nodeState);
                         if (!loadReference.success)
                         {
-                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstance.FullPath))
+                            if (loadReference.projectsInCycle[0].Equals(node.ProjectInstanceSnapshot.FullPath))
                             {
                                 // we have reached the nth project in the cycle, form error message and throw
-                                loadReference.projectsInCycle.Add(referenceNode.ProjectInstance.FullPath);
-                                loadReference.projectsInCycle.Add(node.ProjectInstance.FullPath);
+                                loadReference.projectsInCycle.Add(referenceNode.ProjectInstanceSnapshot.FullPath);
+                                loadReference.projectsInCycle.Add(node.ProjectInstanceSnapshot.FullPath);
 
                                 var errorMessage = FormatCircularDependencyError(loadReference.projectsInCycle);
                                 throw new CircularDependencyException(
@@ -513,7 +515,7 @@ private void DetectCycles(
 
                             // this is one of the projects in the circular dependency
                             // update the list of projects in cycle and return the list to the caller
-                            loadReference.projectsInCycle.Add(referenceNode.ProjectInstance.FullPath);
+                            loadReference.projectsInCycle.Add(referenceNode.ProjectInstanceSnapshot.FullPath);
                             return (false, loadReference.projectsInCycle);
                         }
                     }
@@ -539,7 +541,7 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)
                 throw new InvalidOperationException(ResourceUtilities.GetResourceString("NullReferenceFromProjectInstanceFactory"));
             }
 
-            var graphNode = new ProjectGraphNode(projectInstance);
+            var graphNode = new ProjectGraphNode(projectInstance, KeepProjectInstance);
 
             var referenceInfos = ParseReferences(graphNode);
 
@@ -576,7 +578,7 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
         {
             var referenceInfos = new List<ProjectInterpretation.ReferenceInfo>();
 
-            foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance, _projectCollection, _projectInstanceFactory))
+            foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstanceSnapshot, _projectCollection, _projectInstanceFactory))
             {
                 if (FileUtilities.IsSolutionFilename(referenceInfo.ReferenceConfiguration.ProjectFullPath))
                 {
@@ -636,26 +638,26 @@ private static PropertyDictionary<ProjectPropertyInstance> CreatePropertyDiction
 
         internal sealed class GraphEdges
         {
-            private ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance> ReferenceItems =
-                new ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstance>();
+            private ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstanceSnapshot> ReferenceItems =
+                new ConcurrentDictionary<(ProjectGraphNode, ProjectGraphNode), ProjectItemInstanceSnapshot>();
 
             internal int Count => ReferenceItems.Count;
 
-            public ProjectItemInstance this[(ProjectGraphNode node, ProjectGraphNode reference) key]
+            public ProjectItemInstanceSnapshot this[(ProjectGraphNode node, ProjectGraphNode reference) key]
             {
                 get
                 {
-                    ErrorUtilities.VerifyThrow(ReferenceItems.TryGetValue(key, out ProjectItemInstance referenceItem), "All requested keys should exist");
+                    ErrorUtilities.VerifyThrow(ReferenceItems.TryGetValue(key, out ProjectItemInstanceSnapshot referenceItem), "All requested keys should exist");
                     return referenceItem;
                 }
             }
 
-            public void AddOrUpdateEdge((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance edge)
+            public void AddOrUpdateEdge((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstanceSnapshot edge)
             {
                 ReferenceItems.AddOrUpdate(
                     key,
-                    addValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance referenceItem) => referenceItem,
-                    updateValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstance existingItem, ProjectItemInstance newItem) =>
+                    addValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstanceSnapshot referenceItem) => referenceItem,
+                    updateValueFactory: static ((ProjectGraphNode node, ProjectGraphNode reference) key, ProjectItemInstanceSnapshot existingItem, ProjectItemInstanceSnapshot newItem) =>
                     {
                         string existingTargetsMetadata = existingItem.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
                         string newTargetsMetadata = newItem.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
@@ -669,7 +671,7 @@ public void AddOrUpdateEdge((ProjectGraphNode node, ProjectGraphNode reference)
                         existingTargetsMetadata = GetEffectiveTargets(key.reference, existingTargetsMetadata);
                         newTargetsMetadata = GetEffectiveTargets(key.reference, newTargetsMetadata);
 
-                        ProjectItemInstance mergedItem = existingItem.DeepClone();
+                        ProjectItemInstanceSnapshot mergedItem = existingItem;
                         mergedItem.SetMetadata(ItemMetadataNames.ProjectReferenceTargetsMetadataName, $"{existingTargetsMetadata};{newTargetsMetadata}");
                         return mergedItem;
 
@@ -677,7 +679,7 @@ static string GetEffectiveTargets(ProjectGraphNode reference, string targetsMeta
                         {
                             if (string.IsNullOrWhiteSpace(targetsMetadata))
                             {
-                                return string.Join(";", reference.ProjectInstance.DefaultTargets);
+                                return string.Join(";", reference.ProjectInstanceSnapshot.DefaultTargets);
                             }
 
                             return targetsMetadata;
@@ -693,7 +695,7 @@ public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
 
             internal bool HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
 
-            internal IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> TestOnly_AsConfigurationMetadata()
+            internal IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstanceSnapshot> TestOnly_AsConfigurationMetadata()
             {
                 return ReferenceItems.ToImmutableDictionary(
                     kvp => (kvp.Key.Item1.ToConfigurationMetadata(), kvp.Key.Item2.ToConfigurationMetadata()),
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index 39993e3a4fc..9b96da5cf9a 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -336,6 +336,48 @@ public ProjectGraph(
         {
         }
 
+        /// <summary>
+        ///     Constructs a graph starting from the given graph entry points, evaluating with the provided project collection.
+        /// </summary>
+        /// <param name="entryPoints">The entry points to use in constructing the graph</param>
+        /// <param name="projectCollection">
+        ///     The collection with which all projects in the graph should be associated. May not be
+        ///     null.
+        /// </param>
+        /// <param name="projectInstanceFactory">
+        ///     A delegate used for constructing a <see cref="ProjectInstance" />, called for each
+        ///     project created during graph creation. This value can be null, which uses
+        ///     a default implementation that calls the ProjectInstance constructor. See the remarks
+        ///     on <see cref="ProjectInstanceFactoryFunc" /> for other scenarios.
+        /// </param>
+        /// <param name="keepProjectInstance">
+        ///     Set true to keep Project Instance during building the project graph.
+        /// </param>
+        /// <exception cref="InvalidProjectFileException">
+        ///     If the evaluation of any project in the graph fails
+        /// </exception>
+        /// <exception cref="InvalidOperationException">
+        ///     If a null reference is returned from <paramref name="projectInstanceFactory" />
+        /// </exception>
+        /// <exception cref="CircularDependencyException">
+        ///     If the evaluation is successful but the project graph contains a circular
+        ///     dependency
+        /// </exception>
+        internal ProjectGraph(
+            IEnumerable<ProjectGraphEntryPoint> entryPoints,
+            ProjectCollection projectCollection,
+            ProjectInstanceFactoryFunc projectInstanceFactory,
+            bool keepProjectInstance)
+            : this(
+                entryPoints,
+                projectCollection,
+                projectInstanceFactory,
+                NativeMethodsShared.GetLogicalCoreCount(),
+                CancellationToken.None,
+                keepProjectInstance)
+        {
+        }
+
         /// <summary>
         ///     Constructs a graph starting from the given graph entry points, evaluating with the provided project collection.
         /// </summary>
@@ -413,6 +455,23 @@ public ProjectGraph(
             ProjectInstanceFactoryFunc projectInstanceFactory,
             int degreeOfParallelism,
             CancellationToken cancellationToken)
+            : this(
+                entryPoints,
+                projectCollection,
+                projectInstanceFactory,
+                degreeOfParallelism,
+                cancellationToken,
+                true)
+        {
+        }
+
+        internal ProjectGraph(
+            IEnumerable<ProjectGraphEntryPoint> entryPoints,
+            ProjectCollection projectCollection,
+            ProjectInstanceFactoryFunc projectInstanceFactory,
+            int degreeOfParallelism,
+            CancellationToken cancellationToken,
+            bool keepProjectInstance)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
@@ -427,6 +486,8 @@ public ProjectGraph(
                 ProjectInterpretation.Instance,
                 degreeOfParallelism,
                 cancellationToken);
+
+            graphBuilder.KeepProjectInstance = keepProjectInstance;
             graphBuilder.BuildGraph();
 
             EntryPointNodes = graphBuilder.EntryPointNodes;
@@ -502,11 +563,11 @@ internal string ToDot(
             {
                 var nodeId = GetNodeId(node);
 
-                var nodeName = Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);
+                var nodeName = Path.GetFileNameWithoutExtension(node.ProjectInstanceSnapshot.FullPath);
 
                 var globalPropertiesString = string.Join(
                     "<br/>",
-                    node.ProjectInstance.GlobalProperties.OrderBy(kvp => kvp.Key)
+                    node.ProjectInstanceSnapshot.GlobalProperties.OrderBy(kvp => kvp.Key)
                         .Select(kvp => $"{kvp.Key}={kvp.Value}"));
 
                 var targetListString = GetTargetListString(node);
@@ -607,7 +668,7 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
             foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
             {
                 var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0
-                    ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)
+                    ? ImmutableList.CreateRange(entryPointNode.ProjectInstanceSnapshot.DefaultTargets)
                     : ImmutableList.CreateRange(entryProjectTargets);
                 var entryEdge = new ProjectGraphBuildRequest(entryPointNode, entryTargets);
                 encounteredEdges.Add(entryEdge);
@@ -630,12 +691,12 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
                 }
 
                 // Based on the entry points of this project, determine which targets to propagate down to project references.
-                var targetsToPropagate = ProjectInterpretation.TargetsToPropagate.FromProjectAndEntryTargets(node.ProjectInstance, requestedTargets);
+                var targetsToPropagate = ProjectInterpretation.TargetsToPropagate.FromProjectAndEntryTargets(node.ProjectInstanceSnapshot, requestedTargets);
 
                 // Queue the project references for visitation, if the edge hasn't already been traversed.
                 foreach (var referenceNode in node.ProjectReferences)
                 {
-                    var applicableTargets = targetsToPropagate.GetApplicableTargetsForReference(referenceNode.ProjectInstance);
+                    var applicableTargets = targetsToPropagate.GetApplicableTargetsForReference(referenceNode.ProjectInstanceSnapshot);
 
                     if (applicableTargets.IsEmpty)
                     {
@@ -644,7 +705,7 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
 
                     var expandedTargets = ExpandDefaultTargets(
                         applicableTargets,
-                        referenceNode.ProjectInstance.DefaultTargets,
+                        referenceNode.ProjectInstanceSnapshot.DefaultTargets,
                         Edges[(node, referenceNode)]);
 
                     var projectReferenceEdge = new ProjectGraphBuildRequest(
@@ -707,7 +768,7 @@ void ThrowOnEmptyTargetNames(ICollection<string> targetNames)
             }
         }
 
-        private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string> targets, List<string> defaultTargets, ProjectItemInstance graphEdge)
+        private static ImmutableList<string> ExpandDefaultTargets(ImmutableList<string> targets, List<string> defaultTargets, ProjectItemInstanceSnapshot graphEdge)
         {
             var i = 0;
             while (i < targets.Count)
diff --git a/src/Build/Graph/ProjectGraphNode.cs b/src/Build/Graph/ProjectGraphNode.cs
index bb14d663c84..dc6fa6c486b 100644
--- a/src/Build/Graph/ProjectGraphNode.cs
+++ b/src/Build/Graph/ProjectGraphNode.cs
@@ -3,14 +3,201 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Shared;
+using static Microsoft.Build.Graph.ProjectInterpretation;
 
 #nullable disable
 
 namespace Microsoft.Build.Graph
 {
+    internal class ProjectItemInstanceSnapshot
+    {
+        public string FullPath = string.Empty;
+        public string EvaluatedInclude = string.Empty;
+        public string ItemType = string.Empty;
+
+        private List<(string Name, string Value)> Metadata;
+
+        public ProjectItemInstanceSnapshot(List<(string Name, string Value)> metadata)
+        {
+            Metadata = metadata;
+        }
+
+        public ProjectItemInstanceSnapshot(ProjectItemInstance projectItemInstance)
+        {
+            Metadata = new(projectItemInstance.MetadataCount);
+            foreach (var metadata in projectItemInstance.Metadata)
+            {
+                Metadata.Add((metadata.Name, metadata.EvaluatedValue));
+            }
+
+            FullPath = projectItemInstance.GetMetadataValue(FullPathMetadataName);
+        }
+
+        public string GetMetadataValue(string metadataName)
+        {
+            // Note: FullPath is a special metadata that doesn't count towards the DirectMetadataCount.
+            if (FullPathMetadataName == metadataName)
+            {
+                return FullPath;
+            }
+
+            // Note: caller expect empty string instead of null.
+            var result = Metadata.FirstOrDefault((k) => k.Name == metadataName);
+            return string.IsNullOrEmpty(result.Value) ? string.Empty : result.Value;
+        }
+
+        public void SetMetadata(string metadataName, string value)
+        {
+            RemoveMetadata(metadataName);
+            Metadata.Add((metadataName, value));
+        }
+
+        public void RemoveMetadata(string metadataName)
+        {
+            int count = Metadata.Count;
+            for (int i = 0; i < count; i++)
+            {
+                if (Metadata[i].Name == metadataName)
+                {
+                    Metadata.RemoveAt(i);
+                    break;
+                }
+            }
+        }
+
+        public bool HasMetadata(string metadataName)
+        {
+            return Metadata.Any( (kv) => kv.Name == metadataName);
+        }
+
+        public int DirectMetadataCount => Metadata.Count;
+    }
+
+    internal class ProjectInstanceSnapshot
+    {
+        public ProjectInstanceSnapshot(ProjectInstance instance)
+        {
+            FullPath = instance.FullPath;
+            DefaultTargets = instance.DefaultTargets;
+            ProjectFileLocation = instance.ProjectFileLocation;
+            GlobalPropertiesDictionary = instance.GlobalPropertiesDictionary;
+            GlobalProperties = instance.GlobalProperties;
+            ToolsVersion = instance.ToolsVersion;
+
+            var innerBuildPropName = instance.GetPropertyValue(PropertyNames.InnerBuildProperty);
+            var innerBuildPropValue = instance.GetPropertyValue(innerBuildPropName);
+
+            var innerBuildPropValues = instance.GetPropertyValue(PropertyNames.InnerBuildPropertyValues);
+            var innerBuildPropValuesValue = instance.GetPropertyValue(innerBuildPropValues);
+
+            var isOuterBuild = string.IsNullOrWhiteSpace(innerBuildPropValue) && !string.IsNullOrWhiteSpace(innerBuildPropValuesValue);
+            var isInnerBuild = !string.IsNullOrWhiteSpace(innerBuildPropValue);
+
+            ProjectType = isOuterBuild
+                ? ProjectType.OuterBuild
+                : isInnerBuild
+                    ? ProjectType.InnerBuild
+                    : ProjectType.NonMultitargeting;
+
+            Targets = instance.Targets.Keys.ToList();
+            Properties = new()
+                {
+                    { AddTransitiveProjectReferencesInStaticGraphPropertyName, instance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName) },
+                    { EnableDynamicPlatformResolutionPropertyName, instance.GetPropertyValue(EnableDynamicPlatformResolutionPropertyName) },
+                    { "TargetFrameworks", instance.GetPropertyValue("TargetFrameworks") },
+                    { BuildProjectInSolutionPropertyName, instance.GetPropertyValue(BuildProjectInSolutionPropertyName) },
+                    { PropertyNames.InnerBuildProperty, innerBuildPropName },
+                    { PropertyNames.InnerBuildPropertyValues, innerBuildPropValues },
+                    { UsingMicrosoftNETSdkPropertyName, instance.GetPropertyValue(UsingMicrosoftNETSdkPropertyName) },
+                    { DisableTransitiveProjectReferencesPropertyName, instance.GetPropertyValue(DisableTransitiveProjectReferencesPropertyName) },
+                    { SolutionProjectGenerator.CurrentSolutionConfigurationContents, instance.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents) },
+                    { PlatformMetadataName, instance.GetPropertyValue(PlatformMetadataName) },
+                    { ConfigurationMetadataName, instance.GetPropertyValue(ConfigurationMetadataName) },
+                    { PlatformLookupTableMetadataName, instance.GetPropertyValue(PlatformLookupTableMetadataName) },
+                    { ShouldUnsetParentConfigurationAndPlatformPropertyName, instance.GetPropertyValue(ShouldUnsetParentConfigurationAndPlatformPropertyName) },
+                };
+
+            if (!string.IsNullOrEmpty(innerBuildPropName))
+            {
+                Properties[innerBuildPropName] = innerBuildPropValue;
+            }
+
+            if (!string.IsNullOrEmpty(innerBuildPropValues))
+            {
+                Properties[innerBuildPropValues] = innerBuildPropValuesValue;
+            }
+
+            var projectReferenceTargets = instance.GetItems(ItemTypeNames.ProjectReferenceTargets);
+            ProjectReferenceByTargets = new(projectReferenceTargets.Count) { };
+            foreach (ProjectItemInstance projectReferenceTarget in projectReferenceTargets)
+            {
+                ProjectReferenceByTargets.Add(new ProjectItemInstanceSnapshot(projectReferenceTarget)
+                {
+                    ItemType = projectReferenceTarget.ItemType,
+                    EvaluatedInclude = projectReferenceTarget.EvaluatedInclude,
+                });
+            }
+
+            var projectReferences = instance.GetItems(ItemTypeNames.ProjectReference);
+            ProjectReference = new(projectReferences.Count) { };
+            foreach (ProjectItemInstance projectReference in projectReferences)
+            {
+                ProjectReference.Add(new ProjectItemInstanceSnapshot(projectReference)
+                {
+                    ItemType = projectReference.ItemType,
+                    EvaluatedInclude = projectReference.EvaluatedInclude,
+                });
+            }
+
+            var items = instance.GetItems(ItemTypeNames.ProjectCachePlugin);
+            ProjectCacheDescriptors = new(items.Count);
+            foreach (ProjectItemInstance item in items)
+            {
+                string pluginPath = FileUtilities.NormalizePath(System.IO.Path.Combine(item.Project.Directory, item.EvaluatedInclude));
+
+                var pluginSettings = new Dictionary<string, string>(System.StringComparer.OrdinalIgnoreCase);
+                foreach (ProjectMetadataInstance metadatum in item.Metadata)
+                {
+                    pluginSettings.Add(metadatum.Name, metadatum.EvaluatedValue);
+                }
+
+                ProjectCacheDescriptors.Add(ProjectCacheDescriptor.FromAssemblyPath(pluginPath, pluginSettings));
+            }
+        }
+
+        public string FullPath;
+        public string ToolsVersion;
+        public List<string> Targets;
+        internal ProjectType ProjectType;
+        public List<string> DefaultTargets;
+        public ElementLocation ProjectFileLocation;
+        internal Collections.PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesDictionary;
+
+        public int PropertiesCount => Properties.Count;
+        public IDictionary<string, string> GlobalProperties;
+        public List<ProjectItemInstanceSnapshot> ProjectReferenceByTargets;
+        public List<ProjectItemInstanceSnapshot> ProjectReference;
+        public List<ProjectCacheDescriptor> ProjectCacheDescriptors;
+
+        private Dictionary<string, string> Properties;
+
+        public string GetPropertyValue(string propertyName)
+        {
+            if (Properties.TryGetValue(propertyName, out string result))
+            {
+                return result;
+            }
+
+            return string.Empty;
+        }
+    }
+
     /// <summary>
     /// Represents the node for a particular project in a project graph.
     /// A node is defined by (ProjectPath, ToolsVersion, GlobalProperties).
@@ -22,10 +209,16 @@ public sealed class ProjectGraphNode
         private readonly HashSet<ProjectGraphNode> _referencingProjects = new HashSet<ProjectGraphNode>();
 
         // No public creation.
-        internal ProjectGraphNode(ProjectInstance projectInstance)
+        internal ProjectGraphNode(ProjectInstance projectInstance, bool keepProjectInstance)
         {
             ErrorUtilities.VerifyThrowInternalNull(projectInstance, nameof(projectInstance));
-            ProjectInstance = projectInstance;
+            ProjectInstanceSnapshot = new(projectInstance);
+
+            // Keep ProjectInstance for API compatibility
+            if (keepProjectInstance)
+            {
+                ProjectInstance = projectInstance;
+            }
         }
 
         /// <summary>
@@ -43,15 +236,20 @@ internal ProjectGraphNode(ProjectInstance projectInstance)
         /// </summary>
         public ProjectInstance ProjectInstance { get; }
 
+        /// <summary>
+        /// Gets the evaluated project instance represented by this node in the graph.
+        /// </summary>
+        internal ProjectInstanceSnapshot ProjectInstanceSnapshot { get; }
+
         private string DebugString()
         {
-            var truncatedProjectFile = FileUtilities.TruncatePathToTrailingSegments(ProjectInstance.FullPath, 2);
+            var truncatedProjectFile = FileUtilities.TruncatePathToTrailingSegments(ProjectInstanceSnapshot.FullPath, 2);
 
             return
-                $"{truncatedProjectFile}, #GlobalProps={ProjectInstance.GlobalProperties.Count}, #Props={ProjectInstance.Properties.Count}, #Items={ProjectInstance.Items.Count}, #in={ReferencingProjects.Count}, #out={ProjectReferences.Count}";
+                $"{truncatedProjectFile}, #GlobalProps={ProjectInstanceSnapshot.GlobalProperties.Count}, #Props={ProjectInstanceSnapshot.PropertiesCount}, #in={ReferencingProjects.Count}, #out={ProjectReferences.Count}";
         }
 
-        internal void AddProjectReference(ProjectGraphNode reference, ProjectItemInstance projectReferenceItem, GraphBuilder.GraphEdges edges)
+        internal void AddProjectReference(ProjectGraphNode reference, ProjectItemInstanceSnapshot projectReferenceItem, GraphBuilder.GraphEdges edges)
         {
             _projectReferences.Add(reference);
             reference._referencingProjects.Add(this);
@@ -82,7 +280,7 @@ internal void RemoveReferences(GraphBuilder.GraphEdges edges)
 
         internal ConfigurationMetadata ToConfigurationMetadata()
         {
-            return new ConfigurationMetadata(ProjectInstance.FullPath, ProjectInstance.GlobalPropertiesDictionary);
+            return new ConfigurationMetadata(ProjectInstanceSnapshot.FullPath, ProjectInstanceSnapshot.GlobalPropertiesDictionary);
         }
     }
 }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index d617f78e35a..492e227e8dd 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -21,24 +21,28 @@ namespace Microsoft.Build.Graph
 {
     internal sealed class ProjectInterpretation
     {
-        private const string FullPathMetadataName = "FullPath";
-        private const string ToolsVersionMetadataName = "ToolsVersion";
-        private const string SetConfigurationMetadataName = "SetConfiguration";
-        private const string SetPlatformMetadataName = "SetPlatform";
-        private const string SetTargetFrameworkMetadataName = "SetTargetFramework";
-        private const string GlobalPropertiesToRemoveMetadataName = "GlobalPropertiesToRemove";
-        private const string ProjectReferenceTargetIsOuterBuildMetadataName = "OuterBuild";
+        internal const string FullPathMetadataName = "FullPath";
+        internal const string ToolsVersionMetadataName = "ToolsVersion";
+        internal const string SetConfigurationMetadataName = "SetConfiguration";
+        internal const string SetPlatformMetadataName = "SetPlatform";
+        internal const string SetTargetFrameworkMetadataName = "SetTargetFramework";
+        internal const string GlobalPropertiesToRemoveMetadataName = "GlobalPropertiesToRemove";
+        internal const string ProjectReferenceTargetIsOuterBuildMetadataName = "OuterBuild";
         private const string InnerBuildReferenceItemName = "_ProjectSelfReference";
         internal static string TransitiveReferenceItemName = "_TransitiveProjectReference";
         internal const string AddTransitiveProjectReferencesInStaticGraphPropertyName = "AddTransitiveProjectReferencesInStaticGraph";
-        private const string PlatformLookupTableMetadataName = "PlatformLookupTable";
-        private const string PlatformMetadataName = "Platform";
-        private const string PlatformsMetadataName = "Platforms";
-        private const string EnableDynamicPlatformResolutionPropertyName = "EnableDynamicPlatformResolution";
-        private const string OverridePlatformNegotiationValue = "OverridePlatformNegotiationValue";
-        private const string ShouldUnsetParentConfigurationAndPlatformPropertyName = "ShouldUnsetParentConfigurationAndPlatform";
-        private const string ProjectMetadataName = "Project";
-        private const string ConfigurationMetadataName = "Configuration";
+        internal const string SkipNonexistentTargetsMetadataName = "SkipNonexistentTargets";
+        internal const string PlatformLookupTableMetadataName = "PlatformLookupTable";
+        internal const string PlatformMetadataName = "Platform";
+        internal const string PlatformsMetadataName = "Platforms";
+        internal const string EnableDynamicPlatformResolutionPropertyName = "EnableDynamicPlatformResolution";
+        internal const string OverridePlatformNegotiationValue = "OverridePlatformNegotiationValue";
+        internal const string ShouldUnsetParentConfigurationAndPlatformPropertyName = "ShouldUnsetParentConfigurationAndPlatform";
+        internal const string ProjectMetadataName = "Project";
+        internal const string ConfigurationMetadataName = "Configuration";
+        internal const string DisableTransitiveProjectReferencesPropertyName = "DisableTransitiveProjectReferences";
+        internal const string UsingMicrosoftNETSdkPropertyName = "UsingMicrosoftNETSdk";
+        internal const string BuildProjectInSolutionPropertyName = "BuildProjectInSolution";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -57,7 +61,7 @@ internal enum ProjectType
             NonMultitargeting,
         }
 
-        internal readonly record struct ReferenceInfo(ConfigurationMetadata ReferenceConfiguration, ProjectItemInstance ProjectReferenceItem);
+        internal readonly record struct ReferenceInfo(ConfigurationMetadata ReferenceConfiguration, ProjectItemInstanceSnapshot ProjectReferenceItem);
 
         private readonly struct TargetSpecification
         {
@@ -78,23 +82,23 @@ public TargetSpecification(string target, bool skipIfNonexistent)
             public bool SkipIfNonexistent { get; }
         }
 
-        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection projectCollection, ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory)
+        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstanceSnapshot requesterInstance, ProjectCollection projectCollection, ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory)
         {
-            IEnumerable<ProjectItemInstance> projectReferenceItems;
+            IEnumerable<ProjectItemInstanceSnapshot> projectReferenceItems;
             IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;
 
-            switch (GetProjectType(requesterInstance))
+            switch (requesterInstance.ProjectType)
             {
                 case ProjectType.OuterBuild:
                     projectReferenceItems = ConstructInnerBuildReferences(requesterInstance);
                     break;
                 case ProjectType.InnerBuild:
                     globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));
-                    projectReferenceItems = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
+                    projectReferenceItems = requesterInstance.ProjectReference;
                     break;
                 case ProjectType.NonMultitargeting:
                     globalPropertiesModifiers = ModifierForNonMultitargetingNodes;
-                    projectReferenceItems = requesterInstance.GetItems(ItemTypeNames.ProjectReference);
+                    projectReferenceItems = requesterInstance.ProjectReference;
                     break;
                 default:
                     throw new ArgumentOutOfRangeException();
@@ -107,7 +111,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                 solutionConfiguration = new SolutionConfiguration(solutionConfigurationXml);
             }
 
-            foreach (ProjectItemInstance projectReferenceItem in projectReferenceItems)
+            foreach (ProjectItemInstanceSnapshot projectReferenceItem in projectReferenceItems)
             {
                 if (!String.IsNullOrEmpty(projectReferenceItem.GetMetadataValue(ToolsVersionMetadataName)))
                 {
@@ -210,35 +214,21 @@ static void SetProperty(PropertyDictionary<ProjectPropertyInstance> properties,
             }
         }
 
-        internal static string GetInnerBuildPropertyValue(ProjectInstance project)
+        internal static string GetInnerBuildPropertyValue(ProjectInstanceSnapshot project)
         {
             return project.GetPropertyValue(GetInnerBuildPropertyName(project));
         }
 
-        internal static string GetInnerBuildPropertyName(ProjectInstance project)
+        internal static string GetInnerBuildPropertyName(ProjectInstanceSnapshot project)
         {
             return project.GetPropertyValue(PropertyNames.InnerBuildProperty);
         }
 
-        internal static string GetInnerBuildPropertyValues(ProjectInstance project)
+        internal static string GetInnerBuildPropertyValues(ProjectInstanceSnapshot project)
         {
             return project.GetPropertyValue(project.GetPropertyValue(PropertyNames.InnerBuildPropertyValues));
         }
 
-        internal static ProjectType GetProjectType(ProjectInstance project)
-        {
-            var isOuterBuild = String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project)) && !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValues(project));
-            var isInnerBuild = !String.IsNullOrWhiteSpace(GetInnerBuildPropertyValue(project));
-
-            ErrorUtilities.VerifyThrow(!(isOuterBuild && isInnerBuild), $"A project cannot be an outer and inner build at the same time: ${project.FullPath}");
-
-            return isOuterBuild
-                ? ProjectType.OuterBuild
-                : isInnerBuild
-                    ? ProjectType.InnerBuild
-                    : ProjectType.NonMultitargeting;
-        }
-
         /// <summary>
         /// To avoid calling nuget at graph construction time, the graph is initially constructed with nodes referencing outer build nodes which in turn
         /// reference inner build nodes. However at build time, the inner builds are referenced directly by the nodes referencing the outer build.
@@ -251,7 +241,7 @@ public void AddInnerBuildEdges(Dictionary<ConfigurationMetadata, ParsedProject>
             {
                 ProjectGraphNode outerBuild = node.Value.GraphNode;
 
-                if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)
+                if (outerBuild.ProjectInstanceSnapshot.ProjectType == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)
                 {
                     foreach (ProjectGraphNode innerBuild in outerBuild.ProjectReferences)
                     {
@@ -261,7 +251,7 @@ public void AddInnerBuildEdges(Dictionary<ConfigurationMetadata, ParsedProject>
                             // Decided to use the outerBuildBuildReferencingProject -> outerBuild edge in order to preserve any extra metadata
                             // information that may be present on the edge, like the "Targets" metadata which specifies what
                             // targets to call on the references.
-                            ProjectItemInstance newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
+                            ProjectItemInstanceSnapshot newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
 
                             if (outerBuildReferencingProject.ProjectReferences.Contains(innerBuild))
                             {
@@ -282,7 +272,7 @@ public void AddInnerBuildEdges(Dictionary<ConfigurationMetadata, ParsedProject>
             }
         }
 
-        private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(ProjectInstance outerBuild)
+        private static IEnumerable<ProjectItemInstanceSnapshot> ConstructInnerBuildReferences(ProjectInstanceSnapshot outerBuild)
         {
             var globalPropertyName = GetInnerBuildPropertyName(outerBuild);
             var globalPropertyValues = GetInnerBuildPropertyValues(outerBuild);
@@ -292,12 +282,17 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
 
             foreach (var globalPropertyValue in ExpressionShredder.SplitSemiColonSeparatedList(globalPropertyValues))
             {
-                yield return new ProjectItemInstance(
-                    project: outerBuild,
-                    itemType: InnerBuildReferenceItemName,
-                    includeEscaped: outerBuild.FullPath,
-                    directMetadata: new[] { new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}") },
-                    definingFileEscaped: outerBuild.FullPath);
+                var prSnapshot = new ProjectItemInstanceSnapshot(new List<(string, string)>()
+                {
+                    ( ItemMetadataNames.PropertiesMetadataName , $"{globalPropertyName}={globalPropertyValue}" ),
+                })
+                {
+                    ItemType = InnerBuildReferenceItemName,
+                    EvaluatedInclude = outerBuild.FullPath,
+                    FullPath = outerBuild.FullPath,
+                };
+
+                yield return prSnapshot;
             }
         }
 
@@ -309,7 +304,7 @@ private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(Pr
         /// </remarks>
         private static GlobalPropertyPartsForMSBuildTask ProjectReferenceGlobalPropertiesModifier(
             GlobalPropertyPartsForMSBuildTask defaultParts,
-            ProjectItemInstance projectReference)
+            ProjectItemInstanceSnapshot projectReference)
         {
             // ProjectReference defines yet another metadata name containing properties to undefine. Merge it in if non empty.
             var globalPropertiesToRemove = SplitPropertyNames(projectReference.GetMetadataValue(GlobalPropertiesToRemoveMetadataName));
@@ -369,7 +364,7 @@ public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyTo
             }
         }
 
-        private delegate GlobalPropertyPartsForMSBuildTask GlobalPropertiesModifier(GlobalPropertyPartsForMSBuildTask defaultParts, ProjectItemInstance projectReference);
+        private delegate GlobalPropertyPartsForMSBuildTask GlobalPropertiesModifier(GlobalPropertyPartsForMSBuildTask defaultParts, ProjectItemInstanceSnapshot projectReference);
 
         /// <summary>
         ///     Gets the effective global properties for an item that will get passed to <see cref="MSBuild.Projects"/>.
@@ -379,7 +374,7 @@ public GlobalPropertyPartsForMSBuildTask AddPropertyToUndefine(string propertyTo
         ///     and the <paramref name="globalPropertyModifiers"/> parameter can contain other mutations done at build time in targets / tasks
         /// </remarks>
         private static PropertyDictionary<ProjectPropertyInstance> GetGlobalPropertiesForItem(
-            ProjectItemInstance projectReference,
+            ProjectItemInstanceSnapshot projectReference,
             PropertyDictionary<ProjectPropertyInstance> requesterGlobalProperties,
             bool allowCollectionReuse,
             IEnumerable<GlobalPropertiesModifier> globalPropertyModifiers)
@@ -491,21 +486,21 @@ private TargetsToPropagate(ImmutableList<TargetSpecification> outerBuildTargets,
             /// <param name="project">Project containing the PRT protocol</param>
             /// <param name="entryTargets">Targets with which <paramref name="project"/> will get called</param>
             /// <returns></returns>
-            public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance project, ImmutableList<string> entryTargets)
+            public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstanceSnapshot project, ImmutableList<string> entryTargets)
             {
                 ImmutableList<TargetSpecification>.Builder targetsForOuterBuild = ImmutableList.CreateBuilder<TargetSpecification>();
                 ImmutableList<TargetSpecification>.Builder targetsForInnerBuild = ImmutableList.CreateBuilder<TargetSpecification>();
 
-                ICollection<ProjectItemInstance> projectReferenceTargets = project.GetItems(ItemTypeNames.ProjectReferenceTargets);
+                var projectReferenceTargets = project.ProjectReferenceByTargets;
 
                 foreach (string entryTarget in entryTargets)
                 {
-                    foreach (ProjectItemInstance projectReferenceTarget in projectReferenceTargets)
+                    foreach (var projectReferenceTarget in projectReferenceTargets)
                     {
                         if (projectReferenceTarget.EvaluatedInclude.Equals(entryTarget, StringComparison.OrdinalIgnoreCase))
                         {
                             string targetsMetadataValue = projectReferenceTarget.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
-                            bool skipNonexistentTargets = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue("SkipNonexistentTargets"));
+                            bool skipNonexistentTargets = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue(SkipNonexistentTargetsMetadataName));
                             bool targetsAreForOuterBuild = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName));
                             TargetSpecification[] targets = ExpressionShredder.SplitSemiColonSeparatedList(targetsMetadataValue)
                                 .Select(t => new TargetSpecification(t, skipNonexistentTargets)).ToArray();
@@ -524,18 +519,18 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj
                 return new TargetsToPropagate(targetsForOuterBuild.ToImmutable(), targetsForInnerBuild.ToImmutable());
             }
 
-            public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)
+            public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstanceSnapshot reference)
             {
                 ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSpecification> targets)
                 {
                     // Keep targets that are non-skippable or that exist but are skippable.
                     return targets
-                        .Where(t => !t.SkipIfNonexistent || reference.Targets.ContainsKey(t.Target))
+                        .Where(t => !t.SkipIfNonexistent || reference.Targets.Contains(t.Target))
                         .Select(t => t.Target)
                         .ToImmutableList();
                 }
 
-                return GetProjectType(reference) switch
+                return reference.ProjectType switch
                 {
                     ProjectType.InnerBuild => RemoveNonexistentTargetsIfSkippable(_allTargets),
                     ProjectType.OuterBuild => RemoveNonexistentTargetsIfSkippable(_outerBuildTargets),
@@ -545,10 +540,10 @@ ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSp
             }
         }
 
-        public bool RequiresTransitiveProjectReferences(ProjectInstance projectInstance)
+        public bool RequiresTransitiveProjectReferences(ProjectInstanceSnapshot projectInstance)
         {
             // Outer builds do not get edges based on ProjectReference or their transitive closure, only inner builds do.
-            if (GetProjectType(projectInstance) == ProjectType.OuterBuild)
+            if (projectInstance.ProjectType == ProjectType.OuterBuild)
             {
                 return false;
             }
@@ -556,8 +551,8 @@ public bool RequiresTransitiveProjectReferences(ProjectInstance projectInstance)
             // special case for Quickbuild which updates msbuild binaries independent of props/targets. Remove this when all QB repos will have
             // migrated to new enough Visual Studio versions whose Microsoft.Managed.After.Targets enable transitive references.
             if (string.IsNullOrWhiteSpace(projectInstance.GetPropertyValue(AddTransitiveProjectReferencesInStaticGraphPropertyName)) &&
-                MSBuildStringIsTrue(projectInstance.GetPropertyValue("UsingMicrosoftNETSdk")) &&
-                MSBuildStringIsFalse(projectInstance.GetPropertyValue("DisableTransitiveProjectReferences")))
+                MSBuildStringIsTrue(projectInstance.GetPropertyValue(UsingMicrosoftNETSdkPropertyName)) &&
+                MSBuildStringIsFalse(projectInstance.GetPropertyValue(DisableTransitiveProjectReferencesPropertyName)))
             {
                 return true;
             }
