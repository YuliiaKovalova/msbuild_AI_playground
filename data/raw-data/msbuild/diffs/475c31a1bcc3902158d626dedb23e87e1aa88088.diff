diff --git a/.config/git-merge-flow-config.jsonc b/.config/git-merge-flow-config.jsonc
new file mode 100644
index 00000000000..a58d3e867ea
--- /dev/null
+++ b/.config/git-merge-flow-config.jsonc
@@ -0,0 +1,34 @@
+// IMPORTANT: This file is read by the merge flow from main branch only. 
+{
+    "merge-flow-configurations": {
+        // MSBuild servicing chain from oldest supported through currently-supported to main
+        // Automate opening PRs to merge msbuild's vs16.11 (VS until 4/2029) into vs17.0 (SDK 6.0.1xx)
+        "vs16.11": {
+            "MergeToBranch": "vs17.0"
+        },
+        // Automate opening PRs to merge msbuild's vs17.0 (SDK 6.0.1xx) into vs17.3 (SDK 6.0.4xx)
+        "vs17.0": {
+            "MergeToBranch": "vs17.3"
+        },
+        // Automate opening PRs to merge msbuild's vs17.3 (SDK 6.0.4xx) into vs17.6 (VS until 1/2025)
+        "vs17.3": {
+            "MergeToBranch": "vs17.6"
+        },
+        // Automate opening PRs to merge msbuild's vs17.6 into vs17.8 (VS until 7/2025)
+        "vs17.6": {
+            "MergeToBranch": "vs17.8"
+        },
+        // Automate opening PRs to merge msbuild's vs17.8 (SDK 8.0.1xx) into vs17.10 (SDK 8.0.3xx)
+        "vs17.8": {
+            "MergeToBranch": "vs17.10"
+        },
+        // Automate opening PRs to merge msbuild's vs17.10 (SDK 8.0.3xx) into vs17.11 (SDK 8.0.4xx)
+        "vs17.10": {
+            "MergeToBranch": "vs17.11"
+        },
+        // MSBuild latest release to main
+        "vs17.11": {
+            "MergeToBranch": "main"
+        }
+    }
+}
\ No newline at end of file
diff --git a/.config/guardian/.gdnbaselines b/.config/guardian/.gdnbaselines
index 7c1e70b5438..cd66fbded9f 100644
--- a/.config/guardian/.gdnbaselines
+++ b/.config/guardian/.gdnbaselines
@@ -11,47 +11,44 @@
     }
   },
   "results": {
-    "1757d0179485ad6618415e151de2453f25d5484071f7bae328fa9ca9d4d54688": {
-      "signature": "1757d0179485ad6618415e151de2453f25d5484071f7bae328fa9ca9d4d54688",
-      "alternativeSignatures": [],
-      "target": "src/Tasks.UnitTests/TestResources/mycert.pfx",
-      "line": 1,
+    "24491acb7bf0f8b072d9fbd2f6efcf1bdf6e9506ff3f7a9f9c803445c55b7bd9": {
+      "signature": "24491acb7bf0f8b072d9fbd2f6efcf1bdf6e9506ff3f7a9f9c803445c55b7bd9",
+      "alternativeSignatures": [
+        "2dc3f5f5423a151deb6a74413f2798ade061c1f50519daeed42acfd2caebed03"
+      ],
+      "target": ".packages/drop.app/18.165.29912-buildid11693003/lib/net45/ContentStoreApp.Full/x64/BuildXLAria.dll",
       "memberOf": [
         "default"
       ],
-      "tool": "credscan",
-      "ruleId": "CSCAN-GENERAL0020",
-      "createdDate": "2024-03-14 11:30:33Z",
-      "expirationDate": "2024-08-31 12:48:32Z",
-      "justification": "This error is baselined with an expiration date of 180 days from 2024-03-14 12:48:32Z"
+      "tool": "binskim",
+      "ruleId": "BA2008",
+      "createdDate": "2024-06-19 17:22:41Z"
     },
-    "60d4d52e838e08dc19d3ac2b43b7c809b080db55f9c754b80bd60f30624e9687": {
-      "signature": "60d4d52e838e08dc19d3ac2b43b7c809b080db55f9c754b80bd60f30624e9687",
-      "alternativeSignatures": [],
-      "target": "artifacts/bin/Microsoft.Build.Tasks.UnitTests/Release/net472/TestResources/mycert.pfx",
-      "line": 1,
+    "1dc1a6797e20d1319df1cb8d4df5c6f6194ce4e87151bf801fb9bf2d038ccfaf": {
+      "signature": "1dc1a6797e20d1319df1cb8d4df5c6f6194ce4e87151bf801fb9bf2d038ccfaf",
+      "alternativeSignatures": [
+        "f52bc24a2feebdcb7b1192ac2debea8da9ca5d012a6719e905b16f979711ceca"
+      ],
+      "target": ".packages/drop.app/18.165.29912-buildid11693003/lib/net45/ContentStoreApp.Full/x64/BuildXLNatives.dll",
       "memberOf": [
         "default"
       ],
-      "tool": "credscan",
-      "ruleId": "CSCAN-GENERAL0020",
-      "createdDate": "2024-03-14 12:01:14Z",
-      "expirationDate": "2024-08-31 12:48:32Z",
-      "justification": "This error is baselined with an expiration date of 180 days from 2024-03-14 12:48:32Z"
+      "tool": "binskim",
+      "ruleId": "BA2008",
+      "createdDate": "2024-06-19 17:22:41Z"
     },
-    "7cb5d42a8744e4a214149aa27d3d8a1b7989914d1a2fee8cea13287368cbafff": {
-      "signature": "7cb5d42a8744e4a214149aa27d3d8a1b7989914d1a2fee8cea13287368cbafff",
-      "alternativeSignatures": [],
-      "target": "artifacts/bin/Microsoft.Build.Tasks.UnitTests/Release/net8.0/TestResources/mycert.pfx",
-      "line": 1,
+    "5bf3f552d54adcae12d7f1e79d47b5a9392c774f03943793cd1a0f7bb2eef28b": {
+      "signature": "5bf3f552d54adcae12d7f1e79d47b5a9392c774f03943793cd1a0f7bb2eef28b",
+      "alternativeSignatures": [
+        "ea4d59d18cbff7ffab4bb678927fc6fee763539a51cfbf5aae60ae1b8123a6ba"
+      ],
+      "target": ".packages/drop.app/18.165.29912-buildid11693003/lib/net45/ContentStoreApp.Full/x64/ClientTelemetry.dll",
       "memberOf": [
         "default"
       ],
-      "tool": "credscan",
-      "ruleId": "CSCAN-GENERAL0020",
-      "createdDate": "2024-03-14 12:01:14Z",
-      "expirationDate": "2024-08-31 12:48:32Z",
-      "justification": "This error is baselined with an expiration date of 180 days from 2024-03-14 12:48:32Z"
+      "tool": "binskim",
+      "ruleId": "BA2007",
+      "createdDate": "2024-06-19 17:22:41Z"
     }
   }
-}
\ No newline at end of file
+}
diff --git a/.exp-insertions.yml b/.exp-insertions.yml
index acee0786cb0..40aa1dda370 100644
--- a/.exp-insertions.yml
+++ b/.exp-insertions.yml
@@ -155,6 +155,21 @@ jobs:
       nugetConfigPath: '$(Build.SourcesDirectory)\NuGet.config'
       restoreDirectory: '$(Build.SourcesDirectory)\.packages'
 
+  # https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/1es-security-configuration/configuration-guides/pat-burndown-guidance#authentication-from-pipelines
+  # Requires Azure client 2.x
+  - task: AzureCLI@2
+    displayName: 'Set AzDO.DotnetPerfStarToken'
+    enabled: true
+    inputs:
+      azureSubscription: 'dotnet-perfstar at app.vssps.visualstudio.com'   # Azure DevOps service connection
+      scriptType: 'pscore'
+      scriptLocation: 'inlineScript'
+      inlineScript: |
+        # '499b84ac-1321-427f-aa17-267ca6975798' for Azure DevOps
+        $token = az account get-access-token --query accessToken --resource 499b84ac-1321-427f-aa17-267ca6975798 -o tsv
+        Write-Host "Setting AzDO.DotnetPerfStarToken"
+        Write-Host "##vso[task.setvariable variable=AzDO.DotnetPerfStarToken]${token}"
+
   - powershell: |
       mkdir "$(Pipeline.Workspace)/artifacts"
 
@@ -166,7 +181,7 @@ jobs:
       Write-Host "Detected drop.exe path: $dropExePath"
 
       Write-Host "Downloading VS msbuild"
-      $patAuthEnvVar = "SYSTEM_ACCESSTOKEN"
+      $patAuthEnvVar = "patVariable"
       & "$dropExePath" get --patAuthEnvVar $patAuthEnvVar -u "$(MSBuildDropPath)\$(VSVersion)" -d "$(System.ArtifactsDirectory)/VSMSBuildDrop"
       Write-Host "Download of VS msbuild finished"
 
@@ -175,7 +190,7 @@ jobs:
       Write-Host "Copy of VS msbuild finished"
     displayName: Download msbuild vs drop
     env:
-      SYSTEM_ACCESSTOKEN: $(System.AccessToken)
+      patVariable: $(AzDO.DotnetPerfStarToken)
 
   - task: DownloadBuildArtifacts@1
     inputs:
diff --git a/.gitattributes b/.gitattributes
index af9d9e931ae..964a7141374 100644
--- a/.gitattributes
+++ b/.gitattributes
@@ -24,3 +24,6 @@ eng/common/** linguist-vendored linguist-generated
 
 # Display XLF files collapsed by default in PR diffs
 *.xlf linguist-generated=true
+
+# VerifyTests
+*.verified.txt text eol=lf working-tree-encoding=UTF-8
\ No newline at end of file
diff --git a/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml b/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
new file mode 100644
index 00000000000..7af03649c5e
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/07_buildchecksuggestion.yml
@@ -0,0 +1,27 @@
+name: 💡 BuildCheck Suggestion
+description: Suggesting a diagnostic check (AKA [BuildCheck](https://github.com/dotnet/msbuild/blob/main/documentation/specs/BuildCheck/BuildCheck.md)) that MSBuild could provide.
+title: "[BuildCheck Suggestion]: "
+labels: ["BuildCheck Suggestion", "Area: BuildCheck"]
+body:
+  - type: textarea
+    attributes:
+      label: Summary
+      description: Brief summary of what this proposal is about.
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Background and Motivation
+      description: What is the problem MSBuild should be flagging and in what context did you encounter it?
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Sample issue or antipattern that the check should be flagging
+      description: Please provide as specific as possible sample that you envision to be catched by the check.
+    validations:
+      required: true
+  - type: textarea
+    attributes:
+      label: Sample output
+      description: If you have an idea what and how to report - please try to provide possible sample.
diff --git a/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
new file mode 100644
index 00000000000..edf0c00532e
--- /dev/null
+++ b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
@@ -0,0 +1,171 @@
+name: Sync Microsoft.Build version in analyzer template with Version.props
+on:
+  push:
+    branches:
+      - main
+    paths:
+      - 'eng/Versions.props'
+
+jobs:
+  Sync-version:
+    runs-on: ubuntu-latest
+
+    steps:
+    - name: Checkout repository
+      uses: actions/checkout@v3
+
+    - name: Set baseBranch variable
+      id: vars
+      run: echo "baseBranch=${{ github.ref_name }}" >> $GITHUB_ENV
+
+    - name: Update analyzer template version with version from Versions.props
+      shell: pwsh
+      run: |
+        try {
+            # Define the paths to your XML and JSON files
+            $xmlFilePath = "eng/Versions.props"
+            $jsonFilePath = "template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json"
+
+            # Check if the XML file exists
+            if (-Not (Test-Path -Path $xmlFilePath)) {
+                throw "Versions.props file not found: $xmlFilePath"
+            }
+
+            # Load and parse the XML content
+            [xml]$xmlContent = Get-Content -Path $xmlFilePath
+            $versionPrefix = [string]$xmlContent.Project.PropertyGroup.VersionPrefix
+            $versionPrefix = $versionPrefix.Trim()
+
+            # Validate the versionPrefix
+            if ([string]::IsNullOrWhiteSpace($versionPrefix)) {
+                throw "VersionPrefix is empty or null in the XML file: $xmlFilePath"
+            }
+
+            # Check if the JSON file exists
+            if (-Not (Test-Path -Path $jsonFilePath)) {
+                throw "Analyzer template file not found: $jsonFilePath"
+            }
+
+            # Load the JSON template
+            $jsonContent = Get-Content -Path $jsonFilePath -Raw | ConvertFrom-Json
+
+            # Check if the versionPrefix is different from the current defaultValue
+            if ($versionPrefix -ne $jsonContent.symbols.MicrosoftBuildVersion.defaultValue) {
+                # Update the defaultValue of MicrosoftBuildVersion in the JSON template
+                $jsonContent.symbols.MicrosoftBuildVersion.defaultValue = $versionPrefix
+        
+                # Convert the JSON content back to a string
+                $jsonString = $jsonContent | ConvertTo-Json -Depth 10
+        
+                # Write the updated JSON back to the file
+                Set-Content -Path $jsonFilePath -Value $jsonString
+                Write-Output "Updated MicrosoftBuildVersion to $versionPrefix"
+        
+                # Set the updateNeeded output variable to true
+                $updateNeeded = "true"
+            } else {
+                Write-Output "No update needed. MicrosoftBuildVersion is already $versionPrefix"
+        
+                # Set the updateNeeded output variable to false
+                $updateNeeded = "false"
+            }
+
+            # Set the versionPrefix and template filePath as an output
+            Add-Content -Path $env:GITHUB_ENV -Value "versionPrefix=$versionPrefix"
+            Add-Content -Path $env:GITHUB_ENV -Value "jsonFilePath=$jsonFilePath"
+            Add-Content -Path $env:GITHUB_ENV -Value "updateNeeded=$updateNeeded"
+            Write-Output "Extracted versionPrefix: $versionPrefix"
+            Write-Output "Extracted jsonFilePath: $jsonFilePath"
+            Write-Output "Update needed: $updateNeeded"
+        }
+        catch {
+            Write-Error "An error occurred: $_"
+        }
+
+    - name: Create Pull Request
+      if: env.updateNeeded == 'true'
+      uses: actions/github-script@v7
+      with:
+        script: |
+          const baseBranch = process.env.baseBranch;
+          const versionPrefix = process.env.versionPrefix;
+          const filePath = process.env.jsonFilePath;
+          const newBranch = `${baseBranch}-update-msbuild-version-for-analyzer-template`;
+          const commitMessage = `Update MicrosoftBuildVersion to ${versionPrefix}`;
+          const prBody = '[Automated] Update the MicrosoftBuildVersion defaultValue in the template.json.';
+          const prTitle = 'Update MicrosoftBuildVersion in analyzer template';
+          
+          // Main execution
+          (async () => {
+            try {
+              // Configure git
+              await configureGit();
+          
+              // Create and switch to the new branch
+              await createAndSwitchBranch(newBranch);
+          
+              // Check if the branch PR already exists on the remote
+              const shouldOpenPullRequest = await checkBranchPRExists(newBranch,baseBranch);
+          
+              // Stage and commit the changes
+              await stageAndCommitChanges(filePath, commitMessage);
+          
+              // Push the new branch to the repository
+              await pushBranch(newBranch);
+          
+              // Create the pull request if needed
+              if (shouldOpenPullRequest) {
+                await createPullRequest(baseBranch, newBranch, prTitle, prBody);
+              } else {
+                console.log("The PR already exists, skipping opening a new PR.");
+              }
+            } catch (error) {
+              core.setFailed(error);
+            }
+          })();
+          
+          async function configureGit() {
+            await exec.exec(`git config user.name "github-actions"`);
+            await exec.exec(`git config user.email "github-actions@github.com"`);
+          }
+          
+          async function createAndSwitchBranch(branch) {
+            await exec.exec('git', ['checkout', '-b', branch]);
+          }
+          
+          async function checkBranchPRExists(newBranch,baseBranch) {
+            // Check if a pull request already exists
+            const { data: pullRequests } = await github.rest.pulls.list({
+              owner: context.repo.owner,
+              repo: context.repo.repo,
+              head: newBranch,
+              base: baseBranch,
+              state: 'open',
+            });
+          
+            if (pullRequests.length === 0) {
+              return true;
+            } else {
+              return false;
+            }
+          }
+          
+          async function stageAndCommitChanges(filePath, commitMessage) {
+            await exec.exec(`git add ${filePath}`);
+            await exec.exec(`git commit -m "${commitMessage}"`);
+          }
+          
+          async function pushBranch(branch) {
+            await exec.exec(`git push --force --set-upstream origin HEAD:${branch}`);
+          }
+          
+          async function createPullRequest(baseBranch, newBranch, title, body) {
+            await github.rest.pulls.create({
+              owner: context.repo.owner,
+              repo: context.repo.repo,
+              title: title,
+              body: body,
+              head: newBranch,
+              base: baseBranch
+            });
+          }
diff --git a/.github/workflows/inter-branch-merge-flow.yml b/.github/workflows/inter-branch-merge-flow.yml
new file mode 100644
index 00000000000..68fdef4127b
--- /dev/null
+++ b/.github/workflows/inter-branch-merge-flow.yml
@@ -0,0 +1,15 @@
+name: Inter-branch merge workflow
+on:
+  push:
+    branches:
+      - vs1**
+
+permissions:
+  contents: write
+  pull-requests: write
+
+jobs:
+  Merge:
+    uses: dotnet/arcade/.github/workflows/inter-branch-merge-base.yml@main
+    with:
+      configuration_file_path: '.config/git-merge-flow-config.jsonc'
\ No newline at end of file
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index daf200ae88e..6df5156b632 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -15,11 +15,11 @@ jobs:
       $isVersionBumped = $false
       if ($changedVersionsFile -ne $null) {
         $difference = git diff HEAD~1 $versionsFile
-        $changedContent = $difference -join " "
+        $changedContent = $difference -join "%"
         # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
-        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix> \+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>.*<DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
+        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
         $isInitialCommit = $changedContent -match $initialCommitPattern
-        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.* \+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
+        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
         if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
           try {
             $previousPatch = [Convert]::ToInt32($Matches.previous)
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 3bf73e47ab0..568f2af4ae9 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -34,7 +34,7 @@ variables:
     - name: SourceBranch
       value: ''
   - name: EnableReleaseOneLocBuild
-    value: true
+    value: true # Enable loc for vs17.12
   - name: Codeql.Enabled
     value: true
   - group: DotNet-MSBuild-SDLValidation-Params
@@ -57,6 +57,12 @@ extends:
       # We generate SBOM ourselves, so don't need steps injected by 1ES.
       sbom:
         enabled: false
+      codeSignValidation:
+        enabled: true
+        break: true
+        additionalTargetsGlobPattern: -|**\bootstrapper\**\vs_enterprise.exe
+      credscan:
+        suppressionsFile: $(Build.SourcesDirectory)/eng/CredScanSuppressions.json
 
     stages:
     - stage: build
@@ -176,7 +182,6 @@ extends:
             channelName: $(VisualStudio.ChannelName)
             manifests: $(VisualStudio.SetupManifestList)
             outputFolder: '$(Build.SourcesDirectory)\artifacts\VSSetup\$(BuildConfiguration)\Insertion'
-            bootstrapperCoreVersion:
           displayName: 'OptProf - Build VS bootstrapper'
           condition: succeeded()
 
@@ -208,13 +213,6 @@ extends:
             ArtifactName: logs
           condition: succeededOrFailed()
 
-        - task: 1ES.PublishPipelineArtifact@1
-          displayName: 'Publish Artifact: bin'
-          inputs:
-            path: 'artifacts\bin'
-            artifactName: bin
-          condition: succeededOrFailed()
-
         # Publishes setup VSIXes to a drop.
         # Note: The insertion tool looks for the display name of this task in the logs.
         - task: 1ES.MicroBuildVstsDrop@1
diff --git a/MSBuild.Dev.slnf b/MSBuild.Dev.slnf
index 79c1a4edfdf..893aa59154f 100644
--- a/MSBuild.Dev.slnf
+++ b/MSBuild.Dev.slnf
@@ -4,6 +4,7 @@
     "projects": [
       "src\\Build.OM.UnitTests\\Microsoft.Build.Engine.OM.UnitTests.csproj",
       "src\\Build.UnitTests\\Microsoft.Build.Engine.UnitTests.csproj",
+      "src\\BuildCheck.UnitTests\\Microsoft.Build.BuildCheck.UnitTests.csproj",
       "src\\Build\\Microsoft.Build.csproj",
       "src\\Framework.UnitTests\\Microsoft.Build.Framework.UnitTests.csproj",
       "src\\Framework\\Microsoft.Build.Framework.csproj",
@@ -18,4 +19,4 @@
       "src\\Xunit.NetCore.Extensions\\Xunit.NetCore.Extensions.csproj"
     ]
   }
-}
\ No newline at end of file
+}
diff --git a/NuGet.config b/NuGet.config
index d7187b4d64a..e54eda8378c 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -2,6 +2,15 @@
 <configuration>
   <packageSources>
     <clear />
+    <!--Begin: Package sources managed by Dependency Flow automation. Do not edit the sources below.-->
+    <!--  Begin: Package sources from dotnet-runtime -->
+    <add key="darc-int-dotnet-runtime-2aade6b" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be/nuget/v3/index.json" />
+    <add key="darc-int-dotnet-runtime-2aade6b-5" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be-5/nuget/v3/index.json" />
+    <add key="darc-int-dotnet-runtime-2aade6b-3" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be-3/nuget/v3/index.json" />
+    <add key="darc-int-dotnet-runtime-2aade6b-2" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be-2/nuget/v3/index.json" />
+    <add key="darc-int-dotnet-runtime-2aade6b-1" value="https://pkgs.dev.azure.com/dnceng/internal/_packaging/darc-int-dotnet-runtime-2aade6be-1/nuget/v3/index.json" />
+    <!--  End: Package sources from dotnet-runtime -->
+    <!--End: Package sources managed by Dependency Flow automation. Do not edit the sources above.-->
     <add key="arcade" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/index.json" />
     <add key="dotnet-public" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public/nuget/v3/index.json" />
     <add key="dotnet-tools" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json" />
@@ -10,5 +19,15 @@
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
     <add key="BuildXL" value="https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json" />
   </packageSources>
-  <disabledPackageSources />
+  <disabledPackageSources>
+    <!--Begin: Package sources managed by Dependency Flow automation. Do not edit the sources below.-->
+    <!--  Begin: Package sources from dotnet-runtime -->
+    <add key="darc-int-dotnet-runtime-2aade6b-1" value="true" />
+    <add key="darc-int-dotnet-runtime-2aade6b-2" value="true" />
+    <add key="darc-int-dotnet-runtime-2aade6b-3" value="true" />
+    <add key="darc-int-dotnet-runtime-2aade6b-5" value="true" />
+    <add key="darc-int-dotnet-runtime-2aade6b" value="true" />
+    <!--  End: Package sources from dotnet-runtime -->
+    <!--End: Package sources managed by Dependency Flow automation. Do not edit the sources above.-->
+  </disabledPackageSources>
 </configuration>
diff --git a/README.md b/README.md
index f770f459200..e3e7823cb10 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,8 @@
 # Microsoft.Build (MSBuild)
 
+[![Build Status](https://dev.azure.com/dnceng-public/public/_apis/build/status/75?branchName=main&label=Public)](https://dev.azure.com/dnceng-public/public/_build?definitionId=75) [![Build Status](https://devdiv.visualstudio.com/DevDiv/_apis/build/status/9434?label=Internal&branchName=main)](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434)
+
+
 The Microsoft Build Engine is a platform for building applications. This engine, also known as MSBuild, provides an XML schema for a project file that controls how the build platform processes and builds software. Visual Studio uses MSBuild, but MSBuild can run without Visual Studio. By invoking msbuild.exe on your project or solution file, you can orchestrate and build products in environments where Visual Studio isn't installed.
 
 For more information on MSBuild, see the [MSBuild documentation](https://learn.microsoft.com/visualstudio/msbuild/msbuild) on learn.microsoft.com.
diff --git a/documentation/High-level-overview.md b/documentation/High-level-overview.md
new file mode 100644
index 00000000000..4ee9aaa9e30
--- /dev/null
+++ b/documentation/High-level-overview.md
@@ -0,0 +1,279 @@
+# What is MSBuild
+MSBuild is a build platform used mainly for .NET and Visual Studio. When referencing MSBuild technically we can divide what MSBuild is in a few main parts:
+- Programming language that uses XML to define build actions and data.
+- A standard set of scripts authored in the MSBuild language (so called 'common targets') that are shipped together with the MSBuild binaries and that define what a build process means.
+- API and command line interface that interprets and requests results from programs written in the programming language.
+- Build engine that executes a build based on the programming language inputs.
+
+MSBuild is extensible via XML and .NET plugins. These are built to increase customization and interaction capability.
+
+This document covers all parts of MSBuild in a general manner from the perspective of an MSBuild codebase maintainer. There will be no in depth technical details, or how-to's. If you'd like to learn how to use MSBuild to improve your builds please visit Microsoft Learn's [MSBuild documentation](https://learn.microsoft.com/visualstudio/msbuild).
+
+
+# MSBuild XML Language
+The MSBuild markup language is a subset of XML with a focus on describing a project. An advanced example of this is our own [MSBuild executable's project](../src/MSBuild/MSBuild.csproj).
+
+An MSBuild project file primarily declares a project's data. It uses various XML elements to do so:
+- [Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-properties) are name value pairs, they're used to store data that is used within the project.
+- [Items](https://learn.microsoft.com/visualstudio/msbuild/msbuild-items) are data enumerations, where single element is a string value with optional enumeration of key-value strings - so called `metadata`. `Items` represent project files, code files, libraries and most things that a project can depend on. Together with `Properties`, `Items` are data inputs to the build system - mostly to tasks or targets.
+- [Tasks](https://learn.microsoft.com/visualstudio/msbuild/msbuild-tasks) are how actions are defined in MSBuild, they're a unit of executable code to perform build operations. Many tasks are defined within MSBuild itself, but tasks can also be authored by third parties by implementing the `ITask` interface.
+- [Targets](https://learn.microsoft.com/visualstudio/msbuild/msbuild-targets) represents a group of tasks, in which their order matters. It is a set of instructions for the MSBuild engine to execute. Targets can be ordered relative to other targets.
+
+These attributes are defined within project files (`.csproj`, `.vbproj` etc.). Solution files (`.sln`) are not an MSBuild XML format. They are originally exclusive to Visual Studio, but the MSBuild command-line application can parse them to find projects to build.
+
+While the project file defines the data used for the build, the actual build instructions are generally imported from a common location through the `Import` element or [MSBuild SDKs](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk) that contain their own tasks and targets. One example that is widely used is the [`Microsoft.NET.Sdk`](https://learn.microsoft.com/dotnet/core/project-sdk/overview) from the .NET SDK.
+
+
+# Common Targets
+MSBuild has some Common Targets that adds baseline functionality to the build. This functionality includes build management, like the creation and management of output folders and intermediary folders, defining a project's “primary output”, implementing the [`ProjectReference` protocol](ProjectReference-Protocol.md), and so on.
+
+Visual Studio also depends on the common targets to enable configuring the build through UI and checkboxes, making sure that the user has access to those options and there is not a need to modify the project file XML directly. Some use cases for Visual Studio also include:
+- Population of the Solution Explorer window. For each project, what files need to be added to the view of the complete solution.
+- Executing [design-time builds](https://github.com/dotnet/project-system/blob/500720852f21ac8496390827881eabe4d718c5e2/docs/design-time-builds.md) to extract more detailed information for Visual Studio components like language services.
+
+
+# MSBuild API
+The MSBuild API is a .NET library that can build, fetch data from, and edit MSBuild projects. It is used by Visual Studio and the .NET SDK to integrate MSBuild as their project build system. This API is also available for any third parties to use.
+
+
+# Engine
+The MSBuild Engine's main responsibility is to execute the build instructions and process the results of builds. This includes managing the extensibility that MSBuild offers, integrating customizations into the build process even if they're authored by third parties.
+
+The MSBuild engine's logic is divided into two main stages: 
+- evalution stage
+- execution stage.
+
+```mermaid
+---
+title: MSBuild engine parts
+---
+flowchart LR
+    subgraph Build inputs
+    I["`Inputs
+    _.proj_ file`"]
+    API([API])
+    end
+    
+    subgraph API consumers
+    VS[Visual Studio] --> API
+    SDK[.NET SDK] --> API
+    NC[NuGet Client] --> API
+    E[Extensibilities] --> API
+    end
+
+    API & I --> EN[Entry Point Node 
+    and Scheduler]
+    
+    EN --IPC--> WN[Worker Nodes]
+    WN <--IPC--> TH[Task Host]
+    L[Loggers] --> EN
+    WN --> FW[Forwarding Loggers] --> EN
+```
+
+## Entry points
+There are a few entry points for the MSBuild engine: Visual Studio, .NET SDK (`dotnet build` command) and the CLI executable (`MSBuild.exe` on Windows, and `msbuild` in unix). These partner products are implementations or extensions of the MSBuild API, and we do care about their smooth integration with MSBuild, but do not support them directly.
+
+The inputs necessary to start a build include:
+ - Build logic for the projects, typically the entry point project's XML or from the imports within.
+ - User defined imports
+ - The generated build imports (`.g.props` and `.g.targets`) from NuGet restore.
+
+ ```mermaid
+flowchart TD    
+    UL["`User defined import logic
+    _.props_ and _.targets_`"]
+    
+    PROJ["`_.proj_ file`"
+    eg. Foo.csproj]
+    
+    IL[Common Targets Logic
+    SDK or VS]
+
+    NI["`NuGet imports
+    _.g.props_ and _.g.targets_`"]
+
+    UL --> PROJ
+    IL --> PROJ
+    NI --> PROJ
+ ```
+
+An example of the imported build logic is the `<Project Sdk="Microsoft.NET.Sdk">` that can be seen in some of the built-in .NET templates. This indicates that the project will use build logic from the `Microsoft.NET.Sdk` component comes with the .NET SDK.
+
+More on this in the [Restore](#restore) section below.
+
+## Project Evaluation
+For more detailed information on evaluation visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#evaluation-phase).
+
+Evaluation of a project is the first step of the process. Its main objective is to collect information on the project being built. This includes checking the entry point project for imports, items, and tasks. Some API consumers, like Visual Studio project systems, extract information about which C# files, solution files and project files are relevant to a project after evaluation.
+
+The first step of evaluation is to load XML project file. There are multiple evaluation passes within the same project; each is responsible for evaluating a different type of data that may be required for subsequent passes. Data within the evaluation can be modified depending on the pass the build is currently executing. For example, during the pass that evaluates imports and properties, properties can be modified, but after that pass is done the properties are read-only until the execution phase.
+
+```mermaid
+---
+title: Evaluation passes 
+---
+flowchart LR
+    PE[Project evaluation] --> 
+    EV[Environment variables] --> 
+    IP[Imports and Properties 
+    outside targets] -->
+    ID[Item definitions] -->
+    IO[Items outside targets] -->
+    UE[UsingTasks] -->
+    T[Targets]
+```
+
+Evaluation may occur before or after NuGet restore has run. Since NuGet packages can contain build logic, the pre-restore evaluation should be used only to run restore. After restore, all imports are files on disk and are processed as paths by the engine.
+
+The evaluation stage should not have any side effect on disk, no new or deleted files. One exception is the SDK resolution phase. The .NET SDK resolver looks for SDKs already installed or existing on disk. But MSBuild also has support for resolvers that can run arbitrary .NET code such as referencing SDKs through a network share or fetching SDK packages from a remote server.
+One such resolver that comes with the .NET SDK and Visual Studio is the NuGet's MSBuild SDK resolver (`Microsoft.Build.NuGetSdkResolver`) which downloads the SDK packages from NuGet repositories to local storage.
+
+### Imports
+In MSBuild imports are all treated like a property plus path expansion, however they can take various forms when being defined - a disk path, a property expansion, a known folder, or even environmental variables. There are also some main imports that come with the execution on other platforms, like the Visual Studio or SDK can have import directories that contain wild card imports.
+
+Historically a single version of MSBuild supported multiple `ToolsVersions` that could result in differing imports for the same expression, but today an MSBuild distribution provides only the current version of `ToolsVersion` and selection between versions is expected to be done outside of MSBuild.
+
+## Project Execution
+For more detailed information on execution phase visit [Microsoft Learn](https://learn.microsoft.com/visualstudio/msbuild/build-process-overview#execution-phase).
+
+The execution phase starts with a request to build a list of targets defined in the project (in its own XML or an import). Those targets and their prerequisite targets will then execute. The order of executed targets is defined using a few attributes: `BeforeTargets`, `DependsOnTargets`, and `AfterTargets`. However, the order in which targets are executed during a build will not strictly follow the one defined by those attributes as it depends on more things during a build. The full executing order can be [found here](https://learn.microsoft.com/visualstudio/msbuild/target-build-order#determine-the-target-build-order).
+
+Another target order issue arises when there is a project dependency. Project dependencies are expressed using the `MSBuild` task, so a project target can start executing and then hit a project dependency that has not been completed yet. In this case, the project that is processing the targets will be considered blocked, and will pause its execution (the node building it may be used to work on another project). Once the dependencies have been fullfilled, the original build can resume resume and the target execution will continue in the original order.
+
+### Task Host
+MSBuild generally runs tasks in its own process, but has an ability to run tasks out of process via the “task host”. That allows tasks to run in a different .NET runtime or processor architecture than the one used by the build engine for the build execution.
+
+A specific task host is automatically selected when a task explicitly declares the need for a specific runtime or architecture that is different from the one used by the executing MSBuild engine. The runtime and architecture can be requested via `Runtime` and `Architecture` attributes in [`UsingTask`](https://learn.microsoft.com/visualstudio/msbuild/usingtask-element-msbuild) element defining the task or in the [`Task`](https://learn.microsoft.com/visualstudio/msbuild/task-element-msbuild) element used for task invocation.
+
+TaskHost can be opted-in via `TaskFactory="TaskHostFactory"` in the [`UsingTask`](https://learn.microsoft.com/visualstudio/msbuild/usingtask-element-msbuild) element defining the task. This opt-in behavior can be used for various cases:
+- If a task's source code is in the same repository that is being built, and the repository's build needs to use that task during the build process. Using a Task Host makes sure the DLLs are not locked at the end of the build (as MSBuild uses long living worker nodes that survives single build execution)
+- As an isolation mechanism - separating the execution from the engine execution process.
+
+## Caches
+### Project result cache
+The project Result Cache refers to the cache used by the scheduler that keeps the build results of already executed project. The result of a target is success, failure, and a list of items that succeeded. Beyond that, the `Returns` and `Outputs` attributes from targets are also serialized with the build result, as to be used by other targets for their execution.
+
+There is also another Project Cache Plugin, which focuses on result cache in distributed builds. More information about it is in the [Extensibility](#extensibility) section.
+
+### Register Task Objects
+During execution tasks might need to share state meaningfully between invocations in a single build or across builds. The MSBuild engine provides a mechanism to manage the lifetime of .NET objects to fill this gap. This lifetime can be defined by the user but has specific scopes: it can live per build or indefinitely. However, this mechanism is only available for communication within the same execution node, and it is not serializable.
+
+### Incremental Build Cache
+The build incrementality is controled by individual `Tasks` and `Targets`. Targets can define their `Inputs` and `Outputs` - and if both specified, MSBuild engine will skip execution of `Targets` that are deemed up to date. Tasks may also internally implement incremental behavior.
+For this reason many `Targets` in the MSBuild SDK, that perform intermediate operations, specifies explicit `Inputs` and `Outputs` - while flushing the outputs usually into `IntermediateOutputDirectory` (AKA the 'obj' directory). This helps to follow the incrementality of the build. The `IntermediateOutputDirectory` can hence be regarded as the incremental build cache - though it's not any centraly managed cache with a single de/serialization mechanism. Each Target controls the way how it wants to create and read the intermediate files. The Targets within MSBuild SDK store only up front know data types (no type information is being stored into the cache).
+
+#### RAR Cache
+A special case of incremental build cache within a task implementation is the `ResolveAssemblyReference` (RAR) cache.
+[`ResolveAssemblyReference`](../../src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs) (RAR) is one of the most important tasks in the MSBuild toolset. It is responsible for computing the closure of all references needed to build the project and resolving the full paths to the assemblies representing those references (so that the compiler task can operate on a fully defined input). For more information on RAR please see [the RAR documentation](../documentation/wiki/ResolveAssemblyReference.md).
+To speed subsequent runs over identical or almost-identical inputs, RAR stores assembly information in an intermediate file. The cache content is de/serialized via a custom MSBuild serialization protocol (`ITranslatable`).
+
+## Scheduler
+The scheduler is the part of the MSBuild engine responsible for scheduling work, as well as maintaining and managing the result of already executed projects. When a build starts, the scheduler assigns the entry point project to a worker node (generally the in-proc node). The project's execution starts and proceeds until the whole project ends or is blocked. A project is considered blocked when the project that it is currently building depends on another project that has not yet finished executing. When a node becomes free because it has completed its project or its project is blocked, the scheduler then assesses if it has more work to be given to that node and assigns it.
+
+When a build request completes, the result is sent to the scheduler. The scheduler maintains results of all of the build's executed requests, so when a project or target depends on another to proceed execution, the scheduler can just retrieve that information from the Project Result Cache. This means that a project can be built only once even if referenced by many projects.
+
+If the node's operation is blocked by a dependency, it asks the scheduler for the results of the dependency's execution. If the dependency has been executed, the result is retrieved from the Project Result Cache. If the process has not been executed, the scheduler suspends the current project, making the target / project a pending request. When a request is pending, the scheduler adds to the list of requests to execute, and will eventually assign the dependency to be executed on either the current node or another one that is free.
+
+```mermaid
+flowchart TD
+   A1[Build Request] --> S1[Scheduler]
+   
+   S1 --> C1{Is cached}
+   C1 --Yes--> Result1[Return result]
+   C1 -- No --> Build1[Build Project]
+
+   Build1 --> HD{Has 
+   Dependency}
+   HD --No --> PF[Project Finished]
+   HD --Yes --> DI[Identify Project Dependency]
+
+   DI --Request Dependency Build--> S1
+```
+
+### Incremental build
+Incremental builds are extremely useful for local development, as it speeds consecutive builds on local machines. For this, the output from build targets is persisted to disk, which becomes one big cache for MSBuild.
+
+## Parallelism
+Parallelism for MSBuild is implemented at the project level. Each project is assigned to a specific worker node, and the worker nodes will execute the project build in parallel, with the Scheduler organizing sequence and work division. Within project builds, targets run sequentially and within targets, tasks run sequentially; however a task can maintain its own internal parallelism.
+
+For multi-targeted builds parallelism between TargetFrameworks is enabled by creating distinct projects for each "inner build" from an "outer build". The outer build produces a list of projects to build. This list contains the same project file with a different global property for the target framework. This list is then passed to the MSBuild execute target so the TargetFrameworks can be built in parallel.
+
+### Processes and nodes
+When a new build is started, MSBuild starts a process that runs some setup code and prepares itself to start a build. The process of defining the scheduler differs slightly depending on the environment the build is being executed. 
+
+In the case of a CLI build the process that starts the build becomes the scheduler node and one of the worker nodes, becoming both the entry point for the project build and the scheduler. The main problem that arises from that is when the whole build finishes execution, the OS tears down the process, losing the memory cache and having to restart the whole build process from the start. 
+
+This has been partially addressed by the long lived worker nodes feature (AKA 'node reuse'), where the worker nodes stay idle in the background for some time and can be reused by multiple build requests. The main node (with scheduler, loggers, etc.) is still torn down. In the case of a Visual Studio build that uses the MSBuild API to manage the builds, this problem has been solved by having the scheduler process be within the main Visual Studio process (`devenv.exe`) and keeping it very long lived. In case of CLI an experimental feature - [`MSBuild Server`](#msbuild-server) tries to address this gap by keeping the main node alive between build requests as well.
+
+
+## IPC (Inter-Process Communication)
+In multi-process MSBuild execution, many OS processes exist that need to communicate with each other. There are two main reasons:
+ - Dealing with Build Result data: Communicating with the engine, scheduler, cache, etc...
+ - Communication on task execution for a task host: Task definition, task inputs, task outputs.
+
+The transport layer for messages is a [.NET named pipe](https://learn.microsoft.com/dotnet/standard/io/how-to-use-named-pipes-for-network-interprocess-communication).
+
+The message layer has a custom serialization protocol that is specific to MSBuild. As of .NET 8, all message types used are known internal MSBuild types. Earlier MSBuild versions allowed `BinaryFormatter` serialization of plugin-controlled types.
+
+## Graph build
+A graph build changes the sequence in which MSBuild processes projects. Normally a project starts execution, and when it has a dependency on another project, then that project starts to build. A graph build evaluates all projects and their relationship before starting execution of any project. This is achieved by looking at specific items (like `ProjectReference`) after evaluation to construct the dependency graph.
+
+There are a couple of different modes to run graph mode in (see [the spec](../documentation/specs/static-graph.md#what-is-static-graph) for more details):
+- Standard mode (`-graph`): Tried to work from the leaves of the dependency graph and makes sure all results are within the cache. If there is a cache miss / unexpected reference, it just schedules the missing reference for execution.
+- Strict / isolate mode (`-graph -isolate`): If there is a cache miss when building, the whole build is failed.
+- Single project isolated mode: This is not directly invokable by users, instead it is used from higher order build systems to achive distributed / cached builds (in which the individual projects need to run in isolation from their dependencies - as those can be pulled from distributed cache or scheduled to run on different computation nodes).
+
+## MSBuid Server
+In normal MSBuild command-line build execution the main process exists after the build ends. The MSBuild Server project aims to change that, making the entry point process and the scheduler process node separate entities. This allows processes to preserve in-memory cache and make consecutive builds faster, like they are in Visual Studio and other API consumers.
+For more information please see [the spec](../documentation/MSBuild-Server.md).
+
+# Extensibility
+MSBuild includes some features that are related to the build process but do not fit in the previous categories. These extensibility features are critical for the build process, but they can also be customized by third parties for their own use.
+
+## Packaging
+MSBuild interacts with external packages in almost every build. However, the MSBuild engine does not recognize external packages as third parties, and it also does not handle external dependencies. This is done by a packaging system. The supported one being NuGet. As such, it is NuGet that is responsible for finding the packages, downloading them, and providing the MSBuild engine with a package path for the build.
+
+## Restore
+The restore operation is defined as a no-op in common targets, but provided by NuGet in Visual Studio and .NET SDK. It is executed as any other target within MSBuild. The restore operation walks through the project references and package references to determine information about all the packages that need to be restored. This process might result in new or updated files on disk, as well as new imports to the build process.
+
+## Tasks
+An [msbuild task](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks) is a unit of executable code used by MSBuild to perform build operations. There are many built-in tasks living in the [`Microsoft.Build.Tasks`](../src/Tasks/README.md) assembly. [Tasks can also be authored by third parties](https://learn.microsoft.com/visualstudio/msbuild/task-writing) by implementing the `ITask` interface.
+
+Since a task can be delivered as a .NET assembly, it is possible to run arbitrary code during task execution.
+
+### ToolTask
+`ToolTask` is a widely-used helper class for the use case "build a command line for and then run a command-line tool".
+
+## Diagnosability / Loggers
+Current diagnosability within MSBuild follows a log focused approach, where MSBuild has a more robust logging system that contains more data to identify what is happening during a build.
+
+### General Loggers
+Logging within MSBuild consists of various integrated and third-party loggers. Both use the [`ILogger`](https://learn.microsoft.com/dotnet/api/microsoft.build.framework.ilogger) API. Built-in loggers include the Binary Logger which produces compressed `.binlog` files, the Console and Terminal loggers for interactive output, and a Text Log. Third party loggers  receive events through `ILogger`, and multiple loggers can be connected to a single build.
+
+Loggers must be specified before the build begins. Because of this, build logic (and NuGet) is not able to manipulate loggers.
+
+### Binary logger
+The Binary Logger, also called binlog, is a structured log that captures all the events within a build as well as files that are critical to the build. To read a binlog, the MSBuild CLI can replay the events through arbitrary loggers, and third-party tooling like the [Structured Log Viewer](https://msbuildlog.com) can also read binlogs.
+
+
+## Project result cache plugin
+This system allows plugins to extend the per-build result cache to apply across builds and across machines. It functions as a middle layer between the scheduler and the Project Result Cache. So, when the scheduler requests a result for a target or project, the plugin responds first to check all the different distributed nodes for the result. When the plugin cache gets a hit on an input, it downloads and copies the file results to the right place, deserializes the resulting payload and provides it to the local engine to continue execution.
+
+For more in depth information visit [the spec](specs/project-cache.md).
+
+## BuildCheck
+BuildCheck is new MSBuild extensible and configurable linting/diagnostic feature, that enables users to enable/configure and author checks flagging discouraged and anti-pattern practices.
+For more information please see [the spec](../documentation/specs/BuildCheck/BuildCheck.md).
+
+## Resolvers
+There are a few elements within the MSBuild XML that indicate that a call to the .NET SDK is necessary. When such interaction is necessary for a project build, the first thing that needs to be done is to figure out where the SDK is installed so MSBuild can access the content. This is solved by resolvers, which look for the SDK version that was specified, or gets the latest version by looking for them on the folder adjacent to where MSBuild is executing from.
+
+To read more about SDK resolver you can check the [Microsoft Learn page](https://learn.microsoft.com/visualstudio/msbuild/how-to-use-project-sdk#how-project-sdks-are-resolved), or see the [spec documentation](specs/sdk-resolvers-algorithm.md).
+
+## Telemetry
+MSBuild has a few telemetry points, mostly through the .NET SDK. It is implemented as a logger that keeps track of telemetry events in the SDK, this allows to have a single opt-out mechanism that also works for MSBuild.
+
+Visual Studio telemetry was removed once MSBuild went open source, and it was never added again.
+
+## FileTracker
+In order to automatically detect task inputs and outputs, MSBuild can intercept Windows I/O API calls to track the dependencies. A [FileTracker](https://github.com/dotnet/msbuild/blob/main/src/Utilities/TrackedDependencies/FileTracker.cs) utility is used to accomplish this. It uses [Detours](https://github.com/microsoft/detours) to inject logging code when a tracked application performs filesystem operations.
diff --git a/documentation/release-checklist.md b/documentation/release-checklist.md
index 4f00f360e55..9d86581f0b5 100644
--- a/documentation/release-checklist.md
+++ b/documentation/release-checklist.md
@@ -14,7 +14,7 @@
 ## At release time
 
 - [ ] If the release is being cut more than a few days before the VS-side snap, do these two steps. Otherwise check them off.
-  - [ ]  Modify the VS insertion so that it flows from MSBuild `vs{{THIS_RELEASE_VERSION}}` to VS `main` [in the MSBuild-release-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=1319&view=mine&_a=releases) Edit -> Schedule set under Artifacts -> disable toggle
+  - [ ]  Modify the VS insertion so that it flows from MSBuild `vs{{THIS_RELEASE_VERSION}}` to VS `main` [in the MSBuild-release-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=1319&view=mine&_a=releases). Alternatively, if the release being cut no more than couple of weeks, disable the scheduled releases and create releases from `vs{{THIS_RELEASE_VERSION}}` manually until the VS-side snap: Edit -> Schedule set under Artifacts -> disable toggle
 AND
   - [ ]  Disable automated run of [the MSBuild-main-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) (because our {{NEXT_VERSION}} builds don't have a place to go in VS yet)
 - [ ]  Remove the `main` to old release channel ({{THIS_RELEASE_VERSION}}) default channel \
@@ -31,22 +31,19 @@ if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}"
 - [ ]  If the branch was created before the fork: fast-forward merge the correct commit (the one that is currently inserted to VS main) to the `vs{{THIS_RELEASE_VERSION}}` branch \
 e.g.: `git push upstream 2e6f2ff7ea311214255b6b2ca5cc0554fba1b345:refs/heads/vs17.10` \
 _(This is for the case where we create the branch too early and want it to be based actually on a different commit. If you waited until a good point in time with `main` in a clean state, just branch off and you are done. The branch should point to a good, recent spot, so the final-branding PR goes in on top of the right set of commits.)_
-- [ ]  Update the branch merge flow in `dotnet/versions` to have the currently-in-servicing branches: {{URL_OF_VERSIONS_PR}}
+- [ ]  Update the branch merge flow in `.config/git-merge-flow-config.jsonc` file to have the currently-in-servicing branches.
 - [ ]  Fix OptProf data flow for the new vs{{THIS_RELEASE_VERSION}} branch
-  - [ ] Manually run [OptProf data collection](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=17389) pipeline for vs{{THIS_RELEASE_VERSION}} ('Run pipeline' in upper right)
-  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} without OptProf (set `SkipApplyOptimizationData` variable in 'Advanced options' section of the 'Run pipeline' menu to `true`)
+  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} without OptProf (set `SkipApplyOptimizationData` variable in 'Advanced options' section of the 'Run pipeline' menu to `true`) or alternatively with the latest Opt-Prof collected for the main branch (set `Optional OptProfDrop Override` to the drop path of the collected data, which could be found in the logs of the pipeline: Windows_NT -> Build -> search for `OptimizationData`). 
+  - [ ] Check that the [OptProf data collection](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=17389) pipeline run is triggered for vs{{THIS_RELEASE_VERSION}}. If not, run manually ('Run pipeline' in upper right)
   - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} with no extra customization - OptProf should succeed now
-- [ ]  Create {{NEXT_VERSION}} branding PR (in main): {{URL_OF_NEXT_VERSION_BRANDING_PR}}
-- [ ]  Create {{THIS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to add localization for {{THIS_RELEASE_VERSION}}): {{URL_OF_LOCALIZATION_TICKET}}
-https://ceapex.visualstudio.com/CEINTL/_workitems/edit/957875 (DONE)
+- [ ]  Create {{NEXT_VERSION}} branding PR (in main) including public API baseline package version change: {{URL_OF_NEXT_VERSION_BRANDING_PR}}. In the file `eng/Versions.props` Update the `VersionPrefix` to `{{NEXT_VERSION}}` and `PackageValidationBaselineVersion` set to a latest internally available {{THIS_RELEASE_VERSION}} preview version in the internal dnceng dotnet-tools feed. It might be needed to update `CompatibilitySuppressions.xml` files. See [this documentation](https://learn.microsoft.com/en-us/dotnet/fundamentals/apicompat/overview) for more details. You can update `CompatibilitySuppressions.xml` files by running
+`dotnet pack MSBuild.Dev.slnf /p:ApiCompatGenerateSuppressionFile=true`. 
+- [ ]  Create {{THIS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to switch localization from {{PREVIOUS_RELEASE_VERSION}} to {{THIS_RELEASE_VERSION}}): {{URL_OF_LOCALIZATION_TICKET}}
 - [ ]  Enable {{THIS_RELEASE_VERSION}} localization - by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{THIS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `true`
-- [ ]  Disable {{PREVIOUS_RELEASE_VERSION}} localization -  by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{PREVIOUS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `false` clarify with @JanKrivanek
+- [ ]  Disable {{PREVIOUS_RELEASE_VERSION}} localization -  by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{PREVIOUS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `false`. Update the comment on the same line.
 - [ ]  Merge {{NEXT_VERSION}} branding PR
-- [ ]  Create and merge PR including public API baseline package version change (see https://github.com/dotnet/msbuild/pull/8116#discussion_r1049386978): #8949
-- [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, modify the VS insertion so that it flows from MSBuild main to VS main.
-- [ ]  Create {{PREVIOUS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to remove localization for {{PREVIOUS_RELEASE_VERSION}})
-{{URL_OF_LOCALIZATION_DISABLE_TICKET}}
-- [ ]  Remove MSBuild main from the experimental VS insertion flow.
+- [ ]  Create and merge a PR in main to update a localization version comment in setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/main/.vsts-dotnet.yml) to set up the merge conflict when this line will be updated in the release branch.
+- [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, turn on / modify the VS insertion so that it flows from MSBuild main to VS main.
 - [ ]  Update the [release-branch insertion release definition](https://dev.azure.com/devdiv/DevDiv/_releaseDefinition?definitionId=2153&_a=definition-variables) to have `InsertTargetBranch` `rel/d{{THIS_RELEASE_VERSION}}`.
 - [ ]  Turn [the release pipeline](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) back on.
 - [ ]  Prepare final branding PR for `vs{{THIS_RELEASE_VERSION}}`: {{URL_OF_FINAL_BRANDING_PR}}
@@ -56,6 +53,7 @@ https://ceapex.visualstudio.com/CEINTL/_workitems/edit/957875 (DONE)
 - [ ] Get M2 or QB approval as necessary per the VS schedule
 - [ ]  Merge to VS (babysit the automatically generated VS insertion PR https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequests for the MSBuild commit noted in above step): {{URL_OF_VS_INSERTION}}
 - [ ] Update the PackageValidationBaselineVersion to the latest released version ({{THIS_RELEASE_VERSION}}.0) - this might require temporary addition of the [build artifacts feed](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) as the new version is not yet added to the official feeds (this is post release). This can trigger a high severity CG error (https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/secure-supply-chain/how-to-securely-configure-package-source-files) - however it should be fine to keep this temporary feed untill the release.
+- [ ] Update the requested SDK version for bootstrap folder (the `BootstrapSdkVersion` property in [Versions.props](https://github.com/dotnet/msbuild/blob/main/eng/Versions.props)) and buildToolCommand/_InitializeBuildToolCommand values in cibuild_bootstrapped_msbuild scripts if a fresh sdk was released (released runtimes and associated sdk versions can be checked here - https://dotnet.microsoft.com/download/visual-studio-sdks - make sure to always check the details of the appropriate targeted version of .NET for the matching latest version of SDK).
 
 ## ASAP On/After GA:
 
diff --git a/documentation/specs/BuildCheck/BuildCheck-Architecture.md b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
new file mode 100644
index 00000000000..87c6a30b30e
--- /dev/null
+++ b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
@@ -0,0 +1,160 @@
+
+# BuildCheck - Architecture and Implementation Spec
+
+This is an internal engineering document. For general overview and user point of view - please check the [BuildCheck - Design Spec](BuildCheck.md).
+
+# Areas of Ownership
+
+| Area     |      Owner     |
+|----------|:-------------|
+| PM                  | @baronfel |
+| Advisory/Leadership | @rainersigwald |
+| Infrastructure      | @jankrivanek |
+| Configuration       | @f-alizada   |
+| Custom Checks       | @YuliiaKovalova |
+| Inbox Checks        | @ladipro |
+| Replay Mode         | @surayya-MS |
+| Tracing             | @maridematte |
+| Perf Advisory       | @AR-May |
+
+
+# Infrastructure and Execution
+
+## Data Source
+
+The major source of data for BuildCheck will be the `BuildEventArgs` data - as it is already well established diagnostic source for MSBuild builds.
+
+BuildCheck can source this data either offline from the binlog, or as a plugged logger during the live build execution. Choice was made to support both modes.
+
+The actual OM exposed to users will be translating/mapping/proxying the underlying MSBuild OM and hence the implementation details and actual extent of the data (whether internal or public) will be hidden.
+
+### Sourcing unexposed data from within execution
+
+For agility we'll be able to source internal data during the evaluation and/or execution directly from the build engine, without the `BuildEventArgs` exposure.
+
+To simplify the switch between 'in-node direct data' and 'properly remoted data that can be exposed via public OM' we will internally expose execution data consuming interface - that will be implemented by `LoggingService` as well as BuildCheck infrastructure. This way we can have a simple toggle logic in `LoggingService` that will either forward data to BuildCheck infrastructure (in-proc) or translate them to appropriate `BuildEventArgs` and send them via logging infrastructure.
+
+The following diagram ilustrates the case where data are being consumed directly in node - minimizing the performance and resources impact:
+
+![In node data](BuildCheck/in-node-direct-data.png)
+
+Once the implemented BuildCheck will solidify the idea of need for specific data, those can then be remoted via logging infrastructure and then publicly exposed after translation in BuildCheck central logger connector:
+
+![Cross node data](BuildCheck/cross-node-remoted-data.png)
+
+In both cases the sink for the data is actualy a `LoggingContext` - this is to ensure a valid `BuildEventContext` for all data that might be consumed by BuildCheck. BuildCheck needs to know the currently build project path (for proper configuration of the rules and proper reporting) - for this reasen we need to ensure passing of `BuildEventContext` with all data.
+
+
+#### Sample in-node data case - evaluated project
+
+One example of rich data that might be helpful for internal checks is [`Project`](https://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/Definition/Project.cs#L49). This OM is not currently being used during the standard build execution (`ProjectInstance` is used instead) - but we can conditionaly create and expose `Project` and satisfy the current internal consumers of `ProjectInstance` - spike of that is available [in experimental branch](https://github.com/dotnet/msbuild/compare/main...JanKrivanek:msbuild:research/analyzers-evaluation-hooking#diff-08a12a2fa138c3bfcabc7639bb75dda8534f3b662db4aca4f2b5595dbf9ba197).
+
+## Execution Modes
+
+**Replay Mode** - so that users can choose to perform checks post build, without impacting the performance of the build. And so that some level of checking can be run on artifacts from builds produced by MSBuild from NET 9.0 / VS 17.12 or newer. The older versions won't be supported.
+
+**Live mode** - this is what users are used to from compilation checks. Integrating into build execution will as well help driving adoption by opting-in users by default to some level of checking and hence exposing them to the feature.
+
+## Live Mode Hosting
+
+Prerequisites: [MSBuild Nodes Orchestration](../../wiki/Nodes-Orchestration.md#orchestration)
+
+The BuildCheck infrastructure will be prepared to be available concurrently within the `scheduler node` as well as in the additional `worker nodes`. There are 2 reasons for this:
+* BuildCheck will need to recognize custom check packages during the evaluation time - so some basic code related to BuildCheck will need to be present in the worker node.
+* Presence in worker node (as part of the `RequestBuilder`), will allow inbox checks to agile leverage data not available within `BuildEventArgs` (while data proven to be useful should over time be exposed to `BuildEventArgs`)
+
+## Replay Mode
+
+Prerequisites: [MSBuild Replaying a Binary Log](../../wiki/Binary-Log.md#replaying-a-binary-log)
+
+When replaying a binary log, we can apply BuildCheck with help of `-check` switch:
+```
+> msbuild.exe msbuild.binlog -check
+```
+
+If BuildCheck is enabled, then the events from `BinaryLogReplayEventSource` and new events from BuildCheck are merged into the `IEventSource`, from which the loggers get events.
+
+```mermaid
+flowchart TD
+    replayEventSource[BinaryLogReplayEventSource\nreplayEventSource] --> mergedEventSource[IEventSource\nmergedEventSource]
+    replayEventSource[BinaryLogReplayEventSource\nreplayEventSource] --> BuildCheckBuildEventHandler[BuildCheckBuildEventHandler]
+    BuildCheckBuildEventHandler[BuildCheckBuildEventHandler] --> mergedEventSource[IEventSource\nmergedEventSource]
+    mergedEventSource[IEventSource\nmergedEventSource] --> loggers
+```
+1. The events from `BinaryLogReplayEventSource replayEventSource` are passed to the `IEventSource mergedEventSource` unchanged.
+2. The events from `BinaryLogReplayEventSource replayEventSource` are passed to `BuildCheckBuildEventHandler` in order to produce new events from BuildCheck.
+3. The `BuildCheckBuildEventHandler` uses the `IEventSource mergedEventSource` to invoke new events.
+
+`BuildCheckBuildEventHandler` is an internal infrastructural class and serves as an entry point for producing new events from BuildCheck.
+
+## Handling the Distributed Model
+
+We want to get some benefits (mostly inbox checks agility) from hosting BuildCheck infrastructure in worker nodes, but foremost we should prevent leaking the details of this model into public API and OM, until we are sure we cannot achieve all goals from just scheduler node from `BuildEventArgs` (which will likely never happen - as the build should be fully reconstructable from the `BuildEventArgs`).
+
+How we'll internally handle the distributed model:
+* Each node will have just a single instance of infrastructure (`IBuildCheckManager`) available (registered via the MSBuild dependency injection container - `IBuildComponentHost`). This applies to a scheduler node with inproc worker node as well.
+* Scheduler node will have an MSBuild `ILogger` registered that will enable communicating information from worker nodes BuildCheck module to the scheduler node BuildCheck module - namely:
+    * Acquisition module from worker node will be able to communicated to the scheduler node that it encountered `PackageReference` for particular check and that it should be loaded and instantiated in the main node.
+    * Tracing module will be able to send perf stats from current worker node and aggregate all of those together in the main node.
+    * Theoretical execution-data-only sourcing inbox check will be able to aggregate data from the whole build context (again - we should use this only for agility purposes, but shoot for check that needs presence only in scheduler node). The way to do that can be via being present in all worker nodes, sending a specific type of 'in progress result' BuildEventArgs and aggreggating those intermediary results in the single instance running in the main node.
+* Apart from the scenarios above - the BuildCheck infrastructure modules in individual nodes should be able to function independently (namely - load the inbox checks that should live in nodes; send the checks reports via logging infrastructure; load user configuration from `.editorconfig` and decide on need to enable/disable/configure particular checks).
+* The custom checks will be hosted only in the main node - and hence the distributed model will be fully hidden from them. This might be a subject for revision in future versions.
+* Communication from main to worker node between BuildCheck infra modules is not planned (this might be revisited - even for the V1).
+
+## Check Lifecycle
+
+Planned model:
+* Checks factories get registered with the BuildCheck infrastructure (`BuildCheckManager`)
+    * For inbox checks - this happens on startup.
+    * For custom checks - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom checks only in the main node (as they will be only given data proxied from BuildEventArgs).
+    The `BuildCheckAcquisitionEventArgs` should be sent prior `ProjectEvaluationStartedEventArgs` (buffering will need to take place), or main node will need to replay some initial data after custom check is registered.
+* `BuildCheckManager` receives info about new project starting to be build
+    * On scheduler node the information is sourced from `ProjectEvaluationStartedEventArgs`
+    * On worker node this is received from `RequestBuilder.BuildProject`
+* `BuildCheckManager` calls Configuration module and gets information for all checks in it's registry
+    * Checks with issues in configuration (communicated via `BuildCheckConfigurationException`) will issue an error and then be deregistered for the rest of the build.
+    * Global configuration issue (communicated via `BuildCheckConfigurationException`) will issue an error and then entirely disable BuildCheck.
+* `BuildCheckManager` instantiates all newly enabled checks and updates configuration for all already instantiated checks.
+* At that point of time checks are prepared for receiving data and performing their work. MSBuild will start calling `BuildCheckManager` callbacks (mostly pumping `BuildEventArgs`), passed data will be translated into BuildCheck OM and passed to checks.
+* Checks may decide to report results of their findings (via `BuildCheckDataContext.ReportResult`), the infrastructure will then perform post-processing (filter out reports for `Rule`s that are disabled, set the severity based on configuration) and send the result via the standard MSBuild logging infrastructure.
+* Checks result might hence be reported after project's final `ProjectFinishedEventArgs`
+* Final status of the build should not be reported (and `BuildFinishedEventArgs` logged) until all checks are done processing and their results are accounted for.
+
+# Configuration
+
+[Configuration implmentation details](../../../src/Build/BuildCheck/Infrastructure/EditorConfig/README.md).
+
+## High-level logic
+
+MSBuild engine always finds and parses relevant `.editorconfig` files to see which checks should be enabled, if any. In typical builds this operation will not be expensive compared to everything else happening as part of building a project. It's a new cost to all builds though, and in the unlikely case that it starts showing as a perf bottleneck, we can cache the data relevant to MSBuild in a separate intermediate file, in a process-wide in-memory cache invalidated by timestamp checks, and so on.
+
+The rest of the configuration comes directly or indirectly from project files in the form of properties, which creates an interesting ordering issue. For the engine to know the final values of properties such as `TargetFramework`, it needs to evaluate the project. However, if it turns out that an checks should be enabled that is interested in _tracing_ the evaluation, it is already too late. It's important to note that this issue exists only for a subset of checks. Checks interested in the _result_ of evaluation, for example, are fine. The best way of handling this would be to simply evaluate again. Technically, we only need to finish Pass 1 of evaluation to know the value of properties and have the relevant property functions called, so the extra work can be limited to pass 0 and 1. Measurements show that 75% of evaluation is spent in passes 0 and 1. In the very worst case when an extra pass 0/1 runs for each project and lacks any kind of further optimization, single-process incremental build of OrchardCore has been measured to take about 5% longer. There are opportunities for optimizing this, for example by adding a marker to SDK targets files notifying MSBuild of the point after which `TargetFramework` is expected to be fixed so the engine can bail early.
+
+Once `TargetFramework` is known, we can combine the default checks config with what came from `.editorconfig`, restart evaluation if an evaluation-tracing check just got enabled, and continue with the rest of the build. Unlike `TargetFramework` which has an additive effect on the enabled checks, a master switch like `RunMSBuildChecks` may instruct the engine to not run anything. It would be unfortunate if the user had to pay any extra cost when `RunMSBuildChecks` evaluates to false. So preferrably we don't do anything perf sensitive until we hit the point in evaluation when `TargetFramework`, `RunMSBuildChecks`, `SdkAnalysisLevel`, ... are all known and the set of checks to use is finalized.
+
+Since we are unlikely to enable any checks by default in .NET 9, the focus in this release should be on optimizing the `.editorconfig` handling.
+
+# Acquisition
+
+BuildCheck employs two distinct types of checks: inbox and custom. As a result, the acquisition and distribution processes vary.
+Inbox rules are integrated into the MSBuild repository, while custom checks can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
+
+To streamline the creation of custom rules, a special [template](https://learn.microsoft.com/dotnet/core/tools/custom-templates) has been introduced.
+To enable MSBuild to recognize a custom check, it must invoke the intrinsic function [`void RegisterBuildCheck(string path)`](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/Build/Evaluation/IntrinsicFunctions.cs#L700), which requires the path to the assembly as input. Therefore, it's essential for the user to ensure that the assembly exists in the specified location.
+Additionally, the custom rule must use [`BuildCheckRule`](https://github.com/dotnet/msbuild/blob/9cdb3615adb4115f92b390de2f258fac5f320909/src/Build/BuildCheck/API/BuildAnalyzerRule.cs#L11C14-L11C31) as a parent class; otherwise, MSBuild will not register it.
+
+Examples of custom rules can be found in the [end-to-end tests](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/BuildCheck.UnitTests/EndToEndTests.cs#L139), showcasing various scenarios:
+
+1. [`Single Custom Rule Packaged as a NuGet Package`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate): Demonstrates the implementation of a custom rule encapsulated within a NuGet package. It contains the process of creating, packaging, and integrating a single custom rule into a project.
+2. [`Project with Multiple Checks Referenced`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleChecksInjected): Illustrates a project setup where multiple custom checks are referenced. This scenario is common in larger projects where multiple rule sets need to be enforced simultaneously.
+
+Important Notes: 
+- In these examples, pay attention to the presence of the `CustomCheckName.props` file. This file contains intrinsic function invocations necessary for successful rule registration. Understanding and correctly implementing these invocations are crucial for integrating custom rules into your projects effectively.
+- The examples do not include references to third-party assemblies that might be required in other custom checks. To load the custom instance in MSBuild, third-party assemblies have to be included in the NuGet package. The current implementation achieves this goal by using a special target: [AddNuGetDlls](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj#L22).
+
+### Future Enhancements
+As our library of custom rules expands, we plan to enrich this section with real-world production rule examples. These examples will showcase a diverse range of rules addressing common development challenges. Once these production rules are published and available on nuget.org, we will update this documentation accordingly.
+
+# Build OM for Checks Authoring
+
+**TBD** - details for the initial inbox checks set to be amended by @ladipro
diff --git a/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md b/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
new file mode 100644
index 00000000000..2bc17291362
--- /dev/null
+++ b/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
@@ -0,0 +1,100 @@
+
+# Threat model of MSBuild BuildCheck feature
+
+## BuildCheck Feature Description
+
+The infrastructure within MSBuild allowing pluggability and execution of
+Checks and their Rules previously known as "warning waves" and
+"MSBuild Checks".
+
+The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
+
+[Design
+Spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck.md)
+
+[Architecture](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md)
+
+# Threats Identification
+
+This feature does not alter existing nor create any new trust boundaries.
+
+It is assumed to rely on only trusted sources, be managed by trusted operators, and operated on trusted machines.
+
+For this document, we do not address any threats that result from violating these conditions.
+
+## Acquisition
+
+### Threat: Supply chain attack on custom check
+
+Custom BuildCheck checks are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
+
+#### Mitigation
+
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
+
+Custom checks are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
+Users is expected to implement process to detect and warn about known malicious custom checks.
+
+#### Important Notice:
+Users should not add untrusted build checks to their projects. The use of untrusted or unverified 3rd party checks can introduce security risks and vulnerabilities into the build process. Always ensure that any build checks integrated into your projects come from reputable sources and have been thoroughly vetted.
+
+To ensure a secure and reliable build environment, the following steps should be taken:
+
+#### Use Dedicated Security Tools:
+Utilize specialized security tools and services to scan and monitor 3rd party check packages and their dependencies. 
+#### Regular Updates:
+Ensure that all 3rd party packages and dependencies are regularly updated to the latest versions, which often include security patches and vulnerability fixes.
+
+#### Vendor Documentation and Support:
+Refer to the official documentation and support channels provided by the developers of the 3rd party check packages. They may offer guidance and tools for managing security and addressing vulnerabilities.
+
+#### Internal Security Policies:
+Implement internal policies and processes for the assessment and mitigation of security risks associated with using 3rd party packages. This can include regular security audits, dependency management protocols, and automated vulnerability scanning during the build process.
+
+## Execution
+
+### Threat: Supply chain attack by custom check
+
+Custom BuildCheck checks are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
+
+#### Mitigation
+
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
+
+### Threat: Third-Party Vulnerabilities
+Vulnerabilities in custom check or its dependencies.
+
+#### Mitigation
+
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
+
+## Configuration
+
+### Threat: Malicious configuration value
+
+Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an check or cause build malfunction for any reason.
+
+#### Mitigation
+
+This problem is identical to existing .editorconfig for Roslyn checks and since we share code for parsing it, we adopt same mitigation strategy, which is:
+
+- default template for editor config has `root = true` stopping parent config traversing
+- code is unit tested to verify and sanitize .editorconfig values
+
+### Threat: Intentional check ID conflict or misleading ID
+
+Malicious actors can define check ID to be identical or like existing well known check ID to increase probability of executing malicious check code.
+
+#### Mitigation
+
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
+
+## Declaration
+
+### Threat: Malicious check registration property function
+
+Threat actor can write malicious check registration property function in project files, with intent to run code from non-governed assemblies.
+
+#### Mitigation
+
+This threat is out of scope of this document, as this requires malicious modification of source code (repository) making these sources untrusted.
diff --git a/documentation/specs/BuildCheck/BuildCheck.md b/documentation/specs/BuildCheck/BuildCheck.md
new file mode 100644
index 00000000000..e1aaba36424
--- /dev/null
+++ b/documentation/specs/BuildCheck/BuildCheck.md
@@ -0,0 +1,424 @@
+
+# BuildCheck - Design Spec
+
+Previously known as "warning waves" and "MSBuild Checks"
+
+The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
+
+# Terminology
+
+* **Check** – unit of execution (single implementing class), can host multiple rules. 
+* **Rule** – Single violation type, with single unique code (`“BC1234: Redefining built-in target”`). 
+* **Report** – Output from check informing about violating particular rule.
+* **CodeFix** – Violation remedy suggestion. Not yet applicable for MSBuild.
+* **BuildCheck** - Feature name. The infrastructure within MSBuild allowing pluggability and execution of checks and their Rules
+
+
+# North Star / Longer-term vision
+
+MSBuild provides a rich object model (further just OM) exposing representation of the build scripts (unstructured and structured model of documents contributing to the build), build data (the definition and evaluated values of MSBuild primitives) and build execution (the eventing model of inputs, processing and outputs of the orchestrated execution) so that various quality checking rules can be authored. This includes static check rules (e.g. checking validity of condition expressions) as well as build execution rules (e.g. checking of referencing nonexistent files) and composition rules (e.g. unintended outputs overwrites checking). Identical OM is exposed from live build execution and via post-build log event sourcing – so that users can choose whether the build check will happen as part of the build or as a separate process.
+
+Users are able to tune the behavior of the checks via `.editorconfig` which brings unified and standardized experience with other tooling (including built-in and third-party C# checks) leveraging `.editorconfig` files.
+
+Powerusers are able to develop, test and publish their custom checks easily and contribute them back to community. The local development scenario doesn’t require roundtrip through packaging.
+
+A solid set of in-the-box checks is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box checks are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase the quality of our customers build scripts. To avoid breaking customers builds, there will still be an explicit user gesture required to opt into running the check. This will be done either by configuring the checks with `.editorconfig` or auto-enabling the check based on the TFM of the project. There will be no difference between building with `dotnet build` and with `MSBuild.exe`, they will follow the same enablement rules with the set of enabled built-in checks derived from `.editorconfig` and TFM/props. Building in Visual Studio will eventually reach parity with command-line build as well.
+
+Projects that don't use the .NET SDK and those that are not SDK-style at all are TBD. There is a possibility of using a property like `MSBuildCheckLevel` to enable some base checks we believe will add value everywhere.
+
+The check has small impact on build duration with ability to disable check altogether which will remove all the performance costs associated with the check. The perf impact on representative projects is continuously monitored and documented by the MSBuild team.
+
+
+# Scope of initial iteration
+
+Majority of following cases are included in appropriate context within the scenarios in [User Experience](#user-experience) section. Following is a quick overview.
+
+## In scope
+* Inbox (built-in) checks that run during the build execution.
+* Inbox checks that run when replaying binlog.
+* Custom authored checks, delivered via nuget.
+* Checks reports (errors, warnings, messages) are in logger output, VS error window.
+* Codes will be distinguishable from standard build warnings/error (to prevent easy mixups and attempts to configure standard msbuild warnings/errors via editorconfig), but otherwise the outputs are very similar.
+* Default opt-ins and levels for inbox checks set by sdk version (via [`$SdkAnalysisLevel`]((https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md))) or other agreed mechanism for controlling increasing strictness between .NET versions.
+* Custom checks opted in via `PackageReference` of a particular nuget with the check.
+* Explicit overrides of enablement and check levels via `.editorconfig` file (with up to a per-project scope).
+* [Specification of `.editorconfig`](https://spec.editorconfig.org/) will be observed. 
+* Simplified authoring experience via template and doc.
+* Single check can produce reports for multiple rules. However those need to be declared upfront.
+* Opt-in reporting of time spent via specific checks and infra overall.
+* Collect touched `.editorconfig`s into binlog embedded files.
+* Possibility to opt-out from check - the perf should not be impacted when done so.
+* Team collects performance impact numbers on a set of benchmark builds with the inbox checks enabled.
+
+## Non Goals, but subject for consideration
+* Custom check in a local project (source codes) or a binary.
+* Bulk configuration of multiple rules (based on prefixes).
+* Specifying scope of MSBuild imports that will be considered for check (so that e.g. data from sdk won't even be passed to check, if not requested).
+* Attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
+* Configuring BuildCheck levels when checking from binlog - beyond the collected editorconfigs
+* Structured information in VS error window (similarly to the Roslyn check reports - reports have titles, details, locations, searchable codes and exposed links leading to detailed documentation).
+
+
+## Out of scope
+* Instrumentation for telemetry.
+* Design time build check.
+* Localization support (for reports message formats, identifiers, etc.).
+* Custom checks have equal data access as the inbox checks. We'll aim to ship checks that use public BuildCheck API/OM surface. But for extra agility we might chose to implement and ship some checks using unexposed data.
+* All inbox checks reports have precise location(s) of issues (however for each individual check not providing precise location we should have a very strong reason, why location cannot be provided and why it still brings value even without precise location).
+* Opt-out of BuildCheck on code-level (something like C# `#pragma warning disable`, but within msbuild xml files).
+* Simplified authoring experience via dedicated reference assembly.
+* Restore phase check.
+* Turning check off/on based on target (e.g. multi-targeted builds, calling MSBuild task etc.).
+* Controlling/Configuring lifetime of checks - checks will currently be held alive, as single instance per check, for the whole duration of the build. But future versions might prevent some of the checks to survive beyond a scope of a single project built (means for sharing data would be provided).
+* Event Tracing for Windows (ETW) for checks.
+* Attributing `.editorconfig` configurations to .sln files. E.g.:
+```ini
+# I expect this to apply to all projects within my solution, but not to projects which are not part of the solution
+[ContosoFrontEnd.sln]
+build_check.BC0101.Severity=warning
+```
+* Attributing `.editorconfig` configurations to lower granularity than whole projects. E.g.:
+```ini
+# I expect this to apply only to a scope of the imported file. Or possibly I expect this to apply to all projects importing this project.
+[ContosoCommonImport.proj]
+build_check.BC0101.Severity=warning
+```
+* Respecting `.editorconfig` file in msbuild import locations (unless they are in the parent folders hierarchy of particular project file).
+* CodeFixes are not supported in V1
+ 
+
+# User Experience
+
+## Running / UX
+
+### Inbox Checks
+
+Suggested list of checks to be shipped with V1: https://github.com/dotnet/msbuild/issues/9630#issuecomment-2007440323
+
+The proposed initial configuration for those is TBD (as well based on initial test runs of the checks of chosen public repositories).
+
+### Live Build
+
+BuildCheck will run as part of the build and execute [inbox checks](#inbox-checks) and [custom checks](#acquisition-of-custom-checks) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via an MSBuild property (could be set in a project file or passed on the commandline).
+
+Findings - reports - of checks will be output as build messages/warnings/errors, and the message/warnings/error code should help distinguish BuildCheck produced reports from regular build errors/warnings.
+
+BuildCheck reports will have power to fail the build (via errors or warnings), that would otherwise succeed without the BuildCheck. This is actually the main benefit of the feature - as it helps enforcing new rules, that are easily user configurable individually or as a whole feature - to prevent unwanted breakages of legacy builds not ready for improvements.
+
+### Binlog Replay mode
+
+Users will have option to explicitly opt-in to run BuildCheck during the binlog replay mode:
+
+```bash
+> dotnet build msbuild.binlog /check
+```
+
+Would there be any checks that are not possible to run during the replay mode (subject to internal design - this difference won't be exposed during [custom checks authoring](#custom-checks-authoring)), replay mode will inform user about those via warnings.
+
+Replay mode will by default consider `.editorconfig` files stored within the binlog and will run checks based on those. This would possibly lead to unintended double-reports – as binlog will have the runtime check reports stored, plus the replay-time check reports will be augmented. At the same time we might want to run some additional checks in the replay mode, that have not been enabled (or not even available) during the build time.
+
+For this reason we will consider following modes (all are non-goals):
+* All binlog stored reports are skipped by default. We add option to request not skipping them (but they might need to be prefixed or otherwise distinguished from the 'fresh' reports).
+* Ability to specify skipping of the stored .editorconfig files
+* Ability to specify single replay-time .editorconfig file and it’s precedence (only the specified, specified as most significant, specified as least significant)
+
+We might as well consider specifying custom checks on a command line (as a non-goal) - so that unreferenced custom checks can be run against the binlog.
+
+## Configuration
+
+There will be 3 mechanisms of configuring the checks and rules:
+* The default configuration declared by the checks themselves ([more details on implementation](#rules-declaration))
+* The TFM of the project and the [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox checks
+* `.editorconfig` file
+
+We will also consider respecting `SdkAnalysisLevel` to override the per-TFM defaults. Additionally, we may introduce a new "master switch" property, tentatively called `RunMSBuildChecks`, to make it possible to disable everything whole-sale. This would be used in scenarios like F5 in VS.
+```
+Skipping checks to speed up the build. You can execute 'Build' or 'Rebuild' command to run checks.
+```
+
+Here's the proposed release schedule:
+- **.NET 9** - the feature is introduced and enabled in `dotnet build` and `MSBuild.exe` command-line builds. It is not enabled in VS just yet. No checks are enabled by default. It is not technically required to read the TFM or any other props during evaluation, though it would be nice to respect `RunMSBuildChecks` already in this release. `.editorconfig` can be the sole source of configuration.
+- **.NET 10** - based on feedback and testing, we choose a set of checks to enable by default for projects targeting `net10.0`, and enable the feature as a whole in Visual Studio. Depending on how we feel about the perf characteristics of evaluation, especially the "double evaluation" mandated by discovering evaluation-tracking checks just-in-time, we may want to omit such checks from the default set.
+- **.NET 11** and beyond - some more checks are enabled for projects targeting `net11.0`, the `net10.0` does not change. Everything is mature and performant enough that we are able to auto-enable any check. The gradual tightening of rules enabled by default gets us closer to the long envisioned "strict mode", which will ultimately allow us to evolve MSBuild to be simpler and more performant.
+
+
+For the `.editorconfig` file configuration, following will apply:
+* Only `.editorconfig` files collocated with the project file or up the folder hierarchy will be considered.
+* `.editorconfig` files placed along with explicitly or implicitly imported msbuild files won’t be considered.
+* `.editorconfig` files packaged within nuget packages within local nuget cache won’t be considered.
+
+### Non-Goals (but might be considered):
+* bulk configuration of multiple rules - based on checks/rules prefixes or/and categories.
+* attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
+* configuring check levels when checking from binlog - beyond the collected editorconfigs.
+* Aliasing the checks/rules, allowing to create multiple instances with different custom configuration (e.g. single check checking configurable list of forbidden properties prefixes can have 2 instance, each initialized with different list to check, each of the instance configurable for individual projects separately).
+
+### Out of scope for configuration:
+* opt-out of check on code-level (analogy to C# pragmas, but within msbuild xml files).
+* lower granularity of `.editorconfig` settings other than whole projects.
+* attributing configuration to a .sln file and expecting it will apply to all contained projects.
+* Support for multiple [custom configurations](#custom-configuration-declaration) within a single build for a single rule. (Not to be mixed with [standardized configuration](#standardized-configuration-declaration) - which can be configured freely per project) If a custom configuration will be used, it will need to be specified identically in each explicit configurations of the rule. This is chosen so that there are no implicit requirements on lifetime of the check or check instancing – each check will be instantiated only once per build (this is however something that will very likely change in future versions – so authors are advised not to take hard dependency on single instance policy).
+
+### Sample configuration
+
+```ini
+[*.csproj]
+build_check.BC0101.severity=warning
+
+build_check.COND0543.severity=none
+build_check.COND0543.scope=project
+build_check.COND0543.custom_switch=QWERTY
+```
+
+### User Configurable Options
+
+Initial version of BuildCheck plans a limited set of options configurable by user (via `.editorconfig`) by which users can override default configuration of individual check rules.
+
+**NOTE:** The actual naming of the configuration options is yet to be determined.
+
+#### Severity levels
+
+Option `Severity` with following values will be available:
+
+| Severity      | EditorConfig option      |
+| ------------- | ------------- |
+| Default | `default` |
+| None | `none` |
+| Suggestion | `suggestion` |
+| Warning | `warning` |
+| Error | `error` |
+
+Severity levels are in line with [roslyn analyzers severity levels](https://learn.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers). `Default` severity in `.editorconfig` will lead to using build-in severity from the check (so this can be used for clearing custom severity setting from higher level `.editorconfig` file). `Default` severity in the build-in code has same effect as if the code doesn't specify severity at all - an infrastruture default of `None` is considered.
+
+Configuration will dictate transformation of the check report to particular build output type (message, warning or error).
+
+Each rule has a severity, even if multiple rules are defined in a single check. The rule can have different severities for different projects within a single build session.
+
+If all the rules from a single check have severity `None` - check won't be given any data for such configured part of the build (specific project or a whole build). If check have some rules enabled and some disabled - it will be still fed with data, but the reports will be post-filtered.
+
+#### Configuring severity level
+
+```ini
+[*.csproj]
+build_check.BC0101.severity=warning
+```
+
+#### Scope of Check
+
+Option `EvaluationCheckScope` with following possible options will be available:
+
+| EvaluationCheckScope (Solution Explorer)   | EditorConfig option      |  Behavior  | 
+| ------------- | ------------- |   ------------- |
+| ProjectFileOnly | `project_file` | Only the data from currently checked project will be sent to the check. Imports will be discarded. | 
+| WorkTreeImports | `work_tree_imports` |  Only the data from currently checked project and imports from files not recognized to be in nuget cache or SDK install folder will be sent to the check. Other imports will be discarded. |  
+| ProjectWithAllImports | `all` | All data will be sent to the check. | 
+
+All rules of a single check must have the `EvaluationCheckScope` configured to a same value. If any rule from the check have the value configured differently - a warning will be issued during the build and check will be deregistered.
+
+Same rule can have `EvaluationCheckScope` configured to different values for different projects.
+
+BuildCheck might not be able to guarantee to properly filter the data with this distinction for all [registration types](#RegisterActions) - in case an explicit value is attempted to be configured (either [from the check code](#BuildExecutionCheckConfiguration) or from `.editorconfig` file) for an check that has a subscription to unfilterable data - a warning will be issued during the build and check will be deregistered.
+
+#### Configuring evalution scope
+
+```ini
+[*.csproj]
+build_check.BC0101.scope=all
+```
+
+## Checks and Rules Identification
+
+**TBD**
+
+* Recommended and reserved prefixes
+* Short vs descriptive names
+* Rules categories
+* Ability to use prefixes during configuration
+
+
+## Custom Checks Authoring
+
+### Implementation
+
+To author custom check, user will need to implement given contract (delivered in Microsoft.Build package). The contract will provide access to the exposed BuildCheck OM focused on build check.
+
+#### Check declaration
+
+Simplified proposal:
+
+```csharp
+public abstract class BuildExecutionCheck : IDisposable
+{
+    /// <summary>
+    /// Friendly name of the check.
+    /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
+    /// </summary>
+    public abstract string FriendlyName { get; }
+
+    /// <summary>
+    /// Single or multiple rules supported by the check.
+    /// </summary>
+    public abstract IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; }
+
+    /// <summary>
+    /// Optional initialization of the check.
+    /// </summary>
+    /// <param name="configurationContext">
+    /// Custom data (not recognized by the infrastructure) passed from .editorconfig
+    /// Currently the custom data has to be identical for all rules in the check and all projects.
+    /// </param>
+    public abstract void Initialize(ConfigurationContext configurationContext);
+
+    /// <summary>
+    /// 
+    /// </summary>
+    /// <param name="context"></param>
+    public abstract void RegisterActions(IBuildCheckRegistrationContext context);
+
+    public virtual void Dispose()
+    { }
+}
+```
+
+<a name="RegisterActions"></a>The context in `RegisterActions` call will enable subscriptions for data pumping from the infrastructure. 
+
+Sample of how registrations might look like:
+
+```csharp
+public interface IBuildCheckRegistrationContext
+{
+    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction);
+
+    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction);
+
+    // ...
+}
+```
+
+The data provided in callbacks for registered actions will allow the check to submit reports for its rules. A single callback can lead to multiple reports being generated.
+
+Any check will be allowed to produce reports only for Rules that it declared in it’s `SupportedRules` definition.
+
+#### Rules declaration
+
+A single check can declare support of multiple rules – since it might produce reports for those on top of same input data – and for efficiency reasons a single processing of data might be needed.
+
+Simplified proposal of definition of a single rule:
+
+```csharp
+public class BuildExecutionCheckRule
+{
+    // Identification/Description fields
+    // (To be defined more precisely by https://github.com/dotnet/msbuild/issues/9823)
+
+    /// <summary>
+    /// The default configuration - overridable by the user via .editorconfig.
+    /// If no user specified configuration is provided, this default will be used.
+    /// </summary>
+    public BuildExecutionCheckConfiguration DefaultConfiguration { get; }
+}
+```
+
+<a name="BuildExecutionCheckConfiguration"></a>Each rule will supply its default configuration (mainly enablement and report severity) – those will apply if `.editorconfig` file will not set those settings explicitly. If the rule doesn't provide (some of) its defaults, a global hardcoded default is used (`severity: message, enabled: false`).
+
+#### Standardized configuration declaration
+
+Proposal of configuration specification:
+
+```csharp
+/// <summary>
+/// Configuration for a build check.
+/// Default values can be specified by the check in code.
+/// Users can overwrite the defaults by explicit settings in the .editorconfig file.
+/// Each rule can have its own configuration, which can differ per each project.
+/// The <see cref="EvaluationCheckScope"/> setting must be same for all rules in the same check (but can differ between projects)
+/// </summary>
+public class BuildExecutionCheckConfiguration
+{
+    /// <summary>
+    /// This applies only to specific events, that can distinguish whether they are directly inferred from
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from check.
+    ///
+    /// If not supported by the data source - then the setting is ignored
+    /// </summary>
+    public EvaluationCheckScope? EvaluationCheckScope { get; internal init; }
+
+    /// <summary>
+    /// The default severity of the result for the rule. May be overridden by user configuration.
+    ///
+    /// If all rules within the check are `none`, the whole check will not be run.
+    /// If some rules are `none` and some are not, the check will be run and reports will be post-filtered.
+    /// </summary>
+    public BuildExecutionCheckResultSeverity? Severity { get; internal init; }
+}
+```
+
+Values for this recognized contract, that are explicitly specified via .editorconfig files are passed both to the BuildCheck infrastructure as well as individual checks.
+
+#### Custom configuration declaration
+
+However if user will specify additional – unrecognized - values in `.editorconfig` file as part of a particular check configuration – those values will be extracted as key-value pairs and passed to the check initialization call (`Initialize`) via `ConfigurationContext`:
+
+```csharp
+/// <summary>
+/// Holder of an optional configuration from .editorconfig file (not recognized by the infrastructure)
+/// </summary>
+public class ConfigurationContext
+{
+    /// <summary>
+    /// Custom configuration data - per each rule that has some specified.
+    /// </summary>
+    public IReadOnlyList<CustomConfigurationData> CustomConfigurationData { get; init; }
+
+    /// <summary>
+    /// Configuration data from standard declarations
+    /// </summary>
+    public IReadOnlyList<BuildExecutionCheckConfiguration> BuildExecutionCheckConfig { get; init; }
+}
+```
+
+This can allow creation of extendable checks – e.g. a check that will validate that properties defined within project do not start with any forbidden prefix, while actual prefixes to check are configurable – so the user of the check can tune the behavior to their needs.
+
+More details on configuration are in [Configuration](#configuration) section.
+
+
+#### Compatibility
+
+All the publicly exposed contracts will be available within `Microsoft.Build.Experimental.BuildCheck` namespace. The namespace is expressing that contracts are not guaranteed to be backward compatible (however breakage will be limited to necessary cases). The availability of particular set of BuildCheck API will be queryable via [Feature Query API](https://github.com/dotnet/msbuild/pull/9665):
+
+```csharp
+var availability = Features.CheckFeatureAvailability("BuildCheck.Beta");
+```
+
+This way the checks authors will be equipped to write highly-compatible checks even in a possibility of changing API.
+
+
+### Testing and Debugging
+
+**TBD**
+
+We aim to provide ability to locally test checks from local projects or assemblies without a need to roundtrip through packaging them. The exact way is yet to be determined.
+
+At the same time we aim to provide mocks providing the BuildCheck context data – this work is however a non-goal.
+
+### Packaging
+
+Several requirements are mandated for check packages to be properly recognized (Netstandard only, A call to designated property function will need to be part of the packaged build assets, dependencies will need to be packaged, binaries structure flattened). There might as well be couple of optional practices making the check package more resources savvy (E.g. defining the rule ids and enablement status within the mentioned property function - so that such information doesn't require loading and calling of the check type).
+
+Also custom check package is a dependency is a purely development time harness - so it should be marked as [`DevelopmentDependency`](https://learn.microsoft.com/en-us/nuget/reference/nuspec#developmentdependency).
+
+In order to simplify the packaging process (and meeting above mentioned requirements) a dotnet template will be provided producing proper package on pack action.
+
+**TBD** - dotnet new sample on initiating the development.
+
+## Acquisition of custom checks
+
+Apart from [inbox checks](#inbox-checks) (shipped together with msbuild), users will be able to plug-in packaged checks shipped as nugets (this will serve for community contributions, but possibly as a venue for off-cycle distribution of official checks).
+
+In order to use an check package users just need to reference them via `<PackageReference>` element as standard package reference. 
+
+```xml
+<PackageReference Include="Contoso.checks" Version="1.2.3" />
+```
+
+Only projects referencing the package will be able to run its checks. Enabling the rules from package on other projects won’t take any effect.
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
new file mode 100644
index 00000000000..b208653baff
--- /dev/null
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -0,0 +1,95 @@
+# `BuildCheck` reports codes and their meaning
+
+Report codes are chosen to conform to suggested guidelines. Those guidelines are currently in revew: https://github.com/dotnet/msbuild/pull/10088
+
+| Diagnostic&nbsp;Code | Default Severity | Reason |
+|:-----|-------|----------|
+| [BC0101](#BC0101) | Warning | Shared output path. |
+| [BC0102](#BC0102) | Warning | Double writes. |
+| [BC0103](#BC0103) | Suggestion | Used environment variable. |
+| [BC0201](#BC0201) | Warning | Usage of undefined property. |
+| [BC0202](#BC0202) | Warning | Property first declared after it was used. |
+| [BC0203](#BC0203) | None | Property declared but never used. |
+
+
+To enable verbose logging in order to troubleshoot issue(s), enable [binary logging](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md#msbuild-binary-log-overview)
+
+_Cmd:_
+```cmd
+dotnet build -bl -check
+```
+
+## <a name="BC0101"></a>BC0101 - Shared output path.
+
+"Two projects should not share their OutputPath nor IntermediateOutputPath locations"
+
+It is not recommended to share output path nor intermediate output path between multiple projects. Such practice can lead to silent overwrites of the outputs. Such overwrites will depend on the order of the build, that might not be guaranteed (if not explicitly configured) and hence it can cause nondeterministic behavior of the build.
+
+If you want to produce outputs in a consolidated output folder - consider using the [Artifacts output layout](https://learn.microsoft.com/en-us/dotnet/core/sdk/artifacts-output) and/or [Microsoft.Build.Artifacts SDK](https://github.com/microsoft/MSBuildSdks/tree/main/src/Artifacts).
+
+
+## <a name="BC0102"></a>BC0102 - Double writes.
+
+"Two tasks should not write the same file"
+
+This is a similar problem as ['BC0101 - Shared output path'](#BC0101) - however with higher granularity. It is not recomended that multiple tasks attempt to write to a single file - as such behavior might lead to nondeterminism of a build (as result can be dependent on the order of the tasks execution if those belong to independent projects) or/and to a lost updates.
+
+If you want multiple tasks to update file in a one-by-one pipeline fashion, it is recommended to give each intermediate output a distinct name - preventing silent mixups if any of the tasks in the chain are skipped or removed.
+
+## <a name="BC0103"></a>BC0103 - Used environment variable.
+
+"Environment variables should not be used as a value source for the properties"
+
+Using environment variables as a data source in MSBuild is problematic and can lead to nondeterministic builds.
+Relying on environment variables introduces variability and unpredictability, as their values can change between builds or environments.
+
+This practice can result in inconsistent build outcomes and makes debugging difficult, since environment variables are external to project files and build scripts. To ensure consistent and reproducible builds, avoid using environment variables. Instead, explicitly pass properties using the /p option, which offers better control and traceability.
+
+## <a name="BC0201"></a>BC0201 - Usage of undefined property.
+
+"A property that is accessed should be declared first."
+
+This check indicates that a property was acessed without being declared (the declaration might have happen later - see [BC0202](#BC0202) for such checking). Only accessing in the configured scope (by default it's the project file only) are checked.
+
+There are couple cases which are allowed by the check:
+
+* Selfreferencing declaration is allowed - e.g.:
+  `<ChainProp>$(ChainProp)</ChainProp>`
+
+* Checking the property for emptyness - e.g.:
+  `<PropertyGroup Condition="'$(PropertyThatMightNotBeDefined)' == ''">`
+
+* Any usage of property in condition. This can be opted out vie the configuration `AllowUninitializedPropertiesInConditions` - e.g.:
+  ```ini
+  [*.csproj]
+  build_check.BC0201.severity=error
+  build_check.BC0201.AllowUninitializedPropertiesInConditions=false
+  build_check.BC0202.AllowUninitializedPropertiesInConditions=false
+  ```
+
+  BC0201 and BC0202 must have same value for the optional switch - as both operate on top of same data and same filtering.
+
+## <a name="BC0202"></a>BC0202 - Property first declared after it was used.
+
+"A property should be declared before it is first used."
+
+This check indicates that a property was acessed before it was declared. The default scope of this rule is the project file only. The scope captures the read and write operations as well. So this rule reports:
+ * Uninitialized reads that happened anywhere during the build, while the uninitialized property was later defined within the scope of this check (e.g. project file).
+ * Uninitialized reads that happened within the scope of check (e.g. project file), while later defined anywhere in the build
+
+If `BC0202` and [BC0201](#BC0201) are both enabled - then `BC0201` reports only the undefined reads that are not reported by this rule (so those that do not have late definitions).
+
+## <a name="BC0203"></a>BC0203 -  Property declared but never used.
+
+"A property that is not used should not be declared."
+
+This check indicates that a property was defined in the observed scope (by default it's the project file only) and it was then not used anywhere in the build.
+
+This is a runtime check, not a static analysis check - so it can have false positives (as property not used in particular build might be needed in a build with different conditions). For this reasons it's currently only suggestion.
+
+<BR/>
+<BR/>
+<BR/>
+
+### Related Resources
+* [BuildCheck documentation](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck.md)
diff --git a/documentation/specs/BuildCheck/cross-node-remoted-data.png b/documentation/specs/BuildCheck/cross-node-remoted-data.png
new file mode 100644
index 00000000000..a5c6a827573
Binary files /dev/null and b/documentation/specs/BuildCheck/cross-node-remoted-data.png differ
diff --git a/documentation/specs/BuildCheck/in-node-direct-data.png b/documentation/specs/BuildCheck/in-node-direct-data.png
new file mode 100644
index 00000000000..ba6d632983e
Binary files /dev/null and b/documentation/specs/BuildCheck/in-node-direct-data.png differ
diff --git a/documentation/specs/proposed/interactive-package-references.md b/documentation/specs/BuildCheck/interactive-package-references.md
similarity index 100%
rename from documentation/specs/proposed/interactive-package-references.md
rename to documentation/specs/BuildCheck/interactive-package-references.md
diff --git a/documentation/specs/proposed/packagessourcing-control-flow.jpg b/documentation/specs/BuildCheck/packagessourcing-control-flow.jpg
similarity index 100%
rename from documentation/specs/proposed/packagessourcing-control-flow.jpg
rename to documentation/specs/BuildCheck/packagessourcing-control-flow.jpg
diff --git a/documentation/specs/proposed/security-metadata.md b/documentation/specs/BuildCheck/security-metadata.md
similarity index 100%
rename from documentation/specs/proposed/security-metadata.md
rename to documentation/specs/BuildCheck/security-metadata.md
diff --git a/documentation/specs/proposed/sourcing-vs-context.png b/documentation/specs/BuildCheck/sourcing-vs-context.png
similarity index 100%
rename from documentation/specs/proposed/sourcing-vs-context.png
rename to documentation/specs/BuildCheck/sourcing-vs-context.png
diff --git a/documentation/specs/proposed/BuildCheck-Architecture.md b/documentation/specs/proposed/BuildCheck-Architecture.md
deleted file mode 100644
index f819a3d8d22..00000000000
--- a/documentation/specs/proposed/BuildCheck-Architecture.md
+++ /dev/null
@@ -1,120 +0,0 @@
-
-# BuildCheck - Architecture and Implementation Spec
-
-This is an internal engineering document. For general overview and user point of view - please check the [BuildCheck - Design Spec](BuildCheck.md).
-
-# Areas of Ownership
-
-| Area     |      Owner     |
-|----------|:-------------|
-| PM                  | @baronfel |
-| Advisory/Leadership | @rainersigwald |
-| Infrastructure      | @jankrivanek |
-| Configuration       | @f-alizada   |
-| Custom Analyzers    | @YuliiaKovalova |
-| Inbox Analyzers     | @ladipro |
-| Replay Mode         | @surayya-MS |
-| Tracing             | @maridematte |
-| Perf Advisory       | @AR-May |
-
-
-# Infrastructure and Execution
-
-## Data Source
-
-The major source of data for BuildCheck will be the `BuildEventArgs` data - as it is already well established diagnostic source for MSBuild builds.
-
-BuildCheck can source this data either offline from the binlog, or as a plugged logger during the live build execution. Choice was made to support both modes.
-
-The actual OM exposed to users will be translating/mapping/proxying the underlying MSBuild OM and hence the implementation details and actual extent of the data (whether internal or public) will be hidden.
-
-### Sourcing unexposed data from within execution
-
-For agility we'll be able to source internal data during the evaluation and/or execution directly from the build engine, without the `BuildEventArgs` exposure.
-One example of rich data that might be helpful for internal analyses is [`Project`](https://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/Definition/Project.cs#L49). This OM is not currently being used during the standard build execution (`ProjectInstance` is used instead) - but we can conditionaly create and expose `Project` and satisfy the current internal consumers of `ProjectInstance` - spike of that is available [in experimental branch](https://github.com/dotnet/msbuild/compare/main...JanKrivanek:msbuild:research/analyzers-evaluation-hooking#diff-08a12a2fa138c3bfcabc7639bb75dda8534f3b662db4aca4f2b5595dbf9ba197).
-
-## Execution Modes
-
-**Replay Mode** - so that users can choose to perform analyses post build, without impacting the performance of the build. And so that some level of analysis can be run on artifacts from builds produced by older versions of MSBuild.
-
-**Live mode** - this is what users are used to from compilation analyses. Integrating into build execution will as well help driving adoption by opting-in users by default to some level of checking and hence exposing them to the feature.
-
-## Live Mode Hosting
-
-Prerequisites: [MSBuild Nodes Orchestration](../../wiki/Nodes-Orchestration.md#orchestration)
-
-The BuildCheck infrastructure will be prepared to be available concurrently within the `scheduler node` as well as in the additional `worker nodes`. There are 2 reasons for this:
-* BuildCheck will need to recognize custom analyzers packages during the evaluation time - so some basic code related to BuildCheck will need to be present in the worker node.
-* Presence in worker node (as part of the `RequestBuilder`), will allow inbox analyzers to agile leverage data not available within `BuildEventArgs` (while data proven to be useful should over time be exposed to `BuildEventArgs`)
-
-## Handling the Distributed Model
-
-We want to get some benefits (mostly inbox analyzers agility) from hosting BuildCheck infrastructure in worker nodes, but foremost we should prevent leaking the details of this model into public API and OM, until we are sure we cannot achieve all goals from just scheduler node from `BuildEventArgs` (which will likely never happen - as the build should be fully reconstructable from the `BuildEventArgs`).
-
-How we'll internally handle the distributed model:
-* Each node will have just a single instance of infrastructure (`IBuildCheckManager`) available (registered via the MSBuild dependency injection container - `IBuildComponentHost`). This applies to a scheduler node with inproc worker node as well.
-* Scheduler node will have an MSBuild `ILogger` registered that will enable communicating information from worker nodes BuildCheck module to the scheduler node BuildCheck module - namely:
-    * Acquisition module from worker node will be able to communicated to the scheduler node that it encountered `PackageReference` for particular analyzer and that it should be loaded and instantiated in the main node.
-    * Tracing module will be able to send perf stats from current worker node and aggregate all of those together in the main node.
-    * Theoretical execution-data-only sourcing inbox analyzer will be able to aggregate data from the whole build context (again - we should use this only for agility purposes, but shoot for analyzer that needs presence only in scheduler node). The way to do that can be via being present in all worker nodes, sending a specific type of 'in progress result' BuildEventArgs and aggreggating those intermediary results in the single instance running in the main node.
-* Apart from the scenarios above - the BuildCheck infrastructure modules in individual nodes should be able to function independently (namely - load the inbox analyzers that should live in nodes; send the analyzers reports via logging infrastructure; load user configuration from `.editorconfig` and decide on need to enable/disable/configure particular analyzers).
-* The custom analyzers will be hosted only in the main node - and hence the distributed model will be fully hidden from them. This might be a subject for revision in future versions.
-* Communication from main to worker node between BuildCheck infra modules is not planned (this might be revisited - even for the V1).
-
-## Analyzers Lifecycle
-
-Planned model:
-* Analyzers factories get registered with the BuildCheck infrastructure (`BuildCheckManager`)
-    * For inbox analyzers - this happens on startup.
-    * For custom analyzers - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom analyzers only in the main node (as they will be only given data proxied from BuildEventArgs).
-    The `BuildCheckAcquisitionEventArgs` should be sent prior `ProjectEvaluationStartedEventArgs` (buffering will need to take place), or main node will need to replay some initial data after custom analyzer is registered.
-* `BuildCheckManager` receives info about new project starting to be build
-    * On scheduler node the information is sourced from `ProjectEvaluationStartedEventArgs`
-    * On worker node this is received from `RequestBuilder.BuildProject`
-* `BuildCheckManager` calls Configuration module and gets information for all analyzers in it's registry
-    * Analyzers with issues in configuration (communicated via `BuildCheckConfigurationException`) will issue an error and then be deregistered for the rest of the build.
-    * Global configuration issue (communicated via `BuildCheckConfigurationException`) will issue an error and then entirely disable BuildCheck.
-* `BuildCheckManager` instantiates all newly enabled analyzers and updates configuration for all already instantiated analyzers.
-* At that point of time analyzers are prepared for receiving data and performing their work. MSBuild will start calling `BuildCheckManager` callbacks (mostly pumping `BuildEventArgs`), passed data will be translated into BuildCheck OM and passed to analyzers.
-* Analyzers may decide to report results of their findings (via `BuildCheckDataContext.ReportResult`), the infrastructure will then perform post-processing (filter out reports for `Rule`s that are disabled, set the severity based on configuration) and send the result via the standard MSBuild logging infrastructure.
-* Analysis result might hence be reported after project's final `ProjectFinishedEventArgs`
-* Final status of the build should not be reported (and `BuildFinishedEventArgs` logged) until all analyzers are done processing and their results are accounted for.
-
-# Configuration
-
-**TBD** - implementation details to be amended by @f-alizada 
-
-## High-level logic
-
-MSBuild engine always finds and parses relevant `.editorconfig` files to see which analyzers should be enabled, if any. In typical builds this operation will not be expensive compared to everything else happening as part of building a project. It's a new cost to all builds though, and in the unlikely case that it starts showing as a perf bottleneck, we can cache the data relevant to MSBuild in a separate intermediate file, in a process-wide in-memory cache invalidated by timestamp checks, and so on.
-
-The rest of the configuration comes directly or indirectly from project files in the form of properties, which creates an interesting ordering issue. For the engine to know the final values of properties such as `TargetFramework`, it needs to evaluate the project. However, if it turns out that an analyzer should be enabled that is interested in _tracing_ the evaluation, it is already too late. It's important to note that this issue exists only for a subset of analyzers. Analyzers interested in the _result_ of evaluation, for example, are fine. The best way of handling this would be to simply evaluate again. Technically, we only need to finish Pass 1 of evaluation to know the value of properties and have the relevant property functions called, so the extra work can be limited to pass 0 and 1. Measurements show that 75% of evaluation is spent in passes 0 and 1. In the very worst case when an extra pass 0/1 runs for each project and lacks any kind of further optimization, single-process incremental build of OrchardCore has been measured to take about 5% longer. There are opportunities for optimizing this, for example by adding a marker to SDK targets files notifying MSBuild of the point after which `TargetFramework` is expected to be fixed so the engine can bail early.
-
-Once `TargetFramework` is known, we can combine the default analyzer config with what came from `.editorconfig`, restart evaluation if an evaluation-tracing analyzer just got enabled, and continue with the rest of the build. Unlike `TargetFramework` which has an additive effect on the enabled analyzers, a master switch like `RunMSBuildChecks` may instruct the engine to not run anything. It would be unfortunate if the user had to pay any extra cost when `RunMSBuildChecks` evaluates to false. So preferrably we don't do anything perf sensitive until we hit the point in evaluation when `TargetFramework`, `RunMSBuildChecks`, `SdkAnalysisLevel`, ... are all known and the set of analyzers to use is finalized.
-
-Since we are unlikely to enable any analyzers by default in .NET 9, the focus in this release should be on optimizing the `.editorconfig` handling.
-
-# Acquisition
-
-BuildCheck employs two distinct types of analyzers: inbox and custom. As a result, the acquisition and distribution processes vary.
-Inbox rules are integrated into the MSBuild repository, while custom analyzers can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
-
-To streamline the creation of custom rules, a special [template](https://learn.microsoft.com/dotnet/core/tools/custom-templates) has been introduced.
-To enable MSBuild to recognize a custom analyzer, it must invoke the intrinsic function [`void RegisterBuildCheck(string path)`](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/Build/Evaluation/IntrinsicFunctions.cs#L700), which requires the path to the assembly as input. Therefore, it's essential for the user to ensure that the assembly exists in the specified location.
-Additionally, the custom rule must use [`BuildAnalyzerRule`](https://github.com/dotnet/msbuild/blob/9cdb3615adb4115f92b390de2f258fac5f320909/src/Build/BuildCheck/API/BuildAnalyzerRule.cs#L11C14-L11C31) as a parent class; otherwise, MSBuild will not register it.
-
-Examples of custom rules can be found in the [end-to-end tests](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/BuildCheck.UnitTests/EndToEndTests.cs#L139), showcasing various scenarios:
-
-1. [`Single Custom Rule Packaged as a NuGet Package`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate): Demonstrates the implementation of a custom rule encapsulated within a NuGet package. It contains the process of creating, packaging, and integrating a single custom rule into a project.
-2. [`Project with Multiple Analyzers Referenced`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected): Illustrates a project setup where multiple custom analyzers are referenced. This scenario is common in larger projects where multiple rule sets need to be enforced simultaneously.
-
-Important Notes: 
-- In these examples, pay attention to the presence of the `CustomAnalyzerName.props` file. This file contains intrinsic function invocations necessary for successful rule registration. Understanding and correctly implementing these invocations are crucial for integrating custom rules into your projects effectively.
-- The examples do not include references to third-party assemblies that might be required in other custom analyzers. To load the custom instance in MSBuild, third-party assemblies have to be included in the NuGet package. The current implementation achieves this goal by using a special target: [AddNuGetDlls](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj#L22).
-
-### Future Enhancements
-As our library of custom rules expands, we plan to enrich this section with real-world production rule examples. These examples will showcase a diverse range of rules addressing common development challenges. Once these production rules are published and available on nuget.org, we will update this documentation accordingly.
-
-# Build OM for Analyzers Authoring
-
-**TBD** - details for the initial inbox analyzers set to be amended by @ladipro
diff --git a/documentation/specs/proposed/BuildCheck-acquisition-challenge.md b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
new file mode 100644
index 00000000000..cc19390f06a
--- /dev/null
+++ b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
@@ -0,0 +1,24 @@
+# BuildCheck - Perf and Acquisition Challenge
+
+This is an internal engineering document. For general overview and user-oriented information please refer to [BuildCheck - Design Spec](BuildCheck.md).
+
+# Challenge
+
+Let's recall some details of BuildCheck checks acquisition. There might be two types of the build check: build-in and custom. 
+The build-in checks are configured in the `.editorconfig` file. The custom checks are declared in the project files via PackageReference and also configured in the `.editorconfig` file.
+Project files are read during the first pass of the evaluation of the project. Given the multi-processing nature of MSBuild, this might happen either on main node or on the msbuild worker node. When the check is encountered, the event `BuildCheckAcquisitionEventArgs` is logged with information concerning the check that is needed to be loaded. This event is forwarded by `BuildCheckForwardingLogger` through logging system via the named pipes to the main msbuild node, where it is processed by `BuildCheckConnectorLogger`. This requires the logging system to be configured on main and worker msbuild nodes. 
+
+![checks-acquisition](checks-acquisition.png)
+
+There are two issues that arise from such a design:
+1. The configuration of the logging system should be ideally dependent on the set of the applied build checks. Verbosity of the build hugely affects the set of logging events that are logged by default. Moreover, some events are not forwarded with forwarding loggers, depending on forwarding loggers configuration. This is done for performance reasons to allow to drop the events that are not consumed by any of the central loggers. We need to ensure that the events required for the checks to work pass through. For that we need to have information about active rules from the `.editorconfig` file and the declarations in the project files via PackageReference when setting up the logging system.
+2. There is no synchronization between build manager and logging service. When the build check acquisition events get to the main node, most of the build might have been already finished on worker nodes.
+
+# Solution ideas
+
+- When checks are used, always create and forward all the events. This will have a considerable impact on performance but makes configuring of the logging system easy.
+- Set up the logger configuration before the build starts on the worker nodes: the main node can read the `.editorconfig` file and set up the correct configuration. For custom checks we cannot do that, as they could be downloaded during the restore and discovered during the evaluation. 
+- Change the initial confuguration of the logging system (in particular, forwardning loggers) during the build. 
+    - Do that as soon as we get the events `BuildCheckAcquisitionEventArgs` in forwarding logger: create a custom `BuildCheckForwardingLogger` that will re-configure itself when it gets `BuildCheckAcquisitionEventArgs`. This will need reading the editorconfig files and possibly loading custom checks in the worker node in order to find which events are needed for the custom checks. We will miss some of the events on the evaluation prior `BuildCheckAcquisitionEventArgs` event but since the events are processed in an order, the new filters in the forwarding logger will apply to the later events.
+    - Process the events `BuildCheckAcquisitionEventArgs` in the build check manager and send a message to the worker node to re-configure it. However due to the absence of syncronization between build manager and logging service, this message might get processed on the worker node late and we will miss a lot of events needed for the checks.  
+- As an addition the previous ideas, we may initialize the loggers from cache (either in-process cache or cache file in file system). We might have a strict mode which in case of cache miss invalidates and restarts a corresponding build.
diff --git a/documentation/specs/proposed/BuildCheck-feature-threat-model.md b/documentation/specs/proposed/BuildCheck-feature-threat-model.md
deleted file mode 100644
index feeb937433a..00000000000
--- a/documentation/specs/proposed/BuildCheck-feature-threat-model.md
+++ /dev/null
@@ -1,84 +0,0 @@
-
-# Threat model of MSBuild BuildCheck feature
-
-## BuildCheck Feature Description
-
-The infrastructure within MSBuild allowing pluggability and execution of
-Analyzers and their Rules previously known as "warning waves" and
-"MSBuild Analyzers".
-
-The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
-
-[Design
-Spec](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck.md)
-
-[Architecture](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md)
-
-# Threats Identification
-
-This feature does not alter existing nor create any new trust boundaries.
-
-It is assumed to rely on only trusted sources, be managed by trusted operators, and operated on trusted machines.
-
-For this document, we do not address any threats that result from violating these conditions.
-
-## Acquisition
-
-### Threat: Supply chain attack on custom analyzer
-
-Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
-
-#### Mitigation
-
-Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
-
-Custom analyzers are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
-Users is expected to implement process to detect and warn about known malicious custom analyzers.
-
-## Execution
-
-### Threat: Supply chain attack by custom analyzer
-
-Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
-
-#### Mitigation
-
-Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
-
-### Threat: Third-Party Vulnerabilities
-Vulnerabilities in custom analyzer or its dependencies.
-
-#### Mitigation
-
-Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
-
-## Configuration
-
-### Threat: Malicious configuration value
-
-Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an analyzer or cause build malfunction for any reason.
-
-#### Mitigation
-
-This problem is identical to existing .editorconfig for Roslyn analyzers and since we share code for parsing it, we adopt same mitigation strategy, which is:
-
-- default template for editor config has `root = true` stopping parent config traversing
-- code is unit tested to verify and sanitize .editorconfig values
-
-### Threat: Intentional analyzer ID conflict or misleading ID
-
-Malicious actors can define analyzer ID to be identical or like existing well known analyzer ID to increase probability of executing malicious analyzer code.
-
-#### Mitigation
-
-Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
-
-## Declaration
-
-### Threat: Malicious analyzer registration property function
-
-Threat actor can write malicious analyzer registration property function in project files, with intent to run code from non-governed assemblies.
-
-#### Mitigation
-
-This threat is out of scope of this document, as this requires malicious modification of source code (repository) making these sources untrusted.
diff --git a/documentation/specs/proposed/BuildCheck.md b/documentation/specs/proposed/BuildCheck.md
deleted file mode 100644
index 4fa78061b78..00000000000
--- a/documentation/specs/proposed/BuildCheck.md
+++ /dev/null
@@ -1,404 +0,0 @@
-
-# BuildCheck - Design Spec
-
-Previously known as "warning waves" and "MSBuild Analyzers"
-
-The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
-
-# Terminology
-
-* **Analyzer** – unit of execution (single implementing class), can host multiple rules. 
-* **Rule** – Single violation type, with single unique code (`“BC1234: Redefining built-in target”`). 
-* **Report** – Output from Analyzer informing about violating particular rule.
-* **CodeFix** – Violation remedy suggestion. Not yet applicable for MSBuild.
-* **BuildCheck** - Feature name. The infrastructure within MSBuild allowing pluggability and execution of Analyzers and their Rules
-
-
-# North Star / Longer-term vision
-
-MSBuild provides a rich object model (further just OM) exposing representation of the build scripts (unstructured and structured model of documents contributing to the build), build data (the definition and evaluated values of MSBuild primitives) and build execution (the eventing model of inputs, processing and outputs of the orchestrated execution) so that various quality checking rules can be authored. This includes static analysis rules (e.g. checking validity of condition expressions) as well as build execution rules (e.g. checking of referencing nonexistent files) and composition rules (e.g. unintended outputs overwrites checking). Identical OM is exposed from live build execution and via post-build log event sourcing – so that users can choose whether the build analysis will happen as part of the build or as a separate process.
-
-Users are able to tune the behavior of the checks via `.editorconfig` which brings unified and standardized experience with other tooling (including built-in and third-party C# analyzers) leveraging `.editorconfig` files.
-
-Powerusers are able to develop, test and publish their custom analyzers easily and contribute them back to community. The local development scenario doesn’t require roundtrip through packaging.
-
-A solid set of in-the-box analyzers is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box analyzers are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase the quality of our customers build scripts. To avoid breaking customers builds, there will still be an explicit user gesture required to opt into running the analysis. This will be done either by configuring the analyzers with `.editorconfig` or auto-enabling the analysis based on the TFM of the project. There will be no difference between building with `dotnet build` and with `MSBuild.exe`, they will follow the same enablement rules with the set of enabled built-in analyzers derived from `.editorconfig` and TFM/props. Building in Visual Studio will eventually reach parity with command-line build as well.
-
-Projects that don't use the .NET SDK and those that are not SDK-style at all are TBD. There is a possibility of using a property like `MSBuildAnalysisLevel` to enable some base analyzers we believe will add value everywhere.
-
-The analysis has small impact on build duration with ability to disable analysis altogether which will remove all the performance costs associated with the analysis. The perf impact on representative projects is continuously monitored and documented by the MSBuild team.
-
-
-# Scope of initial iteration
-
-Majority of following cases are included in appropriate context within the scenarios in [User Experience](#user-experience) section. Following is a quick overview.
-
-## In scope
-* Inbox (built-in) analyzers that run during the build execution.
-* Inbox analyzers that run when replaying binlog.
-* Custom authored analyzers, delivered via nuget.
-* Analyzers reports (errors, warnings, messages) are in logger output, VS error window.
-* Codes will be distinguishable from standard build warnings/error (to prevent easy mixups and attempts to configure standard msbuild warnings/errors via editorconfig), but otherwise the outputs are very similar.
-* Default opt-ins and levels for inbox analyzers set by sdk version (via [`$SdkAnalysisLevel`]((https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md))) or other agreed mechanism for controlling increasing strictness between .NET versions.
-* Custom analyzers opted in via `PackageReference` of a particular nuget with the analyzer.
-* Explicit overrides of enablement and analysis levels via `.editorconfig` file (with up to a per-project scope).
-* [Specification of `.editorconfig`](https://spec.editorconfig.org/) will be observed. 
-* Simplified authoring experience via template and doc.
-* Single analyzer can produce reports for multiple rules. However those need to be declared upfront.
-* Opt-in reporting of time spent via specific analyzers and infra overall.
-* Collect touched `.editorconfig`s into binlog embedded files.
-* Possibility to opt-out from analysis - the perf should not be impacted when done so.
-* Team collects performance impact numbers on a set of benchmark builds with the inbox analyzers enabled.
-
-## Non Goals, but subject for consideration
-* Custom analyzer in a local project (source codes) or a binary.
-* Bulk configuration of multiple rules (based on prefixes).
-* Specifying scope of MSBuild imports that will be considered for analysis (so that e.g. data from sdk won't even be passed to analyzer, if not requested).
-* Attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
-* Configuring analysis levels when analyzing from binlog - beyond the collected editorconfigs
-* Structured information in VS error window (similarly to the Roslyn analyzer reports - reports have titles, details, locations, searchable codes and exposed links leading to detailed documentation).
-
-
-## Out of scope
-* Instrumentation for telemetry.
-* Design time build analysis.
-* Localization support (for reports message formats, identifiers, etc.).
-* Custom analyzers have equal data access as the inbox analyzers. We'll aim to ship analyzers that use public BuildCheck API/OM surface. But for extra agility we might chose to implement and ship some analyzers using unexposed data.
-* All inbox analyzers reports have precise location(s) of issues (however for each individual analyzer not providing precise location we should have a very strong reason, why location cannot be provided and why it still brings value even without precise location).
-* Opt-out of analysis on code-level (something like C# `#pragma warning disable`, but within msbuild xml files).
-* Simplified authoring experience via dedicated reference assembly.
-* Restore phase analysis.
-* Turning analysis off/on based on target (e.g. multi-targeted builds, calling MSBuild task etc.).
-* Controlling/Configuring lifetime of analyzers - analyzers will currently be held alive, as single instance per analyzer, for the whole duration of the build. But future versions might prevent some of the analyzers to survive beyond a scope of a single project built (means for sharing data would be provided).
-* Event Tracing for Windows (ETW) for analyzers.
-* Attributing `.editorconfig` configurations to .sln files. E.g.:
-```ini
-# I expect this to apply to all projects within my solution, but not to projects which are not part of the solution
-[ContosoFrontEnd.sln]
-build_check.BC0101.IsEnabled=true
-build_check.BC0101.Severity=warning
-```
-* Attributing `.editorconfig` configurations to lower granularity than whole projects. E.g.:
-```ini
-# I expect this to apply only to a scope of the imported file. Or possibly I expect this to apply to all projects importing this project.
-[ContosoCommonImport.proj]
-buildcheck.BC0101.IsEnabled=true
-buildcheck.BC0101.Severity=warning
-```
-* Respecting `.editorconfig` file in msbuild import locations (unless they are in the parent folders hierarchy of particular project file).
-* CodeFixes are not supported in V1
- 
-
-# User Experience
-
-## Running / UX
-
-### Inbox Analyzers
-
-Suggested list of analyzers to be shipped with V1: https://github.com/dotnet/msbuild/issues/9630#issuecomment-2007440323
-
-The proposed initial configuration for those is TBD (as well based on initial test runs of the analyzers of chosen public repositories).
-
-### Live Build
-
-BuildCheck will run as part of the build and execute [inbox analyzers](#inbox-analyzers) and [custom analyzers](#acquisition-of-custom-analyzers) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via an MSBuild property (could be set in a project file or passed on the commandline).
-
-Findings - reports - of analyzers will be output as build messages/warnings/errors, and the message/warnings/error code should help distinguish BuildCheck produced reports from regular build errors/warnings.
-
-BuildCheck reports will have power to fail the build (via errors or warnings), that would otherwise succeed without the BuildCheck. This is actually the main benefit of the feature - as it helps enforcing new rules, that are easily user configurable individually or as a whole feature - to prevent unwanted breakages of legacy builds not ready for improvements.
-
-### Binlog Replay mode
-
-Users will have option to explicitly opt-in to run BuildCheck during the binlog replay mode:
-
-```bash
-> dotnet build msbuild.binlog /analyze
-```
-
-Would there be any analyzers that are not possible to run during the replay mode (subject to internal design - this difference won't be exposed during [custom analyzers authoring](#custom-analyzers-authoring)), replay mode will inform user about those via warnings.
-
-Replay mode will by default consider `.editorconfig` files stored within the binlog and will run analyzers based on those. This would possibly lead to unintended double-reports – as binlog will have the runtime analysis reports stored, plus the replay-time analysis reports will be augmented. At the same time we might want to run some additional checks in the replay mode, that have not been enabled (or not even available) during the build time.
-
-For this reason we will consider following modes (all are non-goals):
-* All binlog stored reports are skipped by default. We add option to request not skipping them (but they might need to be prefixed or otherwise distinguished from the 'fresh' reports).
-* Ability to specify skipping of the stored .editorconfig files
-* Ability to specify single replay-time .editorconfig file and it’s precedence (only the specified, specified as most significant, specified as least significant)
-
-We might as well consider specifying custom analyzers on a command line (as a non-goal) - so that unreferenced custom analyzers can be run against the binlog.
-
-## Configuration
-
-There will be 3 mechanisms of configuring the analyzers and rules:
-* The default configuration declared by the analyzers themselves ([more details on implementation](#rules-declaration))
-* The TFM of the project and the [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox analyzers
-* `.editorconfig` file
-
-We will also consider respecting `SdkAnalysisLevel` to override the per-TFM defaults. Additionally, we may introduce a new "master switch" property, tentatively called `RunMSBuildChecks`, to make it possible to disable everything whole-sale. This would be used in scenarios like F5 in VS.
-```
-Skipping analyzers to speed up the build. You can execute 'Build' or 'Rebuild' command to run analyzers.
-```
-
-Here's the proposed release schedule:
-- **.NET 9** - the feature is introduced and enabled in `dotnet build` and `MSBuild.exe` command-line builds. It is not enabled in VS just yet. No analyzers are enabled by default. It is not technically required to read the TFM or any other props during evaluation, though it would be nice to respect `RunMSBuildChecks` already in this release. `.editorconfig` can be the sole source of configuration.
-- **.NET 10** - based on feedback and testing, we choose a set of analyzers to enable by default for projects targeting `net10.0`, and enable the feature as a whole in Visual Studio. Depending on how we feel about the perf characteristics of evaluation, especially the "double evaluation" mandated by discovering evaluation-tracking analyzers just-in-time, we may want to omit such analyzers from the default set.
-- **.NET 11** and beyond - some more analyzers are enabled for projects targeting `net11.0`, the `net10.0` does not change. Everything is mature and performant enough that we are able to auto-enable any analyzer. The gradual tightening of rules enabled by default gets us closer to the long envisioned "strict mode", which will ultimately allow us to evolve MSBuild to be simpler and more performant.
-
-
-For the `.editorconfig` file configuration, following will apply:
-* Only `.editorconfig` files collocated with the project file or up the folder hierarchy will be considered.
-* `.editorconfig` files placed along with explicitly or implicitly imported msbuild files won’t be considered.
-* `.editorconfig` files packaged within nuget packages within local nuget cache won’t be considered.
-
-### Non-Goals (but might be considered):
-* bulk configuration of multiple rules - based on analyzers/rules prefixes or/and categories.
-* attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
-* configuring analysis levels when analyzing from binlog - beyond the collected editorconfigs.
-* Aliasing the analyzers/rules, allowing to create multiple instances with different custom configuration (e.g. single analyzer checking configurable list of forbidden properties prefixes can have 2 instance, each initialized with different list to check, each of the instance configurable for individual projects separately).
-
-### Out of scope for configuration:
-* opt-out of analysis on code-level (analogy to C# pragmas, but within msbuild xml files).
-* lower granularity of `.editorconfig` settings other than whole projects.
-* attributing configuration to a .sln file and expecting it will apply to all contained projects.
-* Support for multiple [custom configurations](#custom-configuration-declaration) within a single build for a single rule. (Not to be mixed with [standardized configuration](#standardized-configuration-declaration) - which can be configured freely per project) If a custom configuration will be used, it will need to be specified identically in each explicit configurations of the rule. This is chosen so that there are no implicit requirements on lifetime of the analyzer or analyzer instancing – each analyzer will be instantiated only once per build (this is however something that will very likely change in future versions – so authors are advised not to take hard dependency on single instance policy).
-
-### Sample configuration
-
-```ini
-[*.csproj]
-build_check.BC0101.Severity=warning
-
-build_check.COND0543.Severity=none
-build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
-build_check.COND0543.CustomSwitch=QWERTY
-```
-
-### User Configurable Options
-
-Initial version of BuildCheck plans a limited set of options configurable by user (via `.editorconfig`) by which users can override default configuration of individual analyzer rules.
-
-**NOTE:** The actual naming of the configuration options is yet to be determined.
-
-#### Severity
-
-Option `Severity` with following values will be available:
-
-* `Default`
-* `None`
-* `Suggestion`
-* `Warning`
-* `Error`
-
-Severity levels are in line with [roslyn analyzers severity levels](https://learn.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers). `Default` severity in `.editorconfig` will lead to using build-in severity from the analyzer (so this can be used for clearing custom severity setting from higher level `.editorconfig` file). `Default` severity in the build-in code has same effect as if the code doesn't specify severity at all - an infrastruture default of `None` is considered.
-
-Configuration will dictate transformation of the analyzer report to particular build output type (message, warning or error).
-
-Each rule has a severity, even if multiple rules are defined in a single analyzer. The rule can have different severities for different projects within a single build session.
-
-If all the rules from a single analyzer have severity `None` - analyzer won't be given any data for such configured part of the build (specific project or a whole build). If analyzer have some rules enabled and some disabled - it will be still fed with data, but the reports will be post-filtered.
-
-#### Scope of Analysis
-
-Option `EvaluationAnalysisScope` with following possible options will be available:
-* `ProjectOnly` - Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded.
-* `ProjectWithImportsFromCurrentWorkTree` - Only the data from currently analyzed project and imports from files under the entry project or solution will be sent to the analyzer. Other imports will be discarded.
-* `ProjectWithImportsWithoutSdks` - Imports from SDKs will not be sent to the analyzer. Other imports will be sent.
-* `ProjectWithAllImports` - All data will be sent to the analyzer.
-
-All rules of a single analyzer must have the `EvaluationAnalysisScope` configured to a same value. If any rule from the analyzer have the value configured differently - a warning will be issued during the build and analyzer will be deregistered.
-
-Same rule can have `EvaluationAnalysisScope` configured to different values for different projects.
-
-BuildCheck might not be able to guarantee to properly filter the data with this distinction for all [registration types](#RegisterActions) - in case an explicit value is attempted to be configured (either [from the analyzer code](#BuildAnalyzerConfiguration) or from `.editorconfig` file) for an analyzer that has a subscription to unfilterable data - a warning will be issued during the build and analyzer will be deregistered.
-
-
-## Analyzers and Rules Identification
-
-**TBD**
-
-* Recommended and reserved prefixes
-* Short vs descriptive names
-* Rules categories
-* Ability to use prefixes during configuration
-
-
-## Custom Analyzers Authoring
-
-### Implementation
-
-To author custom analyzer, user will need to implement given contract (delivered in Microsoft.Build package). The contract will provide access to the exposed BuildCheck OM focused on build analysis.
-
-#### Analyzer declaration
-
-Simplified proposal:
-
-```csharp
-public abstract class BuildAnalyzer : IDisposable
-{
-    /// <summary>
-    /// Friendly name of the analyzer.
-    /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
-    /// </summary>
-    public abstract string FriendlyName { get; }
-
-    /// <summary>
-    /// Single or multiple rules supported by the analyzer.
-    /// </summary>
-    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
-
-    /// <summary>
-    /// Optional initialization of the analyzer.
-    /// </summary>
-    /// <param name="configurationContext">
-    /// Custom data (not recognized by the infrastructure) passed from .editorconfig
-    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
-    /// </param>
-    public abstract void Initialize(ConfigurationContext configurationContext);
-
-    /// <summary>
-    /// 
-    /// </summary>
-    /// <param name="context"></param>
-    public abstract void RegisterActions(IBuildCheckRegistrationContext context);
-
-    public virtual void Dispose()
-    { }
-}
-```
-
-<a name="RegisterActions"></a>The context in `RegisterActions` call will enable subscriptions for data pumping from the infrastructure. 
-
-Sample of how registrations might look like:
-
-```csharp
-public interface IBuildCheckRegistrationContext
-{
-    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
-
-    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
-
-    // ...
-}
-```
-
-The data provided in callbacks for registered actions will allow the analyzer to submit reports for its rules. A single callback can lead to multiple reports being generated.
-
-Any analyzer will be allowed to produce reports only for Rules that it declared in it’s `SupportedRules` definition.
-
-#### Rules declaration
-
-A single analyzer can declare support of multiple rules – since it might produce reports for those on top of same input data – and for efficiency reasons a single processing of data might be needed.
-
-Simplified proposal of definition of a single rule:
-
-```csharp
-public class BuildAnalyzerRule
-{
-    // Identification/Description fields
-    // (To be defined more precisely by https://github.com/dotnet/msbuild/issues/9823)
-
-    /// <summary>
-    /// The default configuration - overridable by the user via .editorconfig.
-    /// If no user specified configuration is provided, this default will be used.
-    /// </summary>
-    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
-}
-```
-
-<a name="BuildAnalyzerConfiguration"></a>Each rule will supply its default configuration (mainly enablement and report severity) – those will apply if `.editorconfig` file will not set those settings explicitly. If the rule doesn't provide (some of) its defaults, a global hardcoded default is used (`severity: message, enabled: false`).
-
-#### Standardized configuration declaration
-
-Proposal of configuration specification:
-
-```csharp
-/// <summary>
-/// Configuration for a build analyzer.
-/// Default values can be specified by the Analyzer in code.
-/// Users can overwrite the defaults by explicit settings in the .editorconfig file.
-/// Each rule can have its own configuration, which can differ per each project.
-/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
-/// </summary>
-public class BuildAnalyzerConfiguration
-{
-    /// <summary>
-    /// This applies only to specific events, that can distinguish whether they are directly inferred from
-    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
-    ///
-    /// If not supported by the data source - then the setting is ignored
-    /// </summary>
-    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
-
-    /// <summary>
-    /// The default severity of the result for the rule. May be overridden by user configuration.
-    ///
-    /// If all rules within the analyzer are `none`, the whole analyzer will not be run.
-    /// If some rules are `none` and some are not, the analyzer will be run and reports will be post-filtered.
-    /// </summary>
-    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
-}
-```
-
-Values for this recognized contract, that are explicitly specified via .editorconfig files are passed only to the BuildCheck infrastructure – they are invisible to the actual analyzers (NOTE: this is a subject to likely revision).
-
-#### Custom configuration declaration
-
-However if user will specify additional – unrecognized - values in `.editorconfig` file as part of a particular analyzer configuration – those values will be extracted as key-value pairs and passed to the analyzer initialization call (`Initialize`) via `ConfigurationContext`:
-
-```csharp
-/// <summary>
-/// Holder of an optional configuration from .editorconfig file (not recognized by the infrastructure)
-/// </summary>
-public class ConfigurationContext
-{
-    /// <summary>
-    /// Custom configuration data - per each rule that has some specified.
-    /// </summary>
-    public CustomConfigurationData[] CustomConfigurationData { get; init; }
-}
-```
-
-This can allow creation of extendable checks – e.g. a check that will validate that properties defined within project do not start with any forbidden prefix, while actual prefixes to check are configurable – so the user of the check can tune the behavior to their needs.
-
-More details on configuration are in [Configuration](#configuration) section.
-
-
-#### Compatibility
-
-All the publicly exposed contracts will be available within `Microsoft.Build.Experimental.BuildCheck` namespace. The namespace is expressing that contracts are not guaranteed to be backward compatible (however breakage will be limited to necessary cases). The availability of particular set of BuildCheck API will be queryable via [Feature Query API](https://github.com/dotnet/msbuild/pull/9665):
-
-```csharp
-var availability = Features.CheckFeatureAvailability("BuildCheck.Beta");
-```
-
-This way the analyzers authors will be equipped to write highly-compatible analyzers even in a possibility of changing API.
-
-
-### Testing and Debugging
-
-**TBD**
-
-We aim to provide ability to locally test analyzers from local projects or assemblies without a need to roundtrip through packaging them. The exact way is yet to be determined.
-
-At the same time we aim to provide mocks providing the BuildCheck context data – this work is however a non-goal.
-
-### Packaging
-
-Several requirements are mandated for analyzer packages to be properly recognized (Netstandard only, A call to designated property function will need to be part of the packaged build assets, dependencies will need to be packaged, binaries structure flattened). There might as well be couple of optional practices making the analyzer package more resources savvy (E.g. defining the rule ids and enablement status within the mentioned property function - so that such information doesn't require loading and calling of the analyzer type).
-
-Also custom analyzer package is a dependency is a purely development time harness - so it should be marked as [`DevelopmentDependency`](https://learn.microsoft.com/en-us/nuget/reference/nuspec#developmentdependency).
-
-In order to simplify the packaging process (and meeting above mentioned requirements) a dotnet template will be provided producing proper package on pack action.
-
-**TBD** - dotnet new sample on initiating the development.
-
-## Acquisition of custom analyzers
-
-Apart from [inbox analyzers](#inbox-analyzers) (shipped together with msbuild), users will be able to plug-in packaged analyzers shipped as nugets (this will serve for community contributions, but possibly as a venue for off-cycle distribution of official analyzers).
-
-In order to use an analyzer package users just need to reference them via `<PackageReference>` element as standard package reference. 
-
-```xml
-<PackageReference Include="Contoso.Analyzers" Version="1.2.3" />
-```
-
-Only projects referencing the package will be able to run its analyzers. Enabling the rules from package on other projects won’t take any effect.
diff --git a/documentation/specs/proposed/analyzers-acquisition.png b/documentation/specs/proposed/analyzers-acquisition.png
new file mode 100644
index 00000000000..865871d9c4a
Binary files /dev/null and b/documentation/specs/proposed/analyzers-acquisition.png differ
diff --git a/documentation/wiki/Bootstrap.md b/documentation/wiki/Bootstrap.md
new file mode 100644
index 00000000000..e33007c0f73
--- /dev/null
+++ b/documentation/wiki/Bootstrap.md
@@ -0,0 +1,22 @@
+# Bootstrap MSBuild
+
+Because the binaries and build logic in this repo aren't sufficient to build real-world projects, we need a test environment that mimics the real-world combinations of MSBuild, Roslyn compilers, and other things that combine in the .NET SDK and in Visual Studio to produce a functional build environment. We call this the "bootstrap".
+
+## Quick Intro
+The document describes the logic behind the bootstrap and testing capabilities for the fresh MSBuild bits.
+
+## History
+MSBuild supports two different environments: .NET and .NET Framework. To test changes for .NET, fresh bits were published (the actual target Publish run) to the MSBuild.Bootstrap folder. These bits, along with specific dependencies, were later combined with parts of the .NET SDK that was used to build MSBuild to the bootstrap, making them ready for use with dotnet.exe. To execute the bootstrap MSBuild, you'd combine the `dotnet.exe` muxer from the .dotnet folder with the path to the bootstrap's `MSBuild.dll`.
+
+## Current Implementation for .NET
+During the bootstrap phase, install-scripts are used to download a full copy of the .NET SDK compatible with the current version. The logic for interacting with the scripts has been encapsulated in a separate MSBuild task: InstallDotNetCoreTask.cs. Here’s what happens under the hood:
+
+The SDK is downloaded to the bootstrap folder.
+Fresh MSBuild bits are then copied to this folder.
+The constructed SDK is used for both local end-to-end tests and CI runs.
+
+## Potential Cons
+The reliance on downloading the SDK from a remote source requires an internet connection. For the initial build of the repository, this doesn't change as the SDK is always downloaded to the .dotnet folder first. For subsequent runs, the SDK in bootstrap will be downloaded again only **if the requested version was changed**.
+
+## Pros
+This approach simplifies testing MSBuild as part of dotnet by providing a ready and reliable environment without needing to patch anything into a globally installed SDK, as was previously required.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index c30d03cea0f..ef38fa5942e 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -42,27 +42,6 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Introduce [MSBuild]::StableStringHash overloads](https://github.com/dotnet/msbuild/issues/9519)
 - [Keep the encoding of standard output & error consistent with the console code page for ToolTask](https://github.com/dotnet/msbuild/pull/9539)
 
-### 17.8
-- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
-- [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
-- [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
-- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
-
-### 17.6
-- [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
-- [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
-- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
-- [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
-- [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
-- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
-
-### 17.4
-- [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
-- [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
-- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
-- [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
-- [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
-
 ## Change Waves No Longer In Rotation
 ### 16.8
 - [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
@@ -88,3 +67,27 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
 - [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
 - [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
+
+### 17.4
+
+- [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
+- [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
+- [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
+- [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
+- [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
+
+### 17.6
+
+- [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
+- [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
+- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
+- [Log assembly loads](https://github.com/dotnet/msbuild/pull/8316)
+- [AnyHaveMetadataValue returns false when passed an empty list](https://github.com/dotnet/msbuild/pull/8603)
+- [Log item self-expansion](https://github.com/dotnet/msbuild/pull/8581)
+
+### 17.8
+
+- [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
+- [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
+- [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
+- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/eng/BootStrapMsBuild.props b/eng/BootStrapMsBuild.props
index 858cf76ac54..3dd91450e88 100644
--- a/eng/BootStrapMsBuild.props
+++ b/eng/BootStrapMsBuild.props
@@ -1,20 +1,19 @@
 <Project>
 
-  <!--
-  Construct a location of MSBuild bootstrap folder - to be used for deployment and for tests
-   relying on bootstrapped MSBuild
-   -->
+  <!-- Construct a location of MSBuild bootstrap folder - to be used for deployment and for tests relying on bootstrapped MSBuild -->
 
   <PropertyGroup>
     <BootstrapDestination>$(ArtifactsBinDir)bootstrap\</BootstrapDestination>
     <BootstrapDestination Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
+
+    <!-- This path is used for Windows Full test run and it points to net472 during execution-->
     <BootstrapDestination>$(BootstrapDestination)$(TargetFramework.ToLowerInvariant())\MSBuild\</BootstrapDestination>
   </PropertyGroup>
-  
+
   <PropertyGroup Condition="$(TargetFramework.StartsWith('net4'))">
     <BootstrapBinaryDestination>$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin</BootstrapBinaryDestination>
   </PropertyGroup>
-  
+
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
     <BootstrapBinaryDestination>$(BootstrapDestination)</BootstrapBinaryDestination>
   </PropertyGroup>
diff --git a/eng/BootStrapMsBuild.targets b/eng/BootStrapMsBuild.targets
index 9209876eecf..dcff8617638 100644
--- a/eng/BootStrapMsBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -202,56 +202,40 @@
            AlwaysCreate="true" />
   </Target>
 
-  <Target Name="BootstrapNetCore" DependsOnTargets="CleanBootstrapFolder">
+  <!-- The task allow to download sdk bits for the specified version. It will be used later to bootstrap the runnable MSBuild. -->
+  <UsingTask TaskName="InstallDotNetCoreTask"
+             AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"
+             TaskFactory="RoslynCodeTaskFactory">
+    <Task>
+      <Code Source="$(MSBuildThisFileDirectory)..\src\MSBuild.Bootstrap.Utils\Tasks\InstallDotNetCoreTask.cs" Language="cs" />
+    </Task>
+  </UsingTask>
+  <Target Name="AcquireSdk"
+          BeforeTargets="PrepareForBuild"
+          Condition="!$(TargetFramework.StartsWith('net4'))">
+
+    <PropertyGroup>
+      <InstallDir>$(ArtifactsBinDir)bootstrap\core\</InstallDir>
+    </PropertyGroup>
+
+    <InstallDotNetCoreTask DotNetInstallScriptRootPath="$(DotNetRoot)" InstallDir="$(InstallDir)" Version="$(BootstrapSdkVersion)"/>
+  </Target>
 
-    <!-- Publish the project first.  The more obvious way to do this would be to depend on the Publish target,
-         but that causes a target dependency cycle, even though it seems like AfterTargets="AfterBuild" should
-         probably not count as a link in the cycle. -->
-    <MSBuild Projects="$(MSBuildProjectFile)" Targets="Publish" BuildInParallel="$(BuildInParallel)" />
+  <Target Name="BootstrapNetCore" DependsOnTargets="AcquireSdk">
 
     <ItemGroup>
-      <!-- Copy all items from the publish folder to the bootstrap folder.  We might be able to just use the published
-            version as the bootstrapped version, but the extra separation here seems like it could be valuable. -->
-      <DeployedItems Include="$(PublishDir)\**\*.*" />
-
-      <NuGetSdkResolverManifest Include= "$(RepoRoot)src\MSBuild\SdkResolvers\Standalone\Microsoft.Build.NuGetSdkResolver.xml" />
-      <InstalledSdks Include="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Sdks\**\*.*" />
-      <InstalledExtensions Include="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Current\**\*.*" Exclude="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Current\Microsoft.Common.props" />
+     <!-- *.deps.json are excluded because the SDK rewrites these files for consistency with the rest of the SDK, so take their version. -->
+      <FreshlyBuiltNetBinaries Include="$(OutDir)**\*.*" Exclude="$(OutDir)**\*.deps.json" />
     </ItemGroup>
-    <Copy SourceFiles="@(DeployedItems)"
-          DestinationFolder="$(BootstrapDestination)%(RecursiveDir)" />
-
-    <Copy SourceFiles="@(NuGetSdkResolverManifest)"
-          DestinationFolder="$(BootstrapDestination)SdkResolvers\Microsoft.Build.NuGetSdkResolver" />
-
-    <Copy SourceFiles="$(RuntimeIdentifierGraphPath)"
-          DestinationFolder="$(BootstrapDestination)" />
-
-    <Copy SourceFiles="@(InstalledSdks)"
-          DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)Sdks\%(RecursiveDir)%(Filename)%(Extension)')" />
-
-    <!-- The .NET SDK has a dependency on DependencyModel, but relies on having it in the final
-         MSBuild.deps.json, which differs from ours because it's generated in the SDK repo.
-
-         Copy it from "next to MSBuild" in the pre-bootstrap SDK to our little weirdo bootstrap
-         layout next to the SDK tasks, so it can get loaded by the SDK tasks that need it. -->
-    <Copy SourceFiles="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Microsoft.Extensions.DependencyModel.dll"
-          DestinationFolder="$(BootstrapDestination)Sdks\Microsoft.NET.Sdk\tools\$(LatestDotNetCoreForMSBuild)" />
-
-    <Copy SourceFiles="@(InstalledExtensions)"
-          DestinationFolder="$(BootstrapDestination)Current\%(RecursiveDir)" />
 
+    <!-- The copying of these dependencies is required by bootstrap\**\sdk\**\NuGet.RestoreEx.targets. Otherwise NuGet.Build.Tasks.dll can not be found. -->
     <Copy SourceFiles="@(_NuGetRuntimeDependencies)"
-          DestinationFolder="$(BootstrapDestination)" />
-
-    <Copy SourceFiles="$(RepoRoot)src\MSBuild.Bootstrap\RedirectNuGetConsoleProcess.After.Microsoft.Common.targets"
-          DestinationFolder="$(BootstrapDestination)\Current\Microsoft.Common.targets\ImportAfter" />
+          DestinationFolder="$(InstallDir)sdk\$(BootstrapSdkVersion)\"
+          SkipUnchangedFiles="true" />
 
-    <Copy SourceFiles="$(RepoRoot)src\MSBuild.Bootstrap\RedirectNuGetConsoleProcess.After.Microsoft.Common.targets"
-          DestinationFolder="$(BootstrapDestination)\Current\SolutionFile\ImportAfter" />
+    <Copy SourceFiles="@(FreshlyBuiltNetBinaries)"
+          DestinationFiles="@(FreshlyBuiltNetBinaries->'$(InstallDir)sdk\$(BootstrapSdkVersion)\%(RecursiveDir)%(Filename)%(Extension)')" />
 
-    <!-- Disable workload resolver until we can figure out whether it can work in the bootstrap
-         https://github.com/dotnet/msbuild/issues/6566 -->
-    <Touch Files="$(BootstrapDestination)\DisableWorkloadResolver.sentinel" AlwaysCreate="true" />
   </Target>
+
 </Project>
diff --git a/eng/Packages.props b/eng/Packages.props
index 6f4d99b91a9..e9c77ff48f9 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -19,6 +19,7 @@
     <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
     <PackageVersion Include="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
+    <PackageVersion Include="System.Formats.Asn1" Version="$(SystemFormatsAsn1Version)" />
     <PackageVersion Include="System.Memory" Version="$(SystemMemoryVersion)" />
     <PackageVersion Include="System.Net.Http" Version="$(SystemNetHttpVersion)" />
     <PackageVersion Include="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
diff --git a/eng/Signing.props b/eng/Signing.props
index 3e8e6dbf5cc..e542c633f4a 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -2,6 +2,8 @@
   <ItemGroup>
     <ItemsToSign Include="$(VisualStudioSetupInsertionPath)Microsoft.Build.UnGAC.exe" />
 
+    <ItemsToSign Include="$(ArtifactsDir)\xsd\Update-MSBuildXsds.ps1" />
+
     <FileSignInfo Include="RuntimeContracts.dll" CertificateName="3PartySHA2" />
   </ItemGroup>
 
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 477458641a0..765f504dee0 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -8,14 +8,14 @@
     <UsagePattern IdentityGlob="System.Collections.Immutable/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
     <UsagePattern IdentityGlob="System.Reflection.Metadata/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Resources.Extensions/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*8.0.0*" />
     <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*8.0.3*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*8.0.4*" />
     <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
   </IgnorePatterns>
   <Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index e8427285650..c489a3812ec 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -2,9 +2,9 @@
 <Dependencies>
   <ProductDependencies>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24257.2">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.24372.3">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>6ed73280a6d70f7e7ac39c86f2abe8c10983f0bb</Sha>
+      <Sha>30ed464acd37779c64e9dc652d4460543ebf9966</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
@@ -53,9 +53,9 @@
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
       <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
-    <Dependency Name="System.Text.Json" Version="8.0.3">
+    <Dependency Name="System.Text.Json" Version="8.0.4">
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>9f4b1f5d664afdfc80e1508ab7ed099dff210fbd</Sha>
+      <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
     </Dependency>
     <Dependency Name="System.Threading.Tasks.Dataflow" Version="8.0.0">
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
@@ -65,16 +65,20 @@
       <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
       <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
     </Dependency>
+    <Dependency Name="System.Formats.Asn1" Version="8.0.1">
+      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
+      <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
+    </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24270.4">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24376.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>f2b2071632d5d4c46d0f904f2b0d917b1752551b</Sha>
+      <Sha>1e2be7464703499cf98e20536fb4da4218c8fce1</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24270.4">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24376.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>f2b2071632d5d4c46d0f904f2b0d917b1752551b</Sha>
+      <Sha>1e2be7464703499cf98e20536fb4da4218c8fce1</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
@@ -87,18 +91,18 @@
       <Sha>73f0850939d96131c28cf6ea6ee5aacb4da0083a</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.11.0-preview.2.76">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.11.0-rc.122">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>f1525fc4017aab865deb9325b5f53aac2d8c4cf4</Sha>
+      <Sha>c0d441fc5e99e6765c9e0b2f77de162b9866b305</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.11.0-3.24301.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.11.0-3.24378.3">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>37b70f27ecf6578ad0b74d04406036b03ab90c8f</Sha>
+      <Sha>5e3a11e2e7f952da93f9d35bd63a2fa181c0608b</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24270.4">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24376.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>f2b2071632d5d4c46d0f904f2b0d917b1752551b</Sha>
+      <Sha>1e2be7464703499cf98e20536fb4da4218c8fce1</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 5ad30966449..28671ba9b35 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.11.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.8.3</PackageValidationBaselineVersion>
+    <VersionPrefix>17.12.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.11.0-preview-24318-05</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -26,6 +26,7 @@
   <PropertyGroup>
     <SystemCollectionsImmutableVersion>8.0.0</SystemCollectionsImmutableVersion>
     <SystemConfigurationConfigurationManagerVersion>8.0.0</SystemConfigurationConfigurationManagerVersion>
+    <SystemFormatsAsn1Version>8.0.1</SystemFormatsAsn1Version>
     <!--
         Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
         When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+
@@ -38,7 +39,7 @@
     <SystemResourcesExtensionsVersion>8.0.0</SystemResourcesExtensionsVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
-    <SystemTextJsonVersion>8.0.3</SystemTextJsonVersion>
+    <SystemTextJsonVersion>8.0.4</SystemTextJsonVersion>
     <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
     <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
@@ -48,13 +49,18 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24270.4</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24376.1</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.11.0-3.24301.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.11.0-preview.2.76</NuGetBuildTasksVersion>
+    <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.11.0-3.24378.3</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.11.0-rc.122</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
+
+  <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
+    <BootstrapSdkVersion>8.0.302</BootstrapSdkVersion>
+  </PropertyGroup>
+
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
 
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index b6e3c089135..ff9673037d8 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -84,8 +84,9 @@ try {
   }
   else
   {
-    $buildToolPath = $dotnetExePath
-    $buildToolCommand = Join-Path $bootstrapRoot "net8.0\MSBuild\MSBuild.dll"
+    $buildToolPath = Join-Path $bootstrapRoot "core\dotnet.exe"
+    # The version must be consistent with BootstrapSdkVersion
+    $buildToolCommand = Join-Path $bootstrapRoot "core\sdk\8.0.302\MSBuild.dll"
     $buildToolFramework = "net8.0"
   }
 
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 8edd377ec73..019829d55b9 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -58,8 +58,9 @@ bootstrapRoot="$Stage1Dir/bin/bootstrap"
 
 if [ $host_type = "core" ]
 then
-  _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
-  _InitializeBuildToolCommand="$bootstrapRoot/net8.0/MSBuild/MSBuild.dll"
+  _InitializeBuildTool="$bootstrapRoot/core/dotnet"
+  # The version must be consistent with BootstrapSdkVersion
+  _InitializeBuildToolCommand="$bootstrapRoot/core/sdk/8.0.302/MSBuild.dll"
   _InitializeBuildToolFramework="net8.0"
 else
   echo "Unsupported hostType ($host_type)"
diff --git a/eng/common/post-build/publish-using-darc.ps1 b/eng/common/post-build/publish-using-darc.ps1
index 5a3a32ea8d7..238945cb5ab 100644
--- a/eng/common/post-build/publish-using-darc.ps1
+++ b/eng/common/post-build/publish-using-darc.ps1
@@ -2,7 +2,6 @@ param(
   [Parameter(Mandatory=$true)][int] $BuildId,
   [Parameter(Mandatory=$true)][int] $PublishingInfraVersion,
   [Parameter(Mandatory=$true)][string] $AzdoToken,
-  [Parameter(Mandatory=$true)][string] $MaestroToken,
   [Parameter(Mandatory=$false)][string] $MaestroApiEndPoint = 'https://maestro.dot.net',
   [Parameter(Mandatory=$true)][string] $WaitPublishingFinish,
   [Parameter(Mandatory=$false)][string] $ArtifactsPublishingAdditionalParameters,
@@ -31,13 +30,13 @@ try {
   }
 
   & $darc add-build-to-channel `
-  --id $buildId `
-  --publishing-infra-version $PublishingInfraVersion `
-  --default-channels `
-  --source-branch main `
-  --azdev-pat $AzdoToken `
-  --bar-uri $MaestroApiEndPoint `
-  --password $MaestroToken `
+    --id $buildId `
+    --publishing-infra-version $PublishingInfraVersion `
+    --default-channels `
+    --source-branch main `
+    --azdev-pat "$AzdoToken" `
+    --bar-uri "$MaestroApiEndPoint" `
+    --ci `
 	@optionalParams
 
   if ($LastExitCode -ne 0) {
diff --git a/eng/common/sdl/NuGet.config b/eng/common/sdl/NuGet.config
index 3849bdb3cf5..5bfbb02ef04 100644
--- a/eng/common/sdl/NuGet.config
+++ b/eng/common/sdl/NuGet.config
@@ -5,11 +5,11 @@
   </solution>
   <packageSources>
     <clear />
-    <add key="guardian" value="https://securitytools.pkgs.visualstudio.com/_packaging/Guardian/nuget/v3/index.json" />
+    <add key="guardian" value="https://pkgs.dev.azure.com/dnceng/_packaging/Guardian1ESPTUpstreamOrgFeed/nuget/v3/index.json" />
   </packageSources>
   <packageSourceMapping>
     <packageSource key="guardian">
-      <package pattern="microsoft.guardian.cli" />
+      <package pattern="Microsoft.Guardian.Cli.win-x64" />
     </packageSource>
   </packageSourceMapping>
   <disabledPackageSources>
diff --git a/eng/common/sdl/execute-all-sdl-tools.ps1 b/eng/common/sdl/execute-all-sdl-tools.ps1
index 4715d75e974..81ded5b7f47 100644
--- a/eng/common/sdl/execute-all-sdl-tools.ps1
+++ b/eng/common/sdl/execute-all-sdl-tools.ps1
@@ -6,7 +6,6 @@ Param(
   [string] $BranchName=$env:BUILD_SOURCEBRANCH,                                                  # Optional: name of branch or version of gdn settings; defaults to master
   [string] $SourceDirectory=$env:BUILD_SOURCESDIRECTORY,                                         # Required: the directory where source files are located
   [string] $ArtifactsDirectory = (Join-Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY ('artifacts')),  # Required: the directory where build artifacts are located
-  [string] $AzureDevOpsAccessToken,                                                              # Required: access token for dnceng; should be provided via KeyVault
 
   # Optional: list of SDL tools to run on source code. See 'configure-sdl-tool.ps1' for tools list
   # format.
@@ -75,7 +74,7 @@ try {
   }
 
   Exec-BlockVerbosely {
-    & $(Join-Path $PSScriptRoot 'init-sdl.ps1') -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -AzureDevOpsAccessToken $AzureDevOpsAccessToken -GuardianLoggerLevel $GuardianLoggerLevel
+    & $(Join-Path $PSScriptRoot 'init-sdl.ps1') -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -GuardianLoggerLevel $GuardianLoggerLevel
   }
   $gdnFolder = Join-Path $workingDirectory '.gdn'
 
@@ -104,7 +103,6 @@ try {
           -TargetDirectory $targetDirectory `
           -GdnFolder $gdnFolder `
           -ToolsList $tools `
-          -AzureDevOpsAccessToken $AzureDevOpsAccessToken `
           -GuardianLoggerLevel $GuardianLoggerLevel `
           -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams `
           -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams `
diff --git a/eng/common/sdl/init-sdl.ps1 b/eng/common/sdl/init-sdl.ps1
index 3ac1d92b370..588ff8e22fb 100644
--- a/eng/common/sdl/init-sdl.ps1
+++ b/eng/common/sdl/init-sdl.ps1
@@ -3,7 +3,6 @@ Param(
   [string] $Repository,
   [string] $BranchName='master',
   [string] $WorkingDirectory,
-  [string] $AzureDevOpsAccessToken,
   [string] $GuardianLoggerLevel='Standard'
 )
 
@@ -21,14 +20,7 @@ $ci = $true
 # Don't display the console progress UI - it's a huge perf hit
 $ProgressPreference = 'SilentlyContinue'
 
-# Construct basic auth from AzDO access token; construct URI to the repository's gdn folder stored in that repository; construct location of zip file
-$encodedPat = [Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes(":$AzureDevOpsAccessToken"))
-$escapedRepository = [Uri]::EscapeDataString("/$Repository/$BranchName/.gdn")
-$uri = "https://dev.azure.com/dnceng/internal/_apis/git/repositories/sdl-tool-cfg/Items?path=$escapedRepository&versionDescriptor[versionOptions]=0&`$format=zip&api-version=5.0"
-$zipFile = "$WorkingDirectory/gdn.zip"
-
 Add-Type -AssemblyName System.IO.Compression.FileSystem
-$gdnFolder = (Join-Path $WorkingDirectory '.gdn')
 
 try {
   # if the folder does not exist, we'll do a guardian init and push it to the remote repository
diff --git a/eng/common/sdl/sdl.ps1 b/eng/common/sdl/sdl.ps1
index 648c5068d7d..7fe603fe995 100644
--- a/eng/common/sdl/sdl.ps1
+++ b/eng/common/sdl/sdl.ps1
@@ -4,6 +4,8 @@ function Install-Gdn {
         [Parameter(Mandatory=$true)]
         [string]$Path,
 
+        [string]$Source = "https://pkgs.dev.azure.com/dnceng/_packaging/Guardian1ESPTUpstreamOrgFeed/nuget/v3/index.json",
+
         # If omitted, install the latest version of Guardian, otherwise install that specific version.
         [string]$Version
     )
@@ -19,7 +21,7 @@ function Install-Gdn {
     $ci = $true
     . $PSScriptRoot\..\tools.ps1
 
-    $argumentList = @("install", "Microsoft.Guardian.Cli", "-Source https://securitytools.pkgs.visualstudio.com/_packaging/Guardian/nuget/v3/index.json", "-OutputDirectory $Path", "-NonInteractive", "-NoCache")
+    $argumentList = @("install", "Microsoft.Guardian.Cli.win-x64", "-Source $Source", "-OutputDirectory $Path", "-NonInteractive", "-NoCache")
 
     if ($Version) {
         $argumentList += "-Version $Version"
diff --git a/eng/common/templates-official/job/publish-build-assets.yml b/eng/common/templates-official/job/publish-build-assets.yml
index 589ac80a18b..0117328800c 100644
--- a/eng/common/templates-official/job/publish-build-assets.yml
+++ b/eng/common/templates-official/job/publish-build-assets.yml
@@ -76,13 +76,16 @@ jobs:
     
     - task: NuGetAuthenticate@1
 
-    - task: PowerShell@2
+    - task: AzureCLI@2
       displayName: Publish Build Assets
       inputs:
-        filePath: eng\common\sdk-task.ps1
-        arguments: -task PublishBuildAssets -restore -msbuildEngine dotnet
+        azureSubscription: "Darc: Maestro Production"
+        scriptType: ps
+        scriptLocation: scriptPath
+        scriptPath: $(Build.SourcesDirectory)/eng/common/sdk-task.ps1
+        arguments: >
+          -task PublishBuildAssets -restore -msbuildEngine dotnet
           /p:ManifestsPath='$(Build.StagingDirectory)/Download/AssetManifests'
-          /p:BuildAssetRegistryToken=$(MaestroAccessToken)
           /p:MaestroApiEndpoint=https://maestro-prod.westus2.cloudapp.azure.com
           /p:PublishUsingPipelines=${{ parameters.publishUsingPipelines }}
           /p:OfficialBuildId=$(Build.BuildNumber)
@@ -137,14 +140,16 @@ jobs:
           BARBuildId: ${{ parameters.BARBuildId }}
           PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
 
-      - task: PowerShell@2
+      - task: AzureCLI@2
         displayName: Publish Using Darc
         inputs:
-          filePath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
-          arguments: -BuildId $(BARBuildId) 
+          azureSubscription: "Darc: Maestro Production"
+          scriptType: ps
+          scriptLocation: scriptPath
+          scriptPath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
+          arguments: -BuildId $(BARBuildId)
             -PublishingInfraVersion 3
-            -AzdoToken '$(publishing-dnceng-devdiv-code-r-build-re)'
-            -MaestroToken '$(MaestroApiAccessToken)'
+            -AzdoToken '$(System.AccessToken)'
             -WaitPublishingFinish true
             -ArtifactsPublishingAdditionalParameters '${{ parameters.artifactsPublishingAdditionalParameters }}'
             -SymbolPublishingAdditionalParameters '${{ parameters.symbolPublishingAdditionalParameters }}'
diff --git a/eng/common/templates-official/job/source-build.yml b/eng/common/templates-official/job/source-build.yml
index f193dfbe236..f983033bb02 100644
--- a/eng/common/templates-official/job/source-build.yml
+++ b/eng/common/templates-official/job/source-build.yml
@@ -31,6 +31,12 @@ parameters:
   #   container and pool.
   platform: {}
 
+  # If set to true and running on a non-public project,
+  # Internal blob storage locations will be enabled.
+  # This is not enabled by default because many repositories do not need internal sources
+  # and do not need to have the required service connections approved in the pipeline.
+  enableInternalSources: false
+
 jobs:
 - job: ${{ parameters.jobNamePrefix }}_${{ parameters.platform.name }}
   displayName: Source-Build (${{ parameters.platform.name }})
@@ -62,6 +68,8 @@ jobs:
     clean: all
 
   steps:
+  - ${{ if eq(parameters.enableInternalSources, true) }}:
+    - template: /eng/common/templates-official/steps/enable-internal-runtimes.yml
   - template: /eng/common/templates-official/steps/source-build.yml
     parameters:
       platform: ${{ parameters.platform }}
diff --git a/eng/common/templates-official/job/source-index-stage1.yml b/eng/common/templates-official/job/source-index-stage1.yml
index 43ee0c202fc..60dfb6b2d1c 100644
--- a/eng/common/templates-official/job/source-index-stage1.yml
+++ b/eng/common/templates-official/job/source-index-stage1.yml
@@ -23,7 +23,7 @@ jobs:
     value: ${{ parameters.sourceIndexPackageSource }}
   - name: BinlogPath
     value: ${{ parameters.binlogPath }}
-  - template: /eng/common/templates/variables/pool-providers.yml
+  - template: /eng/common/templates-official/variables/pool-providers.yml
 
   ${{ if ne(parameters.pool, '') }}:
     pool: ${{ parameters.pool }}
@@ -34,7 +34,8 @@ jobs:
         demands: ImageOverride -equals windows.vs2019.amd64.open
       ${{ if eq(variables['System.TeamProject'], 'internal') }}:
         name: $(DncEngInternalBuildPool)
-        demands: ImageOverride -equals windows.vs2019.amd64
+        image: windows.vs2022.amd64
+        os: windows
 
   steps:
   - ${{ each preStep in parameters.preSteps }}:
@@ -70,16 +71,13 @@ jobs:
         scriptType: 'ps'
         scriptLocation: 'inlineScript'
         inlineScript: |
-          echo "##vso[task.setvariable variable=ARM_CLIENT_ID]$env:servicePrincipalId"
-          echo "##vso[task.setvariable variable=ARM_ID_TOKEN]$env:idToken"
-          echo "##vso[task.setvariable variable=ARM_TENANT_ID]$env:tenantId"
+          echo "##vso[task.setvariable variable=ARM_CLIENT_ID;issecret=true]$env:servicePrincipalId"
+          echo "##vso[task.setvariable variable=ARM_ID_TOKEN;issecret=true]$env:idToken"
+          echo "##vso[task.setvariable variable=ARM_TENANT_ID;issecret=true]$env:tenantId"
 
     - script: |
-        echo "Client ID: $(ARM_CLIENT_ID)"
-        echo "ID Token: $(ARM_ID_TOKEN)"
-        echo "Tenant ID: $(ARM_TENANT_ID)"
         az login --service-principal -u $(ARM_CLIENT_ID) --tenant $(ARM_TENANT_ID) --allow-no-subscriptions --federated-token $(ARM_ID_TOKEN)
       displayName: "Login to Azure"
 
     - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name) -s netsourceindexstage1 -b stage1
-      displayName: Upload stage1 artifacts to source index
\ No newline at end of file
+      displayName: Upload stage1 artifacts to source index
diff --git a/eng/common/templates-official/jobs/source-build.yml b/eng/common/templates-official/jobs/source-build.yml
index 08e5db9bb11..5cf6a269c0b 100644
--- a/eng/common/templates-official/jobs/source-build.yml
+++ b/eng/common/templates-official/jobs/source-build.yml
@@ -21,6 +21,12 @@ parameters:
   # one job runs on 'defaultManagedPlatform'.
   platforms: []
 
+  # If set to true and running on a non-public project,
+  # Internal nuget and blob storage locations will be enabled.
+  # This is not enabled by default because many repositories do not need internal sources
+  # and do not need to have the required service connections approved in the pipeline.
+  enableInternalSources: false
+
 jobs:
 
 - ${{ if ne(parameters.allCompletedJobId, '') }}:
@@ -38,9 +44,11 @@ jobs:
     parameters:
       jobNamePrefix: ${{ parameters.jobNamePrefix }}
       platform: ${{ platform }}
+      enableInternalSources: ${{ parameters.enableInternalSources }}
 
 - ${{ if eq(length(parameters.platforms), 0) }}:
   - template: /eng/common/templates-official/job/source-build.yml
     parameters:
       jobNamePrefix: ${{ parameters.jobNamePrefix }}
       platform: ${{ parameters.defaultManagedPlatform }}
+      enableInternalSources: ${{ parameters.enableInternalSources }}
diff --git a/eng/common/templates-official/post-build/post-build.yml b/eng/common/templates-official/post-build/post-build.yml
index da1f40958b4..b81b8770b34 100644
--- a/eng/common/templates-official/post-build/post-build.yml
+++ b/eng/common/templates-official/post-build/post-build.yml
@@ -272,14 +272,16 @@ stages:
 
         - task: NuGetAuthenticate@1
 
-        - task: PowerShell@2
+        - task: AzureCLI@2
           displayName: Publish Using Darc
           inputs:
-            filePath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
+            azureSubscription: "Darc: Maestro Production"
+            scriptType: ps
+            scriptLocation: scriptPath
+            scriptPath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
             arguments: -BuildId $(BARBuildId) 
               -PublishingInfraVersion ${{ parameters.publishingInfraVersion }}
-              -AzdoToken '$(publishing-dnceng-devdiv-code-r-build-re)'
-              -MaestroToken '$(MaestroApiAccessToken)'
+              -AzdoToken '$(System.AccessToken)'
               -WaitPublishingFinish true
               -ArtifactsPublishingAdditionalParameters '${{ parameters.artifactsPublishingAdditionalParameters }}'
               -SymbolPublishingAdditionalParameters '${{ parameters.symbolPublishingAdditionalParameters }}'
diff --git a/eng/common/templates-official/steps/enable-internal-runtimes.yml b/eng/common/templates-official/steps/enable-internal-runtimes.yml
new file mode 100644
index 00000000000..93a8394a666
--- /dev/null
+++ b/eng/common/templates-official/steps/enable-internal-runtimes.yml
@@ -0,0 +1,28 @@
+# Obtains internal runtime download credentials and populates the 'dotnetbuilds-internal-container-read-token-base64'
+# variable with the base64-encoded SAS token, by default
+
+parameters:
+- name: federatedServiceConnection
+  type: string
+  default: 'dotnetbuilds-internal-read'
+- name: outputVariableName
+  type: string
+  default: 'dotnetbuilds-internal-container-read-token-base64'
+- name: expiryInHours
+  type: number
+  default: 1
+- name: base64Encode
+  type: boolean
+  default: true
+
+steps:
+- ${{ if ne(variables['System.TeamProject'], 'public') }}:
+  - template: /eng/common/templates-official/steps/get-delegation-sas.yml
+    parameters:
+      federatedServiceConnection: ${{ parameters.federatedServiceConnection }}
+      outputVariableName: ${{ parameters.outputVariableName }}
+      expiryInHours: ${{ parameters.expiryInHours }}
+      base64Encode: ${{ parameters.base64Encode }}
+      storageAccount: dotnetbuilds
+      container: internal
+      permissions: rl
diff --git a/eng/common/templates-official/steps/execute-sdl.yml b/eng/common/templates-official/steps/execute-sdl.yml
index 07426fde05d..301d5c591eb 100644
--- a/eng/common/templates-official/steps/execute-sdl.yml
+++ b/eng/common/templates-official/steps/execute-sdl.yml
@@ -9,8 +9,6 @@ parameters:
 
 steps:
 - task: NuGetAuthenticate@1
-  inputs:
-    nuGetServiceConnections: GuardianConnect
 
 - task: NuGetToolInstaller@1
   displayName: 'Install NuGet.exe'
diff --git a/eng/common/templates-official/steps/get-delegation-sas.yml b/eng/common/templates-official/steps/get-delegation-sas.yml
new file mode 100644
index 00000000000..c0e8f91317f
--- /dev/null
+++ b/eng/common/templates-official/steps/get-delegation-sas.yml
@@ -0,0 +1,43 @@
+parameters:
+- name: federatedServiceConnection
+  type: string
+- name: outputVariableName
+  type: string
+- name: expiryInHours
+  type: number
+  default: 1
+- name: base64Encode
+  type: boolean
+  default: false
+- name: storageAccount
+  type: string
+- name: container
+  type: string
+- name: permissions
+  type: string
+  default: 'rl'
+
+steps:
+- task: AzureCLI@2
+  displayName: 'Generate delegation SAS Token for ${{ parameters.storageAccount }}/${{ parameters.container }}'
+  inputs:
+    azureSubscription: ${{ parameters.federatedServiceConnection }}
+    scriptType: 'pscore'
+    scriptLocation: 'inlineScript'
+    inlineScript: |
+      # Calculate the expiration of the SAS token and convert to UTC
+      $expiry = (Get-Date).AddHours(${{ parameters.expiryInHours }}).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
+
+      $sas = az storage container generate-sas --account-name ${{ parameters.storageAccount }} --name ${{ parameters.container }} --permissions ${{ parameters.permissions }} --expiry $expiry --auth-mode login --as-user -o tsv
+
+      if ($LASTEXITCODE -ne 0) {
+        Write-Error "Failed to generate SAS token."
+        exit 1
+      }
+
+      if ('${{ parameters.base64Encode }}' -eq 'true') {
+        $sas = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($sas))
+      }
+
+      Write-Host "Setting '${{ parameters.outputVariableName }}' with the access token value"
+      Write-Host "##vso[task.setvariable variable=${{ parameters.outputVariableName }};issecret=true]$sas"
diff --git a/eng/common/templates-official/steps/get-federated-access-token.yml b/eng/common/templates-official/steps/get-federated-access-token.yml
new file mode 100644
index 00000000000..55e33bd38f7
--- /dev/null
+++ b/eng/common/templates-official/steps/get-federated-access-token.yml
@@ -0,0 +1,40 @@
+parameters:
+- name: federatedServiceConnection
+  type: string
+- name: outputVariableName
+  type: string
+- name: stepName
+  type: string
+  default: 'getFederatedAccessToken'
+- name: condition
+  type: string
+  default: ''
+# Resource to get a token for. Common values include:
+# - '499b84ac-1321-427f-aa17-267ca6975798' for Azure DevOps
+# - 'https://storage.azure.com/' for storage
+# Defaults to Azure DevOps
+- name: resource
+  type: string
+  default: '499b84ac-1321-427f-aa17-267ca6975798'
+- name: isStepOutputVariable
+  type: boolean
+  default: false
+
+steps:
+- task: AzureCLI@2
+  displayName: 'Getting federated access token for feeds'
+  name: ${{ parameters.stepName }}
+  ${{ if ne(parameters.condition, '') }}:
+    condition: ${{ parameters.condition }}
+  inputs:
+    azureSubscription: ${{ parameters.federatedServiceConnection }}
+    scriptType: 'pscore'
+    scriptLocation: 'inlineScript'
+    inlineScript: |
+      $accessToken = az account get-access-token --query accessToken --resource ${{ parameters.resource }} --output tsv
+      if ($LASTEXITCODE -ne 0) {
+        Write-Error "Failed to get access token for resource '${{ parameters.resource }}'"
+        exit 1
+      }
+      Write-Host "Setting '${{ parameters.outputVariableName }}' with the access token value"
+      Write-Host "##vso[task.setvariable variable=${{ parameters.outputVariableName }};issecret=true;isOutput=${{ parameters.isStepOutputVariable }}]$accessToken"
\ No newline at end of file
diff --git a/eng/common/templates/job/publish-build-assets.yml b/eng/common/templates/job/publish-build-assets.yml
index 8ec0151def2..cc2b346ba8b 100644
--- a/eng/common/templates/job/publish-build-assets.yml
+++ b/eng/common/templates/job/publish-build-assets.yml
@@ -74,13 +74,16 @@ jobs:
 
     - task: NuGetAuthenticate@1
 
-    - task: PowerShell@2
+    - task: AzureCLI@2
       displayName: Publish Build Assets
       inputs:
-        filePath: eng\common\sdk-task.ps1
-        arguments: -task PublishBuildAssets -restore -msbuildEngine dotnet
+        azureSubscription: "Darc: Maestro Production"
+        scriptType: ps
+        scriptLocation: scriptPath
+        scriptPath: $(Build.SourcesDirectory)/eng/common/sdk-task.ps1
+        arguments: >
+          -task PublishBuildAssets -restore -msbuildEngine dotnet
           /p:ManifestsPath='$(Build.StagingDirectory)/Download/AssetManifests'
-          /p:BuildAssetRegistryToken=$(MaestroAccessToken)
           /p:MaestroApiEndpoint=https://maestro.dot.net
           /p:PublishUsingPipelines=${{ parameters.publishUsingPipelines }}
           /p:OfficialBuildId=$(Build.BuildNumber)
@@ -133,14 +136,16 @@ jobs:
           BARBuildId: ${{ parameters.BARBuildId }}
           PromoteToChannelIds: ${{ parameters.PromoteToChannelIds }}
 
-      - task: PowerShell@2
+      - task: AzureCLI@2
         displayName: Publish Using Darc
         inputs:
-          filePath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
-          arguments: -BuildId $(BARBuildId)
+          azureSubscription: "Darc: Maestro Production"
+          scriptType: ps
+          scriptLocation: scriptPath
+          scriptPath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
+          arguments: -BuildId $(BARBuildId) 
             -PublishingInfraVersion 3
-            -AzdoToken '$(publishing-dnceng-devdiv-code-r-build-re)'
-            -MaestroToken '$(MaestroApiAccessToken)'
+            -AzdoToken '$(System.AccessToken)'
             -WaitPublishingFinish true
             -ArtifactsPublishingAdditionalParameters '${{ parameters.artifactsPublishingAdditionalParameters }}'
             -SymbolPublishingAdditionalParameters '${{ parameters.symbolPublishingAdditionalParameters }}'
diff --git a/eng/common/templates/job/source-build.yml b/eng/common/templates/job/source-build.yml
index 8a3deef2b72..c0ff472b697 100644
--- a/eng/common/templates/job/source-build.yml
+++ b/eng/common/templates/job/source-build.yml
@@ -31,6 +31,12 @@ parameters:
   #   container and pool.
   platform: {}
 
+  # If set to true and running on a non-public project,
+  # Internal blob storage locations will be enabled.
+  # This is not enabled by default because many repositories do not need internal sources
+  # and do not need to have the required service connections approved in the pipeline.
+  enableInternalSources: false
+
 jobs:
 - job: ${{ parameters.jobNamePrefix }}_${{ parameters.platform.name }}
   displayName: Source-Build (${{ parameters.platform.name }})
@@ -61,6 +67,8 @@ jobs:
     clean: all
 
   steps:
+  - ${{ if eq(parameters.enableInternalSources, true) }}:
+    - template: /eng/common/templates/steps/enable-internal-runtimes.yml
   - template: /eng/common/templates/steps/source-build.yml
     parameters:
       platform: ${{ parameters.platform }}
diff --git a/eng/common/templates/job/source-index-stage1.yml b/eng/common/templates/job/source-index-stage1.yml
index 43ee0c202fc..0b6bb89dc78 100644
--- a/eng/common/templates/job/source-index-stage1.yml
+++ b/eng/common/templates/job/source-index-stage1.yml
@@ -70,16 +70,13 @@ jobs:
         scriptType: 'ps'
         scriptLocation: 'inlineScript'
         inlineScript: |
-          echo "##vso[task.setvariable variable=ARM_CLIENT_ID]$env:servicePrincipalId"
-          echo "##vso[task.setvariable variable=ARM_ID_TOKEN]$env:idToken"
-          echo "##vso[task.setvariable variable=ARM_TENANT_ID]$env:tenantId"
+          echo "##vso[task.setvariable variable=ARM_CLIENT_ID;issecret=true]$env:servicePrincipalId"
+          echo "##vso[task.setvariable variable=ARM_ID_TOKEN;issecret=true]$env:idToken"
+          echo "##vso[task.setvariable variable=ARM_TENANT_ID;issecret=true]$env:tenantId"
 
     - script: |
-        echo "Client ID: $(ARM_CLIENT_ID)"
-        echo "ID Token: $(ARM_ID_TOKEN)"
-        echo "Tenant ID: $(ARM_TENANT_ID)"
         az login --service-principal -u $(ARM_CLIENT_ID) --tenant $(ARM_TENANT_ID) --allow-no-subscriptions --federated-token $(ARM_ID_TOKEN)
       displayName: "Login to Azure"
 
     - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name) -s netsourceindexstage1 -b stage1
-      displayName: Upload stage1 artifacts to source index
\ No newline at end of file
+      displayName: Upload stage1 artifacts to source index
diff --git a/eng/common/templates/jobs/source-build.yml b/eng/common/templates/jobs/source-build.yml
index a15b07eb51d..5f46bfa895c 100644
--- a/eng/common/templates/jobs/source-build.yml
+++ b/eng/common/templates/jobs/source-build.yml
@@ -21,6 +21,12 @@ parameters:
   # one job runs on 'defaultManagedPlatform'.
   platforms: []
 
+  # If set to true and running on a non-public project,
+  # Internal nuget and blob storage locations will be enabled.
+  # This is not enabled by default because many repositories do not need internal sources
+  # and do not need to have the required service connections approved in the pipeline.
+  enableInternalSources: false
+
 jobs:
 
 - ${{ if ne(parameters.allCompletedJobId, '') }}:
@@ -38,9 +44,11 @@ jobs:
     parameters:
       jobNamePrefix: ${{ parameters.jobNamePrefix }}
       platform: ${{ platform }}
+      enableInternalSources: ${{ parameters.enableInternalSources }}
 
 - ${{ if eq(length(parameters.platforms), 0) }}:
   - template: /eng/common/templates/job/source-build.yml
     parameters:
       jobNamePrefix: ${{ parameters.jobNamePrefix }}
       platform: ${{ parameters.defaultManagedPlatform }}
+      enableInternalSources: ${{ parameters.enableInternalSources }}
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index aba44a25a33..c3b6a3012fe 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -268,14 +268,16 @@ stages:
 
         - task: NuGetAuthenticate@1
 
-        - task: PowerShell@2
+        - task: AzureCLI@2
           displayName: Publish Using Darc
           inputs:
-            filePath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
+            azureSubscription: "Darc: Maestro Production"
+            scriptType: ps
+            scriptLocation: scriptPath
+            scriptPath: $(Build.SourcesDirectory)/eng/common/post-build/publish-using-darc.ps1
             arguments: -BuildId $(BARBuildId)
               -PublishingInfraVersion ${{ parameters.publishingInfraVersion }}
-              -AzdoToken '$(publishing-dnceng-devdiv-code-r-build-re)'
-              -MaestroToken '$(MaestroApiAccessToken)'
+              -AzdoToken '$(System.AccessToken)'
               -WaitPublishingFinish true
               -ArtifactsPublishingAdditionalParameters '${{ parameters.artifactsPublishingAdditionalParameters }}'
               -SymbolPublishingAdditionalParameters '${{ parameters.symbolPublishingAdditionalParameters }}'
diff --git a/eng/common/templates/post-build/setup-maestro-vars.yml b/eng/common/templates/post-build/setup-maestro-vars.yml
index 0c87f149a4a..64b9abc6850 100644
--- a/eng/common/templates/post-build/setup-maestro-vars.yml
+++ b/eng/common/templates/post-build/setup-maestro-vars.yml
@@ -11,13 +11,14 @@ steps:
         artifactName: ReleaseConfigs
         checkDownloadedFiles: true
 
-  - task: PowerShell@2
+  - task: AzureCLI@2
     name: setReleaseVars
     displayName: Set Release Configs Vars
     inputs:
-      targetType: inline
-      pwsh: true
-      script: |
+      azureSubscription: "Darc: Maestro Production"
+      scriptType: pscore
+      scriptLocation: inlineScript
+      inlineScript: |
         try {
           if (!$Env:PromoteToMaestroChannels -or $Env:PromoteToMaestroChannels.Trim() -eq '') {
             $Content = Get-Content $(Build.StagingDirectory)/ReleaseConfigs/ReleaseConfigs.txt
@@ -31,15 +32,16 @@ steps:
             $AzureDevOpsBuildId = $Env:Build_BuildId
           }
           else {
-            $buildApiEndpoint = "${Env:MaestroApiEndPoint}/api/builds/${Env:BARBuildId}?api-version=${Env:MaestroApiVersion}"
+            . $(Build.SourcesDirectory)\eng\common\tools.ps1
+            $darc = Get-Darc
+            $buildInfo = & $darc get-build `
+              --id ${{ parameters.BARBuildId }} `
+              --extended `
+              --output-format json `
+              --ci `
+              | convertFrom-Json
 
-            $apiHeaders = New-Object 'System.Collections.Generic.Dictionary[[String],[String]]'
-            $apiHeaders.Add('Accept', 'application/json')
-            $apiHeaders.Add('Authorization',"Bearer ${Env:MAESTRO_API_TOKEN}")
-
-            $buildInfo = try { Invoke-WebRequest -Method Get -Uri $buildApiEndpoint -Headers $apiHeaders | ConvertFrom-Json } catch { Write-Host "Error: $_" }
-            
-            $BarId = $Env:BARBuildId
+            $BarId = ${{ parameters.BARBuildId }}
             $Channels = $Env:PromoteToMaestroChannels -split ","
             $Channels = $Channels -join "]["
             $Channels = "[$Channels]"
@@ -65,6 +67,4 @@ steps:
           exit 1
         }
     env:
-      MAESTRO_API_TOKEN: $(MaestroApiAccessToken)
-      BARBuildId: ${{ parameters.BARBuildId }}
       PromoteToMaestroChannels: ${{ parameters.PromoteToChannelIds }}
diff --git a/eng/common/templates/steps/enable-internal-runtimes.yml b/eng/common/templates/steps/enable-internal-runtimes.yml
new file mode 100644
index 00000000000..54dc9416c51
--- /dev/null
+++ b/eng/common/templates/steps/enable-internal-runtimes.yml
@@ -0,0 +1,28 @@
+# Obtains internal runtime download credentials and populates the 'dotnetbuilds-internal-container-read-token-base64'
+# variable with the base64-encoded SAS token, by default
+
+parameters:
+- name: federatedServiceConnection
+  type: string
+  default: 'dotnetbuilds-internal-read'
+- name: outputVariableName
+  type: string
+  default: 'dotnetbuilds-internal-container-read-token-base64'
+- name: expiryInHours
+  type: number
+  default: 1
+- name: base64Encode
+  type: boolean
+  default: true
+
+steps:
+- ${{ if ne(variables['System.TeamProject'], 'public') }}:
+  - template: /eng/common/templates/steps/get-delegation-sas.yml
+    parameters:
+      federatedServiceConnection: ${{ parameters.federatedServiceConnection }}
+      outputVariableName: ${{ parameters.outputVariableName }}
+      expiryInHours: ${{ parameters.expiryInHours }}
+      base64Encode: ${{ parameters.base64Encode }}
+      storageAccount: dotnetbuilds
+      container: internal
+      permissions: rl
diff --git a/eng/common/templates/steps/execute-sdl.yml b/eng/common/templates/steps/execute-sdl.yml
index 07426fde05d..fe0ebf8c904 100644
--- a/eng/common/templates/steps/execute-sdl.yml
+++ b/eng/common/templates/steps/execute-sdl.yml
@@ -9,8 +9,6 @@ parameters:
 
 steps:
 - task: NuGetAuthenticate@1
-  inputs:
-    nuGetServiceConnections: GuardianConnect
 
 - task: NuGetToolInstaller@1
   displayName: 'Install NuGet.exe'
@@ -36,16 +34,19 @@ steps:
     displayName: Execute SDL (Overridden)
     continueOnError: ${{ parameters.sdlContinueOnError }}
     condition: ${{ parameters.condition }}
+    env:
+      GUARDIAN_DEFAULT_PACKAGE_SOURCE_SECRET: $(System.AccessToken)
 
 - ${{ if eq(parameters.overrideParameters, '') }}:
   - powershell: ${{ parameters.executeAllSdlToolsScript }}
       -GuardianCliLocation $(GuardianCliLocation)
       -NugetPackageDirectory $(Build.SourcesDirectory)\.packages
-      -AzureDevOpsAccessToken $(dn-bot-dotnet-build-rw-code-rw)
       ${{ parameters.additionalParameters }}
     displayName: Execute SDL
     continueOnError: ${{ parameters.sdlContinueOnError }}
     condition: ${{ parameters.condition }}
+    env:
+      GUARDIAN_DEFAULT_PACKAGE_SOURCE_SECRET: $(System.AccessToken)
 
 - ${{ if ne(parameters.publishGuardianDirectoryToPipeline, 'false') }}:
   # We want to publish the Guardian results and configuration for easy diagnosis. However, the
diff --git a/eng/common/templates/steps/get-delegation-sas.yml b/eng/common/templates/steps/get-delegation-sas.yml
new file mode 100644
index 00000000000..c0e8f91317f
--- /dev/null
+++ b/eng/common/templates/steps/get-delegation-sas.yml
@@ -0,0 +1,43 @@
+parameters:
+- name: federatedServiceConnection
+  type: string
+- name: outputVariableName
+  type: string
+- name: expiryInHours
+  type: number
+  default: 1
+- name: base64Encode
+  type: boolean
+  default: false
+- name: storageAccount
+  type: string
+- name: container
+  type: string
+- name: permissions
+  type: string
+  default: 'rl'
+
+steps:
+- task: AzureCLI@2
+  displayName: 'Generate delegation SAS Token for ${{ parameters.storageAccount }}/${{ parameters.container }}'
+  inputs:
+    azureSubscription: ${{ parameters.federatedServiceConnection }}
+    scriptType: 'pscore'
+    scriptLocation: 'inlineScript'
+    inlineScript: |
+      # Calculate the expiration of the SAS token and convert to UTC
+      $expiry = (Get-Date).AddHours(${{ parameters.expiryInHours }}).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
+
+      $sas = az storage container generate-sas --account-name ${{ parameters.storageAccount }} --name ${{ parameters.container }} --permissions ${{ parameters.permissions }} --expiry $expiry --auth-mode login --as-user -o tsv
+
+      if ($LASTEXITCODE -ne 0) {
+        Write-Error "Failed to generate SAS token."
+        exit 1
+      }
+
+      if ('${{ parameters.base64Encode }}' -eq 'true') {
+        $sas = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($sas))
+      }
+
+      Write-Host "Setting '${{ parameters.outputVariableName }}' with the access token value"
+      Write-Host "##vso[task.setvariable variable=${{ parameters.outputVariableName }};issecret=true]$sas"
diff --git a/eng/common/templates/steps/get-federated-access-token.yml b/eng/common/templates/steps/get-federated-access-token.yml
new file mode 100644
index 00000000000..55e33bd38f7
--- /dev/null
+++ b/eng/common/templates/steps/get-federated-access-token.yml
@@ -0,0 +1,40 @@
+parameters:
+- name: federatedServiceConnection
+  type: string
+- name: outputVariableName
+  type: string
+- name: stepName
+  type: string
+  default: 'getFederatedAccessToken'
+- name: condition
+  type: string
+  default: ''
+# Resource to get a token for. Common values include:
+# - '499b84ac-1321-427f-aa17-267ca6975798' for Azure DevOps
+# - 'https://storage.azure.com/' for storage
+# Defaults to Azure DevOps
+- name: resource
+  type: string
+  default: '499b84ac-1321-427f-aa17-267ca6975798'
+- name: isStepOutputVariable
+  type: boolean
+  default: false
+
+steps:
+- task: AzureCLI@2
+  displayName: 'Getting federated access token for feeds'
+  name: ${{ parameters.stepName }}
+  ${{ if ne(parameters.condition, '') }}:
+    condition: ${{ parameters.condition }}
+  inputs:
+    azureSubscription: ${{ parameters.federatedServiceConnection }}
+    scriptType: 'pscore'
+    scriptLocation: 'inlineScript'
+    inlineScript: |
+      $accessToken = az account get-access-token --query accessToken --resource ${{ parameters.resource }} --output tsv
+      if ($LASTEXITCODE -ne 0) {
+        Write-Error "Failed to get access token for resource '${{ parameters.resource }}'"
+        exit 1
+      }
+      Write-Host "Setting '${{ parameters.outputVariableName }}' with the access token value"
+      Write-Host "##vso[task.setvariable variable=${{ parameters.outputVariableName }};issecret=true;isOutput=${{ parameters.isStepOutputVariable }}]$accessToken"
\ No newline at end of file
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 665f96765b1..fe9f94a2a72 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -19,7 +19,7 @@
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
-    <PackageVersion Include="Microsoft.BuildXL.Processes" Version="0.1.0-20240307.8" />
+    <PackageVersion Include="Microsoft.BuildXL.Processes" Version="0.1.0-20240606.3" />
     <PackageVersion Update="Microsoft.BuildXL.Processes" Condition="'$(BuildXLProcessesVersion)' != ''" Version="$(BuildXLProcessesVersion)" />
 
     <PackageVersion Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.8.2112" />
diff --git a/global.json b/global.json
index a2815a8c542..c200b890ff4 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.8.5"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24270.4"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24376.1"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 6522e66bbef..271bbd11e8e 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -1850,35 +1850,6 @@ public void ReloadCanOverwriteUnsavedChanges()
             AssertReload(SimpleProject, ComplexProject, true, true, true, act);
         }
 
-        [Fact]
-        public void ReloadDoesNotLeakCachedXmlDocuments()
-        {
-            using var env = TestEnvironment.Create();
-            ChangeWaves.ResetStateForTests();
-            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-            var testFiles = env.CreateTestProjectWithFiles("", new[] { "build.proj" });
-            var projectFile = testFiles.CreatedFiles.First();
-
-            var projectElement = ObjectModelHelpers.CreateInMemoryProjectRootElement(SimpleProject);
-            projectElement.Save(projectFile);
-
-            int originalDocumentCount = GetNumberOfDocumentsInProjectStringCache(projectElement);
-
-            // Test successful reload.
-            projectElement.Reload(false);
-            GetNumberOfDocumentsInProjectStringCache(projectElement).ShouldBe(originalDocumentCount);
-
-            // Test failed reload.
-            using (StreamWriter sw = new StreamWriter(projectFile))
-            {
-                sw.WriteLine("<XXX />"); // Invalid root element
-            }
-            Should.Throw<InvalidProjectFileException>(() => projectElement.Reload(false));
-            GetNumberOfDocumentsInProjectStringCache(projectElement).ShouldBe(originalDocumentCount);
-        }
-
         private void AssertReload(
             string initialContents,
             string changedContents,
@@ -2015,17 +1986,5 @@ private void VerifyAssertLineByLine(string expected, string actual)
         {
             Helpers.VerifyAssertLineByLine(expected, actual, false);
         }
-
-        /// <summary>
-        /// Returns the number of documents retained by the project string cache.
-        /// Peeks at it via reflection since internals are not visible to these tests.
-        /// </summary>
-        private int GetNumberOfDocumentsInProjectStringCache(ProjectRootElement project)
-        {
-            var bindingFlags = BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.GetProperty;
-            object document = typeof(ProjectRootElement).InvokeMember("XmlDocument", bindingFlags, null, project, Array.Empty<object>());
-            object cache = document.GetType().InvokeMember("StringCache", bindingFlags, null, document, Array.Empty<object>());
-            return (int)cache.GetType().InvokeMember("DocumentCount", bindingFlags, null, cache, Array.Empty<object>());
-        }
     }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
index cdbf64f9774..2cb88649b35 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
@@ -340,19 +340,12 @@ public void SetReturns()
         /// <summary>
         /// Parse invalid property under target
         /// </summary>
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void ReadInvalidPropertyUnderTarget(bool enableNewBehavior)
+        [Fact]
+        public void ReadInvalidPropertyUnderTarget()
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
                 ChangeWaves.ResetStateForTests();
-                if (!enableNewBehavior)
-                {
-                    env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-                }
 
                 string projectFile = @"
                     <Project>
@@ -369,14 +362,7 @@ public void ReadInvalidPropertyUnderTarget(bool enableNewBehavior)
 
                 error.ErrorCode.ShouldMatch("MSB4067");
                 var expectedString = "<PropertyGroup>";
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
-                {
-                    error.Message.ShouldMatch(expectedString);
-                }
-                else
-                {
-                    error.Message.ShouldNotMatch(expectedString);
-                }
+                error.Message.ShouldMatch(expectedString);
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index faf9f3f8ccf..1d81e8ac1aa 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -4280,13 +4280,16 @@ public void GraphBuildShouldBeAbleToConstructGraphButSkipBuild()
 
             using (var buildSession = new Helpers.BuildManagerSession(_env))
             {
-                var graphResult = buildSession.BuildGraphSubmission(
-                    new GraphBuildRequestData(
-                        projectGraphEntryPoints: new[] { new ProjectGraphEntryPoint(graph.GraphRoots.First().ProjectInstance.FullPath) },
+                var requestData = new GraphBuildRequestData(
+                        projectGraphEntryPoints: new[] { new ProjectGraphEntryPoint(
+                            graph.GraphRoots.First().ProjectInstance.FullPath,
+                            new Dictionary<string, string>() { {"property1", "value1" } }) },
                         targetsToBuild: Array.Empty<string>(),
                         hostServices: null,
                         flags: BuildRequestDataFlags.None,
-                        graphBuildOptions: new GraphBuildOptions { Build = false }));
+                        graphBuildOptions: new GraphBuildOptions { Build = false });
+
+                var graphResult = buildSession.BuildGraphSubmission(requestData);
 
                 graphResult.OverallResult.ShouldBe(BuildResultCode.Success);
                 logger = buildSession.Logger;
diff --git a/src/Build.UnitTests/BackEnd/BuildOMCompatibility_Tests.cs b/src/Build.UnitTests/BackEnd/BuildOMCompatibility_Tests.cs
new file mode 100644
index 00000000000..53a87ab27a7
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/BuildOMCompatibility_Tests.cs
@@ -0,0 +1,117 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Reflection;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Graph;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Engine.UnitTests.BackEnd
+{
+    public class BuildOMCompatibility_Tests
+    {
+        [Theory]
+        [InlineData("ProjectInstance")]
+        [InlineData("ProjectFullPath")]
+        [InlineData("TargetNames")]
+        [InlineData("Flags")]
+        [InlineData("GlobalProperties")]
+        [InlineData("ExplicitlySpecifiedToolsVersion")]
+        [InlineData("HostServices")]
+        [InlineData("PropertiesToTransfer")]
+        [InlineData("RequestedProjectState")]
+        public void BuildRequestDataPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(BuildRequestData), propertyName);
+
+        [Theory]
+        [InlineData("ProjectGraph")]
+        [InlineData("ProjectGraphEntryPoints")]
+        [InlineData("TargetNames")]
+        [InlineData("Flags")]
+        [InlineData("GraphBuildOptions")]
+        [InlineData("HostServices")]
+        public void GraphBuildRequestDataPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(GraphBuildRequestData), propertyName);
+
+        [Theory]
+        [InlineData("BuildManager")]
+        [InlineData("SubmissionId")]
+        [InlineData("AsyncContext")]
+        [InlineData("WaitHandle")]
+        [InlineData("IsCompleted")]
+        [InlineData("BuildResult")]
+        public void BuildSubmissionDataPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(BuildSubmission), propertyName);
+
+        [Theory]
+        [InlineData("Execute")]
+        [InlineData("ExecuteAsync")]
+        public void BuildSubmissionDataMethodCompatTest(string methodName)
+            => VerifyMethodExists(typeof(BuildSubmission), methodName);
+
+        [Theory]
+        [InlineData("BuildManager")]
+        [InlineData("SubmissionId")]
+        [InlineData("AsyncContext")]
+        [InlineData("WaitHandle")]
+        [InlineData("IsCompleted")]
+        [InlineData("BuildResult")]
+        public void GraphBuildSubmissionDataPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(BuildSubmission), propertyName);
+
+        [Theory]
+        [InlineData("Execute")]
+        [InlineData("ExecuteAsync")]
+        public void GraphBuildSubmissionDataMethodCompatTest(string methodName)
+            => VerifyMethodExists(typeof(BuildSubmission), methodName);
+
+        [Theory]
+        [InlineData("SubmissionId")]
+        [InlineData("ConfigurationId")]
+        [InlineData("GlobalRequestId")]
+        [InlineData("ParentGlobalRequestId")]
+        [InlineData("NodeRequestId")]
+        [InlineData("Exception")]
+        [InlineData("CircularDependency")]
+        [InlineData("OverallResult")]
+        [InlineData("ResultsByTarget")]
+        [InlineData("ProjectStateAfterBuild")]
+        [InlineData("BuildRequestDataFlags")]
+        public void BuildResultPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(BuildResult), propertyName);
+
+        [Theory]
+        [InlineData("AddResultsForTarget")]
+        [InlineData("MergeResults")]
+        [InlineData("HasResultsForTarget")]
+        public void BuildResultMethodCompatTest(string methodName)
+            => VerifyMethodExists(typeof(BuildResult), methodName);
+
+        [Theory]
+        [InlineData("SubmissionId")]
+        [InlineData("Exception")]
+        [InlineData("CircularDependency")]
+        [InlineData("OverallResult")]
+        [InlineData("ResultsByNode")]
+        public void GraphBuildResultPropertyCompatTest(string propertyName)
+            => VerifyPropertyExists(typeof(GraphBuildResult), propertyName);
+
+        private void VerifyPropertyExists(Type type, string propertyName)
+        {
+            type.GetProperty(
+                    propertyName,
+                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly)
+                .ShouldNotBeNull();
+        }
+
+        private void VerifyMethodExists(Type type, string propertyName)
+        {
+            type.GetMethod(
+                    propertyName,
+                    BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly)
+                .ShouldNotBeNull();
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEntry_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEntry_Tests.cs
index e2bb6680df1..b994f4ceb2c 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEntry_Tests.cs
@@ -11,8 +11,6 @@
 using Microsoft.Build.Unittest;
 using Xunit;
 
-#nullable disable
-
 namespace Microsoft.Build.UnitTests.BackEnd
 {
     public class BuildRequestEntry_Tests
@@ -23,7 +21,7 @@ public class BuildRequestEntry_Tests
         public void TestConstructorGood()
         {
             BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
-            BuildRequestData data = new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null);
+            BuildRequestData data = new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null);
             BuildRequestConfiguration config = new BuildRequestConfiguration(1, data, "2.0");
             BuildRequestEntry entry = new BuildRequestEntry(request, config);
 
@@ -36,7 +34,7 @@ public void TestConstructorBad()
         {
             Assert.Throws<ArgumentNullException>(() =>
             {
-                BuildRequestEntry entry = new BuildRequestEntry(null, null);
+                BuildRequestEntry entry = new BuildRequestEntry(null!, null!);
             });
         }
         [Fact]
@@ -44,7 +42,7 @@ public void TestSimpleStateProgression()
         {
             // Start in Ready
             BuildRequest request = CreateNewBuildRequest(1, new string[1] { "foo" });
-            BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
+            BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null), "2.0");
             BuildRequestEntry entry = new BuildRequestEntry(request, config);
             Assert.Equal(BuildRequestEntryState.Ready, entry.State);
             Assert.Equal(entry.Request, request);
@@ -92,7 +90,7 @@ public void TestSimpleStateProgression()
         public void TestResolveConfiguration()
         {
             BuildRequest request = CreateNewBuildRequest(1, new string[1] { "foo" });
-            BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null);
+            BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null);
             BuildRequestConfiguration config = new BuildRequestConfiguration(1, data1, "2.0");
             BuildRequestEntry entry = new BuildRequestEntry(request, config);
 
@@ -114,7 +112,7 @@ public void TestResolveConfiguration()
         public void TestMultipleWaitingRequests()
         {
             BuildRequest request = CreateNewBuildRequest(1, new string[1] { "foo" });
-            BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null);
+            BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null);
             BuildRequestConfiguration config = new BuildRequestConfiguration(1, data1, "2.0");
             BuildRequestEntry entry = new BuildRequestEntry(request, config);
 
@@ -144,7 +142,7 @@ public void TestMultipleWaitingRequests()
         public void TestMixedWaitingRequests()
         {
             BuildRequest request = CreateNewBuildRequest(1, new string[1] { "foo" });
-            BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
+            BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null), "2.0");
             BuildRequestEntry entry = new BuildRequestEntry(request, config);
             Assert.Equal(BuildRequestEntryState.Ready, entry.State);
 
@@ -181,7 +179,7 @@ public void TestNoReadyToWaiting()
             Assert.Throws<InternalErrorException>(() =>
             {
                 BuildRequest request = CreateNewBuildRequest(1, new string[1] { "foo" });
-                BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null);
+                BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null);
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, data1, "2.0");
                 BuildRequestEntry entry = new BuildRequestEntry(request, config);
                 Assert.Equal(BuildRequestEntryState.Ready, entry.State);
@@ -197,7 +195,7 @@ public void TestNoReadyToComplete()
             Assert.Throws<InternalErrorException>(() =>
             {
                 BuildRequest request = CreateNewBuildRequest(1, new string[1] { "foo" });
-                BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null);
+                BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null);
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, data1, "2.0");
                 BuildRequestEntry entry = new BuildRequestEntry(request, config);
                 Assert.Equal(BuildRequestEntryState.Ready, entry.State);
@@ -214,7 +212,7 @@ public void TestNoWaitingToComplete()
             Assert.Throws<InternalErrorException>(() =>
             {
                 BuildRequest request = CreateNewBuildRequest(1, new string[1] { "foo" });
-                BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null);
+                BuildRequestData data1 = new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null);
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, data1, "2.0");
                 BuildRequestEntry entry = new BuildRequestEntry(request, config);
                 Assert.Equal(BuildRequestEntryState.Ready, entry.State);
@@ -238,7 +236,7 @@ public void TestNoCompleteToWaiting()
             Assert.Throws<InternalErrorException>(() =>
             {
                 BuildRequest request = CreateNewBuildRequest(1, new string[1] { "foo" });
-                BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
+                BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null), "2.0");
                 BuildRequestEntry entry = new BuildRequestEntry(request, config);
                 Assert.Equal(BuildRequestEntryState.Ready, entry.State);
 
@@ -258,7 +256,7 @@ public void TestNoCompleteToWaiting()
         public void TestResultsWithNoMatch1()
         {
             BuildRequest request = CreateNewBuildRequest(1, new string[1] { "foo" });
-            BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
+            BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string?>(), "foo", Array.Empty<string>(), null), "2.0");
             BuildRequestEntry entry = new BuildRequestEntry(request, config);
             Assert.Equal(BuildRequestEntryState.Ready, entry.State);
 
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 02c1179e863..dec50951300 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -14,8 +14,6 @@
 using Xunit;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
-#nullable disable
-
 namespace Microsoft.Build.UnitTests.BackEnd
 {
     public class BuildResult_Tests
@@ -39,14 +37,14 @@ public void Clone()
         {
             BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
             BuildResult result1 = new BuildResult(request);
-            result1.ResultsByTarget.Add("FOO", BuildResultUtilities.GetEmptySucceedingTargetResult());
-            Assert.True(result1.ResultsByTarget.ContainsKey("foo")); // test comparer
+            result1.ResultsByTarget?.Add("FOO", BuildResultUtilities.GetEmptySucceedingTargetResult());
+            Assert.True(result1.ResultsByTarget?.ContainsKey("foo")); // test comparer
 
             BuildResult result2 = result1.Clone();
 
-            result1.ResultsByTarget.Add("BAR", BuildResultUtilities.GetEmptySucceedingTargetResult());
-            Assert.True(result1.ResultsByTarget.ContainsKey("foo")); // test comparer
-            Assert.True(result1.ResultsByTarget.ContainsKey("bar"));
+            result1.ResultsByTarget?.Add("BAR", BuildResultUtilities.GetEmptySucceedingTargetResult());
+            Assert.True(result1.ResultsByTarget?.ContainsKey("foo")); // test comparer
+            Assert.True(result1.ResultsByTarget?.ContainsKey("bar"));
 
             Assert.Equal(result1.SubmissionId, result2.SubmissionId);
             Assert.Equal(result1.ConfigurationId, result2.ConfigurationId);
@@ -54,16 +52,16 @@ public void Clone()
             Assert.Equal(result1.ParentGlobalRequestId, result2.ParentGlobalRequestId);
             Assert.Equal(result1.NodeRequestId, result2.NodeRequestId);
             Assert.Equal(result1.CircularDependency, result2.CircularDependency);
-            Assert.Equal(result1.ResultsByTarget["foo"], result2.ResultsByTarget["foo"]);
+            Assert.Equal(result1.ResultsByTarget?["foo"], result2.ResultsByTarget?["foo"]);
             Assert.Equal(result1.OverallResult, result2.OverallResult);
         }
 
         [Fact]
         public void TestConstructorBad()
         {
-            Assert.Throws<InternalErrorException>(() =>
+            Assert.Throws<NullReferenceException>(() =>
             {
-                BuildResult result = new BuildResult(null);
+                BuildResult result = new BuildResult(null!);
             });
         }
         [Fact]
@@ -163,7 +161,7 @@ public void TestAddResultsInvalid1()
             {
                 BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
                 BuildResult result = new BuildResult(request);
-                result.AddResultsForTarget(null, BuildResultUtilities.GetEmptySucceedingTargetResult());
+                result.AddResultsForTarget(null!, BuildResultUtilities.GetEmptySucceedingTargetResult());
             });
         }
 
@@ -174,7 +172,7 @@ public void TestAddResultsInvalid2()
             {
                 BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
                 BuildResult result = new BuildResult(request);
-                result.AddResultsForTarget("foo", null);
+                result.AddResultsForTarget("foo", null!);
             });
         }
 
@@ -185,7 +183,7 @@ public void TestAddResultsInvalid3()
             {
                 BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
                 BuildResult result = new BuildResult(request);
-                result.AddResultsForTarget(null, BuildResultUtilities.GetEmptySucceedingTargetResult());
+                result.AddResultsForTarget(null!, BuildResultUtilities.GetEmptySucceedingTargetResult());
             });
         }
         [Fact]
@@ -222,7 +220,7 @@ public void TestMergeResultsBad1()
                 BuildResult result = new BuildResult(request);
                 result.AddResultsForTarget("foo", BuildResultUtilities.GetEmptySucceedingTargetResult());
 
-                result.MergeResults(null);
+                result.MergeResults(null!);
             });
         }
 
@@ -258,24 +256,25 @@ public void TestEnumerator()
         {
             BuildRequest request = CreateNewBuildRequest(1, Array.Empty<string>());
             BuildResult result = new BuildResult(request);
-            int countFound = 0;
-            foreach (KeyValuePair<string, TargetResult> resultPair in result.ResultsByTarget)
-            {
-                countFound++;
-            }
+            int countFound = result.ResultsByTarget?.Count ?? 0;
             Assert.Equal(0, countFound);
 
             result.AddResultsForTarget("foo", BuildResultUtilities.GetEmptySucceedingTargetResult());
             bool foundFoo = false;
             countFound = 0;
-            foreach (KeyValuePair<string, TargetResult> resultPair in result.ResultsByTarget)
+            if (result.ResultsByTarget != null)
             {
-                if (resultPair.Key == "foo")
+                foreach (KeyValuePair<string, TargetResult> resultPair in result.ResultsByTarget)
                 {
-                    foundFoo = true;
+                    if (resultPair.Key == "foo")
+                    {
+                        foundFoo = true;
+                    }
+
+                    countFound++;
                 }
-                countFound++;
             }
+
             Assert.Equal(1, countFound);
             Assert.True(foundFoo);
 
@@ -283,20 +282,26 @@ public void TestEnumerator()
             foundFoo = false;
             bool foundBar = false;
             countFound = 0;
-            foreach (KeyValuePair<string, TargetResult> resultPair in result.ResultsByTarget)
+            if (result.ResultsByTarget != null)
             {
-                if (resultPair.Key == "foo")
-                {
-                    Assert.False(foundFoo);
-                    foundFoo = true;
-                }
-                if (resultPair.Key == "bar")
+                foreach (KeyValuePair<string, TargetResult> resultPair in result.ResultsByTarget)
                 {
-                    Assert.False(foundBar);
-                    foundBar = true;
+                    if (resultPair.Key == "foo")
+                    {
+                        Assert.False(foundFoo);
+                        foundFoo = true;
+                    }
+
+                    if (resultPair.Key == "bar")
+                    {
+                        Assert.False(foundBar);
+                        foundBar = true;
+                    }
+
+                    countFound++;
                 }
-                countFound++;
             }
+
             Assert.Equal(2, countFound);
             Assert.True(foundFoo);
             Assert.True(foundBar);
@@ -322,12 +327,12 @@ public void TestTranslation()
             ((ITranslatable)result).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = BuildResult.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            BuildResult deserializedResult = packet as BuildResult;
+            BuildResult deserializedResult = (packet as BuildResult)!;
 
             Assert.Equal(result.ConfigurationId, deserializedResult.ConfigurationId);
             Assert.True(TranslationHelpers.CompareCollections(result.DefaultTargets, deserializedResult.DefaultTargets, StringComparer.Ordinal));
             Assert.True(TranslationHelpers.CompareExceptions(result.Exception, deserializedResult.Exception, out string diffReason), diffReason);
-            Assert.Equal(result.Exception.Message, deserializedResult.Exception.Message);
+            Assert.Equal(result.Exception?.Message, deserializedResult.Exception?.Message);
             Assert.Equal(result.GlobalRequestId, deserializedResult.GlobalRequestId);
             Assert.True(TranslationHelpers.CompareCollections(result.InitialTargets, deserializedResult.InitialTargets, StringComparer.Ordinal));
             Assert.Equal(result.NodeRequestId, deserializedResult.NodeRequestId);
diff --git a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
index 5aca8898ee3..0f6e34c6449 100644
--- a/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventSourceSink_Tests.cs
@@ -42,6 +42,7 @@ public void ConsumeEventsGoodEvents()
             EventHandlerHelper testHandlers = new EventHandlerHelper(sink, null);
             VerifyRegisteredHandlers(RaiseEventHelper.BuildStarted, eventHelper, testHandlers);
             VerifyRegisteredHandlers(RaiseEventHelper.BuildFinished, eventHelper, testHandlers);
+            VerifyRegisteredHandlers(RaiseEventHelper.BuildCanceled, eventHelper, testHandlers);
             VerifyRegisteredHandlers(RaiseEventHelper.NormalMessage, eventHelper, testHandlers);
             VerifyRegisteredHandlers(RaiseEventHelper.TaskFinished, eventHelper, testHandlers);
             VerifyRegisteredHandlers(RaiseEventHelper.CommandLine, eventHelper, testHandlers);
@@ -66,6 +67,7 @@ public void ConsumeEventsGoodEventsNoHandlers()
             RaiseEventHelper eventHelper = new RaiseEventHelper(sink);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.BuildStarted);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.BuildFinished);
+            eventHelper.RaiseBuildEvent(RaiseEventHelper.BuildCanceled);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.NormalMessage);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.TaskFinished);
             eventHelper.RaiseBuildEvent(RaiseEventHelper.CommandLine);
@@ -98,6 +100,7 @@ public void LoggerExceptionInEventHandler()
             {
                 RaiseExceptionInEventHandler(RaiseEventHelper.BuildStarted, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.BuildFinished, exception);
+                RaiseExceptionInEventHandler(RaiseEventHelper.BuildCanceled, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.NormalMessage, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.TaskFinished, exception);
                 RaiseExceptionInEventHandler(RaiseEventHelper.CommandLine, exception);
@@ -127,7 +130,7 @@ public void RaiseGenericBuildEventArgs()
             });
         }
         /// <summary>
-        /// Verify that shutdown un registers all of the event handlers
+        /// Verify that shutdown unregisters all of the event handlers
         /// </summary>
         [Fact]
         public void VerifyShutdown()
@@ -294,7 +297,10 @@ private static void VerifyRegisteredHandlers(BuildEventArgs buildEventToRaise, R
             try
             {
                 eventHelper.RaiseBuildEvent(buildEventToRaise);
-                if (buildEventToRaise.GetType() != typeof(GenericBuildStatusEventArgs))
+                Type eventType = buildEventToRaise.GetType();
+
+                if (eventType != typeof(GenericBuildStatusEventArgs) &&
+                    eventType != typeof(BuildCanceledEventArgs))
                 {
                     Assert.Equal(testHandlers.RaisedEvent, buildEventToRaise); // "Expected buildevent in handler to match buildevent raised on event source"
                     Assert.Equal(testHandlers.RaisedEvent, testHandlers.RaisedAnyEvent); // "Expected RaisedEvent and RaisedAnyEvent to match"
@@ -715,6 +721,11 @@ internal sealed class RaiseEventHelper
             /// </summary>
             private static BuildFinishedEventArgs s_buildFinished = new BuildFinishedEventArgs("Message", "Keyword", true);
 
+            /// <summary>
+            /// Build Canceled Event
+            /// </summary>
+            private static BuildCanceledEventArgs s_buildCanceled = new BuildCanceledEventArgs("Message");
+
             /// <summary>
             /// Build Message Event
             /// </summary>
@@ -846,6 +857,17 @@ internal static BuildFinishedEventArgs BuildFinished
                 }
             }
 
+            /// <summary>
+            /// Event which can be raised in multiple tests.
+            /// </summary>
+            internal static BuildCanceledEventArgs BuildCanceled
+            {
+                get
+                {
+                    return s_buildCanceled;
+                }
+            }
+
             /// <summary>
             /// Event which can be raised in multiple tests.
             /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index 1bae3f8adde..5dfb489f483 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -417,7 +417,7 @@ public void RegisterGoodDistributedAndCentralLoggerTestBuildStartedFinished()
             Assert.Equal(2, regularILoggerB.BuildStartedCount);
             Assert.Equal(2, regularILoggerC.BuildStartedCount);
 
-            // Make sure if we call build started again we only get one other build started event.
+            // Make sure if we call build finished again we only get one other build finished event.
             _initializedService.LogBuildFinished(true);
             Assert.Equal(2, regularILoggerA.BuildFinishedCount);
             Assert.Equal(2, regularILoggerB.BuildFinishedCount);
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 7ac9e7f5dbc..fb932fb70d5 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -1001,17 +1001,21 @@ public void ProjectFinished()
         /// Make sure we can log a build started event correctly.
         /// Test both the LogOnlyCriticalEvents true and false
         /// </summary>
-        [Fact]
-        public void LogBuildStarted()
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void LogBuildStarted(bool onlyLogCriticalEvents)
         {
             ProcessBuildEventHelper service =
                 (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
-
+            service.OnlyLogCriticalEvents = onlyLogCriticalEvents;
             service.LogBuildStarted();
 
+            string message = onlyLogCriticalEvents ? string.Empty : ResourceUtilities.GetResourceString("BuildStarted");
+
             BuildStartedEventArgs buildEvent =
                 new BuildStartedEventArgs(
-                    ResourceUtilities.GetResourceString("BuildStarted"),
+                    message,
                     null /* no help keyword */,
                     service.ProcessedBuildEvent.Timestamp);
 
@@ -1020,26 +1024,6 @@ public void LogBuildStarted()
                 new EventArgsEqualityComparer<BuildStartedEventArgs>());
         }
 
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/437")]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void LogBuildStartedCriticalOnly()
-        {
-            ProcessBuildEventHelper service =
-                (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
-            service.OnlyLogCriticalEvents = true;
-            service.LogBuildStarted();
-
-            BuildStartedEventArgs buildEvent =
-                new BuildStartedEventArgs(
-                    string.Empty,
-                    null /* no help keyword */);
-
-            Assert.IsType<BuildStartedEventArgs>(service.ProcessedBuildEvent);
-            Assert.Equal(buildEvent, (BuildStartedEventArgs)service.ProcessedBuildEvent,
-                new EventArgsEqualityComparer<BuildStartedEventArgs>());
-        }
-
         /// <summary>
         /// Make sure we can log a build finished event correctly.
         /// Verify the success cases as well as OnlyLogCriticalEvents
@@ -1064,6 +1048,24 @@ public void LogBuildFinished()
             Assert.True(((BuildFinishedEventArgs)service.ProcessedBuildEvent).IsEquivalent(buildEvent));
         }
 
+        [Fact]
+        public void LogBuildCanceled()
+        {
+            ProcessBuildEventHelper service =
+                (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
+            service.LogBuildCanceled();
+
+
+            BuildCanceledEventArgs buildEvent =
+                new BuildCanceledEventArgs(
+                    ResourceUtilities.GetResourceString("AbortingBuild"),
+                    service.ProcessedBuildEvent.Timestamp);
+
+            Assert.IsType<BuildCanceledEventArgs>(service.ProcessedBuildEvent);
+            Assert.Equal(buildEvent, (BuildCanceledEventArgs)service.ProcessedBuildEvent,
+                new EventArgsEqualityComparer<BuildCanceledEventArgs>());
+        }
+
         /// <summary>
         ///  Exercise Asynchronous code path, this method should return right away as there are no events to process.
         ///  This will be further tested in the LoggingService_Tests class.
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index 1ff79810e54..b4c1306c1b4 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -205,6 +205,9 @@ public IBuildComponent GetComponent(BuildComponentType type)
             };
         }
 
+        public TComponent GetComponent<TComponent>(BuildComponentType type) where TComponent : IBuildComponent
+            => (TComponent) GetComponent(type);
+
         /// <summary>
         /// Register a new build component factory with the host.
         /// </summary>
@@ -224,25 +227,5 @@ public INodePacket DeserializePacket(NodePacketType type, byte[] serializedPacke
         }
 
         #endregion
-
-        #region IBuildComponent Members
-
-        /// <summary>
-        /// Initialize this component using the provided host
-        /// </summary>
-        public void InitializeComponent(IBuildComponentHost host)
-        {
-            throw new NotImplementedException();
-        }
-
-        /// <summary>
-        /// Clean up any state
-        /// </summary>
-        public void ShutdownComponent()
-        {
-            throw new NotImplementedException();
-        }
-
-        #endregion
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index a62b03686d4..e829d9f4384 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -4,7 +4,10 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Logging;
@@ -30,6 +33,11 @@ public MockLoggingService(Action<string> writter = null)
 
         #region ILoggingService Members
 
+        /// <summary>
+        /// Router of the build engine runtime execution information.
+        /// </summary>
+        public IBuildEngineDataRouter BuildEngineDataRouter => this;
+
         /// <summary>
         /// The event to raise when there is a logging exception
         /// </summary>
@@ -486,6 +494,10 @@ public void LogBuildFinished(bool success)
         {
         }
 
+        /// <inheritdoc />
+        public void LogBuildCanceled()
+        {
+        }
 
         /// <inheritdoc />
         public BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId)
@@ -639,6 +651,18 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
             throw new NotImplementedException();
         }
 
+        public void InitializeComponent(IBuildComponentHost host) => throw new NotImplementedException();
+        public void ShutdownComponent() => throw new NotImplementedException();
+
         #endregion
+
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
+        { /* Ignore the data */ }
+
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
+        { /* Ignore the data */ }
+
+        public void ProcessProjectEvaluationStarted(ICheckContext analysisContext, string projectFullPath)
+        { /* Ignore the data */ }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 3d29df4b00a..32f6b0e3093 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -81,6 +81,8 @@ public IBuildComponent GetComponent(BuildComponentType type)
                 throw new NotImplementedException();
             }
 
+            public TComponent GetComponent<TComponent>(BuildComponentType type) where TComponent : IBuildComponent => throw new NotImplementedException("Not expected to be used.");
+
             public void RegisterFactory(BuildComponentType type, BuildComponentFactoryDelegate factory)
             {
             }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 67eba7e0b12..c63606144c8 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using FluentAssertions;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
@@ -73,8 +74,9 @@ public void VerifyEventType()
             PropertyReassignmentEventArgs propReassign = new("prop", "prevValue", "newValue", "loc", "message", "help", "sender", MessageImportance.Normal);
             ResponseFileUsedEventArgs responseFileUsed = new("path");
             UninitializedPropertyReadEventArgs uninitializedPropertyRead = new("prop", "message", "help", "sender", MessageImportance.Normal);
-            EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "help", "sender", MessageImportance.Normal);
+            EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "file", 0, 0);
             GeneratedFileUsedEventArgs generatedFileUsed = new GeneratedFileUsedEventArgs("path", "some content");
+            BuildSubmissionStartedEventArgs buildSubmissionStarted = new(new Dictionary<string, string> { { "Value1", "Value2" } }, ["Path1"], ["TargetName"], BuildRequestDataFlags.ReplaceExistingProjectInstance, 123);
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -108,6 +110,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(uninitializedPropertyRead, LoggingEventType.UninitializedPropertyRead);
             VerifyLoggingPacket(environmentVariableRead, LoggingEventType.EnvironmentVariableReadEvent);
             VerifyLoggingPacket(generatedFileUsed, LoggingEventType.GeneratedFileUsedEvent);
+            VerifyLoggingPacket(buildSubmissionStarted, LoggingEventType.BuildSubmissionStartedEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
@@ -251,7 +254,7 @@ public void TestTranslation()
                 {
                     new ResponseFileUsedEventArgs("path"),
                     new UninitializedPropertyReadEventArgs("prop", "message", "help", "sender", MessageImportance.Normal),
-                    new EnvironmentVariableReadEventArgs("env", "message", "help", "sender", MessageImportance.Normal) { BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6) },
+                    new EnvironmentVariableReadEventArgs("env", "message", "file", 0, 0) { BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6) },
                     new PropertyReassignmentEventArgs("prop", "prevValue", "newValue", "loc", "message", "help", "sender", MessageImportance.Normal),
                     new PropertyInitialValueSetEventArgs("prop", "val", "propsource", "message", "help", "sender", MessageImportance.Normal),
                     new MetaprojectGeneratedEventArgs("metaName", "path", "message"),
diff --git a/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
index 4f35fa823fe..81caa63af47 100644
--- a/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
@@ -18,7 +18,7 @@ public async Task EmitConsoleMessages()
         {
             StringBuilder sb = new StringBuilder();
 
-            using (var writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text)))
+            using (OutOfProcServerNode.RedirectConsoleWriter writer = new(text => sb.Append(text)))
             {
                 writer.WriteLine("Line 1");
                 await Task.Delay(80); // should be somehow bigger than `RedirectConsoleWriter` flush period - see its constructor
diff --git a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
index 8f436af4e0a..99aad984e34 100644
--- a/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RequestBuilder_Tests.cs
@@ -356,16 +356,16 @@ internal void SetNewBuildRequests(FullyQualifiedBuildRequest[] requests)
 
         #region ITargetBuilder Members
 
-        public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, string[] targets, Lookup baseLookup, CancellationToken cancellationToken)
+        public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, (string name, TargetBuiltReason reason)[] targets, Lookup baseLookup, CancellationToken cancellationToken)
         {
             _requestBuilderCallback = callback;
 
             if (cancellationToken.WaitHandle.WaitOne(1500))
             {
                 BuildResult result = new BuildResult(entry.Request);
-                foreach (string target in targets)
+                foreach ((string name, TargetBuiltReason reason) target in targets)
                 {
-                    result.AddResultsForTarget(target, BuildResultUtilities.GetEmptyFailingTargetResult());
+                    result.AddResultsForTarget(target.name, BuildResultUtilities.GetEmptyFailingTargetResult());
                 }
                 return Task<BuildResult>.FromResult(result);
             }
@@ -388,9 +388,9 @@ public Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, Buil
                 if (cancellationToken.WaitHandle.WaitOne(1500))
                 {
                     BuildResult result = new BuildResult(entry.Request);
-                    foreach (string target in targets)
+                    foreach ((string name, TargetBuiltReason reason) target in targets)
                     {
-                        result.AddResultsForTarget(target, BuildResultUtilities.GetEmptyFailingTargetResult());
+                        result.AddResultsForTarget(target.name, BuildResultUtilities.GetEmptyFailingTargetResult());
                     }
                     return Task<BuildResult>.FromResult(result);
                 }
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index ac421399121..7fc43eccc59 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -383,6 +383,7 @@ public static IEnumerable<object[]> CacheSerializationTestData
             }
         }
 
+        // Serialize latest version and deserialize latest version of the cache
         [Theory]
         [MemberData(nameof(CacheSerializationTestData))]
         public void TestResultsCacheTranslation(object obj)
@@ -393,12 +394,49 @@ public void TestResultsCacheTranslation(object obj)
 
             var copy = new ResultsCache(TranslationHelpers.GetReadTranslator());
 
-            copy.ResultsDictionary.Keys.ToHashSet().SetEquals(resultsCache.ResultsDictionary.Keys.ToHashSet()).ShouldBeTrue();
+            CompareResultsCache(resultsCache, copy);
+        }
+
+        [Theory]
+        [InlineData(1, 1)] // Serialize version 0 and deserialize version 0 
+        [InlineData(1, 0)] // Serialize version 0 and deserialize latest version
+        public void TestResultsCacheTranslationAcrossVersions(int envValue1, int envValue2)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                env.SetEnvironmentVariable("MSBUILDDONOTVERSIONBUILDRESULT", $"{envValue1}");
+
+                // Create a ResultsCache
+                var request1 = new BuildRequest(1, 2, 3, new[] { "target1" }, null, BuildEventContext.Invalid, null);
+                var request2 = new BuildRequest(4, 5, 6, new[] { "target2" }, null, BuildEventContext.Invalid, null);
+
+                var br1 = new BuildResult(request1);
+                var br2 = new BuildResult(request2);
+                br2.AddResultsForTarget("target2", BuildResultUtilities.GetEmptyFailingTargetResult());
+
+                var resultsCache = new ResultsCache();
+                resultsCache.AddResult(br1.Clone());
+                resultsCache.AddResult(br2.Clone());
+
+                resultsCache.Translate(TranslationHelpers.GetWriteTranslator());
+
+                env.SetEnvironmentVariable("MSBUILDDONOTVERSIONBUILDRESULT", $"{envValue2}");
+                Traits.UpdateFromEnvironment();
+
+                var copy = new ResultsCache(TranslationHelpers.GetReadTranslator());
+
+                CompareResultsCache(resultsCache, copy);
+            }
+        }
+
+        private void CompareResultsCache(ResultsCache resultsCache1, ResultsCache resultsCache2)
+        {
+            resultsCache2.ResultsDictionary.Keys.ToHashSet().SetEquals(resultsCache1.ResultsDictionary.Keys.ToHashSet()).ShouldBeTrue();
 
-            foreach (var configId in copy.ResultsDictionary.Keys)
+            foreach (var configId in resultsCache2.ResultsDictionary.Keys)
             {
-                var copiedBuildResult = copy.ResultsDictionary[configId];
-                var initialBuildResult = resultsCache.ResultsDictionary[configId];
+                var copiedBuildResult = resultsCache2.ResultsDictionary[configId];
+                var initialBuildResult = resultsCache1.ResultsDictionary[configId];
 
                 copiedBuildResult.SubmissionId.ShouldBe(initialBuildResult.SubmissionId);
                 copiedBuildResult.ConfigurationId.ShouldBe(initialBuildResult.ConfigurationId);
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index f5887f5a46b..62e842a2558 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -150,29 +150,6 @@ public void AssertFirstResolverCanResolve()
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
         }
 
-        [Fact]
-        // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 and resolves sdk.
-        public void AssertFirstResolverWithPatternCantResolveChangeWave17_4()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_4.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeResolversWithPatterns: true));
-
-                SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
-
-                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
-
-                result.Path.ShouldBe("resolverpath1");
-                _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
-                _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
-                ChangeWaves.ResetStateForTests();
-            }
-        }
-
         [Fact]
         // Scenario: MockSdkResolver1 has higher priority than MockSdkResolverWithResolvableSdkPattern1 but MockSdkResolverWithResolvableSdkPattern1 resolves sdk,
         // becuase MockSdkResolver1 is general and MockSdkResolverWithResolvableSdkPattern1 is specific.
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 8807b4c2979..fb9e7d88667 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
 using System.Xml;
@@ -100,9 +101,10 @@ public void TestSimpleBuild()
             // The Empty target has no inputs or outputs.
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Empty" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Empty", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             Assert.True(result.HasResultsForTarget("Empty"));
             Assert.Equal(TargetResultCode.Success, result["Empty"].ResultCode);
             Assert.Empty(result["Empty"].Items);
@@ -120,8 +122,9 @@ public void TestDependencyBuild()
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
 
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Baz" }), cache[1]);
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            (string name, TargetBuiltReason reason)[] target = { ("Baz", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
 
             // The result returned from the builder includes only those for the specified targets.
             Assert.True(result.HasResultsForTarget("Baz"));
@@ -145,8 +148,9 @@ public void TestDependencyBuildWithSkip()
             // DepSkip depends on Skip (which skips) but should succeed itself.
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "DepSkip" }), cache[1]);
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            (string name, TargetBuiltReason reason)[] target = { ("DepSkip", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             Assert.True(result.HasResultsForTarget("DepSkip"));
             Assert.False(result.HasResultsForTarget("Skip"));
             Assert.Equal(TargetResultCode.Success, result["DepSkip"].ResultCode);
@@ -173,8 +177,9 @@ public void TestDependencyBuildWithError()
             taskBuilder.FailTaskNumber = 3; // Succeed on Foo's one task, and Error's first task, and fail the second.
 
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "DepError" }), cache[1]);
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            (string name, TargetBuiltReason reason)[] target = { ("DepError", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             Assert.True(result.HasResultsForTarget("DepError"));
             Assert.False(result.HasResultsForTarget("Foo"));
             Assert.False(result.HasResultsForTarget("Skip"));
@@ -357,9 +362,10 @@ public void TestLegacyCallTarget()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "CallTarget", "Foo2Target", "FooTarget", "GooTarget" });
         }
 
@@ -496,9 +502,10 @@ public void TestBeforeTargetsEmpty()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildTask" });
         }
 
@@ -521,9 +528,10 @@ public void TestBeforeTargetsSingle()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BeforeTask", "BuildTask" });
         }
 
@@ -546,9 +554,10 @@ public void TestBeforeTargetsEscaped()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build;Me" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build;Me", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BeforeTask", "BuildTask" });
         }
 
@@ -575,9 +584,10 @@ public void TestBeforeTargetsSingleWithError()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BeforeTask", "BuildTask" });
         }
 
@@ -609,9 +619,10 @@ public void TestBeforeTargetsSingleWithErrorAndParent()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BeforeTask", "BuildTask", "Error" });
         }
 
@@ -640,9 +651,10 @@ public void TestBeforeTargetsWithTwoReferringToOne()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BeforeTask", "BeforeTask2", "BuildTask" });
         }
 
@@ -670,9 +682,10 @@ public void TestBeforeTargetsWithOneReferringToTwo()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Foo" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Foo", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BeforeTask", "FooTask" });
         }
 
@@ -695,9 +708,10 @@ public void TestBeforeTargetsSkip()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BeforeTask" });
         }
 
@@ -730,9 +744,10 @@ public void TestBeforeTargetsDependencyOrdering()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildDepTask", "BeforeDepTask", "BeforeTask", "BuildTask" });
         }
 
@@ -755,9 +770,10 @@ public void TestAfterTargetsEmpty()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) }
+;            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildTask" });
             Assert.False(result.ResultsByTarget["Build"].AfterTargetsHaveFailed);
         }
@@ -781,9 +797,10 @@ public void TestAfterTargetsSkip()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "AfterTask" });
             Assert.False(result.ResultsByTarget["Build"].AfterTargetsHaveFailed);
         }
@@ -810,9 +827,10 @@ public void TestAfterTargetsSingleWithError()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildTask" });
             Assert.False(result.ResultsByTarget["Build"].AfterTargetsHaveFailed);
         }
@@ -853,9 +871,10 @@ public void TestAfterTargetsSingleWithErrorAndParent()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "PostBuild" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("PostBuild", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildTask", "AfterTask", "Error2" });
             Assert.False(result.ResultsByTarget["PostBuild"].AfterTargetsHaveFailed);
         }
@@ -879,9 +898,10 @@ public void TestAfterTargetsSingle()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildTask", "AfterTask" });
             Assert.False(result.ResultsByTarget["Build"].AfterTargetsHaveFailed);
         }
@@ -905,9 +925,10 @@ public void TestAfterTargetsEscaped()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build;Me" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build;Me", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildTask", "AfterTask" });
             Assert.False(result.ResultsByTarget["Build;Me"].AfterTargetsHaveFailed);
         }
@@ -936,9 +957,10 @@ public void TestAfterTargetsWithTwoReferringToOne()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildTask", "AfterTask", "AfterTask2" });
             Assert.False(result.ResultsByTarget["Build"].AfterTargetsHaveFailed);
         }
@@ -959,7 +981,7 @@ public void TestAfterTargetsWithFailure()
 </Target>
 ";
 
-            BuildResult result = BuildSimpleProject(projectBody, new string[] { "Build" }, failTaskNumber: 2 /* Fail on After */);
+            BuildResult result = BuildSimpleProject(projectBody, new (string name, TargetBuiltReason reason)[] { ("Build", TargetBuiltReason.None) }, failTaskNumber: 2 /* Fail on After */);
             result.ResultsByTarget["Build"].ResultCode.ShouldBe(TargetResultCode.Success);
             result.ResultsByTarget["Build"].AfterTargetsHaveFailed.ShouldBe(true);
         }
@@ -984,7 +1006,7 @@ public void TestAfterTargetsWithTransitiveFailure()
 </Target>
 ";
 
-            BuildResult result = BuildSimpleProject(projectBody, new string[] { "Build" }, failTaskNumber: 3 /* Fail on After2 */);
+            BuildResult result = BuildSimpleProject(projectBody, new (string name, TargetBuiltReason reason)[] { ("Build", TargetBuiltReason.None) }, failTaskNumber: 3 /* Fail on After2 */);
             result.ResultsByTarget["Build"].ResultCode.ShouldBe(TargetResultCode.Success);
             result.ResultsByTarget["Build"].AfterTargetsHaveFailed.ShouldBe(true);
         }
@@ -1003,7 +1025,7 @@ public void TestAfterTargetsWithCycleDoesNotHang()
 <Target Name='After2' AfterTargets='After1' />
 ";
 
-            BuildResult result = BuildSimpleProject(projectBody, new string[] { "Build" }, failTaskNumber: int.MaxValue /* no task failure needed here */);
+            BuildResult result = BuildSimpleProject(projectBody, new (string name, TargetBuiltReason reason)[] { ("Build", TargetBuiltReason.None) }, failTaskNumber: int.MaxValue /* no task failure needed here */);
             result.ResultsByTarget["Build"].ResultCode.ShouldBe(TargetResultCode.Success);
             result.ResultsByTarget["Build"].AfterTargetsHaveFailed.ShouldBe(false);
         }
@@ -1033,9 +1055,10 @@ public void TestAfterTargetsWithOneReferringToTwo()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Foo" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Foo", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "FooTask", "AfterTask" });
         }
 
@@ -1067,9 +1090,10 @@ public void TestAfterTargetsWithDependencyOrdering()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildDepTask", "BuildTask", "AfterDepTask", "AfterTask" });
         }
 
@@ -1117,9 +1141,10 @@ public void TestComplexOrdering()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildDepTask", "BeforeDepDepTask", "BeforeDepTask", "BeforeTask", "BuildTask", "AfterDepDepTask", "AfterDepTask", "AfterTask" });
         }
 
@@ -1176,9 +1201,10 @@ public void TestComplexOrdering2()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildDepTask", "BeforeDepDepTask", "BeforeBeforeDepTask", "AfterBeforeBeforeDepTask", "BeforeDepTask", "BeforeTask", "AfterBeforeDepDepTask", "AfterBeforeDepTask", "AfterBeforeTask", "BuildTask" });
         }
 
@@ -1217,9 +1243,10 @@ public void TestBeforeAndAfterWithErrorTargets()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildTask", "BeforeErrorTargetTask", "ErrorTargetTask", "AfterErrorTargetTask" });
             Assert.False(result.ResultsByTarget["Build"].AfterTargetsHaveFailed);
         }
@@ -1262,9 +1289,10 @@ public void TestBeforeAndAfterOverrides()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BeforeTask", "BuildDepTask", "AfterTask", "BuildTask" });
         }
 
@@ -1292,9 +1320,10 @@ public void TestSkippingBeforeAndAfterTargets()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
             AssertTaskExecutionOrder(new string[] { "BuildTask" });
         }
 
@@ -1365,10 +1394,11 @@ public void TestCancelWithNoEntriesAfterBuild()
 
             TargetBuilder builder = (TargetBuilder)_host.GetComponent(BuildComponentType.TargetBuilder);
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
             using (CancellationTokenSource source = new CancellationTokenSource())
             {
-                BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), source.Token).Result;
+                BuildResult result = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), source.Token).Result;
                 AssertTaskExecutionOrder(new string[] { "BuildTask" });
 
                 // This simply should not fail.
@@ -1397,9 +1427,10 @@ public void SkippedTargetWithFailedDependenciesStopsBuild()
             taskBuilder.FailTaskNumber = 1;
 
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new[] { "Build" }), cache[1]);
+            (string name, TargetBuiltReason reason)[] target = { ("Build", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target), cache[1]);
 
-            var buildResult = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            var buildResult = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
 
             IResultsCache resultsCache = (IResultsCache)_host.GetComponent(BuildComponentType.ResultsCache);
             Assert.True(resultsCache.GetResultForRequest(entry.Request).HasResultsForTarget("Build"));
@@ -1423,8 +1454,9 @@ public void SkipNonexistentTargetsDoesNotExecuteOrCacheTargetResult()
             taskBuilder.FailTaskNumber = 1;
 
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
-            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, new[] { "NotFound" }, BuildRequestDataFlags.SkipNonexistentTargets), cache[1]);
-            var buildResult = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            (string name, TargetBuiltReason reason)[] target = { ("NotFound", TargetBuiltReason.None) };
+            BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, target, BuildRequestDataFlags.SkipNonexistentTargets), cache[1]);
+            var buildResult = builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, target, CreateStandardLookup(project), CancellationToken.None).Result;
 
             IResultsCache resultsCache = (IResultsCache)_host.GetComponent(BuildComponentType.ResultsCache);
 
@@ -1525,9 +1557,9 @@ private void AssertTaskExecutionOrder(string[] tasks)
         /// <summary>
         /// Creates a new build request
         /// </summary>
-        private BuildRequest CreateNewBuildRequest(int configurationId, string[] targets, BuildRequestDataFlags flags = BuildRequestDataFlags.None)
+        private BuildRequest CreateNewBuildRequest(int configurationId, (string name, TargetBuiltReason reason)[] targets, BuildRequestDataFlags flags = BuildRequestDataFlags.None)
         {
-            return new BuildRequest(1 /* submissionId */, _nodeRequestId++, configurationId, targets, null, BuildEventContext.Invalid, null, flags);
+            return new BuildRequest(1 /* submissionId */, _nodeRequestId++, configurationId, targets.Select(t => t.name).ToArray(), null, BuildEventContext.Invalid, null, flags);
         }
 
         /// <summary>
@@ -1668,7 +1700,7 @@ private ProjectLoggingContext GetProjectLoggingContext(BuildRequestEntry entry)
         /// <param name="targets">The targets to build.</param>
         /// <param name="failTaskNumber">The task ordinal to fail on.</param>
         /// <returns>The result of building the specified project/tasks.</returns>
-        private BuildResult BuildSimpleProject(string projectBody, string[] targets, int failTaskNumber)
+        private BuildResult BuildSimpleProject(string projectBody, (string name, TargetBuiltReason reason)[] targets, int failTaskNumber)
         {
             ProjectInstance project = CreateTestProject(projectBody);
 
@@ -1679,7 +1711,7 @@ private BuildResult BuildSimpleProject(string projectBody, string[] targets, int
             IConfigCache cache = (IConfigCache)_host.GetComponent(BuildComponentType.ConfigCache);
             BuildRequestEntry entry = new BuildRequestEntry(CreateNewBuildRequest(1, targets), cache[1]);
 
-            return builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, entry.Request.Targets.ToArray(), CreateStandardLookup(project), CancellationToken.None).Result;
+            return builder.BuildTargets(GetProjectLoggingContext(entry), entry, this, targets, CreateStandardLookup(project), CancellationToken.None).Result;
         }
 
         /// <summary>
@@ -1825,6 +1857,9 @@ public IBuildComponent GetComponent(BuildComponentType type)
                 };
             }
 
+            public TComponent GetComponent<TComponent>(BuildComponentType type) where TComponent : IBuildComponent
+                => (TComponent)GetComponent(type);
+
             /// <summary>
             /// Registers a component factory
             /// </summary>
@@ -1833,27 +1868,6 @@ public void RegisterFactory(BuildComponentType type, BuildComponentFactoryDelega
             }
 
             #endregion
-
-            #region IBuildComponent Members
-
-            /// <summary>
-            /// Sets the component host
-            /// </summary>
-            /// <param name="host">The component host</param>
-            public void InitializeComponent(IBuildComponentHost host)
-            {
-                throw new NotImplementedException();
-            }
-
-            /// <summary>
-            /// Shuts down the component
-            /// </summary>
-            public void ShutdownComponent()
-            {
-                throw new NotImplementedException();
-            }
-
-            #endregion
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 3dea23f8e46..b2cb7cd17bd 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -1327,6 +1327,9 @@ public IBuildComponent GetComponent(BuildComponentType type)
                 };
             }
 
+            public TComponent GetComponent<TComponent>(BuildComponentType type) where TComponent : IBuildComponent
+                => (TComponent)GetComponent(type);
+
             /// <summary>
             /// Register a component factory.
             /// </summary>
@@ -1335,27 +1338,6 @@ public void RegisterFactory(BuildComponentType type, BuildComponentFactoryDelega
             }
 
             #endregion
-
-            #region IBuildComponent Members
-
-            /// <summary>
-            /// Sets the component host
-            /// </summary>
-            /// <param name="host">The component host</param>
-            public void InitializeComponent(IBuildComponentHost host)
-            {
-                throw new NotImplementedException();
-            }
-
-            /// <summary>
-            /// Shuts down the component
-            /// </summary>
-            public void ShutdownComponent()
-            {
-                throw new NotImplementedException();
-            }
-
-            #endregion
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index c4a3d2bda19..68a8dea7eb0 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -1384,6 +1384,9 @@ public IBuildComponent GetComponent(BuildComponentType type)
                 };
             }
 
+            public TComponent GetComponent<TComponent>(BuildComponentType type) where TComponent : IBuildComponent
+                => (TComponent)GetComponent(type);
+
             /// <summary>
             /// Register a component factory.
             /// </summary>
@@ -1392,27 +1395,6 @@ public void RegisterFactory(BuildComponentType type, BuildComponentFactoryDelega
             }
 
             #endregion
-
-            #region IBuildComponent Members
-
-            /// <summary>
-            /// Sets the component host
-            /// </summary>
-            /// <param name="host">The component host</param>
-            public void InitializeComponent(IBuildComponentHost host)
-            {
-                throw new NotImplementedException();
-            }
-
-            /// <summary>
-            /// Shuts down the component
-            /// </summary>
-            public void ShutdownComponent()
-            {
-                throw new NotImplementedException();
-            }
-
-            #endregion
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 5c82a444f39..ebb24ca82e6 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -61,31 +61,11 @@ public void TaskNodesDieAfterBuild()
             }
         }
 
-        [DotNetOnlyTheory]
-        [InlineData(false)]
-        // [InlineData(true)] <-- explicitly opting out on core will lead to node crash
-        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_NetCore(
-            bool testLegacyImplementation)
-            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
-
-        [WindowsFullFrameworkOnlyTheory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost_Framework(
-            bool testLegacyImplementation)
-            => VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(testLegacyImplementation);
-
-        private void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(bool testLegacyImplementation)
+        [Fact]
+        private void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost()
         {
             using TestEnvironment env = TestEnvironment.Create(_output);
 
-            ChangeWaves.ResetStateForTests();
-            if (testLegacyImplementation)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             string boolParam = "True";
             string boolArrayParam = "False;True;False";
             string byteParam = "42";
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 656f906ccfa..2ed1f77f758 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -95,6 +95,45 @@ public void RoundtripBuildFinishedEventArgs()
                 e => e.Succeeded.ToString());
         }
 
+        [Fact]
+        public void RoundtripBuildSubmissionStartedEventArgs()
+        {
+            var globalVariables = new Dictionary<string, string>
+            {
+                {"Variable1", "Value1" },
+                {"Variable2", "" },
+                {"Variable3", null },
+            };
+            var entryPointProjects = new List<string>()
+            {
+                "project1",
+                "project2",
+                "",
+            };
+            var targetNames = new List<string>()
+            {
+                "target1",
+                "target2",
+                "",
+            };
+            var flag = Execution.BuildRequestDataFlags.FailOnUnresolvedSdk;
+            var submissionId = 1234;
+
+            BuildSubmissionStartedEventArgs args = new(
+                globalVariables,
+                entryPointProjects,
+                targetNames,
+                flag,
+                submissionId);
+
+            Roundtrip<BuildSubmissionStartedEventArgs>(args,
+                e => TranslationHelpers.GetPropertiesString(e.GlobalProperties),
+                e => TranslationHelpers.GetPropertiesString(e.EntryProjectsFullPath),
+                e => TranslationHelpers.GetPropertiesString(e.TargetNames),
+                e => e.Flags.ToString(),
+                e => e.SubmissionId.ToString());
+        }
+
         [Fact]
         public void RoundtripProjectStartedEventArgs()
         {
@@ -209,7 +248,7 @@ public void RoundtripTaskStartedEventArgs()
         [Fact]
         public void RoundtripEnvironmentVariableReadEventArgs()
         {
-            EnvironmentVariableReadEventArgs args = new("VarName", "VarValue");
+            EnvironmentVariableReadEventArgs args = new("VarName", "VarValue", "file", 10, 20);
             args.BuildEventContext = new BuildEventContext(4, 5, 6, 7);
             Roundtrip(args,
                 e => e.Message,
@@ -800,22 +839,6 @@ public void RoundtripTargetSkippedEventArgs()
                 e => e.OriginallySucceeded.ToString());
         }
 
-        [Fact]
-        public void RoundTripEnvironmentVariableReadEventArgs()
-        {
-            var args = new EnvironmentVariableReadEventArgs(
-                environmentVariableName: Guid.NewGuid().ToString(),
-                message: Guid.NewGuid().ToString(),
-                helpKeyword: Guid.NewGuid().ToString(),
-                senderName: Guid.NewGuid().ToString());
-
-            Roundtrip(args,
-                e => e.EnvironmentVariableName,
-                e => e.Message,
-                e => e.HelpKeyword,
-                e => e.SenderName);
-        }
-
         [Fact]
         public void RoundTripPropertyReassignmentEventArgs()
         {
diff --git a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
index 882753a8a50..4866a721238 100644
--- a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
@@ -180,7 +180,7 @@ public void ImportProperties()
         public void DeepClone()
         {
             CopyOnWritePropertyDictionary<MockValue> source = CreateInstance("a", "b", "c");
-            CopyOnWritePropertyDictionary<MockValue> clone = source.DeepClone();
+            CopyOnWritePropertyDictionary<MockValue> clone = (CopyOnWritePropertyDictionary<MockValue>)source.DeepClone();
 
             source.ShouldBe(clone);
             source.ShouldNotBeSameAs(clone);
diff --git a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
index 8b7ecc8f0b0..cb38a267ae5 100644
--- a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using FluentAssertions;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Shouldly;
@@ -148,7 +149,7 @@ public void ProjectShouldHaveValidEvaluationIdDuringEvaluation()
                             var eventEvaluationId = args.BuildEventContext.EvaluationId;
 
                             eventEvaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);
-                            project.LastEvaluationId.ShouldBe(eventEvaluationId);
+                            project.LastEvaluationId.Should().Be(eventEvaluationId);
                         }
                     }
                 });
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 64c352cd512..3fd8d86a18a 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -21,7 +21,6 @@
 using Microsoft.Build.Shared.FileSystem;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
 #nullable disable
@@ -51,6 +50,23 @@ public void Dispose()
             GC.Collect();
         }
 
+        [Fact]
+        public void EnsureProjectEvaluationFinishedIsLogged()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile projectFile = env.CreateFile("project.proj", $@"
+<Project Sdk=""Microsoft.NETT.Sdk"">
+  <Target Name=""DefaultTarget"">
+  </Target>
+</Project>
+");
+
+            MockLogger logger = new();
+            using ProjectCollection collection = new(new Dictionary<string, string>(), [logger], ToolsetDefinitionLocations.Default);
+            Assert.Throws<InvalidProjectFileException>(() => collection.LoadProject(projectFile.Path));
+            logger.EvaluationFinishedEvents.ShouldNotBeEmpty();
+        }
+
         [Theory]
         [MemberData(nameof(ImportLoadingScenarioTestData))]
         public void VerifyLoadingImportScenarios(string importParameter, bool shouldSucceed)
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 25187464656..b29a857dc69 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -40,8 +40,6 @@ public class Expander_Tests
         private string _dateToParse = new DateTime(2010, 12, 25).ToString(CultureInfo.CurrentCulture);
         private static readonly string s_rootPathPrefix = NativeMethodsShared.IsWindows ? "C:\\" : Path.VolumeSeparatorChar.ToString();
 
-        private static bool IsIntrinsicFunctionOverloadsEnabled => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8);
-
         [Fact]
         public void ExpandAllIntoTaskItems0()
         {
@@ -4577,7 +4575,7 @@ public void PropertyFunctionMSBuildAddRealLiteral()
         public void PropertyFunctionMSBuildAddIntegerOverflow()
         {
             // Overflow wrapping - result exceeds size of long
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "-9223372036854775808" : (long.MaxValue + 1.0).ToString();
+            string expected = "-9223372036854775808";
             TestPropertyFunction("$([MSBuild]::Add($(X), 1))", "X", long.MaxValue.ToString(), expected);
         }
 
@@ -4612,7 +4610,7 @@ public void PropertyFunctionMSBuildSubtractRealLiteral()
         public void PropertyFunctionMSBuildSubtractIntegerMaxValue()
         {
             // If the double overload is used, there will be a rounding error.
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "1" : "0";
+            string expected = "1";
             TestPropertyFunction("$([MSBuild]::Subtract($(X), 9223372036854775806))", "X", long.MaxValue.ToString(), expected);
         }
 
@@ -4632,7 +4630,7 @@ public void PropertyFunctionMSBuildMultiplyRealLiteral()
         public void PropertyFunctionMSBuildMultiplyIntegerOverflow()
         {
             // Overflow - result exceeds size of long
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "-2" : (long.MaxValue * 2.0).ToString();
+            string expected = "-2";
             TestPropertyFunction("$([MSBuild]::Multiply($(X), 2))", "X", long.MaxValue.ToString(), expected);
         }
 
@@ -4645,7 +4643,7 @@ public void PropertyFunctionMSBuildMultiplyComplex()
         [Fact]
         public void PropertyFunctionMSBuildDivideIntegerLiteral()
         {
-            string expected = IsIntrinsicFunctionOverloadsEnabled ? "6" : "6.5536";
+            string expected = "6";
             TestPropertyFunction("$([MSBuild]::Divide($(X), 10000))", "X", "65536", expected);
         }
 
@@ -5064,6 +5062,41 @@ public void GetTypeMethod_ShouldBeAllowed_EnabledByEnvVariable(string methodName
             }
         }
 
+        [Theory]
+        [InlineData("$([System.Version]::Parse('17.12.11.10').ToString(2))")]
+        [InlineData("$([System.Text.RegularExpressions.Regex]::Replace('abc123def', 'abc', ''))")]
+        [InlineData("$([System.String]::new('Hi').Equals('Hello'))")]
+        [InlineData("$([System.IO.Path]::GetFileNameWithoutExtension('C:\\folder\\file.txt'))")]
+        [InlineData("$([System.Int32]::new(123).ToString('mm')")]
+        [InlineData("$([Microsoft.Build.Evaluation.IntrinsicFunctions]::NormalizeDirectory('C:/folder1/./folder2/'))")]
+        [InlineData("$([Microsoft.Build.Evaluation.IntrinsicFunctions]::IsOSPlatform('Windows'))")]
+        public void FastPathValidationTest(string methodInvocationMetadata)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                // Setting this env variable allows to track if expander was using reflection for a function invocation. 
+                env.SetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection", "1");
+
+                var logger = new MockLogger();
+                ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+                loggingService.RegisterLogger(logger);
+                var loggingContext = new MockLoggingContext(
+                    loggingService,
+                    new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
+
+                _ = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                    new PropertyDictionary<ProjectPropertyInstance>(),
+                    FileSystems.Default,
+                    loggingContext)
+                    .ExpandIntoStringLeaveEscaped(methodInvocationMetadata, ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+
+                string reflectionInfoPath = Path.Combine(Directory.GetCurrentDirectory(), "PropertyFunctionsRequiringReflection");
+
+                // the fast path was successfully resolved without reflection.
+                File.Exists(reflectionInfoPath).ShouldBeFalse();
+            }
+        }
+
         /// <summary>
         /// Determines if ICU mode is enabled.
         /// Copied from: https://learn.microsoft.com/en-us/dotnet/core/extensions/globalization-icu#determine-if-your-app-is-using-icu
diff --git a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
index 9ca64ef3923..099e1404c2c 100644
--- a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
@@ -18,12 +18,8 @@ namespace Microsoft.Build.Engine.UnitTests.Evaluation
 {
     public class IntrinsicFunctionOverload_Tests
     {
-        private Version ChangeWaveForOverloading = ChangeWaves.Wave17_8;
-
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildAddInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildAddInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -32,16 +28,11 @@ public void MSBuildAddInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? unchecked(long.MaxValue + 1).ToString() : (long.MaxValue + 1.0).ToString();
+            string expected = unchecked(long.MaxValue + 1).ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
             ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
 
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
@@ -115,10 +106,8 @@ public void MSBuildAddReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildSubtractInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildSubtractInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -127,17 +116,10 @@ public void MSBuildSubtractInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? 1.ToString() : 0.ToString();
+            string expected = 1.ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
@@ -210,10 +192,8 @@ public void MSBuildSubtractReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildMultiplyInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildMultiplyInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -222,17 +202,10 @@ public void MSBuildMultiplyInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? unchecked(long.MaxValue * 2).ToString() : (long.MaxValue * 2.0).ToString();
+            string expected = unchecked(long.MaxValue * 2).ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
@@ -305,10 +278,8 @@ public void MSBuildMultiplyReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildDivideInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildDivideInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -317,17 +288,10 @@ public void MSBuildDivideInteger(bool isIntrinsicFunctionOverloadsEnabled)
                         </PropertyGroup>
                     </Project>";
 
-            string expected = isIntrinsicFunctionOverloadsEnabled ? (10 / 3).ToString() : (10.0 / 3.0).ToString();
+            string expected = (10 / 3).ToString();
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
@@ -400,10 +364,8 @@ public void MSBuildDivideReal()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void MSBuildModuloInteger(bool isIntrinsicFunctionOverloadsEnabled)
+        [Fact]
+        public void MSBuildModuloInteger()
         {
             const string projectContent = @"
                     <Project>
@@ -416,13 +378,6 @@ public void MSBuildModuloInteger(bool isIntrinsicFunctionOverloadsEnabled)
 
             using TestEnvironment env = TestEnvironment.Create();
 
-            ChangeWaves.ResetStateForTests();
-            if (!isIntrinsicFunctionOverloadsEnabled)
-            {
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaveForOverloading.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-            }
-
             using ProjectFromString projectFromString = new(projectContent.Cleanup());
             Project project = projectFromString.Project;
             ProjectProperty? actualProperty = project.GetProperty("Actual");
diff --git a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
deleted file mode 100644
index 923fe822ce4..00000000000
--- a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
+++ /dev/null
@@ -1,501 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.IO;
-using System.Text;
-using System.Xml;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Xunit;
-
-#nullable disable
-
-namespace Microsoft.Build.UnitTests.OM.Evaluation
-{
-    /// <summary>
-    /// Tests for ProjectStringCache
-    /// </summary>
-    public class ProjectStringCache_Tests
-    {
-        /// <summary>
-        /// Test that loading two instances of the same xml file uses the same strings
-        /// to store read values.
-        /// </summary>
-        [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void ContentIsSameAcrossInstances()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-                    <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
-                        <ItemGroup>
-                           Item group content
-                        </ItemGroup>
-                    </Project>
-                    ");
-
-                string path = FileUtilities.GetTemporaryFileName();
-
-                try
-                {
-                    File.WriteAllText(path, content);
-
-                    ProjectStringCache cache = new ProjectStringCache();
-                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                    document1.StringCache = cache;
-                    document1.Load(path);
-
-                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                    document2.StringCache = cache;
-                    document2.Load(path);
-
-                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
-
-                    Assert.Equal(1, nodes1.Count);
-                    Assert.Equal(1, nodes2.Count);
-
-                    XmlNode node1 = nodes1[0].FirstChild;
-                    XmlNode node2 = nodes2[0].FirstChild;
-
-                    Assert.NotNull(node1);
-                    Assert.NotNull(node2);
-                    Assert.NotSame(node1, node2);
-                    Assert.Same(node1.Value, node2.Value);
-                }
-                finally
-                {
-                    File.Delete(path);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Test that modifying one instance of a file does not affect the other file.
-        /// </summary>
-        [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void ContentCanBeModified()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-                    <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
-                        <ItemGroup attr1='attr1value'>
-                           Item group content
-                        </ItemGroup>
-                    </Project>
-                    ");
-
-                string path = FileUtilities.GetTemporaryFileName();
-
-                try
-                {
-                    File.WriteAllText(path, content);
-                    ProjectStringCache cache = new ProjectStringCache();
-                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                    document1.StringCache = cache;
-                    document1.Load(path);
-
-                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                    document2.StringCache = cache;
-                    document2.Load(path);
-
-                    string outerXml1 = document1.OuterXml;
-                    string outerXml2 = document2.OuterXml;
-                    Assert.Equal(outerXml1, outerXml2);
-
-                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
-
-                    Assert.Equal(1, nodes1.Count);
-                    Assert.Equal(1, nodes2.Count);
-
-                    XmlNode node1 = nodes1[0];
-                    XmlNode node2 = nodes2[0];
-                    Assert.NotNull(node1);
-                    Assert.NotNull(node2);
-                    Assert.NotSame(node1, node2);
-                    Assert.Single(node1.Attributes);
-                    Assert.Single(node2.Attributes);
-                    Assert.Same(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                    node2.Attributes[0].Value = "attr1value";
-                    Assert.Equal(node1.Attributes[0].Value, node2.Attributes[0].Value);
-                    Assert.NotSame(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                    node1 = nodes1[0].FirstChild;
-                    node2 = nodes2[0].FirstChild;
-                    Assert.NotSame(node1, node2);
-                    Assert.Same(node1.Value, node2.Value);
-
-                    XmlText newText = document2.CreateTextNode("New Value");
-                    XmlNode parent = node2.ParentNode;
-                    parent.ReplaceChild(newText, node2);
-
-                    Assert.NotEqual(outerXml1, document2.OuterXml);
-                }
-                finally
-                {
-                    File.Delete(path);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Test that unloading a project file makes its string entries disappear from
-        /// the string cache.
-        /// </summary>
-        [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void RemovingFilesRemovesEntries()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string content = ObjectModelHelpers.CleanupFileContents(@"
-                    <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
-                        <ItemGroup>Content</ItemGroup>
-                    </Project>
-                    ");
-
-                string path = FileUtilities.GetTemporaryFileName();
-
-                try
-                {
-                    File.WriteAllText(path, content);
-
-                    ProjectStringCache cache = new ProjectStringCache();
-                    using ProjectCollection collection = new ProjectCollection();
-                    int entryCount;
-
-                    ProjectRootElement pre1 = ProjectRootElement.Create(collection);
-                    pre1.XmlDocument.StringCache = cache;
-                    pre1.FullPath = path;
-                    pre1.XmlDocument.Load(path);
-
-                    entryCount = cache.Count;
-                    Assert.True(entryCount > 0);
-
-                    ProjectRootElement pre2 = ProjectRootElement.Create(collection);
-                    pre2.XmlDocument.StringCache = cache;
-                    pre2.FullPath = path;
-                    pre2.XmlDocument.Load(path);
-
-                    // Entry count should not have changed
-                    Assert.Equal(entryCount, cache.Count);
-
-                    string itemGroupContent = cache.Get("Content");
-                    Assert.NotNull(itemGroupContent);
-
-                    XmlNodeList nodes1 = pre1.XmlDocument.GetElementsByTagName("ItemGroup");
-                    XmlNodeList nodes2 = pre2.XmlDocument.GetElementsByTagName("ItemGroup");
-
-                    Assert.Equal(1, nodes1.Count);
-                    Assert.Equal(1, nodes2.Count);
-
-                    XmlNode node1 = nodes1[0];
-                    XmlNode node2 = nodes2[0];
-                    Assert.NotNull(node1);
-                    Assert.NotNull(node2);
-                    Assert.NotSame(node1, node2);
-                    Assert.Same(node1.Value, node2.Value);
-
-                    // Now remove one document
-                    collection.UnloadProject(pre1);
-
-                    // We should still be able to get Content
-                    itemGroupContent = cache.Get("Content");
-                    Assert.NotNull(itemGroupContent);
-
-                    // Now remove the second document
-                    collection.UnloadProject(pre2);
-
-                    // Now we should not be able to get Content
-                    itemGroupContent = cache.Get("Content");
-                    Assert.Null(itemGroupContent);
-
-                    // And there should be no entries
-                    Assert.Equal(0, cache.Count);
-                }
-                finally
-                {
-                    File.Delete(path);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Adding a string equivalent to an existing instance and under the same document should
-        /// return the existing instance.
-        /// </summary>
-        [Fact]
-        public void AddReturnsSameInstanceForSameDocument()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-
-                // Content of string should be the same.
-                Assert.Equal(1, cache.Count);
-                Assert.Equal(stringToAdd, return1);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-
-                string return2 = cache.Add(builder.ToString(), document);
-
-                // Content of string should be the same.
-                Assert.Equal(builder.ToString(), return2);
-
-                // Returned references should be the same
-                Assert.Same(return1, return2);
-
-                // Should not have added any new string instances to the cache.
-                Assert.Equal(1, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Adding a string equivalent to an existing instance but under a different document
-        /// should return the existing instance.
-        /// </summary>
-        [Fact]
-        public void AddReturnsSameInstanceForDifferentDocument()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-
-                // Content of string should be the same.
-                Assert.Equal(stringToAdd, return1);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-                XmlDocument document2 = new XmlDocument();
-
-                string return2 = cache.Add(builder.ToString(), document2);
-
-                // Content of string should be the same.
-                Assert.Equal(builder.ToString(), return2);
-
-                // Returned references should be the same
-                Assert.Same(return1, return2);
-
-                // Should not have added any new string instances to the cache.
-                Assert.Equal(1, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Removing the last document containing an instance of a string should remove the string entry.
-        /// A subsequent add should then return a different instance.
-        /// </summary>
-        /// <remarks>
-        /// WHITEBOX ASSUMPTION:
-        /// The following method assumes knowledge of the ProjectStringCache internal implementation
-        /// details, and may become invalid if those details change.
-        /// </remarks>
-        [Fact]
-        public void RemoveLastInstanceDeallocatesEntry()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-
-                cache.Clear(document);
-
-                // Should be no instances left.
-                Assert.Equal(0, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-                XmlDocument document2 = new XmlDocument();
-
-                string return2 = cache.Add(builder.ToString(), document2);
-
-                // Returned references should NOT be the same
-                Assert.NotSame(return1, return2);
-            }
-        }
-
-        /// <summary>
-        /// Removing one document containing a string which already existed in the collection
-        /// should still leave a reference in the collection, so that a subsequent add will
-        /// return the existing reference.
-        /// </summary>
-        [Fact]
-        public void RemoveOneInstance()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                string return1 = cache.Add(stringToAdd, document);
-                Assert.Equal(1, cache.Count);
-
-                XmlDocument document2 = new XmlDocument();
-                cache.Add(stringToAdd, document2);
-                Assert.Equal(1, cache.Count);
-
-                cache.Clear(document2);
-
-                // Since there is still one document referencing the string, it should remain.
-                Assert.Equal(1, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('1');
-                XmlDocument document3 = new XmlDocument();
-
-                string return3 = cache.Add(builder.ToString(), document3);
-
-                // Returned references should be the same
-                Assert.Same(return1, return3);
-
-                // Still should only be one cached instance.
-                Assert.Equal(1, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Different strings should get their own entries.
-        /// </summary>
-        [Fact]
-        public void DifferentStringsSameDocument()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                cache.Add(stringToAdd, document);
-                Assert.Equal(1, cache.Count);
-
-                stringToAdd = "Test2";
-                string return2 = cache.Add(stringToAdd, document);
-
-                // The second string gets its own instance.
-                Assert.Equal(2, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('2');
-                string return3 = cache.Add(builder.ToString(), document);
-
-                // The new string should be the same as the other one already in the collection.
-                Assert.Same(return2, return3);
-
-                // No new instances for string with the same content.
-                Assert.Equal(2, cache.Count);
-            }
-        }
-
-        /// <summary>
-        /// Different strings should get their own entries.
-        /// </summary>
-        [Fact]
-        public void DifferentStringsDifferentDocuments()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                ProjectStringCache cache = new ProjectStringCache();
-
-                XmlDocument document = new XmlDocument();
-
-                string stringToAdd = "Test1";
-                cache.Add(stringToAdd, document);
-                Assert.Equal(1, cache.Count);
-
-                stringToAdd = "Test2";
-                XmlDocument document2 = new XmlDocument();
-                string return2 = cache.Add(stringToAdd, document2);
-
-                // The second string gets its own instance.
-                Assert.Equal(2, cache.Count);
-
-                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-                StringBuilder builder = new StringBuilder();
-                builder.Append("Test");
-                builder.Append('2');
-                XmlDocument document3 = new XmlDocument();
-                string return3 = cache.Add(builder.ToString(), document3);
-
-                // The new string should be the same as the other one already in the collection.
-                Assert.Same(return2, return3);
-
-                // No new instances for string with the same content.
-                Assert.Equal(2, cache.Count);
-            }
-        }
-    }
-}
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index c2f62879a4e..b1a0b664c80 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -70,7 +70,7 @@ public void InvalidCacheFilesShouldLogError(byte[] cacheContents)
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
 
             _logger.FullLog.ShouldContain("MSB4256:");
-            _logger.AllBuildEvents.Count.ShouldBe(4);
+            _logger.AllBuildEvents.Count.ShouldBe(6);
             _logger.ErrorCount.ShouldBe(1);
         }
 
@@ -566,7 +566,7 @@ public void NonExistingInputResultsCacheShouldLogError()
 
             result.OverallResult.ShouldBe(BuildResultCode.Failure);
 
-            _logger.AllBuildEvents.Count.ShouldBe(4);
+            _logger.AllBuildEvents.Count.ShouldBe(6);
             _logger.Errors.First().Message.ShouldContain("MSB4255:");
             _logger.Errors.First().Message.ShouldContain("FileDoesNotExist1");
             _logger.Errors.First().Message.ShouldContain("FileDoesNotExist2");
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 7dc46593e79..7699a66b623 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -194,7 +194,7 @@ public void Metadata()
             item.MetadataCount.ShouldBe(s_builtInMetadataNames.Length + 2);
             item.DirectMetadataCount.ShouldBe(1);
 
-            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
             metadata.Count.ShouldBe(2);
             metadata["a"].EvaluatedValue.ShouldBe("override");
             metadata["b"].EvaluatedValue.ShouldBe("base");
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 201b74d310b..022ed16ed2c 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -843,7 +843,7 @@ private void AssertBuildResultForCacheHit(
             // If it's not a cache result by proxy targets then the cache constructed the target results by hand and only the real target result
             // exists in the BuildResult.
 
-            var targetResult = buildResult.ResultsByTarget["Build"];
+            var targetResult = buildResult.ResultsByTarget!["Build"];
 
             targetResult.Items.ShouldHaveSingleItem();
             var itemResult = targetResult.Items.First();
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index b4dbc09c40a..36254bf8544 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -38,3 +38,5 @@
 
 [assembly: Dependency("BuildXL.Utilities.Core", LoadHint.Sometimes)]
 [assembly: Dependency("BuildXL.Processes", LoadHint.Sometimes)]
+
+[assembly: TypeForwardedTo(typeof(Microsoft.Build.Execution.BuildRequestDataFlags))]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 99acd7b5ac8..52c61ccc9ab 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -21,13 +21,12 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
@@ -41,8 +40,6 @@
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
-#nullable disable
-
 namespace Microsoft.Build.Execution
 {
     /// <summary>
@@ -69,7 +66,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// The singleton instance for the BuildManager.
         /// </summary>
-        private static BuildManager s_singletonInstance;
+        private static BuildManager? s_singletonInstance;
 
         /// <summary>
         /// The next build id;
@@ -86,37 +83,37 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// The cache for build request configurations.
         /// </summary>
-        private IConfigCache _configCache;
+        private IConfigCache? _configCache;
 
         /// <summary>
         /// The cache for build results.
         /// </summary>
-        private IResultsCache _resultsCache;
+        private IResultsCache? _resultsCache;
 
         /// <summary>
         /// The object responsible for creating and managing nodes.
         /// </summary>
-        private INodeManager _nodeManager;
+        private INodeManager? _nodeManager;
 
         /// <summary>
         /// The object responsible for creating and managing task host nodes.
         /// </summary>
-        private INodeManager _taskHostNodeManager;
+        private INodeManager? _taskHostNodeManager;
 
         /// <summary>
         /// The object which determines which projects to build, and where.
         /// </summary>
-        private IScheduler _scheduler;
+        private IScheduler? _scheduler;
 
         /// <summary>
         /// The node configuration to use for spawning new nodes.
         /// </summary>
-        private NodeConfiguration _nodeConfiguration;
+        private NodeConfiguration? _nodeConfiguration;
 
         /// <summary>
         /// Any exception which occurs on a logging thread will go here.
         /// </summary>
-        private ExceptionDispatchInfo _threadException;
+        private ExceptionDispatchInfo? _threadException;
 
         /// <summary>
         /// Set of active nodes in the system.
@@ -126,7 +123,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// Event signalled when all nodes have shutdown.
         /// </summary>
-        private AutoResetEvent _noNodesActiveEvent;
+        private AutoResetEvent? _noNodesActiveEvent;
 
         /// <summary>
         /// Mapping of nodes to the configurations they know about.
@@ -141,7 +138,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// CancellationTokenSource to use for async operations. This will be cancelled when we are shutting down to cancel any async operations.
         /// </summary>
-        private CancellationTokenSource _executionCancellationTokenSource;
+        private CancellationTokenSource? _executionCancellationTokenSource;
 
         /// <summary>
         /// The current state of the BuildManager.
@@ -156,7 +153,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// The parameters with which the build was started.
         /// </summary>
-        private BuildParameters _buildParameters;
+        private BuildParameters? _buildParameters;
 
         /// <summary>
         /// The current pending and active submissions.
@@ -164,20 +161,12 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <remarks>
         /// { submissionId, BuildSubmission }
         /// </remarks>
-        private readonly Dictionary<int, BuildSubmission> _buildSubmissions;
-
-        /// <summary>
-        /// The current pending and active graph build submissions.
-        /// </summary>
-        /// <remarks>
-        /// { submissionId, GraphBuildSubmission }
-        /// </remarks>
-        private readonly Dictionary<int, GraphBuildSubmission> _graphBuildSubmissions;
+        private readonly Dictionary<int, BuildSubmissionBase> _buildSubmissions;
 
         /// <summary>
         /// Event signalled when all build submissions are complete.
         /// </summary>
-        private AutoResetEvent _noActiveSubmissionsEvent;
+        private AutoResetEvent? _noActiveSubmissionsEvent;
 
         /// <summary>
         /// The overall success of the build.
@@ -244,7 +233,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// The worker queue.
         /// </summary>
-        private ActionBlock<Action> _workQueue;
+        private ActionBlock<Action>? _workQueue;
 
         /// <summary>
         /// Flag indicating we have disposed.
@@ -259,15 +248,15 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// Messages to be logged
         /// </summary>
-        private IEnumerable<DeferredBuildMessage> _deferredBuildMessages;
+        private IEnumerable<DeferredBuildMessage>? _deferredBuildMessages;
 
         /// <summary>
         /// Build telemetry to be send when this build ends.
         /// <remarks>Could be null</remarks>
         /// </summary>
-        private BuildTelemetry _buildTelemetry;
+        private BuildTelemetry? _buildTelemetry;
 
-        private ProjectCacheService _projectCacheService;
+        private ProjectCacheService? _projectCacheService;
 
         private bool _hasProjectCacheServiceInitializedVsScenario;
 
@@ -301,8 +290,7 @@ public BuildManager(string hostName)
             ErrorUtilities.VerifyThrowArgumentNull(hostName, nameof(hostName));
             _hostName = hostName;
             _buildManagerState = BuildManagerState.Idle;
-            _buildSubmissions = new Dictionary<int, BuildSubmission>();
-            _graphBuildSubmissions = new Dictionary<int, GraphBuildSubmission>();
+            _buildSubmissions = new Dictionary<int, BuildSubmissionBase>();
             _noActiveSubmissionsEvent = new AutoResetEvent(true);
             _activeNodes = new HashSet<int>();
             _noNodesActiveEvent = new AutoResetEvent(true);
@@ -376,13 +364,13 @@ public static BuildManager DefaultBuildManager
         /// <summary>
         /// Retrieves a hosted<see cref="ISdkResolverService"/> instance for resolving SDKs.
         /// </summary>
-        private ISdkResolverService SdkResolverService => (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
+        private ISdkResolverService SdkResolverService => ((this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService)!;
 
         /// <summary>
         /// Retrieves the logging service associated with a particular build
         /// </summary>
         /// <returns>The logging service.</returns>
-        ILoggingService IBuildComponentHost.LoggingService => _componentFactories.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
+        ILoggingService IBuildComponentHost.LoggingService => _componentFactories.GetComponent<ILoggingService>(BuildComponentType.LoggingService);
 
         /// <summary>
         /// Retrieves the name of the component host.
@@ -393,7 +381,7 @@ public static BuildManager DefaultBuildManager
         /// Retrieves the build parameters associated with this build.
         /// </summary>
         /// <returns>The build parameters.</returns>
-        BuildParameters IBuildComponentHost.BuildParameters => _buildParameters;
+        BuildParameters? IBuildComponentHost.BuildParameters => _buildParameters;
 
         /// <summary>
         /// Retrieves the LegacyThreadingData associated with a particular build manager
@@ -409,7 +397,7 @@ public readonly struct DeferredBuildMessage
 
             public string Text { get; }
 
-            public string FilePath { get; }
+            public string? FilePath { get; }
 
             public DeferredBuildMessage(string text, MessageImportance importance)
             {
@@ -471,7 +459,7 @@ public void BeginBuild(BuildParameters parameters)
                     if (NativeMethodsShared.IsWindows || parameters.LowPriority)
                     {
                         ProcessPriorityClass priority = parameters.LowPriority ? ProcessPriorityClass.BelowNormal : ProcessPriorityClass.Normal;
-                        IEnumerable<Process> processes = _nodeManager?.GetProcesses();
+                        IEnumerable<Process>? processes = _nodeManager?.GetProcesses();
                         if (processes is not null)
                         {
                             foreach (Process p in processes)
@@ -548,7 +536,7 @@ public void BeginBuild(BuildParameters parameters)
                 // Initialize additional build parameters.
                 _buildParameters.BuildId = GetNextBuildId();
 
-                if (_buildParameters.UsesCachedResults() && parameters.ProjectIsolationMode == ProjectIsolationMode.False)
+                if (_buildParameters.UsesCachedResults() && _buildParameters.ProjectIsolationMode == ProjectIsolationMode.False)
                 {
                     // If input or output caches are used and the project isolation mode is set to
                     // ProjectIsolationMode.False, then set it to ProjectIsolationMode.True. The explicit
@@ -578,13 +566,19 @@ public void BeginBuild(BuildParameters parameters)
                 // Log deferred messages and response files
                 LogDeferredMessages(loggingService, _deferredBuildMessages);
 
+                // Log if BuildCheck is enabled
+                if (_buildParameters.IsBuildCheckEnabled)
+                {
+                    loggingService.LogComment(buildEventContext: BuildEventContext.Invalid, MessageImportance.Normal, "BuildCheckEnabled");
+                }
+
                 // Log known deferred telemetry
                 loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.GetProperties());
 
                 InitializeCaches();
 
 #if FEATURE_REPORTFILEACCESSES
-                var fileAccessManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager) as IFileAccessManager;
+                var fileAccessManager = ((IBuildComponentHost)this).GetComponent<IFileAccessManager>(BuildComponentType.FileAccessManager);
 #endif
 
                 _projectCacheService = new ProjectCacheService(
@@ -593,13 +587,13 @@ public void BeginBuild(BuildParameters parameters)
 #if FEATURE_REPORTFILEACCESSES
                     fileAccessManager,
 #endif
-                    _configCache,
+                    _configCache!,
                     _buildParameters.ProjectCacheDescriptor);
 
-                _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
-                _scheduler = ((IBuildComponentHost)this).GetComponent(BuildComponentType.Scheduler) as IScheduler;
+                _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent<INodeManager>(BuildComponentType.TaskHostNodeManager);
+                _scheduler = ((IBuildComponentHost)this).GetComponent<IScheduler>(BuildComponentType.Scheduler);
 
-                _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestBlocker, BuildRequestBlocker.FactoryForDeserialization, this);
+                _nodeManager!.RegisterPacketHandler(NodePacketType.BuildRequestBlocker, BuildRequestBlocker.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfiguration, BuildRequestConfiguration.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse, BuildRequestConfigurationResponse.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildResult, BuildResult.FactoryForDeserialization, this);
@@ -623,8 +617,8 @@ public void BeginBuild(BuildParameters parameters)
 
                 _buildManagerState = BuildManagerState.Building;
 
-                _noActiveSubmissionsEvent.Set();
-                _noNodesActiveEvent.Set();
+                _noActiveSubmissionsEvent!.Set();
+                _noNodesActiveEvent!.Set();
             }
 
             ILoggingService InitializeLoggingService()
@@ -636,7 +630,7 @@ ILoggingService InitializeLoggingService()
                     _buildParameters.WarningsNotAsErrors,
                     _buildParameters.WarningsAsMessages);
 
-                _nodeManager.RegisterPacketHandler(NodePacketType.LogMessage, LogMessagePacket.FactoryForDeserialization, loggingService as INodePacketHandler);
+                _nodeManager!.RegisterPacketHandler(NodePacketType.LogMessage, LogMessagePacket.FactoryForDeserialization, loggingService as INodePacketHandler);
 
                 try
                 {
@@ -688,10 +682,10 @@ void InitializeCaches()
                     ReuseOldCaches(_buildParameters.InputResultsCacheFiles);
                 }
 
-                _configCache = ((IBuildComponentHost)this).GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
-                _resultsCache = ((IBuildComponentHost)this).GetComponent(BuildComponentType.ResultsCache) as IResultsCache;
+                _configCache = ((IBuildComponentHost)this).GetComponent<IConfigCache>(BuildComponentType.ConfigCache);
+                _resultsCache = ((IBuildComponentHost)this).GetComponent<IResultsCache>(BuildComponentType.ResultsCache);
 
-                if (!usesInputCaches && (_buildParameters.ResetCaches || _configCache.IsConfigCacheSizeLargerThanThreshold()))
+                if (!usesInputCaches && (_buildParameters.ResetCaches || _configCache!.IsConfigCacheSizeLargerThanThreshold()))
                 {
                     ResetCaches();
                 }
@@ -699,18 +693,18 @@ void InitializeCaches()
                 {
                     if (!usesInputCaches)
                     {
-                        List<int> configurationsCleared = _configCache.ClearNonExplicitlyLoadedConfigurations();
+                        List<int> configurationsCleared = _configCache!.ClearNonExplicitlyLoadedConfigurations();
 
                         if (configurationsCleared != null)
                         {
                             foreach (int configurationId in configurationsCleared)
                             {
-                                _resultsCache.ClearResultsForConfiguration(configurationId);
+                                _resultsCache!.ClearResultsForConfiguration(configurationId);
                             }
                         }
                     }
 
-                    foreach (var config in _configCache)
+                    foreach (var config in _configCache!)
                     {
                         config.ResultsNodeId = Scheduler.InvalidNodeId;
                     }
@@ -734,7 +728,7 @@ private void EnableDetouredNodeLauncher()
             ErrorUtilities.VerifyThrowInvalidOperation(NativeMethodsShared.ProcessorArchitecture == NativeMethodsShared.ProcessorArchitectures.X64, "ReportFileAccessesX64Only");
 
             // To properly report file access, we need to disable the in-proc node which won't be detoured.
-            _buildParameters.DisableInProcNode = true;
+            _buildParameters!.DisableInProcNode = true;
 
             // Node reuse must be disabled as future builds will not be able to listen to events raised by detours.
             _buildParameters.EnableNodeReuse = false;
@@ -765,7 +759,7 @@ private static void AttachDebugger()
                 case "2":
                     // Sometimes easier to attach rather than deal with JIT prompt
                     Process currentProcess = Process.GetCurrentProcess();
-                    Console.WriteLine($"Waiting for debugger to attach ({currentProcess.MainModule.FileName} PID {currentProcess.Id}).  Press enter to continue...");
+                    Console.WriteLine($"Waiting for debugger to attach ({currentProcess.MainModule!.FileName} PID {currentProcess.Id}).  Press enter to continue...");
                     Console.ReadLine();
                     break;
             }
@@ -781,6 +775,9 @@ public void CancelAllSubmissions()
 
         private void CancelAllSubmissions(bool async)
         {
+            ILoggingService loggingService = ((IBuildComponentHost)this).LoggingService;
+            loggingService.LogBuildCanceled();
+
             var parentThreadCulture = _buildParameters != null
                 ? _buildParameters.Culture
                 : CultureInfo.CurrentCulture;
@@ -788,7 +785,7 @@ private void CancelAllSubmissions(bool async)
                 ? _buildParameters.UICulture
                 : CultureInfo.CurrentUICulture;
 
-            void Callback(object state)
+            void Callback(object? state)
             {
                 lock (_syncLock)
                 {
@@ -807,21 +804,15 @@ void Callback(object state)
 
                     _overallBuildSuccess = false;
 
-                    foreach (BuildSubmission submission in _buildSubmissions.Values)
-                    {
-                        if (submission.BuildRequest != null)
-                        {
-                            BuildResult result = new BuildResult(submission.BuildRequest, new BuildAbortedException());
-                            _resultsCache.AddResult(result);
-                            submission.CompleteResults(result);
-                        }
-                    }
-
-                    foreach (GraphBuildSubmission submission in _graphBuildSubmissions.Values)
+                    foreach (BuildSubmissionBase submission in _buildSubmissions.Values)
                     {
                         if (submission.IsStarted)
                         {
-                            submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, new BuildAbortedException()));
+                            BuildResultBase buildResult = submission.CompleteResultsWithException(new BuildAbortedException());
+                            if (buildResult is BuildResult result)
+                            {
+                                _resultsCache!.AddResult(result);
+                            }
                         }
                     }
 
@@ -843,12 +834,12 @@ public void ResetCaches()
                 ErrorIfState(BuildManagerState.WaitingForBuildToComplete, "WaitingForEndOfBuild");
                 ErrorIfState(BuildManagerState.Building, "BuildInProgress");
 
-                _configCache = ((IBuildComponentHost)this).GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
-                _resultsCache = ((IBuildComponentHost)this).GetComponent(BuildComponentType.ResultsCache) as IResultsCache;
-                _resultsCache.ClearResults();
+                _configCache = ((IBuildComponentHost)this).GetComponent<IConfigCache>(BuildComponentType.ConfigCache);
+                _resultsCache = ((IBuildComponentHost)this).GetComponent<IResultsCache>(BuildComponentType.ResultsCache);
+                _resultsCache!.ClearResults();
 
                 // This call clears out the directory.
-                _configCache.ClearConfigurations();
+                _configCache!.ClearConfigurations();
 
                 _buildParameters?.ProjectRootElementCache.DiscardImplicitReferences();
             }
@@ -865,12 +856,12 @@ public ProjectInstance GetProjectInstanceForBuild(Project project)
             lock (_syncLock)
             {
                 _configCache = ((IBuildComponentHost)this).GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
-                BuildRequestConfiguration configuration = _configCache.GetMatchingConfiguration(
+                BuildRequestConfiguration configuration = _configCache!.GetMatchingConfiguration(
                     new ConfigurationMetadata(project),
                     (config, loadProject) => CreateConfiguration(project, config),
                     loadProject: true);
                 ErrorUtilities.VerifyThrow(configuration.Project != null, "Configuration should have been loaded.");
-                return configuration.Project;
+                return configuration.Project!;
             }
         }
 
@@ -880,27 +871,7 @@ public ProjectInstance GetProjectInstanceForBuild(Project project)
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
         public BuildSubmission PendBuildRequest(BuildRequestData requestData)
-        {
-            lock (_syncLock)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(requestData, nameof(requestData));
-                ErrorIfState(BuildManagerState.WaitingForBuildToComplete, "WaitingForEndOfBuild");
-                ErrorIfState(BuildManagerState.Idle, "NoBuildInProgress");
-                VerifyStateInternal(BuildManagerState.Building);
-
-                var newSubmission = new BuildSubmission(this, GetNextSubmissionId(), requestData, _buildParameters.LegacyThreadingSemantics);
-
-                if (_buildTelemetry != null)
-                {
-                    _buildTelemetry.Project ??= requestData.ProjectFullPath;
-                    _buildTelemetry.Target ??= string.Join(",", requestData.TargetNames);
-                }
-
-                _buildSubmissions.Add(newSubmission.SubmissionId, newSubmission);
-                _noActiveSubmissionsEvent.Reset();
-                return newSubmission;
-            }
-        }
+            => (BuildSubmission) PendBuildRequest<BuildRequestData, BuildResult>(requestData);
 
         /// <summary>
         /// Submits a graph build request to the current build but does not start it immediately.  Allows the user to
@@ -908,6 +879,17 @@ public BuildSubmission PendBuildRequest(BuildRequestData requestData)
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
         public GraphBuildSubmission PendBuildRequest(GraphBuildRequestData requestData)
+            => (GraphBuildSubmission) PendBuildRequest<GraphBuildRequestData, GraphBuildResult>(requestData);
+
+        /// <summary>
+        /// Submits a build request to the current build but does not start it immediately.  Allows the user to
+        /// perform asynchronous execution or access the submission ID prior to executing the request.
+        /// </summary>
+        /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
+        private BuildSubmissionBase<TRequestData, TResultData> PendBuildRequest<TRequestData, TResultData>(
+            TRequestData requestData)
+            where TRequestData : BuildRequestData<TRequestData, TResultData>
+            where TResultData : BuildResultBase
         {
             lock (_syncLock)
             {
@@ -916,39 +898,41 @@ public GraphBuildSubmission PendBuildRequest(GraphBuildRequestData requestData)
                 ErrorIfState(BuildManagerState.Idle, "NoBuildInProgress");
                 VerifyStateInternal(BuildManagerState.Building);
 
-                var newSubmission = new GraphBuildSubmission(this, GetNextSubmissionId(), requestData);
+                var newSubmission = requestData.CreateSubmission(this, GetNextSubmissionId(), requestData,
+                    _buildParameters!.LegacyThreadingSemantics);
 
                 if (_buildTelemetry != null)
                 {
                     // Project graph can have multiple entry points, for purposes of identifying event for same build project,
                     // we believe that including only one entry point will provide enough precision.
-                    _buildTelemetry.Project ??= requestData.ProjectGraphEntryPoints?.FirstOrDefault().ProjectFile;
+                    _buildTelemetry.Project ??= requestData.EntryProjectsFullPath.FirstOrDefault();
                     _buildTelemetry.Target ??= string.Join(",", requestData.TargetNames);
                 }
 
-                _graphBuildSubmissions.Add(newSubmission.SubmissionId, newSubmission);
-                _noActiveSubmissionsEvent.Reset();
+                _buildSubmissions.Add(newSubmission.SubmissionId, newSubmission);
+                _noActiveSubmissionsEvent!.Reset();
                 return newSubmission;
             }
         }
 
+        private TResultData BuildRequest<TRequestData, TResultData>(TRequestData requestData)
+            where TRequestData : BuildRequestData<TRequestData, TResultData>
+            where TResultData : BuildResultBase
+            => PendBuildRequest<TRequestData, TResultData>(requestData).Execute();
+
         /// <summary>
         /// Convenience method. Submits a build request and blocks until the results are available.
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
         public BuildResult BuildRequest(BuildRequestData requestData)
-        {
-            BuildSubmission submission = PendBuildRequest(requestData);
-            BuildResult result = submission.Execute();
-
-            return result;
-        }
+            => BuildRequest<BuildRequestData, BuildResult>(requestData);
 
         /// <summary>
         /// Convenience method. Submits a graph build request and blocks until the results are available.
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if StartBuild has not been called or if EndBuild has been called.</exception>
-        public GraphBuildResult BuildRequest(GraphBuildRequestData requestData) => PendBuildRequest(requestData).Execute();
+        public GraphBuildResult BuildRequest(GraphBuildRequestData requestData)
+            => BuildRequest<GraphBuildRequestData, GraphBuildResult>(requestData);
 
         /// <summary>
         /// Signals that no more build requests are expected (or allowed) and the BuildManager may clean up.
@@ -975,36 +959,30 @@ public void EndBuild()
                 lock (_syncLock)
                 {
                     // If there are any submissions which never started, remove them now.
-                    var submissionsToCheck = new List<BuildSubmission>(_buildSubmissions.Values);
-                    foreach (BuildSubmission submission in submissionsToCheck)
-                    {
-                        CheckSubmissionCompletenessAndRemove(submission);
-                    }
-
-                    var graphSubmissionsToCheck = new List<GraphBuildSubmission>(_graphBuildSubmissions.Values);
-                    foreach (GraphBuildSubmission submission in graphSubmissionsToCheck)
+                    var submissionsToCheck = new List<BuildSubmissionBase>(_buildSubmissions.Values);
+                    foreach (BuildSubmissionBase submission in submissionsToCheck)
                     {
                         CheckSubmissionCompletenessAndRemove(submission);
                     }
                 }
 
-                _noActiveSubmissionsEvent.WaitOne();
+                _noActiveSubmissionsEvent!.WaitOne();
                 ShutdownConnectedNodes(false /* normal termination */);
-                _noNodesActiveEvent.WaitOne();
+                _noNodesActiveEvent!.WaitOne();
 
                 // Wait for all of the actions in the work queue to drain.
                 // _workQueue.Completion.Wait() could throw here if there was an unhandled exception in the work queue,
                 // but the top level exception handler there should catch everything and have forwarded it to the
                 // OnThreadException method in this class already.
-                _workQueue.Complete();
+                _workQueue!.Complete();
                 _workQueue.Completion.Wait();
 
-                Task projectCacheDispose = _projectCacheService.DisposeAsync().AsTask();
+                Task projectCacheDispose = _projectCacheService!.DisposeAsync().AsTask();
 
-                ErrorUtilities.VerifyThrow(_buildSubmissions.Count == 0 && _graphBuildSubmissions.Count == 0, "All submissions not yet complete.");
+                ErrorUtilities.VerifyThrow(_buildSubmissions.Count == 0, "All submissions not yet complete.");
                 ErrorUtilities.VerifyThrow(_activeNodes.Count == 0, "All nodes not yet shut down.");
 
-                if (_buildParameters.UsesOutputCache())
+                if (_buildParameters!.UsesOutputCache())
                 {
                     SerializeCaches();
                 }
@@ -1018,7 +996,7 @@ public void EndBuild()
 
                     foreach (KeyValuePair<int, BuildEventArgs> projectStartedEvent in _projectStartedEvents)
                     {
-                        BuildResult result = _resultsCache.GetResultsForConfiguration(projectStartedEvent.Value.BuildEventContext.ProjectInstanceId);
+                        BuildResult result = _resultsCache!.GetResultsForConfiguration(projectStartedEvent.Value.BuildEventContext!.ProjectInstanceId);
 
                         // It's valid to have a mismatched project started event IFF that particular
                         // project had some sort of unhandled exception.  If there is no result, we
@@ -1038,7 +1016,7 @@ public void EndBuild()
 
                 if (_buildParameters.DiscardBuildResults)
                 {
-                    _resultsCache.ClearResults();
+                    _resultsCache!.ClearResults();
                 }
             }
             catch (Exception e)
@@ -1056,7 +1034,7 @@ public void EndBuild()
             {
                 try
                 {
-                    ILoggingService loggingService = ((IBuildComponentHost)this).LoggingService;
+                    ILoggingService? loggingService = ((IBuildComponentHost)this).LoggingService;
 
                     if (loggingService != null)
                     {
@@ -1077,7 +1055,7 @@ public void EndBuild()
                             _buildTelemetry.DisplayVersion = ProjectCollection.DisplayVersion;
                             _buildTelemetry.FrameworkName = NativeMethodsShared.FrameworkName;
 
-                            string host = null;
+                            string? host = null;
                             if (BuildEnvironmentState.s_runningInVisualStudio)
                             {
                                 host = "VS";
@@ -1102,7 +1080,7 @@ public void EndBuild()
                 }
                 finally
                 {
-                    if (_buildParameters.LegacyThreadingSemantics)
+                    if (_buildParameters!.LegacyThreadingSemantics)
                     {
                         _legacyThreadingData.MainThreadSubmissionId = -1;
                     }
@@ -1139,13 +1117,15 @@ void SerializeCaches()
         /// Convenience method.  Submits a lone build request and blocks until results are available.
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
-        public BuildResult Build(BuildParameters parameters, BuildRequestData requestData)
+        private TResultData Build<TRequestData, TResultData>(BuildParameters parameters, TRequestData requestData)
+            where TRequestData : BuildRequestData<TRequestData, TResultData>
+            where TResultData : BuildResultBase
         {
-            BuildResult result;
+            TResultData result;
             BeginBuild(parameters);
             try
             {
-                result = BuildRequest(requestData);
+                result = BuildRequest<TRequestData, TResultData>(requestData);
                 if (result.Exception == null && _threadException != null)
                 {
                     result.Exception = _threadException.SourceException;
@@ -1160,30 +1140,19 @@ public BuildResult Build(BuildParameters parameters, BuildRequestData requestDat
             return result;
         }
 
+        /// <summary>
+        /// Convenience method.  Submits a lone build request and blocks until results are available.
+        /// </summary>
+        /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
+        public BuildResult Build(BuildParameters parameters, BuildRequestData requestData)
+            => Build<BuildRequestData, BuildResult>(parameters, requestData);
+
         /// <summary>
         /// Convenience method.  Submits a lone graph build request and blocks until results are available.
         /// </summary>
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
         public GraphBuildResult Build(BuildParameters parameters, GraphBuildRequestData requestData)
-        {
-            GraphBuildResult result;
-            BeginBuild(parameters);
-            try
-            {
-                result = BuildRequest(requestData);
-                if (result.Exception == null && _threadException != null)
-                {
-                    result.Exception = _threadException.SourceException;
-                    _threadException = null;
-                }
-            }
-            finally
-            {
-                EndBuild();
-            }
-
-            return result;
-        }
+            => Build<GraphBuildRequestData, GraphBuildResult>(parameters, requestData);
 
         /// <summary>
         /// Shuts down all idle MSBuild nodes on the machine
@@ -1215,7 +1184,7 @@ public void Dispose()
         /// <param name="packet">The packet.</param>
         void INodePacketHandler.PacketReceived(int node, INodePacket packet)
         {
-            _workQueue.Post(() => ProcessPacket(node, packet));
+            _workQueue!.Post(() => ProcessPacket(node, packet));
         }
 
         #endregion
@@ -1247,6 +1216,11 @@ IBuildComponent IBuildComponentHost.GetComponent(BuildComponentType type)
             return _componentFactories.GetComponent(type);
         }
 
+        TComponent IBuildComponentHost.GetComponent<TComponent>(BuildComponentType type)
+        {
+            return _componentFactories.GetComponent<TComponent>(type);
+        }
+
         #endregion
 
         /// <summary>
@@ -1254,38 +1228,40 @@ IBuildComponent IBuildComponentHost.GetComponent(BuildComponentType type)
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Standard ExpectedException pattern used")]
         [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Complex class might need refactoring to separate scheduling elements from submission elements.")]
-        internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThreadBuild)
+        private void ExecuteSubmission(BuildSubmission submission, bool allowMainThreadBuild)
         {
             ErrorUtilities.VerifyThrowArgumentNull(submission, nameof(submission));
             ErrorUtilities.VerifyThrow(!submission.IsCompleted, "Submission already complete.");
 
-            BuildRequestConfiguration resolvedConfiguration = null;
+            BuildRequestConfiguration? resolvedConfiguration = null;
             bool shuttingDown = false;
 
             try
             {
                 lock (_syncLock)
                 {
-                    ProjectInstance projectInstance = submission.BuildRequestData.ProjectInstance;
+                    submission.IsStarted = true;
+
+                    ProjectInstance? projectInstance = submission.BuildRequestData.ProjectInstance;
                     if (projectInstance != null)
                     {
                         if (_acquiredProjectRootElementCacheFromProjectInstance)
                         {
                             ErrorUtilities.VerifyThrowArgument(
-                                _buildParameters.ProjectRootElementCache == projectInstance.ProjectRootElementCache,
+                                _buildParameters!.ProjectRootElementCache == projectInstance.ProjectRootElementCache,
                                 "OM_BuildSubmissionsMultipleProjectCollections");
                         }
                         else
                         {
-                            _buildParameters.ProjectRootElementCache = projectInstance.ProjectRootElementCache;
+                            _buildParameters!.ProjectRootElementCache = projectInstance.ProjectRootElementCache;
                             _acquiredProjectRootElementCacheFromProjectInstance = true;
                         }
                     }
-                    else if (_buildParameters.ProjectRootElementCache == null)
+                    else if (_buildParameters!.ProjectRootElementCache == null)
                     {
                         // Create our own cache; if we subsequently get a build submission with a project instance attached,
                         // we'll dump our cache and use that one.
-                        _buildParameters.ProjectRootElementCache =
+                        _buildParameters!.ProjectRootElementCache =
                             new ProjectRootElementCache(false /* do not automatically reload from disk */);
                     }
 
@@ -1300,20 +1276,20 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
 
                         // If we have already named this instance when it was submitted previously during this build, use the same
                         // name so that we get the same configuration (and thus don't cause it to rebuild.)
-                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance, out var tempName))
+                        if (!_unnamedProjectInstanceToNames.TryGetValue(submission.BuildRequestData.ProjectInstance!, out var tempName))
                         {
                             tempName = "Unnamed_" + _nextUnnamedProjectId++;
-                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance] = tempName;
+                            _unnamedProjectInstanceToNames[submission.BuildRequestData.ProjectInstance!] = tempName;
                         }
 
                         submission.BuildRequestData.ProjectFullPath = Path.Combine(
-                            submission.BuildRequestData.ProjectInstance.GetProperty(ReservedPropertyNames.projectDirectory).EvaluatedValue,
+                            submission.BuildRequestData.ProjectInstance!.GetProperty(ReservedPropertyNames.projectDirectory)!.EvaluatedValue,
                             tempName);
                     }
 
                     // Create/Retrieve a configuration for each request
                     var buildRequestConfiguration = new BuildRequestConfiguration(submission.BuildRequestData, _buildParameters.DefaultToolsVersion);
-                    var matchingConfiguration = _configCache.GetMatchingConfiguration(buildRequestConfiguration);
+                    var matchingConfiguration = _configCache!.GetMatchingConfiguration(buildRequestConfiguration);
                     resolvedConfiguration = ResolveConfiguration(
                         buildRequestConfiguration,
                         matchingConfiguration,
@@ -1332,14 +1308,14 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                             // Only initialize once as it should be the same for all projects.
                             _hasProjectCacheServiceInitializedVsScenario = true;
 
-                            _projectCacheService.InitializePluginsForVsScenario(
+                            _projectCacheService!.InitializePluginsForVsScenario(
                                 ProjectCacheDescriptors.Values,
                                 resolvedConfiguration,
                                 submission.BuildRequestData.TargetNames,
-                                _executionCancellationTokenSource.Token);
+                                _executionCancellationTokenSource!.Token);
                         }
 
-                        if (_projectCacheService.ShouldUseCache(resolvedConfiguration))
+                        if (_projectCacheService!.ShouldUseCache(resolvedConfiguration))
                         {
                             IssueCacheRequestForBuildSubmission(new CacheRequest(submission, resolvedConfiguration));
                         }
@@ -1370,7 +1346,7 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
             {
                 ErrorUtilities.VerifyThrow(resolvedConfiguration is not null, "Cannot call project cache without having BuildRequestConfiguration");
                 // We were already canceled!
-                CompleteSubmissionWithException(submission, resolvedConfiguration, new BuildAbortedException());
+                CompleteSubmissionWithException(submission, resolvedConfiguration!, new BuildAbortedException());
             }
         }
 
@@ -1381,11 +1357,11 @@ private void IssueCacheRequestForBuildSubmission(CacheRequest cacheRequest)
         {
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
-            _workQueue.Post(() =>
+            _workQueue!.Post(() =>
             {
                 try
                 {
-                    _projectCacheService.PostCacheRequest(cacheRequest, _executionCancellationTokenSource.Token);
+                    _projectCacheService!.PostCacheRequest(cacheRequest, _executionCancellationTokenSource!.Token);
                 }
                 catch (Exception e)
                 {
@@ -1394,16 +1370,50 @@ private void IssueCacheRequestForBuildSubmission(CacheRequest cacheRequest)
             });
         }
 
+        internal void ExecuteSubmission<TRequestData, TResultData>(
+            BuildSubmissionBase<TRequestData, TResultData> submission, bool allowMainThreadBuild)
+            where TRequestData : BuildRequestDataBase
+            where TResultData : BuildResultBase
+        {
+            // For the current submission we only know the SubmissionId and that it happened on scheduler node - all other BuildEventContext dimensions are unknown now.
+            BuildEventContext buildEventContext = new BuildEventContext(
+                submission.SubmissionId,
+                nodeId: 1,
+                BuildEventContext.InvalidProjectInstanceId,
+                BuildEventContext.InvalidProjectContextId,
+                BuildEventContext.InvalidTargetId,
+                BuildEventContext.InvalidTaskId);
+
+            BuildSubmissionStartedEventArgs submissionStartedEvent = new(
+                submission.BuildRequestDataBase.GlobalPropertiesLookup,
+                submission.BuildRequestDataBase.EntryProjectsFullPath,
+                submission.BuildRequestDataBase.TargetNames,
+                submission.BuildRequestDataBase.Flags,
+                submission.SubmissionId);
+            submissionStartedEvent.BuildEventContext = buildEventContext;
+
+            ((IBuildComponentHost)this).LoggingService.LogBuildEvent(submissionStartedEvent);
+
+            if (submission is BuildSubmission buildSubmission)
+            {
+                ExecuteSubmission(buildSubmission, allowMainThreadBuild);
+            }
+            else if (submission is GraphBuildSubmission graphBuildSubmission)
+            {
+                ExecuteSubmission(graphBuildSubmission);
+            }
+        }
+
         /// <summary>
         /// This method adds the graph build request in the specified submission to the set of requests being handled by the scheduler.
         /// </summary>
-        internal void ExecuteSubmission(GraphBuildSubmission submission)
+        private void ExecuteSubmission(GraphBuildSubmission submission)
         {
-            lock (_syncLock)
-            {
-                VerifyStateInternal(BuildManagerState.Building);
+            VerifyStateInternal(BuildManagerState.Building);
 
-                try
+            try
+            {
+                lock (_syncLock)
                 {
                     submission.IsStarted = true;
 
@@ -1429,15 +1439,16 @@ internal void ExecuteSubmission(GraphBuildSubmission submission)
                                 HandleSubmissionException(submission, ex);
                             }
                         },
-                        _executionCancellationTokenSource.Token,
+                        _executionCancellationTokenSource!.Token,
                         TaskCreationOptions.LongRunning,
                         TaskScheduler.Default);
                 }
-                catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
-                {
-                    HandleSubmissionException(submission, ex);
-                    throw;
-                }
+            }
+            // The handling of submission exception needs to be done outside of the lock
+            catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+            {
+                HandleSubmissionException(submission, ex);
+                throw;
             }
         }
 
@@ -1487,7 +1498,7 @@ private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bui
                     GetNewConfigurationId(),
                     instances[i])
                 { ExplicitlyLoaded = config.ExplicitlyLoaded };
-                if (_configCache.GetMatchingConfiguration(newConfig) == null)
+                if (_configCache!.GetMatchingConfiguration(newConfig) == null)
                 {
                     _configCache.AddConfiguration(newConfig);
                 }
@@ -1505,7 +1516,7 @@ private static int GetNextBuildId()
         /// <summary>
         /// Creates and optionally populates a new configuration.
         /// </summary>
-        private BuildRequestConfiguration CreateConfiguration(Project project, BuildRequestConfiguration existingConfiguration)
+        private BuildRequestConfiguration CreateConfiguration(Project project, BuildRequestConfiguration? existingConfiguration)
         {
             ProjectInstance newInstance = project.CreateProjectInstance();
 
@@ -1534,7 +1545,7 @@ private void ProcessWorkQueue(Action action)
 
                 try
                 {
-                    if (!Equals(CultureInfo.CurrentCulture, _buildParameters.Culture))
+                    if (!Equals(CultureInfo.CurrentCulture, _buildParameters!.Culture))
                     {
                         CultureInfo.CurrentCulture = _buildParameters.Culture;
                     }
@@ -1656,73 +1667,10 @@ private void CompleteSubmissionWithException(BuildSubmission submission, BuildRe
         /// <remarks>
         /// To avoid deadlock possibility, this method MUST NOT be called inside of 'lock (_syncLock)'
         /// </remarks>
-        private void HandleSubmissionException(BuildSubmission submission, Exception ex)
+        private void HandleSubmissionException(BuildSubmissionBase submission, Exception ex)
         {
             Debug.Assert(!Monitor.IsEntered(_syncLock));
 
-            if (ex is AggregateException ae && ae.InnerExceptions.Count == 1)
-            {
-                ex = ae.InnerExceptions.First();
-            }
-            if (ex is InvalidProjectFileException projectException)
-            {
-                if (!projectException.HasBeenLogged)
-                {
-                    BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                    ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
-                    projectException.HasBeenLogged = true;
-                }
-            }
-
-            bool submissionNeedsCompletion;
-            lock (_syncLock)
-            {
-                // BuildRequest may be null if the submission fails early on.
-                submissionNeedsCompletion = submission.BuildRequest != null;
-                if (submissionNeedsCompletion)
-                {
-                    var result = new BuildResult(submission.BuildRequest, ex);
-                    submission.CompleteResults(result);
-                }
-            }
-
-            if (submissionNeedsCompletion)
-            {
-                WaitForAllLoggingServiceEventsToBeProcessed();
-            }
-
-            lock (_syncLock)
-            {
-                if (submissionNeedsCompletion)
-                {
-                    submission.CompleteLogging();
-                }
-
-                _overallBuildSuccess = false;
-                CheckSubmissionCompletenessAndRemove(submission);
-            }
-        }
-
-        /// <summary>
-        /// Waits to drain all events of logging service.
-        /// This method shall be used carefully because during draining, LoggingService will block all incoming events.
-        /// </summary>
-        /// <remarks>
-        /// To avoid deadlock possibility, this method MUST NOT be called inside of 'lock (_syncLock)'
-        /// </remarks>
-        private void WaitForAllLoggingServiceEventsToBeProcessed()
-        {
-            // this has to be called out of the lock (_syncLock)
-            // because processing events can callback to 'this' instance and cause deadlock
-            Debug.Assert(!Monitor.IsEntered(_syncLock));
-            ((LoggingService)((IBuildComponentHost)this).LoggingService).WaitForLoggingToProcessEvents();
-        }
-
-        /// <summary>
-        /// Deals with exceptions that may be thrown as a result of ExecuteSubmission.
-        /// </summary>
-        private void HandleSubmissionException(GraphBuildSubmission submission, Exception ex)
-        {
             if (ex is AggregateException ae)
             {
                 // If there's exactly 1, just flatten it
@@ -1732,7 +1680,7 @@ private void HandleSubmissionException(GraphBuildSubmission submission, Exceptio
                 }
                 else
                 {
-                    // Log each InvalidProjectFileException encountered during ProjectGraph creation
+                    // Log each InvalidProjectFileException encountered
                     foreach (Exception innerException in ae.InnerExceptions)
                     {
                         if (innerException is InvalidProjectFileException innerProjectException)
@@ -1753,11 +1701,27 @@ private void HandleSubmissionException(GraphBuildSubmission submission, Exceptio
                 LogInvalidProjectFileError(new InvalidProjectFileException(ex.Message, ex));
             }
 
+            bool submissionNeedsCompletion;
             lock (_syncLock)
             {
-                if (submission.IsStarted)
+                // BuildRequest may be null if the submission fails early on.
+                submissionNeedsCompletion = submission.IsStarted;
+                if (submissionNeedsCompletion)
                 {
-                    submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, ex));
+                    submission.CompleteResultsWithException(ex);
+                }
+            }
+
+            if (submissionNeedsCompletion)
+            {
+                WaitForAllLoggingServiceEventsToBeProcessed();
+            }
+
+            lock (_syncLock)
+            {
+                if (submissionNeedsCompletion)
+                {
+                    submission.CompleteLogging();
                 }
 
                 _overallBuildSuccess = false;
@@ -1775,6 +1739,21 @@ void LogInvalidProjectFileError(InvalidProjectFileException projectException)
             }
         }
 
+        /// <summary>
+        /// Waits to drain all events of logging service.
+        /// This method shall be used carefully because during draining, LoggingService will block all incoming events.
+        /// </summary>
+        /// <remarks>
+        /// To avoid deadlock possibility, this method MUST NOT be called inside of 'lock (_syncLock)'
+        /// </remarks>
+        private void WaitForAllLoggingServiceEventsToBeProcessed()
+        {
+            // this has to be called out of the lock (_syncLock)
+            // because processing events can callback to 'this' instance and cause deadlock
+            Debug.Assert(!Monitor.IsEntered(_syncLock));
+            ((LoggingService)((IBuildComponentHost)this).LoggingService).WaitForLoggingToProcessEvents();
+        }
+
         private static void AddBuildRequestToSubmission(BuildSubmission submission, int configurationId, int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
             submission.BuildRequest = new BuildRequest(
@@ -1813,7 +1792,7 @@ private static void AddProxyBuildRequestToSubmission(
         /// </summary>
         private void IssueBuildRequestForBuildSubmission(BuildSubmission submission, BuildRequestConfiguration configuration, bool allowMainThreadBuild = false)
         {
-            _workQueue.Post(
+            _workQueue!.Post(
                 () =>
                 {
                     try
@@ -1842,7 +1821,7 @@ void IssueBuildSubmissionToSchedulerImpl(BuildSubmission submission, bool allowM
                             throw new BuildAbortedException();
                         }
 
-                        if (allowMainThreadBuild && _buildParameters.LegacyThreadingSemantics)
+                        if (allowMainThreadBuild && _buildParameters!.LegacyThreadingSemantics)
                         {
                             if (_legacyThreadingData.MainThreadSubmissionId == -1)
                             {
@@ -1888,7 +1867,7 @@ void IssueBuildSubmissionToSchedulerImpl(BuildSubmission submission, bool allowM
                     lock (_syncLock)
                     {
                         submission.CompleteLogging();
-                        ReportResultsToSubmission(new BuildResult(submission.BuildRequest, ex));
+                        ReportResultsToSubmission<BuildRequestData, BuildResult>(new BuildResult(submission.BuildRequest!, ex));
                         _overallBuildSuccess = false;
                     }
                 }
@@ -1915,7 +1894,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     ProjectCollection.GlobalProjectCollection,
                     (path, properties, collection) =>
                     {
-                        ProjectLoadSettings projectLoadSettings = _buildParameters.ProjectLoadSettings;
+                        ProjectLoadSettings projectLoadSettings = _buildParameters!.ProjectLoadSettings;
                         if (submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports))
                         {
                             projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
@@ -1953,11 +1932,11 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     projectGraph.ConstructionMetrics.NodeCount,
                     projectGraph.ConstructionMetrics.EdgeCount));
 
-            Dictionary<ProjectGraphNode, BuildResult> resultsPerNode = null;
+            Dictionary<ProjectGraphNode, BuildResult>? resultsPerNode = null;
 
             if (submission.BuildRequestData.GraphBuildOptions.Build)
             {
-                _projectCacheService.InitializePluginsForGraph(projectGraph, submission.BuildRequestData.TargetNames, _executionCancellationTokenSource.Token);
+                _projectCacheService!.InitializePluginsForGraph(projectGraph, submission.BuildRequestData.TargetNames, _executionCancellationTokenSource!.Token);
 
                 IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
@@ -1983,12 +1962,12 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                 "Exceptions only get set when the graph submission gets completed with an exception in OnThreadException. That should not happen during graph builds.");
 
             // The overall submission is complete, so report it as complete
-            ReportResultsToSubmission(
+            ReportResultsToSubmission<GraphBuildRequestData, GraphBuildResult>(
                 new GraphBuildResult(
                     submission.SubmissionId,
                     new ReadOnlyDictionary<ProjectGraphNode, BuildResult>(resultsPerNode ?? new Dictionary<ProjectGraphNode, BuildResult>())));
 
-            static void DumpGraph(ProjectGraph graph, IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetList = null)
+            static void DumpGraph(ProjectGraph graph, IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>>? targetList = null)
             {
                 if (Traits.Instance.DebugEngine is false)
                 {
@@ -2011,9 +1990,9 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
 
             var blockedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes);
             var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);
-            var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();
+            var buildingNodes = new Dictionary<BuildSubmissionBase, ProjectGraphNode>();
             var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);
-            ExceptionDispatchInfo submissionException = null;
+            ExceptionDispatchInfo? submissionException = null;
 
             while (blockedNodes.Count > 0 || buildingNodes.Count > 0)
             {
@@ -2062,7 +2041,7 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
                         {
                             lock (graphBuildStateLock)
                             {
-                                if (submissionException == null && finishedBuildSubmission.BuildResult.Exception != null)
+                                if (submissionException == null && finishedBuildSubmission.BuildResult?.Exception != null)
                                 {
                                     // Preserve the original stack.
                                     submissionException = ExceptionDispatchInfo.Capture(finishedBuildSubmission.BuildResult.Exception);
@@ -2073,7 +2052,7 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
                                 finishedNodes.Add(finishedNode);
                                 buildingNodes.Remove(finishedBuildSubmission);
 
-                                resultsPerNode.Add(finishedNode, finishedBuildSubmission.BuildResult);
+                                resultsPerNode.Add(finishedNode, finishedBuildSubmission.BuildResult!);
                             }
 
                             waitHandle.Set();
@@ -2094,17 +2073,17 @@ private void ShutdownConnectedNodes(bool abort)
             lock (_syncLock)
             {
                 _shuttingDown = true;
-                _executionCancellationTokenSource.Cancel();
+                _executionCancellationTokenSource!.Cancel();
 
                 // If we are aborting, we will NOT reuse the nodes because their state may be compromised by attempts to shut down while the build is in-progress.
-                _nodeManager.ShutdownConnectedNodes(!abort && _buildParameters.EnableNodeReuse);
+                _nodeManager!.ShutdownConnectedNodes(!abort && _buildParameters!.EnableNodeReuse);
 
                 // if we are aborting, the task host will hear about it in time through the task building infrastructure;
                 // so only shut down the task host nodes if we're shutting down tidily (in which case, it is assumed that all
                 // tasks are finished building and thus that there's no risk of a race between the two shutdown pathways).
                 if (!abort)
                 {
-                    _taskHostNodeManager.ShutdownConnectedNodes(_buildParameters.EnableNodeReuse);
+                    _taskHostNodeManager!.ShutdownConnectedNodes(_buildParameters!.EnableNodeReuse);
                 }
             }
         }
@@ -2152,23 +2131,22 @@ private void VerifyStateInternal(BuildManagerState requiredState)
         /// </summary>
         private void Reset()
         {
-            _nodeManager.UnregisterPacketHandler(NodePacketType.BuildRequestBlocker);
-            _nodeManager.UnregisterPacketHandler(NodePacketType.BuildRequestConfiguration);
-            _nodeManager.UnregisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse);
-            _nodeManager.UnregisterPacketHandler(NodePacketType.BuildResult);
-            _nodeManager.UnregisterPacketHandler(NodePacketType.NodeShutdown);
+            _nodeManager?.UnregisterPacketHandler(NodePacketType.BuildRequestBlocker);
+            _nodeManager?.UnregisterPacketHandler(NodePacketType.BuildRequestConfiguration);
+            _nodeManager?.UnregisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse);
+            _nodeManager?.UnregisterPacketHandler(NodePacketType.BuildResult);
+            _nodeManager?.UnregisterPacketHandler(NodePacketType.NodeShutdown);
 
-            _nodeManager.ClearPerBuildState();
+            _nodeManager?.ClearPerBuildState();
             _nodeManager = null;
 
             _shuttingDown = false;
-            _executionCancellationTokenSource.Dispose();
+            _executionCancellationTokenSource?.Dispose();
             _executionCancellationTokenSource = null;
             _nodeConfiguration = null;
             _buildSubmissions.Clear();
-            _graphBuildSubmissions.Clear();
 
-            _scheduler.Reset();
+            _scheduler?.Reset();
             _scheduler = null;
             _workQueue = null;
             _projectCacheService = null;
@@ -2193,7 +2171,7 @@ private void Reset()
                 // Optionally clear out the cache. This has the advantage of releasing memory,
                 // but the disadvantage of causing the next build to repeat the load and parse.
                 // We'll experiment here and ship with the best default.
-                _buildParameters.ProjectRootElementCache.Clear();
+                _buildParameters?.ProjectRootElementCache.Clear();
             }
         }
 
@@ -2219,11 +2197,11 @@ private int GetNewConfigurationId()
         /// <summary>
         /// Finds a matching configuration in the cache and returns it, or stores the configuration passed in.
         /// </summary>
-        private BuildRequestConfiguration ResolveConfiguration(BuildRequestConfiguration unresolvedConfiguration, BuildRequestConfiguration matchingConfigurationFromCache, bool replaceProjectInstance)
+        private BuildRequestConfiguration ResolveConfiguration(BuildRequestConfiguration unresolvedConfiguration, BuildRequestConfiguration? matchingConfigurationFromCache, bool replaceProjectInstance)
         {
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
-            BuildRequestConfiguration resolvedConfiguration = matchingConfigurationFromCache ?? _configCache.GetMatchingConfiguration(unresolvedConfiguration);
+            BuildRequestConfiguration resolvedConfiguration = matchingConfigurationFromCache ?? _configCache!.GetMatchingConfiguration(unresolvedConfiguration);
             if (resolvedConfiguration == null)
             {
                 resolvedConfiguration = AddNewConfiguration(unresolvedConfiguration);
@@ -2257,16 +2235,16 @@ private void ReplaceExistingProjectInstance(BuildRequestConfiguration newConfigu
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
             existingConfiguration.Project = newConfiguration.Project;
-            _resultsCache.ClearResultsForConfiguration(existingConfiguration.ConfigurationId);
+            _resultsCache!.ClearResultsForConfiguration(existingConfiguration.ConfigurationId);
         }
 
         private BuildRequestConfiguration AddNewConfiguration(BuildRequestConfiguration unresolvedConfiguration)
         {
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
-            var newConfigurationId = _scheduler.GetConfigurationIdFromPlan(unresolvedConfiguration.ProjectFullPath);
+            var newConfigurationId = _scheduler!.GetConfigurationIdFromPlan(unresolvedConfiguration.ProjectFullPath);
 
-            if (_configCache.HasConfiguration(newConfigurationId) || (newConfigurationId == BuildRequestConfiguration.InvalidConfigurationId))
+            if (_configCache!.HasConfiguration(newConfigurationId) || (newConfigurationId == BuildRequestConfiguration.InvalidConfigurationId))
             {
                 // There is already a configuration like this one or one didn't exist in a plan, so generate a new ID.
                 newConfigurationId = GetNewConfigurationId();
@@ -2281,7 +2259,7 @@ private BuildRequestConfiguration AddNewConfiguration(BuildRequestConfiguration
 
         internal void PostCacheResult(CacheRequest cacheRequest, CacheResult cacheResult, int projectContextId)
         {
-            _workQueue.Post(() =>
+            _workQueue!.Post(() =>
             {
                 if (cacheResult.Exception is not null)
                 {
@@ -2320,16 +2298,16 @@ void HandleCacheResult()
 
                             // There must be a build request for the results, so fake one.
                             AddBuildRequestToSubmission(submission, configuration.ConfigurationId, projectContextId);
-                            var result = new BuildResult(submission.BuildRequest);
+                            var result = new BuildResult(submission.BuildRequest!);
 
-                            foreach (var cacheResult in cacheResult.BuildResult.ResultsByTarget)
+                            foreach (var cacheResultInner in cacheResult.BuildResult?.ResultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
                             {
-                                result.AddResultsForTarget(cacheResult.Key, cacheResult.Value);
+                                result.AddResultsForTarget(cacheResultInner.Key, cacheResultInner.Value);
                             }
 
-                            _resultsCache.AddResult(result);
+                            _resultsCache!.AddResult(result);
                             submission.CompleteLogging();
-                            ReportResultsToSubmission(result);
+                            ReportResultsToSubmission<BuildRequestData, BuildResult>(result);
                         }
                     }
                     catch (Exception e)
@@ -2350,7 +2328,7 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)
             {
                 foreach (BuildRequest request in blocker.BuildRequests)
                 {
-                    BuildRequestConfiguration config = _configCache[request.ConfigurationId];
+                    BuildRequestConfiguration config = _configCache![request.ConfigurationId];
                     if (FileUtilities.IsSolutionFilename(config.ProjectFullPath))
                     {
                         try
@@ -2360,7 +2338,7 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)
                         catch (InvalidProjectFileException e)
                         {
                             // Throw the error in the cache.  The Scheduler will pick it up and return the results correctly.
-                            _resultsCache.AddResult(new BuildResult(request, e));
+                            _resultsCache!.AddResult(new BuildResult(request, e));
                             if (node == Scheduler.VirtualNode)
                             {
                                 throw;
@@ -2370,7 +2348,7 @@ private void HandleNewRequest(int node, BuildRequestBlocker blocker)
                 }
             }
 
-            IEnumerable<ScheduleResponse> response = _scheduler.ReportRequestBlocked(node, blocker);
+            IEnumerable<ScheduleResponse> response = _scheduler!.ReportRequestBlocked(node, blocker);
             PerformSchedulingActions(response);
         }
 
@@ -2385,17 +2363,17 @@ private void HandleResourceRequest(int node, ResourceRequest request)
             {
                 // Resource request requires a response and may be blocking. Our continuation is effectively a callback
                 // to be called once at least one core becomes available.
-                _scheduler.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((Task<int> task) =>
+                _scheduler!.RequestCores(request.GlobalRequestId, request.NumCores, request.IsBlocking).ContinueWith((Task<int> task) =>
                 {
                     var response = new ResourceResponse(request.GlobalRequestId, task.Result);
-                    _nodeManager.SendData(node, response);
+                    _nodeManager!.SendData(node, response);
                 }, TaskContinuationOptions.ExecuteSynchronously);
             }
             else
             {
                 // Resource release is a one-way call, no response is expected. We release the cores as instructed
                 // and kick the scheduler because there may be work waiting for cores to become available.
-                IEnumerable<ScheduleResponse> response = _scheduler.ReleaseCores(request.GlobalRequestId, request.NumCores);
+                IEnumerable<ScheduleResponse> response = _scheduler!.ReleaseCores(request.GlobalRequestId, request.NumCores);
                 PerformSchedulingActions(response);
             }
         }
@@ -2411,7 +2389,7 @@ private void HandleConfigurationRequest(int node, BuildRequestConfiguration unre
 
             var response = new BuildRequestConfigurationResponse(unresolvedConfiguration.ConfigurationId, resolvedConfiguration.ConfigurationId, resolvedConfiguration.ResultsNodeId);
 
-            if (!_nodeIdToKnownConfigurations.TryGetValue(node, out HashSet<int> configurationsOnNode))
+            if (!_nodeIdToKnownConfigurations.TryGetValue(node, out HashSet<int>? configurationsOnNode))
             {
                 configurationsOnNode = new HashSet<int>();
                 _nodeIdToKnownConfigurations[node] = configurationsOnNode;
@@ -2419,7 +2397,7 @@ private void HandleConfigurationRequest(int node, BuildRequestConfiguration unre
 
             configurationsOnNode.Add(resolvedConfiguration.ConfigurationId);
 
-            _nodeManager.SendData(node, response);
+            _nodeManager!.SendData(node, response);
         }
 
         /// <summary>
@@ -2428,7 +2406,7 @@ private void HandleConfigurationRequest(int node, BuildRequestConfiguration unre
         private void HandleResult(int node, BuildResult result)
         {
             // Update cache with the default, initial, and project targets, as needed.
-            BuildRequestConfiguration configuration = _configCache[result.ConfigurationId];
+            BuildRequestConfiguration configuration = _configCache![result.ConfigurationId];
             if (result.DefaultTargets != null)
             {
                 // If the result has Default, Initial, and project targets, we populate the configuration cache with them if it
@@ -2445,7 +2423,7 @@ private void HandleResult(int node, BuildResult result)
             // handled here. This intentionally mirrors the behavior for cache requests, as it doesn't make sense to
             // report for projects which aren't going to be requested. Ideally, *any* request could be handled, but that
             // would require moving the cache service interactions to the Scheduler.
-            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission buildSubmission))
+            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmissionBase? buildSubmissionBase) && buildSubmissionBase is BuildSubmission buildSubmission)
             {
                 // The result may be associated with the build submission due to it being the submission which
                 // caused the build, but not the actual request which was originally used with the build submission.
@@ -2453,14 +2431,14 @@ private void HandleResult(int node, BuildResult result)
                 // isn't what we're looking for. Ensure only the actual submission's request is considered.
                 if (buildSubmission.BuildRequest != null
                     && buildSubmission.BuildRequest.ConfigurationId == configuration.ConfigurationId
-                    && _projectCacheService.ShouldUseCache(configuration))
+                    && _projectCacheService!.ShouldUseCache(configuration))
                 {
-                    BuildEventContext buildEventContext = _projectStartedEvents.TryGetValue(result.SubmissionId, out BuildEventArgs buildEventArgs)
-                        ? buildEventArgs.BuildEventContext
+                    BuildEventContext buildEventContext = _projectStartedEvents.TryGetValue(result.SubmissionId, out BuildEventArgs? buildEventArgs)
+                        ? buildEventArgs.BuildEventContext!
                         : new BuildEventContext(result.SubmissionId, node, configuration.Project?.EvaluationId ?? BuildEventContext.InvalidEvaluationId, configuration.ConfigurationId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                     try
                     {
-                        _projectCacheService.HandleBuildResultAsync(configuration, result, buildEventContext, _executionCancellationTokenSource.Token).Wait();
+                        _projectCacheService.HandleBuildResultAsync(configuration, result, buildEventContext, _executionCancellationTokenSource!.Token).Wait();
                     }
                     catch (AggregateException ex) when (ex.InnerExceptions.All(inner => inner is OperationCanceledException))
                     {
@@ -2473,7 +2451,7 @@ private void HandleResult(int node, BuildResult result)
                 }
             }
 
-            IEnumerable<ScheduleResponse> response = _scheduler.ReportResult(node, result);
+            IEnumerable<ScheduleResponse> response = _scheduler!.ReportResult(node, result);
             PerformSchedulingActions(response);
         }
 
@@ -2485,7 +2463,7 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
             _shuttingDown = true;
-            _executionCancellationTokenSource.Cancel();
+            _executionCancellationTokenSource?.Cancel();
             ErrorUtilities.VerifyThrow(_activeNodes.Contains(node), "Unexpected shutdown from node {0} which shouldn't exist.", node);
             _activeNodes.Remove(node);
 
@@ -2493,47 +2471,44 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
             {
                 if (shutdownPacket.Reason == NodeShutdownReason.ConnectionFailed)
                 {
-                    ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent(BuildComponentType.LoggingService) as ILoggingService;
-                    foreach (BuildSubmission submission in _buildSubmissions.Values)
+                    ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent<ILoggingService>(BuildComponentType.LoggingService);
+                    foreach (BuildSubmissionBase submission in _buildSubmissions.Values)
                     {
                         BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, BuildEventContext.InvalidNodeId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                         string exception = ExceptionHandling.ReadAnyExceptionFromFile(_instantiationTimeUtc);
-                        loggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, exception);
-                    }
-
-                    foreach (GraphBuildSubmission submission in _graphBuildSubmissions.Values)
-                    {
-                        BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, BuildEventContext.InvalidNodeId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                        string exception = ExceptionHandling.ReadAnyExceptionFromFile(_instantiationTimeUtc);
-                        loggingService.LogError(buildEventContext, new BuildEventFileInfo(String.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, exception);
+                        loggingService?.LogError(buildEventContext, new BuildEventFileInfo(string.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, exception);
                     }
                 }
-                else if (shutdownPacket.Reason == NodeShutdownReason.Error && _buildSubmissions.Values.Count == 0 && _graphBuildSubmissions.Values.Count == 0)
+                else if (shutdownPacket.Reason == NodeShutdownReason.Error && _buildSubmissions.Values.Count == 0)
                 {
                     // We have no submissions to attach any exceptions to, lets just log it here.
                     if (shutdownPacket.Exception != null)
                     {
-                        ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent(BuildComponentType.LoggingService) as ILoggingService;
-                        loggingService.LogError(BuildEventContext.Invalid, new BuildEventFileInfo(String.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, shutdownPacket.Exception.ToString());
+                        ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent<ILoggingService>(BuildComponentType.LoggingService);
+                        loggingService?.LogError(BuildEventContext.Invalid, new BuildEventFileInfo(string.Empty) /* no project file */, "ChildExitedPrematurely", node, ExceptionHandling.DebugDumpPath, shutdownPacket.Exception.ToString());
                         OnThreadException(shutdownPacket.Exception);
                     }
                 }
 
-                _nodeManager.ShutdownConnectedNodes(_buildParameters.EnableNodeReuse);
-                _taskHostNodeManager.ShutdownConnectedNodes(_buildParameters.EnableNodeReuse);
+                _nodeManager!.ShutdownConnectedNodes(_buildParameters!.EnableNodeReuse);
+                _taskHostNodeManager!.ShutdownConnectedNodes(_buildParameters.EnableNodeReuse);
 
-                foreach (BuildSubmission submission in _buildSubmissions.Values)
+                foreach (BuildSubmissionBase submission in _buildSubmissions.Values)
                 {
                     // The submission has not started
-                    if (submission.BuildRequest == null)
+                    if (!submission.IsStarted)
                     {
                         continue;
                     }
 
-                    _resultsCache.AddResult(new BuildResult(submission.BuildRequest, shutdownPacket.Exception ?? new BuildAbortedException()));
+                    if (submission is BuildSubmission buildSubmission && buildSubmission.BuildRequest != null)
+                    {
+                        _resultsCache!.AddResult(new BuildResult(buildSubmission.BuildRequest,
+                            shutdownPacket.Exception ?? new BuildAbortedException()));
+                    }
                 }
 
-                _scheduler.ReportBuildAborted(node);
+                _scheduler!.ReportBuildAborted(node);
             }
 
             CheckForActiveNodesAndCleanUpSubmissions();
@@ -2547,7 +2522,7 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
         private void HandleFileAccessReport(int nodeId, FileAccessReport fileAccessReport)
         {
 #if FEATURE_REPORTFILEACCESSES
-            if (_buildParameters.ReportFileAccesses)
+            if (_buildParameters!.ReportFileAccesses)
             {
                 ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportFileAccess(fileAccessReport.FileAccessData, nodeId);
             }
@@ -2562,7 +2537,7 @@ private void HandleFileAccessReport(int nodeId, FileAccessReport fileAccessRepor
         private void HandleProcessReport(int nodeId, ProcessReport processReport)
         {
 #if FEATURE_REPORTFILEACCESSES
-            if (_buildParameters.ReportFileAccesses)
+            if (_buildParameters!.ReportFileAccesses)
             {
                 ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportProcess(processReport.ProcessData, nodeId);
             }
@@ -2581,22 +2556,19 @@ private void CheckForActiveNodesAndCleanUpSubmissions()
 
             if (_activeNodes.Count == 0)
             {
-                var submissions = new List<BuildSubmission>(_buildSubmissions.Values);
-                foreach (BuildSubmission submission in submissions)
+                var submissions = new List<BuildSubmissionBase>(_buildSubmissions.Values);
+                foreach (BuildSubmissionBase submission in submissions)
                 {
                     // The submission has not started do not add it to the results cache
-                    if (submission.BuildRequest == null)
+                    if (!submission.IsStarted)
                     {
                         continue;
                     }
 
-                    // UNDONE: (stability) It might be best to trigger the logging service to shut down here,
-                    //         since the full build is complete.  This would allow us to ensure all logging messages have been
-                    //         drained and all submissions can complete their logging requirements.
-                    BuildResult result = _resultsCache.GetResultsForConfiguration(submission.BuildRequest.ConfigurationId) ??
-                                         new BuildResult(submission.BuildRequest, new BuildAbortedException());
-
-                    submission.CompleteResults(result);
+                    if (!CompleteSubmissionFromCache(submission))
+                    {
+                        submission.CompleteResultsWithException(new BuildAbortedException());
+                    }
 
                     // If we never received a project started event, consider logging complete anyhow, since the nodes have
                     // shut down.
@@ -2605,21 +2577,23 @@ private void CheckForActiveNodesAndCleanUpSubmissions()
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
 
-                var graphSubmissions = new List<GraphBuildSubmission>(_graphBuildSubmissions.Values);
-                foreach (GraphBuildSubmission submission in graphSubmissions)
-                {
-                    if (submission.IsStarted)
-                    {
-                        continue;
-                    }
-
-                    submission.CompleteResults(new GraphBuildResult(submission.SubmissionId, new BuildAbortedException()));
+                _noNodesActiveEvent?.Set();
+            }
+        }
 
-                    CheckSubmissionCompletenessAndRemove(submission);
+        private bool CompleteSubmissionFromCache(BuildSubmissionBase submissionBase)
+        {
+            if (submissionBase is BuildSubmission submission)
+            {
+                BuildResult? result = submission.BuildRequest == null ? null : _resultsCache?.GetResultsForConfiguration(submission.BuildRequest.ConfigurationId);
+                if (result != null)
+                {
+                    submission.CompleteResults(result);
+                    return true;
                 }
-
-                _noNodesActiveEvent.Set();
             }
+
+            return false;
         }
 
         /// <summary>
@@ -2637,22 +2611,22 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                         break;
 
                     case ScheduleActionType.SubmissionComplete:
-                        if (_buildParameters.DetailedSummary)
+                        if (_buildParameters!.DetailedSummary)
                         {
-                            _scheduler.WriteDetailedSummary(response.BuildResult.SubmissionId);
+                            _scheduler!.WriteDetailedSummary(response.BuildResult.SubmissionId);
                         }
 
-                        ReportResultsToSubmission(response.BuildResult);
+                        ReportResultsToSubmission<BuildRequestData, BuildResult>(response.BuildResult);
                         break;
 
                     case ScheduleActionType.CircularDependency:
                     case ScheduleActionType.ResumeExecution:
                     case ScheduleActionType.ReportResults:
-                        _nodeManager.SendData(response.NodeId, response.Unblocker);
+                        _nodeManager!.SendData(response.NodeId, response.Unblocker);
                         break;
 
                     case ScheduleActionType.CreateNode:
-                        IList<NodeInfo> newNodes = _nodeManager.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);
+                        IList<NodeInfo> newNodes = _nodeManager!.CreateNodes(GetNodeConfiguration(), response.RequiredNodeType, response.NumberOfNodesToCreate);
 
                         if (newNodes?.Count != response.NumberOfNodesToCreate || newNodes.Any(n => n == null))
                         {
@@ -2664,11 +2638,11 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
 
                         foreach (var node in newNodes)
                         {
-                            _noNodesActiveEvent.Reset();
+                            _noNodesActiveEvent?.Reset();
                             _activeNodes.Add(node.NodeId);
                         }
 
-                        IEnumerable<ScheduleResponse> newResponses = _scheduler.ReportNodesCreated(newNodes);
+                        IEnumerable<ScheduleResponse> newResponses = _scheduler!.ReportNodesCreated(newNodes);
                         PerformSchedulingActions(newResponses);
 
                         break;
@@ -2681,15 +2655,15 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                             // of which nodes have had configurations specifically assigned to them for building.  However, a node may
                             // have created a configuration based on a build request it needs to wait on.  In this
                             // case we need not send the configuration since it will already have been mapped earlier.
-                            if (!_nodeIdToKnownConfigurations.TryGetValue(response.NodeId, out HashSet<int> configurationsOnNode) ||
+                            if (!_nodeIdToKnownConfigurations.TryGetValue(response.NodeId, out HashSet<int>? configurationsOnNode) ||
                                !configurationsOnNode.Contains(response.BuildRequest.ConfigurationId))
                             {
-                                IConfigCache configCache = _componentFactories.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
-                                _nodeManager.SendData(response.NodeId, configCache[response.BuildRequest.ConfigurationId]);
+                                IConfigCache configCache = _componentFactories.GetComponent<IConfigCache>(BuildComponentType.ConfigCache);
+                                _nodeManager!.SendData(response.NodeId, configCache[response.BuildRequest.ConfigurationId]);
                             }
                         }
 
-                        _nodeManager.SendData(response.NodeId, response.BuildRequest);
+                        _nodeManager!.SendData(response.NodeId, response.BuildRequest);
                         break;
 
                     default:
@@ -2699,15 +2673,15 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
             }
         }
 
-        /// <summary>
-        /// Completes a submission using the specified overall results.
-        /// </summary>
-        private void ReportResultsToSubmission(BuildResult result)
+        internal void ReportResultsToSubmission<TRequestData, TResultData>(TResultData result)
+            where TRequestData : BuildRequestDataBase
+            where TResultData : BuildResultBase
         {
             lock (_syncLock)
             {
                 // The build submission has not already been completed.
-                if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission submission))
+                if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmissionBase? submissionBase) &&
+                    submissionBase is BuildSubmissionBase<TRequestData, TResultData> submission)
                 {
                     /* If the request failed because we caught an exception from the loggers, we can assume we will receive no more logging messages for
                      * this submission, therefore set the logging as complete. InternalLoggerExceptions are unhandled exceptions from the logger. If the logger author does
@@ -2718,31 +2692,13 @@ private void ReportResultsToSubmission(BuildResult result)
                      *
                      * If any other exception happened and logging is not completed, then go ahead and complete it now since this is the last place to do it.
                      * Otherwise the submission would remain uncompleted, potentially causing hangs (EndBuild waiting on all BuildSubmissions, users waiting on BuildSubmission, or expecting a callback, etc)
-                    */
+                     */
                     if (!submission.LoggingCompleted && result.Exception != null)
                     {
                         submission.CompleteLogging();
                     }
 
                     submission.CompleteResults(result);
-
-                    CheckSubmissionCompletenessAndRemove(submission);
-                }
-            }
-        }
-
-        /// <summary>
-        /// Completes a submission using the specified overall results.
-        /// </summary>
-        private void ReportResultsToSubmission(GraphBuildResult result)
-        {
-            lock (_syncLock)
-            {
-                // The build submission has not already been completed.
-                if (_graphBuildSubmissions.TryGetValue(result.SubmissionId, out GraphBuildSubmission submission))
-                {
-                    submission.CompleteResults(result);
-
                     CheckSubmissionCompletenessAndRemove(submission);
                 }
             }
@@ -2751,42 +2707,21 @@ private void ReportResultsToSubmission(GraphBuildResult result)
         /// <summary>
         /// Determines if the submission is fully completed.
         /// </summary>
-        private void CheckSubmissionCompletenessAndRemove(BuildSubmission submission)
-        {
-            lock (_syncLock)
-            {
-                // If the submission has completed or never started, remove it.
-                if (submission.IsCompleted || submission.BuildRequest == null)
-                {
-                    _overallBuildSuccess &= (submission.BuildResult?.OverallResult == BuildResultCode.Success);
-                    _buildSubmissions.Remove(submission.SubmissionId);
-
-                    // Clear all cached SDKs for the submission
-                    SdkResolverService.ClearCache(submission.SubmissionId);
-                }
-
-                CheckAllSubmissionsComplete(submission.BuildRequestData?.Flags);
-            }
-        }
-
-        /// <summary>
-        /// Determines if the submission is fully completed.
-        /// </summary>
-        private void CheckSubmissionCompletenessAndRemove(GraphBuildSubmission submission)
+        private void CheckSubmissionCompletenessAndRemove(BuildSubmissionBase submission)
         {
             lock (_syncLock)
             {
                 // If the submission has completed or never started, remove it.
                 if (submission.IsCompleted || !submission.IsStarted)
                 {
-                    _overallBuildSuccess &= submission.BuildResult?.OverallResult == BuildResultCode.Success;
-                    _graphBuildSubmissions.Remove(submission.SubmissionId);
+                    _overallBuildSuccess &= (submission.BuildResultBase?.OverallResult == BuildResultCode.Success);
+                    _buildSubmissions.Remove(submission.SubmissionId);
 
                     // Clear all cached SDKs for the submission
                     SdkResolverService.ClearCache(submission.SubmissionId);
                 }
 
-                CheckAllSubmissionsComplete(submission.BuildRequestData?.Flags);
+                CheckAllSubmissionsComplete(submission.BuildRequestDataBase.Flags);
             }
         }
 
@@ -2794,7 +2729,7 @@ private void CheckAllSubmissionsComplete(BuildRequestDataFlags? flags)
         {
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
-            if (_buildSubmissions.Count == 0 && _graphBuildSubmissions.Count == 0)
+            if (_buildSubmissions.Count == 0)
             {
                 if (flags.HasValue && flags.Value.HasFlag(BuildRequestDataFlags.ClearCachesAfterBuild))
                 {
@@ -2809,7 +2744,7 @@ private void CheckAllSubmissionsComplete(BuildRequestDataFlags? flags)
 #endif
                 }
 
-                _noActiveSubmissionsEvent.Set();
+                _noActiveSubmissionsEvent?.Set();
             }
         }
 
@@ -2823,7 +2758,7 @@ private NodeConfiguration GetNodeConfiguration()
             if (_nodeConfiguration == null)
             {
                 // Get the remote loggers
-                ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent(BuildComponentType.LoggingService) as ILoggingService;
+                ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent<ILoggingService>(BuildComponentType.LoggingService);
                 var remoteLoggers = new List<LoggerDescription>(loggingService.LoggerDescriptions);
 
                 _nodeConfiguration = new NodeConfiguration(
@@ -2860,40 +2795,30 @@ private void OnThreadException(Exception e)
                     }
 
                     _threadException = ExceptionDispatchInfo.Capture(e);
-                    var submissions = new List<BuildSubmission>(_buildSubmissions.Values);
-                    foreach (BuildSubmission submission in submissions)
+                    var submissions = new List<BuildSubmissionBase>(_buildSubmissions.Values);
+                    foreach (BuildSubmissionBase submission in submissions)
                     {
                         // Submission has not started
-                        if (submission.BuildRequest == null)
+                        if (!submission.IsStarted)
                         {
                             continue;
                         }
 
                         // Attach the exception to this submission if it does not already have an exception associated with it
-                        if (!submission.IsCompleted && submission.BuildResult != null && submission.BuildResult.Exception == null)
+                        if (!submission.IsCompleted && submission.BuildResultBase != null && submission.BuildResultBase.Exception == null)
                         {
-                            submission.BuildResult.Exception = e;
+                            submission.BuildResultBase.Exception = e;
                         }
                         submission.CompleteLogging();
-                        submission.CompleteResults(new BuildResult(submission.BuildRequest, e));
-
-                        CheckSubmissionCompletenessAndRemove(submission);
-                    }
 
-                    var graphSubmissions = new List<GraphBuildSubmission>(_graphBuildSubmissions.Values);
-                    foreach (GraphBuildSubmission submission in graphSubmissions)
-                    {
-                        if (!submission.IsStarted)
+                        if (submission.BuildResultBase != null)
                         {
-                            continue;
+                            submission.CheckForCompletion();
                         }
-
-                        // Attach the exception to this submission if it does not already have an exception associated with it
-                        if (!submission.IsCompleted && submission.BuildResult != null && submission.BuildResult.Exception == null)
+                        else
                         {
-                            submission.BuildResult.Exception = e;
+                            submission.CompleteResultsWithException(e);
                         }
-                        submission.CompleteResults(submission.BuildResult ?? new GraphBuildResult(submission.SubmissionId, e));
 
                         CheckSubmissionCompletenessAndRemove(submission);
                     }
@@ -2906,7 +2831,7 @@ private void OnThreadException(Exception e)
         /// </summary>
         private void OnLoggingThreadException(Exception e)
         {
-            _workQueue.Post(() => OnThreadException(e));
+            _workQueue!.Post(() => OnThreadException(e));
         }
 
         /// <summary>
@@ -2914,13 +2839,13 @@ private void OnLoggingThreadException(Exception e)
         /// </summary>
         private void OnProjectFinished(object sender, ProjectFinishedEventArgs e)
         {
-            _workQueue.Post(() =>
+            _workQueue!.Post(() =>
             {
                 lock (_syncLock)
                 {
-                    if (_projectStartedEvents.TryGetValue(e.BuildEventContext.SubmissionId, out var originalArgs))
+                    if (_projectStartedEvents.TryGetValue(e.BuildEventContext!.SubmissionId, out var originalArgs))
                     {
-                        if (originalArgs.BuildEventContext.Equals(e.BuildEventContext))
+                        if (originalArgs.BuildEventContext!.Equals(e.BuildEventContext))
                         {
                             _projectStartedEvents.Remove(e.BuildEventContext.SubmissionId);
                             if (_buildSubmissions.TryGetValue(e.BuildEventContext.SubmissionId, out var submission))
@@ -2939,11 +2864,11 @@ private void OnProjectFinished(object sender, ProjectFinishedEventArgs e)
         /// </summary>
         private void OnProjectStarted(object sender, ProjectStartedEventArgs e)
         {
-            _workQueue.Post(() =>
+            _workQueue!.Post(() =>
             {
                 lock (_syncLock)
                 {
-                    if (!_projectStartedEvents.ContainsKey(e.BuildEventContext.SubmissionId))
+                    if (!_projectStartedEvents.ContainsKey(e.BuildEventContext!.SubmissionId))
                     {
                         _projectStartedEvents[e.BuildEventContext.SubmissionId] = e;
                     }
@@ -2951,19 +2876,29 @@ private void OnProjectStarted(object sender, ProjectStartedEventArgs e)
             });
         }
 
+        /// <summary>
+        /// Sets <see cref="BuildParameters.IsBuildCheckEnabled"/> to true. Used for BuildCheck Replay Mode.
+        /// </summary>
+        internal void EnableBuildCheck()
+        {
+            _buildParameters ??= new BuildParameters();
+
+            _buildParameters.IsBuildCheckEnabled = true;
+        }
+
         /// <summary>
         /// Creates a logging service around the specified set of loggers.
         /// </summary>
         private ILoggingService CreateLoggingService(
-            IEnumerable<ILogger> loggers,
-            IEnumerable<ForwardingLoggerRecord> forwardingLoggers,
+            IEnumerable<ILogger>? loggers,
+            IEnumerable<ForwardingLoggerRecord>? forwardingLoggers,
             ISet<string> warningsAsErrors,
             ISet<string> warningsNotAsErrors,
             ISet<string> warningsAsMessages)
         {
             Debug.Assert(Monitor.IsEntered(_syncLock));
 
-            int cpuCount = _buildParameters.MaxNodeCount;
+            int cpuCount = _buildParameters!.MaxNodeCount;
 
             LoggerMode loggerMode = cpuCount == 1 && _buildParameters.UseSynchronousLogging
                                         ? LoggerMode.Synchronous
@@ -2999,7 +2934,7 @@ private ILoggingService CreateLoggingService(
                     verbosity: LoggerVerbosity.Quiet);
 
                 ILogger buildCheckLogger =
-                    new BuildCheckConnectorLogger(new AnalyzerLoggingContextFactory(loggingService),
+                    new BuildCheckConnectorLogger(new CheckLoggingContextFactory(loggingService),
                         buildCheckManagerProvider.Instance);
 
                 ForwardingLoggerRecord[] forwardingLogger = { new ForwardingLoggerRecord(buildCheckLogger, forwardingLoggerDescription) };
@@ -3042,11 +2977,11 @@ private ILoggingService CreateLoggingService(
 
             // We need to register SOME logger if we don't have any. This ensures the out of proc nodes will still send us message,
             // ensuring we receive project started and finished events.
-            static List<ForwardingLoggerRecord> ProcessForwardingLoggers(IEnumerable<ForwardingLoggerRecord> forwarders)
+            static List<ForwardingLoggerRecord> ProcessForwardingLoggers(IEnumerable<ForwardingLoggerRecord>? forwarders)
             {
                 Type configurableLoggerType = typeof(ConfigurableForwardingLogger);
                 string engineAssemblyName = configurableLoggerType.GetTypeInfo().Assembly.GetName().FullName;
-                string configurableLoggerName = configurableLoggerType.FullName;
+                string configurableLoggerName = configurableLoggerType.FullName!;
 
                 if (forwarders == null)
                 {
@@ -3065,7 +3000,7 @@ static List<ForwardingLoggerRecord> ProcessForwardingLoggers(IEnumerable<Forward
 
                 // Those are the cases where we are sure that we have the forwarding setup as need.
                 if (result.Any(l =>
-                        l.ForwardingLoggerDescription.Name.Contains(typeof(CentralForwardingLogger).FullName)
+                        l.ForwardingLoggerDescription.Name.Contains(typeof(CentralForwardingLogger).FullName!)
                         ||
                         (l.ForwardingLoggerDescription.Name.Contains(configurableLoggerName)
                          &&
@@ -3080,7 +3015,7 @@ static List<ForwardingLoggerRecord> ProcessForwardingLoggers(IEnumerable<Forward
                 }
 
                 // In case there is a ConfigurableForwardingLogger, that is not configured as we'd need - we can adjust the config
-                ForwardingLoggerRecord configurableLogger = result.FirstOrDefault(l =>
+                ForwardingLoggerRecord? configurableLogger = result.FirstOrDefault(l =>
                     l.ForwardingLoggerDescription.Name.Contains(configurableLoggerName));
 
                 // If there is not - we need to add our own.
@@ -3110,7 +3045,7 @@ ForwardingLoggerRecord CreateMinimalForwarder()
             }
         }
 
-        private static void LogDeferredMessages(ILoggingService loggingService, IEnumerable<DeferredBuildMessage> deferredBuildMessages)
+        private static void LogDeferredMessages(ILoggingService loggingService, IEnumerable<DeferredBuildMessage>? deferredBuildMessages)
         {
             if (deferredBuildMessages == null)
             {
@@ -3135,7 +3070,7 @@ private static void LogDeferredMessages(ILoggingService loggingService, IEnumera
         /// <typeparam name="I">The instance-type of packet being expected</typeparam>
         private static I ExpectPacketType<I>(INodePacket packet, NodePacketType expectedType) where I : class, INodePacket
         {
-            I castPacket = packet as I;
+            I? castPacket = packet as I;
 
             // PERF: Not using VerifyThrow here to avoid boxing of expectedType.
             if (castPacket == null)
@@ -3143,13 +3078,13 @@ private static I ExpectPacketType<I>(INodePacket packet, NodePacketType expected
                 ErrorUtilities.ThrowInternalError("Incorrect packet type: {0} should have been {1}", packet.Type, expectedType);
             }
 
-            return castPacket;
+            return castPacket!;
         }
 
         /// <summary>
         ///  Shutdown the logging service
         /// </summary>
-        private void ShutdownLoggingService(ILoggingService loggingService)
+        private void ShutdownLoggingService(ILoggingService? loggingService)
         {
             try
             {
@@ -3165,7 +3100,7 @@ private void ShutdownLoggingService(ILoggingService loggingService)
             {
                 // Even if an exception is thrown, we want to make sure we null out the logging service so that
                 // we don't try to shut it down again in some other cleanup code.
-                _componentFactories.ReplaceFactory(BuildComponentType.LoggingService, (IBuildComponent)null);
+                _componentFactories.ReplaceFactory(BuildComponentType.LoggingService, (IBuildComponent?)null);
             }
         }
 
@@ -3310,7 +3245,7 @@ private void CancelAndMarkAsFailure()
             // CancelAllSubmissions also ends up setting _shuttingDown and _overallBuildSuccess but it does so in a separate thread to avoid deadlocks.
             // This might cause a race with the first builds which might miss the shutdown update and succeed instead of fail.
             _shuttingDown = true;
-            _executionCancellationTokenSource.Cancel();
+            _executionCancellationTokenSource?.Cancel();
             _overallBuildSuccess = false;
         }
 
@@ -3333,7 +3268,7 @@ public LoggerVerbosity Verbosity
             /// <summary>
             /// The logger parameters.
             /// </summary>
-            public string Parameters
+            public string? Parameters
             {
                 get => String.Empty;
                 set { }
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 826fbadef56..0ce71397288 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -231,7 +231,7 @@ public class BuildParameters : ITranslatable
         /// </summary>
         public BuildParameters()
         {
-            Initialize(Utilities.GetEnvironmentProperties(), new ProjectRootElementCache(false), null);
+            Initialize(Utilities.GetEnvironmentProperties(makeReadOnly: false), new ProjectRootElementCache(false), null);
         }
 
         /// <summary>
@@ -840,7 +840,7 @@ public bool Question
         }
 
         /// <summary>
-        /// Gets or sets an indication of build analysis enablement.
+        /// Gets or sets an indication of build check enablement.
         /// </summary>
         public bool IsBuildCheckEnabled
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index b8ae83411b2..5c69b4aebd0 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -2,94 +2,23 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Linq;
+using System.Runtime.CompilerServices;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Execution
 {
     /// <summary>
-    /// Flags providing additional control over the build request
+    /// BuildRequestData encapsulates all the data needed to submit a build request.
     /// </summary>
-    [Flags]
-    public enum BuildRequestDataFlags
-    {
-        /// <summary>
-        /// No flags.
-        /// </summary>
-        None = 0,
-
-        /// <summary>
-        /// When this flag is present, the existing ProjectInstance in the build will be replaced by this one.
-        /// </summary>
-        ReplaceExistingProjectInstance = 1 << 0,
-
-        /// <summary>
-        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
-        /// include <see cref="BuildResult.ProjectStateAfterBuild"/>.
-        /// </summary>
-        ProvideProjectStateAfterBuild = 1 << 1,
-
-        /// <summary>
-        /// When this flag is present and the project has previously been built on a node whose affinity is
-        /// incompatible with the affinity this request requires, we will ignore the project state (but not
-        /// target results) that were previously generated.
-        /// </summary>
-        /// <remarks>
-        /// This usually is not desired behavior.  It is only provided for those cases where the client
-        /// knows that the new build request does not depend on project state generated by a previous request.  Setting
-        /// this flag can provide a performance boost in the case of incompatible node affinities, as MSBuild would
-        /// otherwise have to serialize the project state from one node to another, which may be
-        /// expensive depending on how much data the project previously generated.
-        ///
-        /// This flag has no effect on target results, so if a previous request already built a target, the new
-        /// request will not re-build that target (nor will any of the project state mutations which previously
-        /// occurred as a consequence of building that target be re-applied.)
-        /// </remarks>
-        IgnoreExistingProjectState = 1 << 2,
-
-        /// <summary>
-        /// When this flag is present, caches including the <see cref="ProjectRootElementCacheBase"/> will be cleared
-        /// after the build request completes.  This is used when the build request is known to modify a lot of
-        /// state such as restoring packages or generating parts of the import graph.
-        /// </summary>
-        ClearCachesAfterBuild = 1 << 3,
-
-        /// <summary>
-        /// When this flag is present, the top level target(s) in the build request will be skipped if those targets
-        /// are not defined in the Project to build. This only applies to this build request (if another target calls
-        /// the "missing target" at any other point this will still result in an error).
-        /// </summary>
-        SkipNonexistentTargets = 1 << 4,
-
-        /// <summary>
-        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
-        /// include a <see cref="BuildResult.ProjectStateAfterBuild"/> that includes ONLY the
-        /// explicitly-requested properties, items, and metadata.
-        /// </summary>
-        ProvideSubsetOfStateAfterBuild = 1 << 5,
-
-        /// <summary>
-        /// When this flag is present, projects loaded during build will ignore missing imports (<see cref="ProjectLoadSettings.IgnoreMissingImports"/> and <see cref="ProjectLoadSettings.IgnoreInvalidImports"/>).
-        /// This is especially useful during a restore since some imports might come from packages that haven't been restored yet.
-        /// </summary>
-        IgnoreMissingEmptyAndInvalidImports = 1 << 6,
-
-        /// <summary>
-        /// When this flag is present, an unresolved MSBuild project SDK will fail the build.  This flag is used to
-        /// change the <see cref="IgnoreMissingEmptyAndInvalidImports" /> behavior to still fail when an SDK is missing
-        /// because those are more fatal.
-        /// </summary>
-        FailOnUnresolvedSdk = 1 << 7,
-    }
-
-    /// <summary>
-    /// BuildRequestData encapsulates all of the data needed to submit a build request.
-    /// </summary>
-    public class BuildRequestData
+    public class BuildRequestData : BuildRequestData<BuildRequestData, BuildResult>
     {
         /// <summary>
         /// Constructs a BuildRequestData for build requests based on project instances.
@@ -119,7 +48,7 @@ public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use, if any.  May be null.</param>
         /// <param name="flags">Flags controlling this build request.</param>
-        public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags)
+        public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags)
             : this(projectInstance, targetsToBuild, hostServices, flags, null)
         {
         }
@@ -132,8 +61,8 @@ public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild
         /// <param name="hostServices">The host services to use, if any.  May be null.</param>
         /// <param name="flags">Flags controlling this build request.</param>
         /// <param name="propertiesToTransfer">The list of properties whose values should be transferred from the project to any out-of-proc node.</param>
-        public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, IEnumerable<string> propertiesToTransfer)
-            : this(targetsToBuild, hostServices, flags)
+        public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags, IEnumerable<string>? propertiesToTransfer)
+            : this(targetsToBuild, hostServices, flags, projectInstance.FullPath)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectInstance, nameof(projectInstance));
 
@@ -144,7 +73,6 @@ public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild
 
             ProjectInstance = projectInstance;
 
-            ProjectFullPath = projectInstance.FullPath;
             GlobalPropertiesDictionary = projectInstance.GlobalPropertiesDictionary;
             ExplicitlySpecifiedToolsVersion = projectInstance.ExplicitToolsVersion;
             if (propertiesToTransfer != null)
@@ -162,7 +90,7 @@ public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild
         /// <param name="flags">Flags controlling this build request.</param>
         /// <param name="propertiesToTransfer">The list of properties whose values should be transferred from the project to any out-of-proc node.</param>
         /// <param name="requestedProjectState">A <see cref="Execution.RequestedProjectState"/> describing properties, items, and metadata that should be returned. Requires setting <see cref="BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/>.</param>
-        public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, IEnumerable<string> propertiesToTransfer, RequestedProjectState requestedProjectState)
+        public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags, IEnumerable<string>? propertiesToTransfer, RequestedProjectState requestedProjectState)
             : this(projectInstance, targetsToBuild, hostServices, flags, propertiesToTransfer)
         {
             ErrorUtilities.VerifyThrowArgumentNull(requestedProjectState, nameof(requestedProjectState));
@@ -179,7 +107,7 @@ public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild
         /// <param name="toolsVersion">The tools version to use for the build.  May be null.</param>
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use.  May be null.</param>
-        public BuildRequestData(string projectFullPath, IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, HostServices hostServices)
+        public BuildRequestData(string projectFullPath, IDictionary<string, string?> globalProperties, string? toolsVersion, string[] targetsToBuild, HostServices? hostServices)
             : this(projectFullPath, globalProperties, toolsVersion, targetsToBuild, hostServices, BuildRequestDataFlags.None)
         {
         }
@@ -194,8 +122,8 @@ public BuildRequestData(string projectFullPath, IDictionary<string, string> glob
         /// <param name="hostServices">The host services to use.  May be null.</param>
         /// <param name="flags">The <see cref="BuildRequestDataFlags"/> to use.</param>
         /// <param name="requestedProjectState">A <see cref="Execution.RequestedProjectState"/> describing properties, items, and metadata that should be returned. Requires setting <see cref="BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/>.</param>
-        public BuildRequestData(string projectFullPath, IDictionary<string, string> globalProperties,
-            string toolsVersion, string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags,
+        public BuildRequestData(string projectFullPath, IDictionary<string, string?> globalProperties,
+            string? toolsVersion, string[] targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags,
             RequestedProjectState requestedProjectState)
             : this(projectFullPath, globalProperties, toolsVersion, targetsToBuild, hostServices, flags)
         {
@@ -213,15 +141,14 @@ public BuildRequestData(string projectFullPath, IDictionary<string, string> glob
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use.  May be null.</param>
         /// <param name="flags">The <see cref="BuildRequestDataFlags"/> to use.</param>
-        public BuildRequestData(string projectFullPath, IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags)
-            : this(targetsToBuild, hostServices, flags)
+        public BuildRequestData(string projectFullPath, IDictionary<string, string?> globalProperties, string? toolsVersion, string[] targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags)
+            : this(targetsToBuild, hostServices, flags, FileUtilities.NormalizePath(projectFullPath)!)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFullPath, nameof(projectFullPath));
             ErrorUtilities.VerifyThrowArgumentNull(globalProperties, nameof(globalProperties));
 
-            ProjectFullPath = FileUtilities.NormalizePath(projectFullPath);
             GlobalPropertiesDictionary = new PropertyDictionary<ProjectPropertyInstance>(globalProperties.Count);
-            foreach (KeyValuePair<string, string> propertyPair in globalProperties)
+            foreach (KeyValuePair<string, string?> propertyPair in globalProperties)
             {
                 GlobalPropertiesDictionary.Set(ProjectPropertyInstance.Create(propertyPair.Key, propertyPair.Value));
             }
@@ -232,13 +159,10 @@ public BuildRequestData(string projectFullPath, IDictionary<string, string> glob
         /// <summary>
         /// Common constructor.
         /// </summary>
-        private BuildRequestData(string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags)
+        private BuildRequestData(string[] targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags, string projectFullPath)
+            : base(targetsToBuild, flags, hostServices)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(targetsToBuild, nameof(targetsToBuild));
-
-            HostServices = hostServices;
-            TargetNames = new List<string>(targetsToBuild);
-            Flags = flags;
+            ProjectFullPath = projectFullPath;
         }
 
         /// <summary>
@@ -246,7 +170,7 @@ private BuildRequestData(string[] targetsToBuild, HostServices hostServices, Bui
         /// May be null.
         /// </summary>
         /// <value>The project instance.</value>
-        public ProjectInstance ProjectInstance
+        public ProjectInstance? ProjectInstance
         {
             get;
         }
@@ -255,16 +179,12 @@ public ProjectInstance ProjectInstance
         /// <value>The project file to be built.</value>
         public string ProjectFullPath { get; internal set; }
 
-        /// <summary>
-        /// The name of the targets to build.
-        /// </summary>
-        /// <value>An array of targets in the project to be built.</value>
-        public ICollection<string> TargetNames { get; }
+        internal override BuildSubmissionBase<BuildRequestData, BuildResult> CreateSubmission(BuildManager buildManager,
+            int submissionId, BuildRequestData requestData,
+            bool legacyThreadingSemantics) =>
+            new BuildSubmission(buildManager, submissionId, requestData, legacyThreadingSemantics);
 
-        /// <summary>
-        /// Extra flags for this BuildRequest.
-        /// </summary>
-        public BuildRequestDataFlags Flags { get; }
+        public override IEnumerable<string> EntryProjectsFullPath => ProjectFullPath.AsSingleItemEnumerable();
 
         /// <summary>
         /// The global properties to use.
@@ -274,26 +194,23 @@ public ProjectInstance ProjectInstance
             (ICollection<ProjectPropertyInstance>)ReadOnlyEmptyCollection<ProjectPropertyInstance>.Instance :
             new ReadOnlyCollection<ProjectPropertyInstance>(GlobalPropertiesDictionary);
 
-        /// <summary>
-        /// The explicitly requested tools version to use.
-        /// </summary>
-        public string ExplicitlySpecifiedToolsVersion { get; }
+        public override bool IsGraphRequest => false;
 
         /// <summary>
-        /// Gets the HostServices object for this request.
+        /// The explicitly requested tools version to use.
         /// </summary>
-        public HostServices HostServices { get; }
+        public string? ExplicitlySpecifiedToolsVersion { get; }
 
         /// <summary>
         /// Returns a list of properties to transfer out of proc for the build.
         /// </summary>
-        public IEnumerable<string> PropertiesToTransfer { get; }
+        public IEnumerable<string>? PropertiesToTransfer { get; }
 
         /// <summary>
         /// Returns the properties, items, and metadata that will be returned
         /// by this build.
         /// </summary>
-        public RequestedProjectState RequestedProjectState { get; }
+        public RequestedProjectState? RequestedProjectState { get; }
 
         /// <summary>
         /// Whether the tools version used originated from an explicit specification,
@@ -304,6 +221,25 @@ public ProjectInstance ProjectInstance
         /// <summary>
         /// Returns the global properties as a dictionary.
         /// </summary>
-        internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
+        internal PropertyDictionary<ProjectPropertyInstance>? GlobalPropertiesDictionary { get; }
+
+        private IReadOnlyDictionary<string, string?>? _globalPropertiesLookup;
+
+        /// <inheritdoc cref="BuildRequestDataBase"/>
+        public override IReadOnlyDictionary<string, string?> GlobalPropertiesLookup => _globalPropertiesLookup ??=
+            Execution.GlobalPropertiesLookup.ToGlobalPropertiesLookup(GlobalPropertiesDictionary);
+
+        // WARNING!: Do not remove the below proxy properties.
+        //  They are required to make the OM forward compatible
+        //  (code built against this OM should run against binaries with previous version of OM).
+
+        /// <inheritdoc cref="BuildRequestDataBase.TargetNames"/>
+        public new ICollection<string> TargetNames => base.TargetNames;
+
+        /// <inheritdoc cref="BuildRequestDataBase.Flags"/>
+        public new BuildRequestDataFlags Flags => base.Flags;
+
+        /// <inheritdoc cref="BuildRequestDataBase.HostServices"/>
+        public new HostServices? HostServices => base.HostServices;
     }
 }
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestDataBase.cs b/src/Build/BackEnd/BuildManager/BuildRequestDataBase.cs
new file mode 100644
index 00000000000..c31381c083d
--- /dev/null
+++ b/src/Build/BackEnd/BuildManager/BuildRequestDataBase.cs
@@ -0,0 +1,67 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Execution
+{
+    public abstract class BuildRequestDataBase
+    {
+        protected BuildRequestDataBase(
+            ICollection<string> targetNames,
+            BuildRequestDataFlags flags,
+            HostServices? hostServices)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(targetNames, nameof(targetNames));
+            foreach (string targetName in targetNames)
+            {
+                ErrorUtilities.VerifyThrowArgumentNull(targetName, "target");
+            }
+
+            TargetNames = new List<string>(targetNames);
+            Flags = flags;
+            HostServices = hostServices;
+        }
+
+        public abstract IEnumerable<string> EntryProjectsFullPath { get; }
+
+        /// <summary>
+        /// The name of the targets to build.
+        /// </summary>
+        /// <value>An array of targets in the project to be built.</value>
+        public ICollection<string> TargetNames { get; protected set; }
+
+        /// <summary>
+        /// Extra flags for this BuildRequest.
+        /// </summary>
+        public BuildRequestDataFlags Flags { get; protected set; }
+
+        /// <summary>
+        /// Gets the global properties to use for this entry point.
+        /// </summary>
+        public abstract IReadOnlyDictionary<string, string?> GlobalPropertiesLookup { get; }
+
+        public abstract bool IsGraphRequest { get; }
+
+        /// <summary>
+        /// Gets the HostServices object for this request.
+        /// </summary>
+        public HostServices? HostServices { get; }
+    }
+
+    public abstract class BuildRequestData<TRequestData, TResultData> : BuildRequestDataBase
+        where TRequestData : BuildRequestData<TRequestData, TResultData>
+        where TResultData : BuildResultBase
+    {
+        protected BuildRequestData(
+            ICollection<string> targetNames,
+            BuildRequestDataFlags flags,
+            HostServices? hostServices)
+            : base(targetNames, flags, hostServices)
+        { }
+
+        internal abstract BuildSubmissionBase<TRequestData, TResultData> CreateSubmission(
+            BuildManager buildManager, int submissionId, TRequestData requestData, bool legacyThreadingSemantics);
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmission.cs b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
index ca2147dfae2..e96185fc640 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmission.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmission.cs
@@ -7,8 +7,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Execution
 {
     /// <summary>
@@ -17,104 +15,171 @@ namespace Microsoft.Build.Execution
     /// <remarks>
     /// When this delegate is invoked, the WaitHandle on the BuildSubmission will have been be signalled and the OverallBuildResult will be valid.
     /// </remarks>
-    public delegate void BuildSubmissionCompleteCallback(BuildSubmission submission);
-
-    /// <summary>
-    /// A BuildSubmission represents an build request which has been submitted to the BuildManager for processing.  It may be used to
-    /// execute synchronous or asynchronous build requests and provides access to the results upon completion.
-    /// </summary>
-    /// <remarks>
-    /// This class is thread-safe.
-    /// </remarks>
-    public class BuildSubmission
+    internal delegate void BuildSubmissionCompleteCallbackInternal<TRequestData, TResultData>(
+        BuildSubmissionBase<TRequestData, TResultData> submission)
+        where TRequestData : BuildRequestDataBase
+        where TResultData : BuildResultBase;
+
+    public abstract class BuildSubmissionBase<TRequestData, TResultData> : BuildSubmissionBase
+        where TRequestData : BuildRequestDataBase
+        where TResultData : BuildResultBase
     {
         /// <summary>
         /// The callback to invoke when the submission is complete.
         /// </summary>
-        private BuildSubmissionCompleteCallback _completionCallback;
+        private BuildSubmissionCompleteCallbackInternal<TRequestData, TResultData>? _completionCallback;
 
         /// <summary>
-        /// The completion event.
+        /// Constructor
         /// </summary>
-        private readonly ManualResetEvent _completionEvent;
+        protected internal BuildSubmissionBase(BuildManager buildManager, int submissionId, TRequestData requestData)
+            : base(buildManager, submissionId)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(requestData, nameof(requestData));
+            BuildRequestData = requestData;
+        }
+
+        //
+        // Unfortunately covariant overrides are not available for .NET 472,
+        //  so we have to use two set of properties for derived classes.
+        internal override BuildResultBase? BuildResultBase => BuildResult;
+        internal override BuildRequestDataBase BuildRequestDataBase => BuildRequestData;
 
         /// <summary>
-        /// Flag indicating if logging is done.
+        /// The results of the build per graph node.  Valid only after WaitHandle has become signalled.
         /// </summary>
-        internal bool LoggingCompleted { get; private set; }
+        public TResultData? BuildResult { get; set; }
 
         /// <summary>
-        /// True if it has been invoked
+        /// The BuildRequestData being used for this submission.
         /// </summary>
-        private int _completionInvoked;
+        internal TRequestData BuildRequestData { get; }
 
         /// <summary>
-        /// Flag indicating whether synchronous wait should support legacy threading semantics.
+        /// Starts the request and blocks until results are available.
         /// </summary>
-        private readonly bool _legacyThreadingSemantics;
+        /// <exception cref="InvalidOperationException">The request has already been started or is already complete.</exception>
+        public abstract TResultData Execute();
+
+        private protected void ExecuteAsync(
+            BuildSubmissionCompleteCallbackInternal<TRequestData, TResultData>? callback,
+            object? context,
+            bool allowMainThreadBuild)
+        {
+            ErrorUtilities.VerifyThrowInvalidOperation(!IsCompleted, "SubmissionAlreadyComplete");
+            _completionCallback = callback;
+            AsyncContext = context;
+            BuildManager.ExecuteSubmission(this, allowMainThreadBuild);
+        }
 
         /// <summary>
-        /// Constructor
+        /// Sets the event signaling that the build is complete.
         /// </summary>
-        internal BuildSubmission(BuildManager buildManager, int submissionId, BuildRequestData requestData, bool legacyThreadingSemantics)
+        internal void CompleteResults(TResultData result)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(buildManager, nameof(buildManager));
-            ErrorUtilities.VerifyThrowArgumentNull(requestData, nameof(requestData));
+            ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
+            CheckResultValidForCompletion(result);
 
-            BuildManager = buildManager;
-            SubmissionId = submissionId;
-            BuildRequestData = requestData;
-            _completionEvent = new ManualResetEvent(false);
-            LoggingCompleted = false;
-            _completionInvoked = 0;
-            _legacyThreadingSemantics = legacyThreadingSemantics;
+            BuildResult ??= result;
+
+            CheckForCompletion();
         }
 
-        /// <summary>
-        /// The BuildManager with which this submission is associated.
-        /// </summary>
-        public BuildManager BuildManager { get; }
+        protected internal abstract void CheckResultValidForCompletion(TResultData result);
 
-        /// <summary>
-        /// An ID uniquely identifying this request from among other submissions within the same build.
-        /// </summary>
-        public int SubmissionId { get; }
+        protected internal abstract TResultData CreateFailedResult(Exception exception);
 
-        /// <summary>
-        /// The asynchronous context provided to <see cref="BuildSubmission.ExecuteAsync(BuildSubmissionCompleteCallback, object)"/>, if any.
-        /// </summary>
-        public Object AsyncContext { get; private set; }
+        internal override BuildResultBase CompleteResultsWithException(Exception exception)
+            => CompleteResults(exception);
 
-        /// <summary>
-        /// A <see cref="System.Threading.WaitHandle"/> which will be signalled when the build is complete.  Valid after <see cref="BuildSubmission.Execute()"/> or <see cref="BuildSubmission.ExecuteAsync(BuildSubmissionCompleteCallback, object)"/> returns, otherwise null.
-        /// </summary>
-        public WaitHandle WaitHandle => _completionEvent;
+        private TResultData CompleteResults(Exception exception)
+        {
+            TResultData result = CreateFailedResult(exception);
+            CompleteResults(result);
+            return result;
+        }
 
         /// <summary>
-        /// Returns true if this submission is complete.
+        /// Determines if we are completely done with this submission and can complete it so the user may access results.
         /// </summary>
-        public bool IsCompleted => WaitHandle.WaitOne(new TimeSpan(0));
+        protected internal override void CheckForCompletion()
+        {
+            if (BuildResult != null && LoggingCompleted)
+            {
+                bool hasCompleted = (Interlocked.Exchange(ref CompletionInvoked, 1) == 1);
+                if (!hasCompleted)
+                {
+                    OnCompletition();
+
+                    CompletionEvent.Set();
+
+                    if (_completionCallback != null)
+                    {
+                        void Callback(object? state)
+                        {
+                            _completionCallback(this);
+                        }
+
+                        ThreadPoolExtensions.QueueThreadPoolWorkItemWithCulture(Callback, CultureInfo.CurrentCulture, CultureInfo.CurrentUICulture);
+                    }
+                }
+            }
+        }
+    }
+
+
+    /// <summary>
+    /// A callback used to receive notification that a build has completed.
+    /// </summary>
+    /// <remarks>
+    /// When this delegate is invoked, the WaitHandle on the BuildSubmission will have been be signalled and the OverallBuildResult will be valid.
+    /// </remarks>
+    public delegate void BuildSubmissionCompleteCallback(BuildSubmission submission);
 
+    /// <summary>
+    /// A BuildSubmission represents a build request which has been submitted to the BuildManager for processing.  It may be used to
+    /// execute synchronous or asynchronous build requests and provides access to the results upon completion.
+    /// </summary>
+    /// <remarks>
+    /// This class is thread-safe.
+    /// </remarks>
+    public class BuildSubmission : BuildSubmissionBase<BuildRequestData, BuildResult>
+    {
         /// <summary>
-        /// The result of the build.  Valid only after WaitHandle has become signalled.
+        /// Flag indicating whether synchronous wait should support legacy threading semantics.
         /// </summary>
-        public BuildResult BuildResult { get; set; }
+        private readonly bool _legacyThreadingSemantics;
 
         /// <summary>
-        /// The BuildRequestData being used for this submission.
+        /// The build request for execution.
         /// </summary>
-        internal BuildRequestData BuildRequestData { get; }
+        internal BuildRequest? BuildRequest { get; set; }
+
+        internal BuildSubmission(BuildManager buildManager, int submissionId, BuildRequestData requestData, bool legacyThreadingSemantics)
+            : base(buildManager, submissionId, requestData)
+        {
+            _legacyThreadingSemantics = legacyThreadingSemantics;
+        }
 
         /// <summary>
-        /// The build request for execution.
+        /// Starts the request asynchronously and immediately returns control to the caller.
         /// </summary>
-        internal BuildRequest BuildRequest { get; set; }
+        /// <exception cref="InvalidOperationException">The request has already been started or is already complete.</exception>
+        public void ExecuteAsync(BuildSubmissionCompleteCallback? callback, object? context)
+        {
+            void Clb(BuildSubmissionBase<BuildRequestData, BuildResult> submission)
+            {
+                callback?.Invoke((BuildSubmission)submission);
+            }
+
+            ExecuteAsync(Clb, context, allowMainThreadBuild: false);
+        }
 
         /// <summary>
         /// Starts the request and blocks until results are available.
         /// </summary>
         /// <exception cref="System.InvalidOperationException">The request has already been started or is already complete.</exception>
-        public BuildResult Execute()
+        public override BuildResult Execute()
         {
             LegacyThreadingData legacyThreadingData = ((IBuildComponentHost)BuildManager).LegacyThreadingData;
             legacyThreadingData.RegisterSubmissionForLegacyThread(SubmissionId);
@@ -131,90 +196,63 @@ public BuildResult Execute()
 
             legacyThreadingData.UnregisterSubmissionForLegacyThread(SubmissionId);
 
-            return BuildResult;
+            ErrorUtilities.VerifyThrow(BuildResult != null,
+                "BuildResult is not populated after Execute is done.");
+
+            return BuildResult!;
         }
 
-        /// <summary>
-        /// Starts the request asynchronously and immediately returns control to the caller.
-        /// </summary>
-        /// <exception cref="System.InvalidOperationException">The request has already been started or is already complete.</exception>
-        public void ExecuteAsync(BuildSubmissionCompleteCallback callback, object context)
+        protected internal override BuildResult CreateFailedResult(Exception exception)
         {
-            ExecuteAsync(callback, context, false);
+            ErrorUtilities.VerifyThrow(BuildRequest != null,
+                "BuildRequest is not populated while reporting failed result.");
+            return new(BuildRequest!, exception);
         }
 
-        /// <summary>
-        /// Sets the event signaling that the build is complete.
-        /// </summary>
-        internal void CompleteResults(BuildResult result)
+        protected internal override void CheckResultValidForCompletion(BuildResult result)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
-
             // We verify that we got results from the same configuration, but not necessarily the same request, because we are
             // rather flexible in how users are allowed to submit multiple requests for the same configuration.  In this case, the
             // request id of the result will match the first request, even though it will contain results for all requests (including
             // this one.)
-            ErrorUtilities.VerifyThrow(result.ConfigurationId == BuildRequest.ConfigurationId, "BuildResult doesn't match BuildRequest configuration");
-
-            if (BuildResult == null)
+            if (result.ConfigurationId != BuildRequest?.ConfigurationId)
             {
-                BuildResult = result;
+                ErrorUtilities.ThrowInternalError("BuildResult configuration ({0}) doesn't match BuildRequest configuration ({1})",
+                    result.ConfigurationId, BuildRequest?.ConfigurationId);
             }
-
-            CheckForCompletion();
         }
 
-        /// <summary>
-        /// Indicates that all logging events for this submission are complete.
-        /// </summary>
-        internal void CompleteLogging()
+        protected internal override void OnCompletition()
         {
-            LoggingCompleted = true;
-            CheckForCompletion();
+            // Did this submission have warnings elevated to errors? If so, mark it as
+            // failed even though it succeeded (with warnings--but they're errors).
+            if (BuildResult != null &&
+                ((IBuildComponentHost)BuildManager).LoggingService.HasBuildSubmissionLoggedErrors(BuildResult.SubmissionId))
+            {
+                BuildResult.SetOverallResult(overallResult: false);
+            }
         }
 
-        /// <summary>
-        /// Starts the request asynchronously and immediately returns control to the caller.
-        /// </summary>
-        /// <exception cref="System.InvalidOperationException">The request has already been started or is already complete.</exception>
-        private void ExecuteAsync(BuildSubmissionCompleteCallback callback, object context, bool allowMainThreadBuild)
-        {
-            ErrorUtilities.VerifyThrowInvalidOperation(!IsCompleted, "SubmissionAlreadyComplete");
-            _completionCallback = callback;
-            AsyncContext = context;
-            BuildManager.ExecuteSubmission(this, allowMainThreadBuild);
-        }
+        // WARNING!: Do not remove the below proxy properties.
+        //  They are required to make the OM forward compatible
+        //  (code built against this OM should run against binaries with previous version of OM).
 
-        /// <summary>
-        /// Determines if we are completely done with this submission and can complete it so the user may access results.
-        /// </summary>
-        private void CheckForCompletion()
-        {
-            if (BuildResult != null && LoggingCompleted)
-            {
-                bool hasCompleted = (Interlocked.Exchange(ref _completionInvoked, 1) == 1);
-                if (!hasCompleted)
-                {
-                    // Did this submission have warnings elevated to errors? If so, mark it as
-                    // failed even though it succeeded (with warnings--but they're errors).
-                    if (((IBuildComponentHost)BuildManager).LoggingService.HasBuildSubmissionLoggedErrors(BuildResult.SubmissionId))
-                    {
-                        BuildResult.SetOverallResult(overallResult: false);
-                    }
+        /// <inheritdoc cref="BuildSubmissionBase{BuildRequestData, BuildResult}.BuildResult"/>
+        public new BuildResult? BuildResult => base.BuildResult;
 
-                    _completionEvent.Set();
+        /// <inheritdoc cref="BuildSubmissionBase.BuildManager"/>
+        public new BuildManager BuildManager => base.BuildManager;
 
-                    if (_completionCallback != null)
-                    {
-                        void Callback(object state)
-                        {
-                            _completionCallback(this);
-                        }
+        /// <inheritdoc cref="BuildSubmissionBase.SubmissionId"/>
+        public new int SubmissionId => base.SubmissionId;
 
-                        ThreadPoolExtensions.QueueThreadPoolWorkItemWithCulture(Callback, CultureInfo.CurrentCulture, CultureInfo.CurrentUICulture);
-                    }
-                }
-            }
-        }
+        /// <inheritdoc cref="BuildSubmissionBase.AsyncContext"/>
+        public new object? AsyncContext => base.AsyncContext;
+
+        /// <inheritdoc cref="BuildSubmissionBase.WaitHandle"/>
+        public new WaitHandle WaitHandle => base.WaitHandle;
+
+        /// <inheritdoc cref="BuildSubmissionBase.IsCompleted"/>
+        public new bool IsCompleted => base.IsCompleted;
     }
 }
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs b/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
new file mode 100644
index 00000000000..ba6f45afc09
--- /dev/null
+++ b/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
@@ -0,0 +1,96 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Execution
+{
+    public abstract class BuildSubmissionBase
+    {
+        /// <summary>
+        /// The completion event.
+        /// </summary>
+        protected readonly ManualResetEvent CompletionEvent;
+
+        /// <summary>
+        /// Flag indicating if logging is done.
+        /// </summary>
+        internal bool LoggingCompleted { get; private set; }
+
+        /// <summary>
+        /// True if it has been invoked
+        /// </summary>
+        protected int CompletionInvoked;
+
+        //
+        // Unfortunately covariant overrides are not available for .NET 472,
+        //  so we have to use two set of properties for derived classes.
+        internal abstract BuildRequestDataBase BuildRequestDataBase { get; }
+
+        internal abstract BuildResultBase? BuildResultBase { get; }
+
+        /// <summary>
+        /// Constructor
+        /// </summary>
+        protected internal BuildSubmissionBase(BuildManager buildManager, int submissionId)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(buildManager, nameof(buildManager));
+
+            BuildManager = buildManager;
+            SubmissionId = submissionId;
+            CompletionEvent = new ManualResetEvent(false);
+            LoggingCompleted = false;
+            CompletionInvoked = 0;
+        }
+
+        /// <summary>
+        /// The BuildManager with which this submission is associated.
+        /// </summary>
+        public BuildManager BuildManager { get; }
+
+        /// <summary>
+        /// An ID uniquely identifying this request from among other submissions within the same build.
+        /// </summary>
+        public int SubmissionId { get; }
+
+        /// <summary>
+        /// The asynchronous context provided to <see cref="BuildSubmission.ExecuteAsync(BuildSubmissionCompleteCallback, object)"/>, if any.
+        /// </summary>
+        public object? AsyncContext { get; protected set; }
+
+        /// <summary>
+        /// A <see cref="System.Threading.WaitHandle"/> which will be signalled when the build is complete.  Valid after <see cref="BuildSubmissionBase{TRequestData,TResultData}.Execute()"/> or <see cref="BuildSubmission.ExecuteAsync(BuildSubmissionCompleteCallback, object)"/> returns, otherwise null.
+        /// </summary>
+        public WaitHandle WaitHandle => CompletionEvent;
+
+        /// <summary>
+        /// Returns true if this submission is complete.
+        /// </summary>
+        public bool IsCompleted => WaitHandle.WaitOne(new TimeSpan(0));
+
+        /// <summary>
+        /// Whether the build has started.
+        /// </summary>
+        internal bool IsStarted { get; set; }
+
+        /// <summary>
+        /// Indicates that all logging events for this submission are complete.
+        /// </summary>
+        internal void CompleteLogging()
+        {
+            LoggingCompleted = true;
+            CheckForCompletion();
+        }
+
+        protected internal virtual void OnCompletition() { }
+        protected internal abstract void CheckForCompletion();
+
+        internal abstract BuildResultBase CompleteResultsWithException(Exception exception);
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/GlobalPropertiesLookup.cs b/src/Build/BackEnd/BuildManager/GlobalPropertiesLookup.cs
new file mode 100644
index 00000000000..1cf11aa2068
--- /dev/null
+++ b/src/Build/BackEnd/BuildManager/GlobalPropertiesLookup.cs
@@ -0,0 +1,64 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+
+namespace Microsoft.Build.Execution
+{
+    internal class GlobalPropertiesLookup : IReadOnlyDictionary<string, string?>
+    {
+        internal static IReadOnlyDictionary<string, string?> ToGlobalPropertiesLookup(
+            PropertyDictionary<ProjectPropertyInstance>? backing)
+        {
+            if (backing == null)
+            {
+                return ImmutableDictionary<string, string?>.Empty;
+            }
+
+            return new GlobalPropertiesLookup(backing);
+        }
+
+        private GlobalPropertiesLookup(IDictionary<string, ProjectPropertyInstance> backingProperties)
+        {
+            _backingProperties = backingProperties;
+        }
+
+        private readonly IDictionary<string, ProjectPropertyInstance> _backingProperties;
+
+        public IEnumerator<KeyValuePair<string, string?>> GetEnumerator()
+            => _backingProperties
+                .Select(p => new KeyValuePair<string, string?>(p.Key, ExtractEscapedValue(p.Value)))
+                .GetEnumerator();
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
+
+        public int Count => _backingProperties.Count;
+        public bool ContainsKey(string key) => _backingProperties.ContainsKey(key);
+
+        public bool TryGetValue(string key, out string? value)
+        {
+            if (_backingProperties.TryGetValue(key, out var property))
+            {
+                value = ExtractEscapedValue(property);
+                return true;
+            }
+
+            value = null;
+            return false;
+        }
+
+        public string? this[string key] => ExtractEscapedValue(_backingProperties[key]);
+
+        public IEnumerable<string> Keys => _backingProperties.Keys;
+        public IEnumerable<string?> Values => _backingProperties.Values.Select(ExtractEscapedValue);
+
+        private static string? ExtractEscapedValue(ProjectPropertyInstance property) => ((IValued)property).EscapedValue;
+    }
+}
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index dd833490899..7262bb0d329 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -162,6 +162,11 @@ public IBuildComponent GetComponent(BuildComponentType type)
             return componentEntry.GetInstance(_host);
         }
 
+        internal TComponent GetComponent<TComponent>(BuildComponentType type) where TComponent : IBuildComponent
+        {
+            return (TComponent)GetComponent(type);
+        }
+
         /// <summary>
         /// A helper class wrapping build components.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 34480ff2142..e34dd90c5b1 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -350,9 +350,14 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
         /// <param name="buildResult">The candidate build result.</param>
         /// <returns>True if the flags and project state filter of the build request is compatible with the build result.</returns>
         private static bool AreBuildResultFlagsCompatible(BuildRequest buildRequest, BuildResult buildResult)
-        {
+        { 
+            if (buildResult.BuildRequestDataFlags is null)
+            {
+                return true;
+            }
+
             BuildRequestDataFlags buildRequestDataFlags = buildRequest.BuildRequestDataFlags;
-            BuildRequestDataFlags buildResultDataFlags = buildResult.BuildRequestDataFlags;
+            BuildRequestDataFlags buildResultDataFlags = (BuildRequestDataFlags) buildResult.BuildRequestDataFlags;
 
             if ((buildRequestDataFlags & FlagsAffectingBuildResults) != (buildResultDataFlags & FlagsAffectingBuildResults))
             {
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
index 6943ff208e0..de28c100d1d 100644
--- a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
@@ -14,7 +14,7 @@
 
 namespace Microsoft.Build.FileAccesses
 {
-    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent
+    internal sealed class FileAccessManager : IFileAccessManager
     {
         private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);
 
diff --git a/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
index dd3b7685053..14c38c0b590 100644
--- a/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
+++ b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
@@ -9,7 +9,7 @@
 
 namespace Microsoft.Build.FileAccesses
 {
-    internal interface IFileAccessManager
+    internal interface IFileAccessManager : IBuildComponent
     {
         void ReportFileAccess(FileAccessData fileAccessData, int nodeId);
 
diff --git a/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
index e211f674789..c1f7df47679 100644
--- a/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
+++ b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.FileAccesses
     /// <summary>
     /// Reports file accesses and process data to the in-proc node.
     /// </summary>
-    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent
+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager
     {
         /// <summary>
         /// The <see cref="Action"/> to report file accesses and process
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 8b2ded4d251..a3fc16da831 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -144,7 +144,7 @@ internal enum BuildComponentType
         NodeLauncher,
 
         /// <summary>
-        /// The Build Analyzer Manager.
+        /// The Build Check Manager.
         /// </summary>
         BuildCheckManagerProvider,
     }
@@ -195,6 +195,15 @@ internal interface IBuildComponentHost
         /// <returns>The component</returns>
         IBuildComponent GetComponent(BuildComponentType type);
 
+        /// <summary>
+        /// Gets an instance of the specified component type from the host.
+        /// </summary>
+        /// <typeparam name="TComponent"></typeparam>
+        /// <param name="type">The component type to be retrieved</param>
+        /// <returns>The component</returns>
+        TComponent GetComponent<TComponent>(BuildComponentType type)
+            where TComponent : IBuildComponent;
+
         #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
index 893d8796e7d..edc8b5c5b84 100644
--- a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
@@ -115,6 +115,7 @@ public IDictionary<int, ISet<string>> WarningsAsMessagesByProject
         /// This property is ignored by this event sink and relies on the receiver to keep track of whether or not any errors have been logged.
         /// </summary>
         public ISet<int> BuildSubmissionIdsThatHaveLoggedErrors { get; } = null;
+        
         #endregion
         #region IBuildEventSink Methods
 
diff --git a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
index 415a79fa848..7577db70433 100644
--- a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
@@ -36,7 +36,7 @@ protected BuildLoggingContext(ILoggingService loggingService, BuildEventContext
         }
 
         /// <inheritdoc cref="LoggingContext"/>
-        protected BuildLoggingContext(BuildLoggingContext baseContext) : base(baseContext)
+        protected BuildLoggingContext(BuildLoggingContext baseContext, BuildEventContext newEventContext) : base(baseContext, newEventContext)
         {
             _isInProcNode = baseContext._isInProcNode;
         }
@@ -59,7 +59,7 @@ public bool IsInProcNode
         /// <param name="taskName">The task in which the error occurred</param>
         internal void LogFatalTaskError(Exception exception, BuildEventFileInfo file, string taskName)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             LoggingService.LogFatalTaskError(BuildEventContext, exception, file, taskName);
             _hasLoggedErrors = true;
         }
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index d9cb65d4b93..15f4387218a 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -3,6 +3,7 @@
 
 using System.Collections;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
@@ -30,6 +31,8 @@ public EvaluationLoggingContext(ILoggingService loggingService, BuildEventContex
         public void LogProjectEvaluationStarted()
         {
             LoggingService.LogProjectEvaluationStarted(BuildEventContext, _projectFile);
+            LoggingService.BuildEngineDataRouter.ProcessProjectEvaluationStarted(
+                new CheckLoggingContext(LoggingService, BuildEventContext), _projectFile);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 8b8885b195e..8804918dbc0 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -255,6 +255,9 @@ public void Consume(BuildEventArgs buildEvent)
                     HaveLoggedBuildFinishedEvent = true;
                     RaiseBuildFinishedEvent(null, buildFinishedEvent);
                     break;
+                case BuildCanceledEventArgs buildCanceledEvent:
+                    RaiseStatusEvent(null, buildCanceledEvent);
+                    break;
                 case CustomBuildEventArgs customBuildEvent:
                     RaiseCustomEvent(null, customBuildEvent);
                     break;
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 3e44402a61e..ecbf7b8026b 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
@@ -27,7 +28,7 @@ namespace Microsoft.Build.BackEnd.Logging
     /// Interface representing logging services in the build system.
     /// Implementations should be thread-safe.
     /// </summary>
-    internal interface ILoggingService
+    internal interface ILoggingService : IBuildComponent, IBuildEngineDataRouter
     {
         #region Events
         /// <summary>
@@ -52,6 +53,11 @@ internal interface ILoggingService
 
         #region Properties
 
+        /// <summary>
+        /// Router of the build engine runtime execution information.
+        /// </summary>
+        IBuildEngineDataRouter BuildEngineDataRouter { get; }
+
         /// <summary>
         /// Provide the current state of the loggingService.
         /// Is it Inistantiated
@@ -462,6 +468,11 @@ MessageImportance MinimumRequiredMessageImportance
         /// <param name="success">Did the build succeed or not</param>
         void LogBuildFinished(bool success);
 
+        /// <summary>
+        /// Logs that the build has canceled
+        /// </summary>
+        void LogBuildCanceled();
+
         /// <summary>
         /// Create an evaluation context, by generating a new evaluation id.
         /// </summary>
@@ -650,6 +661,7 @@ bool HaveLoggedBuildFinishedEvent
             get;
             set;
         }
+
         #endregion
         /// <summary>
         /// Entry point for a sink to consume an event.
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 15b6000a7aa..6c871f7667c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -4,11 +4,11 @@
 using System;
 using System.Diagnostics;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd.Logging
 {
     /// <summary>
@@ -16,7 +16,7 @@ namespace Microsoft.Build.BackEnd.Logging
     /// hides the requirement to pass BuildEventContexts to the logging service or query the
     /// host for the logging service all of the time.
     /// </summary>
-    internal class LoggingContext
+    internal class LoggingContext : IBuildEngineDataConsumer
     {
         /// <summary>
         /// The logging service to which this context is attached
@@ -57,13 +57,19 @@ public LoggingContext(ILoggingService loggingService, BuildEventContext eventCon
         /// while the event context will come from a call into the logging service itself.
         /// </summary>
         /// <param name="baseContext">The context from which this context is being created.</param>
-        public LoggingContext(LoggingContext baseContext)
+        /// <param name="newEventContext">The new logging context to be associated here.</param>
+        public LoggingContext(LoggingContext baseContext, BuildEventContext newEventContext)
         {
             _loggingService = baseContext._loggingService;
-            _eventContext = null;
+            _eventContext = newEventContext;
             _isValid = baseContext._isValid;
         }
 
+        /// <summary>
+        /// Consumer of the execution information from the build engine.
+        /// </summary>
+        internal IBuildEngineDataConsumer BuildEngineDataConsumer => this;
+
         /// <summary>
         /// Retrieves the logging service
         /// </summary>
@@ -87,12 +93,6 @@ public BuildEventContext BuildEventContext
             {
                 return _eventContext;
             }
-
-            protected set
-            {
-                ErrorUtilities.VerifyThrow(_eventContext == null, "eventContext should be null");
-                _eventContext = value;
-            }
         }
 
         /// <summary>
@@ -122,9 +122,9 @@ protected set
         /// <param name="importance">Importance level of the message</param>
         /// <param name="messageResourceName">string within the resource which indicates the format string to use</param>
         /// <param name="messageArgs">string resource arguments</param>
-        internal void LogComment(MessageImportance importance, string messageResourceName, params object[] messageArgs)
+        internal void LogComment(MessageImportance importance, string messageResourceName, params object?[]? messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogComment(_eventContext, importance, messageResourceName, messageArgs);
         }
 
@@ -135,9 +135,9 @@ internal void LogComment(MessageImportance importance, string messageResourceNam
         /// <param name="file">The file in which the event occurred</param>
         /// <param name="messageResourceName">string within the resource which indicates the format string to use</param>
         /// <param name="messageArgs">string resource arguments</param>
-        internal void LogComment(MessageImportance importance, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
+        internal void LogComment(MessageImportance importance, BuildEventFileInfo file, string messageResourceName, params object?[]? messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
 
             _loggingService.LogBuildEvent(new BuildMessageEventArgs(
                 null,
@@ -165,7 +165,7 @@ internal void LogComment(MessageImportance importance, BuildEventFileInfo file,
         /// <param name="message">message to log</param>
         internal void LogCommentFromText(MessageImportance importance, string message)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogCommentFromText(_eventContext, importance, message);
         }
 
@@ -177,7 +177,7 @@ internal void LogCommentFromText(MessageImportance importance, string message)
         /// <param name="messageArgs">Format string arguments</param>
         internal void LogCommentFromText(MessageImportance importance, string message, params object[] messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogCommentFromText(_eventContext, importance, message, messageArgs);
         }
 
@@ -189,7 +189,7 @@ internal void LogCommentFromText(MessageImportance importance, string message, p
         /// <param name="messageArgs">Parameters for the resource string</param>
         internal void LogError(BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogError(_eventContext, file, messageResourceName, messageArgs);
             _hasLoggedErrors = true;
         }
@@ -201,9 +201,9 @@ internal void LogError(BuildEventFileInfo file, string messageResourceName, para
         /// <param name="file">The file in which the error occurred</param>
         /// <param name="messageResourceName">The resource name for the error</param>
         /// <param name="messageArgs">Parameters for the resource string</param>
-        internal void LogErrorWithSubcategory(string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
+        internal void LogErrorWithSubcategory(string? subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogError(_eventContext, subcategoryResourceName, file, messageResourceName, messageArgs);
             _hasLoggedErrors = true;
         }
@@ -216,9 +216,9 @@ internal void LogErrorWithSubcategory(string subcategoryResourceName, BuildEvent
         /// <param name="helpKeyword">Help keyword</param>
         /// <param name="file">The file in which the error occurred</param>
         /// <param name="message">Error message</param>
-        internal void LogErrorFromText(string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message)
+        internal void LogErrorFromText(string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogErrorFromText(_eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
             _hasLoggedErrors = true;
         }
@@ -229,7 +229,7 @@ internal void LogErrorFromText(string subcategoryResourceName, string errorCode,
         /// <param name="invalidProjectFileException">The invalid Project File Exception which is to be logged</param>
         internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProjectFileException)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogInvalidProjectFileError(_eventContext, invalidProjectFileException);
             _hasLoggedErrors = true;
         }
@@ -241,16 +241,16 @@ internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProj
         /// <param name="file">The file in which the error occurred</param>
         /// <param name="messageResourceName">The string resource which has the formatting string for the error</param>
         /// <param name="messageArgs">The arguments for the error message</param>
-        internal void LogFatalError(Exception exception, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
+        internal void LogFatalError(Exception exception, BuildEventFileInfo file, string messageResourceName, params object?[]? messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogFatalError(_eventContext, exception, file, messageResourceName, messageArgs);
             _hasLoggedErrors = true;
         }
 
         internal void LogWarning(string messageResourceName, params object[] messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogWarning(_eventContext, null, BuildEventFileInfo.Empty, messageResourceName, messageArgs);
         }
 
@@ -261,9 +261,9 @@ internal void LogWarning(string messageResourceName, params object[] messageArgs
         /// <param name="file">The file in which the warning occurred</param>
         /// <param name="messageResourceName">The string resource which contains the formatted warning string</param>
         /// <param name="messageArgs">parameters for the string resource</param>
-        internal void LogWarning(string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object[] messageArgs)
+        internal void LogWarning(string? subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, params object?[]? messageArgs)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogWarning(_eventContext, subcategoryResourceName, file, messageResourceName, messageArgs);
         }
 
@@ -275,9 +275,9 @@ internal void LogWarning(string subcategoryResourceName, BuildEventFileInfo file
         /// <param name="helpKeyword"> Help keyword</param>
         /// <param name="file">The file in which the warning occurred</param>
         /// <param name="message">The message to be logged as a warning</param>
-        internal void LogWarningFromText(string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message)
+        internal void LogWarningFromText(string? subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message)
         {
-            ErrorUtilities.VerifyThrow(_isValid, "must be valid");
+            CheckValidity();
             _loggingService.LogWarningFromText(_eventContext, subcategoryResourceName, warningCode, helpKeyword, file, message);
         }
 
@@ -287,7 +287,7 @@ internal void LogWarningFromText(string subcategoryResourceName, string warningC
         /// <param name="buildEvent">The event to log</param>
         internal void LogBuildEvent(BuildEventArgs buildEvent)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             LoggingService.LogBuildEvent(buildEvent);
         }
 
@@ -298,7 +298,7 @@ internal void LogBuildEvent(BuildEventArgs buildEvent)
         /// <param name="file">The file in which the error occurred</param>
         internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             LoggingService.LogFatalBuildError(BuildEventContext, exception, file);
             _hasLoggedErrors = true;
         }
@@ -309,8 +309,27 @@ internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
         /// <param name="filePath">Path to response file</param>
         internal void LogIncludeFile(string filePath)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             _loggingService.LogIncludeFile(BuildEventContext, filePath);
         }
+
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo)
+            => _loggingService.BuildEngineDataRouter.ProcessPropertyRead(
+                    propertyReadInfo,
+                    new CheckLoggingContext(_loggingService, BuildEventContext));
+
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo)
+            => _loggingService.BuildEngineDataRouter.ProcessPropertyWrite(
+                    propertyWriteInfo,
+                    new CheckLoggingContext(_loggingService, BuildEventContext));
+
+        private protected void CheckValidity()
+        {
+            if (!_isValid)
+            {
+                ErrorUtilities.ThrowInternalError("LoggingContext (type: {0}) was not valid during logging attempt.",
+                    this.GetType());
+            }
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index a70ab4f9fb4..9a6df6ce995 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -9,12 +9,13 @@
 using System.Reflection;
 using System.Threading;
 using Microsoft.Build.BackEnd.Components.RequestBuilder;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
+using Microsoft.Build.Experimental.BuildCheck;
 
 #nullable disable
 
@@ -69,7 +70,7 @@ internal enum LoggingServiceState
     /// <summary>
     /// Logging services is used as a helper class to assist logging messages in getting to the correct loggers.
     /// </summary>
-    internal partial class LoggingService : ILoggingService, INodePacketHandler, IBuildComponent
+    internal partial class LoggingService : ILoggingService, INodePacketHandler
     {
         /// <summary>
         /// The default maximum size for the logging event queue.
@@ -356,6 +357,11 @@ protected LoggingService(LoggerMode loggerMode, int nodeId)
 
         #region Properties
 
+        /// <summary>
+        /// Router of the build engine runtime execution information.
+        /// </summary>
+        public IBuildEngineDataRouter BuildEngineDataRouter => this;
+
         /// <summary>
         /// Properties we need to serialize from the child node
         /// </summary>
@@ -923,7 +929,6 @@ public void PacketReceived(int node, INodePacket packet)
         private void WarnOnDeprecatedCustomArgsSerialization(LogMessagePacket loggingPacket)
         {
             if (loggingPacket.EventType == LoggingEventType.CustomEvent
-                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8)
                 && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
             {
                 BuildEventArgs buildEvent = loggingPacket.NodeBuildEvent.Value.Value;
@@ -1283,8 +1288,7 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         {
             if (loggingPacket?.NodeBuildEvent != null && _componentHost != null)
             {
-                var projectStartedEventArgs = loggingPacket.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
-                if (projectStartedEventArgs != null && _configCache.Value != null)
+                if (loggingPacket.NodeBuildEvent.Value.Value is ProjectStartedEventArgs projectStartedEventArgs && _configCache.Value != null)
                 {
                     ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectStartedEventArgs.ProjectId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
                     BuildRequestConfiguration buildRequestConfiguration = _configCache.Value[projectStartedEventArgs.ProjectId];
@@ -1295,6 +1299,12 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
                     s_projectStartedEventArgsGlobalProperties.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.GlobalProperties.ToDictionary(), index: null);
 
                     s_projectStartedEventArgsToolsVersion.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.ToolsVersion, null);
+
+                    // When logging happens out of process, we need to map the project context id to the project file on the receiving side.
+                    if (!_projectFileMap.ContainsKey(projectStartedEventArgs.BuildEventContext.ProjectContextId))
+                    {
+                        _projectFileMap[projectStartedEventArgs.BuildEventContext.ProjectContextId] = projectStartedEventArgs.ProjectFile;
+                    }
                 }
             }
         }
@@ -1592,6 +1602,12 @@ private void RouteBuildEvent(object loggingEvent)
                 _buildSubmissionIdsThatHaveLoggedErrors.Add(errorEvent.BuildEventContext?.SubmissionId ?? BuildEventContext.InvalidSubmissionId);
             }
 
+            if (buildEventArgs is BuildCheckResultError checkResultError)
+            {
+                // If the specified BuildCheckResultError was issued, an empty ISet<string> signifies that the specified build check warnings should be treated as errors.
+                AddWarningsAsErrors(checkResultError.BuildEventContext, new HashSet<string>());
+            }
+
             if (buildEventArgs is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
             {
                 WarningsConfigKey key = GetWarningsConfigKey(projectFinishedEvent);
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 547554d06d8..40762761917 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -4,6 +4,9 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Shared;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
@@ -69,17 +72,8 @@ public void LogCommentFromText(BuildEventContext buildEventContext, MessageImpor
         {
             if (!OnlyLogCriticalEvents)
             {
-                ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext was null");
-                ErrorUtilities.VerifyThrow(message != null, "message was null");
+                BuildMessageEventArgs buildEvent = EventsCreatorHelper.CreateMessageEventFromText(buildEventContext, importance, message, messageArgs);
 
-                BuildMessageEventArgs buildEvent = new BuildMessageEventArgs(
-                        message,
-                        helpKeyword: null,
-                        senderName: "MSBuild",
-                        importance,
-                        DateTime.UtcNow,
-                        messageArgs);
-                buildEvent.BuildEventContext = buildEventContext;
                 ProcessLoggingEvent(buildEvent);
             }
         }
@@ -136,31 +130,8 @@ public void LogError(BuildEventContext buildEventContext, string subcategoryReso
         /// <exception cref="InternalErrorException">Message is null</exception>
         public void LogErrorFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message)
         {
-            ErrorUtilities.VerifyThrow(buildEventContext != null, "Must specify the buildEventContext");
-            ErrorUtilities.VerifyThrow(file != null, "Must specify the associated file.");
-            ErrorUtilities.VerifyThrow(message != null, "Need error message.");
-
-            string subcategory = null;
-
-            if (subcategoryResourceName != null)
-            {
-                subcategory = AssemblyResources.GetString(subcategoryResourceName);
-            }
-
-            BuildErrorEventArgs buildEvent =
-            new BuildErrorEventArgs(
-                subcategory,
-                errorCode,
-                file.File,
-                file.Line,
-                file.Column,
-                file.EndLine,
-                file.EndColumn,
-                message,
-                helpKeyword,
-                "MSBuild");
+            BuildErrorEventArgs buildEvent = EventsCreatorHelper.CreateErrorEventFromText(buildEventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
 
-            buildEvent.BuildEventContext = buildEventContext;
             if (buildEvent.ProjectFile == null && buildEventContext.ProjectContextId != BuildEventContext.InvalidProjectContextId)
             {
                 _projectFileMap.TryGetValue(buildEventContext.ProjectContextId, out string projectFile);
@@ -420,6 +391,15 @@ public void LogBuildFinished(bool success)
             WaitForLoggingToProcessEvents();
         }
 
+        /// <inheritdoc />
+        public void LogBuildCanceled()
+        {
+            string message = ResourceUtilities.GetResourceString("AbortingBuild"); 
+            BuildCanceledEventArgs buildEvent = new BuildCanceledEventArgs(message);
+
+            ProcessLoggingEvent(buildEvent);
+        }
+
         /// <inheritdoc />
         public BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId)
             => new BuildEventContext(submissionId, nodeId, NextEvaluationId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
@@ -817,5 +797,14 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
         }
 
         #endregion
+
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
+            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyRead(propertyReadInfo, checkContext);
+
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
+            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyWrite(propertyWriteInfo, checkContext);
+
+        public void ProcessProjectEvaluationStarted(ICheckContext checkContext, string projectFullPath)
+            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessProjectEvaluationStarted(checkContext, projectFullPath);
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
index 36138422b00..5676d9fecf1 100644
--- a/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/NodeLoggingContext.cs
@@ -90,16 +90,16 @@ internal void LogRequestHandledFromCache(BuildRequest request, BuildRequestConfi
 
             // When pulling a request from the cache, we want to make sure we log a target skipped event for any targets which
             // were used to build the request including default and initial targets.
-            foreach (string target in configuration.GetTargetsUsedToBuildRequest(request))
+            foreach ((string name, TargetBuiltReason reason) target in configuration.GetTargetsUsedToBuildRequest(request))
             {
-                var targetResult = result[target];
+                var targetResult = result[target.name];
                 bool isFailure = targetResult.ResultCode == TargetResultCode.Failure;
 
                 var skippedTargetEventArgs = new TargetSkippedEventArgs(message: null)
                 {
                     BuildEventContext = projectLoggingContext.BuildEventContext,
-                    TargetName = target,
-                    BuildReason = TargetBuiltReason.None,
+                    TargetName = target.name,
+                    BuildReason = target.reason,
                     SkipReason = isFailure ? TargetSkipReason.PreviouslyBuiltUnsuccessfully : TargetSkipReason.PreviouslyBuiltSuccessfully,
                     OriginallySucceeded = !isFailure,
                     OriginalBuildEventContext = (targetResult as TargetResult)?.OriginalBuildEventContext
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index eaf5e31be4f..49a3cd48fb7 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -3,6 +3,7 @@
 
 using System.Collections;
 using System.Collections.Generic;
+using System.Configuration;
 using System.Linq;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
@@ -85,19 +86,54 @@ private ProjectLoggingContext(
             BuildEventContext parentBuildEventContext,
             int evaluationId,
             int projectContextId)
-            : base(nodeLoggingContext)
+            : base(nodeLoggingContext,
+                CreateInitialContext(nodeLoggingContext,
+                    submissionId,
+                     configurationId,
+                    projectFullPath,
+                    targets,
+                    toolsVersion,
+                    projectProperties,
+                    projectItems,
+                    parentBuildEventContext,
+                    evaluationId,
+                    projectContextId))
         {
             _projectFullPath = projectFullPath;
 
+            // No need to log a redundant message in the common case
+            if (toolsVersion != "Current")
+            {
+                LoggingService.LogComment(this.BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", toolsVersion);
+            }
+
+            this.IsValid = true;
+        }
+
+        private static BuildEventContext CreateInitialContext(
+            NodeLoggingContext nodeLoggingContext,
+            int submissionId,
+            int configurationId,
+            string projectFullPath,
+            List<string> targets,
+            string toolsVersion,
+            PropertyDictionary<ProjectPropertyInstance> projectProperties,
+            IItemDictionary<ProjectItemInstance> projectItems,
+            BuildEventContext parentBuildEventContext,
+            int evaluationId,
+            int projectContextId)
+        {
             IEnumerable<DictionaryEntry> properties = null;
             IEnumerable<DictionaryEntry> items = null;
 
-            string[] propertiesToSerialize = LoggingService.PropertiesToSerialize;
+            ILoggingService loggingService = nodeLoggingContext.LoggingService;
+
+            string[] propertiesToSerialize = loggingService.PropertiesToSerialize;
 
             // If we are only logging critical events lets not pass back the items or properties
-            if (!LoggingService.OnlyLogCriticalEvents &&
-                !LoggingService.IncludeEvaluationPropertiesAndItems &&
-                (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
+            if (!loggingService.OnlyLogCriticalEvents &&
+                !loggingService.IncludeEvaluationPropertiesAndItems &&
+                (!loggingService.RunningOnRemoteNode || loggingService.SerializeAllProperties))
             {
                 if (projectProperties is null)
                 {
@@ -116,9 +152,9 @@ private ProjectLoggingContext(
             }
 
             if (projectProperties != null &&
-                !LoggingService.IncludeEvaluationPropertiesAndItems &&
+                !loggingService.IncludeEvaluationPropertiesAndItems &&
                 propertiesToSerialize?.Length > 0 &&
-                !LoggingService.SerializeAllProperties)
+                !loggingService.SerializeAllProperties)
             {
                 PropertyDictionary<ProjectPropertyInstance> projectPropertiesToSerialize = new PropertyDictionary<ProjectPropertyInstance>();
                 foreach (string propertyToGet in propertiesToSerialize)
@@ -135,7 +171,7 @@ private ProjectLoggingContext(
                 properties = projectPropertiesToSerialize.Select((ProjectPropertyInstance property) => new DictionaryEntry(property.Name, property.EvaluatedValue));
             }
 
-            this.BuildEventContext = LoggingService.LogProjectStarted(
+            return loggingService.LogProjectStarted(
                 nodeLoggingContext.BuildEventContext,
                 submissionId,
                 configurationId,
@@ -146,14 +182,6 @@ private ProjectLoggingContext(
                 items,
                 evaluationId,
                 projectContextId);
-
-            // No need to log a redundant message in the common case
-            if (toolsVersion != "Current")
-            {
-                LoggingService.LogComment(this.BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", toolsVersion);
-            }
-
-            this.IsValid = true;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index af37bd0f690..d68f04e2bfa 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -37,15 +37,25 @@ internal class TargetLoggingContext : BuildLoggingContext
         /// Creates a new target logging context from an existing project context and target.
         /// </summary>
         internal TargetLoggingContext(ProjectLoggingContext projectLoggingContext, string projectFullPath, ProjectTargetInstance target, string parentTargetName, TargetBuiltReason buildReason)
-            : base(projectLoggingContext)
+            : base(projectLoggingContext, CreateInitialContext(projectLoggingContext, projectFullPath, target, parentTargetName, buildReason))
         {
             _projectLoggingContext = projectLoggingContext;
             _target = target;
 
-            this.BuildEventContext = LoggingService.LogTargetStarted(projectLoggingContext.BuildEventContext, target.Name, projectFullPath, target.Location.File, parentTargetName, buildReason);
             this.IsValid = true;
         }
 
+        private static BuildEventContext CreateInitialContext(ProjectLoggingContext projectLoggingContext,
+            string projectFullPath, ProjectTargetInstance target, string parentTargetName,
+            TargetBuiltReason buildReason)
+        {
+            BuildEventContext buildEventContext = projectLoggingContext.LoggingService.LogTargetStarted(
+                projectLoggingContext.BuildEventContext, target.Name, projectFullPath, target.Location.File,
+                parentTargetName, buildReason);
+
+            return buildEventContext;
+        }
+
         /// <summary>
         /// Constructor used to support out-of-proc task host (proxy for in-proc logging service.)
         /// </summary>
@@ -91,7 +101,7 @@ internal ProjectTargetInstance Target
         /// </summary>
         internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnumerable<TaskItem> targetOutputs)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "Should be valid");
+            this.CheckValidity();
 
             TargetOutputItemsInstanceEnumeratorProxy targetOutputWrapper = null;
 
@@ -110,7 +120,7 @@ internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnum
         /// </summary>
         internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task, string taskAssemblyLocation)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "Should be valid");
+            this.CheckValidity();
 
             return new TaskLoggingContext(this, projectFullPath, task, taskAssemblyLocation);
         }
diff --git a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
index f962f3da74d..43d668805e4 100644
--- a/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TaskLoggingContext.cs
@@ -35,46 +35,50 @@ internal class TaskLoggingContext : BuildLoggingContext
         /// Constructs a task logging context from a parent target context and a task node.
         /// </summary>
         internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string projectFullPath, ProjectTargetInstanceChild task, string taskAssemblyLocation)
-            : base(targetLoggingContext)
+            : base(targetLoggingContext, CreateInitialContext(targetLoggingContext, projectFullPath, task, taskAssemblyLocation))
         {
             _targetLoggingContext = targetLoggingContext;
             _task = task;
+            _taskName = GetTaskName(task);
+            this.IsValid = true;
+        }
 
+        private static BuildEventContext CreateInitialContext(TargetLoggingContext targetLoggingContext,
+            string projectFullPath, ProjectTargetInstanceChild task, string taskAssemblyLocation)
+        {
+            BuildEventContext buildEventContext = targetLoggingContext.LoggingService.LogTaskStarted2(
+                targetLoggingContext.BuildEventContext,
+                GetTaskName(task),
+                projectFullPath,
+                task.Location.File,
+                task.Location.Line,
+                task.Location.Column,
+                taskAssemblyLocation);
+
+            return buildEventContext;
+        }
+
+        private static string GetTaskName(ProjectTargetInstanceChild task)
+        {
             ProjectTaskInstance taskInstance = task as ProjectTaskInstance;
             if (taskInstance != null)
             {
-                _taskName = taskInstance.Name;
+                return taskInstance.Name;
             }
-            else
+
+            ProjectPropertyGroupTaskInstance propertyGroupInstance = task as ProjectPropertyGroupTaskInstance;
+            if (propertyGroupInstance != null)
             {
-                ProjectPropertyGroupTaskInstance propertyGroupInstance = task as ProjectPropertyGroupTaskInstance;
-                if (propertyGroupInstance != null)
-                {
-                    _taskName = "PropertyGroup";
-                }
-                else
-                {
-                    ProjectItemGroupTaskInstance itemGroupInstance = task as ProjectItemGroupTaskInstance;
-                    if (itemGroupInstance != null)
-                    {
-                        _taskName = "ItemGroup";
-                    }
-                    else
-                    {
-                        _taskName = "Unknown";
-                    }
-                }
+                return "PropertyGroup";
             }
 
-            this.BuildEventContext = LoggingService.LogTaskStarted2(
-                targetLoggingContext.BuildEventContext,
-                _taskName,
-                projectFullPath,
-                task.Location.File,
-                task.Location.Line,
-                task.Location.Column,
-                taskAssemblyLocation);
-            this.IsValid = true;
+            ProjectItemGroupTaskInstance itemGroupInstance = task as ProjectItemGroupTaskInstance;
+            if (itemGroupInstance != null)
+            {
+                return "ItemGroup";
+            }
+
+            return "Unknown";
         }
 
         /// <summary>
@@ -143,7 +147,7 @@ internal void LogTaskBatchFinished(string projectFullPath, bool success)
         /// <param name="taskName">The task in which the warning occurred</param>
         internal void LogTaskWarningFromException(Exception exception, BuildEventFileInfo file, string taskName)
         {
-            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            CheckValidity();
             LoggingService.LogTaskWarningFromException(BuildEventContext, exception, file, taskName);
         }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index e53d28292d1..d573f4bdc74 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -454,7 +454,7 @@ public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancel
 
                 BuildRequestData buildRequest = new BuildRequestData(
                     cacheRequest.Configuration.Project,
-                    cacheRequest.Submission.BuildRequestData.TargetNames.ToArray());
+                    cacheRequest.Submission.BuildRequestData?.TargetNames.ToArray() ?? Array.Empty<string>());
                 BuildEventContext buildEventContext = _loggingService.CreateProjectCacheBuildEventContext(
                     cacheRequest.Submission.SubmissionId,
                     evaluationId: cacheRequest.Configuration.Project.EvaluationId,
@@ -477,13 +477,16 @@ public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancel
 
             void EvaluateProjectIfNecessary(BuildSubmission submission, BuildRequestConfiguration configuration)
             {
+                ErrorUtilities.VerifyThrow(submission.BuildRequestData != null,
+                    "Submission BuildRequestData is not populated.");
+
                 lock (configuration)
                 {
                     if (!configuration.IsLoaded)
                     {
                         configuration.LoadProjectIntoConfiguration(
                             _buildManager,
-                            submission.BuildRequestData.Flags,
+                            submission.BuildRequestData!.Flags,
                             submission.SubmissionId,
                             Scheduler.InProcNodeId);
 
@@ -519,7 +522,7 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
 
             HashSet<ProjectCacheDescriptor> queriedCaches = new(ProjectCacheDescriptorEqualityComparer.Instance);
             CacheResult? cacheResult = null;
-            foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(buildRequest.ProjectInstance))
+            foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(buildRequest.ProjectInstance!))
             {
                 // Ensure each unique plugin is only queried once
                 if (!queriedCaches.Add(projectCacheDescriptor))
@@ -583,7 +586,7 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
                     // TODO: This should be indented by the console logger. That requires making these log events structured.
                     if (!buildRequestConfiguration.IsTraversal)
                     {
-                        _loggingService.LogComment(buildEventContext, MessageImportance.High, "ProjectCacheHitWithOutputs", buildRequest.ProjectInstance.GetPropertyValue(ReservedPropertyNames.projectName));
+                        _loggingService.LogComment(buildEventContext, MessageImportance.High, "ProjectCacheHitWithOutputs", buildRequest.ProjectInstance!.GetPropertyValue(ReservedPropertyNames.projectName));
                     }
 
                     break;
@@ -734,7 +737,7 @@ public async Task HandleBuildResultAsync(
 
             IReadOnlyDictionary<string, string> globalProperties = GetGlobalProperties(requestConfiguration);
 
-            List<string> targets = buildResult.ResultsByTarget.Keys.ToList();
+            List<string> targets = buildResult.ResultsByTarget?.Keys.ToList() ?? new();
             string? targetNames = string.Join(", ", targets);
 
             FileAccessContext fileAccessContext = new(requestConfiguration.ProjectFullPath, globalProperties, targets);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 14150696614..5fd70efcc79 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -66,7 +66,7 @@ public static IDisposable StartTracking(
 #if FEATURE_APPDOMAIN
         public static void StopTracking(AppDomain appDomain)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && !appDomain.IsDefaultAppDomain())
+            if (!appDomain.IsDefaultAppDomain())
             {
                 lock (s_instances)
                 {
@@ -106,20 +106,15 @@ private static IDisposable StartTracking(
             string? initiatorName,
             AppDomain? appDomain)
         {
-            if (
-                // Feature is not enabled
-                !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
+            if (// We do not want to load all assembly loads (including those triggered by builtin types)
+                !Traits.Instance.LogAllAssemblyLoads &&
                 (
-                    // We do not want to load all assembly loads (including those triggered by builtin types)
-                    !Traits.Instance.LogAllAssemblyLoads &&
-                    (
-                        // Load will be initiated by internal type - so we are not interested in those
-                        initiatorType?.Assembly == Assembly.GetExecutingAssembly()
-                        ||
-                        IsBuiltinType(initiatorType?.FullName)
-                        ||
-                        IsBuiltinType(initiatorName)
-                    )
+                    // Load will be initiated by internal type - so we are not interested in those
+                    initiatorType?.Assembly == Assembly.GetExecutingAssembly()
+                    ||
+                    IsBuiltinType(initiatorType?.FullName)
+                    ||
+                    IsBuiltinType(initiatorName)
                 )
             )
             {
@@ -171,7 +166,9 @@ private void CurrentDomainOnAssemblyLoad(object? sender, AssemblyLoadEventArgs a
             if (_loggingContext?.BuildEventContext != null)
             {
                 buildArgs.BuildEventContext = _loggingContext.BuildEventContext;
-                _loggingContext.LogBuildEvent(buildArgs);
+                // bypass the logging context validity check: it's possible that the load happened
+                // on a thread unrelated to the context we're tracking loads in
+                _loggingContext.LoggingService.LogBuildEvent(buildArgs);
             }
             _loggingService?.LogBuildEvent(buildArgs);
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilder.cs
index 51bbb39a2d9..d986c91992c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ITargetBuilder.cs
@@ -4,6 +4,7 @@
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
 using BuildResult = Microsoft.Build.Execution.BuildResult;
 
 #nullable disable
@@ -25,6 +26,6 @@ internal interface ITargetBuilder
         /// <param name="baseLookup">The Lookup containing all current items and properties for this target.</param>
         /// <param name="cancellationToken">The cancellation token used to cancel processing of targets.</param>
         /// <returns>A Task representing the work to be done.</returns>
-        Task<BuildResult> BuildTargets(ProjectLoggingContext projectLoggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, string[] targets, Lookup baseLookup, CancellationToken cancellationToken);
+        Task<BuildResult> BuildTargets(ProjectLoggingContext projectLoggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, (string name, TargetBuiltReason reason)[] targets, Lookup baseLookup, CancellationToken cancellationToken);
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index e32f6cd94d1..2a9cc0e26b0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -182,8 +182,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 if (condition)
                 {
                     ExpanderOptions expanderOptions = ExpanderOptions.ExpandAll;
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) &&
-                        // If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
+                    if (// If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
                         bucket.BucketSequenceNumber == 0 &&
                         // Referring to unqualified metadata of other item (transform) is fine.
                         child.Include.IndexOf("@(", StringComparison.Ordinal) == -1)
@@ -457,7 +456,8 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
                             includeSplit /* before wildcard expansion */,
                             null,
                             null,
-                            originalItem.Location.File));
+                            originalItem.Location.File,
+                            useItemDefinitionsWithoutModification: false));
                     }
                 }
             }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
index 18d85f2323c..02ca6a1dab8 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
@@ -4,6 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -90,6 +91,7 @@ internal override void ExecuteTask(Lookup lookup)
                             }
 
                             bucket.Lookup.SetProperty(ProjectPropertyInstance.Create(property.Name, evaluatedValue, property.Location, Project.IsImmutable));
+                            LoggingContext.ProcessPropertyWrite(new PropertyWriteInfo(property.Name, string.IsNullOrEmpty(evaluatedValue), property.Location));
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 577fc877071..27bc3fa75be 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -10,13 +10,13 @@
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -1105,9 +1105,13 @@ private async Task<BuildResult> BuildProject()
             ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
 
             // We consider this the entrypoint for the project build for purposes of BuildCheck processing 
+            bool isRestoring = _requestEntry.RequestConfiguration.GlobalProperties[MSBuildConstants.MSBuildIsRestoring] is null;
+
+            var buildCheckManager = isRestoring
+                ? (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance
+                : null;
 
-            var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
-            buildCheckManager.SetDataSource(BuildCheckDataSource.BuildExecution);
+            buildCheckManager?.SetDataSource(BuildCheckDataSource.BuildExecution);
 
             // Make sure it is null before loading the configuration into the request, because if there is a problem
             // we do not wand to have an invalid projectLoggingContext floating around. Also if this is null the error will be
@@ -1121,9 +1125,9 @@ private async Task<BuildResult> BuildProject()
                 // Load the project
                 if (!_requestEntry.RequestConfiguration.IsLoaded)
                 {
-                    buildCheckManager.StartProjectEvaluation(
+                    buildCheckManager?.ProjectFirstEncountered(
                         BuildCheckDataSource.BuildExecution,
-                        _requestEntry.Request.ParentBuildEventContext,
+                        new CheckLoggingContext(_nodeLoggingContext.LoggingService, _requestEntry.Request.BuildEventContext),
                         _requestEntry.RequestConfiguration.ProjectFullPath);
 
                     _requestEntry.RequestConfiguration.LoadProjectIntoConfiguration(
@@ -1146,15 +1150,14 @@ private async Task<BuildResult> BuildProject()
             }
             finally
             {
-                buildCheckManager.EndProjectEvaluation(
-                    BuildCheckDataSource.BuildExecution,
-                    _requestEntry.Request.ParentBuildEventContext);
+                buildCheckManager?.EndProjectEvaluation(
+                    _requestEntry.Request.BuildEventContext);
             }
 
             _projectLoggingContext = _nodeLoggingContext.LogProjectStarted(_requestEntry);
-            buildCheckManager.StartProjectRequest(
-                BuildCheckDataSource.BuildExecution,
-                _requestEntry.Request.ParentBuildEventContext);
+            buildCheckManager?.StartProjectRequest(
+                _projectLoggingContext.BuildEventContext,
+                _requestEntry.RequestConfiguration.ProjectFullPath);
 
             try
             {
@@ -1177,7 +1180,7 @@ private async Task<BuildResult> BuildProject()
                 _requestEntry.Request.BuildEventContext = _projectLoggingContext.BuildEventContext;
 
                 // Determine the set of targets we need to build
-                string[] allTargets = _requestEntry.RequestConfiguration
+                (string name, TargetBuiltReason reason)[] allTargets = _requestEntry.RequestConfiguration
                     .GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
 
                 ProjectErrorUtilities.VerifyThrowInvalidProject(allTargets.Length > 0,
@@ -1223,9 +1226,9 @@ private async Task<BuildResult> BuildProject()
             }
             finally
             {
-                buildCheckManager.EndProjectRequest(
-                    BuildCheckDataSource.BuildExecution,
-                    _requestEntry.Request.ParentBuildEventContext);
+                buildCheckManager?.EndProjectRequest(
+                    new CheckLoggingContext(_nodeLoggingContext.LoggingService, _projectLoggingContext.BuildEventContext),
+                    _requestEntry.RequestConfiguration.ProjectFullPath);
             }
 
             BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFromTargetBuilder)
@@ -1402,10 +1405,7 @@ private void ConfigureKnownImmutableFolders()
             ProjectInstance project = _requestEntry?.RequestConfiguration?.Project;
             if (project != null)
             {
-                // example: C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.7.2
-                FileClassifier.Shared.RegisterImmutableDirectory(project.GetPropertyValue("FrameworkPathOverride")?.Trim());
-                // example: C:\Program Files\dotnet\
-                FileClassifier.Shared.RegisterImmutableDirectory(project.GetPropertyValue("NetCoreRoot")?.Trim());
+                FileClassifier.Shared.RegisterKnownImmutableLocations(project.GetPropertyValue);
             }
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 6ff9319f3eb..4961d48c59e 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -100,7 +100,7 @@ internal class TargetBuilder : ITargetBuilder, ITargetBuilderCallback, IBuildCom
         /// <param name="baseLookup">The Lookup containing all current items and properties for this target.</param>
         /// <param name="cancellationToken">The <see cref="CancellationToken"/> to use when building the targets.</param>
         /// <returns>The target's outputs and result codes</returns>
-        public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, string[] targetNames, Lookup baseLookup, CancellationToken cancellationToken)
+        public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, (string name, TargetBuiltReason reason)[] targetNames, Lookup baseLookup, CancellationToken cancellationToken)
         {
             ErrorUtilities.VerifyThrowArgumentNull(loggingContext, "projectLoggingContext");
             ErrorUtilities.VerifyThrowArgumentNull(entry, nameof(entry));
@@ -143,17 +143,17 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
 
             List<TargetSpecification> targets = new List<TargetSpecification>(targetNames.Length);
 
-            foreach (string targetName in targetNames)
+            foreach ((string name, TargetBuiltReason reason) targetName in targetNames)
             {
-                var targetExists = _projectInstance.Targets.TryGetValue(targetName, out ProjectTargetInstance targetInstance);
+                var targetExists = _projectInstance.Targets.TryGetValue(targetName.name, out ProjectTargetInstance targetInstance);
                 if (!targetExists && entry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.SkipNonexistentTargets))
                 {
                     _projectLoggingContext.LogComment(Framework.MessageImportance.Low,
-                        "TargetSkippedWhenSkipNonexistentTargets", targetName);
+                        "TargetSkippedWhenSkipNonexistentTargets", targetName.name);
                 }
                 else
                 {
-                    targets.Add(new TargetSpecification(targetName, targetExists ? targetInstance.Location : _projectInstance.ProjectFileLocation));
+                    targets.Add(new TargetSpecification(targetName.name, targetExists ? targetInstance.Location : _projectInstance.ProjectFileLocation, targetName.reason));
                 }
             }
 
@@ -185,7 +185,7 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
 
             // Gather up outputs for the requested targets and return those.  All of our information should be in the base lookup now.
             ComputeAfterTargetFailures(targetNames);
-            BuildResult resultsToReport = new BuildResult(_buildResult, targetNames);
+            BuildResult resultsToReport = new BuildResult(_buildResult, targetNames.Select(target => target.name).ToArray());
 
             // Return after-build project state if requested.
             if (_requestEntry.Request.BuildRequestDataFlags.HasFlag(BuildRequestDataFlags.ProvideProjectStateAfterBuild))
@@ -735,9 +735,14 @@ private async Task<bool> PushTargets(IList<TargetSpecification> targets, TargetE
                     }
                 }
 
+                // The buildReason argument for this function can be BeforeTargets or AfterTargets, we don't want to override the reason when adding a new entry
+                // If the reason is None, it means it does not depend on another target. So we can use the target's BuiltReason.
+                TargetBuiltReason entryReason = buildReason == TargetBuiltReason.None ? targetSpecification._targetBuiltReason : buildReason;
+
                 // Add to the list of targets to push.  We don't actually put it on the stack here because we could run into a circular dependency
                 // during this loop, in which case the target stack would be out of whack.
-                TargetEntry newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, buildReason, _componentHost, _projectLoggingContext, stopProcessingOnCompletion);
+                TargetEntry newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, entryReason, _componentHost, _projectLoggingContext, stopProcessingOnCompletion);
+
                 newEntry.ErrorTarget = addAsErrorTarget;
                 targetsToPush.Add(newEntry);
                 stopProcessingOnCompletion = false; // The first target on the stack (the last one to be run) always inherits the stopProcessing flag.
@@ -772,15 +777,15 @@ private async Task<bool> CompleteOutstandingActiveRequests(string targetName)
             return false;
         }
 
-        private void ComputeAfterTargetFailures(string[] targetNames)
+        private void ComputeAfterTargetFailures((string name, TargetBuiltReason reason)[] targetNames)
         {
-            foreach (string targetName in targetNames)
+            foreach ((string name, TargetBuiltReason reason) targetName in targetNames)
             {
-                if (_buildResult.ResultsByTarget.TryGetValue(targetName, out TargetResult targetBuildResult))
+                if (_buildResult.ResultsByTarget.TryGetValue(targetName.name, out TargetResult targetBuildResult))
                 {
                     // Queue of targets waiting to be processed, seeded with the specific target for which we're computing AfterTargetsHaveFailed.
                     var targetsToCheckForAfterTargets = new Queue<string>();
-                    targetsToCheckForAfterTargets.Enqueue(targetName);
+                    targetsToCheckForAfterTargets.Enqueue(targetName.name);
 
                     // Set of targets already processed, to break cycles of AfterTargets.
                     // Initialized lazily when needed below.
@@ -804,7 +809,7 @@ private void ComputeAfterTargetFailures(string[] targetNames)
 
                             targetsChecked ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default)
                                 {
-                                    targetName
+                                    targetName.name
                                 };
 
                             // If we haven't seen this target yet, add it to the list to check.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
index a3297139fa8..4de22a23cce 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetSpecification.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 
@@ -18,18 +19,22 @@ internal class TargetSpecification : ITranslatable
         private string _targetName;
         private ElementLocation _referenceLocation;
 
+        internal TargetBuiltReason _targetBuiltReason;
+
         /// <summary>
         /// Construct a target specification.
         /// </summary>
         /// <param name="targetName">The name of the target</param>
         /// <param name="referenceLocation">The location from which it was referred.</param>
-        internal TargetSpecification(string targetName, ElementLocation referenceLocation)
+        /// <param name="targetBuiltReason">Reason the target is being built</param>
+        internal TargetSpecification(string targetName, ElementLocation referenceLocation, TargetBuiltReason targetBuiltReason = TargetBuiltReason.None)
         {
             ErrorUtilities.VerifyThrowArgumentLength(targetName, nameof(targetName));
             ErrorUtilities.VerifyThrowArgumentNull(referenceLocation, nameof(referenceLocation));
 
             this._targetName = targetName;
             this._referenceLocation = referenceLocation;
+            this._targetBuiltReason = targetBuiltReason;
         }
 
         private TargetSpecification()
@@ -41,6 +46,8 @@ private TargetSpecification()
         /// </summary>
         public string TargetName => _targetName;
 
+        public TargetBuiltReason TargetBuiltReason => _targetBuiltReason;
+
         /// <summary>
         /// Gets or sets the reference location
         /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index a7f54890bbd..9de6967036e 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -119,22 +119,11 @@ internal virtual IReadOnlyList<SdkResolverManifest> FindPotentialSdkResolversMan
                 var assembly = Path.Combine(subfolder.FullName, $"{subfolder.Name}.dll");
                 bool assemblyAdded = false;
 
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    // Prefer manifest over the assembly. Try to read the xml first, and if not found then look for an assembly.
-                    assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
-                    if (!assemblyAdded)
-                    {
-                        assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
-                    }
-                }
-                else
+                // Prefer manifest over the assembly. Try to read the xml first, and if not found then look for an assembly.
+                assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
+                if (!assemblyAdded)
                 {
                     assemblyAdded = TryAddAssemblyManifestFromDll(assembly, manifestsList);
-                    if (!assemblyAdded)
-                    {
-                        assemblyAdded = TryAddAssemblyManifestFromXml(manifest, subfolder.FullName, manifestsList, location);
-                    }
                 }
 
                 if (!assemblyAdded)
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 5b0265c8ae2..252bf62ab14 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -40,14 +40,6 @@ internal class SdkResolverService : ISdkResolverService
         /// </summary>
         private readonly ConcurrentDictionary<int, ConcurrentDictionary<SdkResolver, object>> _resolverStateBySubmission = new ConcurrentDictionary<int, ConcurrentDictionary<SdkResolver, object>>();
 
-        /// <summary>
-        /// Stores the list of SDK resolvers which were loaded.
-        /// </summary>
-        /// <remarks>
-        /// Need it for supporting the ChangeWave less than <see cref="ChangeWaves.Wave17_4"/>. Remove when move out Wave17_4.
-        /// </remarks>
-        private IReadOnlyList<SdkResolver> _resolversList;
-
         /// <summary>
         /// Stores the loaded SDK resolvers, mapped to the manifest from which they came.
         /// </summary>
@@ -118,7 +110,7 @@ public virtual void ClearCaches()
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
         public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
-            // If we are running in .NET core, we ask the built-in default resolver first.
+                        // If we are running in .NET core, we ask the built-in default resolver first.
             // - It is a perf optimization (no need to discover and load any of the plug-in assemblies to resolve an "in-box" Sdk).
             // - It brings `dotnet build` to parity with `MSBuild.exe` functionally, as the Framework build of Microsoft.DotNet.MSBuildSdkResolver
             //   contains the same logic and it is the first resolver in priority order.
@@ -165,27 +157,8 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
                 }
             }
 #endif
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-            {
-                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
-            }
-            else
-            {
-                SdkResult result = ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings);
-
-                // Warnings are already logged on success.
-                if (!result.Success)
-                {
-                    if (failOnUnresolvedSdk)
-                    {
-                        loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
-                    }
-
-                    LogWarnings(loggingContext, sdkReferenceLocation, warnings);
-                }
 
-                return result;
-            }
+            return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
         }
 
         /// <remarks>
@@ -311,31 +284,6 @@ private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManif
             return resolvers;
         }
 
-        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings)
-        {
-            // Lazy initialize all SDK resolvers
-            if (_resolversList == null)
-            {
-                Initialize(sdkReferenceLocation);
-            }
-
-            TryResolveSdkUsingSpecifiedResolvers(
-                _resolversList,
-                submissionId,
-                sdk,
-                loggingContext,
-                sdkReferenceLocation,
-                solutionPath,
-                projectPath,
-                interactive,
-                isRunningInVisualStudio,
-                out SdkResult sdkResult,
-                out errors,
-                out warnings);
-
-            return sdkResult;
-        }
-
         private bool TryResolveSdkUsingSpecifiedResolvers(
             IReadOnlyList<SdkResolver> resolvers,
             int submissionId,
@@ -458,24 +406,16 @@ internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IReadO
             _specificResolversManifestsRegistry = null;
             _generalResolversManifestsRegistry = null;
             _manifestToResolvers = null;
-            _resolversList = null;
 
             if (resolvers != null)
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
-                    _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
-                    _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
+                _specificResolversManifestsRegistry = new List<SdkResolverManifest>();
+                _generalResolversManifestsRegistry = new List<SdkResolverManifest>();
+                _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
 
-                    SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
-                    _generalResolversManifestsRegistry.Add(sdkResolverManifest);
-                    _manifestToResolvers[sdkResolverManifest] = resolvers;
-                }
-                else
-                {
-                    _resolversList = resolvers;
-                }
+                SdkResolverManifest sdkResolverManifest = new SdkResolverManifest(DisplayName: "TestResolversManifest", Path: null, ResolvableSdkRegex: null);
+                _generalResolversManifestsRegistry.Add(sdkResolverManifest);
+                _manifestToResolvers[sdkResolverManifest] = resolvers;
             }
         }
 
@@ -517,19 +457,6 @@ private object GetResolverState(int submissionId, SdkResolver resolver)
             return null;
         }
 
-        private void Initialize(ElementLocation location)
-        {
-            lock (_lockObject)
-            {
-                if (_resolversList != null)
-                {
-                    return;
-                }
-
-                _resolversList = _sdkResolverLoader.LoadAllResolvers(location);
-            }
-        }
-
         private void RegisterResolversManifests(ElementLocation location)
         {
             lock (_lockObject)
@@ -587,7 +514,7 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
                     submissionId,
                     _ => new ConcurrentDictionary<SdkResolver, object>(
                         NativeMethodsShared.GetLogicalCoreCount(),
-                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) ? _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count : _resolversList.Count));
+                        _specificResolversManifestsRegistry.Count + _generalResolversManifestsRegistry.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 51ac31c32dd..14706fc57cd 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -303,6 +303,9 @@ IBuildComponent IBuildComponentHost.GetComponent(BuildComponentType type)
             return _componentFactories.GetComponent(type);
         }
 
+        TComponent IBuildComponentHost.GetComponent<TComponent>(BuildComponentType type)
+            => (TComponent)((IBuildComponentHost)this).GetComponent(type);
+
         #endregion
 
         #region INodePacketFactory Members
@@ -583,8 +586,6 @@ private void SendPacket(INodePacket packet)
 #if RUNTIME_TYPE_NETCORE
                 if (packet is LogMessagePacketBase logMessage
                     && logMessage.EventType == LoggingEventType.CustomEvent
-                    &&
-                    (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
                     && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
                 {
                     BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 4f9e62b9343..d409d52d057 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -409,8 +409,8 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)
             (int exitCode, string exitType) buildResult;
 
             // Dispose must be called before the server sends ServerNodeBuildResult packet
-            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, ConsoleOutput.Standard))))
-            using (var errWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, ConsoleOutput.Error))))
+            using (RedirectConsoleWriter outWriter = new(text => SendPacket(new ServerNodeConsoleWrite(text, ConsoleOutput.Standard))))
+            using (RedirectConsoleWriter errWriter = new(text => SendPacket(new ServerNodeConsoleWrite(text, ConsoleOutput.Error))))
             {
                 Console.SetOut(outWriter);
                 Console.SetError(errWriter);
@@ -438,112 +438,316 @@ internal sealed class RedirectConsoleWriter : TextWriter
         {
             private readonly Action<string> _writeCallback;
             private readonly Timer _timer;
-            private readonly TextWriter _syncWriter;
-
+            private readonly object _lock = new();
             private readonly StringWriter _internalWriter;
 
-            private RedirectConsoleWriter(Action<string> writeCallback)
+            public RedirectConsoleWriter(Action<string> writeCallback)
             {
                 _writeCallback = writeCallback;
                 _internalWriter = new StringWriter();
-                _syncWriter = Synchronized(_internalWriter);
                 _timer = new Timer(TimerCallback, null, 0, 40);
             }
 
             public override Encoding Encoding => _internalWriter.Encoding;
 
-            public static TextWriter Create(Action<string> writeCallback)
+            public override void Flush()
             {
-                RedirectConsoleWriter writer = new RedirectConsoleWriter(writeCallback);
+                lock (_lock)
+                {
+                    var sb = _internalWriter.GetStringBuilder();
+                    string captured = sb.ToString();
+                    sb.Clear();
 
-                return writer;
+                    _writeCallback(captured);
+                    _internalWriter.Flush();
+                }
             }
 
-            public override void Flush()
+            public override void Write(char value)
             {
-                var sb = _internalWriter.GetStringBuilder();
-                string captured = sb.ToString();
-                sb.Clear();
-
-                _writeCallback(captured);
-                _internalWriter.Flush();
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
             }
 
-            public override void Write(char value) => _syncWriter.Write(value);
+            public override void Write(char[]? buffer)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(buffer);
+                }
+            }
 
-            public override void Write(char[]? buffer) => _syncWriter.Write(buffer);
+            public override void Write(char[] buffer, int index, int count)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(buffer, index, count);
+                }
+            }
 
-            public override void Write(char[] buffer, int index, int count) => _syncWriter.Write(buffer, index, count);
+            public override void Write(bool value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(bool value) => _syncWriter.Write(value);
+            public override void Write(int value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(int value) => _syncWriter.Write(value);
+            public override void Write(uint value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(uint value) => _syncWriter.Write(value);
+            public override void Write(long value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(long value) => _syncWriter.Write(value);
+            public override void Write(ulong value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(ulong value) => _syncWriter.Write(value);
- 
-            public override void Write(float value) => _syncWriter.Write(value);
+            public override void Write(float value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(double value) => _syncWriter.Write(value);
+            public override void Write(double value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(decimal value) => _syncWriter.Write(value);
+            public override void Write(decimal value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(string? value) => _syncWriter.Write(value);
+            public override void Write(string? value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(object? value) => _syncWriter.Write(value);
+            public override void Write(object? value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(value);
+                }
+            }
 
-            public override void Write(string format, object? arg0) => _syncWriter.Write(format, arg0);
+            public override void Write(string format, object? arg0)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(format, arg0);
+                }
+            }
 
-            public override void Write(string format, object? arg0, object? arg1) => _syncWriter.Write(format, arg0, arg1);
+            public override void Write(string format, object? arg0, object? arg1)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(format, arg0, arg1);
+                }
+            }
 
-            public override void Write(string format, object? arg0, object? arg1, object? arg2) => _syncWriter.Write(format, arg0, arg1, arg2);
+            public override void Write(string format, object? arg0, object? arg1, object? arg2)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.Write(format, arg0, arg1, arg2);
+                }
+            }
 
-            public override void Write(string format, params object?[] arg) => _syncWriter.WriteLine(format, arg);
+            public override void Write(string format, params object?[] arg)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(format, arg);
+                }
+            }
 
-            public override void WriteLine() => _syncWriter.WriteLine();
+            public override void WriteLine()
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine();
+                }
+            }
 
-            public override void WriteLine(char value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(char value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(decimal value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(decimal value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(char[]? buffer) => _syncWriter.WriteLine(buffer);
+            public override void WriteLine(char[]? buffer)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(buffer);
+                }
+            }
 
-            public override void WriteLine(char[] buffer, int index, int count) => _syncWriter.WriteLine(buffer, index, count);
+            public override void WriteLine(char[] buffer, int index, int count)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(buffer, index, count);
+                }
+            }
 
-            public override void WriteLine(bool value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(bool value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(int value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(int value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(uint value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(uint value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(long value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(long value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(ulong value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(ulong value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(float value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(float value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(double value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(double value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(string? value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(string? value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(object? value) => _syncWriter.WriteLine(value);
+            public override void WriteLine(object? value)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(value);
+                }
+            }
 
-            public override void WriteLine(string format, object? arg0) => _syncWriter.WriteLine(format, arg0);
+            public override void WriteLine(string format, object? arg0)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(format, arg0);
+                }
+            }
 
-            public override void WriteLine(string format, object? arg0, object? arg1) => _syncWriter.WriteLine(format, arg0, arg1);
+            public override void WriteLine(string format, object? arg0, object? arg1)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(format, arg0, arg1);
+                }
+            }
 
-            public override void WriteLine(string format, object? arg0, object? arg1, object? arg2) => _syncWriter.WriteLine(format, arg0, arg1, arg2);
+            public override void WriteLine(string format, object? arg0, object? arg1, object? arg2)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(format, arg0, arg1, arg2);
+                }
+            }
 
-            public override void WriteLine(string format, params object?[] arg) => _syncWriter.WriteLine(format, arg);
+            public override void WriteLine(string format, params object?[] arg)
+            {
+                lock (_lock)
+                {
+                    _internalWriter.WriteLine(format, arg);
+                }
+            }
 
             private void TimerCallback(object? state)
             {
                 if (_internalWriter.GetStringBuilder().Length > 0)
                 {
-                    _syncWriter.Flush();
+                    Flush();
                 }
             }
 
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index c5ef050807f..3bca761aab7 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -762,7 +762,7 @@ public void RetrieveFromCache()
         /// </summary>
         /// <param name="request">The request </param>
         /// <returns>An array of t</returns>
-        public List<string> GetTargetsUsedToBuildRequest(BuildRequest request)
+        public List<(string name, TargetBuiltReason reason)> GetTargetsUsedToBuildRequest(BuildRequest request)
         {
             ErrorUtilities.VerifyThrow(request.ConfigurationId == ConfigurationId, "Request does not match configuration.");
             ErrorUtilities.VerifyThrow(_projectInitialTargets != null, "Initial targets have not been set.");
@@ -775,13 +775,31 @@ public List<string> GetTargetsUsedToBuildRequest(BuildRequest request)
                     "Targets must be same as proxy targets");
             }
 
-            List<string> initialTargets = _projectInitialTargets;
-            List<string> nonInitialTargets = (request.Targets.Count == 0) ? _projectDefaultTargets : request.Targets;
+            bool hasInitialTargets = request.Targets.Count == 0 ? false : true;
 
-            var allTargets = new List<string>(initialTargets.Count + nonInitialTargets.Count);
+            List<(string name, TargetBuiltReason reason)> allTargets = new(
+                _projectInitialTargets.Count +
+                (hasInitialTargets ? _projectDefaultTargets.Count : request.Targets.Count));
 
-            allTargets.AddRange(initialTargets);
-            allTargets.AddRange(nonInitialTargets);
+            foreach (var target in _projectInitialTargets)
+            {
+                allTargets.Add((target, TargetBuiltReason.InitialTargets));
+            }
+
+            if (hasInitialTargets)
+            {
+                foreach (var target in request.Targets)
+                {
+                    allTargets.Add((target, TargetBuiltReason.EntryTargets));
+                }
+            }
+            else
+            {
+                foreach (var target in _projectDefaultTargets)
+                {
+                    allTargets.Add((target, TargetBuiltReason.DefaultTargets));
+                }
+            }
 
             return allTargets;
         }
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 208fa2e7b9a..776179d0f03 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -9,8 +9,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-
-#nullable disable
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Execution
 {
@@ -33,7 +32,10 @@ public enum BuildResultCode
     /// <summary>
     /// Contains the current results for all of the targets which have produced results for a particular configuration.
     /// </summary>
-    public class BuildResult : INodePacket, IBuildResults
+    /// <remarks>
+    /// When modifying serialization/deserialization, bump the version and support previous versions in order to keep <see cref="ResultsCache"/> backwards compatible.
+    /// </remarks>
+    public class BuildResult : BuildResultBase, INodePacket, IBuildResults
     {
         /// <summary>
         /// The submission with which this result is associated.
@@ -64,19 +66,27 @@ public class BuildResult : INodePacket, IBuildResults
         /// The first build request to generate results for a configuration will set this so that future
         /// requests may be properly satisfied from the cache.
         /// </summary>
-        private List<string> _initialTargets;
+        private List<string>? _initialTargets;
 
         /// <summary>
         /// The first build request to generate results for a configuration will set this so that future
         /// requests may be properly satisfied from the cache.
         /// </summary>
-        private List<string> _defaultTargets;
+        private List<string>? _defaultTargets;
 
         /// <summary>
         /// The set of results for each target.
         /// </summary>
         private ConcurrentDictionary<string, TargetResult> _resultsByTarget;
 
+        /// <summary>
+        /// Version of the build result.
+        /// </summary>
+        /// <remarks>
+        /// Allows to serialize and deserialize different versions of the build result.
+        /// </remarks>
+        private int _version = Traits.Instance.EscapeHatches.DoNotVersionBuildResult ? 0 : 1;
+
         /// <summary>
         /// The request caused a circular dependency in scheduling.
         /// </summary>
@@ -87,7 +97,7 @@ public class BuildResult : INodePacket, IBuildResults
         /// Note that this can be set if the request itself fails, or if it receives
         /// an exception from a target or task.
         /// </summary>
-        private Exception _requestException;
+        private Exception? _requestException;
 
         /// <summary>
         /// The overall result calculated in the constructor.
@@ -98,13 +108,23 @@ public class BuildResult : INodePacket, IBuildResults
         /// Snapshot of the environment from the configuration this results comes from.
         /// This should only be populated when the configuration for this result is moved between nodes.
         /// </summary>
-        private Dictionary<string, string> _savedEnvironmentVariables;
+        private Dictionary<string, string>? _savedEnvironmentVariables;
+
+        /// <summary>
+        /// When this key is in the dictionary <see cref="_savedEnvironmentVariables"/>, serialize the build result version.
+        /// </summary>
+        private const string SpecialKeyForVersion = "=MSBUILDFEATUREBUILDRESULTHASVERSION=";
+
+        /// <summary>
+        /// Set of additional keys tat might be added to the dictionary <see cref="_savedEnvironmentVariables"/>.
+        /// </summary>
+        private static readonly HashSet<string> s_additionalEntriesKeys = new HashSet<string> { SpecialKeyForVersion };
 
         /// <summary>
         /// Snapshot of the current directory from the configuration this result comes from.
         /// This should only be populated when the configuration for this result is moved between nodes.
         /// </summary>
-        private string _savedCurrentDirectory;
+        private string? _savedCurrentDirectory;
 
         /// <summary>
         /// <see cref="ProjectInstance"/> state after the build. This is only provided if <see cref="BuildRequest.BuildRequestDataFlags"/>
@@ -114,22 +134,26 @@ public class BuildResult : INodePacket, IBuildResults
         /// be used to retrieve <see cref="ProjectInstance.Properties"/>, <see cref="ProjectInstance.GlobalProperties"/> and
         /// <see cref="ProjectInstance.Items"/> from it. No other operation is guaranteed to be supported.
         /// </summary>
-        private ProjectInstance _projectStateAfterBuild;
+        private ProjectInstance? _projectStateAfterBuild;
 
         /// <summary>
         /// The flags provide additional control over the build results and may affect the cached value.
         /// </summary>
+        /// <remarks>
+        /// Is optional, the field is expected to be present starting <see cref="_version"/> 1.
+        /// </remarks>
         private BuildRequestDataFlags _buildRequestDataFlags;
 
-        private string _schedulerInducedError;
+        private string? _schedulerInducedError;
 
-        private HashSet<string> _projectTargets;
+        private HashSet<string>? _projectTargets;
 
         /// <summary>
         /// Constructor for serialization.
         /// </summary>
         public BuildResult()
         {
+            _resultsByTarget = CreateTargetResultDictionary(1);
         }
 
         /// <summary>
@@ -146,7 +170,7 @@ internal BuildResult(BuildRequest request)
         /// </summary>
         /// <param name="request">The build request to which these results should be associated.</param>
         /// <param name="exception">The exception, if any.</param>
-        internal BuildResult(BuildRequest request, Exception exception)
+        internal BuildResult(BuildRequest request, Exception? exception)
             : this(request, null, exception)
         {
         }
@@ -189,7 +213,7 @@ internal BuildResult(BuildResult existingResults, string[] targetNames)
         /// <param name="request">The build request with which these results should be associated.</param>
         /// <param name="existingResults">The existing results, if any.</param>
         /// <param name="exception">The exception, if any</param>
-        internal BuildResult(BuildRequest request, BuildResult existingResults, Exception exception)
+        internal BuildResult(BuildRequest request, BuildResult? existingResults, Exception? exception)
             : this(request, existingResults, null, exception)
         {
         }
@@ -201,9 +225,8 @@ internal BuildResult(BuildRequest request, BuildResult existingResults, Exceptio
         /// <param name="existingResults">The existing results, if any.</param>
         /// <param name="targetNames">The list of target names that are the subset of results that should be returned.</param>
         /// <param name="exception">The exception, if any</param>
-        internal BuildResult(BuildRequest request, BuildResult existingResults, string[] targetNames, Exception exception)
+        internal BuildResult(BuildRequest request, BuildResult? existingResults, string[]? targetNames, Exception? exception)
         {
-            ErrorUtilities.VerifyThrow(request != null, "Must specify a request.");
             _submissionId = request.SubmissionId;
             _configurationId = request.ConfigurationId;
             _globalRequestId = request.GlobalRequestId;
@@ -270,12 +293,13 @@ internal BuildResult(BuildResult result, int submissionId, int configurationId,
         private BuildResult(ITranslator translator)
         {
             ((ITranslatable)this).Translate(translator);
+            _resultsByTarget ??= CreateTargetResultDictionary(1);
         }
 
         /// <summary>
         /// Returns the submission id.
         /// </summary>
-        public int SubmissionId
+        public override int SubmissionId
         {
             [DebuggerStepThrough]
             get
@@ -325,7 +349,7 @@ public int NodeRequestId
         /// <summary>
         /// Returns the exception generated while this result was run, if any.
         /// </summary>
-        public Exception Exception
+        public override Exception? Exception
         {
             [DebuggerStepThrough]
             get
@@ -339,7 +363,7 @@ internal set
         /// <summary>
         /// Returns a flag indicating if a circular dependency was detected.
         /// </summary>
-        public bool CircularDependency
+        public override bool CircularDependency
         {
             [DebuggerStepThrough]
             get
@@ -349,7 +373,7 @@ public bool CircularDependency
         /// <summary>
         /// Returns the overall result for this result set.
         /// </summary>
-        public BuildResultCode OverallResult
+        public override BuildResultCode OverallResult
         {
             get
             {
@@ -358,7 +382,7 @@ public BuildResultCode OverallResult
                     return BuildResultCode.Failure;
                 }
 
-                foreach (KeyValuePair<string, TargetResult> result in _resultsByTarget)
+                foreach (KeyValuePair<string, TargetResult> result in _resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
                 {
                     if ((result.Value.ResultCode == TargetResultCode.Failure && !result.Value.TargetFailureDoesntCauseBuildFailure)
                         || result.Value.AfterTargetsHaveFailed)
@@ -386,7 +410,7 @@ public IDictionary<string, TargetResult> ResultsByTarget
         /// be used to retrieve <see cref="ProjectInstance.Properties"/>, <see cref="ProjectInstance.GlobalProperties"/> and
         /// <see cref="ProjectInstance.Items"/> from it. Any other operation is not guaranteed to be supported.
         /// </summary>
-        public ProjectInstance ProjectStateAfterBuild
+        public ProjectInstance? ProjectStateAfterBuild
         {
             get => _projectStateAfterBuild;
             set => _projectStateAfterBuild = value;
@@ -396,7 +420,10 @@ public ProjectInstance ProjectStateAfterBuild
         /// Gets the flags that were used in the build request to which these results are associated.
         /// See <see cref="Execution.BuildRequestDataFlags"/> for examples of the available flags.
         /// </summary>
-        public BuildRequestDataFlags BuildRequestDataFlags => _buildRequestDataFlags;
+        /// <remarks>
+        /// Is optional, this property exists starting <see cref="_version"/> 1.
+        /// </remarks>
+        public BuildRequestDataFlags? BuildRequestDataFlags => (_version > 0) ? _buildRequestDataFlags : null;
 
         /// <summary>
         /// Returns the node packet type.
@@ -411,7 +438,7 @@ NodePacketType INodePacket.Type
         /// <summary>
         /// Holds a snapshot of the environment at the time we blocked.
         /// </summary>
-        Dictionary<string, string> IBuildResults.SavedEnvironmentVariables
+        Dictionary<string, string>? IBuildResults.SavedEnvironmentVariables
         {
             get => _savedEnvironmentVariables;
 
@@ -421,7 +448,7 @@ Dictionary<string, string> IBuildResults.SavedEnvironmentVariables
         /// <summary>
         /// Holds a snapshot of the current working directory at the time we blocked.
         /// </summary>
-        string IBuildResults.SavedCurrentDirectory
+        string? IBuildResults.SavedCurrentDirectory
         {
             get => _savedCurrentDirectory;
 
@@ -431,7 +458,7 @@ string IBuildResults.SavedCurrentDirectory
         /// <summary>
         /// Returns the initial targets for the configuration which requested these results.
         /// </summary>
-        internal List<string> InitialTargets
+        internal List<string>? InitialTargets
         {
             [DebuggerStepThrough]
             get
@@ -445,7 +472,7 @@ internal List<string> InitialTargets
         /// <summary>
         /// Returns the default targets for the configuration which requested these results.
         /// </summary>
-        internal List<string> DefaultTargets
+        internal List<string>? DefaultTargets
         {
             [DebuggerStepThrough]
             get
@@ -459,7 +486,7 @@ internal List<string> DefaultTargets
         /// <summary>
         /// The defined targets for the project associated with this build result.
         /// </summary>
-        internal HashSet<string> ProjectTargets
+        internal HashSet<string>? ProjectTargets
         {
             [DebuggerStepThrough]
             get => _projectTargets;
@@ -471,7 +498,7 @@ internal HashSet<string> ProjectTargets
         /// Container used to transport errors from the scheduler (issued while computing a build result)
         /// to the TaskHost that has the proper logging context (project id, target id, task id, file location)
         /// </summary>
-        internal string SchedulerInducedError
+        internal string? SchedulerInducedError
         {
             get => _schedulerInducedError;
             set => _schedulerInducedError = value;
@@ -488,7 +515,7 @@ public ITargetResult this[string target]
         {
             [DebuggerStepThrough]
             get
-            { return _resultsByTarget[target]; }
+            { return _resultsByTarget![target]; }
         }
 
         /// <summary>
@@ -506,7 +533,7 @@ public void AddResultsForTarget(string target, TargetResult result)
                 _resultsByTarget ??= CreateTargetResultDictionary(1);
             }
 
-            if (_resultsByTarget.TryGetValue(target, out TargetResult targetResult))
+            if (_resultsByTarget.TryGetValue(target, out TargetResult? targetResult))
             {
                 ErrorUtilities.VerifyThrow(targetResult.ResultCode == TargetResultCode.Skipped, "Items already exist for target {0}.", target);
             }
@@ -524,11 +551,11 @@ internal void KeepSpecificTargetResults(IReadOnlyCollection<string> targetsToKee
                 targetsToKeep.Count > 0,
                 $"{nameof(targetsToKeep)} should contain at least one target.");
 
-            foreach (string target in _resultsByTarget.Keys)
+            foreach (string target in _resultsByTarget?.Keys ?? Enumerable.Empty<string>())
             {
                 if (!targetsToKeep.Contains(target))
                 {
-                    _ = _resultsByTarget.TryRemove(target, out _);
+                    _ = _resultsByTarget!.TryRemove(target, out _);
                 }
             }
         }
@@ -549,7 +576,7 @@ public void MergeResults(BuildResult results)
             }
 
             // Merge in the results
-            foreach (KeyValuePair<string, TargetResult> targetResult in results._resultsByTarget)
+            foreach (KeyValuePair<string, TargetResult> targetResult in results._resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
             {
                 // NOTE: I believe that because we only allow results for a given target to be produced and cached once for a given configuration,
                 // we can never receive conflicting results for that target, since the cache and build request manager would always return the
@@ -559,7 +586,7 @@ public void MergeResults(BuildResult results)
                 // ErrorUtilities.VerifyThrow(!HasResultsForTarget(targetResult.Key), "Results already exist");
 
                 // Copy the new results in.
-                _resultsByTarget[targetResult.Key] = targetResult.Value;
+                _resultsByTarget![targetResult.Key] = targetResult.Value;
             }
 
             // If there is an exception and we did not previously have one, add it in.
@@ -573,7 +600,7 @@ public void MergeResults(BuildResult results)
         /// <returns>True if results exist, false otherwise.</returns>
         public bool HasResultsForTarget(string target)
         {
-            return _resultsByTarget.ContainsKey(target);
+            return _resultsByTarget?.ContainsKey(target) ?? false;
         }
 
         #region INodePacket Members
@@ -598,8 +625,62 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _projectStateAfterBuild, ProjectInstance.FactoryForDeserialization);
             translator.Translate(ref _savedCurrentDirectory);
             translator.Translate(ref _schedulerInducedError);
-            translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);
-            translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
+
+            // This is a work-around for the bug https://github.com/dotnet/msbuild/issues/10208
+            // We are adding a version field to this class to make the ResultsCache backwards compatible with at least 2 previous releases.
+            // The adding of a version field is done without a breaking change in 3 steps, each separated with at least 1 intermediate release.
+            //
+            // 1st step (done): Add a special key to the _savedEnvironmentVariables dictionary during the serialization. A workaround overload of the TranslateDictionary function is created to achieve it.
+            // The presence of this key will indicate that the version is serialized next.
+            // When serializing, add a key to the dictionary and serialize a version field.
+            // Do not actually save the special key to dictionary during the deserialization, but read a version as a next field if it presents.
+            //
+            // 2nd step: Stop serialize a special key with the dictionary _savedEnvironmentVariables using the TranslateDictionary function workaround overload. Always serialize and de-serialize the version field.
+            // Continue to deserialize _savedEnvironmentVariables with the TranslateDictionary function workaround overload in order not to deserialize dictionary with the special keys.
+            //
+            // 3rd step: Stop using the TranslateDictionary function workaround overload during _savedEnvironmentVariables deserialization.
+            if (_version == 0)
+            {
+                // Escape hatch: serialize/deserialize without version field.
+                translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase);
+            }
+            else
+            {
+                Dictionary<string, string> additionalEntries = new();
+
+                if (translator.Mode == TranslationDirection.WriteToStream)
+                {
+                    // Add the special key SpecialKeyForVersion to additional entries indicating the presence of a version to the _savedEnvironmentVariables dictionary.
+                    additionalEntries.Add(SpecialKeyForVersion, String.Empty);
+
+                    // Serialize the special key together with _savedEnvironmentVariables dictionary using the workaround overload of TranslateDictionary:
+                    translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase, ref additionalEntries, s_additionalEntriesKeys);
+
+                    // Serialize version
+                    translator.Translate(ref _version);
+                }
+                else if (translator.Mode == TranslationDirection.ReadFromStream)
+                {
+                    // Read the dictionary using the workaround overload of TranslateDictionary: special keys (additionalEntriesKeys) would be read to additionalEntries instead of the _savedEnvironmentVariables dictionary.
+                    translator.TranslateDictionary(ref _savedEnvironmentVariables, StringComparer.OrdinalIgnoreCase, ref additionalEntries, s_additionalEntriesKeys);
+
+                    // If the special key SpecialKeyForVersion present in additionalEntries, also read a version, otherwise set it to 0.
+                    if (additionalEntries is not null && additionalEntries.ContainsKey(SpecialKeyForVersion))
+                    {
+                        translator.Translate(ref _version);
+                    }
+                    else
+                    {
+                        _version = 0;
+                    }
+                }
+            }
+
+            // Starting version 1 this _buildRequestDataFlags field is present.
+            if (_version > 0)
+            {
+                translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
+            }
         }
 
         /// <summary>
@@ -617,7 +698,7 @@ internal static BuildResult FactoryForDeserialization(ITranslator translator)
         /// </summary>
         internal void CacheIfPossible()
         {
-            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget)
+            foreach (KeyValuePair<string, TargetResult> targetResultPair in _resultsByTarget ?? Enumerable.Empty<KeyValuePair<string, TargetResult>>())
             {
                 targetResultPair.Value.CacheItems(ConfigurationId, targetResultPair.Key);
             }
@@ -648,9 +729,7 @@ internal BuildResult Clone()
                 _parentGlobalRequestId = _parentGlobalRequestId,
                 _nodeRequestId = _nodeRequestId,
                 _requestException = _requestException,
-                _resultsByTarget = new ConcurrentDictionary<string, TargetResult>(
-                    _resultsByTarget,
-                    StringComparer.OrdinalIgnoreCase),
+                _resultsByTarget = new ConcurrentDictionary<string, TargetResult>(_resultsByTarget, StringComparer.OrdinalIgnoreCase),
                 _baseOverallResult = OverallResult == BuildResultCode.Success,
                 _circularDependency = _circularDependency
             };
@@ -685,7 +764,7 @@ private static ConcurrentDictionary<string, TargetResult> CreateTargetResultDict
 
             foreach (string target in targetNames)
             {
-                if (existingResults.ResultsByTarget.TryGetValue(target, out TargetResult targetResult))
+                if (existingResults.ResultsByTarget?.TryGetValue(target, out TargetResult? targetResult) ?? false)
                 {
                     resultsByTarget[target] = targetResult;
                 }
diff --git a/src/Build/BackEnd/Shared/BuildResultBase.cs b/src/Build/BackEnd/Shared/BuildResultBase.cs
new file mode 100644
index 00000000000..f144bcb778c
--- /dev/null
+++ b/src/Build/BackEnd/Shared/BuildResultBase.cs
@@ -0,0 +1,30 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Execution
+{
+    public abstract class BuildResultBase
+    {
+        /// <summary>
+        /// Returns the submission id.
+        /// </summary>
+        public abstract int SubmissionId { get; }
+
+        /// <summary>
+        /// Returns a flag indicating if a circular dependency was detected.
+        /// </summary>
+        public abstract bool CircularDependency { get; }
+
+        /// <summary>
+        /// Returns the exception generated while this result was run, if any.
+        /// </summary>
+        public abstract Exception? Exception { get; internal set; }
+
+        /// <summary>
+        /// Returns the overall result for this result set.
+        /// </summary>
+        public abstract BuildResultCode OverallResult { get; }
+    }
+}
diff --git a/src/Build/BackEnd/Shared/EventsCreatorHelper.cs b/src/Build/BackEnd/Shared/EventsCreatorHelper.cs
new file mode 100644
index 00000000000..ead0c205d27
--- /dev/null
+++ b/src/Build/BackEnd/Shared/EventsCreatorHelper.cs
@@ -0,0 +1,63 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BackEnd.Shared;
+
+internal static class EventsCreatorHelper
+{
+    public static BuildMessageEventArgs CreateMessageEventFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, params object?[]? messageArgs)
+    {
+        ErrorUtilities.VerifyThrowInternalNull(buildEventContext, nameof(buildEventContext));
+        ErrorUtilities.VerifyThrowInternalNull(message, nameof(message));
+
+        BuildMessageEventArgs buildEvent = new BuildMessageEventArgs(
+                message,
+                helpKeyword: null,
+                senderName: "MSBuild",
+                importance,
+                DateTime.UtcNow,
+                messageArgs);
+        buildEvent.BuildEventContext = buildEventContext;
+
+        return buildEvent;
+    }
+
+    public static BuildErrorEventArgs CreateErrorEventFromText(BuildEventContext buildEventContext, string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message)
+    {
+        ErrorUtilities.VerifyThrowInternalNull(buildEventContext, nameof(buildEventContext));
+        ErrorUtilities.VerifyThrowInternalNull(file, nameof(file));
+        ErrorUtilities.VerifyThrowInternalNull(message, nameof(message));
+
+        string? subcategory = null;
+
+        if (subcategoryResourceName != null)
+        {
+            subcategory = AssemblyResources.GetString(subcategoryResourceName);
+        }
+
+        BuildErrorEventArgs buildEvent =
+        new BuildErrorEventArgs(
+            subcategory,
+            errorCode,
+            file!.File,
+            file.Line,
+            file.Column,
+            file.EndLine,
+            file.EndColumn,
+            message,
+            helpKeyword,
+            "MSBuild");
+
+        buildEvent.BuildEventContext = buildEventContext;
+
+        return buildEvent;
+    }
+}
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
deleted file mode 100644
index ab817077725..00000000000
--- a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-
-namespace Microsoft.Build.Experimental.BuildCheck;
-
-/// <summary>
-/// Configuration for a build analyzer.
-/// Default values can be specified by the Analyzer in code.
-/// Users can overwrite the defaults by explicit settings in the .editorconfig file.
-/// Each rule can have its own configuration, which can differ per each project.
-/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
-/// </summary>
-public class BuildAnalyzerConfiguration
-{
-    // Defaults to be used if any configuration property is not specified neither as default
-    //  nor in the editorconfig configuration file.
-    public static BuildAnalyzerConfiguration Default { get; } = new()
-    {
-        EvaluationAnalysisScope = BuildCheck.EvaluationAnalysisScope.ProjectOnly,
-        Severity = BuildAnalyzerResultSeverity.Info,
-        IsEnabled = false,
-    };
-
-    public static BuildAnalyzerConfiguration Null { get; } = new();
-
-    /// <summary>
-    /// This applies only to specific events, that can distinguish whether they are directly inferred from
-    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
-    ///
-    /// If not supported by the data source - then the setting is ignored
-    /// </summary>
-    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
-
-    /// <summary>
-    /// The severity of the result for the rule.
-    /// </summary>
-    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
-
-    /// <summary>
-    /// Whether the analyzer rule is enabled.
-    /// If all rules within the analyzer are not enabled, it will not be run.
-    /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
-    /// </summary>
-    public bool? IsEnabled { get; internal init; }
-
-    /// <summary>
-    /// Creates a <see cref="BuildAnalyzerConfiguration"/> object based on the provided configuration dictionary.
-    /// If the BuildAnalyzerConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
-    /// If parsing failed the value will be equal to null.
-    /// </summary>
-    /// <param name="configDictionary">The configuration dictionary containing the settings for the build analyzer. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
-    /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
-    internal static BuildAnalyzerConfiguration Create(Dictionary<string, string>? configDictionary)
-    {
-        return new()
-        {
-            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,
-            Severity = TryExtractValue(nameof(Severity), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,
-            IsEnabled = TryExtractValue(nameof(IsEnabled), configDictionary, out bool isEnabled) ? isEnabled : null,
-        };
-    }
-
-    private static bool TryExtractValue<T>(string key, Dictionary<string, string>? config, out T value) where T : struct, Enum
-    {
-        value = default;
-
-        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
-        {
-            return false;
-        }
-
-        var isParsed = Enum.TryParse(stringValue, true, out value);
-
-        if (!isParsed)
-        {
-            ThrowIncorrectValueException(key, stringValue);
-        }
-
-        return isParsed;
-    }
-
-    private static bool TryExtractValue(string key, Dictionary<string, string>? config, out bool value)
-    {
-        value = default;
-
-        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
-        {
-            return false;
-        }
-
-        bool isParsed = false;
-        
-        if (bool.TryParse(stringValue, out bool boolValue))
-        {
-            value = boolValue;
-            isParsed = true;
-        }
-        
-        if (!isParsed)
-        {
-            ThrowIncorrectValueException(key, stringValue);
-        }
-
-        return isParsed;
-    }
-
-    private static void ThrowIncorrectValueException(string key, string value)
-    {
-        // TODO: It will be nice to have the filename where the incorrect configuration was placed. 
-        throw new BuildCheckConfigurationException(
-                $"Incorrect value provided in config for key {key}: '{value}'",
-                buildCheckConfigurationErrorScope: BuildCheckConfigurationErrorScope.EditorConfigParser);
-    }
-}
diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
index 03a69e02939..f9184127aa7 100644
--- a/src/Build/BuildCheck/API/BuildCheckResult.cs
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -5,52 +5,54 @@
 using System.IO;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Representation of a single report of a single finding from a BuildAnalyzer
+/// Representation of a single report of a single finding from a Check
 /// Each rule has upfront known message format - so only the concrete arguments are added
 /// Optionally a location is attached - in the near future we might need to support multiple locations
 ///  (for 2 cases - a) grouped result for multiple occurrences; b) a single report for a finding resulting from combination of multiple locations)
 /// </summary>
 public sealed class BuildCheckResult : IBuildCheckResult
 {
-    public static BuildCheckResult Create(BuildAnalyzerRule rule, ElementLocation location, params string[] messageArgs)
+    public static BuildCheckResult Create(CheckRule rule, IMSBuildElementLocation location, params string[] messageArgs)
     {
         return new BuildCheckResult(rule, location, messageArgs);
     }
 
-    public BuildCheckResult(BuildAnalyzerRule buildAnalyzerRule, ElementLocation location, string[] messageArgs)
+    public BuildCheckResult(CheckRule checkConfig, IMSBuildElementLocation location, string[] messageArgs)
     {
-        BuildAnalyzerRule = buildAnalyzerRule;
+        CheckRule = checkConfig;
         Location = location;
         MessageArgs = messageArgs;
     }
 
-    internal BuildEventArgs ToEventArgs(BuildAnalyzerResultSeverity severity)
+    internal BuildEventArgs ToEventArgs(CheckResultSeverity severity)
         => severity switch
         {
-            BuildAnalyzerResultSeverity.Info => new BuildCheckResultMessage(this),
-            BuildAnalyzerResultSeverity.Warning => new BuildCheckResultWarning(this),
-            BuildAnalyzerResultSeverity.Error => new BuildCheckResultError(this),
+            CheckResultSeverity.Suggestion => new BuildCheckResultMessage(this),
+            CheckResultSeverity.Warning => new BuildCheckResultWarning(this, CheckRule.Id),
+            CheckResultSeverity.Error => new BuildCheckResultError(this, CheckRule.Id),
             _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null),
         };
 
-    public BuildAnalyzerRule BuildAnalyzerRule { get; }
+    public CheckRule CheckRule { get; }
 
     /// <summary>
     /// Optional location of the finding (in near future we might need to support multiple locations).
     /// </summary>
-    public ElementLocation Location { get; }
+    public IMSBuildElementLocation Location { get; }
 
     public string LocationString => Location.LocationString;
 
     public string[] MessageArgs { get; }
-    public string MessageFormat => BuildAnalyzerRule.MessageFormat;
+    public string MessageFormat => CheckRule.MessageFormat;
 
+    // Here we will provide different link for built-in rules and custom rules - once we have the base classes differentiated.
     public string FormatMessage() =>
-        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}{BuildAnalyzerRule.Id}: {string.Format(BuildAnalyzerRule.MessageFormat, MessageArgs)}";
+        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}https://aka.ms/buildcheck/codes#{CheckRule.Id} - {string.Format(CheckRule.MessageFormat, MessageArgs)}";
 
     private string? _message;
 }
diff --git a/src/Build/BuildCheck/API/BuildAnalyzer.cs b/src/Build/BuildCheck/API/Check.cs
similarity index 70%
rename from src/Build/BuildCheck/API/BuildAnalyzer.cs
rename to src/Build/BuildCheck/API/Check.cs
index 0c6ed5a0752..4eeeb8599f1 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzer.cs
+++ b/src/Build/BuildCheck/API/Check.cs
@@ -9,29 +9,29 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Base class for build analyzers.
-/// Same base will be used for custom and built-in analyzers.
-/// <see cref="BuildAnalyzer"/> is a unit of build analysis execution, but it can contain multiple rules - each representing a distinct violation.
+/// Base class for build checks.
+/// Same base will be used for custom and built-in checks.
+/// <see cref="Check"/> is a unit of build checks execution, but it can contain multiple rules - each representing a distinct violation.
 /// </summary>
-public abstract class BuildAnalyzer : IDisposable
+public abstract class Check : IDisposable
 {
     /// <summary>
-    /// Friendly name of the analyzer.
+    /// Friendly name of the check.
     /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
     /// </summary>
     public abstract string FriendlyName { get; }
 
     /// <summary>
-    /// Single or multiple rules supported by the analyzer.
+    /// Single or multiple rules supported by the check.
     /// </summary>
-    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
+    public abstract IReadOnlyList<CheckRule> SupportedRules { get; }
 
     /// <summary>
-    /// Optional initialization of the analyzer.
+    /// Optional initialization of the check.
     /// </summary>
     /// <param name="configurationContext">
     /// Custom data (not recognized by the infrastructure) passed from .editorconfig
-    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
+    /// Currently the custom data has to be identical for all rules in the check and all projects.
     /// </param>
     public abstract void Initialize(ConfigurationContext configurationContext);
 
diff --git a/src/Build/BuildCheck/API/CheckConfiguration.cs b/src/Build/BuildCheck/API/CheckConfiguration.cs
new file mode 100644
index 00000000000..9c4ac89749f
--- /dev/null
+++ b/src/Build/BuildCheck/API/CheckConfiguration.cs
@@ -0,0 +1,150 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck.Utilities;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Configuration for a build check.
+/// Default values can be specified by the Check in code.
+/// Users can overwrite the defaults by explicit settings in the .editorconfig file.
+/// Each rule can have its own configuration, which can differ per each project.
+/// The <see cref="EvaluationCheckScope"/> setting must be same for all rules in the same check (but can differ between projects)
+/// </summary>
+public class CheckConfiguration
+{
+    // Defaults to be used if any configuration property is not specified neither as default
+    //  nor in the editorconfig configuration file.
+    public static CheckConfiguration Default { get; } = new()
+    {
+        EvaluationCheckScope = BuildCheck.EvaluationCheckScope.ProjectFileOnly,
+        Severity = CheckResultSeverity.None
+    };
+
+    public static CheckConfiguration Null { get; } = new();
+
+    public string? RuleId { get; internal set; }
+
+    /// <summary>
+    /// This applies only to specific events, that can distinguish whether they are directly inferred from
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from check.
+    ///
+    /// If not supported by the data source - then the setting is ignored
+    /// </summary>
+    public EvaluationCheckScope? EvaluationCheckScope { get; internal init; }
+
+    /// <summary>
+    /// The severity of the result for the rule.
+    /// </summary>
+    public CheckResultSeverity? Severity { get; internal init; }
+
+    /// <summary>
+    /// Whether the check rule is enabled.
+    /// If all rules within the check are not enabled, it will not be run.
+    /// If some rules are enabled and some are not, the check will be run and reports will be post-filtered.
+    /// </summary>
+    public bool? IsEnabled {
+        get
+        {
+            // Do not consider Default as enabled, because the default severity of the rule could be set to None
+            if (Severity.HasValue && Severity.Value != CheckResultSeverity.Default)
+            {
+                return !Severity.Value.Equals(CheckResultSeverity.None);
+            }
+
+            return null;
+        }
+    }
+
+    /// <summary>
+    /// Creates a <see cref="CheckConfiguration"/> object based on the provided configuration dictionary.
+    /// If the BuildCheckConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
+    /// If parsing failed the value will be equal to null.
+    /// </summary>
+    /// <param name="configDictionary">The configuration dictionary containing the settings for the build check. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
+    /// <returns>A new instance of <see cref="CheckConfiguration"/> with the specified settings.</returns>
+    internal static CheckConfiguration Create(Dictionary<string, string>? configDictionary) => new()
+    {
+        EvaluationCheckScope = TryExtractEvaluationCheckScope(configDictionary),
+        Severity = TryExtractSeverity(configDictionary),
+    };
+
+
+    private static EvaluationCheckScope? TryExtractEvaluationCheckScope(Dictionary<string, string>? config)
+    {
+
+        if (!TryExtractValue(BuildCheckConstants.scopeConfigurationKey, config, out string? stringValue) || stringValue is null)
+        {
+            return null;
+        }
+
+        switch (stringValue)
+        {
+            case "projectfile":
+            case "project_file":
+                return BuildCheck.EvaluationCheckScope.ProjectFileOnly;
+            case "work_tree_imports":
+                return BuildCheck.EvaluationCheckScope.WorkTreeImports;
+            case "all":
+                return BuildCheck.EvaluationCheckScope.All;
+            default:
+                ThrowIncorrectValueException(BuildCheckConstants.scopeConfigurationKey, stringValue);
+                break;
+        }
+
+        return null;
+    }
+
+    private static CheckResultSeverity? TryExtractSeverity(Dictionary<string, string>? config)
+    {
+        if (!TryExtractValue(BuildCheckConstants.severityConfigurationKey, config, out string? stringValue) || stringValue is null)
+        {
+            return null;
+        }
+
+        switch (stringValue)
+        {
+            case "none":
+                return CheckResultSeverity.None;
+            case "default":
+                return CheckResultSeverity.Default;
+            case "suggestion":
+                return CheckResultSeverity.Suggestion;
+            case "warning":
+                return CheckResultSeverity.Warning;
+            case "error":
+                return CheckResultSeverity.Error;
+            default:
+                ThrowIncorrectValueException(BuildCheckConstants.severityConfigurationKey, stringValue);
+                break;
+        }
+
+        return null;
+    }
+
+    private static bool TryExtractValue(string key, Dictionary<string, string>? config, out string? stringValue)
+    {
+        stringValue = null;
+
+        if (config == null || !config.TryGetValue(key.ToLower(), out stringValue) || stringValue is null)
+        {
+            return false;
+        }
+
+        stringValue = stringValue.ToLower();
+
+        return true;
+    }
+
+    private static void ThrowIncorrectValueException(string key, string value)
+    {
+        // TODO: It will be nice to have the filename where the incorrect configuration was placed. 
+        throw new BuildCheckConfigurationException(
+                $"Incorrect value provided in config for key {key}: '{value}'",
+                buildCheckConfigurationErrorScope: BuildCheckConfigurationErrorScope.EditorConfigParser);
+    }
+}
diff --git a/src/Build/BuildCheck/API/CheckResultSeverity.cs b/src/Build/BuildCheck/API/CheckResultSeverity.cs
new file mode 100644
index 00000000000..dc26b9d4532
--- /dev/null
+++ b/src/Build/BuildCheck/API/CheckResultSeverity.cs
@@ -0,0 +1,35 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// The severity of reported result (or preconfigured or user configured severity for a rule).
+/// </summary>
+public enum CheckResultSeverity
+{
+    /// <summary>
+    /// When set, the default value of the BuildCheck rule will be used.
+    /// </summary>
+    Default,
+
+    /// <summary>
+    /// When set to None the rule will not run.
+    /// </summary>
+    None,
+
+    /// <summary>
+    /// Information level message.
+    /// </summary>
+    Suggestion,
+
+    /// <summary>
+    /// Results a warning in build if the BuildCheck rule applied.
+    /// </summary>
+    Warning,
+
+    /// <summary>
+    /// Results an error in build if the BuildCheck rule applied.
+    /// </summary>
+    Error
+}
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs b/src/Build/BuildCheck/API/CheckRule.cs
similarity index 75%
rename from src/Build/BuildCheck/API/BuildAnalyzerRule.cs
rename to src/Build/BuildCheck/API/CheckRule.cs
index 8b43dad4999..3fdf97bbc44 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
+++ b/src/Build/BuildCheck/API/CheckRule.cs
@@ -4,14 +4,18 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Represents a rule that is a unit of build analysis.
-/// <see cref="BuildAnalyzer"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types,
-///  for this reason a single <see cref="BuildAnalyzer"/> can expose multiple <see cref="BuildAnalyzerRule"/>s.
+/// Represents a rule that is a unit of a build check.
+/// <see cref="Check"/> is a unit of executing the check, but it can be discovering multiple distinct violation types,
+///  for this reason a single <see cref="Check"/> can expose multiple <see cref="CheckRule"/>s.
 /// </summary>
-public class BuildAnalyzerRule
+public class CheckRule
 {
-    public BuildAnalyzerRule(string id, string title, string description, string messageFormat,
-        BuildAnalyzerConfiguration defaultConfiguration)
+    public CheckRule(
+        string id,
+        string title,
+        string description,
+        string messageFormat,
+        CheckConfiguration defaultConfiguration)
     {
         Id = id;
         Title = title;
@@ -51,5 +55,5 @@ public BuildAnalyzerRule(string id, string title, string description, string mes
     /// The default configuration - overridable by the user via .editorconfig.
     /// If no user specified configuration is provided, this default will be used.
     /// </summary>
-    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+    public CheckConfiguration DefaultConfiguration { get; }
 }
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
index 3ecdd7c6527..86a52ae1a11 100644
--- a/src/Build/BuildCheck/API/ConfigurationContext.cs
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -9,22 +9,28 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Holder of an optional configuration from .editorconfig file (not recognized by the infrastructure)
+/// Holder of configuration from .editorconfig file (not recognized by the infrastructure)
 /// </summary>
 public class ConfigurationContext
 {
-    private ConfigurationContext(CustomConfigurationData[] customConfigurationData)
+    private ConfigurationContext(CustomConfigurationData[] customConfigurationData, CheckConfigurationEffective[] checkConfig)
     {
         CustomConfigurationData = customConfigurationData;
+        CheckConfig = checkConfig;
     }
 
-    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData)
+    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData, CheckConfigurationEffective[] checkConfig)
     {
-        return new ConfigurationContext(customConfigurationData);
+        return new ConfigurationContext(customConfigurationData, checkConfig);
     }
 
     /// <summary>
     /// Custom configuration data - per each rule that has some specified.
     /// </summary>
     public IReadOnlyList<CustomConfigurationData> CustomConfigurationData { get; init; }
+
+    /// <summary>
+    /// Infrastructure configuration data
+    /// </summary>
+    public IReadOnlyList<CheckConfigurationEffective> CheckConfig { get; init; }
 }
diff --git a/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs b/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
deleted file mode 100644
index 39781649359..00000000000
--- a/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
+++ /dev/null
@@ -1,33 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.Build.Experimental.BuildCheck;
-
-/// <summary>
-/// For datasource events that can differentiate from where exactly they originate - e.g.
-///  For a condition string or AST - was that directly in hte analyzed project or imported?
-///
-/// Ignored by infrastructure if the current datasource doesn't support this level of setting.
-/// </summary>
-public enum EvaluationAnalysisScope
-{
-    /// <summary>
-    /// Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded.
-    /// </summary>
-    ProjectOnly,
-
-    /// <summary>
-    /// Only the data from currently analyzed project and imports from files under the entry project or solution will be sent to the analyzer. Other imports will be discarded.
-    /// </summary>
-    ProjectWithImportsFromCurrentWorkTree,
-
-    /// <summary>
-    /// Imports from SDKs will not be sent to the analyzer. Other imports will be sent.
-    /// </summary>
-    ProjectWithImportsWithoutSdks,
-
-    /// <summary>
-    /// All data will be sent to the analyzer.
-    /// </summary>
-    ProjectWithAllImports,
-}
diff --git a/src/Build/BuildCheck/API/EvaluationCheckScope.cs b/src/Build/BuildCheck/API/EvaluationCheckScope.cs
new file mode 100644
index 00000000000..08aecf49c80
--- /dev/null
+++ b/src/Build/BuildCheck/API/EvaluationCheckScope.cs
@@ -0,0 +1,29 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// For datasource events that can differentiate from where exactly they originate - e.g.
+///  For a condition string or AST - was that directly in the checked project or imported?
+///
+/// Ignored by infrastructure if the current datasource doesn't support this level of setting.
+/// </summary>
+public enum EvaluationCheckScope
+{
+    /// <summary>
+    /// Only the data from currently checked project will be sent to the check. Imports will be discarded.
+    /// </summary>
+    ProjectFileOnly,
+
+    /// <summary>
+    /// Only the data from currently checked project and imports from files not recognized to be in nuget cache or SDK install folder will be sent to the check. Other imports will be discarded.
+    /// The generated nuget.g.props, nuget.g.targets will be ignored as well.
+    /// </summary>
+    WorkTreeImports,
+
+    /// <summary>
+    /// All data will be sent to the check.
+    /// </summary>
+    All,
+}
diff --git a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
index d8ad5a396ef..9f033117442 100644
--- a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
+++ b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
@@ -7,7 +7,11 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 
 public interface IBuildCheckRegistrationContext
 {
-    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
-    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
-    void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction);
+    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction);
+
+    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction);
+
+    void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction);
+
+    void RegisterBuildFinishedAction(Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction);
 }
diff --git a/src/Build/BuildCheck/API/IInternalCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IInternalCheckRegistrationContext.cs
new file mode 100644
index 00000000000..2f8875fb62a
--- /dev/null
+++ b/src/Build/BuildCheck/API/IInternalCheckRegistrationContext.cs
@@ -0,0 +1,12 @@
+﻿using System;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal interface IInternalCheckRegistrationContext : IBuildCheckRegistrationContext
+{
+    void RegisterPropertyReadAction(Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction);
+
+    void RegisterPropertyWriteAction(Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction);
+
+    void RegisterProjectRequestProcessingDoneAction(Action<BuildCheckDataContext<ProjectRequestProcessingDoneData>> propertyWriteAction);
+}
diff --git a/src/Build/BuildCheck/API/InternalCheck.cs b/src/Build/BuildCheck/API/InternalCheck.cs
new file mode 100644
index 00000000000..58e71338e93
--- /dev/null
+++ b/src/Build/BuildCheck/API/InternalCheck.cs
@@ -0,0 +1,28 @@
+﻿using System;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal abstract class InternalCheck : Check
+{
+    /// <summary>
+    /// Used by the implementors to subscribe to data and events they are interested in.
+    /// This offers superset of registrations options to <see cref="Check.RegisterActions"/>.
+    /// </summary>
+    /// <param name="registrationContext"></param>
+    public abstract void RegisterInternalActions(IInternalCheckRegistrationContext registrationContext);
+
+    /// <summary>
+    /// This is intentionally not implemented, as it is extended by <see cref="RegisterInternalActions"/>.
+    /// </summary>
+    /// <param name="registrationContext"></param>
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        if (registrationContext is not IInternalCheckRegistrationContext internalRegistrationContext)
+        {
+            throw new ArgumentException("The registration context for InternalBuildAnalyzer must be of type IInternalBuildCheckRegistrationContext.", nameof(registrationContext));
+        }
+
+        this.RegisterInternalActions(internalRegistrationContext);
+    }
+}
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index ee755cc7352..b0899f22134 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -5,9 +5,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -15,10 +13,6 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 
 internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
 {
-    private readonly ILoggingService _loggingService;
-
-    internal BuildCheckAcquisitionModule(ILoggingService loggingService) => _loggingService = loggingService;
-
 #if FEATURE_ASSEMBLYLOADCONTEXT
     /// <summary>
     /// AssemblyContextLoader used to load DLLs outside of msbuild.exe directory.
@@ -27,32 +21,36 @@ internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
 #endif
 
     /// <summary>
-    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
-    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, BuildEventContext buildEventContext)
+    public List<CheckFactory> CreateCheckFactories(
+        CheckAcquisitionData checkAcquisitionData,
+        ICheckContext checkContext)
     {
-        var analyzersFactories = new List<BuildAnalyzerFactory>();
+        var checksFactories = new List<CheckFactory>();
 
         try
         {
             Assembly? assembly = null;
 #if FEATURE_ASSEMBLYLOADCONTEXT
-            assembly = s_coreClrAssemblyLoader.LoadFromPath(analyzerAcquisitionData.AssemblyPath);
+            assembly = s_coreClrAssemblyLoader.LoadFromPath(checkAcquisitionData.AssemblyPath);
 #else
-            assembly = Assembly.LoadFrom(analyzerAcquisitionData.AssemblyPath);
+            assembly = Assembly.LoadFrom(checkAcquisitionData.AssemblyPath);
 #endif
 
             IList<Type> availableTypes = assembly.GetExportedTypes();
-            IList<Type> analyzerTypes = availableTypes.Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t)).ToArray();
+            IList<Type> checkTypes = availableTypes.Where(t => typeof(Check).IsAssignableFrom(t)).ToArray();
 
-            foreach (Type analyzerCandidate in analyzerTypes)
+            foreach (Type checkCandidate in checkTypes)
             {
-                analyzersFactories.Add(() => (BuildAnalyzer)Activator.CreateInstance(analyzerCandidate)!);
+                checksFactories.Add(() => (Check)Activator.CreateInstance(checkCandidate)!);
+                checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckRegistered", checkCandidate.Name, checkCandidate.Assembly);
             }
 
-            if (availableTypes.Count != analyzerTypes.Count)
+            if (availableTypes.Count != checkTypes.Count)
             {
-                availableTypes.Except(analyzerTypes).ToList().ForEach(t => _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerBaseTypeNotAssignable", t.Name, t.Assembly));
+                availableTypes.Except(checkTypes).ToList()
+                    .ForEach(t => checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckBaseTypeNotAssignable", t.Name, t.Assembly));
             }
         }
         catch (ReflectionTypeLoadException ex)
@@ -61,15 +59,15 @@ public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisiti
             {
                 foreach (Exception? loaderException in ex.LoaderExceptions)
                 {
-                    _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", loaderException?.Message);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", loaderException?.Message);
                 }
             }
         }
         catch (Exception ex)
         {
-            _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", ex?.Message);
+            checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", ex?.Message);
         }
 
-        return analyzersFactories;
+        return checksFactories;
     }
 }
diff --git a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
similarity index 59%
rename from src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
rename to src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
index 908aa931bef..74a0c87be38 100644
--- a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
+++ b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
@@ -13,15 +13,17 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 // https://github.com/dotnet/msbuild/issues/9633
 // Acquisition
 //  define the data that will be passed to the acquisition module (and remoted if needed)
-internal class AnalyzerAcquisitionData(string assemblyPath)
+internal class CheckAcquisitionData(string assemblyPath, string projectPath)
 {
     public string AssemblyPath { get; init; } = assemblyPath;
+
+    public string ProjectPath { get; init; } = projectPath;
 }
 
-internal static class AnalyzerAcquisitionDataExtensions
+internal static class CheckAcquisitionDataExtensions
 {
-    public static AnalyzerAcquisitionData ToAnalyzerAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
-        new(eventArgs.AcquisitionPath);
+    public static CheckAcquisitionData ToCheckAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
+        new(eventArgs.AcquisitionPath, eventArgs.ProjectPath);
 
-    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this AnalyzerAcquisitionData data) => new(data.AssemblyPath);
+    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this CheckAcquisitionData data) => new(data.AssemblyPath, data.ProjectPath);
 }
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
index efb860ef844..245736ca67a 100644
--- a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -10,7 +10,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 internal interface IBuildCheckAcquisitionModule
 {
     /// <summary>
-    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
-    List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, BuildEventContext buildEventContext);
+    List<CheckFactory> CreateCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext);
 }
diff --git a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
similarity index 73%
rename from src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
rename to src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
index e5fc6b22cfd..df2cbd61145 100644
--- a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
@@ -10,24 +10,26 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
-using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;
+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData;
 
 #if FEATURE_MSIOREDIST
 using Path = Microsoft.IO.Path;
 #endif
 
-namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class DoubleWritesAnalyzer : BuildAnalyzer
+internal sealed class DoubleWritesCheck : Check
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0102", "DoubleWrites",
+    public static CheckRule SupportedRule = new CheckRule(
+        "BC0102",
+        "DoubleWrites",
         "Two tasks should not write the same file",
         "Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
-    public override string FriendlyName => "MSBuild.DoubleWritesAnalyzer";
+    public override string FriendlyName => "MSBuild.DoubleWritesCheck";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
@@ -44,39 +46,39 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
     /// </summary>
     private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);
 
-    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
-        // This analyzer uses a hard-coded list of tasks known to write files.
+        // This check uses a hard-coded list of tasks known to write files.
         switch (context.Data.TaskName)
         {
             case "Csc":
             case "Vbc":
-            case "Fsc": AnalyzeCompilerTask(context); break;
-            case "Copy": AnalyzeCopyTask(context); break;
+            case "Fsc": CheckCompilerTask(context); break;
+            case "Copy": CheckCopyTask(context); break;
         }
     }
 
-    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void CheckCompilerTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
         // Compiler tasks have several parameters representing files being written.
-        AnalyzeParameter("OutputAssembly");
-        AnalyzeParameter("OutputRefAssembly");
-        AnalyzeParameter("DocumentationFile");
-        AnalyzeParameter("PdbFile");
+        CheckParameter("OutputAssembly");
+        CheckParameter("OutputRefAssembly");
+        CheckParameter("DocumentationFile");
+        CheckParameter("PdbFile");
 
-        void AnalyzeParameter(string parameterName)
+        void CheckParameter(string parameterName)
         {
             if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))
             {
                 string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? "";
-                AnalyzeWrite(context, outputPath);
+                CheckWrite(context, outputPath);
             }
         }
     }
 
-    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void CheckCopyTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
@@ -87,19 +89,19 @@ private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> c
             string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? "";
             foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())
             {
-                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));
+                CheckWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));
             }
         }
         else if (taskParameters.TryGetValue("DestinationFiles", out TaskParameter? destinationFiles))
         {
             foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())
             {
-                AnalyzeWrite(context, destinationFilePath);
+                CheckWrite(context, destinationFilePath);
             }
         }
     }
 
-    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)
+    private void CheckWrite(BuildCheckDataContext<TaskInvocationCheckData> context, string fileBeingWritten)
     {
         if (!string.IsNullOrEmpty(fileBeingWritten))
         {
diff --git a/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
new file mode 100644
index 00000000000..3f0052b8d85
--- /dev/null
+++ b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
@@ -0,0 +1,116 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Construction;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal sealed class NoEnvironmentVariablePropertyCheck : Check
+{
+    public static CheckRule SupportedRule = new CheckRule(
+                "BC0103",
+                "NoEnvironmentVariablePropertyCheck",
+                "No implicit property derived from an environment variable should be used during the build",
+                "Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.",
+                new CheckConfiguration() { Severity = CheckResultSeverity.Suggestion });
+
+    private const string RuleId = "BC0103";
+
+    private const string VerboseEnvVariableOutputKey = "allow_displaying_environment_variable_value";
+
+    /// <summary>
+    /// Contains the list of reported environment variables.
+    /// </summary>
+    private readonly HashSet<EnvironmentVariableIdentityKey> _environmentVariablesReported = new HashSet<EnvironmentVariableIdentityKey>();
+
+    private bool _isVerboseEnvVarOutput;
+    private EvaluationCheckScope _scope;
+
+    public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyCheck";
+
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        _scope = configurationContext.CheckConfig[0].EvaluationCheckScope;
+        foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)
+        {
+            bool? isVerboseEnvVarOutput = GetVerboseEnvVarOutputConfig(customConfigurationData, RuleId);
+            _isVerboseEnvVarOutput = isVerboseEnvVarOutput.HasValue && isVerboseEnvVarOutput.Value;           
+        }
+    }
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);
+
+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
+    {
+        if (context.Data.EvaluatedEnvironmentVariables.Count != 0)
+        {
+            foreach (var envVariableData in context.Data.EvaluatedEnvironmentVariables)
+            {
+                if (!CheckScopeClassifier.IsActionInObservedScope(_scope, envVariableData.Value.File,
+                        context.Data.ProjectFilePath))
+                {
+                    continue;
+                }
+                EnvironmentVariableIdentityKey identityKey = new(envVariableData.Key, envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column);
+                if (!_environmentVariablesReported.Contains(identityKey))
+                {
+                    if (_isVerboseEnvVarOutput)
+                    {
+                        context.ReportResult(BuildCheckResult.Create(
+                            SupportedRule,
+                            ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),
+                            $"'{envVariableData.Key}' with value: '{envVariableData.Value.EnvVarValue}'"));
+                    }
+                    else
+                    {
+                        context.ReportResult(BuildCheckResult.Create(
+                            SupportedRule,
+                            ElementLocation.Create(envVariableData.Value.File, envVariableData.Value.Line, envVariableData.Value.Column),
+                            $"'{envVariableData.Key}'"));
+                    }
+
+                    _environmentVariablesReported.Add(identityKey);
+                }
+            }
+        }
+    }
+
+    private static bool? GetVerboseEnvVarOutputConfig(CustomConfigurationData customConfigurationData, string ruleId) => customConfigurationData.RuleId.Equals(ruleId, StringComparison.InvariantCultureIgnoreCase)
+            && (customConfigurationData.ConfigurationData?.TryGetValue(VerboseEnvVariableOutputKey, out string? configVal) ?? false)
+            ? bool.Parse(configVal)
+            : null;
+
+    internal class EnvironmentVariableIdentityKey(string environmentVariableName, string file, int line, int column) : IEquatable<EnvironmentVariableIdentityKey>
+    {
+        public string EnvironmentVariableName { get; } = environmentVariableName;
+
+        public string File { get; } = file;
+
+        public int Line { get; } = line;
+
+        public int Column { get; } = column;
+
+        public override bool Equals(object? obj) => Equals(obj as EnvironmentVariableIdentityKey);
+
+        public bool Equals(EnvironmentVariableIdentityKey? other) =>
+            other != null &&
+            EnvironmentVariableName == other.EnvironmentVariableName &&
+            File == other.File &&
+            Line == other.Line &&
+            Column == other.Column;
+
+        public override int GetHashCode()
+        {
+            int hashCode = 17;
+            hashCode = hashCode * 31 + (File != null ? File.GetHashCode() : 0);
+            hashCode = hashCode * 31 + Line.GetHashCode();
+            hashCode = hashCode * 31 + Column.GetHashCode();
+            return hashCode;
+        }
+    }
+}
diff --git a/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs b/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
new file mode 100644
index 00000000000..f2e7d2fc37a
--- /dev/null
+++ b/src/Build/BuildCheck/Checks/PropertiesUsageCheck.cs
@@ -0,0 +1,242 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal class PropertiesUsageCheck : InternalCheck
+{
+    private static readonly CheckRule _usedBeforeInitializedRule = new CheckRule("BC0201", "PropertyUsedBeforeDeclared",
+        "A property that is accessed should be declared first.",
+        "Property: [{0}] was accessed, but it was never initialized.",
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });
+
+    private static readonly CheckRule _initializedAfterUsedRule = new CheckRule("BC0202", "PropertyDeclaredAfterUsed",
+        "A property should be declared before it is first used.",
+        "Property: [{0}] first declared/initialized at [{1}] used before it was initialized.",
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });
+
+    private static readonly CheckRule _unusedPropertyRule = new CheckRule("BC0203", "UnusedPropertyDeclared",
+        "A property that is not used should not be declared.",
+        "Property: [{0}] was declared/initialized, but it was never used.",
+        new CheckConfiguration() { Severity = CheckResultSeverity.Suggestion, EvaluationCheckScope = EvaluationCheckScope.ProjectFileOnly });
+
+    internal static readonly IReadOnlyList<CheckRule> SupportedRulesList = [_usedBeforeInitializedRule, _initializedAfterUsedRule, _unusedPropertyRule];
+
+    public override string FriendlyName => "MSBuild.PropertiesUsageAnalyzer";
+
+    public override IReadOnlyList<CheckRule> SupportedRules => SupportedRulesList;
+
+    private const string _allowUninitPropsInConditionsKey = "AllowUninitializedPropertiesInConditions";
+    private bool _allowUninitPropsInConditions = false;
+    // Each check can have it's scope and enablement
+    private EvaluationCheckScope _uninitializedReadScope;
+    private EvaluationCheckScope _unusedPropertyScope;
+    private EvaluationCheckScope _initializedAfterUseScope;
+    private bool _uninitializedReadEnabled;
+    private bool _unusedPropertyEnabled;
+    private bool _initializedAfterUseEnabled;
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        var config = configurationContext.CheckConfig.FirstOrDefault(c => c.RuleId == _usedBeforeInitializedRule.Id)
+                ?? CheckConfigurationEffective.Default;
+
+        _uninitializedReadEnabled = config.IsEnabled;
+        _uninitializedReadScope = config.EvaluationCheckScope;
+
+        config = configurationContext.CheckConfig.FirstOrDefault(c => c.RuleId == _unusedPropertyRule.Id)
+                 ?? CheckConfigurationEffective.Default;
+
+        _unusedPropertyEnabled = config.IsEnabled;
+        _unusedPropertyScope = config.EvaluationCheckScope;
+
+        config = configurationContext.CheckConfig.FirstOrDefault(c => c.RuleId == _usedBeforeInitializedRule.Id)
+                 ?? CheckConfigurationEffective.Default;
+
+        _initializedAfterUseEnabled = config.IsEnabled;
+        _initializedAfterUseScope = config.EvaluationCheckScope;
+
+        bool? allowUninitPropsInConditionsRule1 = null;
+        bool? allowUninitPropsInConditionsRule2 = null;
+
+        foreach (CustomConfigurationData customConfigurationData in configurationContext.CustomConfigurationData)
+        {
+            allowUninitPropsInConditionsRule1 =
+                GetAllowUninitPropsInConditionsConfig(customConfigurationData, _usedBeforeInitializedRule.Id);
+            allowUninitPropsInConditionsRule2 =
+                GetAllowUninitPropsInConditionsConfig(customConfigurationData, _initializedAfterUsedRule.Id);
+        }
+
+        if (allowUninitPropsInConditionsRule1.HasValue &&
+            allowUninitPropsInConditionsRule2.HasValue &&
+            allowUninitPropsInConditionsRule1 != allowUninitPropsInConditionsRule2)
+        {
+            throw new BuildCheckConfigurationException(
+                $"[{_usedBeforeInitializedRule.Id}] and [{_initializedAfterUsedRule.Id}] are not allowed to have differing configuration value for [{_allowUninitPropsInConditionsKey}]");
+        }
+
+        if (allowUninitPropsInConditionsRule1.HasValue || allowUninitPropsInConditionsRule2.HasValue)
+        {
+            _allowUninitPropsInConditions = allowUninitPropsInConditionsRule1 ?? allowUninitPropsInConditionsRule2 ?? false;
+        }
+    }
+
+    private static bool? GetAllowUninitPropsInConditionsConfig(CustomConfigurationData customConfigurationData,
+        string ruleId)
+    {
+        if (customConfigurationData.RuleId.Equals(ruleId, StringComparison.InvariantCultureIgnoreCase) &&
+            (customConfigurationData.ConfigurationData?.TryGetValue(_allowUninitPropsInConditionsKey, out string? configVal) ?? false))
+        {
+            return bool.Parse(configVal);
+        }
+
+        return null;
+    }
+
+    public override void RegisterInternalActions(IInternalCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterPropertyReadAction(ProcessPropertyRead);
+
+        if (_unusedPropertyEnabled || _initializedAfterUseEnabled)
+        {
+            registrationContext.RegisterPropertyWriteAction(ProcessPropertyWrite);
+        }
+
+        if (_unusedPropertyEnabled || _uninitializedReadEnabled)
+        {
+            registrationContext.RegisterProjectRequestProcessingDoneAction(DoneWithProject);
+        }
+    }
+
+    private Dictionary<string, IMSBuildElementLocation?> _writenProperties = new(MSBuildNameIgnoreCaseComparer.Default);
+    private HashSet<string> _readProperties = new(MSBuildNameIgnoreCaseComparer.Default);
+    // For the 'Property Initialized after used' check - we are interested in cases where:
+    //   1. Property is read anywhere and then initialized in the checked scope.
+    //   2. Property is read in the checked scope and then initialized anywhere.
+    private Dictionary<string, IMSBuildElementLocation> _uninitializedReadsInScope = new(MSBuildNameIgnoreCaseComparer.Default);
+    private Dictionary<string, IMSBuildElementLocation> _uninitializedReadsOutOfScope = new(MSBuildNameIgnoreCaseComparer.Default);
+
+    private void ProcessPropertyWrite(BuildCheckDataContext<PropertyWriteData> context)
+    {
+        PropertyWriteData writeData = context.Data;
+
+        // If we want to track unused properties - store all definitions that are in scope.
+        if (_unusedPropertyEnabled && CheckScopeClassifier.IsActionInObservedScope(_unusedPropertyScope,
+                writeData.ElementLocation, writeData.ProjectFilePath))
+        {
+            _writenProperties[writeData.PropertyName] = writeData.ElementLocation;
+        }
+
+        if (_initializedAfterUseEnabled && !writeData.IsEmpty)
+        {
+            // For initialized after used check - we can remove the read from dictionary after hitting write - because
+            //  once the property is written it should no more be uninitialized (so shouldn't be added again).
+
+            if (_uninitializedReadsInScope.TryGetValue(writeData.PropertyName, out IMSBuildElementLocation? uninitInScopeReadLocation))
+            {
+                _uninitializedReadsInScope.Remove(writeData.PropertyName);
+
+                context.ReportResult(BuildCheckResult.Create(
+                    _initializedAfterUsedRule,
+                    uninitInScopeReadLocation,
+                    writeData.PropertyName, writeData.ElementLocation?.LocationString ?? string.Empty));
+            }
+
+            if (CheckScopeClassifier.IsActionInObservedScope(_initializedAfterUseScope,
+                    writeData.ElementLocation, writeData.ProjectFilePath) &&
+                _uninitializedReadsOutOfScope.TryGetValue(writeData.PropertyName, out IMSBuildElementLocation? uninitOutScopeReadLocation))
+            {
+                _uninitializedReadsOutOfScope.Remove(writeData.PropertyName);
+
+                context.ReportResult(BuildCheckResult.Create(
+                    _initializedAfterUsedRule,
+                    uninitOutScopeReadLocation,
+                    writeData.PropertyName, writeData.ElementLocation?.LocationString ?? string.Empty));
+            }
+        }
+    }
+
+    private void ProcessPropertyRead(BuildCheckDataContext<PropertyReadData> context)
+    {
+        PropertyReadData readData = context.Data;
+
+        // Self property initialization is not considered as a violation.
+        if (readData.PropertyReadContext != PropertyReadContext.PropertyEvaluationSelf &&
+            // If we are interested in missing usage checking - let's store, regardless of location of read.
+            _unusedPropertyEnabled)
+        {
+            _readProperties.Add(readData.PropertyName);
+        }
+
+        if (readData.IsUninitialized &&
+            (_uninitializedReadEnabled || _initializedAfterUseEnabled) &&
+            readData.PropertyReadContext != PropertyReadContext.PropertyEvaluationSelf &&
+            readData.PropertyReadContext != PropertyReadContext.ConditionEvaluationWithOneSideEmpty &&
+            (!_allowUninitPropsInConditions ||
+             readData.PropertyReadContext != PropertyReadContext.ConditionEvaluation))
+        {
+            // We want to wait with reporting uninitialized reads until we are sure there wasn't later attempts to initialize them.
+            if (_initializedAfterUseEnabled)
+            {
+                if (CheckScopeClassifier.IsActionInObservedScope(_initializedAfterUseScope,
+                        readData.ElementLocation, readData.ProjectFilePath))
+                {
+                    _uninitializedReadsInScope[readData.PropertyName] = readData.ElementLocation;
+                }
+                // If uninitialized read happened in scope and out of scope - keep just that in scope.
+                else if (!_uninitializedReadsInScope.ContainsKey(readData.PropertyName))
+                {
+                    _uninitializedReadsOutOfScope[readData.PropertyName] = readData.ElementLocation;
+                }
+            }
+            else if (CheckScopeClassifier.IsActionInObservedScope(_uninitializedReadScope,
+                         readData.ElementLocation, readData.ProjectFilePath))
+            {
+                // report immediately
+                context.ReportResult(BuildCheckResult.Create(
+                    _usedBeforeInitializedRule,
+                    readData.ElementLocation,
+                    readData.PropertyName));
+            }
+        }
+    }
+
+
+    private void DoneWithProject(BuildCheckDataContext<ProjectRequestProcessingDoneData> context)
+    {
+        foreach (var propWithLocation in _writenProperties)
+        {
+            if (propWithLocation.Value != null && !_readProperties.Contains(propWithLocation.Key))
+            {
+                context.ReportResult(BuildCheckResult.Create(
+                    _unusedPropertyRule,
+                    propWithLocation.Value,
+                    propWithLocation.Key));
+            }
+        }
+
+        // Report the remaining uninitialized reads - as if 'initialized after read' check was enabled - we cannot report
+        //  uninitialized reads immediately (instead we wait if they are attempted to be initialized late).
+        foreach (var uninitializedRead in _uninitializedReadsInScope)
+        {
+            context.ReportResult(BuildCheckResult.Create(
+                _usedBeforeInitializedRule,
+                uninitializedRead.Value,
+                uninitializedRead.Key));
+        }
+
+        _readProperties = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+        _writenProperties = new Dictionary<string, IMSBuildElementLocation?>(MSBuildNameIgnoreCaseComparer.Default);
+        _uninitializedReadsInScope = new Dictionary<string, IMSBuildElementLocation>(MSBuildNameIgnoreCaseComparer.Default);
+    }
+}
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
similarity index 79%
rename from src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
rename to src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index a09866ebb22..1ec84093e3a 100644
--- a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -9,19 +9,21 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
+internal sealed class SharedOutputPathCheck : Check
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0101", "ConflictingOutputPath",
+    private const string RuleId = "BC0101";
+    public static CheckRule SupportedRule = new CheckRule(RuleId, "ConflictingOutputPath",
         "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
         "Projects {0} and {1} have conflicting output paths: {2}.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });
 
-    public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
+    public override string FriendlyName => "MSBuild.SharedOutputPathCheck";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
@@ -36,7 +38,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
     private readonly Dictionary<string, string> _projectsPerOutputPath = new(StringComparer.CurrentCultureIgnoreCase);
     private readonly HashSet<string> _projects = new(StringComparer.CurrentCultureIgnoreCase);
 
-    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         if (!_projects.Add(context.Data.ProjectFilePath))
         {
@@ -49,6 +51,7 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         context.Data.EvaluatedProperties.TryGetValue("IntermediateOutputPath", out objPath);
 
         string? absoluteBinPath = CheckAndAddFullOutputPath(binPath, context);
+        // Check objPath only if it is different from binPath
         if (
             !string.IsNullOrEmpty(objPath) && !string.IsNullOrEmpty(absoluteBinPath) &&
             !objPath.Equals(binPath, StringComparison.CurrentCultureIgnoreCase)
@@ -59,7 +62,7 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         }
     }
 
-    private string? CheckAndAddFullOutputPath(string? path, BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private string? CheckAndAddFullOutputPath(string? path, BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         if (string.IsNullOrEmpty(path))
         {
@@ -73,6 +76,9 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
             path = Path.Combine(Path.GetDirectoryName(projectPath)!, path);
         }
 
+        // Normalize the path to avoid false negatives due to different path representations.
+        path = FileUtilities.NormalizePath(path);
+
         if (_projectsPerOutputPath.TryGetValue(path!, out string? conflictingProject))
         {
             context.ReportResult(BuildCheckResult.Create(
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
deleted file mode 100644
index 9d7738922e7..00000000000
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.Experimental.BuildCheck;
-
-namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-
-/// <summary>
-/// Counterpart type for BuildAnalyzerConfiguration - with all properties non-nullable
-/// </summary>
-internal sealed class BuildAnalyzerConfigurationInternal
-{
-    public BuildAnalyzerConfigurationInternal(string ruleId, EvaluationAnalysisScope evaluationAnalysisScope, BuildAnalyzerResultSeverity severity, bool isEnabled)
-    {
-        RuleId = ruleId;
-        EvaluationAnalysisScope = evaluationAnalysisScope;
-        Severity = severity;
-        IsEnabled = isEnabled;
-    }
-
-    public string RuleId { get; }
-    public EvaluationAnalysisScope EvaluationAnalysisScope { get; }
-    public BuildAnalyzerResultSeverity Severity { get; }
-    public bool IsEnabled { get; }
-
-    // Intentionally not checking the RuleId
-    //  as for analyzers with multiple rules, we can squash config to a single one,
-    //  if the ruleId is the only thing differing.
-    public bool IsSameConfigurationAs(BuildAnalyzerConfigurationInternal? other) =>
-        other != null &&
-        Severity == other.Severity &&
-        IsEnabled == other.IsEnabled &&
-        EvaluationAnalysisScope == other.EvaluationAnalysisScope;
-}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
new file mode 100644
index 00000000000..419ca2c9f26
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -0,0 +1,191 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck.Utilities;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+internal class BuildCheckBuildEventHandler
+{
+    private readonly IBuildCheckManager _buildCheckManager;
+    private readonly ICheckContextFactory _checkContextFactory;
+
+    private Dictionary<Type, Action<BuildEventArgs>> _eventHandlers;
+    private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlersFull;
+    private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlersRestore;
+
+    internal BuildCheckBuildEventHandler(
+        ICheckContextFactory checkContextFactory,
+        IBuildCheckManager buildCheckManager)
+    {
+        _buildCheckManager = buildCheckManager;
+        _checkContextFactory = checkContextFactory;
+
+        _eventHandlersFull = new()
+        {
+            { typeof(BuildSubmissionStartedEventArgs), (BuildEventArgs e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
+            { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
+            { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
+            { typeof(EnvironmentVariableReadEventArgs), (BuildEventArgs e) => HandleEnvironmentVariableReadEvent((EnvironmentVariableReadEventArgs)e) },
+            { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(e.BuildEventContext!, ((ProjectStartedEventArgs)e).ProjectFile!) },
+            { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => HandleProjectFinishedRequest((ProjectFinishedEventArgs)e) },
+            { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
+            { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => HandleBuildCheckAcquisitionEvent((BuildCheckAcquisitionEventArgs)e) },
+            { typeof(TaskStartedEventArgs), (BuildEventArgs e) => HandleTaskStartedEvent((TaskStartedEventArgs)e) },
+            { typeof(TaskFinishedEventArgs), (BuildEventArgs e) => HandleTaskFinishedEvent((TaskFinishedEventArgs)e) },
+            { typeof(TaskParameterEventArgs), (BuildEventArgs e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
+            { typeof(BuildFinishedEventArgs), (BuildEventArgs e) => HandleBuildFinishedEvent((BuildFinishedEventArgs)e) },
+        };
+
+        // During restore we'll wait only for restore to be done.
+        _eventHandlersRestore = new()
+        {
+            { typeof(BuildSubmissionStartedEventArgs), (BuildEventArgs e) => HandleBuildSubmissionStartedEvent((BuildSubmissionStartedEventArgs)e) },
+        };
+
+        _eventHandlers = _eventHandlersFull;
+    }
+
+    public void HandleBuildEvent(BuildEventArgs e)
+    {
+        if (_eventHandlers.TryGetValue(e.GetType(), out Action<BuildEventArgs>? handler))
+        {
+            handler(e);
+        }
+    }
+
+    private void HandleBuildSubmissionStartedEvent(BuildSubmissionStartedEventArgs eventArgs)
+    {
+        eventArgs.GlobalProperties.TryGetValue(MSBuildConstants.MSBuildIsRestoring, out string? restoreProperty);
+        bool isRestoring = restoreProperty is not null && Convert.ToBoolean(restoreProperty);
+
+        _eventHandlers = isRestoring ? _eventHandlersRestore : _eventHandlersFull;
+    }
+
+    private void HandleProjectEvaluationFinishedEvent(ProjectEvaluationFinishedEventArgs eventArgs)
+    {
+        if (!IsMetaProjFile(eventArgs.ProjectFile))
+        {
+            _buildCheckManager.ProcessEvaluationFinishedEventArgs(
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
+                eventArgs);
+
+            _buildCheckManager.EndProjectEvaluation(eventArgs.BuildEventContext!);
+        }
+    }
+
+    private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventArgs eventArgs)
+    {
+        if (!IsMetaProjFile(eventArgs.ProjectFile))
+        {
+            var checkContext = _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!);
+            _buildCheckManager.ProjectFirstEncountered(
+                BuildCheckDataSource.EventArgs,
+                checkContext,
+                eventArgs.ProjectFile!);
+            _buildCheckManager.ProcessProjectEvaluationStarted(
+                checkContext,
+                eventArgs.ProjectFile!);
+        }
+    }
+
+    private void HandleProjectFinishedRequest(ProjectFinishedEventArgs eventArgs)
+        => _buildCheckManager.EndProjectRequest(
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
+                eventArgs!.ProjectFile!);
+
+    private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
+    {
+        if (!eventArgs.IsAggregatedGlobalReport)
+        {
+            _stats.Merge(eventArgs.TracingData, (span1, span2) => span1 + span2);
+        }
+    }
+
+    private void HandleTaskStartedEvent(TaskStartedEventArgs eventArgs)
+        => _buildCheckManager.ProcessTaskStartedEventArgs(
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
+                eventArgs);
+
+    private void HandleTaskFinishedEvent(TaskFinishedEventArgs eventArgs)
+        => _buildCheckManager.ProcessTaskFinishedEventArgs(
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
+                eventArgs);
+
+    private void HandleTaskParameterEvent(TaskParameterEventArgs eventArgs)
+        => _buildCheckManager.ProcessTaskParameterEventArgs(
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
+                eventArgs);
+
+    private void HandleBuildCheckAcquisitionEvent(BuildCheckAcquisitionEventArgs eventArgs)
+        => _buildCheckManager.ProcessCheckAcquisition(
+                eventArgs.ToCheckAcquisitionData(),
+                _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
+
+    private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs eventArgs)
+        => _buildCheckManager.ProcessEnvironmentVariableReadEventArgs(
+                _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)),
+                eventArgs);
+
+    private bool IsMetaProjFile(string? projectFile) => projectFile?.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase) == true;
+
+    private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();
+
+    private void HandleBuildFinishedEvent(BuildFinishedEventArgs eventArgs)
+    {
+        _buildCheckManager.ProcessBuildFinished(_checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!));
+
+        _stats.Merge(_buildCheckManager.CreateCheckTracingStats(), (span1, span2) => span1 + span2);
+
+        LogCheckStats(_checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
+    }
+
+    private void LogCheckStats(ICheckContext checkContext)
+    {
+        Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
+        Dictionary<string, TimeSpan> checkStats = new Dictionary<string, TimeSpan>();
+
+        foreach (var stat in _stats)
+        {
+            if (stat.Key.StartsWith(BuildCheckConstants.infraStatPrefix))
+            {
+                string newKey = stat.Key.Substring(BuildCheckConstants.infraStatPrefix.Length);
+                infraStats[newKey] = stat.Value;
+            }
+            else
+            {
+                checkStats[stat.Key] = stat.Value;
+            }
+        }
+
+        BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
+        { BuildEventContext = checkContext.BuildEventContext };
+
+        checkContext.DispatchBuildEvent(statEvent);
+
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
+        string infraData = BuildCsvString("Infrastructure run times", infraStats);
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, infraData);
+        string checkData = BuildCsvString("Checks run times", checkStats);
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, checkData);
+    }
+
+    private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData)
+        => title + Environment.NewLine + String.Join(Environment.NewLine, rowData.Select(a => $"{a.Key},{a.Value}")) + Environment.NewLine;
+
+    private BuildEventContext GetBuildEventContext(BuildEventArgs e) => e.BuildEventContext
+        ?? new BuildEventContext(
+                BuildEventContext.InvalidNodeId,
+                BuildEventContext.InvalidTargetId,
+                BuildEventContext.InvalidProjectContextId,
+                BuildEventContext.InvalidTaskId);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 32078038875..fd812421526 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -6,153 +6,208 @@
 using System.Linq;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
-/// A manager of the runs of the analyzers - deciding based on configuration of what to run and what to postfilter.
+/// A manager of the runs of the checks - deciding based on configuration of what to run and what to postfilter.
 /// </summary>
 internal sealed class BuildCheckCentralContext
 {
-    private readonly ConfigurationProvider _configurationProvider;
+    private readonly IConfigurationProvider _configurationProvider;
 
-    internal BuildCheckCentralContext(ConfigurationProvider configurationProvider)
-    {
-        _configurationProvider = configurationProvider;
-    }
+    internal BuildCheckCentralContext(IConfigurationProvider configurationProvider)
+        => _configurationProvider = configurationProvider;
 
     private record CallbackRegistry(
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>)> EvaluatedPropertiesActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<TaskInvocationAnalysisData>>)> TaskInvocationActions)
+        List<(CheckWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<ParsedItemsCheckData>>)> ParsedItemsActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<TaskInvocationCheckData>>)> TaskInvocationActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<PropertyReadData>>)> PropertyReadActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<ProjectRequestProcessingDoneData>>)> ProjectRequestProcessingDoneActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<BuildFinishedCheckData>>)> BuildFinishedActions)
     {
-        public CallbackRegistry() : this([], [], []) { }
+        public CallbackRegistry() : this([], [], [], [], [], [], []) { }
+
+        internal void DeregisterCheck(CheckWrapper check)
+        {
+            EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == check);
+            ParsedItemsActions.RemoveAll(a => a.Item1 == check);
+            PropertyReadActions.RemoveAll(a => a.Item1 == check);
+            PropertyWriteActions.RemoveAll(a => a.Item1 == check);
+            ProjectRequestProcessingDoneActions.RemoveAll(a => a.Item1 == check);
+            BuildFinishedActions.RemoveAll(a => a.Item1 == check);
+        }
     }
 
     // In a future we can have callbacks per project as well
     private readonly CallbackRegistry _globalCallbacks = new();
 
     // This we can potentially use to subscribe for receiving evaluated props in the
-    //  build event args. However - this needs to be done early on, when analyzers might not be known yet
+    //  build event args. However - this needs to be done early on, when checks might not be known yet
     internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Count > 0;
+
     internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Count > 0;
+
     internal bool HasTaskInvocationActions => _globalCallbacks.TaskInvocationActions.Count > 0;
+    internal bool HasPropertyReadActions => _globalCallbacks.PropertyReadActions.Count > 0;
+    internal bool HasPropertyWriteActions => _globalCallbacks.PropertyWriteActions.Count > 0;
+    internal bool HasBuildFinishedActions => _globalCallbacks.BuildFinishedActions.Count > 0;
 
-    internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+    internal void RegisterEvaluatedPropertiesAction(CheckWrapper check, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
         // Here we might want to communicate to node that props need to be sent.
         //  (it was being communicated via MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION)
-        => RegisterAction(analyzer, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
+        => RegisterAction(check, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
 
-    internal void RegisterParsedItemsAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
-        => RegisterAction(analyzer, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
+    internal void RegisterParsedItemsAction(CheckWrapper check, Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction)
+        => RegisterAction(check, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
 
-    internal void RegisterTaskInvocationAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
-        => RegisterAction(analyzer, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
+    internal void RegisterTaskInvocationAction(CheckWrapper check, Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
+        => RegisterAction(check, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
+
+    internal void RegisterPropertyReadAction(CheckWrapper check, Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
+        => RegisterAction(check, propertyReadAction, _globalCallbacks.PropertyReadActions);
+
+    internal void RegisterPropertyWriteAction(CheckWrapper check, Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
+        => RegisterAction(check, propertyWriteAction, _globalCallbacks.PropertyWriteActions);
+
+    internal void RegisterProjectRequestProcessingDoneAction(CheckWrapper check, Action<BuildCheckDataContext<ProjectRequestProcessingDoneData>> projectDoneAction)
+        => RegisterAction(check, projectDoneAction, _globalCallbacks.ProjectRequestProcessingDoneActions);
+
+    internal void RegisterBuildFinishedAction(CheckWrapper check, Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction)
+        => RegisterAction(check, buildFinishedAction, _globalCallbacks.BuildFinishedActions);
 
     private void RegisterAction<T>(
-        BuildAnalyzerWrapper wrappedAnalyzer,
+        CheckWrapper wrappedCheck,
         Action<BuildCheckDataContext<T>> handler,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
-        where T : AnalysisData
+        List<(CheckWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
+        where T : CheckData
     {
         void WrappedHandler(BuildCheckDataContext<T> context)
         {
-            using var _ = wrappedAnalyzer.StartSpan();
+            using var _ = wrappedCheck.StartSpan();
             handler(context);
         }
 
         lock (handlersRegistry)
         {
-            handlersRegistry.Add((wrappedAnalyzer, WrappedHandler));
+            handlersRegistry.Add((wrappedCheck, WrappedHandler));
         }
     }
 
-    internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
+    internal void DeregisterCheck(CheckWrapper check)
     {
-        _globalCallbacks.EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == analyzer);
-        _globalCallbacks.ParsedItemsActions.RemoveAll(a => a.Item1 == analyzer);
-        _globalCallbacks.TaskInvocationActions.RemoveAll(a => a.Item1 == analyzer);
+        _globalCallbacks.DeregisterCheck(check);
     }
 
     internal void RunEvaluatedPropertiesActions(
-        EvaluatedPropertiesAnalysisData evaluatedPropertiesAnalysisData,
-        LoggingContext loggingContext,
-        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult>
+        EvaluatedPropertiesCheckData evaluatedPropertiesCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesAnalysisData,
-            loggingContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesCheckData,
+            checkContext, resultHandler);
 
     internal void RunParsedItemsActions(
-        ParsedItemsAnalysisData parsedItemsAnalysisData,
-        LoggingContext loggingContext,
-        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult>
+        ParsedItemsCheckData parsedItemsCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsAnalysisData,
-            loggingContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsCheckData,
+            checkContext, resultHandler);
 
     internal void RunTaskInvocationActions(
-        TaskInvocationAnalysisData taskInvocationAnalysisData,
-        LoggingContext loggingContext,
-        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult>
+        TaskInvocationCheckData taskInvocationCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationAnalysisData,
-            loggingContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationCheckData,
+            checkContext, resultHandler);
+
+    internal void RunPropertyReadActions(
+        PropertyReadData propertyReadDataData,
+        CheckLoggingContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.PropertyReadActions, propertyReadDataData,
+            checkContext, resultHandler);
+
+    internal void RunPropertyWriteActions(
+        PropertyWriteData propertyWriteData,
+        CheckLoggingContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.PropertyWriteActions, propertyWriteData,
+            checkContext, resultHandler);
+
+    internal void RunProjectProcessingDoneActions(
+        ProjectRequestProcessingDoneData projectProcessingDoneData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.ProjectRequestProcessingDoneActions, projectProcessingDoneData,
+            checkContext, resultHandler);
+
+    internal void RunBuildFinishedActions(
+        BuildFinishedCheckData buildFinishedCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.BuildFinishedActions, buildFinishedCheckData,
+            checkContext, resultHandler);
 
     private void RunRegisteredActions<T>(
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
-        T analysisData,
-        LoggingContext loggingContext,
-        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult> resultHandler)
-    where T : AnalysisData
+        List<(CheckWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
+        T checkData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler)
+    where T : CheckData
     {
-        string projectFullPath = analysisData.ProjectFilePath;
-
-        // Alternatively we might want to actually do this all in serial, but asynchronously (blocking queue)
-        Parallel.ForEach(
-            registeredCallbacks,
-            new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount },
-            /* (BuildAnalyzerWrapper2, Action<BuildAnalysisContext<T>>) */
-            analyzerCallback =>
-            {
-                // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
-                //  to the relevant analyzer (with only the currently accounted part as being the 'core-execution' subspan)
+        string projectFullPath = checkData.ProjectFilePath;
 
-                BuildAnalyzerConfigurationInternal? commonConfig = analyzerCallback.Item1.CommonConfig;
-                BuildAnalyzerConfigurationInternal[] configPerRule;
+        foreach (var checkCallback in registeredCallbacks)
+        {
+            // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
+            //  to the relevant check (with BuildCheckConfigurationEffective only the currently accounted part as being the 'core-execution' subspan)
 
-                if (commonConfig != null)
-                {
-                    if (!commonConfig.IsEnabled)
-                    {
-                        return;
-                    }
+            CheckConfigurationEffective? commonConfig = checkCallback.Item1.CommonConfig;
+            CheckConfigurationEffective[] configPerRule;
 
-                    configPerRule = new[] { commonConfig };
+            if (commonConfig != null)
+            {
+                if (!commonConfig.IsEnabled)
+                {
+                    return;
                 }
-                else
+
+                configPerRule = new[] { commonConfig };
+            }
+            else
+            {
+                configPerRule =
+                    _configurationProvider.GetMergedConfigurations(projectFullPath,
+                        checkCallback.Item1.Check);
+                if (configPerRule.All(c => !c.IsEnabled))
                 {
-                    configPerRule =
-                        _configurationProvider.GetMergedConfigurations(projectFullPath,
-                            analyzerCallback.Item1.BuildAnalyzer);
-                    if (configPerRule.All(c => !c.IsEnabled))
-                    {
-                        return;
-                    }
+                    return;
                 }
+            }
 
-                // Here we might want to check the configPerRule[0].EvaluationAnalysisScope - if the input data supports that
-                // The decision and implementation depends on the outcome of the investigation tracked in:
-                // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
+            // Here we might want to check the configPerRule[0].EvaluationsCheckScope - if the input data supports that
+            // The decision and implementation depends on the outcome of the investigation tracked in:
+            // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
 
-                BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
-                    analyzerCallback.Item1,
-                    loggingContext,
-                    configPerRule,
-                    resultHandler,
-                    analysisData);
+            BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
+                checkCallback.Item1,
+                checkContext,
+                configPerRule,
+                resultHandler,
+                checkData);
 
-                analyzerCallback.Item2(context);
-            });
+            checkCallback.Item2(context);
+        }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
index 69f3335681d..98c04bb78f5 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -13,7 +13,7 @@ internal sealed class BuildCheckConfigurationException : Exception
 {
     /// <summary>
     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
-    /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
+    /// This exception usually leads to defuncting the particular check for the rest of the build (even if issue occured with a single project).
     /// </summary>
     internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;
 
@@ -26,4 +26,7 @@ public BuildCheckConfigurationException(string message, BuildCheckConfigurationE
     {
         this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
     }
+
+    public BuildCheckConfigurationException(string message, Exception innerException) : base(message, innerException)
+    { }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 7dad5f0c4da..7e581e2979d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -5,26 +5,34 @@
 using System.Collections.Generic;
 using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
 using Microsoft.Build.Experimental.BuildCheck.Utilities;
-using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
+/// <summary>
+/// Central logger for the build check infrastructure.
+/// Receives events from the <see cref="BuildCheckForwardingLogger"/>.
+/// Processes the events and forwards them to the <see cref="IBuildCheckManager"/> and registered checks.
+/// </summary>
+/// <remarks>
+/// Ensure that the consuming events are in sync with <see cref="BuildCheckForwardingLogger"/>.
+/// </remarks>
 internal sealed class BuildCheckConnectorLogger : ILogger
 {
-    private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlers;
+    private readonly BuildCheckBuildEventHandler _eventHandler;
     private readonly IBuildCheckManager _buildCheckManager;
-    private readonly IBuildAnalysisLoggingContextFactory _loggingContextFactory;
+    private readonly ICheckContextFactory _checkContextFactory;
 
     internal BuildCheckConnectorLogger(
-        IBuildAnalysisLoggingContextFactory loggingContextFactory,
+        ICheckContextFactory checkContextFactory,
         IBuildCheckManager buildCheckManager)
     {
         _buildCheckManager = buildCheckManager;
-        _loggingContextFactory = loggingContextFactory;
-        _eventHandlers = GetBuildEventHandlers();
+        _checkContextFactory = checkContextFactory;
+        _eventHandler = new BuildCheckBuildEventHandler(checkContextFactory, buildCheckManager);
     }
 
     public LoggerVerbosity Verbosity { get; set; }
@@ -34,12 +42,12 @@ internal BuildCheckConnectorLogger(
     public void Initialize(IEventSource eventSource)
     {
         eventSource.AnyEventRaised += EventSource_AnyEventRaised;
-        eventSource.BuildFinished += EventSource_BuildFinished;
 
         if (eventSource is IEventSource3 eventSource3)
         {
             eventSource3.IncludeTaskInputs();
         }
+
         if (eventSource is IEventSource4 eventSource4)
         {
             eventSource4.IncludeEvaluationPropertiesAndItems();
@@ -50,127 +58,6 @@ public void Shutdown()
     {
     }
 
-    private void HandleProjectEvaluationFinishedEvent(ProjectEvaluationFinishedEventArgs eventArgs)
-    {
-        if (!IsMetaProjFile(eventArgs.ProjectFile))
-        {
-            _buildCheckManager.ProcessEvaluationFinishedEventArgs(
-                _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
-                eventArgs);
-
-            _buildCheckManager.EndProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!);
-        }
-    }
-
-    private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventArgs eventArgs)
-    {
-        if (!IsMetaProjFile(eventArgs.ProjectFile))
-        {
-            _buildCheckManager.StartProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!, eventArgs.ProjectFile!);
-        }
-    }
-
-    private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
-    {
-        if (!eventArgs.IsAggregatedGlobalReport)
-        {
-            _stats.Merge(eventArgs.TracingData, (span1, span2) => span1 + span2);
-        }
-    }
-
-    private void HandleTaskStartedEvent(TaskStartedEventArgs eventArgs)
-    {
-        _buildCheckManager.ProcessTaskStartedEventArgs(
-            _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
-            eventArgs);
-    }
-
-    private void HandleTaskFinishedEvent(TaskFinishedEventArgs eventArgs)
-    {
-        _buildCheckManager.ProcessTaskFinishedEventArgs(
-            _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
-            eventArgs);
-    }
-
-    private void HandleTaskParameterEvent(TaskParameterEventArgs eventArgs)
-    {
-        _buildCheckManager.ProcessTaskParameterEventArgs(
-            _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
-            eventArgs);
-    }
-
-    private bool IsMetaProjFile(string? projectFile) => !string.IsNullOrEmpty(projectFile) && projectFile!.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase);
-
     private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
-    {
-        if (_eventHandlers.TryGetValue(e.GetType(), out Action<BuildEventArgs>? handler))
-        {
-            handler(e);
-        }
-    }
-
-    private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();
-
-    private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
-    {
-        LoggingContext loggingContext = _loggingContextFactory.CreateLoggingContext(GetBuildEventContext(e));
-
-        _stats.Merge(_buildCheckManager.CreateAnalyzerTracingStats(), (span1, span2) => span1 + span2);
-        LogAnalyzerStats(loggingContext);
-    }
-
-    private void LogAnalyzerStats(LoggingContext loggingContext)
-    {
-        Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
-        Dictionary<string, TimeSpan> analyzerStats = new Dictionary<string, TimeSpan>();
-
-        foreach (var stat in _stats)
-        {
-            if (stat.Key.StartsWith(BuildCheckConstants.infraStatPrefix))
-            {
-                string newKey = stat.Key.Substring(BuildCheckConstants.infraStatPrefix.Length);
-                infraStats[newKey] = stat.Value;
-            }
-            else
-            {
-                analyzerStats[stat.Key] = stat.Value;
-            }
-        }
-
-        BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
-        { BuildEventContext = loggingContext.BuildEventContext };
-
-        loggingContext.LogBuildEvent(statEvent);
-
-        loggingContext.LogCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
-        string infraData = BuildCsvString("Infrastructure run times", infraStats);
-        loggingContext.LogCommentFromText(MessageImportance.Low, infraData);
-        string analyzerData = BuildCsvString("Analyzer run times", analyzerStats);
-        loggingContext.LogCommentFromText(MessageImportance.Low, analyzerData);
-    }
-
-    private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData)
-    {
-        return title + Environment.NewLine + String.Join(Environment.NewLine, rowData.Select(a => $"{a.Key},{a.Value}")) + Environment.NewLine;
-    }
-
-    private Dictionary<Type, Action<BuildEventArgs>> GetBuildEventHandlers() => new()
-    {
-        { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs)e) },
-        { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs)e) },
-        { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
-        { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => _buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
-        { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
-        { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData(), GetBuildEventContext(e)) },
-        { typeof(TaskStartedEventArgs), (BuildEventArgs e) => HandleTaskStartedEvent((TaskStartedEventArgs)e) },
-        { typeof(TaskFinishedEventArgs), (BuildEventArgs e) => HandleTaskFinishedEvent((TaskFinishedEventArgs)e) },
-        { typeof(TaskParameterEventArgs), (BuildEventArgs e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
-    };
-
-    private BuildEventContext GetBuildEventContext(BuildEventArgs e) => e.BuildEventContext
-        ?? new BuildEventContext(
-                BuildEventContext.InvalidNodeId,
-                BuildEventContext.InvalidTargetId,
-                BuildEventContext.InvalidProjectContextId,
-                BuildEventContext.InvalidTaskId);
+        => _eventHandler.HandleBuildEvent(e);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
deleted file mode 100644
index 76ac5ec7767..00000000000
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Threading;
-using Microsoft.Build.Experimental.BuildCheck;
-
-namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-
-internal sealed class BuildCheckRegistrationContext(BuildAnalyzerWrapper analyzerWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
-{
-    public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
-    {
-        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(analyzerWrapper, evaluatedPropertiesAction);
-    }
-
-    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
-    {
-        buildCheckCentralContext.RegisterParsedItemsAction(analyzerWrapper, parsedItemsAction);
-    }
-
-    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
-    {
-        buildCheckCentralContext.RegisterTaskInvocationAction(analyzerWrapper, taskInvocationAction);
-    }
-}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
index 6e8f969b544..491fe92d700 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
@@ -7,13 +7,63 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Framework;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.BuildCheckManagerProvider;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// Forwarding logger for the build check infrastructure.
-/// For now we jus want to forward all events, while disable verbose logging of tasks.
+/// For now we just want to forward all events that are needed for BuildCheckConnectorLogger and filter out all other.
+/// If the custom check is detected, starts to unconditionally forward all events.
 /// In the future we may need more specific behavior.
 /// </summary>
-internal class BuildCheckForwardingLogger : CentralForwardingLogger
-{ }
+/// <remarks>
+/// Ensure that events filtering is in sync with <see cref="BuildCheckConnectorLogger"/>
+/// </remarks>
+internal class BuildCheckForwardingLogger : IForwardingLogger
+{
+    public IEventRedirector? BuildEventRedirector { get; set; }
+
+    public int NodeId { get; set; }
+
+    public LoggerVerbosity Verbosity { get => LoggerVerbosity.Quiet; set { return; } }
+
+    public string? Parameters { get; set; }
+
+    /// <summary>
+    /// Set of events to be forwarded to  <see cref="BuildCheckConnectorLogger"/>
+    /// </summary>
+    private HashSet<Type> _eventsToForward = new HashSet<Type>
+    {
+        typeof(EnvironmentVariableReadEventArgs),
+        typeof(BuildSubmissionStartedEventArgs),
+        typeof(ProjectEvaluationFinishedEventArgs),
+        typeof(ProjectEvaluationStartedEventArgs),
+        typeof(ProjectStartedEventArgs),
+        typeof(ProjectFinishedEventArgs),
+        typeof(BuildCheckTracingEventArgs),
+        typeof(BuildCheckAcquisitionEventArgs),
+        typeof(TaskStartedEventArgs),
+        typeof(TaskFinishedEventArgs),
+        typeof(TaskParameterEventArgs)
+    };
+
+    public void Initialize(IEventSource eventSource, int nodeCount) => Initialize(eventSource);
+
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+    }
+
+    public void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent)
+    {
+        if (_eventsToForward.Contains(buildEvent.GetType()))
+        {
+            BuildEventRedirector?.ForwardEvent(buildEvent);
+        }
+    }
+
+    public void Shutdown() { }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 945990a102b..7f76541d134 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -2,23 +2,25 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Linq;
 using System.Threading;
+using System.Diagnostics;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck.Acquisition;
-using Microsoft.Build.Experimental.BuildCheck.Analyzers;
-using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal delegate BuildAnalyzer BuildAnalyzerFactory();
-internal delegate BuildAnalyzerWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
+internal delegate Check CheckFactory();
+internal delegate CheckWrapper CheckWrapperFactory(ConfigurationContext configurationContext);
 
 /// <summary>
 /// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
@@ -31,6 +33,10 @@ internal sealed class BuildCheckManagerProvider : IBuildCheckManagerProvider
 
     public IBuildCheckManager Instance => GlobalInstance;
 
+    public IBuildEngineDataRouter BuildEngineDataRouter => (IBuildEngineDataRouter)GlobalInstance;
+
+    public static IBuildEngineDataRouter? GlobalBuildEngineDataRouter => (IBuildEngineDataRouter?)s_globalInstance;
+
     internal static IBuildComponent CreateComponent(BuildComponentType type)
     {
         ErrorUtilities.VerifyThrow(type == BuildComponentType.BuildCheckManagerProvider, "Cannot create components of type {0}", type);
@@ -46,7 +52,7 @@ public void InitializeComponent(IBuildComponentHost host)
             IBuildCheckManager instance;
             if (host!.BuildParameters.IsBuildCheckEnabled)
             {
-                instance = new BuildCheckManager(host.LoggingService);
+                instance = new BuildCheckManager();
             }
             else
             {
@@ -61,22 +67,20 @@ public void InitializeComponent(IBuildComponentHost host)
 
     public void ShutdownComponent() => GlobalInstance.Shutdown();
 
-    internal sealed class BuildCheckManager : IBuildCheckManager
+    internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRouter
     {
         private readonly TracingReporter _tracingReporter = new TracingReporter();
-        private readonly ConfigurationProvider _configurationProvider = new ConfigurationProvider();
+        private readonly IConfigurationProvider _configurationProvider = new ConfigurationProvider();
         private readonly BuildCheckCentralContext _buildCheckCentralContext;
-        private readonly ILoggingService _loggingService;
-        private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
+        private readonly List<CheckFactoryContext> _checkRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
         private readonly BuildEventsProcessor _buildEventsProcessor;
         private readonly IBuildCheckAcquisitionModule _acquisitionModule;
 
-        internal BuildCheckManager(ILoggingService loggingService)
+        internal BuildCheckManager()
         {
-            _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
-            _acquisitionModule = new BuildCheckAcquisitionModule(loggingService);
-            _loggingService = loggingService;
+            _checkRegistry = new List<CheckFactoryContext>();
+            _acquisitionModule = new BuildCheckAcquisitionModule();
             _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
         }
@@ -86,7 +90,7 @@ internal BuildCheckManager(ILoggingService loggingService)
 
         /// <summary>
         /// Notifies the manager that the data source will be used -
-        ///   so it should register the built-in analyzers for the source if it hasn't been done yet.
+        ///   so it should register the built-in checks for the source if it hasn't been done yet.
         /// </summary>
         /// <param name="buildCheckDataSource"></param>
         public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
@@ -95,226 +99,228 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
             if (!_enabledDataSources[(int)buildCheckDataSource])
             {
                 _enabledDataSources[(int)buildCheckDataSource] = true;
-                RegisterBuiltInAnalyzers(buildCheckDataSource);
-            }
+                RegisterBuiltInChecks(buildCheckDataSource);
+            } 
             stopwatch.Stop();
             _tracingReporter.AddSetDataSourceStats(stopwatch.Elapsed);
         }
 
-        public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext)
+        public void ProcessCheckAcquisition(
+            CheckAcquisitionData acquisitionData,
+            ICheckContext checkContext)
         {
             Stopwatch stopwatch = Stopwatch.StartNew();
             if (IsInProcNode)
             {
-                var analyzersFactories = _acquisitionModule.CreateBuildAnalyzerFactories(acquisitionData, buildEventContext);
-                if (analyzersFactories.Count != 0)
+                var checksFactories = _acquisitionModule.CreateCheckFactories(acquisitionData, checkContext);
+                if (checksFactories.Count != 0)
                 {
-                    RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, analyzersFactories, buildEventContext);
+                    RegisterCustomCheck(acquisitionData.ProjectPath, BuildCheckDataSource.EventArgs, checksFactories, checkContext);
                 }
                 else
                 {
-                    _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerFailedAcquisition", acquisitionData.AssemblyPath);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedAcquisition", acquisitionData.AssemblyPath);
                 }
             }
             else
             {
                 BuildCheckAcquisitionEventArgs eventArgs = acquisitionData.ToBuildEventArgs();
-                eventArgs.BuildEventContext = buildEventContext;
+                eventArgs.BuildEventContext = checkContext.BuildEventContext!;
 
-                _loggingService.LogBuildEvent(eventArgs);
+                checkContext.DispatchBuildEvent(eventArgs);
             }
+
             stopwatch.Stop();
             _tracingReporter.AddAcquisitionStats(stopwatch.Elapsed);
         }
 
         private static T Construct<T>() where T : new() => new();
 
-        private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][] s_builtInFactoriesPerDataSource =
+        private static readonly (string[] ruleIds, bool defaultEnablement, CheckFactory factory)[][] s_builtInFactoriesPerDataSource =
         [
+
             // BuildCheckDataSource.EventArgs
             [
-                ([SharedOutputPathAnalyzer.SupportedRule.Id], SharedOutputPathAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathAnalyzer>),
-                ([DoubleWritesAnalyzer.SupportedRule.Id], DoubleWritesAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesAnalyzer>),
+                ([SharedOutputPathCheck.SupportedRule.Id], SharedOutputPathCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathCheck>),
+                ([DoubleWritesCheck.SupportedRule.Id], DoubleWritesCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesCheck>),
+                ([NoEnvironmentVariablePropertyCheck.SupportedRule.Id], NoEnvironmentVariablePropertyCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyCheck>)
             ],
+
             // BuildCheckDataSource.Execution
-            []
+            [
+                (PropertiesUsageCheck.SupportedRulesList.Select(r => r.Id).ToArray(),
+                    PropertiesUsageCheck.SupportedRulesList.Any(r => r.DefaultConfiguration.IsEnabled ?? false),
+                    Construct<PropertiesUsageCheck>)
+            ]
         ];
 
         /// <summary>
-        /// For tests only. TODO: Remove when analyzer acquisition is done.
+        /// For tests only. TODO: Remove when check acquisition is done.
         /// </summary>
-        internal static (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][]? s_testFactoriesPerDataSource;
+        internal static (string[] ruleIds, bool defaultEnablement, CheckFactory factory)[][]? s_testFactoriesPerDataSource;
 
-        private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
+        private void RegisterBuiltInChecks(BuildCheckDataSource buildCheckDataSource)
         {
-            _analyzersRegistry.AddRange(
+            _checkRegistry.AddRange(
                 s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
-                    .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+                    .Select(v => new CheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
 
             if (s_testFactoriesPerDataSource is not null)
             {
-                _analyzersRegistry.AddRange(
+                _checkRegistry.AddRange(
                     s_testFactoriesPerDataSource[(int)buildCheckDataSource]
-                        .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
-            }
-        }
-
-        /// <summary>
-        /// To be used by acquisition module.
-        /// Registers the custom analyzers, the construction of analyzers is deferred until the first using project is encountered.
-        /// </summary>
-        internal void RegisterCustomAnalyzers(
-            BuildCheckDataSource buildCheckDataSource,
-            IEnumerable<BuildAnalyzerFactory> factories,
-            string[] ruleIds,
-            bool defaultEnablement)
-        {
-            if (_enabledDataSources[(int)buildCheckDataSource])
-            {
-                foreach (BuildAnalyzerFactory factory in factories)
-                {
-                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory, ruleIds, defaultEnablement));
-                }
+                        .Select(v => new CheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
             }
         }
 
         /// <summary>
         /// To be used by acquisition module
-        /// Registers the custom analyzer, the construction of analyzer is needed during registration.
+        /// Registers the custom check, the construction of check is needed during registration.
         /// </summary>
+        /// <param name="projectPath">The project path is used for the correct .editorconfig resolution.</param>
         /// <param name="buildCheckDataSource">Represents different data sources used in build check operations.</param>
-        /// <param name="factories">A collection of build analyzer factories for rules instantiation.</param>
-        /// <param name="buildEventContext">The context of the build event.</param>
-        internal void RegisterCustomAnalyzer(
+        /// <param name="factories">A collection of build check factories for rules instantiation.</param>
+        /// <param name="checkContext">The logging context of the build event.</param>
+        internal void RegisterCustomCheck(
+            string projectPath,
             BuildCheckDataSource buildCheckDataSource,
-            IEnumerable<BuildAnalyzerFactory> factories,
-            BuildEventContext buildEventContext)
+            IEnumerable<CheckFactory> factories,
+            ICheckContext checkContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
                 foreach (var factory in factories)
                 {
                     var instance = factory();
-                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(
+                    var checkFactoryContext = new CheckFactoryContext(
                         factory,
                         instance.SupportedRules.Select(r => r.Id).ToArray(),
-                        instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
-                    _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
-                }     
+                        instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true));
+
+                    if (checkFactoryContext != null)
+                    {
+                        _checkRegistry.Add(checkFactoryContext);
+                        SetupSingleCheck(checkFactoryContext, projectPath);
+                        checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckSuccessfulAcquisition", instance.FriendlyName);
+                    }
+                }
             }
         }
 
-        private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryContext, string projectFullPath, BuildEventContext buildEventContext)
+        private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string projectFullPath)
         {
-            // For custom analyzers - it should run only on projects where referenced
-            //  (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
-            //  on others it should work similarly as disabling them.
-            // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
-
-            BuildAnalyzerWrapper wrapper;
-            BuildAnalyzerConfigurationInternal[] configurations;
-            if (analyzerFactoryContext.MaterializedAnalyzer == null)
+            // For custom checks - it should run only on projects where referenced
+            // (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
+            // on others it should work similarly as disabling them.
+            // Disabled check should not only post-filter results - it shouldn't even see the data 
+            CheckWrapper wrapper;
+            CheckConfigurationEffective[] configurations;
+            if (checkFactoryContext.MaterializedCheck == null)
             {
-                BuildAnalyzerConfiguration[] userConfigs =
-                    _configurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                CheckConfiguration[] userConfigs =
+                    _configurationProvider.GetUserConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
+                if (userConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
                 {
-                    // the analyzer was not yet instantiated nor mounted - so nothing to do here now.
+                    // the check was not yet instantiated nor mounted - so nothing to do here now.
                     return;
                 }
 
                 CustomConfigurationData[] customConfigData =
-                    _configurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetCustomConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData);
+                Check uninitializedCheck = checkFactoryContext.Factory();
+                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedCheck);
 
-                wrapper = analyzerFactoryContext.Factory(configurationContext);
-                analyzerFactoryContext.MaterializedAnalyzer = wrapper;
-                BuildAnalyzer analyzer = wrapper.BuildAnalyzer;
+                ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData, configurations);
 
-                // This is to facilitate possible perf improvement for custom analyzers - as we might want to
+                wrapper = checkFactoryContext.Initialize(uninitializedCheck, configurationContext);
+                checkFactoryContext.MaterializedCheck = wrapper;
+                Check check = wrapper.Check;
+
+                // This is to facilitate possible perf improvement for custom checks - as we might want to
                 //  avoid loading the assembly and type just to check if it's supported.
                 // If we expose a way to declare the enablement status and rule ids during registration (e.g. via
                 //  optional arguments of the intrinsic property function) - we can then avoid loading it.
                 // But once loaded - we should verify that the declared enablement status and rule ids match the actual ones.
                 if (
-                    analyzer.SupportedRules.Count != analyzerFactoryContext.RuleIds.Length
+                    check.SupportedRules.Count != checkFactoryContext.RuleIds.Length
                     ||
-                    !analyzer.SupportedRules.Select(r => r.Id)
-                        .SequenceEqual(analyzerFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
+                    !check.SupportedRules.Select(r => r.Id)
+                        .SequenceEqual(checkFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
                 )
                 {
                     throw new BuildCheckConfigurationException(
-                        $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
+                        $"The check '{check.FriendlyName}' exposes rules '{check.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{checkFactoryContext.RuleIds.ToCsvString()}'");
                 }
 
-                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, analyzer);
-
-                // technically all analyzers rules could be disabled, but that would mean
+                // technically all checks rules could be disabled, but that would mean
                 // that the provided 'IsEnabledByDefault' value wasn't correct - the only
                 // price to be paid in that case is slight performance cost.
 
                 // Create the wrapper and register to central context
                 wrapper.StartNewProject(projectFullPath, configurations);
-                var wrappedContext = new BuildCheckRegistrationContext(wrapper, _buildCheckCentralContext);
-                analyzer.RegisterActions(wrappedContext);
+                var wrappedContext = new CheckRegistrationContext(wrapper, _buildCheckCentralContext);
+                check.RegisterActions(wrappedContext);
             }
             else
             {
-                wrapper = analyzerFactoryContext.MaterializedAnalyzer;
+                wrapper = checkFactoryContext.MaterializedCheck;
 
-                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.Check);
 
                 _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
-                    analyzerFactoryContext.RuleIds[0]);
+                    checkFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
                 wrapper.StartNewProject(projectFullPath, configurations);
             }
 
-            if (configurations.GroupBy(c => c.EvaluationAnalysisScope).Count() > 1)
+            if (configurations.GroupBy(c => c.EvaluationCheckScope).Count() > 1)
             {
                 throw new BuildCheckConfigurationException(
-                    string.Format("All rules for a single analyzer should have the same EvaluationAnalysisScope for a single project (violating rules: [{0}], project: {1})",
-                        analyzerFactoryContext.RuleIds.ToCsvString(),
+                    string.Format("All rules for a single check should have the same EvaluationCheckScope for a single project (violating rules: [{0}], project: {1})",
+                        checkFactoryContext.RuleIds.ToCsvString(),
                         projectFullPath));
             }
         }
 
-        private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventContext buildEventContext)
+        private void SetupChecksForNewProject(string projectFullPath, ICheckContext checkContext)
         {
-            // Only add analyzers here
-            // On an execution node - we might remove and dispose the analyzers once project is done
+            // Only add checks here
+            // On an execution node - we might remove and dispose the checks once project is done
 
             // If it's already constructed - just control the custom settings do not differ
             Stopwatch stopwatch = Stopwatch.StartNew();
-            List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
-            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            List<CheckFactoryContext> checksToRemove = new();
+            foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
                 try
                 {
-                    SetupSingleAnalyzer(analyzerFactoryContext, projectFullPath, buildEventContext);
+                    SetupSingleCheck(checkFactoryContext, projectFullPath);
                 }
                 catch (BuildCheckConfigurationException e)
                 {
-                    _loggingService.LogErrorFromText(buildEventContext, null, null, null,
+                    checkContext.DispatchAsErrorFromText(
+                        null,
+                        null,
+                        null,
                         new BuildEventFileInfo(projectFullPath),
                         e.Message);
-                    analyzersToRemove.Add(analyzerFactoryContext);
+                    checksToRemove.Add(checkFactoryContext);
                 }
             }
 
-            analyzersToRemove.ForEach(c =>
+            checksToRemove.ForEach(c =>
             {
-                _analyzersRegistry.Remove(c);
-                _loggingService.LogCommentFromText(buildEventContext, MessageImportance.High, $"Dismounting analyzer '{c.FriendlyName}'");
+                _checkRegistry.Remove(c);
+                checkContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting check '{c.FriendlyName}'");
             });
-            foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
+            foreach (var checkToRemove in checksToRemove.Select(a => a.MaterializedCheck).Where(a => a != null))
             {
-                _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
-                _tracingReporter.AddAnalyzerStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
-                analyzerToRemove.BuildAnalyzer.Dispose();
+                _buildCheckCentralContext.DeregisterCheck(checkToRemove!);
+                _tracingReporter.AddCheckStats(checkToRemove!.Check.FriendlyName, checkToRemove.Elapsed);
+                checkToRemove.Check.Dispose();
             }
 
             stopwatch.Stop();
@@ -322,42 +328,73 @@ private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventConte
         }
 
         public void ProcessEvaluationFinishedEventArgs(
-            AnalyzerLoggingContext buildAnalysisContext,
+            ICheckContext checkContext,
             ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
-            => _buildEventsProcessor
-                .ProcessEvaluationFinishedEventArgs(buildAnalysisContext, evaluationFinishedEventArgs);
+        {
+            Dictionary<string, string>? propertiesLookup = null;
+            // The FileClassifier is normally initialized by executing build requests.
+            // However, if we are running in a main node that has no execution nodes - we need to initialize it here (from events).
+            if (!IsInProcNode)
+            {
+                propertiesLookup =
+                    BuildEventsProcessor.ExtractPropertiesLookup(evaluationFinishedEventArgs);
+                Func<string, string?> getPropertyValue = p =>
+                    propertiesLookup.TryGetValue(p, out string? value) ? value : null;
+
+                FileClassifier.Shared.RegisterFrameworkLocations(getPropertyValue);
+                FileClassifier.Shared.RegisterKnownImmutableLocations(getPropertyValue);
+            }
+
+            _buildEventsProcessor
+                .ProcessEvaluationFinishedEventArgs(checkContext, evaluationFinishedEventArgs, propertiesLookup);
+        }
+
+        public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+        {
+            if (projectEvaluationEventArgs is EnvironmentVariableReadEventArgs evr)
+            {
+                _buildEventsProcessor.ProcessEnvironmentVariableReadEventArgs(
+                    evr.EnvironmentVariableName,
+                    evr.Message ?? string.Empty,
+                    evr.File,
+                    evr.LineNumber,
+                    evr.ColumnNumber);
+            }
+        }
 
         public void ProcessTaskStartedEventArgs(
-            AnalyzerLoggingContext buildAnalysisContext,
+            ICheckContext checkContext,
             TaskStartedEventArgs taskStartedEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskStartedEventArgs(buildAnalysisContext, taskStartedEventArgs);
+                .ProcessTaskStartedEventArgs(checkContext, taskStartedEventArgs);
+
+        public void ProcessBuildFinished(ICheckContext checkContext)
+            => _buildEventsProcessor.ProcessBuildDone(checkContext);
 
         public void ProcessTaskFinishedEventArgs(
-            AnalyzerLoggingContext buildAnalysisContext,
+            ICheckContext checkContext,
             TaskFinishedEventArgs taskFinishedEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskFinishedEventArgs(buildAnalysisContext, taskFinishedEventArgs);
+                .ProcessTaskFinishedEventArgs(checkContext, taskFinishedEventArgs);
 
         public void ProcessTaskParameterEventArgs(
-            AnalyzerLoggingContext buildAnalysisContext,
+            ICheckContext checkContext,
             TaskParameterEventArgs taskParameterEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskParameterEventArgs(buildAnalysisContext, taskParameterEventArgs);
+                .ProcessTaskParameterEventArgs(checkContext, taskParameterEventArgs);
 
-        public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats()
+        public Dictionary<string, TimeSpan> CreateCheckTracingStats()
         {
-            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
-                if (analyzerFactoryContext.MaterializedAnalyzer != null)
+                if (checkFactoryContext.MaterializedCheck != null)
                 {
-                    _tracingReporter.AddAnalyzerStats(analyzerFactoryContext.FriendlyName,
-                        analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
-                    analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
+                    _tracingReporter.AddCheckStats(checkFactoryContext.FriendlyName, checkFactoryContext.MaterializedCheck.Elapsed);
+                    checkFactoryContext.MaterializedCheck.ClearStats();
                 }
             }
 
-            _tracingReporter.AddAnalyzerInfraStats();
+            _tracingReporter.AddCheckInfraStats();
             return _tracingReporter.TracingStats;
         }
 
@@ -369,68 +406,185 @@ public void FinalizeProcessing(LoggingContext loggingContext)
                 return;
             }
 
-            var analyzerEventStats = CreateAnalyzerTracingStats();
+            var checkEventStats = CreateCheckTracingStats();
+
+            BuildCheckTracingEventArgs checkEventArg =
+                new(checkEventStats) { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(checkEventArg);
+        }
+
+        private readonly ConcurrentDictionary<int, string> _projectsByInstnaceId = new();
+        private readonly ConcurrentDictionary<int, string> _projectsByEvaluationId = new();
+
+        /// <summary>
+        /// This method fetches the project full path from the context id.
+        /// This is needed because the full path is needed for configuration and later for fetching configured checks
+        ///  (future version might optimize by using the ProjectContextId directly for fetching the checks).
+        /// </summary>
+        /// <param name="buildEventContext"></param>
+        /// <param name="projectFullPath"></param>
+        /// <returns></returns>
+        private bool TryGetProjectFullPath(BuildEventContext buildEventContext, out string projectFullPath)
+        {
+            if (buildEventContext.EvaluationId >= 0)
+            {
+                if (_projectsByEvaluationId.TryGetValue(buildEventContext.EvaluationId, out string? val))
+                {
+                    projectFullPath = val;
+                    return true;
+                }
+            }
+            else if (buildEventContext.ProjectInstanceId >= 0)
+            {
+                if (_projectsByInstnaceId.TryGetValue(buildEventContext.ProjectInstanceId, out string? val))
+                {
+                    projectFullPath = val;
+                    return true;
+                }
+            }
+            else if (_projectsByInstnaceId.Count == 1)
+            {
+                projectFullPath = _projectsByInstnaceId.FirstOrDefault().Value;
+                // This is for a rare possibility of a race where other thread removed the item (between the if check and fetch here).
+                // We currently do not support multiple projects in parallel in a single node anyway.
+                if (!string.IsNullOrEmpty(projectFullPath))
+                {
+                    return true;
+                }
+            }
+            else if (_projectsByEvaluationId.Count == 1)
+            {
+                projectFullPath = _projectsByEvaluationId.FirstOrDefault().Value;
+                if (!string.IsNullOrEmpty(projectFullPath))
+                {
+                    return true;
+                }
+            }
 
-            BuildCheckTracingEventArgs analyzerEventArg =
-                new(analyzerEventStats) { BuildEventContext = loggingContext.BuildEventContext };
-            loggingContext.LogBuildEvent(analyzerEventArg);
+            projectFullPath = string.Empty;
+            return false;
         }
 
-        public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext,
-            string fullPath)
+        public void ProjectFirstEncountered(
+            BuildCheckDataSource buildCheckDataSource,
+            ICheckContext checkContext,
+            string projectFullPath)
         {
             if (buildCheckDataSource == BuildCheckDataSource.EventArgs && IsInProcNode)
             {
                 // Skipping this event - as it was already handled by the in-proc node.
-                // This is because in-proc node has the BuildEventArgs source and BuildExecution source
+                // This is because in-proc node has the BuildEventArgs source and check source
                 //  both in a single manager. The project started is first encountered by the execution before the EventArg is sent
                 return;
             }
 
-            SetupAnalyzersForNewProject(fullPath, buildEventContext);
+            SetupChecksForNewProject(projectFullPath, checkContext);
+        }
+
+        public void ProcessProjectEvaluationStarted(
+            ICheckContext checkContext,
+            string projectFullPath)
+        {
+            _projectsByEvaluationId[checkContext.BuildEventContext.EvaluationId] = projectFullPath;
         }
 
         /*
          *
-         * Following methods are for future use (should we decide to approach in-execution analysis)
+         * Following methods are for future use (should we decide to approach in-execution check)
          *
          */
 
 
-        public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        public void EndProjectEvaluation(BuildEventContext buildEventContext)
+        {
+        }
+
+        public void StartProjectRequest(BuildEventContext buildEventContext, string projectFullPath)
+        {
+            // There can be multiple ProjectStarted-ProjectFinished per single configuration project build (each request for different target)
+            _projectsByInstnaceId[buildEventContext.ProjectInstanceId] = projectFullPath;
+        }
+
+        public void EndProjectRequest(
+            ICheckContext checkContext,
+            string projectFullPath)
         {
+            _buildEventsProcessor.ProcessProjectDone(checkContext, projectFullPath);
         }
 
-        public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
         {
+            if (!_buildCheckCentralContext.HasPropertyReadActions)
+            {
+                return;
+            }
+
+            if (TryGetProjectFullPath(checkContext.BuildEventContext, out string projectFullPath))
+            {
+                PropertyReadData propertyReadData = new(
+                    projectFullPath,
+                    checkContext.BuildEventContext.ProjectInstanceId,
+                    propertyReadInfo);
+                _buildEventsProcessor.ProcessPropertyRead(propertyReadData, checkContext);
+            }
         }
 
-        public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
         {
+            if (!_buildCheckCentralContext.HasPropertyWriteActions)
+            {
+                return;
+            }
+
+            if (TryGetProjectFullPath(checkContext.BuildEventContext, out string projectFullPath))
+            {
+                PropertyWriteData propertyWriteData = new(
+                    projectFullPath,
+                    checkContext.BuildEventContext.ProjectInstanceId,
+                    propertyWriteInfo);
+                _buildEventsProcessor.ProcessPropertyWrite(propertyWriteData, checkContext);
+            }
         }
 
         public void Shutdown()
         { /* Too late here for any communication to the main node or for logging anything */ }
 
-        private class BuildAnalyzerFactoryContext(
-            BuildAnalyzerFactory factory,
+        private class CheckFactoryContext(
+            CheckFactory factory,
             string[] ruleIds,
             bool isEnabledByDefault)
         {
-            public BuildAnalyzerWrapperFactory Factory { get; init; } = configContext =>
+            public Check Factory()
             {
-                BuildAnalyzer ba = factory();
-                ba.Initialize(configContext);
-                return new BuildAnalyzerWrapper(ba);
-            };
+                Check ba = factory();
+                return ba;
+            }
+
+            public CheckWrapper Initialize(Check ba, ConfigurationContext configContext)
+            {
+                try
+                {
+                    ba.Initialize(configContext);
+                }
+                catch (BuildCheckConfigurationException)
+                {
+                    throw;
+                }
+                catch (Exception e)
+                {
+                    throw new BuildCheckConfigurationException(
+                        $"The Check '{ba.FriendlyName}' failed to initialize: {e.Message}", e);
+                }
+                return new CheckWrapper(ba);
+            }
 
-            public BuildAnalyzerWrapper? MaterializedAnalyzer { get; set; }
+            public CheckWrapper? MaterializedCheck { get; set; }
 
             public string[] RuleIds { get; init; } = ruleIds;
 
             public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
 
-            public string FriendlyName => MaterializedAnalyzer?.BuildAnalyzer.FriendlyName ?? factory().FriendlyName;
+            public string FriendlyName => MaterializedCheck?.Check.FriendlyName ?? factory().FriendlyName;
         }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
new file mode 100644
index 00000000000..515b050a8cc
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
@@ -0,0 +1,54 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// The class that creates an <see cref="IEventSource"/> for binary log replay with BuildCheck enabled.
+/// </summary>
+public static class BuildCheckReplayModeConnector
+{
+    /// <summary>
+    /// Gets merged <see cref="IEventSource"/> for binary log replay with BuildCheck enabled.
+    /// </summary>
+    /// <param name="buildManager"><see cref="BuildManager"/> to get the registered <see cref="IBuildCheckManagerProvider"/> component from.</param>
+    /// <param name="replayEventSource">The initial event source.</param>
+    /// <returns>The merged <see cref="IEventSource"/>. Used for binary log replay.</returns>
+    public static IEventSource GetMergedEventSource(
+        BuildManager buildManager,
+        IEventSource replayEventSource)
+    {
+        buildManager.EnableBuildCheck();
+
+        var buildCheckManagerProvider = ((IBuildComponentHost)buildManager)
+            .GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider;
+
+        buildCheckManagerProvider!.Instance.SetDataSource(BuildCheckDataSource.EventArgs);
+
+        var mergedEventSource = new EventArgsDispatcher();
+
+        // Pass the events from replayEventSource to the mergedEventSource
+        replayEventSource.AnyEventRaised += (sender, e) => mergedEventSource.Dispatch(e);
+
+        // Create BuildCheckBuildEventHandler that passes new events to the mergedEventSource
+        var buildCheckEventHandler = new BuildCheckBuildEventHandler(
+            new CheckDispatchingContextFactory(mergedEventSource),
+            buildCheckManagerProvider.Instance);
+
+        // Pass the events from replayEventSource to the BuildCheckBuildEventHandler to produce new events
+        replayEventSource.AnyEventRaised += (sender, e) => buildCheckEventHandler.HandleBuildEvent(e);
+
+        return mergedEventSource;
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index e9a5f9e8aa2..d06190f3008 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -3,21 +3,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.Diagnostics;
-using System.Diagnostics.Tracing;
-using System.IO;
 using System.Linq;
-using System.Runtime.ConstrainedExecution;
-using Microsoft.Build.BackEnd;
-using Microsoft.Build.BackEnd.Components.Caching;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck.Analyzers;
-using Microsoft.Build.Experimental.BuildCheck.Logging;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -29,13 +17,13 @@ internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralCo
     /// Represents a task currently being executed.
     /// </summary>
     /// <remarks>
-    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="AnalysisData"/>
+    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="CheckData"/>
     /// is immutable.
     /// </remarks>
     private struct ExecutingTaskData
     {
-        public TaskInvocationAnalysisData AnalysisData;
-        public Dictionary<string, TaskInvocationAnalysisData.TaskParameter> TaskParameters;
+        public TaskInvocationCheckData CheckData;
+        public Dictionary<string, TaskInvocationCheckData.TaskParameter> TaskParameters;
     }
 
     /// <summary>
@@ -50,25 +38,40 @@ public TaskKey(BuildEventContext context)
 
     private readonly SimpleProjectRootElementCache _cache = new SimpleProjectRootElementCache();
     private readonly BuildCheckCentralContext _buildCheckCentralContext = buildCheckCentralContext;
+    private Dictionary<string, (string EnvVarValue, string File, int Line, int Column)> _evaluatedEnvironmentVariables = new Dictionary<string, (string EnvVarValue, string File, int Line, int Column)>();
 
     /// <summary>
     /// Keeps track of in-flight tasks. Keyed by task ID as passed in <see cref="BuildEventContext.TaskId"/>.
     /// </summary>
     private readonly Dictionary<TaskKey, ExecutingTaskData> _tasksBeingExecuted = [];
 
-    // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
-    internal void ProcessEvaluationFinishedEventArgs(
-        AnalyzerLoggingContext buildAnalysisContext,
-        ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
+    internal static Dictionary<string, string> ExtractPropertiesLookup(ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
     {
         Dictionary<string, string> propertiesLookup = new Dictionary<string, string>();
         Internal.Utilities.EnumerateProperties(evaluationFinishedEventArgs.Properties, propertiesLookup,
             static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
 
-        EvaluatedPropertiesAnalysisData analysisData =
-            new(evaluationFinishedEventArgs.ProjectFile!, propertiesLookup);
+        return propertiesLookup;
+    }
+
+    // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
+    internal void ProcessEvaluationFinishedEventArgs(
+        ICheckContext checkContext,
+        ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs,
+        Dictionary<string, string>? propertiesLookup)
+    {
+        if (_buildCheckCentralContext.HasEvaluatedPropertiesActions)
+        {
+            propertiesLookup ??= ExtractPropertiesLookup(evaluationFinishedEventArgs);
+
+            EvaluatedPropertiesCheckData checkData =
+                new(evaluationFinishedEventArgs.ProjectFile!,
+                    evaluationFinishedEventArgs.BuildEventContext?.ProjectInstanceId,
+                    propertiesLookup!,
+                    _evaluatedEnvironmentVariables);
 
-        _buildCheckCentralContext.RunEvaluatedPropertiesActions(analysisData, buildAnalysisContext, ReportResult);
+            _buildCheckCentralContext.RunEvaluatedPropertiesActions(checkData, checkContext, ReportResult);
+        }
 
         if (_buildCheckCentralContext.HasParsedItemsActions)
         {
@@ -76,20 +79,44 @@ internal void ProcessEvaluationFinishedEventArgs(
                 evaluationFinishedEventArgs.ProjectFile!, /*unused*/
                 null, /*unused*/null, _cache, false /*Not explicitly loaded - unused*/);
 
-            ParsedItemsAnalysisData itemsAnalysisData = new(evaluationFinishedEventArgs.ProjectFile!,
+            ParsedItemsCheckData itemsCheckData = new(
+                evaluationFinishedEventArgs.ProjectFile!,
+                evaluationFinishedEventArgs.BuildEventContext?.ProjectInstanceId,
                 new ItemsHolder(xml.Items, xml.ItemGroups));
 
-            _buildCheckCentralContext.RunParsedItemsActions(itemsAnalysisData, buildAnalysisContext, ReportResult);
+            _buildCheckCentralContext.RunParsedItemsActions(itemsCheckData, checkContext, ReportResult);
         }
     }
 
+    /// <summary>
+    /// The method collects events associated with the used environment variables in projects.
+    /// </summary>
+    internal void ProcessEnvironmentVariableReadEventArgs(string envVarName, string envVarValue, string file, int line, int column)
+    {
+        if (!_evaluatedEnvironmentVariables.ContainsKey(envVarName))
+        {
+            _evaluatedEnvironmentVariables.Add(envVarName, (envVarValue, file, line, column));
+        }
+    }
+
+    internal void ProcessBuildDone(ICheckContext checkContext)
+    {
+        if (!_buildCheckCentralContext.HasBuildFinishedActions)
+        {
+            // No analyzer is interested in the event -> nothing to do.
+            return;
+        }
+
+        _buildCheckCentralContext.RunBuildFinishedActions(new BuildFinishedCheckData(), checkContext, ReportResult);
+    }
+
     internal void ProcessTaskStartedEventArgs(
-        AnalyzerLoggingContext buildAnalysisContext,
+        ICheckContext checkContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -102,13 +129,14 @@ internal void ProcessTaskStartedEventArgs(
 
             // Add a new entry to _tasksBeingExecuted. TaskParameters are initialized empty and will be recorded
             // based on TaskParameterEventArgs we receive later.
-            Dictionary<string, TaskInvocationAnalysisData.TaskParameter> taskParameters = new();
+            Dictionary<string, TaskInvocationCheckData.TaskParameter> taskParameters = new();
 
             ExecutingTaskData taskData = new()
             {
                 TaskParameters = taskParameters,
-                AnalysisData = new(
+                CheckData = new(
                     projectFilePath: taskStartedEventArgs.ProjectFile!,
+                    projectConfigurationId: taskStartedEventArgs.BuildEventContext.ProjectInstanceId,
                     taskInvocationLocation: invocationLocation,
                     taskName: taskStartedEventArgs.TaskName,
                     taskAssemblyLocation: taskStartedEventArgs.TaskAssemblyLocation,
@@ -120,12 +148,12 @@ internal void ProcessTaskStartedEventArgs(
     }
 
     internal void ProcessTaskFinishedEventArgs(
-        AnalyzerLoggingContext buildAnalysisContext,
+        ICheckContext checkContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -136,18 +164,18 @@ internal void ProcessTaskFinishedEventArgs(
             {
                 // All task parameters have been recorded by now so remove the task from the dictionary and fire the registered build check actions.
                 _tasksBeingExecuted.Remove(taskKey);
-                _buildCheckCentralContext.RunTaskInvocationActions(taskData.AnalysisData, buildAnalysisContext, ReportResult);
+                _buildCheckCentralContext.RunTaskInvocationActions(taskData.CheckData, checkContext, ReportResult);
             }
         }
     }
 
     internal void ProcessTaskParameterEventArgs(
-        AnalyzerLoggingContext buildAnalysisContext,
+        ICheckContext checkContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -171,28 +199,46 @@ internal void ProcessTaskParameterEventArgs(
                 _ => taskParameterEventArgs.Items,
             };
 
-            taskData.TaskParameters[parameterName] = new TaskInvocationAnalysisData.TaskParameter(parameterValue, isOutput);
+            taskData.TaskParameters[parameterName] = new TaskInvocationCheckData.TaskParameter(parameterValue, isOutput);
         }
     }
 
+    public void ProcessPropertyRead(PropertyReadData propertyReadData, CheckLoggingContext checkContext)
+        => _buildCheckCentralContext.RunPropertyReadActions(
+                propertyReadData,
+                checkContext,
+                ReportResult);
+
+    public void ProcessPropertyWrite(PropertyWriteData propertyWriteData, CheckLoggingContext checkContext)
+        => _buildCheckCentralContext.RunPropertyWriteActions(
+                propertyWriteData,
+                checkContext,
+                ReportResult);
+
+    public void ProcessProjectDone(ICheckContext checkContext, string projectFullPath)
+        => _buildCheckCentralContext.RunProjectProcessingDoneActions(
+                new ProjectRequestProcessingDoneData(projectFullPath, checkContext.BuildEventContext.ProjectInstanceId),
+                checkContext,
+                ReportResult);
+
     private static void ReportResult(
-        BuildAnalyzerWrapper analyzerWrapper,
-        LoggingContext loggingContext,
-        BuildAnalyzerConfigurationInternal[] configPerRule,
+        CheckWrapper checkWrapper,
+        ICheckContext checkContext,
+        CheckConfigurationEffective[] configPerRule,
         BuildCheckResult result)
     {
-        if (!analyzerWrapper.BuildAnalyzer.SupportedRules.Contains(result.BuildAnalyzerRule))
+        if (!checkWrapper.Check.SupportedRules.Contains(result.CheckRule))
         {
-            loggingContext.LogErrorFromText(null, null, null,
+            checkContext.DispatchAsErrorFromText(null, null, null,
                 BuildEventFileInfo.Empty,
-                $"The analyzer '{analyzerWrapper.BuildAnalyzer.FriendlyName}' reported a result for a rule '{result.BuildAnalyzerRule.Id}' that it does not support.");
+                $"The check '{checkWrapper.Check.FriendlyName}' reported a result for a rule '{result.CheckRule.Id}' that it does not support.");
             return;
         }
 
-        BuildAnalyzerConfigurationInternal config = configPerRule.Length == 1
+        CheckConfigurationEffective config = configPerRule.Length == 1
             ? configPerRule[0]
             : configPerRule.First(r =>
-                r.RuleId.Equals(result.BuildAnalyzerRule.Id, StringComparison.CurrentCultureIgnoreCase));
+                r.RuleId.Equals(result.CheckRule.Id, StringComparison.CurrentCultureIgnoreCase));
 
         if (!config.IsEnabled)
         {
@@ -201,10 +247,8 @@ private static void ReportResult(
 
         BuildEventArgs eventArgs = result.ToEventArgs(config.Severity);
 
-        // TODO: This is a workaround for https://github.com/dotnet/msbuild/issues/10176
-        // eventArgs.BuildEventContext = loggingContext.BuildEventContext;
-        eventArgs.BuildEventContext = BuildEventContext.Invalid;
+        eventArgs.BuildEventContext = checkContext.BuildEventContext;
 
-        loggingContext.LogBuildEvent(eventArgs);
+        checkContext.DispatchBuildEvent(eventArgs);
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckConfigurationEffective.cs b/src/Build/BuildCheck/Infrastructure/CheckConfigurationEffective.cs
new file mode 100644
index 00000000000..0f857dad631
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckConfigurationEffective.cs
@@ -0,0 +1,45 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Counterpart type for BuildCheckConfiguration - with all properties non-nullable
+/// </summary>
+public sealed class CheckConfigurationEffective
+{
+    public CheckConfigurationEffective(string ruleId, EvaluationCheckScope evaluationCheckScope, CheckResultSeverity severity)
+    {
+        if (severity == CheckResultSeverity.Default)
+        {
+            throw new ArgumentOutOfRangeException(nameof(severity), severity, "Severity 'Default' is not recognized by the BuildCheck reports infrastructure");
+        }
+
+        RuleId = ruleId;
+        EvaluationCheckScope = evaluationCheckScope;
+        Severity = severity;
+    }
+
+    internal static CheckConfigurationEffective Default { get; } =
+        new(string.Empty, CheckConfiguration.Default.EvaluationCheckScope!.Value,
+            CheckConfiguration.Default.Severity!.Value);
+
+    public string RuleId { get; }
+
+    public EvaluationCheckScope EvaluationCheckScope { get; }
+
+    public CheckResultSeverity Severity { get; }
+
+    public bool IsEnabled => Severity >= CheckResultSeverity.Suggestion;
+
+    // Intentionally not checking the RuleId
+    //  as for checks with multiple rules, we can squash config to a single one,
+    //  if the ruleId is the only thing differing.
+    public bool IsSameConfigurationAs(CheckConfigurationEffective? other) =>
+        other != null &&
+        Severity == other.Severity &&
+        EvaluationCheckScope == other.EvaluationCheckScope;
+}
diff --git a/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
new file mode 100644
index 00000000000..71befe7991b
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
@@ -0,0 +1,65 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BackEnd.Shared;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// <see cref="ICheckContext"/> that uses <see cref="EventArgsDispatcher"/> to dispatch.
+/// </summary>
+internal class CheckDispatchingContext : ICheckContext
+{
+    private readonly EventArgsDispatcher _eventDispatcher;
+    private readonly BuildEventContext _eventContext;
+
+    public CheckDispatchingContext(
+        EventArgsDispatcher dispatch,
+        BuildEventContext eventContext)
+    {
+        _eventDispatcher = dispatch;
+        _eventContext = eventContext;
+    }
+
+    public BuildEventContext BuildEventContext => _eventContext;
+
+    public void DispatchBuildEvent(BuildEventArgs buildEvent)
+    {
+        ErrorUtilities.VerifyThrowInternalNull(buildEvent, nameof(buildEvent));
+
+        _eventDispatcher.Dispatch(buildEvent);
+    }
+
+    public void DispatchAsComment(MessageImportance importance, string messageResourceName, params object?[] messageArgs)
+    {
+        ErrorUtilities.VerifyThrowInternalLength(messageResourceName,nameof(messageResourceName));
+
+        DispatchAsCommentFromText(_eventContext, importance, ResourceUtilities.GetResourceString(messageResourceName), messageArgs);
+    }
+
+    public void DispatchAsCommentFromText(MessageImportance importance, string message)
+        => DispatchAsCommentFromText(_eventContext, importance, message, messageArgs: null);
+
+    private void DispatchAsCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, params object?[]? messageArgs)
+    {
+        BuildMessageEventArgs buildEvent = EventsCreatorHelper.CreateMessageEventFromText(buildEventContext, importance, message, messageArgs);
+
+        _eventDispatcher.Dispatch(buildEvent);
+    }
+
+    public void DispatchAsErrorFromText(string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message)
+    {
+        BuildErrorEventArgs buildEvent = EventsCreatorHelper.CreateErrorEventFromText(_eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
+
+        _eventDispatcher.Dispatch(buildEvent);
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
new file mode 100644
index 00000000000..6c536a14df9
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
@@ -0,0 +1,24 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+internal class CheckDispatchingContextFactory : ICheckContextFactory
+{
+    private readonly EventArgsDispatcher _eventDispatcher;
+
+    public event AnyEventHandler? AnyEventRaised;
+
+    public CheckDispatchingContextFactory(EventArgsDispatcher eventDispatcher)
+    {
+        _eventDispatcher = eventDispatcher;
+
+        _eventDispatcher.AnyEventRaised += (sender, e) => AnyEventRaised?.Invoke(sender, e);
+    }
+
+    public ICheckContext CreateCheckContext(BuildEventContext eventContext)
+        => new CheckDispatchingContext(_eventDispatcher, eventContext);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
new file mode 100644
index 00000000000..c295b254f49
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
@@ -0,0 +1,42 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// <see cref="ICheckContext"/> that uses <see cref="ILoggingService"/> to dispatch.
+/// </summary>
+/// <remarks>
+/// Making this a record struct to avoid allocations (unless called through interface - which leads to boxing).
+/// This is wanted since this can be used in a hot path (of property reads and writes)
+/// </remarks>
+internal readonly struct CheckLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
+    : ICheckContext
+{
+    public BuildEventContext BuildEventContext => eventContext;
+
+    public void DispatchBuildEvent(BuildEventArgs buildEvent)
+        => loggingService
+            .LogBuildEvent(buildEvent);
+
+    public void DispatchAsComment(MessageImportance importance, string messageResourceName, params object?[] messageArgs)
+        => loggingService
+            .LogComment(eventContext, importance, messageResourceName, messageArgs);
+
+    public void DispatchAsCommentFromText(MessageImportance importance, string message)
+        => loggingService
+            .LogCommentFromText(eventContext, importance, message);
+
+    public void DispatchAsErrorFromText(string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message)
+        => loggingService
+            .LogErrorFromText(eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
new file mode 100644
index 00000000000..5f429c94b02
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
@@ -0,0 +1,22 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+internal class CheckLoggingContextFactory : ICheckContextFactory
+{
+    private readonly ILoggingService _loggingService;
+
+    public CheckLoggingContextFactory(ILoggingService loggingService) => _loggingService = loggingService;
+
+    public ICheckContext CreateCheckContext(BuildEventContext eventContext)
+        => new CheckLoggingContext(_loggingService, eventContext);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
new file mode 100644
index 00000000000..7c4e82861ea
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Interface that contains an instance of <see cref="BuildEventContext"/> and methods to dispatch it.
+/// </summary>
+internal interface ICheckContext
+{
+    /// <summary>
+    /// Instance of <see cref="BuildEventContext"/>.
+    /// </summary>
+    BuildEventContext BuildEventContext { get; }
+
+    /// <summary>
+    /// Dispatch the instance of <see cref="BuildEventContext"/> as a comment.
+    /// </summary>
+    void DispatchAsComment(MessageImportance importance, string messageResourceName, params object?[] messageArgs);
+
+    /// <summary>
+    /// Dispatch a <see cref="BuildEventArgs"/>.
+    /// </summary>
+    void DispatchBuildEvent(BuildEventArgs buildEvent);
+
+    /// <summary>
+    /// Dispatch the instance of <see cref="BuildEventContext"/> as an error message.
+    /// </summary>
+    void DispatchAsErrorFromText(string? subcategoryResourceName, string? errorCode, string? helpKeyword, BuildEventFileInfo file, string message);
+
+    /// <summary>
+    /// Dispatch the instance of <see cref="BuildEventContext"/> as a comment with provided text for the message.
+    /// </summary>
+    void DispatchAsCommentFromText(MessageImportance importance, string message);
+}
diff --git a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
similarity index 54%
rename from src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
index bbb562c5ec9..da90050598d 100644
--- a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
@@ -1,12 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal interface IBuildAnalysisLoggingContextFactory
+internal interface ICheckContextFactory
 {
-    AnalyzerLoggingContext CreateLoggingContext(BuildEventContext eventContext);
+    ICheckContext CreateCheckContext(BuildEventContext eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs b/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs
new file mode 100644
index 00000000000..33fb7e09ff3
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckRegistrationContext.cs
@@ -0,0 +1,39 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+internal sealed class CheckRegistrationContext(CheckWrapper checkWrapper, BuildCheckCentralContext buildCheckCentralContext) : IInternalCheckRegistrationContext
+{
+    public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
+    {
+        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(checkWrapper, evaluatedPropertiesAction);
+    }
+
+    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction)
+    {
+        buildCheckCentralContext.RegisterParsedItemsAction(checkWrapper, parsedItemsAction);
+    }
+
+    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
+    {
+        buildCheckCentralContext.RegisterTaskInvocationAction(checkWrapper, taskInvocationAction);
+    }
+
+    public void RegisterPropertyReadAction(Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
+        => buildCheckCentralContext.RegisterPropertyReadAction(checkWrapper, propertyReadAction);
+
+    public void RegisterPropertyWriteAction(Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
+        => buildCheckCentralContext.RegisterPropertyWriteAction(checkWrapper, propertyWriteAction);
+
+    public void RegisterProjectRequestProcessingDoneAction(Action<BuildCheckDataContext<ProjectRequestProcessingDoneData>> projectDoneAction)
+        => buildCheckCentralContext.RegisterProjectRequestProcessingDoneAction(checkWrapper, projectDoneAction);
+
+    public void RegisterBuildFinishedAction(Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction)
+        => buildCheckCentralContext.RegisterBuildFinishedAction(checkWrapper, buildFinishedAction);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs b/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
new file mode 100644
index 00000000000..58002c5a2e9
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
@@ -0,0 +1,60 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+internal static class CheckScopeClassifier
+{
+    /// <summary>
+    /// Indicates whether given location is in the observed scope, based on currently built project path.
+    /// </summary>
+    /// <param name="scope"></param>
+    /// <param name="location"></param>
+    /// <param name="projectFileFullPath"></param>
+    /// <returns></returns>
+    /// <exception cref="ArgumentOutOfRangeException"></exception>
+    internal static bool IsActionInObservedScope(
+        EvaluationCheckScope scope,
+        IMSBuildElementLocation? location,
+        string projectFileFullPath)
+        => IsActionInObservedScope(scope, location?.File, projectFileFullPath);
+
+    /// <summary>
+    /// Indicates whether given location is in the observed scope, based on currently built project path.
+    /// </summary>
+    /// <param name="scope"></param>
+    /// <param name="filePathOfEvent"></param>
+    /// <param name="projectFileFullPath"></param>
+    /// <returns></returns>
+    /// <exception cref="ArgumentOutOfRangeException"></exception>
+    internal static bool IsActionInObservedScope(
+        EvaluationCheckScope scope,
+        string? filePathOfEvent,
+        string projectFileFullPath)
+    {
+        switch (scope)
+        {
+            case EvaluationCheckScope.ProjectFileOnly:
+                return filePathOfEvent == projectFileFullPath;
+            case EvaluationCheckScope.WorkTreeImports:
+                return
+                    filePathOfEvent != null &&
+                    !FileClassifier.Shared.IsNonModifiable(filePathOfEvent) &&
+                    !IsGeneratedNugetImport(filePathOfEvent);
+            case EvaluationCheckScope.All:
+                return true;
+            default:
+                throw new ArgumentOutOfRangeException(nameof(scope), scope, null);
+        }
+    }
+
+    private static bool IsGeneratedNugetImport(string file)
+    {
+        return file.EndsWith("nuget.g.props", StringComparison.OrdinalIgnoreCase) ||
+               file.EndsWith("nuget.g.targets", StringComparison.OrdinalIgnoreCase);
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
similarity index 78%
rename from src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
rename to src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
index 598d0be021d..62011296cb5 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
@@ -11,28 +11,28 @@
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
-/// A wrapping, enriching class for BuildAnalyzer - so that we have additional data and functionality.
+/// A wrapping, enriching class for BuildCheck - so that we have additional data and functionality.
 /// </summary>
-internal sealed class BuildAnalyzerWrapper
+internal sealed class CheckWrapper
 {
     private readonly Stopwatch _stopwatch = new Stopwatch();
 
-    public BuildAnalyzerWrapper(BuildAnalyzer buildAnalyzer)
+    public CheckWrapper(Check check)
     {
-        BuildAnalyzer = buildAnalyzer;
+        Check = check;
     }
 
-    internal BuildAnalyzer BuildAnalyzer { get; }
+    internal Check Check { get; }
     private bool _isInitialized = false;
 
     // Let's optimize for the scenario where users have a single .editorconfig file that applies to the whole solution.
     // In such case - configuration will be same for all projects. So we do not need to store it per project in a collection.
-    internal BuildAnalyzerConfigurationInternal? CommonConfig { get; private set; }
+    internal CheckConfigurationEffective? CommonConfig { get; private set; }
 
     // start new project
     internal void StartNewProject(
         string fullProjectPath,
-        IReadOnlyList<BuildAnalyzerConfigurationInternal> userConfigs)
+        IReadOnlyList<CheckConfigurationEffective> userConfigs)
     {
         if (!_isInitialized)
         {
@@ -52,7 +52,7 @@ internal void StartNewProject(
         }
     }
 
-    // to be used on eval node (BuildCheckDataSource.BuildExecution)
+    // to be used on eval node (BuildCheckDataSource.check)
     internal void Uninitialize()
     {
         _isInitialized = false;
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index ab2e298879b..e102fe96ced 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -7,19 +7,21 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
 using Microsoft.Build.Experimental.BuildCheck;
 using System.Collections.Concurrent;
+using Microsoft.Build.Experimental.BuildCheck.Utilities;
+using Microsoft.Build.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal sealed class ConfigurationProvider
+internal sealed class ConfigurationProvider : IConfigurationProvider
 {
     private readonly EditorConfigParser _editorConfigParser = new EditorConfigParser();
 
     private const string BuildCheck_ConfigurationKey = "build_check";
 
     /// <summary>
-    /// The dictionary used for storing the BuildAnalyzerConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
+    /// The dictionary used for storing the BuildCheckConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
     /// </summary>
-    private readonly ConcurrentDictionary<string, BuildAnalyzerConfiguration> _buildAnalyzerConfiguration = new ConcurrentDictionary<string, BuildAnalyzerConfiguration>(StringComparer.InvariantCultureIgnoreCase);
+    private readonly ConcurrentDictionary<string, CheckConfiguration> _checkConfiguration = new ConcurrentDictionary<string, CheckConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
     /// <summary>
     /// The dictionary used for storing the key-value pairs retrieved from the .editorconfigs for specific projectfile. The key is equal to projectFullPath.
@@ -31,14 +33,13 @@ internal sealed class ConfigurationProvider
     /// </summary>
     private readonly ConcurrentDictionary<string, CustomConfigurationData> _customConfigurationData = new ConcurrentDictionary<string, CustomConfigurationData>(StringComparer.InvariantCultureIgnoreCase);
 
-    private readonly string[] _infrastructureConfigurationKeys = new string[] {
-        nameof(BuildAnalyzerConfiguration.EvaluationAnalysisScope).ToLower(),
-        nameof(BuildAnalyzerConfiguration.IsEnabled).ToLower(),
-        nameof(BuildAnalyzerConfiguration.Severity).ToLower()
+    private readonly string[] _infrastructureConfigurationKeys = {
+        BuildCheckConstants.scopeConfigurationKey,
+        BuildCheckConstants.severityConfigurationKey,
     };
 
     /// <summary>
-    /// Gets the user specified unrecognized configuration for the given analyzer rule.
+    /// Gets the user specified unrecognized configuration for the given check rule.
     /// 
     /// The configuration module should as well check that CustomConfigurationData
     ///  for a particular rule is equal across the whole build (for all projects)  - otherwise it should error out.
@@ -84,7 +85,7 @@ public CustomConfigurationData GetCustomConfiguration(string projectFullPath, st
     /// <param name="ruleId"></param>
     /// <throws><see cref="BuildCheckConfigurationException"/> If CustomConfigurationData differs in a build for a same ruleId</throws>
     /// <returns></returns>
-    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
+    public void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
     {
         var configuration = GetCustomConfiguration(projectFullPath, ruleId);
         VerifyCustomConfigurationEquality(ruleId, configuration);
@@ -101,12 +102,12 @@ internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurati
         }
     }
 
-    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+    public CheckConfigurationEffective[] GetMergedConfigurations(
         string projectFullPath,
-        BuildAnalyzer analyzer)
-        => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
+        Check check)
+        => FillConfiguration(projectFullPath, check.SupportedRules, GetMergedConfiguration);
 
-    internal BuildAnalyzerConfiguration[] GetUserConfigurations(
+    public CheckConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
@@ -122,17 +123,17 @@ public CustomConfigurationData[] GetCustomConfigurations(
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
-        BuildAnalyzerConfiguration[] userConfigs,
-        BuildAnalyzer analyzer)
+    public CheckConfigurationEffective[] GetMergedConfigurations(
+        CheckConfiguration[] userConfigs,
+        Check check)
     {
-        var configurations = new BuildAnalyzerConfigurationInternal[userConfigs.Length];
+        var configurations = new CheckConfigurationEffective[userConfigs.Length];
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
             configurations[idx] = MergeConfiguration(
-                analyzer.SupportedRules[idx].Id,
-                analyzer.SupportedRules[idx].DefaultConfiguration,
+                check.SupportedRules[idx].Id,
+                check.SupportedRules[idx].DefaultConfiguration,
                 userConfigs[idx]);
         }
 
@@ -217,27 +218,28 @@ internal Dictionary<string, string> GetConfiguration(string projectFullPath, str
     }
 
     /// <summary>
-    /// Gets effective user specified (or default) configuration for the given analyzer rule.
+    /// Gets effective user specified (or default) configuration for the given check rule.
     /// The configuration values CAN be null upon this operation.
     /// 
-    /// The configuration module should as well check that BuildAnalyzerConfigurationInternal.EvaluationAnalysisScope
+    /// The configuration module should as well check that BuildCheckConfigurationInternal.EvaluationCheckScope
     ///  for all rules is equal - otherwise it should error out.
     /// </summary>
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    internal CheckConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
     {
         var cacheKey = $"{ruleId}-{projectFullPath}";
 
-        var editorConfigValue = _buildAnalyzerConfiguration.GetOrAdd(cacheKey, (key) =>
+        var editorConfigValue = _checkConfiguration.GetOrAdd(cacheKey, (key) =>
         {
-            BuildAnalyzerConfiguration? editorConfig = BuildAnalyzerConfiguration.Null;
+            CheckConfiguration? editorConfig = CheckConfiguration.Null;
+            editorConfig.RuleId = ruleId;
             var config = GetConfiguration(projectFullPath, ruleId);
 
             if (config.Any())
             {
-                editorConfig = BuildAnalyzerConfiguration.Create(config);
+                editorConfig = CheckConfiguration.Create(config);
             }
 
             return editorConfig;
@@ -247,38 +249,53 @@ internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath,
     }
 
     /// <summary>
-    /// Gets effective configuration for the given analyzer rule.
+    /// Gets effective configuration for the given check rule.
     /// The configuration values are guaranteed to be non-null upon this merge operation.
     /// </summary>
     /// <param name="projectFullPath"></param>
-    /// <param name="analyzerRule"></param>
+    /// <param name="checkRule"></param>
     /// <returns></returns>
-    internal BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
-        => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
+    internal CheckConfigurationEffective GetMergedConfiguration(string projectFullPath, CheckRule checkRule)
+        => GetMergedConfiguration(projectFullPath, checkRule.Id, checkRule.DefaultConfiguration);
 
-    internal BuildAnalyzerConfigurationInternal MergeConfiguration(
+    internal CheckConfigurationEffective MergeConfiguration(
         string ruleId,
-        BuildAnalyzerConfiguration defaultConfig,
-        BuildAnalyzerConfiguration editorConfig)
-        => new BuildAnalyzerConfigurationInternal(
+        CheckConfiguration defaultConfig,
+        CheckConfiguration editorConfig)
+        => new CheckConfigurationEffective(
             ruleId: ruleId,
-            evaluationAnalysisScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationAnalysisScope),
-            isEnabled: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.IsEnabled),
-            severity: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.Severity));
+            evaluationCheckScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationCheckScope),
+            severity: GetSeverityValue(editorConfig, defaultConfig));
 
-    private BuildAnalyzerConfigurationInternal GetMergedConfiguration(
+    private CheckConfigurationEffective GetMergedConfiguration(
         string projectFullPath,
         string ruleId,
-        BuildAnalyzerConfiguration defaultConfig)
+        CheckConfiguration defaultConfig)
         => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
 
     private T GetConfigValue<T>(
-        BuildAnalyzerConfiguration editorConfigValue,
-        BuildAnalyzerConfiguration defaultValue,
-        Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
+        CheckConfiguration editorConfigValue,
+        CheckConfiguration defaultValue,
+        Func<CheckConfiguration, T?> propertyGetter) where T : struct
         => propertyGetter(editorConfigValue) ??
            propertyGetter(defaultValue) ??
-           EnsureNonNull(propertyGetter(BuildAnalyzerConfiguration.Default));
+           EnsureNonNull(propertyGetter(CheckConfiguration.Default));
+
+    private CheckResultSeverity GetSeverityValue(CheckConfiguration editorConfigValue, CheckConfiguration defaultValue)
+    {
+        CheckResultSeverity? resultSeverity = null;
+
+        // Consider Default as null, so the severity from the default value could be selected.
+        // Default severity is not recognized by the infrastructure and serves for configuration purpuses only. 
+        if (editorConfigValue.Severity != null && editorConfigValue.Severity != CheckResultSeverity.Default)
+        {
+            resultSeverity = editorConfigValue.Severity;
+        }
+
+        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(CheckConfiguration.Default.Severity);
+
+        return resultSeverity.Value;
+    }
 
     private static T EnsureNonNull<T>(T? value) where T : struct
     {
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
index afd3645cf2e..ac8d8012e01 100644
--- a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Holder for the key-value pairs of unstructured data from .editorconfig file,
 ///  that were attribute to a particular rule, but were not recognized by the infrastructure.
-/// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
+/// The configuration data that is recognized by the infrastructure is passed as <see cref="CheckConfiguration"/>.
 /// </summary>
 public sealed class CustomConfigurationData
 {
@@ -41,7 +41,7 @@ public CustomConfigurationData(string ruleId, Dictionary<string, string> propert
     /// Key-value pairs of unstructured data from .editorconfig file.
     /// E.g. if in editorconfig file we'd have:
     /// [*.csrpoj]
-    /// build_analyzer.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
+    /// build_check.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
     ///
     /// the ConfigurationData would be:
     /// "name_of_targets_to_restrict" -> "Build,CoreCompile,ResolveAssemblyReferences"
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
index e19b61c2c40..163fd84f1ff 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
@@ -7,7 +7,7 @@ To track the request on sharing the code: https://github.com/dotnet/roslyn/issue
 In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. 
 
 Configuration divided into two categories: 
-- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope
+- Infra related configuration. IsEnabled, Severity, EvaluationCheckScope
 - Custom configuration, any other config specified by user for this particular rule
 
 ### Example
@@ -38,7 +38,7 @@ list<editorConfig>{
 }
 ```
 Reverse the order and collect all matching section key-value pairs into new dictionary
-Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)
+Remove non-msbuild-check related key-values (keys not starting with msbuild_check.RULEID)
 
 The implementation differs depending on category: 
  - Infra related config: Merges the configuration retrieved from configuration module with default values (respecting the specified configs in editorconfig) 
@@ -67,12 +67,12 @@ Lifecycle of BuildCheckManager could be found [here](https://github.com/dotnet/m
 
 
 #### Custom configuration data
-CustomConfigurationData is propogated to the BuildCheck Analyzer instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
-during the initialization of the [BuildAnalyzer](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildAnalyzer.cs#L36).
+CustomConfigurationData is propogated to the BuildCheck Check instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
+during the initialization of the [BuildExecutionCheck](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildExecutionCheck.cs#L36).
 
 
 #### Example of consuming the CustomConfigurationData
-The `Initialize` method of BuildCheck Analyzer:
+The `Initialize` method of BuildCheck Check:
 ```C#
 public override void Initialize(ConfigurationContext configurationContext)
 {
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index 9f39f8dcb69..88c644954e7 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
-using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
@@ -37,40 +36,52 @@ internal enum BuildCheckDataSource
 internal interface IBuildCheckManager
 {
     void ProcessEvaluationFinishedEventArgs(
-        AnalyzerLoggingContext buildAnalysisContext,
+        ICheckContext checksContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
 
+    void ProcessEnvironmentVariableReadEventArgs(
+        ICheckContext checksContext,
+        EnvironmentVariableReadEventArgs envVariableReadEventArgs);
+
     void ProcessTaskStartedEventArgs(
-        AnalyzerLoggingContext buildAnalysisContext,
+        ICheckContext checksContext,
         TaskStartedEventArgs taskStartedEventArgs);
 
     void ProcessTaskFinishedEventArgs(
-        AnalyzerLoggingContext buildAnalysisContext,
+        ICheckContext checksContext,
         TaskFinishedEventArgs taskFinishedEventArgs);
 
     void ProcessTaskParameterEventArgs(
-        AnalyzerLoggingContext buildAnalysisContext,
+        ICheckContext checksContext,
         TaskParameterEventArgs taskParameterEventArgs);
 
+    void ProcessBuildFinished(ICheckContext analysisContext);
+
     void SetDataSource(BuildCheckDataSource buildCheckDataSource);
 
-    void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext);
+    void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData, ICheckContext checksContext);
 
-    Dictionary<string, TimeSpan> CreateAnalyzerTracingStats();
+    Dictionary<string, TimeSpan> CreateCheckTracingStats();
 
     void FinalizeProcessing(LoggingContext loggingContext);
 
     // All those to be called from RequestBuilder,
     //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
-    //  to manager about what analyzers need to be materialized and configuration fetched.
-    // No unloading of analyzers is yet considered - once loaded it stays for whole build.
-    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string fullPath);
+    //  to manager about what checks need to be materialized and configuration fetched.
+    // No unloading of checks is yet considered - once loaded it stays for whole build.
+    
+	
+    // Project might be encountered first time in some node, but be already evaluated in another - so StartProjectEvaluation won't happen
+    //  - but we still need to know about it, hence the dedicated event.
+    void ProjectFirstEncountered(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext, string projectFullPath);
+
+    void ProcessProjectEvaluationStarted(ICheckContext checksContext, string projectFullPath);
 
-    void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+    void EndProjectEvaluation(BuildEventContext buildEventContext);
 
-    void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+    void StartProjectRequest(BuildEventContext buildEventContext, string projectFullPath);
 
-    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
+    void EndProjectRequest(ICheckContext checksContext, string projectFullPath);
 
     void Shutdown();
 }
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
index 43b08b39111..45eb5acea41 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManagerProvider.cs
@@ -7,11 +7,12 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Experimental.BuildCheck;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal interface IBuildCheckManagerProvider : IBuildComponent
 {
     IBuildCheckManager Instance { get; }
+
+    IBuildEngineDataRouter BuildEngineDataRouter { get; }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
new file mode 100644
index 00000000000..e51903fb06e
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
@@ -0,0 +1,28 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+internal interface IConfigurationProvider
+{
+    CheckConfiguration[] GetUserConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds);
+
+    CheckConfigurationEffective[] GetMergedConfigurations(
+        string projectFullPath,
+        Check check);
+
+    CheckConfigurationEffective[] GetMergedConfigurations(
+        CheckConfiguration[] userConfigs,
+        Check check);
+
+    CustomConfigurationData[] GetCustomConfigurations(
+        string projectFullPath,
+        IReadOnlyList<string> ruleIds);
+
+    void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
new file mode 100644
index 00000000000..ac9a4323dfb
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
@@ -0,0 +1,23 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Consumer of the data from the build engine.
+/// Currently, this is used to send data for checks to the BuildCheck.
+/// In the future we can multiplex the data to other consumers (e.g. copilot).
+/// </summary>
+internal interface IBuildEngineDataConsumer
+{
+    void ProcessPropertyRead(PropertyReadInfo propertyReadInfo);
+    
+    /// <summary>
+    /// Signals that a property was written to.
+    /// </summary>
+    /// <param name="propertyWriteInfo">Name of the property.</param>
+    void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo);
+
+    // TODO: We might want to move acquisition data processing into this interface as well
+    // void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
new file mode 100644
index 00000000000..6d94625052c
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
@@ -0,0 +1,32 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+/// <summary>
+/// The module that routes the data to the final consumer.
+/// Typically, it is the BuildCheck (in case of in-node check) or LoggingService
+///  (in case of centralized check, where the data will first be wrapped to BuildEventArgs and sent to central node).
+/// </summary>
+internal interface IBuildEngineDataRouter
+{
+    void ProcessPropertyRead(
+        PropertyReadInfo propertyReadInfo,
+        // This is intentionally CheckLoggingContext instead of ICheckContext - to avoid boxing allocations
+        //  on a hot path of properties reading (same for writing)
+        CheckLoggingContext checkContext);
+
+    /// <summary>
+    /// Signals that a property was written to.
+    /// </summary>
+    void ProcessPropertyWrite(
+        PropertyWriteInfo propertyWriteInfo,
+        CheckLoggingContext checkContext);
+
+    /// <summary>
+    /// Signals that evaluation in current node is starting
+    /// </summary>
+    /// <param name="checkContext"></param>
+    /// <param name="projectFullPath"></param>
+    void ProcessProjectEvaluationStarted(ICheckContext checkContext, string projectFullPath);
+}
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs
new file mode 100644
index 00000000000..9fa2029535a
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyReadInfo.cs
@@ -0,0 +1,24 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Bag of information for a performed property read.
+/// </summary>
+/// <param name="PropertyName">The portion of MSBuild script that contains the property name, that's being expanded.</param>
+/// <param name="StartIndex">Start index of the property name within the <see cref="PropertyName"/> property.</param>
+/// <param name="EndIndex">End index of the property name within the <see cref="PropertyName"/> property.</param>
+/// <param name="ElementLocation">The xml element location in which the property expansion happened.</param>
+/// <param name="IsUninitialized">Indicates whether the property was uninitialized when being expanded.</param>
+/// <param name="PropertyReadContext">Evaluation context in which the property was expanded.</param>
+internal readonly record struct PropertyReadInfo(
+    string PropertyName,
+    int StartIndex,
+    int EndIndex,
+    IMSBuildElementLocation ElementLocation,
+    bool IsUninitialized,
+    PropertyReadContext PropertyReadContext);
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyWriteInfo.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyWriteInfo.cs
new file mode 100644
index 00000000000..b93e256dac6
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/PropertyWriteInfo.cs
@@ -0,0 +1,17 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Bag of information for a performed property write.
+/// </summary>
+/// <param name="PropertyName">Name of the property.</param>
+/// <param name="IsEmpty">Was any value written? (E.g. if we set propA with value propB, while propB is undefined - the isEmpty will be true)</param>
+/// <param name="ElementLocation">Location of the property write</param>
+internal readonly record struct PropertyWriteInfo(
+    string PropertyName,
+    bool IsEmpty,
+    IMSBuildElementLocation? ElementLocation);
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index a0136eafac8..a5bf0b968a8 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -5,44 +5,52 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
-using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal class NullBuildCheckManager : IBuildCheckManager
+internal class NullBuildCheckManager : IBuildCheckManager, IBuildEngineDataRouter
 {
     public void Shutdown()
     {
     }
 
     public void ProcessEvaluationFinishedEventArgs(
-        AnalyzerLoggingContext buildAnalysisContext,
+        ICheckContext checkContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs)
     {
     }
 
+    public void ProcessBuildFinished(ICheckContext analysisContext)
+    {
+    }
+
     public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
     {
     }
 
-    public void ProcessTaskStartedEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+    public void ProcessTaskStartedEventArgs(
+        ICheckContext checkContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
     }
 
-    public void ProcessTaskFinishedEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+    public void ProcessTaskFinishedEventArgs(
+        ICheckContext checkContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
     }
 
-    public void ProcessTaskParameterEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+    public void ProcessTaskParameterEventArgs(
+        ICheckContext checkContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
     }
 
-    public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext) 
+    public void ProcessCheckAcquisition(
+        CheckAcquisitionData acquisitionData,
+        ICheckContext checkContext)
     {
     }
 
@@ -50,38 +58,35 @@ public void FinalizeProcessing(LoggingContext loggingContext)
     {
     }
 
-    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string fullPath)
-    {
-    }
-
-    public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    public void ProjectFirstEncountered(BuildCheckDataSource buildCheckDataSource, ICheckContext checkContext,
+        string projectFullPath)
     {
     }
 
-    public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    public void ProcessProjectEvaluationStarted(ICheckContext checkContext, string projectFullPath)
     {
     }
 
-    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    public void EndProjectEvaluation(BuildEventContext buildEventContext)
     {
     }
 
-    public void YieldProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    public void StartProjectRequest(BuildEventContext buildEventContext, string projectFullPath)
     {
     }
 
-    public void ResumeProject(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+    public void EndProjectRequest(ICheckContext checkContext, string projectFullPath)
     {
     }
 
-    public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats() => new Dictionary<string, TimeSpan>();
+    public Dictionary<string, TimeSpan> CreateCheckTracingStats() => new Dictionary<string, TimeSpan>();
 
-    public void StartTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskStartedEventArgs eventArgs)
+    public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext buildEventContext)
     { }
 
-    public void EndTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskFinishedEventArgs eventArgs)
+    public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext buildEventContext)
     { }
 
-    public void ProcessTaskParameter(BuildCheckDataSource buildCheckDataSource, TaskParameterEventArgs eventArg)
+    public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
     { }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
index 6005d4a7ea8..33da469ac5f 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManagerProvider.cs
@@ -8,12 +8,15 @@
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal class NullBuildCheckManagerProvider : IBuildCheckManagerProvider
 {
-    public IBuildCheckManager Instance { get; } = new NullBuildCheckManager();
+    private readonly NullBuildCheckManager _instance = new NullBuildCheckManager();
+    public IBuildCheckManager Instance => _instance;
+    public IBuildEngineDataRouter BuildEngineDataRouter => _instance;
 
     public void InitializeComponent(IBuildComponentHost host) { }
     public void ShutdownComponent() { }
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
index 9809ad27e49..d7f75922966 100644
--- a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -17,11 +17,11 @@ internal class TracingReporter
 
     // Infrastructure time keepers
     // TODO: add more timers throughout BuildCheck run
-    private TimeSpan analyzerAcquisitionTime;
-    private TimeSpan analyzerSetDataSourceTime;
-    private TimeSpan newProjectAnalyzersTime;
+    private TimeSpan checkAcquisitionTime;
+    private TimeSpan checkSetDataSourceTime;
+    private TimeSpan newProjectChecksTime;
 
-    public void AddAnalyzerStats(string name, TimeSpan subtotal)
+    public void AddCheckStats(string name, TimeSpan subtotal)
     {
         if (TracingStats.TryGetValue(name, out TimeSpan existing))
         {
@@ -35,25 +35,25 @@ public void AddAnalyzerStats(string name, TimeSpan subtotal)
 
     public void AddAcquisitionStats(TimeSpan subtotal)
     {
-        analyzerAcquisitionTime += subtotal;
+        checkAcquisitionTime += subtotal;
     }
 
     public void AddSetDataSourceStats(TimeSpan subtotal)
     {
-        analyzerSetDataSourceTime += subtotal;
+        checkSetDataSourceTime += subtotal;
     }
 
     public void AddNewProjectStats(TimeSpan subtotal)
     {
-        newProjectAnalyzersTime += subtotal;
+        newProjectChecksTime += subtotal;
     }
 
-    public void AddAnalyzerInfraStats()
+    public void AddCheckInfraStats()
     {
         var infraStats = new Dictionary<string, TimeSpan>() {
-                { $"{BuildCheckConstants.infraStatPrefix}analyzerAcquisitionTime", analyzerAcquisitionTime },
-                { $"{BuildCheckConstants.infraStatPrefix}analyzerSetDataSourceTime", analyzerSetDataSourceTime },
-                { $"{BuildCheckConstants.infraStatPrefix}newProjectAnalyzersTime", newProjectAnalyzersTime }
+                { $"{BuildCheckConstants.infraStatPrefix}checkAcquisitionTime", checkAcquisitionTime },
+                { $"{BuildCheckConstants.infraStatPrefix}checkSetDataSourceTime", checkSetDataSourceTime },
+                { $"{BuildCheckConstants.infraStatPrefix}newProjectChecksTime", newProjectChecksTime }
             };
 
         TracingStats.Merge(infraStats, (span1, span2) => span1 + span2);
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
deleted file mode 100644
index b7e39eaa8b0..00000000000
--- a/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Experimental.BuildCheck.Logging;
-
-internal class AnalyzerLoggingContext : LoggingContext
-{
-    public AnalyzerLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
-        : base(loggingService, eventContext)
-    {
-        IsValid = true;
-    }
-
-    public AnalyzerLoggingContext(LoggingContext baseContext) : base(baseContext)
-    {
-        IsValid = true;
-    }
-}
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
deleted file mode 100644
index 06b7dd6e033..00000000000
--- a/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Experimental.BuildCheck.Logging;
-
-internal class AnalyzerLoggingContextFactory(ILoggingService loggingService) : IBuildAnalysisLoggingContextFactory
-{
-    public AnalyzerLoggingContext CreateLoggingContext(BuildEventContext eventContext) =>
-        new AnalyzerLoggingContext(loggingService, eventContext);
-}
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index b47f510e165..fd33666fbd9 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -15,18 +15,40 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Base for a data passed from infrastructure to build analyzers.
+/// Base for a data passed from infrastructure to build checks.
 /// </summary>
 /// <param name="projectFilePath">Currently built project.</param>
-public abstract class AnalysisData(string projectFilePath)
+/// <param name="projectConfigurationId">The unique id of a project with unique global properties set.</param>
+public abstract class CheckData(string projectFilePath, int? projectConfigurationId)
 {
     private string? _projectFileDirectory;
+    // The id is going to be used in future revision
+#pragma warning disable CA1823
+    private int? _projectConfigurationId = projectConfigurationId;
+#pragma warning restore CA1823
 
     /// <summary>
     /// Full path to the project file being built.
     /// </summary>
     public string ProjectFilePath { get; } = projectFilePath;
 
+    // TBD: ProjectConfigurationId is not yet populated - as we need to properly anchor project build events
+    ///// <summary>
+    ///// The unique id of a project with unique global properties set.
+    ///// This is helpful to distinguish between different configurations of a single project in case of multitargeting.
+    /////
+    ///// In cases where the project instance cannot be determined, it will be set to <see cref="BuildEventContext.InvalidProjectInstanceId"/>.
+    ///// This is generally case of all evaluation-time data. To relate evaluation-time and build-execution-time data, use (TBD: ProjectStarted event/data)
+    ///// </summary>
+    ///// <remarks>
+    ///// The same project with same global properties (aka configuration), can be executed multiple times to obtain results for multiple targets.
+    /////  (this is internally distinguished as 'ProjectContextId' - each context is a different request for different targets results).
+    ///// This is not distinguished by the ProjectConfigurationId - as all of those executions share same configuration and results and prevents re-execution of the same targets.
+    /////
+    ///// InstanceId (ConfigurationId): https://github.com/dotnet/msbuild/blob/2a8b16dbabd25782554ff0fe77619d58eccfe603/src/Build/BackEnd/BuildManager/BuildManager.cs#L2186-L2244
+    ///// </remarks>
+    ////public int ProjectConfigurationId { get; } = projectConfigurationId ?? BuildEventContext.InvalidProjectInstanceId;
+
     /// <summary>
     /// Directory path of the file being built (the containing directory of <see cref="ProjectFilePath"/>).
     /// </summary>
@@ -35,39 +57,39 @@ public abstract class AnalysisData(string projectFilePath)
 }
 
 /// <summary>
-/// Data passed from infrastructure to build analyzers.
+/// Data passed from infrastructure to build checks.
 /// </summary>
-/// <typeparam name="T">The type of the actual data for analysis.</typeparam>
-public class BuildCheckDataContext<T> where T : AnalysisData
+/// <typeparam name="T">The type of the actual data for checking.</typeparam>
+public class BuildCheckDataContext<T> where T : CheckData
 {
-    private readonly BuildAnalyzerWrapper _analyzerWrapper;
-    private readonly LoggingContext _loggingContext;
-    private readonly BuildAnalyzerConfigurationInternal[] _configPerRule;
-    private readonly Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult> _resultHandler;
+    private readonly CheckWrapper _executionCheckWrapper;
+    private readonly ICheckContext _checkContext;
+    private readonly CheckConfigurationEffective[] _configPerRule;
+    private readonly Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> _resultHandler;
 
     internal BuildCheckDataContext(
-        BuildAnalyzerWrapper analyzerWrapper,
-        LoggingContext loggingContext,
-        BuildAnalyzerConfigurationInternal[] configPerRule,
-        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult> resultHandler,
+        CheckWrapper checkWrapper,
+        ICheckContext loggingContext,
+        CheckConfigurationEffective[] configPerRule,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler,
         T data)
     {
-        _analyzerWrapper = analyzerWrapper;
-        _loggingContext = loggingContext;
+        _executionCheckWrapper = checkWrapper;
+        _checkContext = loggingContext;
         _configPerRule = configPerRule;
         _resultHandler = resultHandler;
         Data = data;
     }
 
     /// <summary>
-    /// Method for reporting the result of the build analyzer rule.
+    /// Method for reporting the result of the build check rule.
     /// </summary>
     /// <param name="result"></param>
     public void ReportResult(BuildCheckResult result)
-        => _resultHandler(_analyzerWrapper, _loggingContext, _configPerRule, result);
+        => _resultHandler(_executionCheckWrapper, _checkContext, _configPerRule, result);
 
     /// <summary>
-    /// Data to be analyzed.
+    /// Data to be checked.
     /// </summary>
     public T Data { get; }
 }
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs b/src/Build/BuildCheck/OM/BuildFinishedCheckData.cs
similarity index 51%
rename from src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
rename to src/Build/BuildCheck/OM/BuildFinishedCheckData.cs
index 412a014be06..e22cf937908 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
+++ b/src/Build/BuildCheck/OM/BuildFinishedCheckData.cs
@@ -4,11 +4,8 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// The severity of reported result (or preconfigured or user configured severity for a rule).
+/// BuildCheck data indicating end of the build.
+/// This is the last event that can be received from the BuildCheck infrastructure.
 /// </summary>
-public enum BuildAnalyzerResultSeverity
-{
-    Info,
-    Warning,
-    Error,
-}
+public class BuildFinishedCheckData() : CheckData(string.Empty, null)
+{ }
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
deleted file mode 100644
index f3a336a41ec..00000000000
--- a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Collections.Generic;
-using Microsoft.Build.BackEnd.Logging;
-
-namespace Microsoft.Build.Experimental.BuildCheck;
-
-/// <summary>
-/// BuildCheck OM data representing the evaluated properties of a project.
-/// </summary>
-public class EvaluatedPropertiesAnalysisData : AnalysisData
-{
-    internal EvaluatedPropertiesAnalysisData(
-        string projectFilePath,
-        IReadOnlyDictionary<string, string> evaluatedProperties) :
-        base(projectFilePath) => EvaluatedProperties = evaluatedProperties;
-
-    public IReadOnlyDictionary<string, string> EvaluatedProperties { get; }
-}
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
new file mode 100644
index 00000000000..9b84e9ca2f9
--- /dev/null
+++ b/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
@@ -0,0 +1,34 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// BuildCheck OM data representing the evaluated properties of a project.
+/// </summary>
+public class EvaluatedPropertiesCheckData : CheckData
+{
+    internal EvaluatedPropertiesCheckData(
+        string projectFilePath,
+        int? projectConfigurationId,
+        IReadOnlyDictionary<string, string> evaluatedProperties,
+        IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)> evaluatedEnvironmentVariables)
+        : base(projectFilePath, projectConfigurationId)
+    {
+        EvaluatedProperties = evaluatedProperties;
+        EvaluatedEnvironmentVariables = evaluatedEnvironmentVariables;
+    }
+
+    /// <summary>
+    /// Gets the evaluated properties of the project.
+    /// </summary>
+    public IReadOnlyDictionary<string, string> EvaluatedProperties { get; }
+
+    /// <summary>
+    /// Gets the evaluated environment variables and their metadata.
+    /// </summary>
+    public IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)> EvaluatedEnvironmentVariables { get; }
+}
diff --git a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs b/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
similarity index 91%
rename from src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
rename to src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
index fdaf92aa510..46c295514c3 100644
--- a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
+++ b/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
@@ -42,12 +42,13 @@ public IEnumerable<ProjectItemElement> GetItemsOfType(string itemType)
 /// <summary>
 /// BuildCheck OM data representing the evaluated items of a project.
 /// </summary>
-public class ParsedItemsAnalysisData : AnalysisData
+public class ParsedItemsCheckData : CheckData
 {
-    internal ParsedItemsAnalysisData(
+    internal ParsedItemsCheckData(
         string projectFilePath,
+        int? projectConfigurationId,
         ItemsHolder itemsHolder) :
-        base(projectFilePath) => ItemsHolder = itemsHolder;
+        base(projectFilePath, projectConfigurationId) => ItemsHolder = itemsHolder;
 
     public ItemsHolder ItemsHolder { get; }
 }
@@ -55,7 +56,7 @@ internal ParsedItemsAnalysisData(
 /// <summary>
 /// BuildCheck OM data representing a task executed by a project.
 /// </summary>
-public sealed class TaskInvocationAnalysisData : AnalysisData
+public sealed class TaskInvocationCheckData : CheckData
 {
     /// <summary>
     /// Represents an input or output parameter of a task.
@@ -106,13 +107,14 @@ public IEnumerable<string> EnumerateStringValues()
         }
     }
 
-    internal TaskInvocationAnalysisData(
+    internal TaskInvocationCheckData(
         string projectFilePath,
+        int? projectConfigurationId,
         ElementLocation taskInvocationLocation,
         string taskName,
         string taskAssemblyLocation,
         IReadOnlyDictionary<string, TaskParameter> parameters)
-        : base(projectFilePath)
+        : base(projectFilePath, projectConfigurationId)
     {
         TaskInvocationLocation = taskInvocationLocation;
         TaskName = taskName;
diff --git a/src/Build/BuildCheck/OM/ProjectRequestProcessingDoneData.cs b/src/Build/BuildCheck/OM/ProjectRequestProcessingDoneData.cs
new file mode 100644
index 00000000000..3fa36d4cde5
--- /dev/null
+++ b/src/Build/BuildCheck/OM/ProjectRequestProcessingDoneData.cs
@@ -0,0 +1,15 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// This data captures end of single build request on a project.
+/// There can be multiple build request on a single project within single build
+/// (e.g. multiple targetting, or there can be explicit request for results of specific targets)
+/// </summary>
+/// <param name="projectFilePath"></param>
+/// <param name="projectConfigurationId"></param>
+internal class ProjectRequestProcessingDoneData(string projectFilePath, int? projectConfigurationId) : CheckData(projectFilePath, projectConfigurationId);
diff --git a/src/Build/BuildCheck/OM/PropertyReadData.cs b/src/Build/BuildCheck/OM/PropertyReadData.cs
new file mode 100644
index 00000000000..3599b381a5d
--- /dev/null
+++ b/src/Build/BuildCheck/OM/PropertyReadData.cs
@@ -0,0 +1,54 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Information about property being accessed - whether during evaluation or build.
+/// </summary>
+internal class PropertyReadData(
+    string projectFilePath,
+    int? projectConfigurationId,
+    string propertyName,
+    IMSBuildElementLocation elementLocation,
+    bool isUninitialized,
+    PropertyReadContext propertyReadContext)
+    : CheckData(projectFilePath, projectConfigurationId)
+{
+    public PropertyReadData(
+        string projectFilePath,
+        int? projectConfigurationId,
+        PropertyReadInfo propertyReadInfo)
+        : this(projectFilePath,
+            projectConfigurationId,
+            propertyReadInfo.PropertyName.Substring(propertyReadInfo.StartIndex, propertyReadInfo.EndIndex - propertyReadInfo.StartIndex + 1),
+            propertyReadInfo.ElementLocation,
+            propertyReadInfo.IsUninitialized,
+            propertyReadInfo.PropertyReadContext)
+    { }
+
+    /// <summary>
+    /// Name of the property that was accessed.
+    /// </summary>
+    public string PropertyName { get; } = propertyName;
+
+    /// <summary>
+    /// Location of the property access.
+    /// </summary>
+    public IMSBuildElementLocation ElementLocation { get; } = elementLocation;
+
+    /// <summary>
+    /// Indicates whether the property was accessed before being initialized.
+    /// </summary>
+    public bool IsUninitialized { get; } = isUninitialized;
+
+    /// <summary>
+    /// Gets the context type in which the property was accessed.
+    /// </summary>
+    public PropertyReadContext PropertyReadContext { get; } = propertyReadContext;
+}
diff --git a/src/Build/BuildCheck/OM/PropertyWriteData.cs b/src/Build/BuildCheck/OM/PropertyWriteData.cs
new file mode 100644
index 00000000000..c15ac695031
--- /dev/null
+++ b/src/Build/BuildCheck/OM/PropertyWriteData.cs
@@ -0,0 +1,46 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// Information about property being written to - either during evaluation phase
+///  or as part of property definition within the target.
+/// </summary>
+internal class PropertyWriteData(
+    string projectFilePath,
+    int? projectConfigurationId,
+    string propertyName,
+    IMSBuildElementLocation? elementLocation,
+    bool isEmpty)
+    : CheckData(projectFilePath, projectConfigurationId)
+{
+    public PropertyWriteData(string projectFilePath, int? projectConfigurationId, PropertyWriteInfo propertyWriteInfo)
+        : this(projectFilePath,
+            projectConfigurationId,
+            propertyWriteInfo.PropertyName,
+            propertyWriteInfo.ElementLocation,
+            propertyWriteInfo.IsEmpty)
+    { }
+
+    /// <summary>
+    /// Name of the property that was written to.
+    /// </summary>
+    public string PropertyName { get; } = propertyName;
+
+    /// <summary>
+    /// Location of the property write.
+    /// If the location is null, it means that the property doesn't come from xml, but rather other sources
+    ///  (environment variable, global property, toolset properties etc.).
+    /// </summary>
+    public IMSBuildElementLocation? ElementLocation { get; } = elementLocation;
+
+    /// <summary>
+    /// Was any value written? (E.g. if we set propA with value propB, while propB is undefined - the isEmpty will be true).
+    /// </summary>
+    public bool IsEmpty { get; } = isEmpty;
+}
diff --git a/src/Build/BuildCheck/Utilities/Constants.cs b/src/Build/BuildCheck/Utilities/Constants.cs
index 50a3d1bc63c..a95f02452e5 100644
--- a/src/Build/BuildCheck/Utilities/Constants.cs
+++ b/src/Build/BuildCheck/Utilities/Constants.cs
@@ -15,4 +15,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Utilities;
 internal static class BuildCheckConstants
 {
     internal const string infraStatPrefix = "infrastructureStat_";
+
+    internal const string severityConfigurationKey = "severity";
+    internal const string scopeConfigurationKey = "scope";
 }
diff --git a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs b/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
index 96efc8ff2fd..f89f72b0e2c 100644
--- a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
+++ b/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+using System.Collections.ObjectModel;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
@@ -23,6 +21,26 @@ public static string ToCsvString<T>(this IEnumerable<T>? source, bool useSpace =
         return source == null ? "<NULL>" : string.Join(useSpace ? ", " : ",", source);
     }
 
+    /// <summary>
+    /// Returns the item as an enumerable with single item.
+    /// </summary>
+    /// <typeparam name="T"></typeparam>
+    /// <param name="item"></param>
+    /// <returns></returns>
+    public static IEnumerable<T> AsSingleItemEnumerable<T>(this T item)
+    {
+        yield return item;
+    }
+
+#if !NET
+    /// <summary>
+    /// Returns a read-only <see cref="ReadOnlyDictionary{TKey, TValue}"/> wrapper
+    /// for the current dictionary.
+    /// </summary>
+    public static ReadOnlyDictionary<TKey, TValue> AsReadOnly<TKey, TValue>(this IDictionary<TKey, TValue> dictionary)
+        => new(dictionary);
+#endif
+
     /// <summary>
     /// Adds a content of given dictionary to current dictionary.
     /// </summary>
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 76e975fe3c3..44e7fe20555 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -36,18 +36,18 @@ namespace Microsoft.Build.Collections
     /// </remarks>
     /// <typeparam name="T">Property or Metadata class type to store</typeparam>
     [DebuggerDisplay("#Entries={Count}")]
-    internal sealed class CopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatable<CopyOnWritePropertyDictionary<T>>, IDictionary<string, T>
+    internal sealed class CopyOnWritePropertyDictionary<T> : ICopyOnWritePropertyDictionary<T>, IEquatable<CopyOnWritePropertyDictionary<T>>
         where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
     {
         private static readonly ImmutableDictionary<string, T> NameComparerDictionaryPrototype = ImmutableDictionary.Create<string, T>(MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
-        /// Backing dictionary
+        /// Backing dictionary.
         /// </summary>
         private ImmutableDictionary<string, T> _backing;
 
         /// <summary>
-        /// Creates empty dictionary
+        /// Creates empty dictionary.
         /// </summary>
         public CopyOnWritePropertyDictionary()
         {
@@ -55,7 +55,7 @@ public CopyOnWritePropertyDictionary()
         }
 
         /// <summary>
-        /// Cloning constructor, with deferred cloning semantics
+        /// Cloning constructor, with deferred cloning semantics.
         /// </summary>
         private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         {
@@ -63,12 +63,12 @@ private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         }
 
         /// <summary>
-        /// Accessor for the list of property names
+        /// Accessor for the list of property names.
         /// </summary>
         ICollection<string> IDictionary<string, T>.Keys => ((IDictionary<string, T>)_backing).Keys;
 
         /// <summary>
-        /// Accessor for the list of properties
+        /// Accessor for the list of properties.
         /// </summary>
         ICollection<T> IDictionary<string, T>.Values => ((IDictionary<string, T>)_backing).Values;
 
@@ -115,6 +115,16 @@ public T this[string name]
         /// </summary>
         public bool Contains(string name) => _backing.ContainsKey(name);
 
+        public string GetEscapedValue(string name)
+        {
+            if (_backing.TryGetValue(name, out T value))
+            {
+                return value?.EscapedValue;
+            }
+
+            return null;
+        }
+
         /// <summary>
         /// Empties the collection
         /// </summary>
@@ -134,7 +144,7 @@ public void Clear()
         /// </summary>
         IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
-        #region IEquatable<PropertyDictionary<T>> Members
+        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
 
         /// <summary>
         /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
@@ -180,6 +190,56 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
 
         #endregion
 
+        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
+
+        /// <summary>
+        /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
+        /// same values as the other, unequal otherwise.
+        /// </summary>
+        /// <param name="other">The dictionary to which this should be compared</param>
+        /// <returns>True if they are equivalent, false otherwise.</returns>
+        public bool Equals(ICopyOnWritePropertyDictionary<T> other)
+        {
+            if (other == null)
+            {
+                return false;
+            }
+
+            ImmutableDictionary<string, T> thisBacking = _backing;
+            IDictionary<string, T> otherDict = other;
+
+            if (other is CopyOnWritePropertyDictionary<T> otherCopyOnWritePropertyDictionary)
+            {
+                // If the backing collections are the same, we are equal.
+                // Note that with this check, we intentionally avoid the common reference
+                // comparison between 'this' and 'other'.
+                if (ReferenceEquals(thisBacking, otherCopyOnWritePropertyDictionary._backing))
+                {
+                    return true;
+                }
+
+                otherDict = otherCopyOnWritePropertyDictionary._backing;
+            }
+
+            if (thisBacking.Count != otherDict.Count)
+            {
+                return false;
+            }
+
+            foreach (T thisProp in thisBacking.Values)
+            {
+                if (!otherDict.TryGetValue(thisProp.Key, out T thatProp) ||
+                    !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        #endregion
+
         #region IDictionary<string,T> Members
 
         /// <summary>
@@ -274,7 +334,7 @@ public bool Remove(string name)
         /// Overwrites any property with the same name already in the collection.
         /// To remove a property, use Remove(...) instead.
         /// </summary>
-        internal void Set(T projectProperty)
+        public void Set(T projectProperty)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectProperty, nameof(projectProperty));
 
@@ -285,7 +345,7 @@ internal void Set(T projectProperty)
         /// Adds the specified properties to this dictionary.
         /// </summary>
         /// <param name="other">An enumerator over the properties to add.</param>
-        internal void ImportProperties(IEnumerable<T> other)
+        public void ImportProperties(IEnumerable<T> other)
         {
             _backing = _backing.SetItems(Items());
 
@@ -302,7 +362,7 @@ IEnumerable<KeyValuePair<string, T>> Items()
         /// Clone. As we're copy on write, this
         /// should be cheap.
         /// </summary>
-        internal CopyOnWritePropertyDictionary<T> DeepClone()
+        public ICopyOnWritePropertyDictionary<T> DeepClone()
         {
             return new CopyOnWritePropertyDictionary<T>(this);
         }
diff --git a/src/Build/Collections/ICopyOnWritePropertyDictionary.cs b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
new file mode 100644
index 00000000000..310476fa83b
--- /dev/null
+++ b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
@@ -0,0 +1,65 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using Microsoft.Build.Shared;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// An interface that represents a dictionary of unordered property or metadata name/value pairs with copy-on-write semantics.
+    /// </summary>
+    /// <remarks>
+    /// The value that this adds over IDictionary&lt;string, T&gt; is:
+    ///     - supports copy on write
+    ///     - enforces that key = T.Name
+    ///     - default enumerator is over values
+    ///     - (marginal) enforces the correct key comparer
+    ///
+    /// Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
+    /// either not expose this collection or expose it through a readonly wrapper.
+    ///
+    /// This collection is safe for concurrent readers and a single writer.
+    /// </remarks>
+    /// <typeparam name="T">Property or Metadata class type to store</typeparam>
+    internal interface ICopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatable<ICopyOnWritePropertyDictionary<T>>, IDictionary<string, T>
+        where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
+    {
+        /// <summary>
+        /// Returns true if a property with the specified name is present in the collection, otherwise false.
+        /// </summary>
+        bool Contains(string name);
+
+        /// <summary>
+        /// Add the specified property to the collection.
+        /// Overwrites any property with the same name already in the collection.
+        /// To remove a property, use Remove(...) instead.
+        /// </summary>
+        void Set(T projectProperty);
+
+        /// <summary>
+        /// Adds the specified properties to this dictionary.
+        /// </summary>
+        /// <param name="other">An enumerator over the properties to add.</param>
+        void ImportProperties(IEnumerable<T> other);
+
+        /// <summary>
+        /// Clone. As we're copy on write, this should be cheap.
+        /// </summary>
+        ICopyOnWritePropertyDictionary<T> DeepClone();
+
+        /// <summary>
+        /// <typeparamref name="T"/> must implement <see cref="IKeyed"/>, which means it contains an
+        /// EscapedValue. This method allows retrieving the EscapedValue of an object in the dictionary
+        /// directly.
+        /// </summary>
+        string GetEscapedValue(string name);
+    }
+}
diff --git a/src/Build/Collections/IMultiDictionary.cs b/src/Build/Collections/IMultiDictionary.cs
new file mode 100644
index 00000000000..1fece50dc23
--- /dev/null
+++ b/src/Build/Collections/IMultiDictionary.cs
@@ -0,0 +1,24 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Represents a dictionary that can hold more than one distinct value with the same key.
+    /// All keys must have at least one value: null values are currently rejected.
+    /// </summary>
+    /// <typeparam name="K">Type of key</typeparam>
+    /// <typeparam name="V">Type of value</typeparam>
+    internal interface IMultiDictionary<K, V>
+        where K : class
+        where V : class
+    {
+        IEnumerable<V> this[K key] { get; }
+    }
+}
diff --git a/src/Build/Collections/MultiDictionary.cs b/src/Build/Collections/MultiDictionary.cs
index b2fc7427261..ef8c02c8c8e 100644
--- a/src/Build/Collections/MultiDictionary.cs
+++ b/src/Build/Collections/MultiDictionary.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Collections
     /// <typeparam name="K">Type of key</typeparam>
     /// <typeparam name="V">Type of value</typeparam>
     [DebuggerDisplay("#Keys={KeyCount} #Values={ValueCount}")]
-    internal class MultiDictionary<K, V>
+    internal class MultiDictionary<K, V> : IMultiDictionary<K, V>
         where K : class
         where V : class
     {
@@ -86,7 +86,7 @@ internal MultiDictionary(IEqualityComparer<K> keyComparer)
         /// <summary>
         /// Enumerator over values that have the specified key.
         /// </summary>
-        internal IEnumerable<V> this[K key]
+        public IEnumerable<V> this[K key]
         {
             get
             {
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 26be27d807b..c105e12083b 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -42,14 +42,14 @@ internal sealed class PropertyDictionary<T> : IEnumerable<T>, IEquatable<Propert
         /// Backing dictionary
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        private readonly IRetrievableEntryHashSet<T> _properties;
+        private readonly IRetrievableValuedEntryHashSet<T> _properties;
 
         /// <summary>
         /// Creates empty dictionary
         /// </summary>
         public PropertyDictionary()
         {
-            _properties = new RetrievableEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new RetrievableValuedEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -57,7 +57,7 @@ public PropertyDictionary()
         /// </summary>
         internal PropertyDictionary(int capacity)
         {
-            _properties = new RetrievableEntryHashSet<T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new RetrievableValuedEntryHashSet<T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -77,7 +77,7 @@ internal PropertyDictionary(IEnumerable<T> elements)
         /// </summary>
         internal PropertyDictionary(MSBuildNameIgnoreCaseComparer comparer)
         {
-            _properties = new RetrievableEntryHashSet<T>(comparer);
+            _properties = new RetrievableValuedEntryHashSet<T>(comparer);
         }
 
         /// <summary>
@@ -96,7 +96,7 @@ internal PropertyDictionary(int capacity, IEnumerable<T> elements)
         /// Initializes a new instance of the <see cref="PropertyDictionary{T}"/> class.
         /// </summary>
         /// <param name="propertiesHashSet">The collection of properties to use.</param>
-        internal PropertyDictionary(IRetrievableEntryHashSet<T> propertiesHashSet)
+        internal PropertyDictionary(IRetrievableValuedEntryHashSet<T> propertiesHashSet)
         {
             _properties = propertiesHashSet;
         }
@@ -324,6 +324,24 @@ public T Get(string keyString, int startIndex, int endIndex)
             return GetProperty(keyString, startIndex, endIndex);
         }
 
+        /// <summary>
+        /// Gets the unescaped value of a particular property.
+        /// </summary>
+        /// <param name="propertyName">The name of the property whose value is sought.</param>
+        /// <param name="unescapedValue">The out parameter by which a successfully retrieved value is returned.</param>
+        /// <returns>True if a property with a matching name was found. False otherwise.</returns>
+        public bool TryGetPropertyUnescapedValue(string propertyName, out string unescapedValue)
+        {
+            if (_properties.TryGetEscapedValue(propertyName, out string escapedValue) && escapedValue != null)
+            {
+                unescapedValue = EscapingUtilities.UnescapeAll(escapedValue);
+                return true;
+            }
+
+            unescapedValue = null;
+            return false;
+        }
+
         #region IDictionary<string,T> Members
 
         /// <summary>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
index 3100e7914a8..4d271575848 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
@@ -8,6 +8,12 @@
 
 namespace Microsoft.Build.Collections
 {
+    /// <summary>
+    /// Represents a hash set mapping string to <typeparamref name="T"/>, with the specialization that
+    /// value lookup supports using substrings of a provided key without requiring instantiating the substring
+    /// (in order to avoid the memory usage of string allocation).
+    /// </summary>
+    /// <typeparam name="T">The type of data the hash set contains (which must be <see cref="IKeyed"/>).</typeparam>
     internal interface IRetrievableEntryHashSet<T> :
         ICollection<T>,
         ISerializable,
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
new file mode 100644
index 00000000000..e3b10556772
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
@@ -0,0 +1,34 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Like <see cref="IRetrievableEntryHashSet{T}"/>, this represents a hash set mapping string to <typeparamref name="T"/>
+    /// with the specialization that value lookup supports using substrings of a provided key without requiring instantiating
+    /// the substring (in order to avoid the memory usage of string allocation).
+    ///
+    /// This interface extends the functionality of <see cref="IRetrievableEntryHashSet{T}"/> by introducing the ability
+    /// to directly retrieve the Value of an instance of T instead of retrieving the instance of T itself. Implementations of
+    /// this interface can avoid the cost of allocating an instance of <typeparamref name="T"/> when the caller requests only
+    /// the Value.
+    /// </summary>
+    /// <typeparam name="T">The type of data the hash set contains (which must be
+    /// <see cref="IKeyed"/> and also <see cref="IValued"/>).</typeparam>
+    internal interface IRetrievableValuedEntryHashSet<T> : IRetrievableEntryHashSet<T>
+        where T : class, IKeyed, IValued
+    {
+        /// <summary>
+        /// Gets the <see cref="IValued.EscapedValue"/> of the item whose <see cref="IKeyed.Key"/> matches <paramref name="key"/>.
+        /// </summary>
+        /// <param name="key">The key of the item whose value is sought.</param>
+        /// <param name="escapedValue">The out parameter by which a successfully retrieved <see cref="IValued.EscapedValue"/> is returned.</param>
+        /// <returns>True if an item whose <see cref="IKeyed.Key"/> matches <paramref name="key"/> was found. False otherwise.</returns>
+        bool TryGetEscapedValue(string key, out string escapedValue);
+    }
+}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
similarity index 99%
rename from src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
rename to src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
index e6160cec90f..dc8d96f9f7c 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
@@ -320,7 +320,7 @@ public bool TryGetValue(string key, out T item)
         /// Gets the item if any with the given name
         /// </summary>
         /// <param name="key">key to check for containment</param>
-        /// <returns>true if item contained; false if not</returns>
+        /// <returns>The item, if it was found. Otherwise, default(T).</returns>
         public T Get(string key)
         {
             return GetCore(key, 0, key?.Length ?? 0);
diff --git a/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
new file mode 100644
index 00000000000..c45da4e12b6
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
@@ -0,0 +1,53 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <inheritdoc />
+    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]
+    [DebuggerDisplay("Count = {Count}")]
+#if FEATURE_SECURITY_PERMISSIONS
+    [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
+#endif
+    internal class RetrievableValuedEntryHashSet<T> : RetrievableEntryHashSet<T>, IRetrievableValuedEntryHashSet<T>
+        where T : class, IKeyed, IValued
+    {
+        /// <summary>
+        /// Initializes a new instance of the RetrievableValuedEntryHashSet class.
+        /// </summary>
+        /// <param name="comparer">A comparer with which the items' <see cref="IKeyed.Key"/> key values are compared.</param>
+        public RetrievableValuedEntryHashSet(IEqualityComparer<string> comparer)
+            : base(comparer)
+        {
+        }
+
+        /// <summary>
+        /// Initializes a new instance of the RetrievableValuedEntryHashSet class.
+        /// </summary>
+        /// <param name="suggestedCapacity">A value suggesting a good approximate minimum size for the initial collection.</param>
+        /// <param name="comparer">A comparer with which the items' <see cref="IKeyed.Key"/> key values are compared.</param>
+        public RetrievableValuedEntryHashSet(int suggestedCapacity, IEqualityComparer<string> comparer)
+            : base(suggestedCapacity, comparer)
+        {
+        }
+
+        /// <inheritdoc />
+        public bool TryGetEscapedValue(string key, out string escapedValue)
+        {
+            if (TryGetValue(key, out T item) && item != null)
+            {
+                escapedValue = item.EscapedValue;
+                return true;
+            }
+
+            escapedValue = null;
+            return false;
+        }
+    }
+}
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
index 85a8e28b087..17d4b54af0f 100644
--- a/src/Build/CompatibilitySuppressions.xml
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -3,288 +3,560 @@
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
   <Suppression>
     <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.IBuildEventStringsReader</Target>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.IBuildEventStringsReader</Target>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.IBuildEventStringsReader</Target>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0001</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.IBuildEventStringsReader</Target>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.add_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.remove_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.add_StringEncountered(System.Action)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.remove_StringEncountered(System.Action)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.add_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.remove_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.add_StringEncountered(System.Action)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.remove_StringEncountered(System.Action)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.add_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.remove_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.add_StringEncountered(System.Action)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.remove_StringEncountered(System.Action)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.add_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
-    <Left>ref/net8.0/Microsoft.Build.dll</Left>
-    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BinaryLogReplayEventSource.remove_NotificationsSourceCreated(System.Action{Microsoft.Build.Logging.IBuildEventArgsReaderNotifications})</Target>
-    <Left>ref/net8.0/Microsoft.Build.dll</Left>
-    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.add_StringEncountered(System.Action)</Target>
-    <Left>ref/net8.0/Microsoft.Build.dll</Left>
-    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Logging.BuildEventArgsReader.remove_StringEncountered(System.Action)</Target>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.ArchiveFileEncountered</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.RecoverableReadError</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.StringReadDone</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.ArchiveFileEncountered</Target>
-    <Left>lib/net8.0/Microsoft.Build.dll</Left>
-    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_Location</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.RecoverableReadError</Target>
-    <Left>lib/net8.0/Microsoft.Build.dll</Left>
-    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.StringReadDone</Target>
-    <Left>lib/net8.0/Microsoft.Build.dll</Left>
-    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0006</DiagnosticId>
-    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.ArchiveFileEncountered</Target>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0006</DiagnosticId>
-    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.RecoverableReadError</Target>
-    <Left>ref/net8.0/Microsoft.Build.dll</Left>
-    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterBuildFinishedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.BuildFinishedCheckData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0006</DiagnosticId>
-    <Target>E:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications.StringReadDone</Target>
-    <Left>ref/net8.0/Microsoft.Build.dll</Left>
-    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.BuildEventArgsReader</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.BuildEventArgsReader</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterBuildFinishedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.BuildFinishedCheckData}})</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.BuildEventArgsReader</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.BuildEventArgsReader</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterBuildFinishedAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.BuildFinishedCheckData}})</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0008</DiagnosticId>
-    <Target>T:Microsoft.Build.Logging.IBuildEventArgsReaderNotifications</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
-  <!-- Changes to the Experimental namespace are considered non-breaking, and this ctor should be used only internally, not by plugin code. -->
   <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.FileAccess.FileAccessData.#ctor(Microsoft.Build.Experimental.FileAccess.ReportedFileOperation,Microsoft.Build.Experimental.FileAccess.RequestedAccess,System.UInt32,System.UInt32,Microsoft.Build.Experimental.FileAccess.DesiredAccess,Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes,System.String,System.String,System.Boolean)</Target>
-    <Left>lib/net472/Microsoft.Build.dll</Left>
-    <Right>lib/net472/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.FileAccess.FileAccessData.#ctor(Microsoft.Build.Experimental.FileAccess.ReportedFileOperation,Microsoft.Build.Experimental.FileAccess.RequestedAccess,System.UInt32,System.UInt32,Microsoft.Build.Experimental.FileAccess.DesiredAccess,Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes,System.String,System.String,System.Boolean)</Target>
-    <Left>lib/net8.0/Microsoft.Build.dll</Left>
-    <Right>lib/net8.0/Microsoft.Build.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
-  <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.FileAccess.FileAccessData.#ctor(Microsoft.Build.Experimental.FileAccess.ReportedFileOperation,Microsoft.Build.Experimental.FileAccess.RequestedAccess,System.UInt32,System.UInt32,Microsoft.Build.Experimental.FileAccess.DesiredAccess,Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes,System.String,System.String,System.Boolean)</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.FileAccess.FileAccessData.#ctor(Microsoft.Build.Experimental.FileAccess.ReportedFileOperation,Microsoft.Build.Experimental.FileAccess.RequestedAccess,System.UInt32,System.UInt32,Microsoft.Build.Experimental.FileAccess.DesiredAccess,Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes,System.String,System.String,System.Boolean)</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 92e920c3f80..2ab9a1a53d4 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1691,31 +1691,13 @@ private void ReloadFrom(Func<bool, XmlDocumentWithLocation> documentProducer, bo
 
             var oldDocument = XmlDocument;
             XmlDocumentWithLocation newDocument = documentProducer(preserveFormatting ?? PreserveFormatting);
-            try
-            {
-                // Reload should only mutate the state if there are no parse errors.
-                ThrowIfDocumentHasParsingErrors(newDocument);
 
-                RemoveAllChildren();
+            // Reload should only mutate the state if there are no parse errors.
+            ThrowIfDocumentHasParsingErrors(newDocument);
 
-                ProjectParser.Parse(newDocument, this);
-            }
-            finally
-            {
-                // Whichever document didn't become this element's document must be removed from the string cache.
-                // We do it after the fact based on the assumption that Projects are reloaded repeatedly from their
-                // file with small increments, and thus most strings would get reused avoiding unnecessary churn in
-                // the string cache.
-                var currentDocument = XmlDocument;
-                if (!object.ReferenceEquals(currentDocument, oldDocument))
-                {
-                    oldDocument.ClearAnyCachedStrings();
-                }
-                if (!object.ReferenceEquals(currentDocument, newDocument))
-                {
-                    newDocument.ClearAnyCachedStrings();
-                }
-            }
+            RemoveAllChildren();
+
+            ProjectParser.Parse(newDocument, this);
 
             MarkDirty("Project reloaded", null);
         }
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 741babe959c..d7d90b3a939 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -3571,7 +3571,6 @@ public override void Unload()
             {
                 Xml.OnAfterProjectRename -= _renameHandler;
                 Xml.OnProjectXmlChanged -= ProjectRootElement_ProjectXmlChangedHandler;
-                Xml.XmlDocument.ClearAnyCachedStrings();
                 _renameHandler = null;
             }
 
@@ -4439,7 +4438,7 @@ public IItemDefinition<ProjectMetadata> GetItemDefinition(string itemType)
             /// <summary>
             /// Sets a property which is not derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
+            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false)
             {
                 ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext);
                 Properties.Set(property);
@@ -4452,7 +4451,7 @@ public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bo
             /// <summary>
             /// Sets a property derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
+            public ProjectProperty SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, LoggingContext loggingContext)
             {
                 ProjectProperty predecessor = GetProperty(propertyElement.Name);
                 ProjectProperty property = ProjectProperty.Create(Project, propertyElement, evaluatedValueEscaped, predecessor);
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 11dd0a1143d..93e536f0aa8 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -887,6 +887,21 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
         /// Returns the property dictionary containing the properties representing the environment.
         /// </summary>
         internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
+        {
+            get
+            {
+                // Retrieves the environment properties.
+                // This is only done once, when the project collection is created. Any subsequent
+                // environment changes will be ignored. Child nodes will be passed this set
+                // of properties in their build parameters.
+                return new PropertyDictionary<ProjectPropertyInstance>(SharedReadOnlyEnvironmentProperties);
+            }
+        }
+
+        /// <summary>
+        /// Returns a shared immutable property dictionary containing the properties representing the environment.
+        /// </summary>
+        internal PropertyDictionary<ProjectPropertyInstance> SharedReadOnlyEnvironmentProperties
         {
             get
             {
@@ -898,7 +913,7 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                 {
                     if (_environmentProperties != null)
                     {
-                        return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
+                        return _environmentProperties;
                     }
                 }
 
@@ -906,9 +921,9 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                 {
                     if (_environmentProperties == null)
                     {
-                        _environmentProperties = Utilities.GetEnvironmentProperties();
+                        _environmentProperties = Utilities.GetEnvironmentProperties(makeReadOnly: true);
                     }
-                    return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
+                    return _environmentProperties;
                 }
             }
         }
@@ -1348,18 +1363,6 @@ public void UnloadProject(Project project)
                 // free memory. These may be the last references to the ProjectRootElements
                 // in the cache, so the cache shouldn't hold strong references to them of its own.
                 ProjectRootElementCache.DiscardStrongReferences();
-
-                // Aggressively release any strings from all the contributing documents.
-                // It's fine if we cache less (by now we likely did a lot of loading and got the benefits)
-                // If we don't do this, we could be releasing the last reference to a
-                // ProjectRootElement, causing it to fall out of the weak cache leaving its strings and XML
-                // behind in the string cache.
-                project.Xml.XmlDocument.ClearAnyCachedStrings();
-
-                foreach (var import in project.Imports)
-                {
-                    import.ImportedProject.XmlDocument.ClearAnyCachedStrings();
-                }
             }
         }
 
@@ -1390,7 +1393,6 @@ public void UnloadProject(ProjectRootElement projectRootElement)
                     ErrorUtilities.ThrowInvalidOperation("OM_ProjectXmlCannotBeUnloadedDueToLoadedProjects", projectRootElement.FullPath, conflictingProject.FullPath);
                 }
 
-                projectRootElement.XmlDocument.ClearAnyCachedStrings();
                 ProjectRootElementCache.DiscardAnyWeakReference(projectRootElement);
             }
         }
@@ -1541,7 +1543,6 @@ public bool TryUnloadProject(ProjectRootElement projectRootElement)
                 if (conflictingProject == null)
                 {
                     ProjectRootElementCache.DiscardAnyWeakReference(projectRootElement);
-                    projectRootElement.XmlDocument.ClearAnyCachedStrings();
                     return true;
                 }
 
@@ -1972,6 +1973,11 @@ public ReusableLogger(ILogger originalLogger)
             /// </summary>
             public event BuildFinishedEventHandler BuildFinished;
 
+            /// <summary>
+            /// The BuildCanceled logging event
+            /// </summary>
+            public event BuildCanceledEventHandler BuildCanceled;
+
             /// <summary>
             /// The ProjectStarted logging event
             /// </summary>
@@ -2392,6 +2398,14 @@ private void BuildFinishedHandler(object sender, BuildFinishedEventArgs e)
                 BuildFinished?.Invoke(sender, e);
             }
 
+            /// <summary>
+            /// Handler for BuildCanceled events.
+            /// </summary>
+            private void BuildCanceledHandler(object sender, BuildCanceledEventArgs e)
+            {
+                BuildCanceled?.Invoke(sender, e);
+            }
+
             /// <summary>
             /// Handler for Any events.
             /// </summary>
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 6a05f7dadbc..43c7b7a3826 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -33,6 +33,11 @@ public abstract class ProjectProperty : IKeyed, IValued, IProperty, IEquatable<P
         /// </summary>
         private string _evaluatedValueEscaped;
 
+        /// <summary>
+        /// Property location in xml file. Can be empty.
+        /// </summary>
+        private (string File, int Line, int Column) _location;
+
         internal ProjectProperty(Project project)
         {
             ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
@@ -100,7 +105,7 @@ string IProperty.EvaluatedValueEscaped
             {
                 if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext is { IsValid: true } loggingContext && !environmentProperty._loggedEnvProperty && !Traits.LogAllEnvironmentVariables)
                 {
-                    EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal);
+                    EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal, string.Empty, 0, 0);
                     args.BuildEventContext = loggingContext.BuildEventContext;
                     loggingContext.LogBuildEvent(args);
                     environmentProperty._loggedEnvProperty = true;
@@ -110,6 +115,27 @@ string IProperty.EvaluatedValueEscaped
             }
         }
 
+        /// <summary>
+        /// Gets object's location in xml file.
+        /// </summary>
+        public (string File, int Line, int Column) Location { get => _location; }
+
+        string IProperty.GetEvaluatedValueEscaped(IElementLocation location)
+        {
+            if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext is { IsValid: true } loggingContext && !environmentProperty._loggedEnvProperty && !Traits.LogAllEnvironmentVariables)
+            {
+                EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal, location.File, location.Line, location.Column);
+                args.BuildEventContext = loggingContext.BuildEventContext;
+                loggingContext.LogBuildEvent(args);
+                environmentProperty._loggedEnvProperty = true;
+            }
+
+            // the location is handy in BuildCheck messages.
+            _location = (location.File, location.Line, location.Column);
+
+            return EvaluatedValueEscapedInternal;
+        }
+
         /// <summary>
         /// Gets or sets the unevaluated property value.
         /// Updates the evaluated value in the project, although this is not sure to be correct until re-evaluation.
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 0799d38db90..fdc817b930c 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -419,16 +419,8 @@ private void ReadEachToolset(
 
                     Toolset toolset = ReadToolset(toolsVersion, globalProperties, initialPropertiesClone, accumulateProperties);
 
-                    // Register toolset paths into list of immutable directories
-                    // example: C:\Windows\Microsoft.NET\Framework
-                    string frameworksPathPrefix32 = existingRootOrNull(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath32")?.EvaluatedValue?.Trim());
-                    FileClassifier.Shared.RegisterImmutableDirectory(frameworksPathPrefix32);
-                    // example: C:\Windows\Microsoft.NET\Framework64
-                    string frameworksPathPrefix64 = existingRootOrNull(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath64")?.EvaluatedValue?.Trim());
-                    FileClassifier.Shared.RegisterImmutableDirectory(frameworksPathPrefix64);
-                    // example: C:\Windows\Microsoft.NET\FrameworkArm64
-                    string frameworksPathPrefixArm64 = existingRootOrNull(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPathArm64")?.EvaluatedValue?.Trim());
-                    FileClassifier.Shared.RegisterImmutableDirectory(frameworksPathPrefixArm64);
+                    FileClassifier.Shared.RegisterFrameworkLocations(p =>
+                        initialPropertiesClone.GetProperty(p)?.EvaluatedValue);
 
                     if (toolset != null)
                     {
@@ -436,28 +428,6 @@ private void ReadEachToolset(
                     }
                 }
             }
-
-            string existingRootOrNull(string path)
-            {
-                if (!string.IsNullOrEmpty(path))
-                {
-                    try
-                    {
-                        path = Directory.GetParent(FileUtilities.EnsureNoTrailingSlash(path))?.FullName;
-
-                        if (!Directory.Exists(path))
-                        {
-                            path = null;
-                        }
-                    }
-                    catch
-                    {
-                        path = null;
-                    }
-                }
-
-                return path;
-            }
         }
 
         /// <summary>
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 71f51e9f272..cfa910da6a8 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using Microsoft.NET.StringTools;
 
 #nullable disable
 
@@ -23,11 +24,6 @@ namespace Microsoft.Build.Construction
     /// </remarks>
     internal class XmlDocumentWithLocation : XmlDocument
     {
-        /// <summary>
-        /// Used to cache strings used in attribute values and comments.
-        /// </summary>
-        private static ProjectStringCache s_globalStringCache = new ProjectStringCache();
-
         /// <summary>
         /// Used to cache tag names in loaded files.
         /// </summary>
@@ -49,11 +45,6 @@ internal class XmlDocumentWithLocation : XmlDocument
         /// </summary>
         private string _fullPath;
 
-        /// <summary>
-        /// Local cache of strings for attribute values and comments. Used for testing.
-        /// </summary>
-        private ProjectStringCache _stringCache;
-
         /// <summary>
         /// Whether we can expect to never save this file.
         /// In such a case, we can discard as much as possible on load, like comments and whitespace.
@@ -124,19 +115,6 @@ internal string FullPath
             set { _fullPath = value; }
         }
 
-        /// <summary>
-        /// Sets or gets the string cache used by this XmlDocument.
-        /// </summary>
-        /// <remarks>
-        /// When a particular instance has not been set will use the global string cache. The ability
-        /// to use a particular instance is useful for tests.
-        /// </remarks>
-        internal ProjectStringCache StringCache
-        {
-            get { return _stringCache ?? s_globalStringCache; }
-            set { _stringCache = value; }
-        }
-
         /// <summary>
         /// Loads from an XmlReader, intercepting the reader.
         /// </summary>
@@ -262,7 +240,7 @@ public override XmlWhitespace CreateWhitespace(string text)
                 text = String.Empty;
             }
 
-            string interned = StringCache.Add(text, this);
+            string interned = Strings.WeakIntern(text);
             return base.CreateWhitespace(interned);
         }
 
@@ -278,7 +256,7 @@ public override XmlSignificantWhitespace CreateSignificantWhitespace(string text
                 text = String.Empty;
             }
 
-            string interned = StringCache.Add(text, this);
+            string interned = Strings.WeakIntern(text);
             return base.CreateSignificantWhitespace(interned);
         }
 
@@ -288,7 +266,7 @@ public override XmlSignificantWhitespace CreateSignificantWhitespace(string text
         /// </summary>
         public override XmlText CreateTextNode(string text)
         {
-            string textNode = StringCache.Add(text, this);
+            string textNode = Strings.WeakIntern(text);
             return base.CreateTextNode(textNode);
         }
 
@@ -303,7 +281,7 @@ public override XmlComment CreateComment(string data)
                 data = String.Empty;
             }
 
-            string interned = StringCache.Add(data, this);
+            string interned = Strings.WeakIntern(data);
             return base.CreateComment(interned);
         }
 
@@ -356,16 +334,6 @@ internal static void ClearReadOnlyFlags_UnitTestsOnly()
             s_readOnlyFlags = ReadOnlyLoadFlags.Undefined;
         }
 
-        /// <summary>
-        /// Called when the XmlDocument is unloaded to remove this XML's
-        /// contribution to the string interning cache.
-        /// Does NOT zombie the ProjectRootElement or anything else.
-        /// </summary>
-        internal void ClearAnyCachedStrings()
-        {
-            StringCache.Clear(this);
-        }
-
         /// <summary>
         /// Determine whether we should load this file read only.
         /// We decide yes if it is in program files or the OS directory, and the file name starts with "microsoft", else no.
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index b82733a9d8e..064ea77a49d 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -333,7 +333,26 @@ internal static void Evaluate(
                 loggingService,
                 buildEventContext);
 
-            evaluator.Evaluate();
+            try
+            {
+                evaluator.Evaluate();
+            }
+            finally
+            {
+                IEnumerable globalProperties = null;
+                IEnumerable properties = null;
+                IEnumerable items = null;
+
+                if (evaluator._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
+                {
+                    globalProperties = evaluator._data.GlobalPropertiesDictionary;
+                    properties = Traits.LogAllEnvironmentVariables ? evaluator._data.Properties : evaluator.FilterOutEnvironmentDerivedProperties(evaluator._data.Properties);
+                    items = evaluator._data.Items;
+                }
+
+                evaluator._evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, evaluator._evaluationProfiler.ProfiledResult);
+            }
+
             MSBuildEventSource.Log.EvaluateStop(root.ProjectFileLocation.File);
         }
 
@@ -595,11 +614,15 @@ private static ProjectTargetInstance ReadNewTargetElement(ProjectTargetElement t
         private void Evaluate()
         {
             string projectFile = String.IsNullOrEmpty(_projectRootElement.ProjectFileLocation.File) ? "(null)" : _projectRootElement.ProjectFileLocation.File;
-            using (AssemblyLoadsTracker.StartTracking(_evaluationLoggingContext, AssemblyLoadingContext.Evaluation))
             using (_evaluationProfiler.TrackPass(EvaluationPass.TotalEvaluation))
             {
                 ErrorUtilities.VerifyThrow(_data.EvaluationId == BuildEventContext.InvalidEvaluationId, "There is no prior evaluation ID. The evaluator data needs to be reset at this point");
                 _data.EvaluationId = _evaluationLoggingContext.BuildEventContext.EvaluationId;
+                _evaluationLoggingContext.LogProjectEvaluationStarted();
+
+                // Track loads only after start of evaluation was actually logged
+                using var assemblyLoadsTracker =
+                    AssemblyLoadsTracker.StartTracking(_evaluationLoggingContext, AssemblyLoadingContext.Evaluation);
 
                 _logProjectImportedEvents = Traits.Instance.EscapeHatches.LogProjectImports;
 
@@ -621,8 +644,6 @@ private void Evaluate()
                     }
                 }
 
-                _evaluationLoggingContext.LogProjectEvaluationStarted();
-
                 ErrorUtilities.VerifyThrow(_data.EvaluationId != BuildEventContext.InvalidEvaluationId, "Evaluation should produce an evaluation ID");
 
                 MSBuildEventSource.Log.EvaluatePass0Stop(projectFile);
@@ -798,19 +819,6 @@ private void Evaluate()
             }
 
             ErrorUtilities.VerifyThrow(_evaluationProfiler.IsEmpty(), "Evaluation profiler stack is not empty.");
-
-            IEnumerable globalProperties = null;
-            IEnumerable properties = null;
-            IEnumerable items = null;
-
-            if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
-            {
-                globalProperties = _data.GlobalPropertiesDictionary;
-                properties = Traits.LogAllEnvironmentVariables ? _data.Properties : FilterOutEnvironmentDerivedProperties(_data.Properties);
-                items = _data.Items;
-            }
-
-            _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
         private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary<P> dictionary)
@@ -1199,7 +1207,7 @@ private void AddToolsetProperties()
         {
             foreach (ProjectPropertyInstance toolsetProperty in _data.Toolset.Properties.Values)
             {
-                _data.SetProperty(toolsetProperty.Name, ((IProperty)toolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
+                _data.SetProperty(toolsetProperty.Name, ((IProperty)toolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */, loggingContext: _evaluationLoggingContext);
             }
 
             if (_data.SubToolsetVersion == null)
@@ -1208,7 +1216,7 @@ private void AddToolsetProperties()
                 // is most likely not a subtoolset now, we need to add VisualStudioVersion if its not already a property.
                 if (!_data.Properties.Contains(Constants.VisualStudioVersionPropertyName))
                 {
-                    _data.SetProperty(Constants.VisualStudioVersionPropertyName, MSBuildConstants.CurrentVisualStudioVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
+                    _data.SetProperty(Constants.VisualStudioVersionPropertyName, MSBuildConstants.CurrentVisualStudioVersion, false /* NOT global property */, false /* may NOT be a reserved name */, loggingContext: _evaluationLoggingContext);
                 }
             }
             else
@@ -1218,14 +1226,14 @@ private void AddToolsetProperties()
                 // set the property even if there is no matching sub-toolset.
                 if (!_data.Properties.Contains(Constants.SubToolsetVersionPropertyName))
                 {
-                    _data.SetProperty(Constants.SubToolsetVersionPropertyName, _data.SubToolsetVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
+                    _data.SetProperty(Constants.SubToolsetVersionPropertyName, _data.SubToolsetVersion, false /* NOT global property */, false /* may NOT be a reserved name */, loggingContext: _evaluationLoggingContext);
                 }
 
                 if (_data.Toolset.SubToolsets.TryGetValue(_data.SubToolsetVersion, out SubToolset subToolset))
                 {
                     foreach (ProjectPropertyInstance subToolsetProperty in subToolset.Properties.Values)
                     {
-                        _data.SetProperty(subToolsetProperty.Name, ((IProperty)subToolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
+                        _data.SetProperty(subToolsetProperty.Name, ((IProperty)subToolsetProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */, loggingContext: _evaluationLoggingContext);
                     }
                 }
             }
@@ -1243,7 +1251,7 @@ private int AddGlobalProperties()
 
             foreach (ProjectPropertyInstance globalProperty in _data.GlobalPropertiesDictionary)
             {
-                _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */);
+                _data.SetProperty(globalProperty.Name, ((IProperty)globalProperty).EvaluatedValueEscaped, true /* IS global property */, false /* may NOT be a reserved name */, loggingContext: _evaluationLoggingContext);
             }
 
             return _data.GlobalPropertiesDictionary.Count;
@@ -1257,7 +1265,7 @@ private int AddGlobalProperties()
         /// </summary>
         private P SetBuiltInProperty(string name, string evaluatedValueEscaped)
         {
-            P property = _data.SetProperty(name, evaluatedValueEscaped, false /* NOT global property */, true /* OK to be a reserved name */);
+            P property = _data.SetProperty(name, evaluatedValueEscaped, false /* NOT global property */, true /* OK to be a reserved name */, loggingContext: _evaluationLoggingContext);
             return property;
         }
 
@@ -1295,7 +1303,7 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
 
                 _expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(propertyElement, evaluatedValue, _evaluationLoggingContext);
 
-                _data.SetProperty(propertyElement, evaluatedValue);
+                _data.SetProperty(propertyElement, evaluatedValue, _evaluationLoggingContext);
             }
         }
 
@@ -1588,7 +1596,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
                 if (!_fallbackSearchPathsCache.DirectoryExists(extensionPathExpanded))
                 {
                     // Set to log an error only if the change wave is enabled.
-                    missingDirectoryDespiteTrueCondition = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && !containsWildcards;
+                    missingDirectoryDespiteTrueCondition = !containsWildcards;
                     continue;
                 }
 
@@ -2562,7 +2570,8 @@ private void SetAllProjectsProperty()
                         ? $"{_lastModifiedProject.FullPath}{streamImports}"
                         : $"{_lastModifiedProject.FullPath}{streamImports};{oldValue.EvaluatedValue}",
                     isGlobalProperty: false,
-                    mayBeReserved: false);
+                    mayBeReserved: false,
+                    loggingContext: _evaluationLoggingContext);
             }
         }
 
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index c64d877596a..6d2b14dfdc6 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -340,7 +340,7 @@ internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem, Loggi
         /// Properties may be null.
         ///
         /// Used for tests and for ToolsetReader - that operates agnostic on the project
-        ///   - so no logging context is passed, and no BuildCheck analysis will be executed.
+        ///   - so no logging context is passed, and no BuildCheck check will be executed.
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
         : this(properties, fileSystem, null)
@@ -394,9 +394,9 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMeta
         /// Any or all may be null.
         ///
         /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
-        ///  - BuildCheck analysis won't be executed for those.
+        ///  - BuildCheck checking won't be executed for those.
         /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
-        /// 
+        ///
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem)
             : this(properties, items, fileSystem, null)
@@ -1558,7 +1558,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                                    MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7);
 
                 propertiesUseTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtifical);
-                
+
                 if (isArtifical)
                 {
                     // It could be one of the MSBuildThisFileXXXX properties,
@@ -1583,7 +1583,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                         environmentDerivedProperty.loggingContext = propertiesUseTracker.LoggingContext;
                     }
 
-                    propertyValue = property.EvaluatedValueEscaped;
+                    propertyValue = property.GetEvaluatedValueEscaped(elementLocation);
                 }
 
                 return propertyValue;
@@ -1654,9 +1654,8 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
             {
 #if RUNTIME_TYPE_NETCORE
                 // .NET Core MSBuild used to always return empty, so match that behavior
-                // on non-Windows (no registry), and with a changewave (in case someone
-                // had a registry property and it breaks when it lights up).
-                if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                // on non-Windows (no registry).
+                if (!NativeMethodsShared.IsWindows)
                 {
                     return string.Empty;
                 }
@@ -2017,8 +2016,7 @@ internal static bool ExpandExpressionCapture<S>(
                     if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)) != true)
                     {
                         // ...or a function "AnyHaveMetadataValue", since that will want to return false for an empty list.
-                        if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
-                            expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
+                        if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
                         {
                             itemsFromCapture = new List<KeyValuePair<string, S>>();
                             return false;
@@ -3571,8 +3569,14 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         try
                         {
                             // First attempt to recognize some well-known functions to avoid binding
-                            // and potential first-chance MissingMethodExceptions
+                            // and potential first-chance MissingMethodExceptions.
                             wellKnownFunctionSuccess = TryExecuteWellKnownFunction(out functionResult, objectInstance, args);
+
+                            if (!wellKnownFunctionSuccess)
+                            {
+                                // Some well-known functions need evaluated value from properties.
+                                wellKnownFunctionSuccess = TryExecuteWellKnownFunctionWithPropertiesParam(properties, out functionResult, objectInstance, args);
+                            }
                         }
                         // we need to preserve the same behavior on exceptions as the actual binder
                         catch (Exception ex)
@@ -3669,6 +3673,27 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                 }
             }
 
+            private bool TryExecuteWellKnownFunctionWithPropertiesParam(IPropertyProvider<T> properties, out object returnVal, object objectInstance, object[] args)
+            {
+                returnVal = null;
+
+                if (_receiverType == typeof(IntrinsicFunctions))
+                {
+                    if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
+                    {
+                        string projectPath = properties.GetProperty("MSBuildProjectFullPath")?.EvaluatedValue ?? string.Empty;
+                        ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
+                        if (TryGetArg(args, out string arg0))
+                        {
+                            returnVal = IntrinsicFunctions.RegisterBuildCheck(projectPath, arg0, _loggingContext);
+                            return true;
+                        }
+                    }
+                }
+
+                return false;
+            }
+
             /// <summary>
             /// Shortcut to avoid calling into binding if we recognize some most common functions.
             /// Binding is expensive and throws first-chance MissingMethodExceptions, which is
@@ -3864,6 +3889,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             return true;
                         }
                     }
+                    else if (string.Equals(_methodMethodName, nameof(string.Equals), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (TryGetArg(args, out string arg0))
+                        {
+                            returnVal = text.Equals(arg0);
+                            return true;
+                        }
+                    }
                 }
                 else if (objectInstance is string[] stringArray)
                 {
@@ -3926,16 +3959,6 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                     }
                     else if (_receiverType == typeof(IntrinsicFunctions))
                     {
-                        if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterBuildCheck), StringComparison.OrdinalIgnoreCase))
-                        {
-                            ErrorUtilities.VerifyThrow(_loggingContext != null, $"The logging context is missed. {nameof(IntrinsicFunctions.RegisterBuildCheck)} can not be invoked.");
-                            if (TryGetArg(args, out string arg0))
-                            {
-                                returnVal = IntrinsicFunctions.RegisterBuildCheck(arg0, _loggingContext);
-                                return true;
-                            }
-                        }
-
                         if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.EnsureTrailingSlash), StringComparison.OrdinalIgnoreCase))
                         {
                             if (TryGetArg(args, out string arg0))
@@ -4310,6 +4333,22 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.NormalizeDirectory), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.NormalizeDirectory(arg0);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.IsOSPlatform), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = IntrinsicFunctions.IsOSPlatform(arg0);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Path))
                     {
@@ -4407,6 +4446,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                                 return true;
                             }
                         }
+                        else if (string.Equals(_methodMethodName, nameof(Path.GetFileNameWithoutExtension), StringComparison.OrdinalIgnoreCase))
+                        {
+                            if (TryGetArg(args, out string arg0))
+                            {
+                                returnVal = Path.GetFileNameWithoutExtension(arg0);
+                                return true;
+                            }
+                        }
                     }
                     else if (_receiverType == typeof(Version))
                     {
@@ -4419,7 +4466,7 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             }
                         }
                     }
-                    else if (_receiverType == typeof(System.Guid))
+                    else if (_receiverType == typeof(Guid))
                     {
                         if (string.Equals(_methodMethodName, nameof(Guid.NewGuid), StringComparison.OrdinalIgnoreCase))
                         {
@@ -4430,8 +4477,31 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             }
                         }
                     }
+                    else if (string.Equals(_methodMethodName, nameof(Regex.Replace), StringComparison.OrdinalIgnoreCase) && args.Length == 3)
+                    {
+                        if (TryGetArg([args[0]], out string arg1) && TryGetArg([args[1]], out string arg2) && TryGetArg([args[2]], out string arg3))
+                        {
+                            returnVal = Regex.Replace(arg1, arg2, arg3);
+                            return true;
+                        }
+                    }
+                }
+                else if (string.Equals(_methodMethodName, nameof(Version.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is Version v)
+                {
+                    if (TryGetArg(args, out int arg0))
+                    {
+                        returnVal = v.ToString(arg0);
+                        return true;
+                    }
+                }
+                else if (string.Equals(_methodMethodName, nameof(Int32.ToString), StringComparison.OrdinalIgnoreCase) && objectInstance is int i)
+                {
+                    if (TryGetArg(args, out string arg0))
+                    {
+                        returnVal = i.ToString(arg0);
+                        return true;
+                    }
                 }
-
                 if (Traits.Instance.LogPropertyFunctionsRequiringReflection)
                 {
                     LogFunctionCall("PropertyFunctionsRequiringReflection", objectInstance, args);
@@ -4872,13 +4942,10 @@ private static bool TryExecuteArithmeticOverload(object[] args, Func<long, long,
                     return false;
                 }
 
-                if (IntrinsicFunctionOverload.IsIntrinsicFunctionOverloadsEnabled())
+                if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
                 {
-                    if (TryConvertToLong(args[0], out long argLong0) && TryConvertToLong(args[1], out long argLong1))
-                    {
-                        resultValue = integerOperation(argLong0, argLong1);
-                        return true;
-                    }
+                    resultValue = integerOperation(argLong0, argLong1);
+                    return true;
                 }
 
                 if (TryConvertToDouble(args[0], out double argDouble0) && TryConvertToDouble(args[1], out double argDouble1))
@@ -5510,17 +5577,11 @@ internal static class IntrinsicFunctionOverload
         // For reuse, the comparer is cached in a non-generic type.
         // Both comparer instances can be cached to support change wave testing.
         private static IComparer<MemberInfo>? s_comparerLongBeforeDouble;
-        private static IComparer<MemberInfo>? s_comparerDoubleBeforeLong;
 
-        internal static IComparer<MemberInfo> IntrinsicFunctionOverloadMethodComparer => IsIntrinsicFunctionOverloadsEnabled() ? LongBeforeDoubleComparer : DoubleBeforeLongComparer;
+        internal static IComparer<MemberInfo> IntrinsicFunctionOverloadMethodComparer => LongBeforeDoubleComparer;
 
         private static IComparer<MemberInfo> LongBeforeDoubleComparer => s_comparerLongBeforeDouble ??= Comparer<MemberInfo>.Create((key0, key1) => SelectTypeOfFirstParameter(key0).CompareTo(SelectTypeOfFirstParameter(key1)));
 
-        private static IComparer<MemberInfo> DoubleBeforeLongComparer => s_comparerDoubleBeforeLong ??= Comparer<MemberInfo>.Create((key0, key1) => SelectTypeOfFirstParameter(key1).CompareTo(SelectTypeOfFirstParameter(key0)));
-
-        // The arithmetic overload feature uses this method to test for the change wave.
-        internal static bool IsIntrinsicFunctionOverloadsEnabled() => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8);
-
         internal static bool IsKnownOverloadMethodName(string methodName) => s_knownOverloadName.Any(name => string.Equals(name, methodName, StringComparison.OrdinalIgnoreCase));
 
         private static TypeCode SelectTypeOfFirstParameter(MemberInfo member)
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 12d42a71ea9..212f446d70f 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -268,12 +268,12 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, BackEnd.Logging.LoggingContext loggingContext, bool isEnvironmentVariable = false);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
         /// </summary>
-        P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped);
+        P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, BackEnd.Logging.LoggingContext loggingContext);
 
         /// <summary>
         /// Retrieves an existing target, if any.
diff --git a/src/Build/Evaluation/IProperty.cs b/src/Build/Evaluation/IProperty.cs
index da311eb95dc..d20249ce349 100644
--- a/src/Build/Evaluation/IProperty.cs
+++ b/src/Build/Evaluation/IProperty.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -13,7 +14,7 @@ namespace Microsoft.Build.Evaluation
     internal interface IProperty : IKeyed
     {
         /// <summary>
-        /// Name of the property
+        /// Name of the property.
         /// </summary>
         string Name
         {
@@ -29,11 +30,24 @@ string EvaluatedValue
         }
 
         /// <summary>
-        /// Returns the evaluated, escaped value for the property
+        /// Returns the evaluated, escaped value for the property.
         /// </summary>
         string EvaluatedValueEscaped
         {
             get;
         }
+
+        /// <summary>
+        /// Returns the evaluated, escaped value for the property and sets up the property location if it is available.
+        /// </summary>
+        string GetEvaluatedValueEscaped(IElementLocation location);
+
+        /// <summary>
+        /// Returns property location in xml file. Can be empty.
+        /// </summary>
+        (string File, int Line, int Column) Location
+        {
+            get;
+        }
     }
 }
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 17e67ce123a..4a4a183d24f 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -191,9 +191,8 @@ internal static object GetRegistryValue(string keyName, string valueName)
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return null;
             }
@@ -208,9 +207,8 @@ internal static object GetRegistryValue(string keyName, string valueName, object
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return defaultValue;
             }
@@ -222,9 +220,8 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return defaultValue;
             }
@@ -245,9 +242,8 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
         {
 #if RUNTIME_TYPE_NETCORE
             // .NET Core MSBuild used to always return empty, so match that behavior
-            // on non-Windows (no registry), and with a changewave (in case someone
-            // had a registry property and it breaks when it lights up).
-            if (!NativeMethodsShared.IsWindows || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // on non-Windows (no registry).
+            if (!NativeMethodsShared.IsWindows)
             {
                 return defaultValue;
             }
@@ -697,17 +693,17 @@ public static string GetMSBuildExtensionsPath()
 
         public static bool IsRunningFromVisualStudio() => BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio;
 
-        public static bool RegisterBuildCheck(string pathToAssembly, LoggingContext loggingContext)
+        public static bool RegisterBuildCheck(string projectPath, string pathToAssembly, LoggingContext loggingContext)
         {
             pathToAssembly = FileUtilities.GetFullPathNoThrow(pathToAssembly);
             if (File.Exists(pathToAssembly))
             {
-                loggingContext.LogBuildEvent(new BuildCheckAcquisitionEventArgs(pathToAssembly));
+                loggingContext.LogBuildEvent(new BuildCheckAcquisitionEventArgs(pathToAssembly, projectPath));
 
                 return true;
             }
 
-            loggingContext.LogComment(MessageImportance.Low, "CustomAnalyzerAssemblyNotExist", pathToAssembly);
+            loggingContext.LogComment(MessageImportance.Low, "CustomCheckAssemblyNotExist", pathToAssembly);
 
             return false;
         }
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index e9b381b5aa1..ce2c28494ff 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -569,7 +569,9 @@ public override IEnumerable<string> GetReferencedItems()
     /// </summary>
     /// <typeparam name="P">Property type</typeparam>
     /// <typeparam name="I">Item type</typeparam>
-    internal sealed class MetadataTrie<P, I> where P : class, IProperty where I : class, IItem, IMetadataTable
+    internal sealed class MetadataTrie<P, I>
+        where P : class, IProperty
+        where I : class, IItem, IMetadataTable
     {
         private readonly Dictionary<string, MetadataTrie<P, I>> _children;
         private readonly Func<string, string> _normalize;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 248945f74fd..5d749befd8d 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -306,12 +306,12 @@ public void RecordImportWithDuplicates(ProjectImportElement importElement, Proje
                 _wrappedData.RecordImportWithDuplicates(importElement, import, versionEvaluated);
             }
 
-            public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
+            public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, BackEnd.Logging.LoggingContext loggingContext)
             {
-                return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped);
+                return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped, loggingContext);
             }
 
-            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext loggingContext = null)
+            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false)
             {
                 return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext);
             }
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 5de3520dab8..5ad09b27116 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -629,13 +629,10 @@ private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation el
                         {
                             ProjectErrorUtilities.ThrowInvalidProject(onError.Location, "NodeMustBeLastUnderElement", XMakeElements.onError, XMakeElements.target, childElement.Name);
                         }
-                        if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+                        if (childElement.ChildNodes.Count == 1 && childElement.FirstChild.NodeType == XmlNodeType.Text)
                         {
-                            if (childElement.ChildNodes.Count == 1 && childElement.FirstChild.NodeType == XmlNodeType.Text)
-                            {
-                                // If the element has inner text and no other child elements except text, then this should be a property and throw invalid child element of <Target>
-                                ProjectErrorUtilities.ThrowInvalidProject(childElement.Location, "PropertyOutsidePropertyGroupInTarget", childElement.Name, childElement.ParentNode.Name);
-                            }
+                            // If the element has inner text and no other child elements except text, then this should be a property and throw invalid child element of <Target>
+                            ProjectErrorUtilities.ThrowInvalidProject(childElement.Location, "PropertyOutsidePropertyGroupInTarget", childElement.Name, childElement.ParentNode.Name);
                         }
 
                         child = ParseProjectTaskElement(childElement, target);
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 143587d96ee..97c925a0327 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -438,14 +438,8 @@ internal override void DiscardStrongReferences()
             {
                 DebugTraceCache("Clearing strong refs: ", _strongCache.Count);
 
-                LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
                 _strongCache = new LinkedList<ProjectRootElement>();
 
-                foreach (ProjectRootElement projectRootElement in oldStrongCache)
-                {
-                    RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
-                }
-
                 // A scavenge of the weak cache is probably not worth it as
                 // the GC would have had to run immediately after the line above.
             }
@@ -459,45 +453,8 @@ internal override void Clear()
         {
             lock (_locker)
             {
-                if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)
-                {
-                    LinkedList<ProjectRootElement> oldStrongCache = _strongCache;
-                    _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
-                    _strongCache = new LinkedList<ProjectRootElement>();
-
-                    foreach (ProjectRootElement projectRootElement in oldStrongCache)
-                    {
-                        RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
-                    }
-                }
-                else
-                {
-                    // Manually iterate through LinkedList so we can remove items during this iteration
-                    for (var listNode = _strongCache.First; listNode != null;)
-                    {
-                        var nextNode = listNode.Next;
-
-                        ProjectRootElement projectRootElement = listNode.Value;
-                        // Do not remove cache of files from immutable locations.
-                        // Those are mostly SDK project files and will be most probably needed in next builds.
-                        if (!FileClassifier.Shared.IsNonModifiable(projectRootElement.FullPath))
-                        {
-                            _weakCache.Remove(projectRootElement.FullPath);
-                            _strongCache.Remove(listNode);
-                            RaiseProjectRootElementRemovedFromStrongCache(projectRootElement);
-                        }
-
-                        listNode = nextNode;
-                    }
-
-                    // From weak list remove all which is not in strong list anymore
-                    IList<string> toBeRemovedFromWeakRefs = _weakCache.Keys.Except(_strongCache.Select(i => i.FullPath)).ToList();
-                    foreach (string victim in toBeRemovedFromWeakRefs)
-                    {
-                        _weakCache.Remove(victim);
-                    }
-                    _weakCache.Scavenge();
-                }
+                _weakCache = new WeakValueDictionary<string, ProjectRootElement>(StringComparer.OrdinalIgnoreCase);
+                _strongCache = new LinkedList<ProjectRootElement>();
             }
         }
 
@@ -540,10 +497,6 @@ internal override void DiscardImplicitReferences()
                         {
                             _strongCache.AddFirst(kvp.Value);
                         }
-                        else
-                        {
-                            RaiseProjectRootElementRemovedFromStrongCache(kvp.Value);
-                        }
                     }
                 }
             }
@@ -608,7 +561,6 @@ private void RenameEntryInternal(string oldFullPathIfAny, ProjectRootElement pro
             if (existingWeakEntry != null && !object.ReferenceEquals(existingWeakEntry, projectRootElement))
             {
                 _strongCache.Remove(existingWeakEntry);
-                RaiseProjectRootElementRemovedFromStrongCache(existingWeakEntry);
             }
 
             DebugTraceCache("Adding: ", projectRootElement.FullPath);
@@ -654,7 +606,6 @@ private void BoostEntryInStrongCache(ProjectRootElement projectRootElement)
 
                 DebugTraceCache("Shedding: ", node.Value.FullPath);
                 _strongCache.Remove(node);
-                RaiseProjectRootElementRemovedFromStrongCache(node.Value);
             }
         }
 
@@ -674,7 +625,6 @@ private void ForgetEntry(ProjectRootElement projectRootElement)
             if (strongCacheEntry != null)
             {
                 _strongCache.Remove(strongCacheEntry);
-                RaiseProjectRootElementRemovedFromStrongCache(strongCacheEntry.Value);
             }
 
             DebugTraceCache("Out of date dropped from XML cache: ", projectRootElement.FullPath);
diff --git a/src/Build/Evaluation/ProjectRootElementCacheBase.cs b/src/Build/Evaluation/ProjectRootElementCacheBase.cs
index 97857fa0b6e..bc8823398b5 100644
--- a/src/Build/Evaluation/ProjectRootElementCacheBase.cs
+++ b/src/Build/Evaluation/ProjectRootElementCacheBase.cs
@@ -27,11 +27,6 @@ internal abstract class ProjectRootElementCacheBase
         /// </summary>
         internal delegate ProjectRootElement OpenProjectRootElement(string path, ProjectRootElementCacheBase cache);
 
-        /// <summary>
-        /// Event that is fired when an entry in the Strong Cache is removed.
-        /// </summary>
-        internal static event StrongCacheEntryRemovedDelegate StrongCacheEntryRemoved;
-
         /// <summary>
         /// Event which is fired when a project root element is added to this cache.
         /// </summary>
@@ -96,15 +91,6 @@ protected void RaiseProjectRootElementAddedToCacheEvent(ProjectRootElement rootE
         {
             ProjectRootElementAddedHandler?.Invoke(this, new ProjectRootElementCacheAddEntryEventArgs(rootElement));
         }
-
-        /// <summary>
-        /// Raises an event which is raised when a project root element is removed from the strong cache.
-        /// </summary>
-        protected virtual void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement)
-        {
-            StrongCacheEntryRemovedDelegate removedEvent = StrongCacheEntryRemoved;
-            removedEvent?.Invoke(this, projectRootElement);
-        }
     }
 
     /// <summary>
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
deleted file mode 100644
index 7753ae7e5a5..00000000000
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ /dev/null
@@ -1,320 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Xml;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-
-#nullable disable
-
-namespace Microsoft.Build.Construction
-{
-    /// <summary>
-    /// This class will cache string values for loaded Xml files.
-    /// </summary>
-    [DebuggerDisplay("#Strings={Count} #Documents={_documents.Count}")]
-    internal class ProjectStringCache
-    {
-        /// <summary>
-        /// Start off with a large size as there are very many strings in common scenarios and resizing is expensive.
-        /// Note that there is a single instance of this cache for the lifetime of the process (albeit cleared out on XML unload)
-        /// Australian Govt has about 3000 strings; a single VC project with all its various XML files has about 4000 strings.
-        /// </summary>
-        private const int InitialSize = 5000;
-
-        /// <summary>
-        /// Store interned strings, and also a ref count, one per document using them.
-        /// </summary>
-        private RetrievableEntryHashSet<StringCacheEntry> _strings = new RetrievableEntryHashSet<StringCacheEntry>(InitialSize, StringComparer.Ordinal);
-
-        /// <summary>
-        /// Store all the strings a document is using, so their ref count can be decremented.
-        /// </summary>
-        private Dictionary<XmlDocument, HashSet<StringCacheEntry>> _documents = new Dictionary<XmlDocument, HashSet<StringCacheEntry>>();
-
-        /// <summary>
-        /// Locking object for this shared cache
-        /// </summary>
-        private Object _locker = new Object();
-
-        /// <summary>
-        /// Public constructor.
-        /// </summary>
-        public ProjectStringCache()
-        {
-            ProjectRootElementCacheBase.StrongCacheEntryRemoved += OnStrongCacheEntryRemoved;
-        }
-
-        /// <summary>
-        /// Obtain the number of entries contained in the cache.
-        /// </summary>
-        internal int Count
-        {
-            get
-            {
-                lock (_locker)
-                {
-                    return _strings.Count;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Obtain the number of documents contained in the cache.
-        /// </summary>
-        internal int DocumentCount
-        {
-            get
-            {
-                lock (_locker)
-                {
-                    return _documents.Count;
-                }
-            }
-        }
-
-        /// <summary>
-        /// Add the given string to the cache or return the existing string if it is already
-        /// in the cache.
-        /// Constant time operation.
-        /// </summary>
-        public string Add(string key, XmlDocument document)
-        {
-            // Remove string interning in ChangeWave 17.6
-            // Note: When ready to remove the ChangeWaves under 17.6, please delete this entire class and all references to it. (See the PR https://github.com/dotnet/msbuild/pull/7952).
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
-            {
-                return key;
-            }
-
-            if (key.Length == 0)
-            {
-                return String.Empty;
-            }
-
-            // see Microsoft.Build.BackEnd.BuildRequestConfiguration.CreateUniqueGlobalProperty
-            if (key.StartsWith(MSBuildConstants.MSBuildDummyGlobalPropertyHeader, StringComparison.Ordinal))
-            {
-                return key;
-            }
-
-            lock (_locker)
-            {
-                VerifyState();
-
-                StringCacheEntry entry;
-                HashSet<StringCacheEntry> entries;
-
-                bool seenString = _strings.TryGetValue(key, out entry);
-                bool seenDocument = _documents.TryGetValue(document, out entries);
-
-                if (!seenString)
-                {
-                    entry = new StringCacheEntry(key);
-                    _strings.Add(entry);
-                }
-
-                if (!seenDocument)
-                {
-                    entries = new HashSet<StringCacheEntry>();
-                    _documents.Add(document, entries);
-                }
-
-                bool seenStringInThisDocument = seenString && seenDocument && entries.Contains(entry);
-
-                if (!seenStringInThisDocument)
-                {
-                    entries.Add(entry);
-
-                    // We've been referred to by a new document, so increment our ref count.
-                    entry.Increment();
-                }
-
-                VerifyState();
-
-                return entry.CachedString;
-            }
-        }
-
-        /// <summary>
-        /// Find the matching string in the cache.
-        /// Constant time operation.
-        /// </summary>
-        /// <param name="key">String to find in the cache.</param>
-        /// <returns>Existing string in the cache, or null if it is not contained.</returns>
-        public string Get(string key)
-        {
-            lock (_locker)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(key, nameof(key));
-
-                if (key.Length == 0)
-                {
-                    return String.Empty;
-                }
-
-                StringCacheEntry entry;
-                if (_strings.TryGetValue(key, out entry))
-                {
-                    return entry.CachedString;
-                }
-
-                return null;
-            }
-        }
-
-        /// <summary>
-        /// Indicates that a document's entries should be removed.
-        /// If document is unknown, does nothing.
-        /// Complexity proportional to the number of strings in the document,
-        /// if the document is anywhere in the cache, otherwise O(1).
-        /// </summary>
-        public void Clear(XmlDocument document)
-        {
-            lock (_locker)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(document, nameof(document));
-
-                VerifyState();
-
-                HashSet<StringCacheEntry> entries;
-                if (_documents.TryGetValue(document, out entries))
-                {
-                    foreach (var entry in entries)
-                    {
-                        string str = entry.CachedString;
-                        entry.Decrement();
-
-                        if (entry.RefCount == 0)
-                        {
-                            _strings.Remove(str);
-                        }
-                    }
-
-                    _documents.Remove(document);
-                }
-
-                VerifyState();
-            }
-        }
-
-        /// <summary>
-        /// Verifies that each string entry has only one instance in the system.
-        /// Enable the conditional if and while you make any modifications to the class, then disable as it is very slow.
-        /// </summary>
-        [Conditional("NEVER")]
-        private void VerifyState()
-        {
-            HashSet<StringCacheEntry> uniqueEntries = new HashSet<StringCacheEntry>();
-            foreach (var entries in _documents.Values)
-            {
-                foreach (var entry in entries)
-                {
-                    uniqueEntries.Add(entry);
-                    ErrorUtilities.VerifyThrow(entry.RefCount > 0, "extra deref");
-
-                    // We only ever create one StringCacheEntry instance per unique string, and that instance should be
-                    // the same in both collections.
-                    ErrorUtilities.VerifyThrow(Object.ReferenceEquals(entry, _strings[entry.CachedString]), "bad state");
-                }
-            }
-
-            ErrorUtilities.VerifyThrow(uniqueEntries.Count == _strings.Count, "bad state");
-        }
-
-        /// <summary>
-        /// Handle event that is fired when an entry in the project root element cache is removed
-        /// from its strong cache.
-        /// </summary>
-        /// <remarks>
-        /// When an entry is removed from a project root element cache's strong cache, we will remove
-        /// its entries from our string cache. Otherwise the string cache ends up being the only one
-        /// holding references to the Xml documents that have already been dropped.
-        /// </remarks>
-        private void OnStrongCacheEntryRemoved(object sender, ProjectRootElement projectRootElement)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
-            Clear(projectRootElement.XmlDocument);
-        }
-
-        /// <summary>
-        /// Represents an entry in the ProjectStringCache.
-        /// Can't be a struct because the copy-by-value and the ref counting don't go well together.
-        /// </summary>
-        [DebuggerDisplay("Count={_refCount} String={_cachedString}")]
-        private class StringCacheEntry : IKeyed
-        {
-            /// <summary>
-            /// Cached string
-            /// </summary>
-            private string _cachedString;
-
-            /// <summary>
-            /// Number of XmlDocuments where this string is included.
-            /// </summary>
-            private int _refCount;
-
-            /// <summary>
-            /// Constructor.
-            /// Caller must then do Increment().
-            /// </summary>
-            internal StringCacheEntry(string str)
-            {
-                _cachedString = str;
-                _refCount = 0;
-            }
-
-            /// <summary>
-            /// Key to find it
-            /// </summary>
-            public string Key
-            {
-                get { return _cachedString; }
-            }
-
-            /// <summary>
-            /// Number of documents using this string
-            /// </summary>
-            internal int RefCount
-            {
-                get { return _refCount; }
-            }
-
-            /// <summary>
-            /// Get the cached string.
-            /// </summary>
-            internal string CachedString
-            {
-                get
-                {
-                    ErrorUtilities.VerifyThrow(_refCount > 0, "extra deref");
-                    return _cachedString;
-                }
-            }
-
-            /// <summary>
-            /// Indicates that this entry is included in the given document.
-            /// Callers must verify that we were not already adreffed for this document.
-            /// </summary>
-            internal void Increment()
-            {
-                _refCount++;
-            }
-
-            /// <summary>
-            /// Removes a container for this entry.
-            /// Callers must verify that this was not already reffed and not subsequently dereffed.
-            /// </summary>
-            internal void Decrement()
-            {
-                ErrorUtilities.VerifyThrow(_refCount > 0, "extra deref");
-                _refCount--;
-            }
-        }
-    }
-}
diff --git a/src/Build/Evaluation/PropertiesUseTracker.cs b/src/Build/Evaluation/PropertiesUseTracker.cs
index b88423adff1..fefa8be1d24 100644
--- a/src/Build/Evaluation/PropertiesUseTracker.cs
+++ b/src/Build/Evaluation/PropertiesUseTracker.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -20,9 +21,9 @@ namespace Microsoft.Build.Evaluation;
 /// </summary>
 internal sealed class PropertiesUseTracker
 {
-    internal LoggingContext LoggingContext { get; init; }
+    internal LoggingContext? LoggingContext { get; init; }
 
-    public PropertiesUseTracker(LoggingContext loggingContext) => LoggingContext = loggingContext;
+    public PropertiesUseTracker(LoggingContext? loggingContext) => LoggingContext = loggingContext;
 
     /// <summary>
     /// Whether to warn when we set a property for the first time, after it was previously used.
@@ -38,7 +39,16 @@ internal sealed class PropertiesUseTracker
 
     internal void TrackRead(string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, bool isUninitialized, bool isArtificial)
     {
-        if (isArtificial || !isUninitialized)
+        if (isArtificial)
+        {
+            return;
+        }
+
+        // LoggingContext can be null e.g. for initial toolset resolving and reading - we'll miss those expansions in our tracking
+        LoggingContext?.ProcessPropertyRead(new PropertyReadInfo(propertyName, startIndex, endIndex,
+            elementLocation, isUninitialized, GetPropertyReadContext(propertyName, startIndex, endIndex)));
+
+        if (!isUninitialized)
         {
             return;
         }
@@ -64,6 +74,19 @@ internal void TrackRead(string propertyName, int startIndex, int endIndex, IElem
         }
     }
 
+    private PropertyReadContext GetPropertyReadContext(string propertyName, int startIndex, int endIndex)
+    {
+        if (PropertyReadContext == PropertyReadContext.PropertyEvaluation &&
+            !string.IsNullOrEmpty(CurrentlyEvaluatingPropertyElementName) &&
+            MSBuildNameIgnoreCaseComparer.Default.Equals(CurrentlyEvaluatingPropertyElementName, propertyName,
+                startIndex, endIndex - startIndex + 1))
+        {
+            return PropertyReadContext.PropertyEvaluationSelf;
+        }
+
+        return PropertyReadContext;
+    }
+
     internal void TryAdd(string propertyName, IElementLocation elementLocation)
     {
         if (_properties is null)
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 4b2cd613881..23630119bcb 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
@@ -86,16 +87,17 @@ public P GetProperty(string name, int startIndex, int endIndex)
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext? loggingContext = null)
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable = false)
         {
             P? originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, _evaluationLoggingContext);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, _evaluationLoggingContext, isEnvironmentVariable);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
                 null,
-                this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable));
+                this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable),
+                loggingContext);
 
             return newProperty;
         }
@@ -107,16 +109,17 @@ public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalPro
         /// project file, and whose conditions evaluated to true.
         /// If there are none above this is null.
         /// </summary>
-        public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
+        public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, LoggingContext loggingContext)
         {
             P? originalProperty = _wrapped.GetProperty(propertyElement.Name);
-            P newProperty = _wrapped.SetProperty(propertyElement, evaluatedValueEscaped);
+            P newProperty = _wrapped.SetProperty(propertyElement, evaluatedValueEscaped, loggingContext);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
                 propertyElement.Location,
-                PropertySource.Xml);
+                PropertySource.Xml,
+                loggingContext);
 
             return newProperty;
         }
@@ -213,7 +216,10 @@ private void TrackEnvironmentVariableRead(string name)
 
             var args = new EnvironmentVariableReadEventArgs(
                 name,
-                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentVariableRead", name));
+                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentVariableRead", name),
+                string.Empty,
+                0,
+                0);
             args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
 
             _evaluationLoggingContext.LogBuildEvent(args);
@@ -238,10 +244,17 @@ private void TrackUninitializedPropertyRead(string name)
             _evaluationLoggingContext.LogBuildEvent(args);
         }
 
-        private void TrackPropertyWrite(P? predecessor, P property, IElementLocation? location, PropertySource source)
+        private void TrackPropertyWrite(
+            P? predecessor,
+            P property,
+            IElementLocation? location,
+            PropertySource source,
+            LoggingContext loggingContext)
         {
             string name = property.Name;
 
+            loggingContext.ProcessPropertyWrite(new PropertyWriteInfo(property.Name, string.IsNullOrEmpty(property.EscapedValue), location));
+
             if (predecessor == null)
             {
                 // If this property had no previous value, then track an initial value.
diff --git a/src/Build/Evaluation/SimpleProjectRootElementCache.cs b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
index f359d3cbd07..e2a9d7d782e 100644
--- a/src/Build/Evaluation/SimpleProjectRootElementCache.cs
+++ b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
@@ -139,10 +139,5 @@ internal override void OnProjectDirtied(Project sender, ProjectChangedEventArgs
         {
             throw new NotImplementedException();
         }
-
-        protected override void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement)
-        {
-            throw new NotImplementedException();
-        }
     }
 }
diff --git a/src/Build/Graph/GraphBuildRequestData.cs b/src/Build/Graph/GraphBuildRequestData.cs
index c09a587b106..31e8cae7c7e 100644
--- a/src/Build/Graph/GraphBuildRequestData.cs
+++ b/src/Build/Graph/GraphBuildRequestData.cs
@@ -2,11 +2,13 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Linq;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Graph
 {
     public record GraphBuildOptions
@@ -20,7 +22,7 @@ public record GraphBuildOptions
     /// <summary>
     /// GraphBuildRequestData encapsulates all of the data needed to submit a graph build request.
     /// </summary>
-    public sealed class GraphBuildRequestData
+    public sealed class GraphBuildRequestData : BuildRequestData<GraphBuildRequestData, GraphBuildResult>
     {
         /// <summary>
         /// Constructs a GraphBuildRequestData for build requests based on a project graph.
@@ -38,7 +40,7 @@ public GraphBuildRequestData(ProjectGraph projectGraph, ICollection<string> targ
         /// <param name="projectGraph">The graph to build.</param>
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use, if any.  May be null.</param>
-        public GraphBuildRequestData(ProjectGraph projectGraph, ICollection<string> targetsToBuild, HostServices hostServices)
+        public GraphBuildRequestData(ProjectGraph projectGraph, ICollection<string> targetsToBuild, HostServices? hostServices)
             : this(projectGraph, targetsToBuild, hostServices, BuildRequestDataFlags.None)
         {
         }
@@ -50,7 +52,7 @@ public GraphBuildRequestData(ProjectGraph projectGraph, ICollection<string> targ
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use, if any.  May be null.</param>
         /// <param name="flags">Flags controlling this build request.</param>
-        public GraphBuildRequestData(ProjectGraph projectGraph, ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags)
+        public GraphBuildRequestData(ProjectGraph projectGraph, ICollection<string> targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags)
             : this(targetsToBuild, hostServices, flags)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectGraph, nameof(projectGraph));
@@ -65,7 +67,7 @@ public GraphBuildRequestData(ProjectGraph projectGraph, ICollection<string> targ
         /// <param name="globalProperties">The global properties which should be used during evaluation of the project.  Cannot be null.</param>
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use.  May be null.</param>
-        public GraphBuildRequestData(string projectFullPath, IDictionary<string, string> globalProperties, ICollection<string> targetsToBuild, HostServices hostServices)
+        public GraphBuildRequestData(string projectFullPath, IDictionary<string, string> globalProperties, ICollection<string> targetsToBuild, HostServices? hostServices)
             : this(new ProjectGraphEntryPoint(projectFullPath, globalProperties).AsEnumerable(), targetsToBuild, hostServices, BuildRequestDataFlags.None)
         {
         }
@@ -78,7 +80,7 @@ public GraphBuildRequestData(string projectFullPath, IDictionary<string, string>
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use.  May be null.</param>
         /// <param name="flags">The <see cref="BuildRequestDataFlags"/> to use.</param>
-        public GraphBuildRequestData(string projectFullPath, IDictionary<string, string> globalProperties, ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags)
+        public GraphBuildRequestData(string projectFullPath, IDictionary<string, string> globalProperties, ICollection<string> targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags)
             : this(new ProjectGraphEntryPoint(projectFullPath, globalProperties).AsEnumerable(), targetsToBuild, hostServices, flags)
         {
         }
@@ -99,7 +101,7 @@ public GraphBuildRequestData(ProjectGraphEntryPoint projectGraphEntryPoint, ICol
         /// <param name="projectGraphEntryPoint">The entry point to use in the build.</param>
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use, if any.  May be null.</param>
-        public GraphBuildRequestData(ProjectGraphEntryPoint projectGraphEntryPoint, ICollection<string> targetsToBuild, HostServices hostServices)
+        public GraphBuildRequestData(ProjectGraphEntryPoint projectGraphEntryPoint, ICollection<string> targetsToBuild, HostServices? hostServices)
             : this(projectGraphEntryPoint.AsEnumerable(), targetsToBuild, hostServices, BuildRequestDataFlags.None)
         {
         }
@@ -111,7 +113,7 @@ public GraphBuildRequestData(ProjectGraphEntryPoint projectGraphEntryPoint, ICol
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use, if any.  May be null.</param>
         /// <param name="flags">Flags controlling this build request.</param>
-        public GraphBuildRequestData(ProjectGraphEntryPoint projectGraphEntryPoint, ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags)
+        public GraphBuildRequestData(ProjectGraphEntryPoint projectGraphEntryPoint, ICollection<string> targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags)
             : this(projectGraphEntryPoint.AsEnumerable(), targetsToBuild, hostServices, flags)
         {
         }
@@ -132,7 +134,7 @@ public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEnt
         /// <param name="projectGraphEntryPoints">The entry points to use in the build.</param>
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use, if any.  May be null.</param>
-        public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection<string> targetsToBuild, HostServices hostServices)
+        public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection<string> targetsToBuild, HostServices? hostServices)
             : this(projectGraphEntryPoints, targetsToBuild, hostServices, BuildRequestDataFlags.None)
         {
         }
@@ -144,7 +146,7 @@ public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEnt
         /// <param name="targetsToBuild">The targets to build.</param>
         /// <param name="hostServices">The host services to use, if any.  May be null.</param>
         /// <param name="flags">Flags controlling this build request.</param>
-        public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags)
+        public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection<string> targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags)
             : this(targetsToBuild, hostServices, flags)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectGraphEntryPoints, nameof(projectGraphEntryPoints));
@@ -152,28 +154,21 @@ public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEnt
             ProjectGraphEntryPoints = projectGraphEntryPoints;
         }
 
-        public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, GraphBuildOptions graphBuildOptions)
+        public GraphBuildRequestData(IEnumerable<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection<string> targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags, GraphBuildOptions graphBuildOptions)
             : this(targetsToBuild, hostServices, flags, graphBuildOptions)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectGraphEntryPoints, nameof(projectGraphEntryPoints));
 
-            ProjectGraphEntryPoints = projectGraphEntryPoints;
+            ProjectGraphEntryPoints = projectGraphEntryPoints.ToList();
         }
 
         /// <summary>
         /// Common constructor.
         /// </summary>
-        private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, GraphBuildOptions graphBuildOptions = null)
+        private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices? hostServices, BuildRequestDataFlags flags, GraphBuildOptions? graphBuildOptions = null)
+        : base(targetsToBuild, flags, hostServices)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(targetsToBuild, nameof(targetsToBuild));
-            foreach (string targetName in targetsToBuild)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(targetName, "target");
-            }
-
-            HostServices = hostServices;
-            TargetNames = new List<string>(targetsToBuild);
-            Flags = flags;
+            base.Flags = flags;
             GraphBuildOptions = graphBuildOptions ?? new GraphBuildOptions();
         }
 
@@ -182,34 +177,77 @@ private GraphBuildRequestData(ICollection<string> targetsToBuild, HostServices h
         /// May be null.
         /// </summary>
         /// <value>The project graph.</value>
-        public ProjectGraph ProjectGraph { get; }
+        public ProjectGraph? ProjectGraph { get; }
 
         /// <summary>
         /// The project graph entry points.
         /// May be null.
         /// </summary>
         /// <value>The project graph entry points.</value>
-        public IEnumerable<ProjectGraphEntryPoint> ProjectGraphEntryPoints { get; }
+        public IEnumerable<ProjectGraphEntryPoint>? ProjectGraphEntryPoints { get; }
 
-        /// <summary>
-        /// The name of the targets to build.
-        /// </summary>
-        /// <value>An array of targets in the project to be built.</value>
-        public ICollection<string> TargetNames { get; }
+        internal override BuildSubmissionBase<GraphBuildRequestData, GraphBuildResult> CreateSubmission(BuildManager buildManager, int submissionId, GraphBuildRequestData requestData,
+            bool legacyThreadingSemantics) =>
+            new GraphBuildSubmission(buildManager, submissionId, requestData);
 
-        /// <summary>
-        /// Extra flags for this BuildRequest.
-        /// </summary>
-        public BuildRequestDataFlags Flags { get; }
+        public override IEnumerable<string> EntryProjectsFullPath
+        {
+            get
+            {
+                if (ProjectGraph != null)
+                {
+                    foreach (ProjectGraphNode entryPoint in ProjectGraph.EntryPointNodes)
+                    {
+                        yield return entryPoint.ProjectInstance.FullPath;
+                    }
+                }
+                else if (ProjectGraphEntryPoints != null)
+                {
+                    foreach (ProjectGraphEntryPoint entryPoint in ProjectGraphEntryPoints)
+                    {
+                        yield return entryPoint.ProjectFile;
+                    }
+                }
+            }
+        }
+
+        public override IReadOnlyDictionary<string, string?> GlobalPropertiesLookup
+        {
+            get
+            {
+                ProjectGraphNode? node = ProjectGraph?.EntryPointNodes.FirstOrDefault();
+                if (node != null)
+                {
+                    return node.ProjectInstance.GlobalProperties.AsReadOnly();
+                }
+
+                ProjectGraphEntryPoint? entryPoint = ProjectGraphEntryPoints?.FirstOrDefault();
+                if (entryPoint != null)
+                {
+                    return entryPoint.Value.GlobalProperties.AsReadOnly();
+                }
+
+                return ImmutableDictionary<string, string?>.Empty;
+            }
+        }
+        public override bool IsGraphRequest => true;
 
         /// <summary>
         /// Options for how the graph should be built.
         /// </summary>
         public GraphBuildOptions GraphBuildOptions { get; }
 
-        /// <summary>
-        /// Gets the HostServices object for this request.
-        /// </summary>
-        public HostServices HostServices { get; }
+        // WARNING!: Do not remove the below proxy properties.
+        //  They are required to make the OM forward compatible
+        //  (code built against this OM should run against binaries with previous version of OM).
+
+        /// <inheritdoc cref="BuildRequestDataBase.TargetNames"/>
+        public new ICollection<string> TargetNames => base.TargetNames;
+
+        /// <inheritdoc cref="BuildRequestDataBase.Flags"/>
+        public new BuildRequestDataFlags Flags => base.Flags;
+
+        /// <inheritdoc cref="BuildRequestDataBase.HostServices"/>
+        public new HostServices? HostServices => base.HostServices;
     }
 }
diff --git a/src/Build/Graph/GraphBuildResult.cs b/src/Build/Graph/GraphBuildResult.cs
index 6df04a0c899..c13ea8ce105 100644
--- a/src/Build/Graph/GraphBuildResult.cs
+++ b/src/Build/Graph/GraphBuildResult.cs
@@ -3,14 +3,13 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 
-#nullable disable
-
 namespace Microsoft.Build.Graph
 {
-    public sealed class GraphBuildResult
+    public sealed class GraphBuildResult : BuildResultBase
     {
         /// <summary>
         /// Constructor creates a build result with results for each graph node.
@@ -32,27 +31,28 @@ internal GraphBuildResult(int submissionId, Exception exception)
         {
             SubmissionId = submissionId;
             Exception = exception;
+            ResultsByNode = ImmutableDictionary<ProjectGraphNode, BuildResult>.Empty;
         }
 
         /// <summary>
         /// Returns the submission id.
         /// </summary>
-        public int SubmissionId { get; }
+        public override int SubmissionId { get; }
 
         /// <summary>
         /// Returns a flag indicating if a circular dependency was detected.
         /// </summary>
-        public bool CircularDependency => Exception is CircularDependencyException;
+        public override bool CircularDependency => Exception is CircularDependencyException;
 
         /// <summary>
         /// Returns the exception generated while this result was run, if any.
         /// </summary>
-        public Exception Exception { get; internal set; }
+        public override Exception? Exception { get; internal set; }
 
         /// <summary>
         /// Returns the overall result for this result set.
         /// </summary>
-        public BuildResultCode OverallResult
+        public override BuildResultCode OverallResult
         {
             get
             {
diff --git a/src/Build/Graph/GraphBuildSubmission.cs b/src/Build/Graph/GraphBuildSubmission.cs
index 9c00b5bb0e4..270134614f5 100644
--- a/src/Build/Graph/GraphBuildSubmission.cs
+++ b/src/Build/Graph/GraphBuildSubmission.cs
@@ -4,11 +4,10 @@
 using System;
 using System.Globalization;
 using System.Threading;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Graph
 {
     /// <summary>
@@ -26,126 +25,72 @@ namespace Microsoft.Build.Graph
     /// <remarks>
     /// This class is thread-safe.
     /// </remarks>
-    public class GraphBuildSubmission
+    public class GraphBuildSubmission : BuildSubmissionBase<GraphBuildRequestData, GraphBuildResult>
     {
-        /// <summary>
-        /// The callback to invoke when the submission is complete.
-        /// </summary>
-        private GraphBuildSubmissionCompleteCallback _completionCallback;
-
-        /// <summary>
-        /// The completion event.
-        /// </summary>
-        private readonly ManualResetEvent _completionEvent;
-
-        /// <summary>
-        /// True if it has been invoked
-        /// </summary>
-        private int _completionInvoked;
-
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        internal GraphBuildSubmission(BuildManager buildManager, int submissionId, GraphBuildRequestData requestData)
+        internal GraphBuildSubmission(BuildManager buildManager, int submissionId, GraphBuildRequestData requestData) :
+            base(buildManager, submissionId, requestData)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(buildManager, nameof(buildManager));
-            ErrorUtilities.VerifyThrowArgumentNull(requestData, nameof(requestData));
-
-            BuildManager = buildManager;
-            SubmissionId = submissionId;
-            BuildRequestData = requestData;
-            _completionEvent = new ManualResetEvent(false);
-            _completionInvoked = 0;
+            CompleteLogging();
         }
 
         /// <summary>
-        /// The BuildManager with which this submission is associated.
-        /// </summary>
-        public BuildManager BuildManager { get; }
-
-        /// <summary>
-        /// An ID uniquely identifying this request from among other submissions within the same build.
-        /// </summary>
-        public int SubmissionId { get; }
-
-        /// <summary>
-        /// The asynchronous context provided to <see cref="BuildSubmission.ExecuteAsync(BuildSubmissionCompleteCallback, object)"/>, if any.
-        /// </summary>
-        public Object AsyncContext { get; private set; }
-
-        /// <summary>
-        /// A <see cref="System.Threading.WaitHandle"/> which will be signalled when the build is complete.  Valid after <see cref="BuildSubmission.Execute()"/> or <see cref="BuildSubmission.ExecuteAsync(BuildSubmissionCompleteCallback, object)"/> returns, otherwise null.
-        /// </summary>
-        public WaitHandle WaitHandle => _completionEvent;
-
-        /// <summary>
-        /// Returns true if this submission is complete.
-        /// </summary>
-        public bool IsCompleted => WaitHandle.WaitOne(new TimeSpan(0));
-
-        /// <summary>
-        /// The results of the build per graph node.  Valid only after WaitHandle has become signalled.
-        /// </summary>
-        public GraphBuildResult BuildResult { get; internal set; }
-
-        /// <summary>
-        /// The BuildRequestData being used for this submission.
+        /// Starts the request asynchronously and immediately returns control to the caller.
         /// </summary>
-        internal GraphBuildRequestData BuildRequestData { get; }
+        /// <exception cref="InvalidOperationException">The request has already been started or is already complete.</exception>
+        public void ExecuteAsync(GraphBuildSubmissionCompleteCallback? callback, object? context)
+        {
+            void Clb(BuildSubmissionBase<GraphBuildRequestData, GraphBuildResult> submission)
+            {
+                callback?.Invoke((GraphBuildSubmission)submission);
+            }
 
-        /// <summary>
-        /// Whether the graph build has started.
-        /// </summary>
-        internal bool IsStarted { get; set; }
+            ExecuteAsync(Clb, context, allowMainThreadBuild: false);
+        }
 
         /// <summary>
         /// Starts the request and blocks until results are available.
         /// </summary>
         /// <exception cref="System.InvalidOperationException">The request has already been started or is already complete.</exception>
-        public GraphBuildResult Execute()
+        public override GraphBuildResult Execute()
         {
             ExecuteAsync(null, null);
             WaitHandle.WaitOne();
 
-            return BuildResult;
+            ErrorUtilities.VerifyThrow(BuildResult != null,
+                "BuildResult is not populated after Execute is done.");
+
+            return BuildResult!;
         }
 
-        /// <summary>
-        /// Starts the request asynchronously and immediately returns control to the caller.
-        /// </summary>
-        /// <exception cref="System.InvalidOperationException">The request has already been started or is already complete.</exception>
-        public void ExecuteAsync(GraphBuildSubmissionCompleteCallback callback, object context)
+        protected internal override void CheckResultValidForCompletion(GraphBuildResult result)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(!IsCompleted, "SubmissionAlreadyComplete");
-            _completionCallback = callback;
-            AsyncContext = context;
-            BuildManager.ExecuteSubmission(this);
+            ErrorUtilities.VerifyThrow(result.SubmissionId == SubmissionId,
+                "GraphBuildResult's submission id doesn't match GraphBuildSubmission's");
         }
 
-        /// <summary>
-        /// Sets the event signaling that the build is complete.
-        /// </summary>
-        internal void CompleteResults(GraphBuildResult result)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(result, nameof(result));
-            ErrorUtilities.VerifyThrow(result.SubmissionId == SubmissionId, "GraphBuildResult's submission id doesn't match GraphBuildSubmission's");
+        protected internal override GraphBuildResult CreateFailedResult(Exception exception)
+            => new(SubmissionId, exception);
 
-            bool hasCompleted = (Interlocked.Exchange(ref _completionInvoked, 1) == 1);
-            if (!hasCompleted)
-            {
-                BuildResult = result;
-                _completionEvent.Set();
-
-                if (_completionCallback != null)
-                {
-                    void Callback(object state)
-                    {
-                        _completionCallback(this);
-                    }
-
-                    ThreadPoolExtensions.QueueThreadPoolWorkItemWithCulture(Callback, CultureInfo.CurrentCulture, CultureInfo.CurrentUICulture);
-                }
-            }
-        }
+        // WARNING!: Do not remove the below proxy properties.
+        //  They are required to make the OM forward compatible
+        //  (code built against this OM should run against binaries with previous version of OM).
+
+        /// <inheritdoc cref="BuildSubmissionBase{GraphBuildRequestData, GraphBuildResult}.BuildResult"/>
+        public new GraphBuildResult? BuildResult => base.BuildResult;
+
+        /// <inheritdoc cref="BuildSubmissionBase.BuildManager"/>
+        public new BuildManager BuildManager => base.BuildManager;
+
+        /// <inheritdoc cref="BuildSubmissionBase.SubmissionId"/>
+        public new int SubmissionId => base.SubmissionId;
+
+        /// <inheritdoc cref="BuildSubmissionBase.AsyncContext"/>
+        public new object? AsyncContext => base.AsyncContext;
+
+        /// <inheritdoc cref="BuildSubmissionBase.WaitHandle"/>
+        public new WaitHandle WaitHandle => base.WaitHandle;
+
+        /// <inheritdoc cref="BuildSubmissionBase.IsCompleted"/>
+        public new bool IsCompleted => base.IsCompleted;
     }
 }
diff --git a/src/Build/Instance/IImmutableInstanceProvider.cs b/src/Build/Instance/IImmutableInstanceProvider.cs
index a862a12cf13..4b39fc66288 100644
--- a/src/Build/Instance/IImmutableInstanceProvider.cs
+++ b/src/Build/Instance/IImmutableInstanceProvider.cs
@@ -9,6 +9,19 @@ namespace Microsoft.Build.Execution
     /// <typeparam name="T">The Instance type.</typeparam>
     internal interface IImmutableInstanceProvider<T>
     {
-        T ImmutableInstance { get; set; }
+        /// <summary>
+        /// Gets the Immutable Instance.
+        /// </summary>
+        T ImmutableInstance { get; }
+
+        /// <summary>
+        /// If the ImmutableInstance has not already been set, then this
+        /// method sets the ImmutableInstance to the requested value.
+        /// An already set ImmutableInstance is never replaced.
+        /// </summary>
+        /// <param name="instance">An instance that will be set as the immutable instance, provided that
+        /// the immutable instance has not already been set.</param>
+        /// <returns>The immutable instance, which may or may not be the supplied <paramref name="instance"/>.</returns>
+        T GetOrSetImmutableInstance(T instance);
     }
 }
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
index ae164108704..f15fd45f63e 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
@@ -6,11 +6,8 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Data;
 using System.Runtime.Serialization;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Instance
@@ -18,20 +15,19 @@ namespace Microsoft.Build.Instance
     /// <summary>
     /// A specialized collection used when element data originates in an immutable Project.
     /// </summary>
-    internal sealed class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
         where T : class, IKeyed
     {
-        private readonly IDictionary<string, TCached> _projectElements;
-        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+        protected readonly IDictionary<string, TCached> _projectElements;
         private readonly ValuesCollection _values;
 
         public ImmutableElementCollectionConverter(
             IDictionary<string, TCached> projectElements,
-            IDictionary<(string, int, int), TCached> constrainedProjectElements)
+            IDictionary<(string, int, int), TCached> constrainedProjectElements,
+            Func<TCached, T> convertElement)
         {
             _projectElements = projectElements;
-            _constrainedProjectElements = constrainedProjectElements;
-            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);
+            _values = new ValuesCollection(_projectElements, constrainedProjectElements, convertElement);
         }
 
         public T this[string key]
@@ -110,13 +106,16 @@ private sealed class ValuesCollection : ICollection<T>
         {
             private readonly IDictionary<string, TCached> _projectElements;
             private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+            private readonly Func<TCached, T> _getElementInstance;
 
             public ValuesCollection(
                 IDictionary<string, TCached> projectElements,
-                IDictionary<(string, int, int), TCached> constrainedProjectElements)
+                IDictionary<(string, int, int), TCached> constrainedProjectElements,
+                Func<TCached, T> getElementInstance)
             {
                 _projectElements = projectElements;
                 _constrainedProjectElements = constrainedProjectElements;
+                _getElementInstance = getElementInstance;
             }
 
             public int Count => _projectElements.Count;
@@ -155,7 +154,7 @@ public void CopyTo(T[] array, int arrayIndex, int count)
                 int endIndex = arrayIndex + count;
                 foreach (var item in _projectElements.Values)
                 {
-                    array[index] = GetElementInstance(item);
+                    array[index] = _getElementInstance(item);
                     ++index;
                     if (index >= endIndex)
                     {
@@ -171,7 +170,7 @@ public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex)
                 int index = arrayIndex;
                 foreach (var item in _projectElements.Values)
                 {
-                    var itemInstance = GetElementInstance(item);
+                    var itemInstance = _getElementInstance(item);
                     array[index] = new KeyValuePair<string, T>(itemInstance.Key, itemInstance);
                     ++index;
                 }
@@ -181,7 +180,7 @@ public IEnumerator<T> GetEnumerator()
             {
                 foreach (var item in _projectElements.Values)
                 {
-                    yield return GetElementInstance(item);
+                    yield return _getElementInstance(item);
                 }
             }
 
@@ -189,7 +188,7 @@ public IEnumerator<KeyValuePair<string, T>> GetKvpEnumerator()
             {
                 foreach (var kvp in _projectElements)
                 {
-                    T instance = GetElementInstance(kvp.Value);
+                    T instance = _getElementInstance(kvp.Value);
                     yield return new KeyValuePair<string, T>(kvp.Key, instance);
                 }
             }
@@ -200,7 +199,7 @@ IEnumerator IEnumerable.GetEnumerator()
             {
                 foreach (var item in _projectElements.Values)
                 {
-                    yield return GetElementInstance(item);
+                    yield return _getElementInstance(item);
                 }
             }
 
@@ -208,7 +207,7 @@ public T Get(string key)
             {
                 if (_projectElements.TryGetValue(key, out TCached element))
                 {
-                    return GetElementInstance(element);
+                    return _getElementInstance(element);
                 }
 
                 return null;
@@ -216,9 +215,14 @@ public T Get(string key)
 
             public T Get(string keyString, int startIndex, int length)
             {
+                if (_constrainedProjectElements == null)
+                {
+                    return Get(keyString);
+                }
+
                 if (_constrainedProjectElements.TryGetValue((keyString, startIndex, length), out TCached element))
                 {
-                    return GetElementInstance(element);
+                    return _getElementInstance(element);
                 }
 
                 return null;
@@ -232,19 +236,9 @@ public bool TryGetValue(string key, out T value)
                     return false;
                 }
 
-                value = GetElementInstance(element);
+                value = _getElementInstance(element);
                 return value != null;
             }
-
-            private T GetElementInstance(TCached element)
-            {
-                if (element is IImmutableInstanceProvider<T> instanceProvider)
-                {
-                    return instanceProvider.ImmutableInstance;
-                }
-
-                return null;
-            }
         }
     }
 }
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
new file mode 100644
index 00000000000..b5579adf088
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
@@ -0,0 +1,251 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.CodeDom;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Runtime.Serialization;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+#nullable disable
+
+namespace Microsoft.Build.Instance.ImmutableProjectCollections
+{
+    /// <summary>
+    /// A collection representing the set of Global ProjectPropertyInstance objects.
+    /// </summary>
+    /// <remarks>This class is used only when the containing ProjectInstance originates from an
+    /// immutable linked project source. It's specialized in order to reduce required allocations
+    /// by instead relying on the linked project source's collection of global properties
+    /// (the IDictionary _globalProperties) and the ProjectInstance's collection of all
+    /// properties (the PropertyDictionary _allProperties). When a property is requested,
+    /// _globalProperties is checked to determine whether the named property is actually
+    /// a global property and, if it is, then instance is retrieved from _allProperties.
+    /// </remarks>
+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>
+    {
+        private readonly IDictionary<string, string> _globalProperties;
+        private readonly PropertyDictionary<ProjectPropertyInstance> _allProperties;
+        private readonly ValuesCollection _values;
+
+        public ImmutableGlobalPropertiesCollectionConverter(
+            IDictionary<string, string> globalProperties,
+            PropertyDictionary<ProjectPropertyInstance> allProperties)
+        {
+            _globalProperties = globalProperties;
+            _allProperties = allProperties;
+            _values = new ValuesCollection(this);
+        }
+
+        public ProjectPropertyInstance this[string key]
+        {
+            set => throw new NotSupportedException();
+            get
+            {
+                if (_globalProperties.ContainsKey(key))
+                {
+                    return _allProperties[key];
+                }
+
+                return null;
+            }
+        }
+
+        public int Count => _globalProperties.Count;
+
+        public bool IsReadOnly => true;
+
+        public ICollection<string> Keys => _globalProperties.Keys;
+
+        public ICollection<ProjectPropertyInstance> Values => _values;
+
+        public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+        public void Add(string key, ProjectPropertyInstance value) => throw new NotSupportedException();
+
+        public void Add(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public bool Contains(ProjectPropertyInstance item) => _values.Contains(item);
+
+        public bool Contains(KeyValuePair<string, ProjectPropertyInstance> itemKvp) => _values.Contains(itemKvp.Value);
+
+        public bool ContainsKey(string key) => _globalProperties.ContainsKey(key);
+
+        public void CopyTo(ProjectPropertyInstance[] array) => _values.CopyTo(array, arrayIndex: 0);
+
+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);
+
+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);
+
+        public void CopyTo(KeyValuePair<string, ProjectPropertyInstance>[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _globalProperties.Count);
+
+            int currentIndex = arrayIndex;
+            foreach (var itemKey in _globalProperties.Keys)
+            {
+                ProjectPropertyInstance instance = _allProperties[itemKey];
+                if (instance != null)
+                {
+                    array[currentIndex] = new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);
+                    ++currentIndex;
+                }
+            }
+        }
+
+        public ProjectPropertyInstance Get(string key)
+        {
+            return this[key];
+        }
+
+        public ProjectPropertyInstance Get(string key, int index, int length)
+        {
+            // The PropertyDictionary containing all of the properties can efficiently
+            // look up the requested property while honoring the specific index and length
+            // constraints. We then just have to verify that it's one of the global properties.
+            ProjectPropertyInstance actualProperty = _allProperties.Get(key, index, length);
+            if (actualProperty != null && _globalProperties.ContainsKey(actualProperty.Name))
+            {
+                return actualProperty;
+            }
+
+            return null;
+        }
+
+        public IEnumerator<ProjectPropertyInstance> GetEnumerator() => _values.GetEnumerator();
+
+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();
+
+        public void OnDeserialization(object sender) => throw new NotSupportedException();
+
+        public bool Remove(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+        public bool Remove(string key) => throw new NotSupportedException();
+
+        public bool Remove(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();
+
+        public void TrimExcess()
+        {
+        }
+
+        public bool TryGetValue(string key, out ProjectPropertyInstance value)
+        {
+            ProjectPropertyInstance instance = Get(key);
+            value = instance;
+            return instance != null;
+        }
+
+        public void UnionWith(IEnumerable<ProjectPropertyInstance> other) => throw new NotSupportedException();
+
+        IEnumerator<KeyValuePair<string, ProjectPropertyInstance>> IEnumerable<KeyValuePair<string, ProjectPropertyInstance>>.GetEnumerator()
+        {
+            foreach (var itemKey in _globalProperties.Keys)
+            {
+                ProjectPropertyInstance instance = _allProperties[itemKey];
+                if (instance != null)
+                {
+                    yield return new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);
+                }
+            }
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();
+
+        private class ValuesCollection : ICollection<ProjectPropertyInstance>
+        {
+            private readonly ImmutableGlobalPropertiesCollectionConverter _parent;
+
+            public ValuesCollection(ImmutableGlobalPropertiesCollectionConverter parent)
+            {
+                _parent = parent;
+            }
+
+            public int Count => _parent._globalProperties.Count;
+
+            public bool IsReadOnly => true;
+
+            public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+            public void Clear() => throw new NotSupportedException();
+
+            public bool Remove(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+            public bool Contains(ProjectPropertyInstance item)
+            {
+                if (!_parent._globalProperties.ContainsKey(item.Name))
+                {
+                    return false;
+                }
+
+                ProjectPropertyInstance actualInstance = _parent._allProperties[item.Name];
+
+                if (actualInstance == null)
+                {
+                    return false;
+                }
+
+                return actualInstance.Equals(item);
+            }
+
+            public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex)
+            {
+                CopyTo(array, arrayIndex, _parent._globalProperties.Count);
+            }
+
+            public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count)
+            {
+                ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _parent._globalProperties.Count);
+
+                int currentIndex = arrayIndex;
+                int currentCount = 0;
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    if (currentCount >= count)
+                    {
+                        return;
+                    }
+
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        array[currentIndex] = instance;
+                        ++currentIndex;
+                        ++currentCount;
+                    }
+                }
+            }
+
+            public IEnumerator<ProjectPropertyInstance> GetEnumerator()
+            {
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
new file mode 100644
index 00000000000..1a1d499b0aa
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
@@ -0,0 +1,182 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutableItemDefinitionsListConverter<TCached, T> : IList<T>
+        where T : IKeyed
+        where TCached : IKeyed
+    {
+        private readonly IList<TCached>? _itemList;
+        private readonly TCached? _itemTypeDefinition;
+        private readonly Func<TCached, T> _getInstance;
+
+        public ImmutableItemDefinitionsListConverter(
+            IList<TCached>? itemList,
+            TCached? itemTypeDefinition,
+            Func<TCached, T> getInstance)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(getInstance, nameof(getInstance));
+
+            _itemList = itemList;
+            _itemTypeDefinition = itemTypeDefinition;
+            _getInstance = getInstance;
+        }
+
+        public T this[int index]
+        {
+            set => throw new NotSupportedException();
+            get
+            {
+                if (_itemList == null)
+                {
+                    if (index != 0 || _itemTypeDefinition == null)
+                    {
+                        throw new IndexOutOfRangeException();
+                    }
+
+                    return _getInstance(_itemTypeDefinition);
+                }
+
+                if (index > _itemList.Count)
+                {
+                    throw new IndexOutOfRangeException();
+                }
+
+                if (index == _itemList.Count)
+                {
+                    if (_itemTypeDefinition == null)
+                    {
+                        throw new IndexOutOfRangeException();
+                    }
+
+                    return _getInstance(_itemTypeDefinition);
+                }
+
+                return _getInstance(_itemList[index]);
+            }
+        }
+
+        public int Count => (_itemList == null ? 0 : _itemList.Count) + (_itemTypeDefinition == null ? 0 : 1);
+
+        public bool IsReadOnly => true;
+
+        public void Add(T item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public void Insert(int index, T item) => throw new NotSupportedException();
+
+        public bool Remove(T item) => throw new NotSupportedException();
+
+        public void RemoveAt(int index) => throw new NotSupportedException();
+
+        public bool Contains(T item)
+        {
+            return IndexOf(item) >= 0;
+        }
+
+        public void CopyTo(T[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), Count);
+
+            int currentIndex = arrayIndex;
+            void PutItemIntoArray(TCached item)
+            {
+                array[currentIndex] = _getInstance(item);
+                ++currentIndex;
+            }
+
+            if (_itemList != null)
+            {
+                foreach (var item in _itemList)
+                {
+                    PutItemIntoArray(item);
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                PutItemIntoArray(_itemTypeDefinition);
+            }
+        }
+
+        public IEnumerator<T> GetEnumerator() => GetEnumeratorImpl();
+
+        public int IndexOf(T item)
+        {
+            int currentIndex = 0;
+            if (_itemList != null)
+            {
+                foreach (var cachedItem in _itemList)
+                {
+                    if (IsMatchingItem(cachedItem, item))
+                    {
+                        return currentIndex;
+                    }
+
+                    ++currentIndex;
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                if (IsMatchingItem(_itemTypeDefinition, item))
+                {
+                    return currentIndex;
+                }
+            }
+
+            return -1;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumeratorImpl();
+
+        private bool IsMatchingItem(TCached cachedItem, T item)
+        {
+            if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.Key, item.Key))
+            {
+                T? foundItem = _getInstance(cachedItem);
+                if (foundItem is not null && foundItem.Equals(item))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private IEnumerator<T> GetEnumeratorImpl()
+        {
+            if (_itemList != null)
+            {
+                foreach (var item in _itemList)
+                {
+                    T? instance = _getInstance(item);
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                T? instance = _getInstance(_itemTypeDefinition);
+                if (instance != null)
+                {
+                    yield return instance;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
index 74919a57b97..de2d06522ae 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
@@ -19,29 +19,28 @@ namespace Microsoft.Build.Instance
     /// </summary>
     internal sealed class ImmutableItemDictionary<TCached, T> : IItemDictionary<T>
         where T : class, IKeyed, IItem
+        where TCached : IKeyed, IItem
     {
         private readonly IDictionary<string, ICollection<TCached>> _itemsByType;
-        private readonly ICollection<T> _allItems;
-
-        public ImmutableItemDictionary(IDictionary<string, ICollection<TCached>> itemsByType, ICollection<TCached> allItems)
+        private readonly ICollection<TCached> _allCachedItems;
+        private readonly Func<TCached, T?> _getInstance;
+        private readonly Func<T, string?> _getItemType;
+
+        public ImmutableItemDictionary(
+            ICollection<TCached> allItems,
+            IDictionary<string, ICollection<TCached>> itemsByType,
+            Func<TCached, T?> getInstance,
+            Func<T, string?> getItemType)
         {
-            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
-
             if (allItems == null)
             {
                 throw new ArgumentNullException(nameof(allItems));
             }
 
-            var convertedItems = new HashSet<T>(allItems.Count);
-            foreach (var item in allItems)
-            {
-                T? instance = GetInstance(item);
-                if (instance != null)
-                {
-                    convertedItems.Add(instance);
-                }
-            }
-            _allItems = new ReadOnlyCollection<T>(convertedItems);
+            _allCachedItems = allItems;
+            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
+            _getInstance = getInstance;
+            _getItemType = getItemType;
         }
 
         /// <inheritdoc />
@@ -54,12 +53,12 @@ public ICollection<T> this[string itemType]
                     return Array.Empty<T>();
                 }
 
-                return new ListConverter(itemType, _allItems, list);
+                return new ListConverter(itemType, list, _getInstance);
             }
         }
 
         /// <inheritdoc />
-        public int Count => _allItems.Count;
+        public int Count => _allCachedItems.Count;
 
         /// <inheritdoc />
         public ICollection<string> ItemTypes => _itemsByType.Keys;
@@ -77,7 +76,22 @@ public ICollection<T> this[string itemType]
         public void Clear() => throw new NotSupportedException();
 
         /// <inheritdoc />
-        public bool Contains(T projectItem) => _allItems.Contains(projectItem);
+        public bool Contains(T projectItem)
+        {
+            if (projectItem == null)
+            {
+                return false;
+            }
+
+            string? itemType = _getItemType(projectItem);
+            if (itemType == null)
+            {
+                return false;
+            }
+
+            ICollection<T> items = GetItems(itemType);
+            return items.Contains(projectItem);
+        }
 
         /// <inheritdoc />
         public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
@@ -90,31 +104,55 @@ public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallbac
                     continue;
                 }
 
-                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, _allItems, kvp.Value));
+                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, kvp.Value, _getInstance));
             }
         }
 
         /// <inheritdoc />
         public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)
         {
-            foreach (var item in _allItems)
+            foreach (var cachedItem in _allCachedItems)
             {
-                yield return selector(item);
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return selector(item);
+                }
             }
         }
 
         /// <inheritdoc />
-        public IEnumerator<T> GetEnumerator() => _allItems.GetEnumerator();
+        public IEnumerator<T> GetEnumerator()
+        {
+            foreach (var cachedItem in _allCachedItems)
+            {
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return item;
+                }
+            }
+        }
 
         /// <inheritdoc />
-        IEnumerator IEnumerable.GetEnumerator() => _allItems.GetEnumerator();
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            foreach (var cachedItem in _allCachedItems)
+            {
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return item;
+                }
+            }
+        }
 
         /// <inheritdoc />
         public ICollection<T> GetItems(string itemType)
         {
             if (_itemsByType.TryGetValue(itemType, out ICollection<TCached>? items))
             {
-                return new ListConverter(itemType, _allItems, items);
+                return new ListConverter(itemType, items, _getInstance);
             }
 
             return Array.Empty<T>();
@@ -138,27 +176,17 @@ public ICollection<T> GetItems(string itemType)
         /// <inheritdoc />
         public void Replace(T existingItem, T newItem) => throw new NotSupportedException();
 
-        private static T? GetInstance(TCached item)
-        {
-            if (item is IImmutableInstanceProvider<T> instanceProvider)
-            {
-                return instanceProvider.ImmutableInstance;
-            }
-
-            return null;
-        }
-
         private sealed class ListConverter : ICollection<T>
         {
             private readonly string _itemType;
-            private readonly ICollection<T> _allItems;
             private readonly ICollection<TCached> _list;
+            private readonly Func<TCached, T?> _getInstance;
 
-            public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCached> list)
+            public ListConverter(string itemType, ICollection<TCached> list, Func<TCached, T?> getInstance)
             {
                 _itemType = itemType;
-                _allItems = allItems;
                 _list = list;
+                _getInstance = getInstance;
             }
 
             public int Count => _list.Count;
@@ -173,8 +201,20 @@ public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCach
 
             public bool Contains(T item)
             {
-                return MSBuildNameIgnoreCaseComparer.Default.Equals(item.Key, _itemType) &&
-                       _allItems.Contains(item);
+                return _list.Any(
+                    cachedItem =>
+                    {
+                        if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.EvaluatedIncludeEscaped, item.EvaluatedIncludeEscaped))
+                        {
+                            T? foundItem = _getInstance(cachedItem);
+                            if (foundItem is not null && foundItem.Equals(item))
+                            {
+                                return true;
+                            }
+                        }
+
+                        return false;
+                    });
             }
 
             public void CopyTo(T[] array, int arrayIndex)
@@ -184,7 +224,7 @@ public void CopyTo(T[] array, int arrayIndex)
                 int currentIndex = arrayIndex;
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         array[currentIndex] = instance;
@@ -197,7 +237,7 @@ public IEnumerator<T> GetEnumerator()
             {
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         yield return instance;
@@ -209,7 +249,7 @@ IEnumerator IEnumerable.GetEnumerator()
             {
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         yield return instance;
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
new file mode 100644
index 00000000000..1b11db2341a
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+
+namespace Microsoft.Build.Instance.ImmutableProjectCollections
+{
+    internal class ImmutableLinkedMultiDictionaryConverter<K, VCached, V> : IMultiDictionary<K, V>
+        where K : class
+        where V : class
+        where VCached : class
+    {
+        private readonly Func<K, IEnumerable<VCached>> _getCachedValues;
+        private readonly Func<VCached, V> _getInstance;
+
+        public ImmutableLinkedMultiDictionaryConverter(Func<K, IEnumerable<VCached>> getCachedValues, Func<VCached, V> getInstance)
+        {
+            _getCachedValues = getCachedValues;
+            _getInstance = getInstance;
+        }
+
+        public IEnumerable<V> this[K key]
+        {
+            get
+            {
+                IEnumerable<VCached> cachedValues = _getCachedValues(key);
+                if (cachedValues != null)
+                {
+                    foreach (var cachedValue in cachedValues)
+                    {
+                        yield return _getInstance(cachedValue);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
new file mode 100644
index 00000000000..27610c71543
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
@@ -0,0 +1,72 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutablePropertyCollectionConverter<TCached, T> : ImmutableElementCollectionConverter<TCached, T>, ICopyOnWritePropertyDictionary<T>
+        where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
+        where TCached : class, IValued, IEquatable<TCached>
+    {
+        public ImmutablePropertyCollectionConverter(IDictionary<string, TCached> properties, Func<TCached, T> convertProperty)
+            : base(properties, constrainedProjectElements: null, convertProperty)
+        {
+        }
+
+        public bool Contains(string name) => ContainsKey(name);
+
+        public string? GetEscapedValue(string name)
+        {
+            if (_projectElements.TryGetValue(name, out TCached? value))
+            {
+                return value?.EscapedValue;
+            }
+
+            return null;
+        }
+
+        public ICopyOnWritePropertyDictionary<T> DeepClone() => this;
+
+        public void ImportProperties(IEnumerable<T> other) => throw new NotSupportedException();
+
+        public void Set(T projectProperty) => throw new NotSupportedException();
+
+        public bool Equals(ICopyOnWritePropertyDictionary<T>? other)
+        {
+            if (other == null || Count != other.Count)
+            {
+                return false;
+            }
+
+            if (other is ImmutablePropertyCollectionConverter<TCached, T> otherImmutableDict)
+            {
+                // When comparing to another CollectionConverter we compare the TCached values
+                // in order to avoid causing the instantiation of each T instance.
+                foreach (var propKvp in _projectElements)
+                {
+                    if (!otherImmutableDict._projectElements.TryGetValue(propKvp.Key, out TCached? otherProperty) ||
+                        !EqualityComparer<TCached>.Default.Equals(propKvp.Value, otherProperty))
+                    {
+                        return false;
+                    }
+                }
+            }
+            else
+            {
+                foreach (T thisProp in Values)
+                {
+                    if (!other.TryGetValue(thisProp.Key, out T? thatProp) ||
+                        !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs
new file mode 100644
index 00000000000..89e12f7c0a1
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs
@@ -0,0 +1,99 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutableStringValuedListConverter<T> : IList<string>, IReadOnlyList<string>
+    {
+        private readonly IList<T> _itemList;
+        private readonly Func<T, string> _getStringValue;
+
+        public ImmutableStringValuedListConverter(IList<T> itemList, Func<T, string> getStringValue)
+        {
+            _itemList = itemList;
+            _getStringValue = getStringValue;
+        }
+
+        public string this[int index]
+        {
+            set => throw new NotSupportedException();
+            get => _getStringValue(_itemList[index]);
+        }
+
+        public int Count => _itemList.Count;
+
+        public bool IsReadOnly => true;
+
+        public void Add(string item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public void Insert(int index, string item) => throw new NotSupportedException();
+
+        public bool Remove(string item) => throw new NotSupportedException();
+
+        public void RemoveAt(int index) => throw new NotSupportedException();
+
+        public bool Contains(string item)
+        {
+            return IndexOf(item) >= 0;
+        }
+
+        public void CopyTo(string[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _itemList.Count);
+
+            int currentIndex = arrayIndex;
+            foreach (var item in _itemList)
+            {
+                array[currentIndex] = _getStringValue(item);
+                ++currentIndex;
+            }
+        }
+
+        public IEnumerator<string> GetEnumerator()
+        {
+            foreach (var item in _itemList)
+            {
+                string? stringValue = _getStringValue(item);
+                if (stringValue != null)
+                {
+                    yield return stringValue;
+                }
+            }
+        }
+
+        public int IndexOf(string item)
+        {
+            for (int i = 0; i < _itemList.Count; ++i)
+            {
+                T cachedItem = _itemList[i];
+                string stringValue = _getStringValue(cachedItem);
+                if (MSBuildNameIgnoreCaseComparer.Default.Equals(stringValue, item))
+                {
+                    return i;
+                }
+            }
+
+            return -1;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            foreach (var item in _itemList)
+            {
+                string? instance = _getStringValue(item);
+                if (instance != null)
+                {
+                    yield return instance;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs
new file mode 100644
index 00000000000..5477ba57c28
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs
@@ -0,0 +1,37 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+
+namespace Microsoft.Build.Instance
+{
+    /// <inheritdoc />
+    internal sealed class ImmutableValuedElementCollectionConverter<TCached, T> : ImmutableElementCollectionConverter<TCached, T>, IRetrievableValuedEntryHashSet<T>
+        where T : class, IKeyed, IValued
+        where TCached : IValued
+    {
+        public ImmutableValuedElementCollectionConverter(
+            IDictionary<string, TCached> projectElements,
+            IDictionary<(string, int, int), TCached> constrainedProjectElements,
+            Func<TCached, T> convertElement)
+            : base(projectElements, constrainedProjectElements, convertElement)
+        {
+        }
+
+        public bool TryGetEscapedValue(string key, out string escapedValue)
+        {
+            if (_projectElements.TryGetValue(key, out TCached value) && value != null)
+            {
+                escapedValue = value.EscapedValue;
+                return true;
+            }
+
+            escapedValue = null;
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index c8bdd009a8f..001761c4707 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -14,7 +14,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
@@ -23,6 +22,7 @@
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Instance;
+using Microsoft.Build.Instance.ImmutableProjectCollections;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -93,9 +93,9 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
 
         private List<string> _initialTargets;
 
-        private List<string> _importPaths;
+        private IList<string> _importPaths;
 
-        private List<string> _importPathsIncludingDuplicates;
+        private IList<string> _importPathsIncludingDuplicates;
 
         /// <summary>
         /// The global properties evaluation occurred with.
@@ -132,7 +132,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// <summary>
         /// Items organized by evaluatedInclude value
         /// </summary>
-        private MultiDictionary<string, ProjectItemInstance> _itemsByEvaluatedInclude;
+        private IMultiDictionary<string, ProjectItemInstance> _itemsByEvaluatedInclude;
 
         /// <summary>
         /// The project's root directory, for evaluation of relative paths and
@@ -435,41 +435,41 @@ private ProjectInstance(Project linkedProject, bool fastItemLookupNeeded)
             EvaluationId = linkedProject.EvaluationCounter;
 
             // ProjectProperties
-            InitializeImmutableProjectPropertyInstances(linkedProject.Properties);
-            var projectPropertiesConverter = GetImmutableElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(linkedProject.Properties);
-            _properties = new PropertyDictionary<ProjectPropertyInstance>(projectPropertiesConverter);
+            _properties = GetImmutablePropertyDictionaryFromImmutableProject(linkedProject);
 
             // ProjectItemDefinitions
-            InitializeImmutableProjectItemDefinitionInstances(linkedProject.ItemDefinitions);
-            _itemDefinitions = GetImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(linkedProject.ItemDefinitions);
+            _itemDefinitions = GetImmutableItemDefinitionsHashSetFromImmutableProject(linkedProject);
 
             // ProjectItems
-            InitializeImmutableProjectItemInstances(linkedProject.Items);
-            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
-            _items = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(itemsByType, linkedProject.Items);
+            _items = GetImmutableItemsDictionaryFromImmutableProject(linkedProject, this);
 
             // ItemsByEvaluatedInclude
             if (fastItemLookupNeeded)
             {
-                _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
-                foreach (var item in linkedProject.Items)
-                {
-                    if (item is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
-                    {
-                        _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, immutableInstanceProvider.ImmutableInstance);
-                    }
-                }
+                _itemsByEvaluatedInclude = new ImmutableLinkedMultiDictionaryConverter<string, ProjectItem, ProjectItemInstance>(
+                                                linkedProject.GetItemsByEvaluatedInclude,
+                                                item => ConvertCachedProjectItemToInstance(linkedProject, this, item));
             }
 
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(linkedProject.GlobalPropertiesCount);
-            foreach (var property in linkedProject.GlobalPropertiesEnumerable)
-            {
-                _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
-            }
+            // GlobalProperties
+            var globalPropertiesRetrievableHashSet = new ImmutableGlobalPropertiesCollectionConverter(linkedProject.GlobalProperties, _properties);
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(globalPropertiesRetrievableHashSet);
+
+            // EnvironmentVariableProperties
+            _environmentVariableProperties = linkedProject.ProjectCollection.SharedReadOnlyEnvironmentProperties;
 
-            CreateEnvironmentVariablePropertiesSnapshot(linkedProject.ProjectCollection.EnvironmentProperties);
-            CreateTargetsSnapshot(linkedProject.Targets, null, null, null, null);
-            CreateImportsSnapshot(linkedProject.Imports, linkedProject.ImportsIncludingDuplicates);
+            // Targets
+            _targets = linkedProject.Targets;
+            InitializeTargetsData(null, null, null, null);
+
+            // Imports
+            var importsListConverter = new ImmutableStringValuedListConverter<ResolvedImport>(linkedProject.Imports, GetImportFullPath);
+            _importPaths = importsListConverter;
+            ImportPaths = importsListConverter;
+
+            importsListConverter = new ImmutableStringValuedListConverter<ResolvedImport>(linkedProject.ImportsIncludingDuplicates, GetImportFullPath);
+            _importPathsIncludingDuplicates = importsListConverter;
+            ImportPathsIncludingDuplicates = importsListConverter;
 
             Toolset = linkedProject.ProjectCollection.GetToolset(linkedProject.ToolsVersion);
             SubToolsetVersion = linkedProject.SubToolsetVersion;
@@ -550,9 +550,9 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
             this.TaskRegistry = projectToInheritFrom.TaskRegistry;
             _isImmutable = projectToInheritFrom._isImmutable;
             _importPaths = projectToInheritFrom._importPaths;
-            ImportPaths = _importPaths.AsReadOnly();
+            ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
             _importPathsIncludingDuplicates = projectToInheritFrom._importPathsIncludingDuplicates;
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
@@ -754,9 +754,9 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                 _itemDefinitions = that._itemDefinitions;
                 _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
                 _importPaths = that._importPaths;
-                ImportPaths = _importPaths.AsReadOnly();
+                ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
                 _importPathsIncludingDuplicates = that._importPathsIncludingDuplicates;
-                ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+                ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
                 this.EvaluatedItemElements = that.EvaluatedItemElements;
 
@@ -899,9 +899,145 @@ public static ProjectInstance FromImmutableProjectSource(Project project, Projec
             return new ProjectInstance(project, fastItemLookupNeeded);
         }
 
-        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
-            ICollection<TCached> elementsCollection)
-            where T : class, IKeyed
+        private static IRetrievableEntryHashSet<ProjectItemDefinitionInstance> GetImmutableItemDefinitionsHashSetFromImmutableProject(Project linkedProject)
+        {
+            IDictionary<string, ProjectItemDefinition> linkedProjectItemDefinitions = linkedProject.ItemDefinitions;
+            VerifyCollectionImplementsRequiredDictionaryInterfaces(
+                linkedProjectItemDefinitions,
+                out IDictionary<string, ProjectItemDefinition> elementsDictionary,
+                out IDictionary<(string, int, int), ProjectItemDefinition> constrainedElementsDictionary);
+
+            var hashSet = new ImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(
+                                elementsDictionary,
+                                constrainedElementsDictionary,
+                                ConvertCachedItemDefinitionToInstance);
+
+            return hashSet;
+        }
+
+        private static ImmutableItemDictionary<ProjectItem, ProjectItemInstance> GetImmutableItemsDictionaryFromImmutableProject(
+            Project linkedProject,
+            ProjectInstance owningProjectInstance)
+        {
+            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
+            if (itemsByType == null)
+            {
+                throw new ArgumentException(nameof(linkedProject));
+            }
+
+            Func<ProjectItem, ProjectItemInstance> convertCachedItemToInstance =
+                projectItem => ConvertCachedProjectItemToInstance(linkedProject, owningProjectInstance, projectItem);
+
+            var itemDictionary = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(
+                linkedProject.Items,
+                itemsByType,
+                convertCachedItemToInstance,
+                projectItemInstance => projectItemInstance.ItemType);
+
+            return itemDictionary;
+        }
+
+        private static ProjectItemInstance ConvertCachedProjectItemToInstance(
+            Project linkedProject,
+            ProjectInstance owningProjectInstance,
+            ProjectItem projectItem)
+        {
+            ProjectItemInstance result = null;
+            if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    var newInstance = InstantiateProjectItemInstanceFromImmutableProjectSource(
+                        linkedProject,
+                        owningProjectInstance,
+                        projectItem);
+
+                    result = instanceProvider.GetOrSetImmutableInstance(newInstance);
+                }
+            }
+
+            return result;
+        }
+
+        private static ProjectItemDefinitionInstance ConvertCachedItemDefinitionToInstance(ProjectItemDefinition projectItemDefinition)
+        {
+            ProjectItemDefinitionInstance result = null;
+
+            if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    IDictionary<string, ProjectMetadataInstance> metadata = null;
+                    if (projectItemDefinition.Metadata is IDictionary<string, ProjectMetadata> linkedMetadataDict)
+                    {
+                        metadata = new ImmutableElementCollectionConverter<ProjectMetadata, ProjectMetadataInstance>(
+                                        linkedMetadataDict,
+                                        constrainedProjectElements: null,
+                                        ConvertCachedProjectMetadataToInstance);
+                    }
+
+                    result = instanceProvider.GetOrSetImmutableInstance(
+                        new ProjectItemDefinitionInstance(projectItemDefinition.ItemType, metadata));
+                }
+            }
+
+            return result;
+        }
+
+        private static ProjectMetadataInstance ConvertCachedProjectMetadataToInstance(ProjectMetadata projectMetadata)
+        {
+            ProjectMetadataInstance result = null;
+
+            if (projectMetadata is IImmutableInstanceProvider<ProjectMetadataInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    result = instanceProvider.GetOrSetImmutableInstance(new ProjectMetadataInstance(projectMetadata));
+                }
+            }
+
+            return result;
+        }
+
+        private static PropertyDictionary<ProjectPropertyInstance> GetImmutablePropertyDictionaryFromImmutableProject(Project linkedProject)
+        {
+            ICollection<ProjectProperty> linkedProjectProperties = linkedProject.Properties;
+            VerifyCollectionImplementsRequiredDictionaryInterfaces(
+                linkedProjectProperties,
+                out IDictionary<string, ProjectProperty> elementsDictionary,
+                out IDictionary<(string, int, int), ProjectProperty> constrainedElementsDictionary);
+
+            var hashSet = new ImmutableValuedElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(
+                                elementsDictionary,
+                                constrainedElementsDictionary,
+                                ConvertCachedPropertyToInstance);
+
+            return new PropertyDictionary<ProjectPropertyInstance>(hashSet);
+        }
+
+        private static ProjectPropertyInstance ConvertCachedPropertyToInstance(ProjectProperty property)
+        {
+            ProjectPropertyInstance result = null;
+
+            if (property is IImmutableInstanceProvider<ProjectPropertyInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    result = instanceProvider.GetOrSetImmutableInstance(InstantiateProjectPropertyInstance(property, isImmutable: true));
+                }
+            }
+
+            return result;
+        }
+
+        private static void VerifyCollectionImplementsRequiredDictionaryInterfaces<TCached>(
+            object elementsCollection,
+            out IDictionary<string, TCached> elementsDictionary,
+            out IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
         {
             // The elementsCollection we receive here is implemented in CPS as a special collection
             // that is both IDictionary<string, TCached> and also IDictionary<(string, int, int), TCached>.
@@ -912,25 +1048,14 @@ private static ImmutableElementCollectionConverter<TCached, T> GetImmutableEleme
             // represents the elementsCollection as an IRetrievableEntryHashSet<T>.
             // That IRetrievableEntryHashSet is then used either directly or as a backing source for
             // another collection wrapper (e.g. PropertyDictionary).
-            if (elementsCollection is not IDictionary<string, TCached> elementsDictionary ||
-                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
+            if (elementsCollection is not IDictionary<string, TCached> elementsDict ||
+                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDict)
             {
                 throw new ArgumentException(nameof(elementsCollection));
             }
 
-            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
-        }
-
-        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
-            IDictionary<string, TCached> elementsDictionary)
-            where T : class, IKeyed
-        {
-            if (elementsDictionary is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
-            {
-                throw new ArgumentException(nameof(elementsDictionary));
-            }
-
-            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
+            elementsDictionary = elementsDict;
+            constrainedElementsDictionary = constrainedElementsDict;
         }
 
         /// <summary>
@@ -1665,7 +1790,7 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// immutable if we are immutable.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, LoggingContext loggingContext)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext, bool isEnvironmentVariable)
         {
             // Mutability not verified as this is being populated during evaluation
             ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable, isEnvironmentVariable, loggingContext);
@@ -1678,7 +1803,7 @@ ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInsta
         /// Predecessor is discarded as it is a design time only artefact.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, LoggingContext loggingContext)
         {
             // Mutability not verified as this is being populated during evaluation
             ProjectPropertyInstance property = ProjectPropertyInstance.Create(propertyElement.Name, evaluatedValueEscaped, false /* may not be reserved */, _isImmutable);
@@ -1765,10 +1890,12 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         /// </remarks>
         public string GetPropertyValue(string name)
         {
-            ProjectPropertyInstance property = _properties[name];
-            string value = (property == null) ? String.Empty : property.EvaluatedValue;
+            if (!_properties.TryGetPropertyUnescapedValue(name, out string unescapedValue))
+            {
+                unescapedValue = String.Empty;
+            }
 
-            return value;
+            return unescapedValue;
         }
 
         /// <summary>
@@ -2859,28 +2986,6 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
             }
         }
 
-        private static void InitializeImmutableProjectItemDefinitionInstances(IDictionary<string, ProjectItemDefinition> projectItemDefinitions)
-        {
-            foreach (var projectItemDefinition in projectItemDefinitions.Values)
-            {
-                if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> immutableInstanceProvider)
-                {
-                    immutableInstanceProvider.ImmutableInstance = new ProjectItemDefinitionInstance(projectItemDefinition);
-                }
-            }
-        }
-
-        private static void InitializeImmutableProjectPropertyInstances(ICollection<ProjectProperty> projectProperties)
-        {
-            foreach (var projectProperty in projectProperties)
-            {
-                if (projectProperty is IImmutableInstanceProvider<ProjectPropertyInstance> immutableInstanceProvider)
-                {
-                    immutableInstanceProvider.ImmutableInstance = InstantiateProjectPropertyInstance(projectProperty, isImmutable: true);
-                }
-            }
-        }
-
         private static ProjectPropertyInstance InstantiateProjectPropertyInstance(ProjectProperty property, bool isImmutable)
         {
             // Allow reserved property names, since this is how they are added to the project instance.
@@ -2932,15 +3037,15 @@ private void Initialize(
             _actualTargets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
             _targets = new ObjectModel.ReadOnlyDictionary<string, ProjectTargetInstance>(_actualTargets);
             _importPaths = new List<string>();
-            ImportPaths = _importPaths.AsReadOnly();
+            ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
             _importPathsIncludingDuplicates = new List<string>();
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>((globalProperties == null) ? 0 : globalProperties.Count);
             _environmentVariableProperties = buildParameters.EnvironmentPropertiesInternal;
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
             _hostServices = buildParameters.HostServices;
             this.ProjectRootElementCache = buildParameters.ProjectRootElementCache;
-            _loggingContext = new AnalyzerLoggingContext(loggingService, buildEventContext);
+            _loggingContext = new GenericLoggingContext(loggingService, buildEventContext);
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
             _explicitToolsVersionSpecified = (explicitToolsVersion != null);
@@ -3051,8 +3156,16 @@ private void CreateTargetsSnapshot(
             // ProjectTargetInstances are immutable so only the dictionary must be cloned
             _targets = CreateCloneDictionary(targets);
 
-            this.DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
-            this.InitialTargets = defaultTargets == null ? new List<string>(0) : new List<string>(initialTargets);
+            InitializeTargetsData(defaultTargets, initialTargets, beforeTargets, afterTargets);
+        }
+
+        private void InitializeTargetsData(List<string> defaultTargets,
+            List<string> initialTargets,
+            IDictionary<string, List<TargetSpecification>> beforeTargets,
+            IDictionary<string, List<TargetSpecification>> afterTargets)
+        {
+            DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
+            InitialTargets = initialTargets == null ? new List<string>(0) : new List<string>(initialTargets);
             ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(beforeTargets, StringComparer.OrdinalIgnoreCase);
             ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(afterTargets, StringComparer.OrdinalIgnoreCase);
         }
@@ -3062,29 +3175,31 @@ private void CreateTargetsSnapshot(
         /// </summary>
         private void CreateImportsSnapshot(IList<ResolvedImport> importClosure, IList<ResolvedImport> importClosureWithDuplicates)
         {
-            _importPaths = new List<string>(Math.Max(0, importClosure.Count - 1) /* outer project */);
+            var importPaths = new List<string>(Math.Max(0, importClosure.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosure)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
                 {
-                    _importPaths.Add(resolvedImport.ImportedProject.FullPath);
+                    importPaths.Add(resolvedImport.ImportedProject.FullPath);
                 }
             }
 
-            ImportPaths = _importPaths.AsReadOnly();
+            _importPaths = importPaths;
+            ImportPaths = importPaths.AsReadOnly();
 
-            _importPathsIncludingDuplicates = new List<string>(Math.Max(0, importClosureWithDuplicates.Count - 1) /* outer project */);
+            var importPathsIncludingDuplicates = new List<string>(Math.Max(0, importClosureWithDuplicates.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosureWithDuplicates)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
                 {
-                    _importPathsIncludingDuplicates.Add(resolvedImport.ImportedProject.FullPath);
+                    importPathsIncludingDuplicates.Add(resolvedImport.ImportedProject.FullPath);
                 }
             }
 
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            _importPathsIncludingDuplicates = importPathsIncludingDuplicates;
+            ImportPathsIncludingDuplicates = importPathsIncludingDuplicates.AsReadOnly();
         }
 
         /// <summary>
@@ -3123,11 +3238,13 @@ private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache,
                 return;
             }
 
-            _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
+            var multiDictionary = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
             foreach (var item in items)
             {
-                _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
+                multiDictionary.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
             }
+
+            _itemsByEvaluatedInclude = multiDictionary;
         }
 
         /// <summary>
@@ -3149,22 +3266,9 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
             return projectItemToInstanceMap;
         }
 
-        private void InitializeImmutableProjectItemInstances(ICollection<ProjectItem> projectItems)
-        {
-            foreach (var projectItem in projectItems)
-            {
-                if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
-                {
-                    ProjectItemInstance instance = InstantiateProjectItemInstance(projectItem);
-                    immutableInstanceProvider.ImmutableInstance = instance;
-                }
-            }
-        }
-
         private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
         {
             List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
-
             if (item.InheritedItemDefinitions != null)
             {
                 inheritedItemDefinitions = new List<ProjectItemDefinitionInstance>(item.InheritedItemDefinitions.Count);
@@ -3178,7 +3282,6 @@ private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
             }
 
             CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
-
             if (item.DirectMetadata != null)
             {
                 directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
@@ -3187,16 +3290,87 @@ private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
                 directMetadata.ImportProperties(projectMetadataInstances);
             }
 
+            GetEvaluatedIncludesFromProjectItem(
+                item,
+                out string evaluatedIncludeEscaped,
+                out string evaluatedIncludeBeforeWildcardExpansionEscaped);
+
+            var instance = new ProjectItemInstance(
+                this,
+                item.ItemType,
+                evaluatedIncludeEscaped,
+                evaluatedIncludeBeforeWildcardExpansionEscaped,
+                directMetadata,
+                inheritedItemDefinitions,
+                item.Xml.ContainingProject.EscapedFullPath,
+                useItemDefinitionsWithoutModification: false);
+
+            return instance;
+        }
+
+        private static void GetEvaluatedIncludesFromProjectItem(
+            ProjectItem item,
+            out string evaluatedIncludeEscaped,
+            out string evaluatedIncludeBeforeWildcardExpansionEscaped)
+        {
             // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
-            var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
+            evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
             evaluatedIncludeEscaped ??= item.EvaluatedInclude;
-            var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
+            evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
             evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
+        }
+
+        private static ProjectItemInstance InstantiateProjectItemInstanceFromImmutableProjectSource(
+            Project linkedProject,
+            ProjectInstance projectInstance,
+            ProjectItem item)
+        {
+            linkedProject.ItemDefinitions.TryGetValue(item.ItemType, out ProjectItemDefinition itemTypeDefinition);
+
+            IList<ProjectItemDefinitionInstance> inheritedItemDefinitions =
+                new ImmutableItemDefinitionsListConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(
+                    item.InheritedItemDefinitions,
+                    itemTypeDefinition,
+                    ConvertCachedItemDefinitionToInstance);
 
-            ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
+            if (item.DirectMetadata is not null)
+            {
+                if (item.DirectMetadata is IDictionary<string, ProjectMetadata> metadataDict)
+                {
+                    directMetadata = new ImmutablePropertyCollectionConverter<ProjectMetadata, ProjectMetadataInstance>(metadataDict, ConvertCachedProjectMetadataToInstance);
+                }
+                else
+                {
+                    directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+
+                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
+                    directMetadata.ImportProperties(projectMetadataInstances);
+                }
+            }
+
+            GetEvaluatedIncludesFromProjectItem(
+                item,
+                out string evaluatedIncludeEscaped,
+                out string evaluatedIncludeBeforeWildcardExpansionEscaped);
+
+            ProjectItemInstance instance = new ProjectItemInstance(
+                projectInstance,
+                item.ItemType,
+                evaluatedIncludeEscaped,
+                evaluatedIncludeBeforeWildcardExpansionEscaped,
+                directMetadata,
+                inheritedItemDefinitions,
+                item.Xml.ContainingProject.EscapedFullPath,
+                useItemDefinitionsWithoutModification: true);
             return instance;
         }
 
+        private static string GetImportFullPath(ResolvedImport import)
+        {
+            return import.ImportedProject.FullPath;
+        }
+
         /// <summary>
         /// Create ItemDefinitions snapshot
         /// </summary>
@@ -3223,5 +3397,11 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
                 _properties.Set(instance);
             }
         }
+
+        internal class GenericLoggingContext : LoggingContext
+        {
+            public GenericLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
+                : base(loggingService, eventContext) => IsValid = true;
+        }
     }
 }
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index fa41b3882ec..2051107c8bd 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Instance;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -31,9 +32,8 @@ public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefini
         /// <summary>
         /// Collection of metadata that link the XML metadata and instance metadata
         /// Since evaluation has occurred, this is an unordered collection.
-        /// Is never null or empty.
         /// </summary>
-        private CopyOnWritePropertyDictionary<ProjectMetadataInstance> _metadata;
+        private IDictionary<string, ProjectMetadataInstance> _metadata;
 
         /// <summary>
         /// Constructs an empty project item definition instance.
@@ -58,13 +58,25 @@ internal ProjectItemDefinitionInstance(ProjectItemDefinition itemDefinition)
         {
             if (itemDefinition.MetadataCount > 0)
             {
-                _metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-
+                var copyOnWriteMetadataDictionary = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                 IEnumerable<ProjectMetadataInstance> projectMetadataInstances = itemDefinition.Metadata.Select(originalMetadata => new ProjectMetadataInstance(originalMetadata));
-                _metadata.ImportProperties(projectMetadataInstances);
+                copyOnWriteMetadataDictionary.ImportProperties(projectMetadataInstances);
+
+                _metadata = copyOnWriteMetadataDictionary;
             }
         }
 
+        /// <summary>
+        /// Initializes a new instance of the <see cref="ProjectItemDefinitionInstance"/> class.
+        /// </summary>
+        /// <param name="itemType">The type of item this definition object represents.</param>
+        /// <param name="metadata">A (possibly null) collection of the metadata associated with this item definition.</param>
+        internal ProjectItemDefinitionInstance(string itemType, IDictionary<string, ProjectMetadataInstance> metadata)
+            : this(itemType)
+        {
+            _metadata = metadata;
+        }
+
         private ProjectItemDefinitionInstance()
         {
         }
@@ -95,7 +107,7 @@ public ICollection<ProjectMetadataInstance> Metadata
                     return ReadOnlyEmptyCollection<ProjectMetadataInstance>.Instance;
                 }
 
-                return new ReadOnlyCollection<ProjectMetadataInstance>(_metadata);
+                return new ReadOnlyCollection<ProjectMetadataInstance>(_metadata.Values);
             }
         }
 
@@ -110,21 +122,7 @@ public int MetadataCount
         /// <summary>
         /// Names of all metadata on this item definition
         /// </summary>
-        public IEnumerable<string> MetadataNames
-        {
-            get
-            {
-                if (_metadata == null)
-                {
-                    yield break;
-                }
-
-                foreach (ProjectMetadataInstance metadatum in _metadata)
-                {
-                    yield return metadatum.Name;
-                }
-            }
-        }
+        public IEnumerable<string> MetadataNames => _metadata == null ? Enumerable.Empty<string>() : _metadata.Keys;
 
         /// <summary>
         /// Implementation of IKeyed exposing the item type, so these
@@ -213,8 +211,9 @@ internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElem
         {
             ProjectItemDefinitionElement element = parent.ContainingProject.CreateItemDefinitionElement(ItemType);
             parent.AppendChild(element);
-            foreach (ProjectMetadataInstance metadataInstance in _metadata)
+            foreach (var kvp in _metadata)
             {
+                ProjectMetadataInstance metadataInstance = kvp.Value;
                 element.AddMetadata(metadataInstance.Name, metadataInstance.EvaluatedValue);
             }
 
@@ -224,7 +223,7 @@ internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElem
         void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _itemType);
-            translator.TranslateDictionary(ref _metadata, ProjectMetadataInstance.FactoryForDeserialization);
+            translator.TranslateDictionary(ref _metadata, ProjectMetadataInstance.FactoryForDeserialization, CreateMetadataCollection);
         }
 
         internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITranslator translator)
@@ -236,5 +235,10 @@ internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITransla
         }
 
         string IItemTypeDefinition.ItemType => _itemType;
+
+        private static IDictionary<string, ProjectMetadataInstance> CreateMetadataCollection(int capacity)
+        {
+            return new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+        }
     }
 }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index cf6fc186770..ce19ec7872f 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -77,7 +77,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// Mutability follows the project.
         /// </summary>
         internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, string definingFileEscaped)
-            : this(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, null /* no direct metadata */, null /* need to add item definition metadata */, definingFileEscaped)
+            : this(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, null /* no direct metadata */, null /* need to add item definition metadata */, definingFileEscaped, useItemDefinitionsWithoutModification: false)
         {
         }
 
@@ -94,9 +94,17 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// <remarks>
         /// Not public since the only creation scenario is setting on a project.
         /// </remarks>
-        internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata, List<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped)
+        internal ProjectItemInstance(
+            ProjectInstance project,
+            string itemType,
+            string includeEscaped,
+            string includeBeforeWildcardExpansionEscaped,
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+            IList<ProjectItemDefinitionInstance> itemDefinitions,
+            string definingFileEscaped,
+            bool useItemDefinitionsWithoutModification)
         {
-            CommonConstructor(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, directMetadata, itemDefinitions, definingFileEscaped);
+            CommonConstructor(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, directMetadata, itemDefinitions, definingFileEscaped, useItemDefinitionsWithoutModification);
         }
 
         /// <summary>
@@ -121,7 +129,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
                 metadata.ImportProperties(directMetadataInstances);
             }
 
-            CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped);
+            CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped, useItemDefinitionsWithoutModification: false);
         }
 
         /// <summary>
@@ -615,7 +623,7 @@ internal static ProjectItemInstance FactoryForDeserialization(ITranslator transl
         /// Add a metadata with the specified names and values.
         /// Overwrites any metadata with the same name already in the collection.
         /// </summary>
-        internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataDictionary)
+        internal void SetMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataDictionary)
         {
             _project.VerifyThrowNotImmutable();
 
@@ -682,33 +690,53 @@ internal ProjectItemElement ToProjectItemElement(ProjectElementContainer parent)
         /// Inherited item definition metadata may be null. It is assumed to ALREADY HAVE BEEN CLONED.
         /// Mutability follows the project.
         /// </summary>
-        private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUse, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata, List<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped)
+        private void CommonConstructor(
+            ProjectInstance projectToUse,
+            string itemTypeToUse,
+            string includeEscaped,
+            string includeBeforeWildcardExpansionEscaped,
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+            IList<ProjectItemDefinitionInstance> itemDefinitions,
+            string definingFileEscaped,
+            bool useItemDefinitionsWithoutModification)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectToUse, "project");
             ErrorUtilities.VerifyThrowArgumentLength(itemTypeToUse, "itemType");
             XmlUtilities.VerifyThrowArgumentValidElementName(itemTypeToUse);
             ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(itemTypeToUse), "OM_ReservedName", itemTypeToUse);
 
-            // TaskItems don't have an item type. So for their benefit, we have to lookup and add the regular item definition.
-            List<ProjectItemDefinitionInstance> inheritedItemDefinitions = (itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(itemDefinitions);
+            IList<ProjectItemDefinitionInstance> inheritedItemDefinitions;
+            if (itemDefinitions == null || !useItemDefinitionsWithoutModification)
+            {
+                // TaskItems don't have an item type. So for their benefit, we have to lookup and add the regular item definition.
+                inheritedItemDefinitions = (itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(itemDefinitions);
 
-            ProjectItemDefinitionInstance itemDefinition;
-            if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
+                ProjectItemDefinitionInstance itemDefinition;
+                if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
+                {
+                    inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
+                    inheritedItemDefinitions.Add(itemDefinition);
+                }
+            }
+            else
             {
-                inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
-                inheritedItemDefinitions.Add(itemDefinition);
+                // In this case the caller specifying useItemDefinitionsWithoutModification is guaranteeing that
+                // the itemDefinitions collection contains all necessary definitions (including the definition
+                // associated with itemTypeToUse) and, for performance reasons, the provided (immutable) collection
+                // should be used as is.
+                inheritedItemDefinitions = itemDefinitions;
             }
 
             _project = projectToUse;
             _itemType = itemTypeToUse;
             _taskItem = new TaskItem(
-                                        includeEscaped,
-                                        includeBeforeWildcardExpansionEscaped,
-                                        directMetadata?.DeepClone(), // copy on write!
-                                        inheritedItemDefinitions,
-                                        _project.Directory,
-                                        _project.IsImmutable,
-                                        definingFileEscaped);
+                            includeEscaped,
+                            includeBeforeWildcardExpansionEscaped,
+                            directMetadata?.DeepClone(), // copy on write!
+                            inheritedItemDefinitions,
+                            _project.Directory,
+                            _project.IsImmutable,
+                            definingFileEscaped);
         }
 
         /// <summary>
@@ -751,7 +779,7 @@ internal sealed class TaskItem :
             /// Lazily created, as there are huge numbers of items generated in
             /// a build that have no metadata at all.
             /// </remarks>
-            private CopyOnWritePropertyDictionary<ProjectMetadataInstance> _directMetadata;
+            private ICopyOnWritePropertyDictionary<ProjectMetadataInstance> _directMetadata;
 
             /// <summary>
             /// Cached value of the fullpath metadata. All other metadata are computed on demand.
@@ -765,7 +793,7 @@ internal sealed class TaskItem :
             /// be item definitions inherited from items that were
             /// used to create this item.
             /// </summary>
-            private List<ProjectItemDefinitionInstance> _itemDefinitions;
+            private IList<ProjectItemDefinitionInstance> _itemDefinitions;
 
             /// <summary>
             /// Directory of the associated project. If this is available,
@@ -794,8 +822,8 @@ internal TaskItem(string includeEscaped, string definingFileEscaped)
             internal TaskItem(
                               string includeEscaped,
                               string includeBeforeWildcardExpansionEscaped,
-                              CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
-                              List<ProjectItemDefinitionInstance> itemDefinitions,
+                              ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+                              IList<ProjectItemDefinitionInstance> itemDefinitions,
                               string projectDirectory,
                               bool immutable,
                               string definingFileEscaped) // the actual project file (or import) that defines this item.
@@ -909,11 +937,11 @@ public ICollection MetadataNames
             {
                 get
                 {
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
+                    ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
 
                     List<string> names = new List<string>(capacity: metadataCollection.Count + FileUtilities.ItemSpecModifiers.All.Length);
 
-                    foreach (ProjectMetadataInstance metadatum in metadataCollection)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadataCollection)
                     {
                         names.Add(metadatum.Name);
                     }
@@ -1058,11 +1086,11 @@ public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
             /// </summary>
             /// <param name="list">The source list to return metadata from.</param>
             /// <returns>An array of string key-value pairs representing metadata.</returns>
-            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
                 var result = new List<KeyValuePair<string, string>>(list.Count);
 
-                foreach (var projectMetadataInstance in list)
+                foreach (var projectMetadataInstance in list.Values)
                 {
                     if (projectMetadataInstance != null)
                     {
@@ -1074,9 +1102,9 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnW
                 return result.ToArray();
             }
 
-            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
-                foreach (var projectMetadataInstance in list)
+                foreach (var projectMetadataInstance in list.Values)
                 {
                     if (projectMetadataInstance != null)
                     {
@@ -1093,7 +1121,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWriteP
             /// This is a read-only collection. To modify the metadata, use <see cref="SetMetadata(string, string)"/>.
             /// Computed, not necessarily fast.
             /// </summary>
-            internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollection
+            internal ICopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollection
             {
                 get
                 {
@@ -1137,7 +1165,7 @@ IEnumerable<ProjectMetadataInstance> metaData()
                         // Finally any direct metadata win.
                         if (_directMetadata != null)
                         {
-                            foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                            foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)_directMetadata)
                             {
                                 if (metadatum != null)
                                 {
@@ -1287,16 +1315,16 @@ public string GetMetadataEscaped(string metadataName)
                     ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
                 }
 
-                ProjectMetadataInstance metadatum;
                 if (_directMetadata != null)
                 {
-                    metadatum = _directMetadata[metadataName];
-                    if (metadatum != null)
+                    string escapedValue = _directMetadata.GetEscapedValue(metadataName);
+                    if (escapedValue != null)
                     {
-                        return metadatum.EvaluatedValueEscaped;
+                        return escapedValue;
                     }
                 }
 
+                ProjectMetadataInstance metadatum;
                 metadatum = GetItemDefinitionMetadata(metadataName);
 
                 if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
@@ -1404,7 +1432,10 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                     }
                     else if (_itemDefinitions != null)
                     {
-                        destinationAsTaskItem._itemDefinitions.AddRange(_itemDefinitions);
+                        for (int i = 0; i < _itemDefinitions.Count; i++)
+                        {
+                            destinationAsTaskItem._itemDefinitions.Add(_itemDefinitions[i]);
+                        }
                     }
                 }
                 else if (destinationItem is IMetadataContainer destinationItemAsMetadataContainer)
@@ -1428,7 +1459,7 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                 else
                 {
                     // OK, most likely the destination item was a Microsoft.Build.Utilities.TaskItem.
-                    foreach (ProjectMetadataInstance metadatum in MetadataCollection)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)MetadataCollection)
                     {
                         // When copying metadata, we do NOT overwrite metadata already on the destination item.
                         string destinationValue = destinationItem.GetMetadata(metadatum.Name);
@@ -1460,7 +1491,7 @@ public IDictionary CloneCustomMetadata()
                 var metadata = MetadataCollection;
                 Dictionary<string, string> clonedMetadata = new Dictionary<string, string>(metadata.Count, MSBuildNameIgnoreCaseComparer.Default);
 
-                foreach (ProjectMetadataInstance metadatum in metadata)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadata)
                 {
                     clonedMetadata[metadatum.Name] = metadatum.EvaluatedValue;
                 }
@@ -1477,7 +1508,7 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
             {
                 Dictionary<string, string> clonedMetadata = new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
 
-                foreach (ProjectMetadataInstance metadatum in MetadataCollection)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)MetadataCollection)
                 {
                     clonedMetadata[metadatum.Name] = metadatum.EvaluatedValueEscaped;
                 }
@@ -1501,8 +1532,17 @@ void ITranslatable.Translate(ITranslator translator)
                 translator.Translate(ref _isImmutable);
                 translator.Translate(ref _definingFileEscaped);
 
-                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
-                translator.TranslateDictionary(ref _directMetadata, ProjectMetadataInstance.FactoryForDeserialization);
+                TranslatorHelpers.Translate(
+                    translator,
+                    ref _itemDefinitions,
+                    ProjectItemDefinitionInstance.FactoryForDeserialization,
+                    (capacity) => new List<ProjectItemDefinitionInstance>(capacity));
+
+                TranslatorHelpers.TranslateDictionary(
+                    translator,
+                    ref _directMetadata,
+                    ProjectMetadataInstance.FactoryForDeserialization,
+                    (capacity) => new CopyOnWritePropertyDictionary<ProjectMetadataInstance>());
 
                 if (_itemDefinitions?.Count == 0)
                 {
@@ -1580,32 +1620,33 @@ public bool Equals(TaskItem other)
                 // the set of metadata names on 'this', to avoid computing the full metadata collection
                 // of both 'this' and 'other'. Once we have the names for 'this', we enumerate 'other'
                 // and ensure the names we see there are set-equal to the names we produce here.
-                var thisNames = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                int capacity = _itemDefinitions?.Count ?? 0 + _directMetadata?.Count ?? 0;
+                var thisNames = new HashSet<string>(capacity, MSBuildNameIgnoreCaseComparer.Default);
 
                 if (_itemDefinitions is not null)
                 {
-                    foreach (ProjectItemDefinitionInstance itemDefinition in _itemDefinitions)
+                    for (int i = 0; i < _itemDefinitions.Count; i++)
                     {
-                        thisNames.UnionWith(itemDefinition.MetadataNames);
+                        thisNames.UnionWith(_itemDefinitions[i].MetadataNames);
                     }
                 }
 
                 if (_directMetadata is not null)
                 {
-                    foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)_directMetadata)
                     {
                         thisNames.Add(metadatum.Name);
                     }
                 }
 
-                CopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
+                ICopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
 
                 if (otherMetadata.Count != thisNames.Count)
                 {
                     return false;
                 }
 
-                foreach (ProjectMetadataInstance metadatum in otherMetadata)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)otherMetadata)
                 {
                     string name = metadatum.Name;
 
@@ -1702,7 +1743,11 @@ private void ReadInternString(ITranslator translator, LookasideStringInterner in
             /// </summary>
             internal void TranslateWithInterning(ITranslator translator, LookasideStringInterner interner)
             {
-                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
+                TranslatorHelpers.Translate(
+                    translator,
+                    ref _itemDefinitions,
+                    ProjectItemDefinitionInstance.FactoryForDeserialization,
+                    (capacity) => new List<ProjectItemDefinitionInstance>(capacity));
                 translator.Translate(ref _isImmutable);
                 translator.Translate(ref _includeEscaped);
 
@@ -1711,14 +1756,14 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                     WriteInternString(translator, interner, ref _includeBeforeWildcardExpansionEscaped);
                     WriteInternString(translator, interner, ref _definingFileEscaped);
 
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
+                    ICopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
 
                     // Intern the metadata
                     if (translator.TranslateNullable(temp))
                     {
                         int count = temp.Count;
                         translator.Writer.Write(count);
-                        foreach (ProjectMetadataInstance metadatum in temp)
+                        foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)temp)
                         {
                             int key = interner.Intern(metadatum.Name);
                             int value = interner.Intern(metadatum.EvaluatedValueEscaped);
@@ -1779,7 +1824,7 @@ internal ProjectMetadataInstance GetMetadataObject(string name)
             /// Add a metadata with the specified name and value.
             /// Overwrites any metadata with the same name already in the collection.
             /// </summary>
-            internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata)
+            internal void SetMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata)
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
@@ -1891,14 +1936,13 @@ private string GetBuiltInMetadataEscaped(string name)
             /// </summary>
             private ProjectMetadataInstance GetItemDefinitionMetadata(string metadataName)
             {
-
                 // Check any inherited item definition metadata first. It's more like
                 // direct metadata, but we didn't want to copy the tables.
                 if (_itemDefinitions != null)
                 {
-                    foreach (ProjectItemDefinitionInstance itemDefinition in _itemDefinitions)
+                    for (int i = 0; i < _itemDefinitions.Count; i++)
                     {
-                        ProjectMetadataInstance metadataFromDefinition = itemDefinition.GetMetadata(metadataName);
+                        ProjectMetadataInstance metadataFromDefinition = _itemDefinitions[i].GetMetadata(metadataName);
 
                         if (metadataFromDefinition != null)
                         {
@@ -2051,7 +2095,7 @@ private ProjectItemInstance CreateItem(string includeEscaped, string includeBefo
                         itemDefinitionsClone.Add(sourceItemDefinition);
                     }
 
-                    return new ProjectItemInstance(_project, ItemType, includeEscaped, includeBeforeWildcardExpansionEscaped, source._taskItem._directMetadata, itemDefinitionsClone, definingProject);
+                    return new ProjectItemInstance(_project, ItemType, includeEscaped, includeBeforeWildcardExpansionEscaped, source._taskItem._directMetadata, itemDefinitionsClone, definingProject, useItemDefinitionsWithoutModification: false);
                 }
             }
 
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index 9c2d9ed766e..13b3c076958 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -33,6 +33,11 @@ public class ProjectPropertyInstance : IKeyed, IValued, IProperty, IEquatable<Pr
         /// </summary>
         private string _escapedValue;
 
+        /// <summary>
+        /// Property location in xml file. Can be empty.
+        /// </summary>
+        private (string File, int Line, int Column) _location;
+
         /// <summary>
         /// Private constructor
         /// </summary>
@@ -80,6 +85,11 @@ public string EvaluatedValue
         /// </summary>
         public virtual bool IsImmutable => false;
 
+        /// <summary>
+        /// Gets or sets object's location in xml file.
+        /// </summary>
+        public (string File, int Line, int Column) Location { get => _location; }
+
         /// <summary>
         /// Evaluated value of the property, escaped as necessary.
         /// Setter assumes caller has protected global properties, if necessary.
@@ -91,7 +101,7 @@ string IProperty.EvaluatedValueEscaped
             {
                 if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty && !Traits.LogAllEnvironmentVariables)
                 {
-                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);
+                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue, string.Empty, 0, 0);
                     args.BuildEventContext = envProperty.loggingContext.BuildEventContext;
                     envProperty.loggingContext.LogBuildEvent(args);
                     envProperty._loggedEnvProperty = true;
@@ -100,8 +110,25 @@ string IProperty.EvaluatedValueEscaped
                 return _escapedValue;
             }
         }
+
+        string IProperty.GetEvaluatedValueEscaped(IElementLocation location)
+        {
+            if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty && !Traits.LogAllEnvironmentVariables)
+            {
+                EnvironmentVariableReadEventArgs args = new(Name, _escapedValue, location.File, location.Line, location.Column);
+                args.BuildEventContext = envProperty.loggingContext.BuildEventContext;
+                envProperty.loggingContext.LogBuildEvent(args);
+                envProperty._loggedEnvProperty = true;
+            }
+
+            // the location is handy in BuildCheck messages.
+            _location = (location.File, location.Line, location.Column);
+
+            return _escapedValue;
+        }
+
         /// <summary>
-        /// Implementation of IKeyed exposing the property name
+        /// Implementation of IKeyed exposing the property name.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
         string IKeyed.Key => Name;
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 7dc448e6fb5..d254e53458d 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -881,7 +881,7 @@ public int Compare(object o1, object o2)
 
         public virtual void Shutdown()
         {
-            Traits.LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES")) && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4);
+            Traits.LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"));
         }
 
         internal abstract void ResetConsoleLoggerState();
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 22921695dea..394d752372b 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -40,5 +40,6 @@ public enum BinaryLogRecordKind
         TaskParameter,
         ResponseFileUsed,
         AssemblyLoad,
+        BuildSubmissionStarted,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index abf9e4e80c9..1e7ab846695 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -59,7 +59,8 @@ void DeferredInitialize(
     /// by implementing IEventSource and raising corresponding events.
     /// </summary>
     /// <remarks>The class is public so that we can call it from MSBuild.exe when replaying a log file.</remarks>
-    public sealed class BinaryLogReplayEventSource : EventArgsDispatcher,
+    public sealed class BinaryLogReplayEventSource :
+        EventArgsDispatcher,
         IBinaryLogReplaySource
     {
         private int? _fileFormatVersion;
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index d4c37461938..5ad623deb77 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -73,14 +73,17 @@ public sealed class BinaryLogger : ILogger
         //   - TaskStartedEventArgs: Added TaskAssemblyLocation property
         // version 21:
         //   - TaskParameterEventArgs: Added ParameterName and PropertyName properties
-
+        // version 22:
+        //    - extend EnvironmentVariableRead with location where environment variable was used.
+        // version 23:
+        //    - new record kind: BuildSubmissionStartedEventArgs
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
         internal const int ForwardCompatibilityMinimalVersion = 18;
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 21;
+        internal const int FileFormatVersion = 23;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
@@ -188,6 +191,7 @@ public void Initialize(IEventSource eventSource)
                 if (CollectProjectImports != ProjectImportsCollectionMode.None && replayEventSource == null)
                 {
                     projectImportsCollector = new ProjectImportsCollector(FilePath, CollectProjectImports == ProjectImportsCollectionMode.ZipFile);
+                    projectImportsCollector.FileIOExceptionEvent += EventSource_AnyEventRaised;
                 }
 
                 if (eventSource is IEventSource3 eventSource3)
@@ -320,6 +324,7 @@ public void Shutdown()
                     projectImportsCollector.DeleteArchive();
                 }
 
+                projectImportsCollector.FileIOExceptionEvent -= EventSource_AnyEventRaised;
                 projectImportsCollector = null;
             }
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 358c410265f..9bbf41c3050 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Buffers;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
@@ -13,6 +12,7 @@
 using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
@@ -296,6 +296,7 @@ void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType re
             {
                 BinaryLogRecordKind.BuildStarted => ReadBuildStartedEventArgs(),
                 BinaryLogRecordKind.BuildFinished => ReadBuildFinishedEventArgs(),
+                BinaryLogRecordKind.BuildSubmissionStarted => ReadBuildSubmissionStartedEventArgs(),
                 BinaryLogRecordKind.ProjectStarted => ReadProjectStartedEventArgs(),
                 BinaryLogRecordKind.ProjectFinished => ReadProjectFinishedEventArgs(),
                 BinaryLogRecordKind.TargetStarted => ReadTargetStartedEventArgs(),
@@ -619,6 +620,29 @@ private BuildEventArgs ReadBuildFinishedEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadBuildSubmissionStartedEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+
+            IDictionary<string, string>? globalProperties = null;
+            globalProperties = ReadStringDictionary() ?? new Dictionary<string, string>();
+
+            var entryProjectsFullPath = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
+            var targetNames = ReadStringIEnumerable() ?? Enumerable.Empty<string>();
+            var flags = (BuildRequestDataFlags)ReadInt32();
+            var submissionId = ReadInt32();
+
+            var e = new BuildSubmissionStartedEventArgs(
+                (IReadOnlyDictionary<string, string?>)globalProperties,
+                entryProjectsFullPath,
+                targetNames,
+                flags,
+                submissionId);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
@@ -1095,14 +1119,23 @@ private BuildEventArgs ReadEnvironmentVariableReadEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            var environmentVariableName = ReadDeduplicatedString();
+            string? environmentVariableName = ReadDeduplicatedString();
+            int line = 0;
+            int column = 0;
+            string? fileName = null;
+            if (_fileFormatVersion >= 22)
+            {
+                line = ReadInt32();
+                column = ReadInt32();
+                fileName = ReadDeduplicatedString();
+            }
 
-            var e = new EnvironmentVariableReadEventArgs(
-                environmentVariableName,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Importance);
+            BuildEventArgs e = new EnvironmentVariableReadEventArgs(
+                    environmentVariableName ?? string.Empty,
+                    fields.Message,
+                    fileName ?? string.Empty,
+                    line,
+                    column);
             SetCommonFields(e, fields);
 
             return e;
@@ -1548,6 +1581,28 @@ private ITaskItem ReadTaskItem()
             return list;
         }
 
+        private IEnumerable<string>? ReadStringIEnumerable()
+        {
+            int count = ReadInt32();
+            if (count == 0)
+            {
+                return null;
+            }
+
+            var list = new string[count];
+
+            for (int i = 0; i < count; i++)
+            {
+                string? item = ReadDeduplicatedString();
+                if (item is not null)
+                {
+                    list[i] = item;
+                }
+            }
+
+            return list;
+        }
+
         private string ReadString()
         {
             string text = _binaryReader.ReadString();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index a9a734b1638..d2b6850df6b 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Buffers;
 using System.Collections;
 using System.Collections.Generic;
 using System.Globalization;
@@ -14,8 +13,8 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 
 #nullable disable
@@ -185,6 +184,7 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     TargetFinished
                     ProjectStarted
                     ProjectFinished
+                    BuildSubmissionStarted
                     BuildStarted
                     BuildFinished
                     ProjectEvaluationStarted
@@ -212,6 +212,7 @@ private BinaryLogRecordKind WriteCore(BuildEventArgs e)
                 case BuildWarningEventArgs buildWarning: return Write(buildWarning);
                 case ProjectStartedEventArgs projectStarted: return Write(projectStarted);
                 case ProjectFinishedEventArgs projectFinished: return Write(projectFinished);
+                case BuildSubmissionStartedEventArgs buildSubmissionStarted: return Write(buildSubmissionStarted);
                 case BuildStartedEventArgs buildStarted: return Write(buildStarted);
                 case BuildFinishedEventArgs buildFinished: return Write(buildFinished);
                 case ProjectEvaluationStartedEventArgs projectEvaluationStarted: return Write(projectEvaluationStarted);
@@ -338,6 +339,18 @@ private BinaryLogRecordKind Write(ProjectEvaluationFinishedEventArgs e)
             return BinaryLogRecordKind.ProjectEvaluationFinished;
         }
 
+        private BinaryLogRecordKind Write(BuildSubmissionStartedEventArgs e)
+        {
+            WriteBuildEventArgsFields(e, writeMessage: false);
+            Write(e.GlobalProperties);
+            WriteStringList(e.EntryProjectsFullPath);
+            WriteStringList(e.TargetNames);
+            Write((int)e.Flags);
+            Write(e.SubmissionId);
+
+            return BinaryLogRecordKind.BuildSubmissionStarted;
+        }
+
         private BinaryLogRecordKind Write(ProjectStartedEventArgs e)
         {
             WriteBuildEventArgsFields(e, writeMessage: false);
@@ -547,10 +560,15 @@ private BinaryLogRecordKind Write(PropertyInitialValueSetEventArgs e)
 
         private BinaryLogRecordKind Write(EnvironmentVariableReadEventArgs e)
         {
-            WriteMessageFields(e, writeImportance: true);
+            WriteMessageFields(e, writeImportance: false);
             WriteDeduplicatedString(e.EnvironmentVariableName);
+            Write(e.LineNumber);
+            Write(e.ColumnNumber);
+            WriteDeduplicatedString(e.File);
+
             return BinaryLogRecordKind.EnvironmentVariableRead;
         }
+
         private BinaryLogRecordKind Write(ResponseFileUsedEventArgs e)
         {
             WriteMessageFields(e);
@@ -1041,6 +1059,16 @@ private void Write(IEnumerable<KeyValuePair<string, string>> keyValuePairs)
             nameValueListBuffer.Clear();
         }
 
+        private void WriteStringList(IEnumerable<string> items)
+        {
+            int length = items.Count();
+            Write(length);
+            foreach (string entry in items)
+            {
+                WriteDeduplicatedString(entry);
+            }
+        }
+
         private void WriteNameValueList()
         {
             if (nameValueListBuffer.Count == 0)
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsDispatcher.cs b/src/Build/Logging/BinaryLogger/EventArgsDispatcher.cs
similarity index 100%
rename from src/Build/Logging/BinaryLogger/BuildEventArgsDispatcher.cs
rename to src/Build/Logging/BinaryLogger/EventArgsDispatcher.cs
diff --git a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
index 536d7f9ed48..8f46bdbc733 100644
--- a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
+++ b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
@@ -7,6 +7,8 @@
 using System.IO.Compression;
 using System.Text;
 using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -33,6 +35,7 @@ internal class ProjectImportsCollector
 
         // this will form a chain of file write tasks, running sequentially on a background thread
         private Task _currentTask = Task.CompletedTask;
+        internal event AnyEventHandler? FileIOExceptionEvent;
 
         internal static void FlushBlobToFile(
             string logFilePath,
@@ -143,8 +146,10 @@ bool TryAddFile()
                     addFileWorker(filePath);
                     return true;
                 }
-                catch
-                { }
+                catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
+                {
+                    InvokeFileIOErrorEvent(filePath, TaskLoggingHelper.GetInnerExceptionMessageString(e));
+                }
 
                 return false;
             }
@@ -166,6 +171,16 @@ private void AddFileCore(string filePath)
             AddFileData(filePath, content, null);
         }
 
+        private void InvokeFileIOErrorEvent(string filePath, string message)
+        {
+            BuildEventArgs args = new BuildMessageEventArgs(
+                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectImportsCollectorFileIOFail", filePath, message),
+                helpKeyword: null,
+                senderName: nameof(ProjectImportsCollector),
+                MessageImportance.Low);
+            FileIOExceptionEvent?.Invoke(this, args);
+        }
+
         /// <remarks>
         /// This method doesn't need locking/synchronization because it's only called
         /// from a task that is chained linearly
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 280d61a3bad..d59bbb81e46 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1212,6 +1212,10 @@ public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
                     propertyOutputMap[evaluationKey] = value;
                 }
             }
+            else if (e is BuildCanceledEventArgs buildCanceled)
+            {
+                Console.WriteLine(e.Message);
+            }
         }
 
         private void DisplayDeferredStartedEvents(BuildEventContext e)
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 61f750ff472..49573c943fb 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -517,8 +517,8 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                     setColor(ConsoleColor.DarkGray);
                 }
 
-                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty ?
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentDerivedProperty.EnvironmentVariableName, e.Message)
+                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty
+                    ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentDerivedProperty.EnvironmentVariableName, e.Message)
                     : e.Message ?? String.Empty;
 
                 // Include file information if present.
@@ -587,6 +587,10 @@ public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
                     }
                 }
             }
+            else if (e is BuildCanceledEventArgs buildCanceled)
+            {;
+                Console.WriteLine(e.Message);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index aeedba3e4c2..b06858fa47a 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -132,8 +132,11 @@
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="BackEnd\BuildManager\BuildManager.cs" />
     <Compile Include="BackEnd\BuildManager\BuildParameters.cs" />
+    <Compile Include="BackEnd\BuildManager\BuildRequestDataBase.cs" />
+    <Compile Include="BackEnd\BuildManager\BuildSubmissionBase.cs" />
     <Compile Include="BackEnd\BuildManager\CacheSerialization.cs" />
     <Compile Include="BackEnd\BuildManager\CacheAggregator.cs" />
+    <Compile Include="BackEnd\BuildManager\GlobalPropertiesLookup.cs" />
     <Compile Include="BackEnd\BuildManager\ProjectIsolationMode.cs" />
     <Compile Include="BackEnd\Client\MSBuildClientPacketPump.cs" />
     <Compile Include="BackEnd\Client\MSBuildClientExitType.cs" />
@@ -151,49 +154,13 @@
     <Compile Include="BackEnd\Components\FileAccesses\FileAccessReport.cs" />
     <Compile Include="BackEnd\Components\FileAccesses\OutOfProcNodeFileAccessManager.cs" />
     <Compile Include="BackEnd\Components\FileAccesses\ProcessReport.cs" />
+    <Compile Include="BackEnd\Shared\EventsCreatorHelper.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\AssemblyLoadsTracker.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
-    <Compile Include="BuildCheck\Acquisition\AnalyzerAcquisitionData.cs" />
-    <Compile Include="BuildCheck\Acquisition\BuildCheckAcquisitionModule.cs" />
-    <Compile Include="BuildCheck\Acquisition\IBuildCheckAcquisitionModule.cs" />
-    <Compile Include="BuildCheck\Analyzers\SharedOutputPathAnalyzer.cs" />
-    <Compile Include="BuildCheck\Analyzers\DoubleWritesAnalyzer.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationException.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildCheckForwardingLogger.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildEventsProcessor.cs" />
-    <Compile Include="BuildCheck\Infrastructure\IBuildCheckManagerProvider.cs" />
-    <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManager.cs" />
-    <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManagerProvider.cs" />
-    <Compile Include="BuildCheck\Infrastructure\TracingReporter.cs" />
-    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigFile.cs" />
-    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigGlobsMatcher.cs" />
-    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigParser.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationErrorScope.cs" />
-    <Compile Include="BuildCheck\OM\BuildCheckDataContext.cs" />
-    <Compile Include="BuildCheck\API\BuildAnalyzer.cs" />
-    <Compile Include="BuildCheck\API\BuildAnalyzerConfiguration.cs" />
-    <Compile Include="BuildCheck\API\BuildCheckResult.cs" />
-    <Compile Include="BuildCheck\API\BuildAnalyzerResultSeverity.cs" />
-    <Compile Include="BuildCheck\API\BuildAnalyzerRule.cs" />
-    <Compile Include="BuildCheck\API\ConfigurationContext.cs" />
-    <Compile Include="BuildCheck\API\EvaluationAnalysisScope.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildAnalyzerConfigurationInternal.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildAnalyzerWrapper.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildCheckCentralContext.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildCheckConnectorLogger.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildCheckContext.cs" />
-    <Compile Include="BuildCheck\Infrastructure\BuildCheckManagerProvider.cs" />
-    <Compile Include="BuildCheck\Infrastructure\ConfigurationProvider.cs" />
-    <Compile Include="BuildCheck\Infrastructure\CustomConfigurationData.cs" />
-    <Compile Include="BuildCheck\API\IBuildCheckRegistrationContext.cs" />
-    <Compile Include="BuildCheck\Infrastructure\IBuildCheckManager.cs" />
-    <Compile Include="BuildCheck\Logging\IBuildAnalysisLoggingContextFactory.cs" />
-    <Compile Include="BuildCheck\OM\EvaluatedPropertiesAnalysisData.cs" />
-    <Compile Include="BuildCheck\OM\ParsedItemsAnalysisData.cs" />
-    <Compile Include="BuildCheck\Utilities\Constants.cs" />
-    <Compile Include="BuildCheck\Utilities\EnumerableExtensions.cs" />
+    <Compile Include="BackEnd\Shared\BuildResultBase.cs" />
+    <Compile Include="BuildCheck\**\*.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
     <Compile Include="Evaluation\PropertiesUseTracker.cs" />
     <Compile Include="FileAccess\DesiredAccess.cs" />
@@ -202,8 +169,6 @@
     <Compile Include="FileAccess\ProcessData.cs" />
     <Compile Include="FileAccess\ReportedFileOperation.cs" />
     <Compile Include="FileAccess\RequestedAccess.cs" />
-    <Compile Include="BuildCheck\Logging\AnalyzerLoggingContext.cs" />
-    <Compile Include="BuildCheck\Logging\AnalyzerLoggingContextFactory.cs" />
     <Compile Include="Instance\IPropertyElementWithLocation.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
@@ -285,14 +250,6 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResultFactory.cs" />
     <Compile Include="BackEnd\Node\LoggingNodeConfiguration.cs" />
     <Compile Include="BackEnd\Shared\ConfigurationMetadata.cs" />
-    <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
-    <Compile Include="Collections\ConcurrentStackExtensions.cs" />
-    <Compile Include="Collections\LookasideStringInterner.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSet.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
     <Compile Include="Construction\ImplicitImportLocation.cs" />
     <Compile Include="Construction\ProjectSdkElement.cs" />
     <Compile Include="Definition\ProjectOptions.cs" />
@@ -402,6 +359,9 @@
     <Compile Include="BackEnd\TaskExecutionHost\TaskExecutionHost.cs" />
     <!-- #### COLLECTIONS ### -->
     <Compile Include="..\Shared\CollectionHelpers.cs" />
+    <Compile Include="Collections\ArrayDictionary.cs" />
+    <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
+    <Compile Include="Collections\ConcurrentStackExtensions.cs" />
     <Compile Include="Collections\ConvertingEnumerable.cs" />
     <Compile Include="Collections\CopyOnReadEnumerable.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
@@ -411,17 +371,25 @@
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="Collections\HashTableUtility.cs" />
     <Compile Include="Collections\IConstrainableDictionary.cs" />
+    <Compile Include="Collections\ICopyOnWritePropertyDictionary.cs" />
     <Compile Include="Collections\IItemDictionary.cs" />
+    <Compile Include="Collections\IMultiDictionary.cs" />
     <Compile Include="Collections\ItemDictionary.cs" />
     <Compile Include="Collections\IImmutable.cs" />
     <Compile Include="Collections\MultiDictionary.cs" />
     <Compile Include="Collections\IValued.cs" />
+    <Compile Include="Collections\LookasideStringInterner.cs" />
     <Compile Include="Collections\PropertyDictionary.cs" />
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
     <Compile Include="Collections\ReadOnlyConvertingDictionary.cs" />
-    <!-- ######################## -->
+    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableValuedEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\RetrievableEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\RetrievableValuedEntryHashSet.cs" />
     <Compile Include="Collections\WeakValueDictionary.cs" />
-    <Compile Include="Collections\ArrayDictionary.cs" />
     <!-- #### CONSTRUCTION MODEL ### -->
     <Compile Include="Construction\ProjectElement.cs" />
     <Compile Include="Construction\ProjectElementContainer.cs" />
@@ -519,7 +487,6 @@
     <Compile Include="Evaluation\ProjectRootElementCacheBase.cs" />
     <Compile Include="Evaluation\ProjectRootElementCache.cs" />
     <Compile Include="Evaluation\SimpleProjectRootElementCache.cs" />
-    <Compile Include="Evaluation\ProjectStringCache.cs" />
     <Compile Include="Evaluation\SemiColonTokenizer.cs" />
     <Compile Include="Evaluation\StringMetadataTable.cs" />
     <Compile Include="Evaluation\ExpressionShredder.cs" />
@@ -536,7 +503,13 @@
     <!-- #### INSTANCE MODEL ### -->
     <Compile Include="Instance\IImmutableInstanceProvider.cs" />
     <Compile Include="Instance\ImmutableProjectCollections\ImmutableElementCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableGlobalPropertiesCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDefinitionsListConverter.cs" />
     <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDictionary.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableLinkedMultiDictionaryConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutablePropertyCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableStringValuedListConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableValuedElementCollectionConverter.cs" />
     <Compile Include="Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="Instance\HostServices.cs" />
     <Compile Include="Instance\ProjectTargetInstanceChild.cs" />
@@ -567,7 +540,7 @@
     <Compile Include="Logging\BinaryLogger\BinaryLogger.cs" />
     <Compile Include="Logging\BinaryLogger\BinaryLogRecordKind.cs" />
     <Compile Include="Logging\BinaryLogger\BinaryLogReplayEventSource.cs" />
-    <Compile Include="Logging\BinaryLogger\BuildEventArgsDispatcher.cs" />
+    <Compile Include="Logging\BinaryLogger\EventArgsDispatcher.cs" />
     <Compile Include="Logging\BinaryLogger\BuildEventArgsFieldFlags.cs" />
     <Compile Include="Logging\BinaryLogger\BuildEventArgsFields.cs" />
     <Compile Include="Logging\BinaryLogger\BuildEventArgsReader.cs" />
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index c0165f577a5..4618292cc2d 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
+using System.Threading;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -234,18 +235,27 @@ public UsingTaskParameterGroupElement Create(UsingTaskParameterGroupElementLink
 
         #region Linked classes helpers
         // Using the pattern with overloaded classes that provide "Link" object so we ensure we do not increase the
-        // memory storage of original items (with the Link field) while it is small, some of the MSbuild items can be created
+        // memory storage of original items (with the Link field) while it is small, some of the MSBuild items can be created
         // in millions so it does adds up otherwise.
 
         private class LinkedProjectItem : ProjectItem, ILinkableObject, IImmutableInstanceProvider<ProjectItemInstance>
         {
+            private ProjectItemInstance _immutableInstance;
+
             internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemLink link)
                 : base(xml, project)
             {
                 Link = link;
             }
 
-            public ProjectItemInstance ImmutableInstance { get; set; }
+            public ProjectItemInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectItemInstance GetOrSetImmutableInstance(ProjectItemInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             internal override ProjectItemLink Link { get; }
 
@@ -254,32 +264,54 @@ internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemL
 
         private class LinkedProjectItemDefinition : ProjectItemDefinition, ILinkableObject, IImmutableInstanceProvider<ProjectItemDefinitionInstance>
         {
+            private ProjectItemDefinitionInstance _immutableInstance;
+
             internal LinkedProjectItemDefinition(ProjectItemDefinitionLink link, Project project, string itemType)
                 : base(project, itemType)
             {
                 Link = link;
             }
 
-            public ProjectItemDefinitionInstance ImmutableInstance { get; set; }
+            public ProjectItemDefinitionInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectItemDefinitionInstance GetOrSetImmutableInstance(ProjectItemDefinitionInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             internal override ProjectItemDefinitionLink Link { get; }
             object ILinkableObject.Link => Link;
         }
 
-        private class LinkedProjectMetadata : ProjectMetadata, ILinkableObject
+        private class LinkedProjectMetadata : ProjectMetadata, ILinkableObject, IImmutableInstanceProvider<ProjectMetadataInstance>
         {
+            private ProjectMetadataInstance _immutableInstance;
+
             internal LinkedProjectMetadata(object parent, ProjectMetadataLink link)
                 : base(parent, link.Xml)
             {
                 Link = link;
             }
 
+            public ProjectMetadataInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectMetadataInstance GetOrSetImmutableInstance(ProjectMetadataInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
+
             internal override ProjectMetadataLink Link { get; }
             object ILinkableObject.Link => Link;
         }
 
         private class LinkedProjectProperty : ProjectProperty, ILinkableObject, IImmutableInstanceProvider<ProjectPropertyInstance>
         {
+            private ProjectPropertyInstance _immutableInstance;
+
             internal ProjectPropertyLink Link { get; }
             object ILinkableObject.Link => Link;
 
@@ -295,7 +327,14 @@ internal LinkedProjectProperty(Project project, ProjectPropertyLink link)
                 Link = link;
             }
 
-            public ProjectPropertyInstance ImmutableInstance { get; set;  }
+            public ProjectPropertyInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectPropertyInstance GetOrSetImmutableInstance(ProjectPropertyInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             public override string Name => Link.Name;
 
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 33bf5dc2a81..53df24ba2d9 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -139,6 +139,9 @@
   <data name="NoBuildInProgress" xml:space="preserve">
     <value>The operation cannot be completed because BeginBuild has not yet been called.</value>
   </data>
+  <data name="AbortingBuild" xml:space="preserve">
+    <value>Attempting to cancel the build...</value>
+  </data>
   <data name="WaitingForEndOfBuild" xml:space="preserve">
     <value>The operation cannot be completed because EndBuild has already been called but existing submissions have not yet completed.</value>
   </data>
@@ -2104,29 +2107,38 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
     </comment>
   </data>
-  <data name="CustomAnalyzerSuccessfulAcquisition" xml:space="preserve">
-    <value>Custom analyzer rule: {0} has been registered successfully.</value>
-    <comment>The message is emitted on successful loading of the custom analyzer rule in process.</comment>
+  <data name="CustomCheckSuccessfulAcquisition" xml:space="preserve">
+    <value>Custom check rule: '{0}' has been registered successfully.</value>
+    <comment>The message is emitted on successful loading of the custom check rule in process.</comment>
   </data>
-  <data name="CustomAnalyzerFailedAcquisition" xml:space="preserve">
-    <value>Failed to register the custom analyzer: {0}.</value>
-    <comment>The message is emitted on failed loading of the custom analyzer in process.</comment>
+  <data name="CustomCheckFailedAcquisition" xml:space="preserve">
+    <value>Failed to register the custom check: '{0}'.</value>
+    <comment>The message is emitted on failed loading of the custom check in process.</comment>
   </data>
-  <data name="CustomAnalyzerFailedRuleLoading" xml:space="preserve">
-    <value>Failed to instantiate the custom analyzer rule with the following exception: {0}.</value>
-    <comment>The message is emitted on failed loading of the custom analyzer rule in process.</comment>
+  <data name="CustomCheckFailedRuleLoading" xml:space="preserve">
+    <value>Failed to instantiate the custom check rule with the following exception: '{0}'.</value>
+    <comment>The message is emitted on failed loading of the custom check rule in process.</comment>
   </data>
-  <data name="CustomAnalyzerAssemblyNotExist" xml:space="preserve">
-    <value>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</value>
-    <comment>The message is emitted when the custom analyzer assembly can not be found.</comment>
+  <data name="CustomCheckAssemblyNotExist" xml:space="preserve">
+    <value>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</value>
+    <comment>The message is emitted when the custom check assembly can not be found.</comment>
   </data>
-  <data name="CustomAnalyzerBaseTypeNotAssignable" xml:space="preserve">
-    <value>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
-    <comment>The message is emitted when the custom analyzer assembly can not be successfully registered.</comment>
+  <data name="CustomCheckBaseTypeNotAssignable" xml:space="preserve">
+    <value>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
+    <comment>The message is emitted when the custom check assembly can not be successfully registered.</comment>
   </data>
   <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
     <value>Task assembly was loaded from '{0}' while the desired location was '{1}'.</value>
   </data>
+  <data name="ProjectImportsCollectorFileIOFail" xml:space="preserve">
+    <value>An exception occurred when adding the file '{0}', Exception: '{1}'</value>
+  </data>
+  <data name="BuildCheckEnabled" xml:space="preserve">
+    <value>The BuildCheck is enabled for this build.</value>
+  </data>
+  <data name="CustomCheckRegistered" xml:space="preserve">
+    <value>The custom check: '{0}' is registered for the build from the location: '{1}'.</value>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 6c08269e695..c59ba7f91b5 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="cs" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">Pokus o zrušení sestavování...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: Úloha {0} má více než jeden parametr s názvem {1}.</target>
@@ -126,6 +131,11 @@
         <target state="translated">Zápis není podporován.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">Pro tento build je povolena funkce BuildCheck.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Vytvoření otázky SELHALO. Vytváření bylo předčasně ukončeno, protože se při něm narazilo na cíl nebo úlohu, které nebyly aktuální.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">Nepodařilo se najít zadané sestavení vlastního analyzátoru: {0}. Zkontrolujte prosím, jestli existuje.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Nepodařilo se načíst vlastní typ analyzátoru: {0} ze sestavení: {1}. Ujistěte se, že dědí základní třídu Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Pokud se nemá jednat o vlastní analyzátor, neměl by být odkrytý. Další informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">Nepodařilo se zaregistrovat vlastní analyzátor: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">Nepovedlo se vytvořit instanci pravidla vlastního analyzátoru s následující výjimkou: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">Pravidlo vlastního analyzátoru: {0} se úspěšně zaregistrovalo.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">{1} neimportoval projekt {0} v ({2},{3}), protože se výraz vyhodnocuje na prázdný řetězec.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">Při přidávání souboru {0} došlo k výjimce. Výjimka:{1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Počáteční hodnota vlastnosti: $({0})={1} Zdroj: {2}</target>
@@ -557,7 +577,7 @@ Chyby: {3}</target>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">Překladač {0} se pokusil přeložit sadu SDK {1} a vrátil hodnotu null jako řetězec v seznamu upozornění nebo chyb.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 0536cd54244..1da92bd2dc3 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="de" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">Es wird versucht, den Buildvorgang abzubrechen...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: Die {0}-Aufgabe enthält mehrere Parameter mit dem Namen "{1}".</target>
@@ -126,6 +131,11 @@
         <target state="translated">Schreibvorgänge werden nicht unterstützt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">BuildCheck ist für diesen Build aktiviert.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Fehler beim Erstellen der Frage. Der Build wurde früh beendet, da ein Ziel oder eine Aufgabe gefunden wurde, die nicht aktuell war.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Analysetoolassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Fehler beim Laden des benutzerdefinierten Analysetooltyps „{0}“ aus der Assembly „{1}“. Stellen Sie sicher, dass es die Basisklasse „Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer“ erbt. Wenn es sich nicht um ein benutzerdefiniertes Analysetool handelt, sollte es nicht verfügbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">Fehler beim Registrieren des benutzerdefinierten Analysetools: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">Fehler beim Instanziieren der benutzerdefinierten Analysetoolregel mit der folgenden Ausnahme: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">Benutzerdefinierte Analysetoolregel {0} wurde erfolgreich registriert.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">Das Projekt "{0}" wurde nicht von "{1}" bei ({2},{3}) importiert, weil der Ausdruck in eine leere Zeichenfolge ausgewertet wurde.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">Ausnahme beim Hinzufügen der Datei „{0}“, Ausnahme: „{1}“</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Anfangswert der Eigenschaft: $({0})="{1}", Quelle: {2}</target>
@@ -557,7 +577,7 @@ Fehler: {3}</target>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">Der Resolver „{0}“ hat versucht, das SDK „{1}“ aufzulösen, und hat NULL als Zeichenfolge in der Liste der Warnungen oder Fehler zurückgegeben.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 110b467333d..df05725c5e4 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">Intentando cancelar la compilación...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: La tarea"{0}" tiene más de un parámetro denominado "{1}".</target>
@@ -126,6 +131,11 @@
         <target state="translated">No se admite la escritura.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">BuildCheck está habilitado para esta compilación.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">La creación de la pregunta ha FALLADO. La creación finalizó antes de tiempo al encontrar un objetivo o tarea que no estaba actualizado.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">No se ha podido encontrar el ensamblado del analizador personalizado especificado: {0}. Compruebe si existe.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">No se pudo cargar el tipo de analizador personalizado: {0} del ensamblado: {1}. Asegúrese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Si no está pensado para ser un analizador personalizado, entonces no debería exponerse. Más información: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">No se ha podido registrar el analizador personalizado: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">No se ha podido crear una instancia de la regla del analizador personalizado con la siguiente excepción: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">Regla del analizador personalizado: {0} se ha registrado correctamente.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">"{1}" no importó el proyecto "{0}" en ({2},{3}) porque la expresión se evalúa en una cadena vacía.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">Se ha producido una excepción al agregar el archivo '{0}'. Excepción: '{1}'</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valor inicial de la propiedad: $({0})="{1}" Origen: {2}</target>
@@ -557,7 +577,7 @@ Errores: {3}</target>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">El solucionador de "{0}" ha intentado resolver el SDK "{1}" y ha devuelto null como cadena en la lista de advertencias o errores.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 496a22ee1d7..4fb21225130 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">Tentative d'annulation de la génération en cours...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: La tâche "{0}" a plusieurs paramètres appelés "{1}".</target>
@@ -126,6 +131,11 @@
         <target state="translated">L’écriture n’est pas recommandée.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">BuildCheck est activé pour cette build.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">ÉCHEC de la génération de la question. La génération s’est arrêtée tôt, car elle a rencontré une cible ou une tâche qui n’était pas à jour.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">Impossible de trouver l’assemblée d'analyseur personnalisé spécifié : {0}. Vérifiez s’il existe.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Échec du chargement du type d’analyseur personnalisé : {0} à partir de l’assembly : {1}. Assurez-vous qu’il hérite de la classe de base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. S’il ne doit pas être un analyseur personnalisé, il ne doit pas être exposé. Plus d’informations : https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">Échec de l’inscription de l’analyseur personnalisé : {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">Échec de l’instanciation de la règle d’analyseur personnalisé avec l’exception suivante : {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">Règle de l’analyseur personnalisé : {0} a été correctement inscrit.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">Le projet "{0}" n'a pas été importé par "{1}" sur ({2},{3}), car l'expression a la valeur d'une chaîne vide.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">Une exception s’est produite lors de l’ajout du fichier « {0} ». Exception : « {1} »</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valeur initiale de la propriété : $({0})="{1}" Source : {2}</target>
@@ -557,7 +577,7 @@ Erreurs : {3}</target>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">Le programme de résolution de « {0} » a tenté de résoudre le SDK « {1} » et a retourné nul en tant que chaîne dans la liste des avertissements ou des erreurs.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index f458ff5b358..b2d59875e50 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="it" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">Tentativo di annullare la compilazione in corso...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: l'attività "{0}" contiene più di un parametro denominato "{1}".</target>
@@ -126,6 +131,11 @@
         <target state="translated">La scrittura non è supportata.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">BuildCheck è abilitato per questa compilazione.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Compilazione della domanda NON RIUSCITA. La compilazione è terminata in anticipo perché è stata rilevata una destinazione o un'attività non aggiornata.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">Impossibile trovare l'assembly dell'analizzatore personalizzato specificato: {0}. Verificare se esiste.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Non è stato possibile caricare il tipo di analizzatore diagnostico personalizzato: {0} dall'assembly: {1}. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se non è destinato a essere un analizzatore personalizzato, non deve essere esposto. Per altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">Impossibile registrare l'analizzatore personalizzato: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">Impossibile creare un'istanza della regola dell'analizzatore personalizzato con l'eccezione seguente: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">Regola dell'analizzatore personalizzato: {0} è stata registrata.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">Il progetto "{0}" non è stato importato da "{1}" alla posizione ({2},{3}) perché l'espressione restituisce una stringa vuota.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">Si è verificata un'eccezione durante l'aggiunta del file '{0}', Eccezione: '{1}'</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valore iniziale della proprietà: $({0})="{1}". Origine: {2}</target>
@@ -557,7 +577,7 @@ Errori: {3}</target>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">Il resolver "{0}" ha tentato di risolvere l'SDK "{1}" e ha restituito Null come stringa nell'elenco di avvisi o errori.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 9988fdeaa35..b8d4ba74700 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ja" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">ビルドを取り消そうとしています...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: "{0}" タスクには "{1}" という名前のパラメーターが 2 つ以上あります。</target>
@@ -126,6 +131,11 @@
         <target state="translated">書き込みはサポートされていません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">BuildCheck は、このビルドに対して有効になっています。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">質問のビルドに失敗しました。ビルドは、最新ではないターゲットまたはタスクが検出されたため、早期に終了しました。</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">指定されたカスタム アナライザー アセンブリが見つかりませんでした: {0}。存在するかどうか確認してください。</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">カスタム アナライザーの種類を読み込めませんでした: アセンブリ {1} の {0}。Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底クラスを継承していることを確認してください。カスタム アナライザーを意図していない場合は、公開しないでください。詳細情報: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">カスタム アナライザーを登録できませんでした: {0}</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">次の例外により、カスタム アナライザー ルールのインスタンスを作成できませんでした: {0}。</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">カスタム アナライザー ルール: {0} が正常に登録されました。</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">式の評価結果が空の文字列になったため、プロジェクト "{0}" は "{1}" によって ({2},{3}) でインポートされませんでした。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">ファイル '{0}' を追加中に例外が発生しました、例外: '{1}'</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">プロパティの初期値: $({0})="{1}" ソース: {2}</target>
@@ -557,7 +577,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">"{0}" リゾルバーは SDK "{1}" を解決しようとしましたが、警告またはエラーのリストで文字列として null を返しました。</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 2ac37d0efec..82287483bf4 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">빌드를 취소하는 중...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: "{0}" 작업에 이름이 "{1}"인 매개 변수가 두 개 이상 있습니다.</target>
@@ -126,6 +131,11 @@
         <target state="translated">쓰기는 지원되지 않습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">이 빌드에 대해 BuildCheck를 사용할 수 있습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">질문 빌드에 실패했습니다. 빌드가 최신이 아닌 대상 또는 작업을 발견하여 일찍 종료되었습니다.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">지정한 사용자 지정 분석기 어셈블리를 찾지 못했습니다. {0}. 존재하는지 확인하세요.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">사용자 지정 분석기 형식을 로드하지 못했습니다. 어셈블리에서 {0} : {1}. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 기본 클래스를 상속해야 합니다. 사용자 지정 분석기가 아닌 경우 노출되지 않아야 합니다. 추가 정보: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">사용자 지정 분석기를 등록하지 못했습니다. {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">다음 예외로 인해 사용자 지정 분석기 규칙을 인스턴스화하지 못했습니다. {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">사용자 지정 분석기 규칙: {0}이(가) 등록되었습니다.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">빈 문자열로 평가되는 식 때문에 ({2},{3})의 "{1}"이(가) 프로젝트 "{0}"을(를) 가져오지 않았습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">'{0}' 파일을 추가하는 동안 예외가 발생했습니다. 예외: '{1}'</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">속성 초기 값: $({0})="{1}" 소스: {2}</target>
@@ -557,7 +577,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">"{0}" 확인자가 SDK "{1}" 해결을 시도했으며 경고 또는 오류 목록에서 null을 문자열로 반환했습니다.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index ab4852a92f2..63ace7582fc 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pl" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">Trwa próba anulowania kompilacji...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: Zadanie „{0}” zawiera więcej niż jeden parametr o nazwie „{1}”.</target>
@@ -126,6 +131,11 @@
         <target state="translated">Zapisywanie nie jest obsługiwane.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">Dla tej kompilacji włączono funkcję BuildCheck.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">NIEPOWODZENIE kompilacji pytania. Kompilacja została zakończona wcześniej, ponieważ napotkała element docelowy lub zadanie, które nie było aktualne.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">Nie można odnaleźć określonego zestawu analizatora niestandardowego: {0}. Sprawdź, czy istnieje.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Nie udało się załadować niestandardowego analizatora typu: {0} z zestawu: {1}. Upewnij się, że dziedziczy po klasie bazowej Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Jeśli nie jest przeznaczony do niestandardowego analizatora, nie powinien być ujawniany. Więcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">Nie można zarejestrować analizatora niestandardowego: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">Nie można utworzyć wystąpienia niestandardowej reguły analizatora z następującym wyjątkiem: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">Niestandardowa reguła analizatora: {0} została pomyślnie zarejestrowana.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">Projekt „{0}” nie został zaimportowany przez projekt „{1}” o ({2},{3}) z powodu wyrażenia ocenianego jako pusty ciąg.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">Wystąpił wyjątek podczas dodawania pliku „{0}”. Wyjątek: „{1}”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Wartość początkowa właściwości: $({0})=„{1}” Źródło: {2}</target>
@@ -557,7 +577,7 @@ Błędy: {3}</target>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">Program rozpoznawania nazw „{0}” próbował rozpoznać zestaw SDK „{1}” i zwrócił wartość null jako ciąg na liście ostrzeżeń lub błędów.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index baf32381069..f857b1890f2 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pt-BR" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">Tentando cancelar a compilação...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: A tarefa "{0}" tem mais de um parâmetro denominado "{1}".</target>
@@ -126,6 +131,11 @@
         <target state="translated">Não há suporte para gravação.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">O BuildCheck está habilitado para esse build.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">FALHA na compilação da pergunta. A compilação foi encerrada antecipadamente ao se deparar com um alvo ou tarefa que não estava atualizado.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">Falha ao localizar o assembly do analisador personalizado especificado: {0}. Verifique se existe.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Falha ao carregar o tipo de analisador personalizado: {0} do assembly: {1}. Certifique-se de que ele herde a classe base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se não se destina a ser um analisador personalizado, ele não deve ser exposto. Mais informações: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">Falha ao registrar o analisador personalizado: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">Falha ao criar uma instância da regra do analisador personalizado com a seguinte exceção: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">Regra do analisador personalizado: {0} foi registrado com sucesso.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">O projeto "{0}" não foi importado por "{1}" em ({2},{3}), porque a expressão foi avaliada como uma cadeia de caracteres vazia.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">Ocorreu uma exceção ao adicionar o arquivo '{0}', Exceção: '{1}'</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Valor inicial da propriedade: $({0})="{1}" Origem: {2}</target>
@@ -557,7 +577,7 @@ Erros: {3}</target>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">O resolvedor "{0}" tentou resolver o SDK "{1}" e retornou nulo como uma cadeia de caracteres na lista de avisos ou erros.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 6be008360cc..b5107f73d35 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">Попытка отменить сборку...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: у задачи "{0}" несколько параметров "{1}".</target>
@@ -126,6 +131,11 @@
         <target state="translated">Запись не поддерживается.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">Для этой сборки включен параметр BuildCheck.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">СБОЙ сборки вопроса. Выход из сборки выполнен раньше, так как была обнаружена цель или задача без обновления.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">Не удалось найти указанную сборку настраиваемого анализатора: {0}. Убедитесь, что она существует.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Не удалось загрузить настраиваемый тип анализатора {0} из сборки {1}. Убедитесь, что он наследует базовый класс Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Если он не предназначен для настраиваемого анализатора, его не следует предоставлять. Дополнительные сведения: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">Не удалось зарегистрировать настраиваемый анализатор: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">Не удалось создать экземпляр правила настраиваемого анализатора со следующим исключением: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">Зарегистрировано правило настраиваемого анализатора: {0}.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">Проект "{0}" не был импортирован "{1}" в ({2},{3}), так как результатом вычисления выражения была пустая строка.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">Возникло исключение при добавлении файла "{0}", исключение: "{1}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Начальное значение свойства: $({0})="{1}" Источник: {2}</target>
@@ -557,7 +577,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">Сопоставитель "{0}" попытался разрешить пакет SDK "{1}" и вернул значение NULL в виде строки в списке предупреждений или ошибок.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index d4aeee4b36e..21edf0d75d2 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="tr" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">Oluşturma iptal edilmeye çalışılıyor...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: "{0}" görevinin "{1}" adında birden fazla parametresi var.</target>
@@ -126,6 +131,11 @@
         <target state="translated">Yazma işlemi desteklenmiyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">BuildCheck bu derleme için etkinleştirildi.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">Soru derleme BAŞARISIZ oldu. Güncel olmayan bir hedef veya görev ile karşılaştığından derleme işleminden erken çıkıldı.</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">Belirtilen {0} özel çözümleyici derlemesi bulunamadı. Lütfen var olup olmadığını kontrol edin.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Özel çözümleyici türü yüklenemedi: {0} derlemeden: {1}. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer temel sınıf devralınmış olduğundan emin olun. Özel bir çözümleyici olması amaçlanmadıysa açığa çıkarılmaması gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">Özel çözümleyici kaydedilemedi: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">Özel çözümleyici kuralı şu özel durumla başlatılamadı: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">{0} özel çözümleyici kuralı başarıyla kaydedildi.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">"{0}" adlı proje, ifadenin boş dize olarak değerlendirilmesi nedeniyle ({2},{3}) konumundaki "{1}" tarafından içeri aktarılmadı.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">Exception: '{1}': '{0}' dosyası eklenirken özel durum oluştu</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">Özellik başlangıç değeri: $({0})="{1}" Kaynak: {2}</target>
@@ -557,7 +577,7 @@ Hatalar: {3}</target>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">"{0}" çözümleyicisi "{1}" SDK'sını çözümlemeye çalıştı ve uyarılar veya hatalar listesinde bir dize olarak null döndürdü.</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 50e20f5f9db..350c89b3d35 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">正在尝试取消生成...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: “{0}”任务包含多个名为“{1}”的参数。</target>
@@ -126,6 +131,11 @@
         <target state="translated">不支持写入。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">已为此内部版本启用 BuildCheck。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">问题生成失败。生成提前退出，因为遇到不是最新的目标或任务。</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">找不到指定的自定义分析器程序集: {0}。请检查它是否存在。</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">未能从程序集 {1} 加载自定义分析器类型 {0}。请确保它继承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基类。如果不打算将其作为自定义分析器，则不应将其公开。详细信息: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">无法注册自定义分析器: {0}。</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">无法实例化自定义分析器规则，出现以下异常: {0}。</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">自定义分析器规则: {0} 已成功注册。</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">由于表达式评估为空字符串，因此项目“{0}”不由 ({2}、{3}) 处的“{1}”导入。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">添加文件“{0}”时发生异常，异常:“{1}”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">属性初始值: $({0})=“{1}”，源: {2}</target>
@@ -557,7 +577,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">“{0}”解析程序已尝试解析 SDK“{1}”，并在警告或错误列表中以字符串形式返回 null。</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index decd0d4af66..4d3f605a97d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
+      <trans-unit id="AbortingBuild">
+        <source>Attempting to cancel the build...</source>
+        <target state="translated">正在嘗試取消建置...</target>
+        <note />
+      </trans-unit>
       <trans-unit id="AmbiguousTaskParameterError">
         <source>MSB4001: The "{0}" task has more than one parameter called "{1}".</source>
         <target state="translated">MSB4001: "{0}" 工作有多個名稱為 "{1}" 的參數。</target>
@@ -126,6 +131,11 @@
         <target state="translated">不支援寫入。</target>
         <note />
       </trans-unit>
+      <trans-unit id="BuildCheckEnabled">
+        <source>The BuildCheck is enabled for this build.</source>
+        <target state="translated">已為此組建啟用 BuildCheck。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinishedQuestionFailure">
         <source>Question build FAILED. The build exited early as it encountered a target or task that was not up-to-date.</source>
         <target state="translated">問題建立失敗。建置提早結束，因為它遇到不是最新的目標或工作。</target>
@@ -207,30 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</source>
-        <target state="translated">找不到指定的自訂分析器組件: {0}。請檢查它是否存在。</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">無法從組件 {1} 載入自訂分析器類型 {0}。請確定它繼承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基類。如果不是要作為自訂分析器，則不應公開。更多資訊: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: {0}.</source>
-        <target state="translated">無法登錄自訂分析器: {0}。</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: {0}.</source>
-        <target state="translated">無法具現化自訂分析器規則，發生下列例外狀況: {0}。</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: {0} has been registered successfully.</source>
-        <target state="translated">自訂分析器規則: 已成功登錄 {0}。</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
@@ -514,6 +529,11 @@
         <target state="translated">因為運算式評估為空字串，所以專案 "{0}" 未在 ({2},{3}) 由 "{1}" 匯入。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectImportsCollectorFileIOFail">
+        <source>An exception occurred when adding the file '{0}', Exception: '{1}'</source>
+        <target state="translated">新增檔案 '{0}' 時發生例外狀況，例外狀況： '{1}'</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PropertyAssignment">
         <source>Property initial value: $({0})="{1}" Source: {2}</source>
         <target state="translated">屬性初始值: $({0})="{1}" 來源: {2}</target>
@@ -557,7 +577,7 @@ Errors: {3}</source>
       </trans-unit>
       <trans-unit id="SDKResolverNullMessage">
         <source>The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</source>
-        <target state="new">The "{0}" resolver attempted to resolve the SDK "{1}" and returned null as a string in the list of warnings or errors.</target>
+        <target state="translated">"{0}" 解析程式嘗試解析 SDK "{1}"，並以警告或錯誤清單中的字串傳回 null。</target>
         <note>
       LOCALIZATION: Do not localize the word SDK.
     </note>
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 67b454cc023..e8bf893be60 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -462,11 +462,11 @@ private static bool UsingDifferentToolsVersionFromProjectFile(string toolsVersio
         /// Retrieves properties derived from the current
         /// environment variables.
         /// </summary>
-        internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProperties()
+        internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProperties(bool makeReadOnly)
         {
             IDictionary<string, string> environmentVariablesBag = CommunicationsUtilities.GetEnvironmentVariables();
 
-            PropertyDictionary<ProjectPropertyInstance> environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(environmentVariablesBag.Count + 2);
+            var envPropertiesHashSet = new RetrievableValuedEntryHashSet<ProjectPropertyInstance>(environmentVariablesBag.Count + 2, MSBuildNameIgnoreCaseComparer.Default);
 
             // We set the MSBuildExtensionsPath variables here because we don't want to make them official
             // reserved properties; we need the ability for people to override our default in their
@@ -483,11 +483,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                                           ? Path.Combine(programFiles32, ReservedPropertyNames.extensionsPathSuffix)
                                           : programFiles32;
 #endif
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath32, extensionsPath32, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath32, extensionsPath32, true));
 
 #if !FEATURE_INSTALLED_MSBUILD
             string extensionsPath64 = extensionsPath;
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
 #else
             // "MSBuildExtensionsPath64". This points to whatever the value of "Program Files" environment variable is on a
             // 64-bit machine, and is empty on a 32-bit machine.
@@ -500,7 +500,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                                                   FrameworkLocationHelper.programFiles64,
                                                   ReservedPropertyNames.extensionsPathSuffix)
                                               : FrameworkLocationHelper.programFiles64;
-                environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
+                envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
             }
 #endif
 
@@ -523,13 +523,13 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             }
 #endif
 
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath, extensionsPath, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath, extensionsPath, true));
 
             // Windows XP and Windows Server 2003 don't define LocalAppData in their environment.
             // We'll set it here if the environment doesn't have it so projects can reliably
             // depend on $(LocalAppData).
             string localAppData = String.Empty;
-            ProjectPropertyInstance localAppDataProp = environmentProperties.GetProperty(ReservedPropertyNames.localAppData);
+            ProjectPropertyInstance localAppDataProp = envPropertiesHashSet.Get(ReservedPropertyNames.localAppData);
             if (localAppDataProp != null)
             {
                 localAppData = localAppDataProp.EvaluatedValue;
@@ -551,11 +551,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             }
 
 
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.localAppData, localAppData));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.localAppData, localAppData));
 
             // Add MSBuildUserExtensionsPath at $(LocalAppData)\Microsoft\MSBuild
             string userExtensionsPath = Path.Combine(localAppData, ReservedPropertyNames.userExtensionsPathSuffix);
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.userExtensionsPath, userExtensionsPath));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.userExtensionsPath, userExtensionsPath));
 
             foreach (KeyValuePair<string, string> environmentVariable in environmentVariablesBag)
             {
@@ -570,7 +570,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                 {
                     ProjectPropertyInstance environmentProperty = ProjectPropertyInstance.Create(environmentVariableName, environmentVariable.Value);
 
-                    environmentProperties.Set(environmentProperty);
+                    envPropertiesHashSet.Add(environmentProperty);
                 }
                 else
                 {
@@ -579,6 +579,12 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                 }
             }
 
+            if (makeReadOnly)
+            {
+                envPropertiesHashSet.MakeReadOnly();
+            }
+
+            var environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(envPropertiesHashSet);
             return environmentProperties;
         }
 
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index c5ef688824e..e555da0aae3 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -98,7 +98,7 @@ internal static bool VerifyValidProjectNamespace(XmlElementWithLocation element)
             }
             else if (string.IsNullOrEmpty(element.NamespaceURI))
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) && Path.GetExtension(element.Location.File).Equals(".dwproj", StringComparison.OrdinalIgnoreCase))
+                if (Path.GetExtension(element.Location.File).Equals(".dwproj", StringComparison.OrdinalIgnoreCase))
                 {
                     bool validMSBuildProject = true;
                     foreach (XmlNode child in element.ChildNodes)
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
deleted file mode 100644
index 7bd57f8014b..00000000000
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
+++ /dev/null
@@ -1,38 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Xunit;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
-using Shouldly;
-
-namespace Microsoft.Build.BuildCheck.UnitTests;
-
-public class BuildAnalyzerConfigurationInternalTests
-{
-    [Theory]
-    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
-    [InlineData("ruleId2", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
-    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Error, true, false)]
-    public void IsSameConfigurationAsTest(
-        string secondRuleId,
-        EvaluationAnalysisScope secondScope,
-        BuildAnalyzerResultSeverity secondSeverity,
-        bool secondEnabled,
-        bool isExpectedToBeSame)
-    {
-        BuildAnalyzerConfigurationInternal configuration1 = new BuildAnalyzerConfigurationInternal(
-                       ruleId: "ruleId",
-                       evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
-                       severity: BuildAnalyzerResultSeverity.Warning,
-                       isEnabled: true);
-
-        BuildAnalyzerConfigurationInternal configuration2 = new BuildAnalyzerConfigurationInternal(
-            ruleId: secondRuleId,
-            evaluationAnalysisScope: secondScope,
-            severity: secondSeverity,
-            isEnabled: secondEnabled);
-
-        configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
-    }
-}
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
deleted file mode 100644
index edfdfaf4589..00000000000
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
+++ /dev/null
@@ -1,113 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Collections.Generic;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
-using Shouldly;
-using Xunit;
-
-namespace Microsoft.Build.BuildCheck.UnitTests;
-
-public class BuildAnalyzerConfiguration_Test
-{
-    [Fact]
-    public void CreateWithNull_ReturnsObjectWithNullValues()
-    {
-        var buildConfig = BuildAnalyzerConfiguration.Create(null);
-        buildConfig.ShouldNotBeNull();
-        buildConfig.Severity.ShouldBeNull();
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Fact]
-    public void CreateWithEmpty_ReturnsObjectWithNullValues()
-    {
-        var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());
-        buildConfig.ShouldNotBeNull();
-        buildConfig.Severity.ShouldBeNull();
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("error", BuildAnalyzerResultSeverity.Error)]
-    [InlineData("info", BuildAnalyzerResultSeverity.Info)]
-    [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
-    [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
-    public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { "severity" , parameter },
-        };
-        var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-        buildConfig.ShouldNotBeNull();
-        buildConfig.Severity.ShouldBe(expected);
-
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("true", true)]
-    [InlineData("TRUE", true)]
-    [InlineData("false", false)]
-    [InlineData("FALSE", false)]
-    public void CreateBuildAnalyzerConfiguration_IsEnabled(string parameter, bool? expected)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { "isenabled" , parameter },
-        };
-
-        var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-        buildConfig.ShouldNotBeNull();
-        buildConfig.IsEnabled.ShouldBe(expected);
-
-        buildConfig.Severity.ShouldBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("ProjectOnly", EvaluationAnalysisScope.ProjectOnly)]
-    [InlineData("ProjectWithImportsFromCurrentWorkTree", EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree)]
-    [InlineData("ProjectWithImportsWithoutSdks", EvaluationAnalysisScope.ProjectWithImportsWithoutSdks)]
-    [InlineData("ProjectWithAllImports", EvaluationAnalysisScope.ProjectWithAllImports)]
-    [InlineData("projectwithallimports", EvaluationAnalysisScope.ProjectWithAllImports)]
-    public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string parameter, EvaluationAnalysisScope? expected)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { "evaluationanalysisscope" , parameter },
-        };
-
-        var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-        buildConfig.ShouldNotBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBe(expected);
-
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.Severity.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("evaluationanalysisscope", "incorrec-value")]
-    [InlineData("isenabled", "incorrec-value")]
-    [InlineData("severity", "incorrec-value")]
-    public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { key , value },
-        };
-
-        var exception = Should.Throw<BuildCheckConfigurationException>(() => {
-            BuildAnalyzerConfiguration.Create(config);
-        });
-        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
-    }
-}
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
index bf1ccb8105a..d33261fc6d9 100644
--- a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -5,10 +5,11 @@
 using System.Linq;
 using System.Reflection;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck.Acquisition;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Acquisition;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests;
 using Shouldly;
@@ -29,27 +30,30 @@ public BuildCheckManagerTests(ITestOutputHelper output)
         _loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
         _logger = new MockLogger();
         _loggingService.RegisterLogger(_logger);
-        _testedInstance = new BuildCheckManager(_loggingService);
+        _testedInstance = new BuildCheckManager();
     }
 
     [Theory]
-    [InlineData(true, new[] { "Custom analyzer rule: Rule1 has been registered successfully.", "Custom analyzer rule: Rule2 has been registered successfully." })]
-    [InlineData(false, new[] { "Failed to register the custom analyzer: DummyPath." })]
-    public void ProcessAnalyzerAcquisitionTest(bool isAnalyzerRuleExist, string[] expectedMessages)
+    [InlineData(true, new[] { "Custom check rule: 'Rule1' has been registered successfully.", "Custom check rule: 'Rule2' has been registered successfully." })]
+    [InlineData(false, new[] { "Failed to register the custom check: 'DummyPath'." })]
+    public void ProcessCheckAcquisitionTest(bool isCheckRuleExist, string[] expectedMessages)
     {
-        MockBuildCheckAcquisition(isAnalyzerRuleExist);
+        MockConfigurationProvider();
+        MockBuildCheckAcquisition(isCheckRuleExist);
         MockEnabledDataSourcesDefinition();
 
-        _testedInstance.ProcessAnalyzerAcquisition(new AnalyzerAcquisitionData("DummyPath"), new BuildEventContext(1, 2, 3, 4, 5, 6, 7));
+        _testedInstance.ProcessCheckAcquisition(new CheckAcquisitionData("DummyPath", "ProjectPath"), new CheckLoggingContext(_loggingService, new BuildEventContext(1, 2, 3, 4, 5, 6, 7)));
 
         _logger.AllBuildEvents.Where(be => be.GetType() == typeof(BuildMessageEventArgs)).Select(be => be.Message).ToArray()
             .ShouldBeEquivalentTo(expectedMessages);
     }
 
-    private void MockBuildCheckAcquisition(bool isAnalyzerRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isAnalyzerRuleExist));
+    private void MockBuildCheckAcquisition(bool isCheckRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isCheckRuleExist));
 
     private void MockEnabledDataSourcesDefinition() => MockField("_enabledDataSources", new[] { true, true });
 
+    private void MockConfigurationProvider() => MockField("_configurationProvider", new ConfigurationProviderMock());
+
     private void MockField(string fieldName, object mockedValue)
     {
         var mockedField = _testedInstance.GetType().GetField(fieldName, BindingFlags.NonPublic | BindingFlags.Instance);
@@ -60,39 +64,52 @@ private void MockField(string fieldName, object mockedValue)
     }
 }
 
+internal sealed class ConfigurationProviderMock : IConfigurationProvider
+{
+    public void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId) { }
+
+    public CustomConfigurationData[] GetCustomConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
+
+    public CheckConfigurationEffective[] GetMergedConfigurations(string projectFullPath, Check check) => [];
+
+    public CheckConfigurationEffective[] GetMergedConfigurations(CheckConfiguration[] userConfigs, Check check) => [];
+
+    public CheckConfiguration[] GetUserConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
+}
+
 internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionModule
 {
-    private readonly bool _isAnalyzerRuleExistForTest = true;
+    private readonly bool _isCheckRuleExistForTest = true;
 
-    internal BuildCheckAcquisitionModuleMock(bool isAnalyzerRuleExistForTest) => _isAnalyzerRuleExistForTest = isAnalyzerRuleExistForTest;
+    internal BuildCheckAcquisitionModuleMock(bool isCheckRuleExistForTest) => _isCheckRuleExistForTest = isCheckRuleExistForTest;
 
-    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, BuildEventContext buildEventContext)
-        => _isAnalyzerRuleExistForTest
-        ? new List<BuildAnalyzerFactory>() { () => new BuildAnalyzerRuleMock("Rule1"), () => new BuildAnalyzerRuleMock("Rule2") }
-        : new List<BuildAnalyzerFactory>();
+    public List<CheckFactory> CreateCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext)
+        => _isCheckRuleExistForTest
+        ? new List<CheckFactory>() { () => new CheckRuleMock("Rule1"), () => new CheckRuleMock("Rule2") }
+        : new List<CheckFactory>();
 }
 
-internal sealed class BuildAnalyzerRuleMock : BuildAnalyzer
+internal sealed class CheckRuleMock : Check
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+    public static CheckRule SupportedRule = new CheckRule(
         "X01234",
         "Title",
         "Description",
         "Message format: {0}",
-        new BuildAnalyzerConfiguration());
+        new CheckConfiguration());
 
-    internal BuildAnalyzerRuleMock(string friendlyName)
+    internal CheckRuleMock(string friendlyName)
     {
         FriendlyName = friendlyName;
     }
 
     public override string FriendlyName { get; }
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
-        // configurationContext to be used only if analyzer needs external configuration data.
+        // configurationContext to be used only if check needs external configuration data.
     }
 
     public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -100,7 +117,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
         registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
     }
 
-    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         context.ReportResult(BuildCheckResult.Create(
             SupportedRule,
diff --git a/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
new file mode 100644
index 00000000000..12920740700
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
@@ -0,0 +1,63 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Xunit;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using System;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CheckConfigurationEffectiveTests
+{
+    [Theory]
+    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Warning,  true)]
+    [InlineData("ruleId2", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Warning,  true)]
+    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Error, false)]
+    public void IsSameConfigurationAsTest(
+        string secondRuleId,
+        EvaluationCheckScope secondScope,
+        CheckResultSeverity secondSeverity,
+        bool isExpectedToBeSame)
+    {
+        CheckConfigurationEffective configuration1 = new CheckConfigurationEffective(
+                       ruleId: "ruleId",
+                       evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
+                       severity: CheckResultSeverity.Warning);
+
+        CheckConfigurationEffective configuration2 = new CheckConfigurationEffective(
+            ruleId: secondRuleId,
+            evaluationCheckScope: secondScope,
+            severity: secondSeverity);
+
+        configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
+    }
+
+    [Theory]
+    [InlineData( CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Suggestion, true)]
+    [InlineData(CheckResultSeverity.Error, true)]
+    [InlineData(CheckResultSeverity.None, false)]
+    public void CheckConfigurationInternal_Constructor_SeverityConfig(CheckResultSeverity severity, bool isEnabledExpected)
+    {
+        CheckConfigurationEffective configuration = new CheckConfigurationEffective(
+                       ruleId: "ruleId",
+                       evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
+                       severity: severity);
+
+        configuration.IsEnabled.ShouldBe(isEnabledExpected);
+    }
+
+    [Fact]
+    public void CheckConfigurationInternal_Constructor_SeverityConfig_Fails()
+    {
+        Should.Throw<ArgumentOutOfRangeException>(() =>
+        {
+            new CheckConfigurationEffective(
+                        ruleId: "ruleId",
+                        evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
+                        severity: CheckResultSeverity.Default);
+        });
+    }
+}
diff --git a/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
new file mode 100644
index 00000000000..3fd22bd8a46
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
@@ -0,0 +1,117 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CheckConfiguration_Test
+{
+    [Fact]
+    public void CreateWithNull_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = CheckConfiguration.Create(null);
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationCheckScope.ShouldBeNull();
+    }
+
+    [Fact]
+    public void CreateWithEmpty_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = CheckConfiguration.Create(new Dictionary<string, string>());
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationCheckScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", CheckResultSeverity.Error)]
+    [InlineData("ERROR", CheckResultSeverity.Error)]
+    [InlineData("suggestion", CheckResultSeverity.Suggestion)]
+    [InlineData("SUGGESTION", CheckResultSeverity.Suggestion)]
+    [InlineData("warning", CheckResultSeverity.Warning)]
+    [InlineData("WARNING", CheckResultSeverity.Warning)]
+    [InlineData("NONE", CheckResultSeverity.None)]
+    [InlineData("none", CheckResultSeverity.None)]
+    [InlineData("default", CheckResultSeverity.Default)]
+    [InlineData("DEFAULT", CheckResultSeverity.Default)]
+    public void CreateCheckConfiguration_Severity(string parameter, CheckResultSeverity? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity" , parameter },
+        };
+
+        var buildConfig = CheckConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBe(expected);
+        buildConfig.EvaluationCheckScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", true)]
+    [InlineData("warning", true)]
+    [InlineData("suggestion", true)]
+    [InlineData("none", false)]
+    [InlineData("default", null)]
+    public void CreateCheckConfiguration_SeverityAndEnabledOrder(string parameter, bool? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity", parameter },
+        };
+        
+        var buildConfig = CheckConfiguration.Create(config);
+
+        buildConfig.IsEnabled.ShouldBe(expected);
+    }
+
+    [Theory]
+    [InlineData("project_file", EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData("projectfile", EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData("PROJECT_FILE", EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData("work_tree_imports", EvaluationCheckScope.WorkTreeImports)]
+    [InlineData("WORK_TREE_IMPORTS", EvaluationCheckScope.WorkTreeImports)]
+    [InlineData("all", EvaluationCheckScope.All)]
+    [InlineData("ALL", EvaluationCheckScope.All)]
+    public void CreateCheckConfiguration_EvaluationCheckScope(string parameter, EvaluationCheckScope? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "scope" , parameter },
+        };
+
+        var buildConfig = CheckConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.EvaluationCheckScope.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.Severity.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("scope", "incorrec-value")]
+    [InlineData("severity", "incorrec-value")]
+    public void CreateCheckConfiguration_ExceptionOnInvalidInputValue(string key, string value)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { key , value },
+        };
+
+        var exception = Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            CheckConfiguration.Create(config);
+        });
+        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
index d559e1724b1..53b7ba1b7b3 100644
--- a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -76,8 +76,9 @@ public void GetRuleIdConfiguration_CustomConfigurationData()
         [*.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled=true
-        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.is_enabled_2=true
+        build_check.rule_id.scope=project
+        build_check.rule_id.severity=default
         any_other_key1=any_other_value1
         any_other_key2=any_other_value2
         any_other_key3=any_other_value3
@@ -92,7 +93,7 @@ public void GetRuleIdConfiguration_CustomConfigurationData()
 
         configs.ContainsKey("property1").ShouldBeTrue();
         configs.ContainsKey("property2").ShouldBeTrue();
-        configs.ContainsKey("isenabled2").ShouldBeTrue();
+        configs.ContainsKey("is_enabled_2").ShouldBeTrue();
     }
 
     [Fact]
@@ -106,9 +107,8 @@ public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
         root=true
 
         [*.csproj]
-        build_check.rule_id.isEnabled=true
-        build_check.rule_id.Severity=Error
-        build_check.rule_id.EvaluationAnalysisScope=ProjectOnly
+        build_check.rule_id.severity=error
+        build_check.rule_id.scope=project_file
         """);
 
         var configurationProvider = new ConfigurationProvider();
@@ -116,9 +116,9 @@ public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
 
         buildConfig.ShouldNotBeNull();
 
-        buildConfig.IsEnabled?.ShouldBeTrue();
-        buildConfig.Severity?.ShouldBe(BuildAnalyzerResultSeverity.Error);
-        buildConfig.EvaluationAnalysisScope?.ShouldBe(EvaluationAnalysisScope.ProjectOnly);
+        buildConfig.IsEnabled.ShouldBe(true);
+        buildConfig.Severity.ShouldBe(CheckResultSeverity.Error);
+        buildConfig.EvaluationCheckScope.ShouldBe(EvaluationCheckScope.ProjectFileOnly);
     }
 
     [Fact]
@@ -134,14 +134,12 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_Differen
         [*.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled=true
-        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.is_enabled_2=true
 
         [test123.csproj]
         build_check.rule_id.property1=value2
         build_check.rule_id.property2=value3
-        build_check.rule_id.isEnabled=true
-        build_check.rule_id.isEnabled2=tru1
+        build_check.rule_id.is_enabled_2=tru1
         """);
 
         var configurationProvider = new ConfigurationProvider();
@@ -167,13 +165,13 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_Differen
         [*.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.is_enabled_2=true
 
         [test123.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled2=true
-        build_check.rule_id.isEnabled3=true
+        build_check.rule_id.is_enabled_2=true
+        build_check.rule_id.is_enabled_3=true
         """);
 
         var configurationProvider = new ConfigurationProvider();
@@ -199,14 +197,12 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
         [*.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled=true
-        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.is_enabled_2=true
 
         [test123.csproj]
         build_check.rule_id.property1=value1
         build_check.rule_id.property2=value2
-        build_check.rule_id.isEnabled=true
-        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.is_enabled_2=true
         """);
 
         var configurationProvider = new ConfigurationProvider();
@@ -218,4 +214,29 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
             configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
         });
     }
+
+    [Theory]
+    [InlineData(CheckResultSeverity.Warning, CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Error, CheckResultSeverity.Error, true)]
+    [InlineData(CheckResultSeverity.Default, CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Suggestion, CheckResultSeverity.Suggestion, true)]
+    [InlineData(CheckResultSeverity.None, CheckResultSeverity.None, false)]
+    [InlineData(null, CheckResultSeverity.Warning, true)]
+    public void GetConfigurationProvider_MergesSeverity_Correctly(CheckResultSeverity? checkResultSeverity, CheckResultSeverity expectedSeverity, bool expectedEnablment)
+    {
+        var configurationProvider = new ConfigurationProvider();
+        CheckConfiguration checkConfiguration = new CheckConfiguration()
+        {
+            Severity = checkResultSeverity
+        };
+
+        CheckConfiguration defaultValue = new CheckConfiguration()
+        {
+            Severity = CheckResultSeverity.Warning
+        };
+
+        var internalCheck = configurationProvider.MergeConfiguration("ruleId", defaultValue, checkConfiguration);
+        internalCheck.Severity.ShouldBe(expectedSeverity);
+        internalCheck.IsEnabled.ShouldBe(expectedEnablment);
+    }
 }
diff --git a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
index fd1b601af06..c773fefbc11 100644
--- a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
+++ b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
@@ -6,61 +6,32 @@
 using System.IO;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Experimental.BuildCheck.Analyzers;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.BuildCheck.UnitTests
 {
-    public sealed class DoubleWritesAnalyzer_Tests
+    public sealed class DoubleWritesCheck_Tests
     {
-        private sealed class MockBuildCheckRegistrationContext : IBuildCheckRegistrationContext
-        {
-            private event Action<BuildCheckDataContext<TaskInvocationAnalysisData>>? _taskInvocationAction;
-
-            public List<BuildCheckResult> Results { get; } = new();
-
-            public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction) => throw new NotImplementedException();
-            public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction) => throw new NotImplementedException();
-
-            public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
-                => _taskInvocationAction += taskInvocationAction;
-
-            public void TriggerTaskInvocationAction(TaskInvocationAnalysisData data)
-            {
-                if (_taskInvocationAction is not null)
-                {
-                    BuildCheckDataContext<TaskInvocationAnalysisData> context = new BuildCheckDataContext<TaskInvocationAnalysisData>(
-                        null!,
-                        null!,
-                        null!,
-                        ResultHandler,
-                        data);
-                    _taskInvocationAction(context);
-                }
-            }
-
-            private void ResultHandler(BuildAnalyzerWrapper wrapper, LoggingContext context, BuildAnalyzerConfigurationInternal[] configs, BuildCheckResult result)
-                => Results.Add(result);
-        }
-
-        private readonly DoubleWritesAnalyzer _analyzer;
+        private readonly DoubleWritesCheck _check;
 
         private readonly MockBuildCheckRegistrationContext _registrationContext;
 
-        public DoubleWritesAnalyzer_Tests()
+        public DoubleWritesCheck_Tests()
         {
-            _analyzer = new DoubleWritesAnalyzer();
+            _check = new DoubleWritesCheck();
             _registrationContext = new MockBuildCheckRegistrationContext();
-            _analyzer.RegisterActions(_registrationContext);
+            _check.RegisterActions(_registrationContext);
         }
 
-        private TaskInvocationAnalysisData MakeTaskInvocationData(string taskName, Dictionary<string, TaskInvocationAnalysisData.TaskParameter> parameters)
+        private TaskInvocationCheckData MakeTaskInvocationData(string taskName, Dictionary<string, TaskInvocationCheckData.TaskParameter> parameters)
         {
             string projectFile = NativeMethodsShared.IsWindows ? @"C:\fake\project.proj" : "/fake/project.proj";
-            return new TaskInvocationAnalysisData(
+            return new TaskInvocationCheckData(
                 projectFile,
+                null,
                 Construction.ElementLocation.EmptyLocation,
                 taskName,
                 projectFile,
@@ -70,19 +41,19 @@ private TaskInvocationAnalysisData MakeTaskInvocationData(string taskName, Dicti
         [Fact]
         public void TestCopyTask()
         {
-            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationAnalysisData.TaskParameter>
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
                 {
-                    { "SourceFiles", new TaskInvocationAnalysisData.TaskParameter("source1", IsOutput: false) },
-                    { "DestinationFolder", new TaskInvocationAnalysisData.TaskParameter("outdir", IsOutput: false) },
+                    { "SourceFiles", new TaskInvocationCheckData.TaskParameter("source1", IsOutput: false) },
+                    { "DestinationFolder", new TaskInvocationCheckData.TaskParameter("outdir", IsOutput: false) },
                 }));
-            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationAnalysisData.TaskParameter>
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
                 {
-                    { "SourceFiles", new TaskInvocationAnalysisData.TaskParameter("source1", IsOutput: false) },
-                    { "DestinationFiles", new TaskInvocationAnalysisData.TaskParameter(Path.Combine("outdir", "source1"), IsOutput: false) },
+                    { "SourceFiles", new TaskInvocationCheckData.TaskParameter("source1", IsOutput: false) },
+                    { "DestinationFiles", new TaskInvocationCheckData.TaskParameter(Path.Combine("outdir", "source1"), IsOutput: false) },
                 }));
 
             _registrationContext.Results.Count.ShouldBe(1);
-            _registrationContext.Results[0].BuildAnalyzerRule.Id.ShouldBe("BC0102");
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0102");
         }
 
         [Theory]
@@ -93,17 +64,17 @@ public void TestCompilerTask(string taskName)
         {
             for (int i = 0; i < 2; i++)
             {
-                _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData(taskName, new Dictionary<string, TaskInvocationAnalysisData.TaskParameter>
+                _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData(taskName, new Dictionary<string, TaskInvocationCheckData.TaskParameter>
                     {
-                        { "OutputAssembly", new TaskInvocationAnalysisData.TaskParameter("out.dll", IsOutput: false) },
-                        { "OutputRefAssembly", new TaskInvocationAnalysisData.TaskParameter("out_ref.dll", IsOutput: false) },
-                        { "DocumentationFile", new TaskInvocationAnalysisData.TaskParameter("out.xml", IsOutput: false) },
-                        { "PdbFile", new TaskInvocationAnalysisData.TaskParameter("out.pdb", IsOutput: false) },
+                        { "OutputAssembly", new TaskInvocationCheckData.TaskParameter("out.dll", IsOutput: false) },
+                        { "OutputRefAssembly", new TaskInvocationCheckData.TaskParameter("out_ref.dll", IsOutput: false) },
+                        { "DocumentationFile", new TaskInvocationCheckData.TaskParameter("out.xml", IsOutput: false) },
+                        { "PdbFile", new TaskInvocationCheckData.TaskParameter("out.pdb", IsOutput: false) },
                     }));
             }
 
             _registrationContext.Results.Count.ShouldBe(4);
-            _registrationContext.Results.ForEach(result => result.BuildAnalyzerRule.Id.ShouldBe("BC0102"));
+            _registrationContext.Results.ForEach(result => result.CheckRule.Id.ShouldBe("BC0102"));
         }
     }
 }
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
index 1b1b0c5aaa4..84e9af60f02 100644
--- a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -841,13 +841,13 @@ public void CanGetSectionsWithSpecialCharacters()
 build_metadata.Compile.ToRetrieve = def456
 ");
 
-        var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
+        var set = CheckConfigSet.Create(ImmutableArray.Create(config));
 
         var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
-        Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+        Assert.Equal("abc123", sectionOptions.CheckOptions["build_metadata.compile.toretrieve"]);
 
         sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
-        Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+        Assert.Equal("def456", sectionOptions.CheckOptions["build_metadata.compile.toretrieve"]);
     }*/
 
     [Fact]
@@ -895,9 +895,9 @@ public void CaseInsensitivePropKey()
     public void NonReservedKeyPreservedCaseVal()
     {
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
+            CheckConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
+            CheckConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
             config.GlobalSection.Properties);
     }*/
 
@@ -1055,10 +1055,10 @@ public void ReservedValues()
     {
         int index = 0;
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
+            CheckConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
         index = 0;
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
+            CheckConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
             config.GlobalSection.Properties);
     }
     */
@@ -1068,9 +1068,9 @@ public void ReservedValues()
     public void ReservedKeys()
     {
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
+            CheckConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
+            CheckConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
             config.GlobalSection.Properties);
     }
     */
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 98d53d0e384..2ccc4a88c32 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -2,8 +2,13 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
+using System.Text.RegularExpressions;
+using System.IO.Ports;
+using System.Linq;
 using System.Xml;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
@@ -15,6 +20,8 @@ namespace Microsoft.Build.BuildCheck.UnitTests;
 
 public class EndToEndTests : IDisposable
 {
+    private const string EditorConfigFileName = ".editorconfig";
+
     private readonly TestEnvironment _env;
 
     public EndToEndTests(ITestOutputHelper output)
@@ -31,139 +38,349 @@ public EndToEndTests(ITestOutputHelper output)
 
     public void Dispose() => _env.Dispose();
 
-    [Theory(Skip = "https://github.com/dotnet/msbuild/issues/10036")]
+    [Fact]
+    public void PropertiesUsageAnalyzerTest()
+    {
+        using TestEnvironment env = TestEnvironment.Create();
+        string contents = """
+                              <Project DefaultTargets="PrintEnvVar">
+
+                              <!-- MyProp4 is not defined - but it's checked against empty - which is allowed -->
+                              <PropertyGroup Condition="'$(MyProp4)' == ''">
+                                <!-- MyProp3 defined here - but not used anywhere -->
+                                <!-- MyProp1 used here - but not defined -->
+                                <MyProp3>$(MyProp1)</MyProp3>
+                              </PropertyGroup>
+
+
+                              <Target Name="PrintEnvVar">
+                                  <!-- MyProp2 used here - but defined later -->
+                                  <Message Text="MyProp2 has value $(MyProp2)" Importance="High" Condition="'$(MyProp2)' == ''" />
+                                  <PropertyGroup>
+                                    <MyProp2>$(MyProp2);xxx</MyProp2>
+                                  </PropertyGroup>
+                              </Target>
+
+                              </Project>
+                              """;
+        TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
+        TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild($"{projectFile.Path} -check /v:detailed", out bool success);
+        _env.Output.WriteLine(output);
+        _env.Output.WriteLine("=========================");
+        success.ShouldBeTrue(output);
+
+        output.ShouldMatch(@"BC0201: .* Property: \[MyProp1\]");
+        output.ShouldMatch(@"BC0202: .* Property: \[MyProp2\]");
+        // since it's just suggestion, it doesn't have a colon ':'
+        output.ShouldMatch(@"BC0203 .* Property: \[MyProp3\]");
+
+        // each finding should be found just once - but reported twice, due to summary
+        Regex.Matches(output, "BC0201: .* Property").Count.ShouldBe(2);
+        Regex.Matches(output, "BC0202: .* Property").Count.ShouldBe(2);
+        // since it's not an error - it's not in summary
+        Regex.Matches(output, "BC0203 .* Property").Count.ShouldBe(1);
+    }
+
+    [Theory]
     [InlineData(true, true)]
     [InlineData(false, true)]
     [InlineData(false, false)]
-    public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool analysisRequested)
+    public void SampleCheckIntegrationTest_CheckOnBuild(bool buildInOutOfProcessNode, bool checkRequested)
     {
-        TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
-        TransientTestFile testFile = _env.CreateFile(workFolder, "somefile");
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
 
-        string contents = $"""
-            <Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
-                
-                <PropertyGroup>
-                    <OutputType>Exe</OutputType>
-                    <TargetFramework>net8.0</TargetFramework>
-                    <ImplicitUsings>enable</ImplicitUsings>
-                    <Nullable>enable</Nullable>
-                </PropertyGroup>
-                  
-                <PropertyGroup Condition="$(Test) == true">
-                    <TestProperty>Test</TestProperty>
-                </PropertyGroup>
-                 
-                <Target Name="Hello">
-                    <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
-                    <Copy SourceFiles="{testFile.Path}" DestinationFolder="{workFolder.Path}" />
-                    <MSBuild Projects=".\FooBar-Copy.csproj" Targets="Hello" />
-                </Target>
-                
-            </Project>
-            """;
-
-        string contents2 = $"""
-            <Project Sdk="Microsoft.NET.Sdk">
-                <PropertyGroup>
-                    <OutputType>Exe</OutputType>
-                    <TargetFramework>net8.0</TargetFramework>
-                    <ImplicitUsings>enable</ImplicitUsings>
-                    <Nullable>enable</Nullable>
-                </PropertyGroup>
-                                 
-                <PropertyGroup Condition="$(Test) == true">
-                    <TestProperty>Test</TestProperty>
-                </PropertyGroup>
-                                
-                <ItemGroup>
-                    <Reference Include="bin/foo.dll" />
-                </ItemGroup>
-                                
-                <Target Name="Hello">
-                    <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
-                    <Copy SourceFiles="{testFile.Path}" DestinationFolder="{workFolder.Path}" />
-                </Target>
-                               
-            </Project>
-            """;
-        TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
-        TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
+            (checkRequested ? " -check" : string.Empty), out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
+        _env.Output.WriteLine(output);
 
-        TransientTestFile config = _env.CreateFile(workFolder, ".editorconfig",
-            """
-            root=true
+        success.ShouldBeTrue();
 
-            [*.csproj]
-            build_check.BC0101.IsEnabled=true
-            build_check.BC0101.Severity=warning
+        // The check warnings should appear - but only if check was requested.
+        if (checkRequested)
+        {
+            output.ShouldContain("BC0101");
+            output.ShouldContain("BC0102");
+            output.ShouldContain("BC0103");
+        }
+        else
+        {
+            output.ShouldNotContain("BC0101");
+            output.ShouldNotContain("BC0102");
+            output.ShouldNotContain("BC0103");
+        }
+    }
 
-            build_check.BC0102.IsEnabled=true
-            build_check.BC0102.Severity=warning
+    [Theory]
+    [InlineData(true, true, "warning")]
+    [InlineData(true, true, "error")]
+    [InlineData(true, true, "suggestion")]
+    [InlineData(false, true, "warning")]
+    [InlineData(false, true, "error")]
+    [InlineData(false, true, "suggestion")]
+    [InlineData(false, false, "warning")]
+    public void SampleCheckIntegrationTest_ReplayBinaryLogOfCheckedBuild(bool buildInOutOfProcessNode, bool checkRequested, string BC0101Severity)
+    {
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", BC0101Severity) });
 
-            build_check.COND0543.IsEnabled=false
-            build_check.COND0543.Severity=Error
-            build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
-            build_check.COND0543.CustomSwitch=QWERTY
+        var projectDirectory = Path.GetDirectoryName(projectFile.Path);
+        string logFile = _env.ExpectFile(".binlog").Path;
 
-            build_check.BLA.IsEnabled=false
-            """);
+        _ = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore {(checkRequested ? "-check" : string.Empty)} -bl:{logFile}",
+            out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
 
-        // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
-        // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
-        // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
-        _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
+        if (BC0101Severity != "error")
+        {
+            success.ShouldBeTrue();
+        }
 
-        _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
-        _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
-            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
-            (analysisRequested ? " -analyze" : string.Empty), out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
+         $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic",
+         out success, false, _env.Output, timeoutMilliseconds: 120_000);
+
+        _env.Output.WriteLine(output);
+
+        if (BC0101Severity != "error")
+        {
+            success.ShouldBeTrue();
+        }
+
+        // The conflicting outputs warning appears - but only if check was requested
+        if (checkRequested)
+        {
+            output.ShouldContain("BC0101");
+            output.ShouldContain("BC0102");
+            output.ShouldContain("BC0103");
+        }
+        else
+        {
+            output.ShouldNotContain("BC0101");
+            output.ShouldNotContain("BC0102");
+            output.ShouldNotContain("BC0103");
+        }
+    }
+
+    [Theory]
+    [InlineData("warning", "warning BC0101", new string[] { "error BC0101" })]
+    [InlineData("error", "error BC0101", new string[] { "warning BC0101" })]
+    [InlineData("suggestion", "BC0101", new string[] { "error BC0101", "warning BC0101" })]
+    [InlineData("default", "warning BC0101", new string[] { "error BC0101" })]
+    [InlineData("none", null, new string[] { "BC0101" })]
+    public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string expectedOutputValues, string[] unexpectedOutputValues)
+    {
+        PrepareSampleProjectsAndConfig(true, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", BC0101Severity) });
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check",
+            out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
+
+        if (BC0101Severity != "error")
+        {
+            success.ShouldBeTrue();
+        }
+
+        if (!string.IsNullOrEmpty(expectedOutputValues))
+        {
+            output.ShouldContain(expectedOutputValues);
+        }
+
+        foreach (string unexpectedOutputValue in unexpectedOutputValues)
+        {
+            output.ShouldNotContain(unexpectedOutputValue);
+        }
+    }
+
+    [Theory]
+    [InlineData(true, true)]
+    [InlineData(false, true)]
+    [InlineData(false, false)]
+    public void SampleCheckIntegrationTest_CheckOnBinaryLogReplay(bool buildInOutOfProcessNode, bool checkRequested)
+    {
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
+
+        string? projectDirectory = Path.GetDirectoryName(projectFile.Path);
+        string logFile = _env.ExpectFile(".binlog").Path;
+
+        _ = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -bl:{logFile}",
+            out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
+
+        success.ShouldBeTrue();
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+         $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic {(checkRequested ? "-check" : string.Empty)}",
+         out success, false, _env.Output, timeoutMilliseconds: 120_000);
+
         _env.Output.WriteLine(output);
+
         success.ShouldBeTrue();
-        // The analyzer warnings should appear - but only if analysis was requested.
-        if (analysisRequested)
+
+        // The conflicting outputs warning appears - but only if check was requested
+        if (checkRequested)
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
+            output.ShouldContain("BC0103");
         }
         else
         {
             output.ShouldNotContain("BC0101");
             output.ShouldNotContain("BC0102");
+            output.ShouldNotContain("BC0103");
         }
     }
 
     [Theory]
-    [InlineData("AnalysisCandidate", new[] { "CustomRule1", "CustomRule2" })]
-    [InlineData("AnalysisCandidateWithMultipleAnalyzersInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
-    public void CustomAnalyzerTest(string analysisCandidate, string[] expectedRegisteredRules, bool expectedRejectedAnalyzers = false)
+    [InlineData(null, "Property is derived from environment variable: 'TEST'. Properties should be passed explicitly using the /p option.")]
+    [InlineData(true, "Property is derived from environment variable: 'TEST' with value: 'FromEnvVariable'. Properties should be passed explicitly using the /p option.")]
+    [InlineData(false, "Property is derived from environment variable: 'TEST'. Properties should be passed explicitly using the /p option.")]
+    public void NoEnvironmentVariableProperty_Test(bool? customConfigEnabled, string expectedMessage)
+    {
+        List<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? customConfigData = null;
+
+        if (customConfigEnabled.HasValue)
+        {
+            customConfigData = new List<(string, (string, string))>()
+            {
+                ("BC0103", ("allow_displaying_environment_variable_value", customConfigEnabled.Value ? "true" : "false")),
+            };
+        }
+
+        PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode: true,
+            out TransientTestFile projectFile,
+            new List<(string, string)>() { ("BC0103", "error") },
+            customConfigData);
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check", out bool success, false, _env.Output);
+
+        output.ShouldContain(expectedMessage);
+    }
+
+    [Theory]
+    [InlineData(EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData(EvaluationCheckScope.WorkTreeImports)]
+    [InlineData(EvaluationCheckScope.All)]
+    public void NoEnvironmentVariableProperty_Scoping(EvaluationCheckScope scope)
+    {
+        List<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? customConfigData = null;
+
+        string editorconfigScope = scope switch
+        {
+            EvaluationCheckScope.ProjectFileOnly => "project_file",
+            EvaluationCheckScope.WorkTreeImports => "work_tree_imports",
+            EvaluationCheckScope.All => "all",
+            _ => throw new ArgumentOutOfRangeException(nameof(scope), scope, null),
+        };
+
+        customConfigData = new List<(string, (string, string))>()
+        {
+            ("BC0103", ("scope", editorconfigScope)),
+        };
+
+        PrepareSampleProjectsAndConfig(
+            buildInOutOfProcessNode: true,
+            out TransientTestFile projectFile,
+            new List<(string, string)>() { ("BC0103", "error") },
+            customConfigData);
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check", out bool success, false, _env.Output);
+
+        if(scope == EvaluationCheckScope.ProjectFileOnly)
+        {
+            output.ShouldNotContain("Property is derived from environment variable: 'TestImported'. Properties should be passed explicitly using the /p option.");
+        }
+        else
+        {
+            output.ShouldContain("Property is derived from environment variable: 'TestImported'. Properties should be passed explicitly using the /p option.");
+        }
+    }
+
+    [Theory]
+    [InlineData("CheckCandidate", new[] { "CustomRule1", "CustomRule2" })]
+    [InlineData("CheckCandidateWithMultipleChecksInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
+    public void CustomCheckTest_NoEditorConfig(string checkCandidate, string[] expectedRegisteredRules, bool expectedRejectedChecks = false)
     {
         using (var env = TestEnvironment.Create())
         {
-            var analysisCandidatePath = Path.Combine(TestAssetsRootPath, analysisCandidate);
-            AddCustomDataSourceToNugetConfig(analysisCandidatePath);
+            var checkCandidatePath = Path.Combine(TestAssetsRootPath, checkCandidate);
+            AddCustomDataSourceToNugetConfig(checkCandidatePath);
 
-            string projectAnalysisBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
-                $"{Path.Combine(analysisCandidatePath, $"{analysisCandidate}.csproj")} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -analyze -verbosity:n",
+            string projectCheckBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore -check -verbosity:n",
                 out bool successBuild);
-            successBuild.ShouldBeTrue(projectAnalysisBuildLog);
 
             foreach (string registeredRule in expectedRegisteredRules)
             {
-                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerSuccessfulAcquisition", registeredRule));
+                projectCheckBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomCheckSuccessfulAcquisition", registeredRule));
             }
 
-            if (expectedRejectedAnalyzers)
+            if (!expectedRejectedChecks)
+            {
+                successBuild.ShouldBeTrue(projectCheckBuildLog);
+            }
+            else
             {
-                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerBaseTypeNotAssignable", "InvalidAnalyzer", "InvalidCustomAnalyzer, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
+                projectCheckBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
+                    "CustomCheckBaseTypeNotAssignable",
+                    "InvalidCheck",
+                    "InvalidCustomCheck, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
             }
         }
     }
 
-    private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
+    [Theory]
+    [InlineData("CheckCandidate", "X01234", "error", "error X01234")]
+    [InlineData("CheckCandidateWithMultipleChecksInjected", "X01234", "warning", "warning X01234")]
+    public void CustomCheckTest_WithEditorConfig(string checkCandidate, string ruleId, string severity, string expectedMessage)
+    {
+        using (var env = TestEnvironment.Create())
+        {
+            string checkCandidatePath = Path.Combine(TestAssetsRootPath, checkCandidate);
+
+            // Can't use Transitive environment due to the need to dogfood local nuget packages.
+            AddCustomDataSourceToNugetConfig(checkCandidatePath);
+            string editorConfigName = Path.Combine(checkCandidatePath, EditorConfigFileName);
+            File.WriteAllText(editorConfigName, ReadEditorConfig(
+                new List<(string, string)>() { (ruleId, severity) },
+                ruleToCustomConfig: null,
+                checkCandidatePath));
+
+            string projectCheckBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore -check -verbosity:n", out bool _, timeoutMilliseconds: 1200_0000);
+
+            projectCheckBuildLog.ShouldContain(expectedMessage);
+            
+            // Cleanup
+            File.Delete(editorConfigName);
+        }
+    }
+
+    [Theory]
+    [InlineData(true)]
+    [InlineData(false)]
+    public void DoesNotRunOnRestore(bool buildInOutOfProcessNode)
+    {
+        PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
+
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -t:restore -check",
+            out bool success);
+
+        success.ShouldBeTrue();
+        output.ShouldNotContain("BC0101");
+        output.ShouldNotContain("BC0102");
+        output.ShouldNotContain("BC0103");
+    }
+
+    private void AddCustomDataSourceToNugetConfig(string checkCandidatePath)
     {
-        var nugetTemplatePath = Path.Combine(analysisCandidatePath, "nugetTemplate.config");
+        var nugetTemplatePath = Path.Combine(checkCandidatePath, "nugetTemplate.config");
 
         var doc = new XmlDocument();
         doc.LoadXml(File.ReadAllText(nugetTemplatePath));
@@ -171,11 +388,11 @@ private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
         {
             XmlNode? packageSourcesNode = doc.SelectSingleNode("//packageSources");
 
-            // The test packages are generated during the test project build and saved in CustomAnalyzers folder.
-            string analyzersPackagesPath = Path.Combine(Directory.GetParent(AssemblyLocation)?.Parent?.FullName ?? string.Empty, "CustomAnalyzers");
-            AddPackageSource(doc, packageSourcesNode, "Key", analyzersPackagesPath);
+            // The test packages are generated during the test project build and saved in CustomChecks folder.
+            string checksPackagesPath = Path.Combine(Directory.GetParent(AssemblyLocation)?.Parent?.FullName ?? string.Empty, "CustomChecks");
+            AddPackageSource(doc, packageSourcesNode, "Key", checksPackagesPath);
 
-            doc.Save(Path.Combine(analysisCandidatePath, "nuget.config"));
+            doc.Save(Path.Combine(checkCandidatePath, "nuget.config"));
         }
     }
 
@@ -199,4 +416,76 @@ private void PopulateXmlAttribute(XmlDocument doc, XmlNode node, string attribut
         attribute.Value = attributeValue;
         node.Attributes!.Append(attribute);
     }
+
+    private void PrepareSampleProjectsAndConfig(
+        bool buildInOutOfProcessNode,
+        out TransientTestFile projectFile,
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
+        IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig = null)
+    {
+        string testAssetsFolderName = "SampleCheckIntegrationTest";
+        TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
+        TransientTestFile testFile = _env.CreateFile(workFolder, "somefile");
+
+        string contents = ReadAndAdjustProjectContent("Project1");
+        string contents2 = ReadAndAdjustProjectContent("Project2");
+        string contentsImported = ReadAndAdjustProjectContent("ImportedFile1");
+
+        projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
+        TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
+        TransientTestFile importedFile1 = _env.CreateFile(workFolder, "ImportedFile1.props", contentsImported);
+
+        _env.CreateFile(workFolder, ".editorconfig", ReadEditorConfig(ruleToSeverity, ruleToCustomConfig, testAssetsFolderName));
+
+        // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
+        // This discrepancy breaks path equality checks in MSBuild checks if we pass to MSBuild full path to the initial project.
+        // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
+        _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
+
+        _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
+        _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
+
+        _env.SetEnvironmentVariable("TEST", "FromEnvVariable");
+        _env.SetEnvironmentVariable("TestImported", "FromEnv");
+
+        string ReadAndAdjustProjectContent(string fileName) =>
+            File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, fileName))
+                .Replace("TestFilePath", testFile.Path)
+                .Replace("WorkFolderPath", workFolder.Path);
+    }
+
+    private string ReadEditorConfig(
+        IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
+        IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig,
+        string testAssetsFolderName)
+    {
+        string configContent = File.ReadAllText(Path.Combine(TestAssetsRootPath, testAssetsFolderName, $"{EditorConfigFileName}test"));
+
+        PopulateRuleToSeverity(ruleToSeverity, ref configContent);
+        PopulateRuleToCustomConfig(ruleToCustomConfig, ref configContent);
+
+        return configContent;
+    }
+
+    private void PopulateRuleToSeverity(IEnumerable<(string RuleId, string Severity)>? ruleToSeverity, ref string configContent)
+    {
+        if (ruleToSeverity != null && ruleToSeverity.Any())
+        {
+            foreach (var rule in ruleToSeverity)
+            {
+                configContent = configContent.Replace($"build_check.{rule.RuleId}.Severity={rule.RuleId}Severity", $"build_check.{rule.RuleId}.Severity={rule.Severity}");
+            }
+        }
+    }
+
+    private void PopulateRuleToCustomConfig(IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig, ref string configContent)
+    {
+        if (ruleToCustomConfig != null && ruleToCustomConfig.Any())
+        {
+            foreach (var rule in ruleToCustomConfig)
+            {
+                configContent = configContent.Replace($"build_check.{rule.RuleId}.CustomConfig=dummy", $"build_check.{rule.RuleId}.{rule.CustomConfig.ConfigKey}={rule.CustomConfig.Value}");
+            }
+        }
+    }
 }
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 6a72903b8e6..3961ef049c3 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -17,9 +17,9 @@
   </ItemGroup>
   
   <ItemGroup Label="TestAssests">
-    <ProjectReference Include=".\TestAssets\CustomAnalyzer\CustomAnalyzer.csproj" />
-    <ProjectReference Include=".\TestAssets\CustomAnalyzer2\CustomAnalyzer2.csproj" />
-    <ProjectReference Include=".\TestAssets\InvalidCustomAnalyzer\InvalidCustomAnalyzer.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomCheck\CustomCheck.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomCheck2\CustomCheck2.csproj" />
+    <ProjectReference Include=".\TestAssets\InvalidCustomCheck\InvalidCustomCheck.csproj" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
new file mode 100644
index 00000000000..09ad642ff8b
--- /dev/null
+++ b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
@@ -0,0 +1,58 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    internal sealed class MockBuildCheckRegistrationContext : IBuildCheckRegistrationContext
+    {
+        private event Action<BuildCheckDataContext<TaskInvocationCheckData>>? _taskInvocationAction;
+        private event Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>? _evaluatedPropertiesAction;
+
+        public List<BuildCheckResult> Results { get; } = new();
+
+        public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
+            => _evaluatedPropertiesAction += evaluatedPropertiesAction;
+        public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction) => throw new NotImplementedException();
+
+        public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
+            => _taskInvocationAction += taskInvocationAction;
+
+        public void RegisterBuildFinishedAction(Action<BuildCheckDataContext<BuildFinishedCheckData>> buildFinishedAction) => throw new NotImplementedException();
+
+        public void TriggerTaskInvocationAction(TaskInvocationCheckData data)
+        {
+            if (_taskInvocationAction is not null)
+            {
+                BuildCheckDataContext<TaskInvocationCheckData> context = new BuildCheckDataContext<TaskInvocationCheckData>(
+                    null!,
+                    null!,
+                    null!,
+                    ResultHandler,
+                    data);
+                _taskInvocationAction(context);
+            }
+        }
+        public void TriggerEvaluatedPropertiesAction(EvaluatedPropertiesCheckData data)
+        {
+            if (_evaluatedPropertiesAction is not null)
+            {
+                BuildCheckDataContext<EvaluatedPropertiesCheckData> context = new BuildCheckDataContext<EvaluatedPropertiesCheckData>(
+                    null!,
+                    null!,
+                    null!,
+                    ResultHandler,
+                    data);
+                _evaluatedPropertiesAction(context);
+            }
+        }
+
+        private void ResultHandler(CheckWrapper wrapper, ICheckContext context, CheckConfigurationEffective[] configs, BuildCheckResult result)
+            => Results.Add(result);
+    }
+}
+
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
index 7734c19f311..f9f5612c0bb 100644
--- a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -10,7 +10,7 @@
 
 namespace Microsoft.Build.BuildCheck.UnitTests;
 
-public class ParsedItemsAnalysisDataTests
+public class ParsedItemsCheckDataTests
 {
     [Fact]
     public void ItemsHolder_GetItemsOfType_ShouldFilterProperly()
diff --git a/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
new file mode 100644
index 00000000000..629775901a4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
@@ -0,0 +1,138 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    public class SharedOutputPathCheck_Tests
+    {
+        private readonly SharedOutputPathCheck _check;
+
+        private readonly MockBuildCheckRegistrationContext _registrationContext;
+
+        public SharedOutputPathCheck_Tests()
+        {
+            _check = new SharedOutputPathCheck();
+            _registrationContext = new MockBuildCheckRegistrationContext();
+            _check.RegisterActions(_registrationContext);
+        }
+
+        private EvaluatedPropertiesCheckData MakeEvaluatedPropertiesAction(
+            string projectFile,
+            Dictionary<string, string>? evaluatedProperties,
+            IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)>? evaluatedEnvVars)
+        {
+            return new EvaluatedPropertiesCheckData(
+                projectFile,
+                null,
+                evaluatedProperties ?? new Dictionary<string, string>(),
+                evaluatedEnvVars ?? new Dictionary<string, (string EnvVarValue, string File, int Line, int Column)>());
+        }
+
+        [Fact]
+        public void TestTwoProjectsWithSameRelativeOutputPath()
+        {
+            // Full output and intermediate paths are different: "C:/fake1/bin/Debug" and "C:/fake1/obj/Debug".
+            string projectFile1 = NativeMethodsShared.IsWindows ? "C:\\fake1\\project1.proj" : "/fake1/project1.proj";
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile1,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj/Debug" },
+                },
+                null));
+
+            // Full output and intermediate paths are different: "C:/fake2/bin/Debug" and "C:/fake2/obj/Debug".
+            string projectFile2 = NativeMethodsShared.IsWindows ? "C:\\fake2\\project2.proj" : "/fake2/project2.proj";
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile2,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj/Debug" },
+                },
+                null));
+
+            // Relative paths coincide but full does not. SharedOutputPathCheck should not report it.
+            _registrationContext.Results.Count.ShouldBe(0);
+        }
+
+        [Fact]
+        public void TestProjectsWithDifferentPathsSeparators()
+        {
+            // Paths separators are messed up.
+            string projectFile1 = NativeMethodsShared.IsWindows ? "C:\\fake\\project1.proj" : "/fake/project1.proj";
+            string projectFile2 = NativeMethodsShared.IsWindows ? "C:\\fake\\project2.proj" : "/fake/project2.proj";
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile1,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj\\Debug" },
+                },
+                null));
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile2,
+                new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj\\Debug" },
+                },
+                null));
+
+            // 2 reports for bin and obj folders.
+            _registrationContext.Results.Count.ShouldBe(2);
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0101");
+            _registrationContext.Results[1].CheckRule.Id.ShouldBe("BC0101");
+
+            // Check that paths are formed with correct paths separators
+            string wrongPathSeparator = NativeMethodsShared.IsWindows ? "/" : "\\";
+
+            foreach (string path in _registrationContext.Results[0].MessageArgs)
+            {
+                path.ShouldNotContain(wrongPathSeparator);
+            }
+            foreach (string path in _registrationContext.Results[1].MessageArgs)
+            {
+                path.ShouldNotContain(wrongPathSeparator);
+            }
+        }
+
+        [Fact]
+        public void TestThreeProjectsWithSameOutputPath()
+        {
+            string projectFolder = NativeMethodsShared.IsWindows ? "C:\\fake\\" : "/fake/";
+            string projectFile1 = $"{projectFolder}project1.proj";
+            string projectFile2 = $"{projectFolder}project2.proj";
+            string projectFile3 = $"{projectFolder}project3.proj";
+            var evaluatedProperties = new Dictionary<string, string> {
+                    { "OutputPath", "bin/Debug" },
+                    { "IntermediateOutputPath", "obj\\Debug" },};
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile1,
+                evaluatedProperties,
+                null));
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile2,
+                evaluatedProperties,
+                null));
+
+            _registrationContext.TriggerEvaluatedPropertiesAction(MakeEvaluatedPropertiesAction(
+                projectFile3,
+                evaluatedProperties,
+                null));
+
+            _registrationContext.Results.Count.ShouldBe(4); // 4 reports for two pairs of project: (1, 2) and (1, 3).
+            foreach (var result in _registrationContext.Results)
+            {
+                result.CheckRule.Id.ShouldBe("BC0101");
+            }
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
index e0600fc657c..7d109f7da15 100644
--- a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
@@ -17,18 +17,18 @@
 
 namespace Microsoft.Build.BuildCheck.UnitTests
 {
-    public class TaskInvocationAnalysisDataTests : IDisposable
+    public class TaskInvocationCheckDataTests : IDisposable
     {
-        internal sealed class TestAnalyzer : BuildAnalyzer
+        internal sealed class TestCheck : Check
         {
-            #region BuildAnalyzer initialization
+            #region Check initialization
 
-            public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0000", "TestRule", "TestDescription", "TestMessage",
-                new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+            public static CheckRule SupportedRule = new CheckRule("BC0000", "TestRule", "TestDescription", "TestMessage",
+                new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
-            public override string FriendlyName => "MSBuild.TestAnalyzer";
+            public override string FriendlyName => "MSBuild.TestCheck";
 
-            public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+            public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
             public override void Initialize(ConfigurationContext configurationContext)
             { }
@@ -43,29 +43,29 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             /// <summary>
             /// Stores all TaskInvocationAnalysisData reported during the build.
             /// </summary>
-            public List<TaskInvocationAnalysisData> AnalysisData = new();
+            public List<TaskInvocationCheckData> CheckData = new();
 
-            private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+            private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
             {
-                AnalysisData.Add(context.Data);
+                CheckData.Add(context.Data);
             }
         }
 
-        private static TestAnalyzer? s_testAnalyzer;
+        private static TestCheck? s_testCheck;
 
-        public TaskInvocationAnalysisDataTests()
+        public TaskInvocationCheckDataTests()
         {
             BuildCheckManager.s_testFactoriesPerDataSource =
             [
                 // BuildCheckDataSource.EventArgs
                 [
-                    ([TestAnalyzer.SupportedRule.Id], true, () => (s_testAnalyzer = new TestAnalyzer())),
+                    ([TestCheck.SupportedRule.Id], true, () => (s_testCheck = new TestCheck())),
                 ],
                 // BuildCheckDataSource.Execution
                 [],
             ];
 
-            s_testAnalyzer?.AnalysisData.Clear();
+            s_testCheck?.CheckData.Clear();
         }
 
         public void Dispose()
@@ -81,7 +81,7 @@ private void BuildProject(string taskInvocation)
 
                 using (var buildManager = new BuildManager())
                 {
-                    var request = new BuildRequestData(testProject.ProjectFile, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, [], null, BuildRequestDataFlags.None);
+                    var request = new BuildRequestData(testProject.ProjectFile, new Dictionary<string, string?>(), MSBuildConstants.CurrentToolsVersion, [], null, BuildRequestDataFlags.None);
                     var parameters = new BuildParameters
                     {
                         LogTaskInputs = true,
@@ -94,7 +94,7 @@ private void BuildProject(string taskInvocation)
                     result.OverallResult.ShouldBe(BuildResultCode.Success);
                 }
 
-                foreach (var data in s_testAnalyzer!.AnalysisData)
+                foreach (var data in s_testCheck!.CheckData)
                 {
                     data.ProjectFilePath.ShouldBe(testProject.ProjectFile);
                     data.TaskInvocationLocation.Line.ShouldBeGreaterThan(0);
@@ -108,8 +108,8 @@ public void ReportsSimpleTaskParameters()
         {
             BuildProject("<Message Text='Hello'/>");
 
-            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
-            var data = s_testAnalyzer.AnalysisData[0];
+            s_testCheck!.CheckData.Count.ShouldBe(1);
+            var data = s_testCheck.CheckData[0];
             data.TaskName.ShouldBe("Message");
             data.Parameters.Count.ShouldBe(1);
             data.Parameters["Text"].IsOutput.ShouldBe(false);
@@ -130,8 +130,8 @@ public void ReportsComplexTaskParameters(string outputElement)
                 </CombinePath>
             """);
 
-            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
-            var data = s_testAnalyzer.AnalysisData[0];
+            s_testCheck!.CheckData.Count.ShouldBe(1);
+            var data = s_testCheck.CheckData[0];
             data.TaskName.ShouldBe("CombinePath");
             data.Parameters.Count.ShouldBe(3);
 
@@ -174,8 +174,8 @@ public void TaskParameterEnumeratesValues()
             parameter5.EnumerateValues().SequenceEqual(array2).ShouldBeTrue();
             parameter5.EnumerateStringValues().SequenceEqual(["item1", "item2"]).ShouldBeTrue();
 
-            static TaskInvocationAnalysisData.TaskParameter MakeParameter(object value)
-                => new TaskInvocationAnalysisData.TaskParameter(value, IsOutput: false);
+            static TaskInvocationCheckData.TaskParameter MakeParameter(object value)
+                => new TaskInvocationCheckData.TaskParameter(value, IsOutput: false);
         }
     }
 }
diff --git a/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest
new file mode 100644
index 00000000000..be166e833cd
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest
@@ -0,0 +1,4 @@
+root = true
+
+[*.csproj]
+build_check.X01234.Severity=X01234Severity
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/CheckCandidate.csproj
similarity index 83%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidate/CheckCandidate.csproj
index 52f65afffee..6d35fe06138 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/CheckCandidate.csproj
@@ -6,7 +6,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
+    <PackageReference Include="CustomCheck" Version="1.0.0"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/nugetTemplate.config
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidate/nugetTemplate.config
diff --git a/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
new file mode 100644
index 00000000000..be166e833cd
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
@@ -0,0 +1,4 @@
+root = true
+
+[*.csproj]
+build_check.X01234.Severity=X01234Severity
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
similarity index 62%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
index 0ffaa8d26b7..07695e19e8e 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
@@ -6,9 +6,9 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
-    <PackageReference Include="CustomAnalyzer2" Version="1.0.0"/>
-    <PackageReference Include="InvalidCustomAnalyzer" Version="1.0.0"/>
+    <PackageReference Include="CustomCheck" Version="1.0.0"/>
+    <PackageReference Include="CustomCheck2" Version="1.0.0"/>
+    <PackageReference Include="InvalidCustomCheck" Version="1.0.0"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/nugetTemplate.config
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/nugetTemplate.config
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
index 4e4cb1c0796..d79475be5f0 100644
--- a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
@@ -5,7 +5,7 @@
     <IsPackable>true</IsPackable>
     <IsShipping>false</IsShipping>
     <PackageVersion>1.0.0</PackageVersion>
-    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomAnalyzers</ArtifactsNonShippingPackagesDir>
+    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomChecks</ArtifactsNonShippingPackagesDir>
     <NoWarn>NU5101;NU5128;MSB3277;NU1507;NU1701;NU1702;NU5104</NoWarn>
   </PropertyGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props
deleted file mode 100644
index 31a9526dd62..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomAnalyzer.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props
deleted file mode 100644
index 869000fa12f..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomAnalyzer2.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
similarity index 65%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
index 5cd1d3317c0..940791d3705 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace CustomAnalyzer
+namespace CustomCheck
 {
-    public sealed class Analyzer1 : BuildAnalyzer
+    public sealed class Check1 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01234",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule1";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -27,7 +27,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
similarity index 65%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
index 714a82ae95a..4517f8eeee6 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace CustomAnalyzer
+namespace CustomCheck
 {
-    public sealed class Analyzer2 : BuildAnalyzer
+    public sealed class Check2 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01235",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule2";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -27,7 +27,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.csproj
similarity index 79%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.csproj
index f27ab620690..fc81bc53eb5 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.csproj
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="CustomAnalyzer.props" Pack="true" PackagePath="build\CustomAnalyzer.props" />
+    <None Include="CustomCheck.props" Pack="true" PackagePath="build\CustomCheck.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.props b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.props
new file mode 100644
index 00000000000..f7aae0517f4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomCheck.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
similarity index 65%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
index c0272937c87..528b29e224a 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace CustomAnalyzer2
+namespace CustomCheck2
 {
-    public sealed class Analyzer3 : BuildAnalyzer
+    public sealed class Check3 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01235",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule3";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -27,7 +27,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.csproj
similarity index 78%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.csproj
index a405546f1cc..5d4396dea07 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.csproj
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="CustomAnalyzer2.props" Pack="true" PackagePath="build\CustomAnalyzer2.props" />
+    <None Include="CustomCheck2.props" Pack="true" PackagePath="build\CustomCheck2.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.props b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.props
new file mode 100644
index 00000000000..f2377250f91
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomCheck2.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
deleted file mode 100644
index e5f466ce414..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿using System.Collections.Generic;
-
-namespace InvalidCustomAnalyzer
-{
-    public sealed class InvalidAnalyzer
-    {
-        public string FriendlyName => "InvalidAnalyzer";
-    }
-}
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
deleted file mode 100644
index 52a9bab57c0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)InvalidCustomAnalyzer.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs
new file mode 100644
index 00000000000..0b727549e95
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs
@@ -0,0 +1,9 @@
+﻿using System.Collections.Generic;
+
+namespace InvalidCustomCheck
+{
+    public sealed class InvalidCheck
+    {
+        public string FriendlyName => "InvalidCheck";
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.csproj
similarity index 76%
rename from src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
rename to src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.csproj
index 4ef7f0674ca..81c7c28efe7 100644
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.csproj
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="InvalidCustomAnalyzer.props" Pack="true" PackagePath="build\InvalidCustomAnalyzer.props" />
+    <None Include="InvalidCustomCheck.props" Pack="true" PackagePath="build\InvalidCustomCheck.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.props b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.props
new file mode 100644
index 00000000000..01867df6b8a
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)InvalidCustomCheck.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
new file mode 100644
index 00000000000..57d36981808
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
@@ -0,0 +1,13 @@
+root=true
+
+[*.csproj]
+build_check.BC0101.Severity=BC0101Severity
+
+build_check.BC0102.Severity=warning
+
+build_check.BC0103.Severity=warning
+build_check.BC0103.CustomConfig=dummy
+
+build_check.COND0543.Severity=Error
+build_check.COND0543.EvaluationCheckScope=CheckedProjectOnly
+build_check.COND0543.CustomSwitch=QWERTY
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1
new file mode 100644
index 00000000000..ff344c1d281
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+
+    <PropertyGroup Condition="$(TestImported) == true">
+        <TestProperty>TestImported</TestProperty>
+    </PropertyGroup>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1
new file mode 100644
index 00000000000..4412879248c
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1
@@ -0,0 +1,29 @@
+<Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
+                
+   <PropertyGroup>
+       <OutputType>Exe</OutputType>
+       <TargetFramework>net8.0</TargetFramework>
+       <ImplicitUsings>enable</ImplicitUsings>
+       <Nullable>enable</Nullable>
+   </PropertyGroup>
+
+   <Import Project="ImportedFile1.props" />
+
+   <PropertyGroup Condition="$(Test) == true">
+       <TestProperty>Test</TestProperty>
+   </PropertyGroup>
+
+   <Target Name="Hello">
+       <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+       <Copy SourceFiles="TestFilePath" DestinationFolder="WorkFolderPath" />
+       <MSBuild Projects=".\FooBar-Copy.csproj" Targets="Hello" />
+
+       <PropertyGroup>
+         <ReadFromEnvVariable>$(TEST)</ReadFromEnvVariable>
+       </PropertyGroup>
+
+       <Message Importance="High" Text="$(ReadFromEnvVariable)" />
+
+   </Target>
+                
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2
new file mode 100644
index 00000000000..17b8d3da249
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2
@@ -0,0 +1,22 @@
+<Project Sdk="Microsoft.NET.Sdk">
+    <PropertyGroup>
+        <OutputType>Exe</OutputType>
+        <TargetFramework>net8.0</TargetFramework>
+        <ImplicitUsings>enable</ImplicitUsings>
+        <Nullable>enable</Nullable>
+    </PropertyGroup>
+                     
+    <PropertyGroup Condition="$(Test) == true">
+        <TestProperty>Test</TestProperty>
+    </PropertyGroup>
+                    
+    <ItemGroup>
+        <Reference Include="bin/foo.dll" />
+    </ItemGroup>
+                    
+    <Target Name="Hello">
+        <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+        <Copy SourceFiles="TestFilePath" DestinationFolder="WorkFolderPath" />
+    </Target>
+                   
+</Project>
\ No newline at end of file
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 1990818c5e3..699df69088c 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -117,9 +117,9 @@ namespace Microsoft.Build.Conversion
      **************************************************************************/
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// This class performs a project file format conversion from Visual Studio
     /// .NET 2002 or 2003 to MSBuild format (for Whidbey).
     /// </summary>
@@ -207,9 +207,9 @@ public sealed class ProjectFileConverter
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Default constructor.  We need a constructor that takes zero parameters,
         /// because this class needs to be instantiated from COM.
@@ -239,9 +239,9 @@ public ProjectFileConverter
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The read/write accessor for the old project filename.  This must be
         /// set by the consumer before calling Convert().
@@ -271,9 +271,9 @@ public string OldProjectFile
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The read/write accessor for the new project filename.  This must be
         /// set by the consumer before calling Convert().
@@ -303,9 +303,9 @@ public string NewProjectFile
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The read/write accessor for the boolean which tells the converter
         /// whether the project file we're converting is a "main" project file
@@ -338,9 +338,9 @@ public bool IsUserFile
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The read/write accessor for the solution file which contains this
         /// project being converted.  This is used to look up information about the
@@ -371,9 +371,9 @@ public string SolutionFile
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Indicates if the last attempted conversion was skipped because the project is already in the latest format.
         /// This will always return false;
@@ -400,9 +400,9 @@ public bool ConversionSkippedBecauseProjectAlreadyConverted
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This property returns the list of warnings that were generated during the conversion
         /// </summary>
@@ -429,9 +429,9 @@ public string[] ConversionWarnings
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Is the conversion a minor upgrade operation?
         /// Minor upgrade also means the converted project file can be opened in old VS as well, so we won't update the tools version.
@@ -461,9 +461,9 @@ public bool IsMinorUpgrade
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This is the entry point method, which performs the project file format
         /// conversion.  This method will overwrite "newProjectFile" if it already
@@ -1064,9 +1064,9 @@ private bool FixTargetFrameworkSubset()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Performs conversions specific to F# projects (VS2008 CTP -> VS2012) and (VS2010 -> VS2012).
         /// This involves: changing the location of FSharp targets,
@@ -1515,9 +1515,9 @@ private bool VBSpecificConversions()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This is the entry point method, which performs the project file format
         /// conversion.  This method will simply create a new MSBuild Project object
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index 4901dbab37b..ca1e9c4dffc 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -18,9 +18,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a single task.
     /// </summary>
@@ -144,9 +144,9 @@ internal XmlElement TaskXmlElement
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the task's "name" element.
         /// </summary>
@@ -171,9 +171,9 @@ public string Name
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the task's "condition".
         /// </summary>
@@ -215,9 +215,9 @@ public string Condition
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the task's "ContinueOnError".
         /// </summary>
@@ -284,9 +284,9 @@ public bool ContinueOnError
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// System.Type object corresponding to the task class that implements
         /// the functionality that runs this task object.
@@ -336,9 +336,9 @@ public Type Type
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the "host object" for this task.
         /// </summary>
@@ -390,9 +390,9 @@ internal Target ParentTarget
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This retrieves the list of all parameter names from the element
         /// node of this task. Note that it excludes anything that a specific
@@ -438,9 +438,9 @@ public string[] GetParameterNames()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This retrieves an arbitrary attribute from the task element.  These
         /// are attributes that the project author has placed on the task element
@@ -478,9 +478,9 @@ string attributeName
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This sets an arbitrary attribute on the task element.  These
         /// are attributes that the project author has placed on the task element
@@ -514,9 +514,9 @@ bool treatParameterValueAsLiteral
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This sets an arbitrary attribute on the task element.  These
         /// are attributes that the project author has placed on the task element
@@ -560,9 +560,9 @@ string parameterValue
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Adds an Output tag to this task element
         /// </summary>
@@ -615,9 +615,9 @@ internal void AddOutputItem(string taskParameter, string itemName, string condit
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Adds an Output tag to this task element
         /// </summary>
@@ -654,9 +654,9 @@ public void AddOutputProperty(string taskParameter, string propertyName)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Runs the task associated with this object.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/Import.cs b/src/Deprecated/Engine/Engine/Import.cs
index e51e7d5c55b..2db3879914e 100644
--- a/src/Deprecated/Engine/Engine/Import.cs
+++ b/src/Deprecated/Engine/Engine/Import.cs
@@ -13,9 +13,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a single Import element in a project file
     /// </summary>
@@ -59,9 +59,9 @@ internal XmlElement ImportElement
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Returns true if this Import came from an imported project
         /// </summary>
@@ -85,9 +85,9 @@ public bool IsImported
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Returns the original import path from the Import element
         /// </summary>
@@ -128,9 +128,9 @@ internal XmlAttribute ProjectPathAttribute
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Returns the full evaluated import path
         /// </summary>
@@ -154,9 +154,9 @@ public string EvaluatedProjectPath
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The condition string for this UsingTask
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/ImportCollection.cs b/src/Deprecated/Engine/Engine/ImportCollection.cs
index 0b724418cad..a397a3a33a0 100644
--- a/src/Deprecated/Engine/Engine/ImportCollection.cs
+++ b/src/Deprecated/Engine/Engine/ImportCollection.cs
@@ -15,9 +15,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a collection of all Import elements in a given project file
     /// </summary>
@@ -64,9 +64,9 @@ internal ImportCollection(Project parentProject)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// IEnumerable member method for returning the enumerator
         /// </summary>
@@ -94,9 +94,9 @@ public IEnumerator GetEnumerator()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// ICollection member method for copying the contents of this collection into an array
         /// </summary>
@@ -121,9 +121,9 @@ public void CopyTo(Array array, int index)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// ICollection member property for returning the number of items in this collection
         /// </summary>
@@ -149,9 +149,9 @@ public int Count
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// ICollection member property for determining whether this collection is thread-safe
         /// </summary>
@@ -177,9 +177,9 @@ public bool IsSynchronized
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// ICollection member property for returning this collection's synchronization object
         /// </summary>
@@ -246,9 +246,9 @@ internal Import this[string index]
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Copy the contents of this collection into a strongly typed array
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index ed6334ecee4..19e512008a0 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -20,9 +20,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a single target in its parent project.
     /// </summary>
@@ -290,9 +290,9 @@ internal int Id
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the target's name as specified in the "Name" attribute. The value of this attribute is never evaluated.
         /// </summary>
@@ -317,9 +317,9 @@ public string Name
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the target's unevaluated "DependsOnTargets" string.
         /// Returns unevaluated.
@@ -350,9 +350,9 @@ public string DependsOnTargets
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the target's unevaluated "Inputs" string.
         /// Returns unevaluated.
@@ -383,9 +383,9 @@ public string Inputs
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the target's unevaluated "Outputs" string.
         /// Returns unevaluated.
@@ -416,9 +416,9 @@ public string Outputs
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the item's "condition". Returned unevaluated.
         /// </summary>
@@ -563,9 +563,9 @@ internal List<string> GetBatchableTargetParameters()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This returns a boolean telling you whether this particular target
         /// was imported from another project, or whether it was defined
@@ -612,9 +612,9 @@ internal TargetExecutionWrapper ExecutionState
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Allows the caller to use a foreach loop to enumerate through the individual
         /// BuildTask objects contained within this Target.
@@ -884,9 +884,9 @@ string attributeValue
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Adds a task with the specified name to the end of this target.  This method
         /// does all of the work to manipulate the project's XML content.
@@ -928,9 +928,9 @@ string taskName
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Removes the specified BuildTask from the target.  This method correctly updates
         /// the project's XML content, so the task will no longer show up when the project
diff --git a/src/Deprecated/Engine/Engine/TargetCollection.cs b/src/Deprecated/Engine/Engine/TargetCollection.cs
index fa101c9c3c4..f574b1f7c31 100644
--- a/src/Deprecated/Engine/Engine/TargetCollection.cs
+++ b/src/Deprecated/Engine/Engine/TargetCollection.cs
@@ -17,9 +17,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a collection of persisted &lt;Target&gt;'s.  Each
     /// MSBuild project has exactly one TargetCollection, which includes
@@ -82,9 +82,9 @@ internal Project ParentProject
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Read-only property which returns the number of Targets contained
         /// in our collection.
@@ -112,9 +112,9 @@ public int Count
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This ICollection property tells whether this object is thread-safe.
         /// </summary>
@@ -139,9 +139,9 @@ public bool IsSynchronized
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This ICollection property returns the object to be used to synchronize
         /// access to the class.
@@ -167,9 +167,9 @@ public object SyncRoot
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the target with the given name, case-insensitively.
         /// Note that this also defines the .BuildItem() accessor automagically.
@@ -203,9 +203,9 @@ public Target this[string index]
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This ICollection method copies the contents of this collection to an
         /// array.
@@ -234,9 +234,9 @@ int index
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the Target objects contained in
@@ -280,9 +280,9 @@ internal void AddOverrideTarget(Target newTarget)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Adds a new &lt;Target&gt; element to the project file, at the very end.
         /// </summary>
@@ -326,9 +326,9 @@ string targetName
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Removes a target from the project, and removes the corresponding &lt;Target&gt; element
         /// from the project's XML.
@@ -383,9 +383,9 @@ Target targetToRemove
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Checks if a target with given name already exists
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/Toolset.cs b/src/Deprecated/Engine/Engine/Toolset.cs
index 6cd7b37a330..c996b2936fa 100644
--- a/src/Deprecated/Engine/Engine/Toolset.cs
+++ b/src/Deprecated/Engine/Engine/Toolset.cs
@@ -13,9 +13,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// Aggregation of a toolset version (eg. "2.0"), tools path, and optional set of associated properties
     /// </summary>
diff --git a/src/Deprecated/Engine/Engine/ToolsetCollection.cs b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
index 57769b2776b..38bfb7b7897 100644
--- a/src/Deprecated/Engine/Engine/ToolsetCollection.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetCollection.cs
@@ -14,9 +14,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// Implementation of ICollection&lt;Toolset&gt; that also supports
     /// key-based retrieval by passing the string value of the tools version
@@ -66,10 +66,10 @@ internal ToolsetCollection(Engine parentEngine)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// The names of the toolsets stored in this collection.
         /// </summary>
         /// <remarks>
@@ -92,9 +92,9 @@ public IEnumerable<string> ToolsVersions
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the Toolset with matching toolsVersion.
         /// </summary>
@@ -128,9 +128,9 @@ public Toolset this[string toolsVersion]
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Determines whether the collection contains a Toolset with matching
         /// tools version.
@@ -167,9 +167,9 @@ public int Count
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Always returns false
         /// </summary>
@@ -193,10 +193,10 @@ public bool IsReadOnly
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Adds the given Toolset to this collection, replacing any previous value
         /// with the same tools version.  Also notifies the parent Engine of the
         /// change.
@@ -232,9 +232,9 @@ public void Add(Toolset item)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This method is not supported.
         /// </summary>
@@ -255,9 +255,9 @@ public void Clear()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Determines whether or not this collection contains the given toolset.
         /// </summary>
@@ -280,9 +280,9 @@ public bool Contains(Toolset item)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Copies the contents of this collection to the given array, beginning
         /// at the given index.
@@ -306,9 +306,9 @@ public void CopyTo(Toolset[] array, int arrayIndex)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Generic enumerator for the Toolsets in this collection.
         /// </summary>
@@ -330,9 +330,9 @@ public IEnumerator<Toolset> GetEnumerator()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Non-generic enumerator for the Toolsets in this collection.
         /// </summary>
@@ -354,10 +354,10 @@ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// This method is not supported.
         /// </summary>
         /// <param name="item"></param>
diff --git a/src/Deprecated/Engine/Engine/UsingTask.cs b/src/Deprecated/Engine/Engine/UsingTask.cs
index ae384542520..7fe49860a72 100644
--- a/src/Deprecated/Engine/Engine/UsingTask.cs
+++ b/src/Deprecated/Engine/Engine/UsingTask.cs
@@ -14,9 +14,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a single UsingTask element in a project file
     /// </summary>
@@ -39,9 +39,9 @@ public class UsingTask
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Returns true if this UsingTask was imported from another project
         /// </summary>
@@ -65,9 +65,9 @@ public bool IsImported
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The task name
         /// </summary>
@@ -99,9 +99,9 @@ internal XmlAttribute TaskNameAttribute
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The name of the assembly containing the task
         /// </summary>
@@ -133,9 +133,9 @@ internal XmlAttribute AssemblyNameAttribute
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The assembly file containing the task
         /// </summary>
@@ -167,9 +167,9 @@ internal XmlAttribute AssemblyFileAttribute
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The condition string for this UsingTask
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/UsingTaskCollection.cs b/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
index feee5b19458..90e3cfd0e0f 100644
--- a/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
+++ b/src/Deprecated/Engine/Engine/UsingTaskCollection.cs
@@ -14,9 +14,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a collection of all UsingTask elements in a given project file.
     /// </summary>
@@ -56,9 +56,9 @@ internal UsingTaskCollection()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// IEnumerable member method for returning the enumerator
         /// </summary>
@@ -86,9 +86,9 @@ public IEnumerator GetEnumerator()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// ICollection member method for copying the contents of this collection into an array
         /// </summary>
@@ -113,10 +113,10 @@ public void CopyTo(Array array, int index)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// ICollection member property for returning the number of items in this collection
         /// </summary>
         /// <remarks>
@@ -141,9 +141,9 @@ public int Count
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// ICollection member property for determining whether this collection is thread-safe
         /// </summary>
@@ -169,9 +169,9 @@ public bool IsSynchronized
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// ICollection member property for returning this collection's synchronization object
         /// </summary>
@@ -237,9 +237,9 @@ internal UsingTask this[int index]
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Copy the contents of this collection into a strongly typed array
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/Utilities.cs b/src/Deprecated/Engine/Engine/Utilities.cs
index 71593148804..051e2f92fd9 100644
--- a/src/Deprecated/Engine/Engine/Utilities.cs
+++ b/src/Deprecated/Engine/Engine/Utilities.cs
@@ -19,9 +19,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class contains utility methods for the MSBuild engine.
     /// </summary>
@@ -537,9 +537,9 @@ internal static string RemoveXmlNamespace(string xml)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Escapes given string, that is replaces special characters with escape sequences that allow MSBuild hosts
         /// to treat MSBuild-interpreted characters literally (';' becomes "%3b" and so on).
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index a8b941e0975..086aa26a7a5 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -16,9 +16,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This exception is used to wrap an unhandled exception from a logger. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
@@ -140,10 +140,10 @@ private InternalLoggerException(SerializationInfo info, StreamingContext context
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// ISerializable method which we must override since Exception implements this interface
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
diff --git a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
index 8d329e3076c..4e1e59b8e07 100644
--- a/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidProjectFileException.cs
@@ -16,9 +16,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This exception is thrown whenever there is a problem with the user's XML project file. The problem might be semantic or
     /// syntactical. The latter would be of a type typically caught by XSD validation (if it was performed by the project writer).
@@ -45,9 +45,9 @@ public sealed class InvalidProjectFileException : Exception
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Default constructor.
         /// </summary>
@@ -73,10 +73,10 @@ public InvalidProjectFileException()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Creates an instance of this exception using the specified error message.
         /// </summary>
         /// <remarks>
@@ -102,10 +102,10 @@ public InvalidProjectFileException(string message)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Creates an instance of this exception using the specified error message and inner exception.
         /// </summary>
         /// <owner>SumedhK</owner>
@@ -156,9 +156,9 @@ private InvalidProjectFileException(SerializationInfo info, StreamingContext con
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// ISerializable method which we must override since Exception implements this interface
         /// If we ever add new members to this class, we'll need to update this.
@@ -197,9 +197,9 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Creates an instance of this exception using rich error information.
         /// </summary>
@@ -245,9 +245,9 @@ string helpKeyword
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Creates an instance of this exception using rich error information.
         /// </summary>
@@ -305,9 +305,9 @@ string helpKeyword
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the exception message including the affected project file (if any).
         /// </summary>
@@ -335,9 +335,9 @@ public override string Message
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the exception message not including the project file.
         /// </summary>
@@ -363,9 +363,9 @@ public string BaseMessage
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the project file (if any) associated with this exception.
         /// </summary>
@@ -391,10 +391,10 @@ public string ProjectFile
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Gets the invalid line number (if any) in the project.
         /// </summary>
         /// <owner>SumedhK</owner>
@@ -419,9 +419,9 @@ public int LineNumber
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the invalid column number (if any) in the project.
         /// </summary>
@@ -447,9 +447,9 @@ public int ColumnNumber
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the last line number (if any) of a range of invalid lines in the project.
         /// </summary>
@@ -475,10 +475,10 @@ public int EndLineNumber
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Gets the last column number (if any) of a range of invalid columns in the project.
         /// </summary>
         /// <owner>SumedhK</owner>
@@ -503,9 +503,9 @@ public int EndColumnNumber
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the error sub-category (if any) that describes the type of this error.
         /// </summary>
@@ -531,10 +531,10 @@ public string ErrorSubcategory
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Gets the error code (if any) associated with the exception message.
         /// </summary>
         /// <owner>SumedhK</owner>
@@ -559,10 +559,10 @@ public string ErrorCode
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Gets the F1-help keyword (if any) associated with this error, for the host IDE.
         /// </summary>
         /// <owner>SumedhK</owner>
diff --git a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
index 349ff2bb620..4d9aaa39cb4 100644
--- a/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Deprecated/Engine/Errors/InvalidToolsetDefinitionException.cs
@@ -15,9 +15,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// Exception subclass that ToolsetReaders should throw.
     /// </summary>
@@ -41,10 +41,10 @@ public class InvalidToolsetDefinitionException : Exception
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Basic constructor.
         /// </summary>
         /// <remarks>
@@ -64,10 +64,10 @@ public InvalidToolsetDefinitionException()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Basic constructor.
         /// </summary>
         /// <param name="message"></param>
@@ -88,10 +88,10 @@ public InvalidToolsetDefinitionException(string message)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Basic constructor.
         /// </summary>
         /// <param name="message"></param>
@@ -126,10 +126,10 @@ protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingCon
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Constructor that takes an MSBuild error code
         /// </summary>
         /// <param name="message"></param>
@@ -152,9 +152,9 @@ public InvalidToolsetDefinitionException(string message, string errorCode)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Constructor that takes an MSBuild error code
         /// </summary>
@@ -179,10 +179,10 @@ public InvalidToolsetDefinitionException(string message, string errorCode, Excep
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// ISerializable method which we must override since Exception implements this interface
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
@@ -210,9 +210,9 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The MSBuild error code corresponding with this exception, or
         /// null if none was specified.
diff --git a/src/Deprecated/Engine/Errors/RemoteErrorException.cs b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
index 94e7adf41c3..0a4462e055f 100644
--- a/src/Deprecated/Engine/Errors/RemoteErrorException.cs
+++ b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
@@ -16,9 +16,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class is used to wrap exceptions that occur on a different node
     /// </summary>
@@ -60,9 +60,9 @@ private RemoteErrorException(SerializationInfo info, StreamingContext context)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// ISerializable method which we must override since Exception implements this interface
         /// If we ever add new members to this class, we'll need to update this.
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index 69e73737084..8076c0ba31d 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -20,9 +20,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a single item of the project. An item is usually a file on disk, with a type associated with it, and
     /// its own item-specific attributes. The list of items is initially specified via XML tags in the project file, although a
@@ -478,9 +478,9 @@ private void BuildItemHelper(XmlDocument ownerDocument, string itemName, string
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This constructor creates a new virtual (non-persisted) item with the
         /// specified type and include.
@@ -528,9 +528,9 @@ internal BuildItem(XmlElement itemElement, bool importedFromAnotherProject, bool
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This constructor creates a new virtual (non-persisted) item based
         /// on a ITaskItem object that was emitted by a task.
@@ -583,9 +583,9 @@ public BuildItem(string itemName, ITaskItem taskItem)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This returns a boolean telling you whether this particular item
         /// was imported from another project, or whether it was defined
@@ -609,9 +609,9 @@ public bool IsImported
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the item's "type" string.  Note that changing the "Type"
         /// of an BuildItem requires the whole project to be re-evalauted.  This is because
@@ -690,9 +690,9 @@ internal ItemDefinitionLibrary ItemDefinitionLibrary
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the item's "include" string.
         /// </summary>
@@ -766,9 +766,9 @@ public string Include
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the names of metadata on the item -- also includes the pre-defined/reserved item-spec modifiers.
         /// </summary>
@@ -800,9 +800,9 @@ public ICollection MetadataNames
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the number of metadata set on the item.
         /// </summary>
@@ -828,9 +828,9 @@ public int MetadataCount
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the names of metadata on the item -- also includes the pre-defined/reserved item-spec modifiers.
         /// </summary>
@@ -857,9 +857,9 @@ public ICollection CustomMetadataNames
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the number of metadata set on the item.
         /// </summary>
@@ -894,9 +894,9 @@ internal XmlAttribute IncludeAttribute
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the item's "exclude" string.
         /// </summary>
@@ -940,9 +940,9 @@ internal XmlAttribute ExcludeAttribute
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the item's "condition".
         /// </summary>
@@ -1379,9 +1379,9 @@ BuildEventContext buildEventContext
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Indicates if the given metadata is set on the item.
         /// </summary>
@@ -1430,9 +1430,9 @@ public bool HasMetadata(string metadataName)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Retrieves an arbitrary unevaluated metadata value from the item element. These are pieces of metadata that the project author has
         /// placed on the item element that have no meaning to MSBuild. They are just arbitrary metadata that travel around with
@@ -1483,9 +1483,9 @@ public string GetMetadata(string metadataName)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Retrieves an arbitrary metadata from the item element, expands any property and item references within it, and
         /// unescapes it.
@@ -1594,9 +1594,9 @@ internal int GetCustomMetadataCount()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Copies all custom attributes to given item.
         /// </summary>
@@ -1742,9 +1742,9 @@ private IDictionary MergeDefaultMetadata(IDictionary customMetadata)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Sets custom metadata on this item, with the option of treating the metadata value
         /// literally, meaning that special sharacters will be escaped.
@@ -1826,9 +1826,9 @@ internal void RevertToPersistedMetadata()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Sets an arbitrary metadata on the item element. These are metadata that the project author has placed on the item
         /// element that have no meaning to MSBuild. They are just arbitrary metadata that travel around with the BuildItem.
@@ -1873,10 +1873,10 @@ public void SetMetadata(string metadataName, string metadataValue)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Removes the specified metadata on the item.
         /// </summary>
         /// <remarks>Removal of well-known metadata is not allowed.</remarks>
@@ -2153,9 +2153,9 @@ internal void SplitChildItemIfNecessary()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This creates a shallow clone of the BuildItem.  If this is an xml-backed item,
         /// then the clone references the same XML element as the original, meaning
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index a6636fc7580..b1540013640 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -17,9 +17,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a collection of items.  It may be represented
     /// physically by an &lt;ItemGroup&gt; element persisted in the project file,
@@ -72,9 +72,9 @@ public class BuildItemGroup : IItemPropertyGrouping, IEnumerable
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Default constructor, which initializes a virtual (non-persisted) BuildItemGroup.
         /// </summary>
@@ -133,9 +133,9 @@ internal BuildItemGroup(XmlDocument ownerDocument, bool importedFromAnotherProje
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This returns a boolean telling you whether this particular item
         /// group was imported from another project, or whether it was defined
@@ -159,9 +159,9 @@ public bool IsImported
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the condition on the item group.
         /// </summary>
@@ -218,9 +218,9 @@ internal void ClearParentProject()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Number of items in this group.
         /// </summary>
@@ -241,9 +241,9 @@ public int Count
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets the item at the specified index.
         /// </summary>
@@ -293,9 +293,9 @@ internal XmlElement ParentElement
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Copies the items in this group into a new array.
         /// NOTE: the copies are NOT clones i.e. only the references are copied
@@ -317,9 +317,9 @@ public BuildItem[] ToArray()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the BuildItem objects contained in
@@ -560,9 +560,9 @@ internal void AddItem(BuildItem itemToAdd)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Creates a new BuildItem defined by the given "Type" and "Include", and
         /// adds it to the end of this BuildItemGroup.
@@ -599,9 +599,9 @@ public BuildItem AddNewItem(string itemName, string itemInclude)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Adds a new item to the ItemGroup, optional treating the item Include as literal so that
         /// any special characters will be escaped before persisting it.
@@ -669,9 +669,9 @@ public void RemoveItem(BuildItem itemToRemove)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Removes the item at the specified index.
         /// </summary>
@@ -713,9 +713,9 @@ private void RemoveItemElement(BuildItem item)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Clones the BuildItemGroup.  A shallow clone here is one that references
         /// the same BuildItem objects as the original, whereas a deep clone actually
@@ -781,9 +781,9 @@ internal BuildItemGroup ShallowClone()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Removes all Items from this BuildItemGroup, and also deletes the Condition
         /// and Name.
diff --git a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
index f8bb79c6360..696f6b448ab 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroupCollection.cs
@@ -14,9 +14,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a collection of persisted &lt;ItemGroup&gt;'s.  Each
     /// MSBuild project has exactly one BuildItemGroupCollection, which includes
@@ -79,9 +79,9 @@ GroupingCollection groupingCollection
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Read-only property which returns the number of ItemGroups contained
         /// in our collection.
@@ -107,9 +107,9 @@ public int Count
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This ICollection property tells whether this object is thread-safe.
         /// </summary>
@@ -134,9 +134,9 @@ public bool IsSynchronized
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This ICollection property returns the object to be used to synchronize
         /// access to the class.
@@ -200,9 +200,9 @@ internal BuildItemGroup LastLocalItemGroup
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This ICollection method copies the contents of this collection to an
         /// array.
@@ -231,9 +231,9 @@ int index
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the BuildItemGroup objects contained in
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index 242e4c3f095..e484ce02acd 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -17,9 +17,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class hosts a node class in the child process. It uses shared memory to communicate
     /// with the local node provider.
@@ -40,9 +40,9 @@ public class LocalNode
         #region Static Constructors
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Hook up an unhandled exception handler, in case our error handling paths are leaky
         /// </summary>
@@ -245,9 +245,9 @@ private static bool CreateGlobalEvents(int nodeNumber)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This function starts local node when process is launched and shuts it down on time out
         /// Called by msbuild.exe.
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index 60e8dbb99d7..c0e71d36c65 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -36,9 +36,9 @@ namespace Microsoft.Build.BuildEngine
 
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class implements the default logger that outputs event data
     /// to the console (stdout).
@@ -72,10 +72,10 @@ public class ConsoleLogger : INodeLogger
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Default constructor.
         /// </summary>
         /// <remarks>
@@ -96,9 +96,9 @@ public ConsoleLogger()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Create a logger instance with a specific verbosity.  This logs to
         /// the default console.
@@ -129,9 +129,9 @@ public ConsoleLogger(LoggerVerbosity verbosity)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Initializes the logger, with alternate output handlers.
         /// </summary>
@@ -222,10 +222,10 @@ private void InitializeBaseConsoleLogger()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Gets or sets the level of detail to show in the event log.
         /// </summary>
         /// <value>Verbosity level.</value>
@@ -261,10 +261,10 @@ public LoggerVerbosity Verbosity
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// The console logger takes a single parameter to suppress the output of the errors
         /// and warnings summary at the end of a build.
         /// </summary>
@@ -301,9 +301,9 @@ public string Parameters
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Suppresses the display of project headers. Project headers are
         /// displayed by default unless this property is set.
@@ -340,10 +340,10 @@ public bool SkipProjectStartedText
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Suppresses the display of error and warnings summary.
         /// </summary>
         /// <remarks>
@@ -406,10 +406,10 @@ protected WriteHandler WriteHandler
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Apply a parameter.
         /// NOTE: This method was public by accident in Whidbey, so it cannot be made internal now. It has
         /// no good reason for being public.
@@ -432,9 +432,9 @@ public void ApplyParameter(string parameterName, string parameterValue)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Signs up the console logger for all build events.
         /// </summary>
@@ -457,9 +457,9 @@ public virtual void Initialize(IEventSource eventSource)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// </summary>
         /// <remarks>
         /// <format type="text/markdown"><![CDATA[
@@ -480,9 +480,9 @@ public virtual void Initialize(IEventSource eventSource, int nodeCount)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The console logger does not need to release any resources.
         /// This method does nothing.
@@ -504,9 +504,9 @@ public virtual void Shutdown()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Handler for build started events
         /// </summary>
@@ -531,9 +531,9 @@ public void BuildStartedHandler(object sender, BuildStartedEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Handler for build finished events
         /// </summary>
@@ -558,9 +558,9 @@ public void BuildFinishedHandler(object sender, BuildFinishedEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Handler for project started events
         /// </summary>
@@ -585,9 +585,9 @@ public void ProjectStartedHandler(object sender, ProjectStartedEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Handler for project finished events
         /// </summary>
@@ -612,9 +612,9 @@ public void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Handler for target started events
         /// </summary>
@@ -639,9 +639,9 @@ public void TargetStartedHandler(object sender, TargetStartedEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Handler for target finished events
         /// </summary>
@@ -666,9 +666,9 @@ public void TargetFinishedHandler(object sender, TargetFinishedEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Handler for task started events
         /// </summary>
@@ -693,9 +693,9 @@ public void TaskStartedHandler(object sender, TaskStartedEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Handler for task finished events
         /// </summary>
@@ -720,9 +720,9 @@ public void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Prints an error event
         /// </summary>
@@ -745,9 +745,9 @@ public void ErrorHandler(object sender, BuildErrorEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Prints a warning event
         /// </summary>
@@ -770,9 +770,9 @@ public void WarningHandler(object sender, BuildWarningEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Prints a message event
         /// </summary>
@@ -795,10 +795,10 @@ public void MessageHandler(object sender, BuildMessageEventArgs e)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Prints a custom event
         /// </summary>
         /// <remarks>
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 242adbfaafd..4ea5d77dfe2 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -15,9 +15,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// Logger that forwards events to a central logger (e.g ConsoleLogger)
     /// residing on the parent node.
@@ -37,9 +37,9 @@ public class ConfigurableForwardingLogger : IForwardingLogger
         #region Constructors
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Default constructor.
         /// </summary>
@@ -63,9 +63,9 @@ public ConfigurableForwardingLogger()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Gets or sets the level of detail to show in the event log.
         /// </summary>
@@ -88,9 +88,9 @@ public LoggerVerbosity Verbosity
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The console logger takes a single parameter to suppress the output of the errors
         /// and warnings summary at the end of a build.
@@ -114,9 +114,9 @@ public string Parameters
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This property is set by the build engine to allow a node loggers to forward messages to the
         /// central logger
@@ -139,9 +139,9 @@ public IEventRedirector BuildEventRedirector
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// </summary>
         /// <remarks>
         /// <format type="text/markdown"><![CDATA[
@@ -243,9 +243,9 @@ private void ApplyParameter(string parameterName)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Signs up the console logger for all build events.
         /// </summary>
@@ -288,9 +288,9 @@ public virtual void Initialize(IEventSource eventSource)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Signs up the console logger for all build events.
         /// </summary>
@@ -384,10 +384,10 @@ private void ResetLoggerState()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Called when Engine is done with this logger
         /// </summary>
         /// <remarks>
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index 063d7545b85..bebbfb9ceee 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -15,9 +15,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class will create a text file which will contain the build log for that node
     /// </summary>
@@ -36,9 +36,9 @@ public class DistributedFileLogger : IForwardingLogger
         #region Constructors
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Default constructor.
         /// </summary>
@@ -62,9 +62,9 @@ public DistributedFileLogger()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// </summary>
         /// <remarks>
         /// <format type="text/markdown"><![CDATA[
@@ -136,9 +136,9 @@ private void ApplyFileLoggerParameter(string parameterName, string parameterValu
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// </summary>
         /// <remarks>
         /// <format type="text/markdown"><![CDATA[
@@ -188,9 +188,9 @@ public void Initialize(IEventSource eventSource)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// </summary>
         /// <remarks>
         /// <format type="text/markdown"><![CDATA[
@@ -221,9 +221,9 @@ internal FileLogger InternalFilelogger
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// </summary>
         /// <remarks>
         /// <format type="text/markdown"><![CDATA[
@@ -250,9 +250,9 @@ public IEventRedirector BuildEventRedirector
         // Node Id of the node which the forwarding logger is attached to
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// </summary>
         /// <remarks>
         /// <format type="text/markdown"><![CDATA[
@@ -279,9 +279,9 @@ public int NodeId
         // The verbosity for now is set at detailed
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// </summary>
         /// <remarks>
         /// <format type="text/markdown"><![CDATA[
@@ -308,9 +308,9 @@ public LoggerVerbosity Verbosity
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// </summary>
         /// <remarks>
         /// <format type="text/markdown"><![CDATA[
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index 3869711b643..4ec8236fa53 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -16,9 +16,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// A specialization of the ConsoleLogger that logs to a file instead of the console.
     /// The output in terms of what is written and how it looks is identical. For example you can
@@ -45,9 +45,9 @@ public class FileLogger : ConsoleLogger
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Default constructor.
         /// </summary>
@@ -71,10 +71,10 @@ public FileLogger() : base(LoggerVerbosity.Normal)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Signs up the console file logger for all build events.
         /// This is the backward-compatible overload.
         /// </summary>
@@ -152,10 +152,10 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Multiproc aware initialization
         /// </summary>
         /// <remarks>
@@ -200,9 +200,9 @@ private void Write(string text)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Shutdown method implementation of ILogger - we need to flush and close our logfile.
         /// </summary>
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index 40b9536e81f..e0ed4cba6cd 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -16,9 +16,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class is used to contain information about a logger as a collection of values that
     /// can be used to instantiate the logger and can be serialized to be passed between different
@@ -44,9 +44,9 @@ internal LoggerDescription()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Creates a logger description from given data
         /// </summary>
@@ -119,10 +119,10 @@ internal string Name
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Returns the string of logger parameters, null if there are none
         /// </summary>
         /// <remarks>
@@ -145,9 +145,9 @@ public string LoggerSwitchParameters
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Return the verbosity for this logger (from command line all loggers get same verbosity)
         /// </summary>
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index 00223fa2a44..6ac5465d80e 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -57,9 +57,9 @@ internal enum PropertyType
 
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class holds an MSBuild property.  This may be a property that is
     /// represented in the MSBuild project file by an XML element, or it
@@ -348,9 +348,9 @@ PropertyType propertyType
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Constructor, which initializes the property from just the property
         /// name and value, creating it as a "normal" property.  This ends up
@@ -384,9 +384,9 @@ string propertyValue
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the property name.  This is read-only, so one cannot
         /// change the property name once it's set ... your only option is
@@ -429,9 +429,9 @@ public string Name
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the property value.  Normal properties can be modified;
         /// other property types cannot.
@@ -531,9 +531,9 @@ internal string FinalValueEscaped
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Returns the unescaped value of the property.
         /// </summary>
@@ -579,9 +579,9 @@ internal PropertyType Type
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Did this property originate from an imported project file?
         /// </summary>
@@ -606,9 +606,9 @@ public bool IsImported
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the condition on the property.
         /// </summary>
@@ -732,9 +732,9 @@ private void MarkPropertyAsDirty
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Creates a shallow or deep clone of this BuildProperty object.
         ///
@@ -830,9 +830,9 @@ BuildProperty compareToProperty
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Returns the property value.
         /// </summary>
@@ -860,9 +860,9 @@ public override string ToString
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This allows an implicit typecast from a "BuildProperty" to a "string"
         /// when trying to access the property's value.
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index 38ca722ac49..de0cdfc4c5a 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -19,9 +19,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// A BuildPropertyGroup is a collection of BuildProperty objects. This could be represented by a persisted &lt;PropertyGroup&gt;
     /// element in the project file, or it could be a virtual collection of properties, such as in the case of global properties,
@@ -149,9 +149,9 @@ internal void CreateFromStream(BinaryReader reader)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Default constructor, that creates an empty virtual (non-persisted) BuildPropertyGroup.
         /// </summary>
@@ -172,9 +172,9 @@ public BuildPropertyGroup()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Default constructor, that creates an empty virtual (non-persisted) BuildPropertyGroup.
         /// </summary>
@@ -362,9 +362,9 @@ bool importedFromAnotherProject
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This returns a boolean telling you whether this particular property
         /// group was imported from another project, or whether it was defined
@@ -392,9 +392,9 @@ public bool IsImported
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Accessor for the condition on the property group.
         /// </summary>
@@ -435,9 +435,9 @@ public string Condition
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Allows setting the condition for imported property groups. Changes will not be persisted.
         /// </summary>
@@ -547,10 +547,10 @@ internal XmlElement ParentElement
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
         /// 
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// Returns the number of properties contained in this BuildPropertyGroup.
         /// </summary>
         /// <remarks>
@@ -630,9 +630,9 @@ internal string ImportedFromFilename
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This is the indexer for the BuildPropertyGroup class, which allows the caller to set or get the property data using simple
         /// array indexer [] notation. The caller passes in the property name inside the [], and out comes the  BuildProperty object,
@@ -688,9 +688,9 @@ public BuildProperty this[string propertyName]
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the BuildProperty objects contained in
@@ -745,9 +745,9 @@ internal BuildPropertyGroup ShallowClone()
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This method creates a copy of the BuildPropertyGroup. A shallow clone will reference the same BuildProperty objects as the
         /// original. A deep clone will deep clone the BuildProperty objects themselves. If this is a persisted BuildPropertyGroup, only
@@ -1012,9 +1012,9 @@ BuildProperty newProperty
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Sets a property taking the property name and value as strings directly.
         ///
@@ -1045,9 +1045,9 @@ public void SetProperty(string propertyName, string propertyValue)
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Sets a property in this PropertyGroup, optionally escaping the property value so
         /// that it will be treated as a literal.
@@ -1079,9 +1079,9 @@ bool treatPropertyValueAsLiteral
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// The AddNewProperty method adds a new property element to the persisted
         /// &lt;PropertyGroup&gt; at the end.  This method takes the property name and
@@ -1122,9 +1122,9 @@ string propertyValue
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Adds a new property to the PropertyGroup, optionally escaping the property value so
         /// that it will be treated as a literal.
@@ -1236,9 +1236,9 @@ BuildProperty propertyToAdd
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Removes the given BuildProperty object from either a persisted or a virtual
         /// BuildPropertyGroup.
@@ -1295,9 +1295,9 @@ BuildProperty property
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Removes all properties with the given name from either a persisted or a virtual BuildPropertyGroup. For persisted
         /// PropertyGroups, there could be multiple. For a virtual BuildPropertyGroup, there can be only one.
@@ -1486,9 +1486,9 @@ internal void ClearImportedPropertyGroup
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Removes all properties and conditions from this BuildPropertyGroup.
         /// </summary>
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
index 4404ad64c28..8a02719ea94 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroupCollection.cs
@@ -12,9 +12,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class represents a collection of persisted &lt;PropertyGroup&gt;'s.  Each
     /// MSBuild project has exactly one BuildPropertyGroupCollection, which includes
@@ -75,9 +75,9 @@ GroupingCollection groupingCollection
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Read-only property which returns the number of PropertyGroups contained
         /// in our collection.
@@ -103,9 +103,9 @@ public int Count
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This ICollection property tells whether this object is thread-safe.
         /// </summary>
@@ -130,9 +130,9 @@ public bool IsSynchronized
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This ICollection property returns the object to be used to synchronize
         /// access to the class.
@@ -195,9 +195,9 @@ internal BuildPropertyGroup LastLocalPropertyGroup
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This ICollection method copies the contents of this collection to an
         /// array.
@@ -224,9 +224,9 @@ int index
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// This IEnumerable method returns an IEnumerator object, which allows
         /// the caller to enumerate through the BuildPropertyGroup objects contained in
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index 2f0e9475f4c..33542698739 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -20,9 +20,9 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-    /// <xref:Microsoft.Build.Construction>
-    /// <xref:Microsoft.Build.Evaluation>
-    /// <xref:Microsoft.Build.Execution>
+    /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+    /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+    /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
     /// 
     /// This class is used to generate an MSBuild wrapper project for a solution file or standalone VC project.
     /// </summary>
@@ -47,9 +47,9 @@ public static class SolutionWrapperProject
 
         /// <summary>
         /// This method (and the whole namespace) is deprecated. Please use the classes in these namespaces instead: 
-        /// <xref:Microsoft.Build.Construction>
-        /// <xref:Microsoft.Build.Evaluation>
-        /// <xref:Microsoft.Build.Execution>
+        /// <see href="/dotnet/api/microsoft.build.construction">Microsoft.Build.Construction</see>
+        /// <see href="/dotnet/api/microsoft.build.evaluation">Microsoft.Build.Evaluation</see>
+        /// <see href="/dotnet/api/microsoft.build.execution">Microsoft.Build.Execution</see>
         /// 
         /// Given the full path to a solution, returns a string containing the v3.5 MSBuild-format
         /// wrapper project for that solution.
diff --git a/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs b/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
new file mode 100644
index 00000000000..1db4853b515
--- /dev/null
+++ b/src/Framework.UnitTests/BuildSubmissionStartedEventAgs_Tests.cs
@@ -0,0 +1,66 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class BuildSubmissionStartedEventAgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            var globalVariables = new Dictionary<string, string?>
+            {
+                {"Variable1", "Value1" },
+                {"Variable2", "" },
+                {"Variable3", null },
+            };
+
+            var entryPointProjects = new List<string>()
+            {
+                "project1",
+                "project2",
+                "",
+            };
+            var targetNames = new List<string>()
+            {
+                "target1",
+                "target2",
+                "",
+            };
+            var flag = Execution.BuildRequestDataFlags.FailOnUnresolvedSdk;
+            var submissionId = 1234;
+
+            BuildSubmissionStartedEventArgs args = new(
+                globalVariables,
+                entryPointProjects,
+                targetNames,
+                flag,
+                submissionId);
+
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            args.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            BuildSubmissionStartedEventArgs argDeserialized = new();
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+
+            argDeserialized.CreateFromStream(br, packetVersion);
+            argDeserialized.GlobalProperties.ShouldBe(globalVariables);
+            argDeserialized.EntryProjectsFullPath.ShouldBe(entryPointProjects);
+            argDeserialized.TargetNames.ShouldBe(targetNames);
+            argDeserialized.Flags.ShouldBe(flag);
+            argDeserialized.SubmissionId.ShouldBe(submissionId);
+        }
+    }
+} 
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index d3ae3878226..a2a72ede9eb 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -22,6 +22,14 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal static class BinaryTranslator
     {
+        /// <summary>
+        /// Presence of this key in the dictionary indicates that it was null.
+        /// </summary>
+        /// <remarks>
+        /// This constant is needed for a workaround concerning serializing BuildResult with a version.
+        /// </remarks>
+        private const string SpecialKeyForDictionaryBeingNull = "=MSBUILDDICTIONARYWASNULL=";
+
 #nullable enable
         /// <summary>
         /// Returns a read-only serializer.
@@ -590,6 +598,53 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua
                 dictionary = (Dictionary<string, string>)copy;
             }
 
+            /// <summary>
+            /// Translates a dictionary of { string, string } with additional entries. The dictionary might be null despite being populated.
+            /// </summary>
+            /// <param name="dictionary">The dictionary to be translated.</param>
+            /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
+            /// <param name="additionalEntries">Additional entries to be translated</param>
+            /// <param name="additionalEntriesKeys">Additional entries keys</param>
+            /// <remarks>
+            /// This overload is needed for a workaround concerning serializing BuildResult with a version.
+            /// It deserializes additional entries together with the main dictionary.
+            /// </remarks>
+            public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys)
+            {
+                if (!TranslateNullable(dictionary))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                dictionary = new Dictionary<string, string>(count, comparer);
+                additionalEntries = new();
+
+                for (int i = 0; i < count; i++)
+                {
+                    string key = null;
+                    Translate(ref key);
+                    string value = null;
+                    Translate(ref value);
+                    if (additionalEntriesKeys.Contains(key))
+                    {
+                        additionalEntries[key] = value;
+                    }
+                    else if (comparer.Equals(key, SpecialKeyForDictionaryBeingNull))
+                    {
+                        // Presence of special key SpecialKeyForDictionaryBeingNull indicates that the dictionary was null.
+                        dictionary = null;
+
+                        // If the dictionary is null, we should have only two keys: SpecialKeyForDictionaryBeingNull, SpecialKeyForVersion
+                        Debug.Assert(count == 2);
+                    }
+                    else if (dictionary is not null)
+                    {
+                        dictionary[key] = value;
+                    }
+                }
+            }
+
             public void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> dictionaryCreator)
             {
                 if (!TranslateNullable(dictionary))
@@ -1261,6 +1316,72 @@ public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqua
                 TranslateDictionary(ref copy, (NodePacketCollectionCreator<IDictionary<string, string>>)null);
             }
 
+            /// <summary>
+            /// Translates a dictionary of { string, string } adding additional entries.
+            /// </summary>
+            /// <param name="dictionary">The dictionary to be translated.</param>
+            /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
+            /// <param name="additionalEntries">Additional entries to be translated.</param>
+            /// <param name="additionalEntriesKeys">Additional entries keys.</param>
+            /// <remarks>
+            /// This overload is needed for a workaround concerning serializing BuildResult with a version.
+            /// It serializes additional entries together with the main dictionary.
+            /// </remarks>
+            public void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys)
+            {
+                // Translate whether object is null
+                if ((dictionary is null) && ((additionalEntries is null) || (additionalEntries.Count == 0)))
+                {
+                    _writer.Write(false);
+                    return;
+                }
+                else
+                {
+                    // Translate that object is not null
+                    _writer.Write(true);
+                }
+
+                // Writing a dictionary, additional entries and special key if dictionary was null. We need the special key for distinguishing whether the initial dictionary was null or empty.
+                int count = (dictionary is null ? 1 : 0) +
+                            (additionalEntries is null ? 0 : additionalEntries.Count) +
+                            (dictionary is null ? 0 : dictionary.Count);
+
+                _writer.Write(count);
+
+                // If the dictionary was null, serialize a special key SpecialKeyForDictionaryBeingNull.
+                if (dictionary is null)
+                {
+                    string key = SpecialKeyForDictionaryBeingNull;
+                    Translate(ref key);
+                    string value = string.Empty;
+                    Translate(ref value);
+                }
+
+                // Serialize additional entries
+                if (additionalEntries is not null)
+                {
+                    foreach (KeyValuePair<string, string> pair in additionalEntries)
+                    {
+                        string key = pair.Key;
+                        Translate(ref key);
+                        string value = pair.Value;
+                        Translate(ref value);
+                    }
+                }
+
+                // Serialize dictionary
+                if (dictionary is not null)
+                {
+                    foreach (KeyValuePair<string, string> pair in dictionary)
+                    {
+                        string key = pair.Key;
+                        Translate(ref key);
+                        string value = pair.Value;
+                        Translate(ref value);
+                    }
+                }
+            }
+
             public void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> dictionaryCreator)
             {
                 if (!TranslateNullable(dictionary))
diff --git a/src/Framework/BuildCanceledEventArgs.cs b/src/Framework/BuildCanceledEventArgs.cs
new file mode 100644
index 00000000000..9f9e4ac5cf9
--- /dev/null
+++ b/src/Framework/BuildCanceledEventArgs.cs
@@ -0,0 +1,54 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This class represents the event arguments for build canceled events.
+    /// </summary>
+    public sealed class BuildCanceledEventArgs : BuildStatusEventArgs
+    {
+        /// <summary>
+        /// Constructor to initialize all parameters.
+        /// Sender field cannot be set here and is assumed to be "MSBuild".
+        /// </summary>
+        /// <param name="message">text message</param>
+        public BuildCanceledEventArgs(string message)
+            : this(message, DateTime.UtcNow)
+        { 
+        }
+
+        /// <summary>
+        /// Constructor which allows the timestamp to be set.
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="eventTimestamp">Timestamp when the event was created</param>
+        public BuildCanceledEventArgs(
+            string message,
+            DateTime eventTimestamp)
+            : this(message, eventTimestamp, null)
+        {
+        }
+
+        /// <summary>
+        /// Constructor which allows the timestamp to be set.
+        /// </summary>
+        /// <param name="message">text message</param>
+        /// <param name="eventTimestamp">Timestamp when the event was created</param>
+        /// <param name="messageArgs">message arguments</param>
+        public BuildCanceledEventArgs(
+            string message,
+            DateTime eventTimestamp,
+            params object[]? messageArgs)
+            : base(message, null, "MSBuild", eventTimestamp, messageArgs)
+        {
+            if (string.IsNullOrWhiteSpace(message))
+            {
+                throw new InternalErrorException("Message cannot be null or consist only white-space characters.");
+            }
+        }
+    }
+}
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index 7789ba37d18..4b4e95960c6 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -71,15 +71,15 @@ internal override void CreateFromStream(BinaryReader reader, int version)
     }
 }
 
-internal sealed class BuildCheckAcquisitionEventArgs(string acquisitionPath) : BuildCheckEventArgs
+internal sealed class BuildCheckAcquisitionEventArgs(string acquisitionPath, string projectPath) : BuildCheckEventArgs
 {
     internal BuildCheckAcquisitionEventArgs()
-        : this(string.Empty)
+        : this(string.Empty, string.Empty)
     {
     }
 
     /// <summary>
-    /// Gets the path to the analyzer assembly that needs to be loaded into the application context.
+    /// Gets the path to the check assembly that needs to be loaded into the application context.
     /// </summary>
     /// <remarks>
     /// The <see cref="AcquisitionPath"/> property contains the file system path to the assembly
@@ -91,11 +91,14 @@ internal BuildCheckAcquisitionEventArgs()
     /// </value>
     public string AcquisitionPath { get; private set; } = acquisitionPath;
 
+    public string ProjectPath { get; private set; } = projectPath;
+
     internal override void WriteToStream(BinaryWriter writer)
     {
         base.WriteToStream(writer);
 
         writer.Write(AcquisitionPath);
+        writer.Write(ProjectPath);
     }
 
     internal override void CreateFromStream(BinaryReader reader, int version)
@@ -103,13 +106,16 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         base.CreateFromStream(reader, version);
 
         AcquisitionPath = reader.ReadString();
+        ProjectPath = reader.ReadString();
     }
 }
+
 internal sealed class BuildCheckResultWarning : BuildWarningEventArgs
 {
-    public BuildCheckResultWarning(IBuildCheckResult result)
+    public BuildCheckResultWarning(IBuildCheckResult result, string code)
+        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: result.FormatMessage(), helpKeyword: null, senderName: null)
     {
-        this.Message = result.FormatMessage();
+        RawMessage = result.FormatMessage();
     }
 
     internal BuildCheckResultWarning() { }
@@ -118,24 +124,23 @@ internal override void WriteToStream(BinaryWriter writer)
     {
         base.WriteToStream(writer);
 
-        writer.Write(Message!);
+        writer.Write(RawMessage!);
     }
 
     internal override void CreateFromStream(BinaryReader reader, int version)
     {
         base.CreateFromStream(reader, version);
 
-        Message = reader.ReadString();
+        RawMessage = reader.ReadString();
     }
-
-    public override string? Message { get; protected set; }
 }
 
 internal sealed class BuildCheckResultError : BuildErrorEventArgs
 {
-    public BuildCheckResultError(IBuildCheckResult result)
+    public BuildCheckResultError(IBuildCheckResult result, string code)
+        : base(subcategory: null, code: code, file: null, lineNumber: 0, columnNumber: 0, endLineNumber: 0, endColumnNumber: 0, message: result.FormatMessage(), helpKeyword: null, senderName: null)
     {
-        this.Message = result.FormatMessage();
+        RawMessage = result.FormatMessage();
     }
 
     internal BuildCheckResultError() { }
@@ -144,24 +149,22 @@ internal override void WriteToStream(BinaryWriter writer)
     {
         base.WriteToStream(writer);
 
-        writer.Write(Message!);
+        writer.Write(RawMessage!);
     }
 
     internal override void CreateFromStream(BinaryReader reader, int version)
     {
         base.CreateFromStream(reader, version);
 
-        Message = reader.ReadString();
+        RawMessage = reader.ReadString();
     }
-
-    public override string? Message { get; protected set; }
 }
 
 internal sealed class BuildCheckResultMessage : BuildMessageEventArgs
 {
     public BuildCheckResultMessage(IBuildCheckResult result)
     {
-        this.Message = result.FormatMessage();
+        RawMessage = result.FormatMessage();
     }
 
     internal BuildCheckResultMessage() { }
@@ -170,15 +173,13 @@ internal override void WriteToStream(BinaryWriter writer)
     {
         base.WriteToStream(writer);
 
-        writer.Write(Message!);
+        writer.Write(RawMessage!);
     }
 
     internal override void CreateFromStream(BinaryReader reader, int version)
     {
         base.CreateFromStream(reader, version);
 
-        Message = reader.ReadString();
+        RawMessage = reader.ReadString();
     }
-
-    public override string? Message { get; protected set; }
 }
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index ca01f781d2f..37d6ff1c3d1 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -215,6 +215,20 @@ public BuildMessageEventArgs(
             this.endColumnNumber = endColumnNumber;
         }
 
+        protected BuildMessageEventArgs(
+           string message,
+           string file,
+           int lineNumber,
+           int columnNumber,
+           MessageImportance importance)
+            : base(message, helpKeyword: null, senderName: null)
+        {
+            this.importance = importance;
+            this.file = file;
+            this.lineNumber = lineNumber;
+            this.columnNumber = columnNumber;
+        }
+
         private MessageImportance importance;
 
         [OptionalField(VersionAdded = 2)]
@@ -311,7 +325,11 @@ public MessageImportance Importance
         /// <summary>
         /// File associated with event.
         /// </summary>
-        public string File => file;
+        public string File
+        {
+            get => file;
+            internal set => file = value;
+        }
 
         /// <summary>
         /// Line number of interest in associated file.
diff --git a/src/Framework/BuildRequestDataFlags.cs b/src/Framework/BuildRequestDataFlags.cs
new file mode 100644
index 00000000000..8a0c1f585f2
--- /dev/null
+++ b/src/Framework/BuildRequestDataFlags.cs
@@ -0,0 +1,87 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+// Note: Namespace is within Build.Execution for type forwarding to work correctly
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Flags providing additional control over the build request
+    /// </summary>
+    [Flags]
+    public enum BuildRequestDataFlags
+    {
+        /// <summary>
+        /// No flags.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// When this flag is present, the existing ProjectInstance in the build will be replaced by this one.
+        /// </summary>
+        ReplaceExistingProjectInstance = 1 << 0,
+
+        /// <summary>
+        /// When this flag is present, the "BuildResult" issued in response to this request will
+        /// include "BuildResult.ProjectStateAfterBuild".
+        /// </summary>
+        ProvideProjectStateAfterBuild = 1 << 1,
+
+        /// <summary>
+        /// When this flag is present and the project has previously been built on a node whose affinity is
+        /// incompatible with the affinity this request requires, we will ignore the project state (but not
+        /// target results) that were previously generated.
+        /// </summary>
+        /// <remarks>
+        /// This usually is not desired behavior.  It is only provided for those cases where the client
+        /// knows that the new build request does not depend on project state generated by a previous request.  Setting
+        /// this flag can provide a performance boost in the case of incompatible node affinities, as MSBuild would
+        /// otherwise have to serialize the project state from one node to another, which may be
+        /// expensive depending on how much data the project previously generated.
+        ///
+        /// This flag has no effect on target results, so if a previous request already built a target, the new
+        /// request will not re-build that target (nor will any of the project state mutations which previously
+        /// occurred as a consequence of building that target be re-applied.)
+        /// </remarks>
+        IgnoreExistingProjectState = 1 << 2,
+
+        /// <summary>
+        /// When this flag is present, caches including the "ProjectRootElementCacheBase" will be cleared
+        /// after the build request completes.  This is used when the build request is known to modify a lot of
+        /// state such as restoring packages or generating parts of the import graph.
+        /// </summary>
+        ClearCachesAfterBuild = 1 << 3,
+
+        /// <summary>
+        /// When this flag is present, the top level target(s) in the build request will be skipped if those targets
+        /// are not defined in the Project to build. This only applies to this build request (if another target calls
+        /// the "missing target" at any other point this will still result in an error).
+        /// </summary>
+        SkipNonexistentTargets = 1 << 4,
+
+        /// <summary>
+        /// When this flag is present, the "BuildResult" issued in response to this request will
+        /// include a "BuildResult.ProjectStateAfterBuild" that includes ONLY the
+        /// explicitly-requested properties, items, and metadata.
+        /// </summary>
+        ProvideSubsetOfStateAfterBuild = 1 << 5,
+
+        /// <summary>
+        /// When this flag is present, projects loaded during build will ignore missing imports ("ProjectLoadSettings.IgnoreMissingImports" and "ProjectLoadSettings.IgnoreInvalidImports").
+        /// This is especially useful during a restore since some imports might come from packages that haven't been restored yet.
+        /// </summary>
+        IgnoreMissingEmptyAndInvalidImports = 1 << 6,
+
+        /// <summary>
+        /// When this flag is present, an unresolved MSBuild project SDK will fail the build.  This flag is used to
+        /// change the "IgnoreMissingEmptyAndInvalidImports" behavior to still fail when an SDK is missing
+        /// because those are more fatal.
+        /// </summary>
+        FailOnUnresolvedSdk = 1 << 7,
+    }
+}
diff --git a/src/Framework/BuildSubmissionStartedEventArgs.cs b/src/Framework/BuildSubmissionStartedEventArgs.cs
new file mode 100644
index 00000000000..f77fdf8cfd0
--- /dev/null
+++ b/src/Framework/BuildSubmissionStartedEventArgs.cs
@@ -0,0 +1,121 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Framework
+{
+    public sealed class BuildSubmissionStartedEventArgs : BuildStatusEventArgs
+    {
+        /// <summary>
+        /// Constructor with default values.
+        /// </summary>
+        public BuildSubmissionStartedEventArgs()
+        {
+            GlobalProperties = new Dictionary<string, string?>();
+            EntryProjectsFullPath = Enumerable.Empty<string>();
+            TargetNames = Enumerable.Empty<string>();
+            Flags = BuildRequestDataFlags.None;
+            SubmissionId = 0;
+        }
+
+        public BuildSubmissionStartedEventArgs(
+            IReadOnlyDictionary<string, string?> globalProperties,
+            IEnumerable<string> entryProjectsFullPath,
+            IEnumerable<string> targetNames,
+            BuildRequestDataFlags flags,
+            int submissionId)
+            : base("", null, null, DateTime.UtcNow)
+        {
+            GlobalProperties = globalProperties;
+            EntryProjectsFullPath = entryProjectsFullPath;
+            TargetNames = targetNames;
+            Flags = flags;
+            SubmissionId = submissionId;
+        }
+
+        public IReadOnlyDictionary<string, string?> GlobalProperties { get; set; }
+
+        public IEnumerable<string> EntryProjectsFullPath { get; set; }
+
+        public IEnumerable<string> TargetNames { get; set; }
+
+        public BuildRequestDataFlags Flags { get; set; }
+
+        public int SubmissionId { get; set; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            writer.Write(GlobalProperties.Count);
+            foreach (var entry in GlobalProperties)
+            {
+                writer.Write((string)entry.Key);
+                writer.WriteOptionalString(entry.Value);
+            }
+
+            writer.Write(EntryProjectsFullPath.Count());
+            foreach(var entry in EntryProjectsFullPath)
+            {
+                writer.Write((string)entry);
+            }
+
+            writer.Write(TargetNames.Count());
+            foreach (var entry in TargetNames)
+            {
+                writer.Write((string)entry);
+            }
+
+            writer.Write((int)Flags);
+            writer.Write((int)SubmissionId);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            int numberOfProperties = reader.ReadInt32();
+            Dictionary<string, string?> globalProperties = new Dictionary<string, string?>(numberOfProperties);
+            for (int i = 0; i < numberOfProperties; i++)
+            {
+                string key = reader.ReadString();
+                string? value = reader.ReadOptionalString();
+
+                if (key != null)
+                {
+                    globalProperties[key] = value;
+                }
+            }
+
+            GlobalProperties = globalProperties;
+
+            int numberOfEntries = reader.ReadInt32();
+            var entries = new string[numberOfEntries];
+            for (int i = 0; i < numberOfEntries; i++)
+            {
+                entries[i] = reader.ReadString();
+            }
+
+            EntryProjectsFullPath = entries;
+
+            int numberOfTargets = reader.ReadInt32();
+            var targets = new string[numberOfTargets];
+            for (int i = 0; i < numberOfTargets; i++)
+            {
+                targets[i] = reader.ReadString();
+            }
+
+            TargetNames = targets;
+
+            Flags = (BuildRequestDataFlags)reader.ReadInt32();
+            SubmissionId = reader.ReadInt32();
+        }
+    }
+}
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 51717c375ae..1d682c4fc75 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -25,12 +25,9 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves-Dev.md
     internal static class ChangeWaves
     {
-        internal static readonly Version Wave17_4 = new Version(17, 4);
-        internal static readonly Version Wave17_6 = new Version(17, 6);
-        internal static readonly Version Wave17_8 = new Version(17, 8);
         internal static readonly Version Wave17_10 = new Version(17, 10);
         internal static readonly Version Wave17_12 = new Version(17, 12);
-        internal static readonly Version[] AllWaves = { Wave17_4, Wave17_6, Wave17_8, Wave17_10, Wave17_12 };
+        internal static readonly Version[] AllWaves = { Wave17_10, Wave17_12 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/CompatibilitySuppressions.xml b/src/Framework/CompatibilitySuppressions.xml
index 2545a39b99a..0555875eb66 100644
--- a/src/Framework/CompatibilitySuppressions.xml
+++ b/src/Framework/CompatibilitySuppressions.xml
@@ -1,11 +1,6 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
-       This is intentional, because you can only use MSBuild in the context of a .NET SDK
-       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
-       have previously shipped netstandard2.0 packages, and if you want to support both
-       runtime contexts it still makes sense to target that. -->
   <Suppression>
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>.NETCoreApp,Version=v2.0</Target>
@@ -54,4 +49,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-</Suppressions>
+</Suppressions>
\ No newline at end of file
diff --git a/src/Framework/EncodingUtilities.cs b/src/Framework/EncodingUtilities.cs
index 93e0dd940fe..4ee4679dd3f 100644
--- a/src/Framework/EncodingUtilities.cs
+++ b/src/Framework/EncodingUtilities.cs
@@ -264,11 +264,6 @@ internal static Encoding BatchFileEncoding(string contents, string encodingSpeci
         /// </returns>
         public static CultureInfo? GetExternalOverriddenUILanguageIfSupportableWithEncoding()
         {
-            if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-            {
-                return null;
-            }
-
             CultureInfo? externalLanguageSetting = GetExternalOverriddenUILanguage();
             if (externalLanguageSetting != null)
             {
diff --git a/src/Framework/EnvironmentVariableReadEventArgs.cs b/src/Framework/EnvironmentVariableReadEventArgs.cs
index 3d246fb6c03..ef5bb651404 100644
--- a/src/Framework/EnvironmentVariableReadEventArgs.cs
+++ b/src/Framework/EnvironmentVariableReadEventArgs.cs
@@ -2,6 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Diagnostics;
+using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -10,7 +13,6 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for the environment variable read event.
     /// </summary>
-    [Serializable]
     public class EnvironmentVariableReadEventArgs : BuildMessageEventArgs
     {
         /// <summary>
@@ -33,14 +35,49 @@ public EnvironmentVariableReadEventArgs(
             string message,
             string helpKeyword = null,
             string senderName = null,
-            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
-        {
-            this.EnvironmentVariableName = environmentVariableName;
-        }
+            MessageImportance importance = MessageImportance.Low)
+            : base(message, helpKeyword, senderName, importance) => EnvironmentVariableName = environmentVariableName;
+
+        /// <summary>
+        /// Initializes an instance of the EnvironmentVariableReadEventArgs class.
+        /// </summary>
+        /// <param name="environmentVarName">The name of the environment variable that was read.</param>
+        /// <param name="environmentVarValue">The value of the environment variable that was read.</param>
+        /// <param name="file">file associated with the event</param>
+        /// <param name="line">line number (0 if not applicable)</param>
+        /// <param name="column">column number (0 if not applicable)</param>
+        public EnvironmentVariableReadEventArgs(
+            string environmentVarName,
+            string environmentVarValue,
+            string file,
+            int line,
+            int column)
+            : base(environmentVarValue, file, line, column, MessageImportance.Low) => EnvironmentVariableName = environmentVarName;
 
         /// <summary>
         /// The name of the environment variable that was read.
         /// </summary>
         public string EnvironmentVariableName { get; set; }
+
+        // <summary>
+        // The file name where environment variable is used.
+        // </summary>
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+            writer.Write(EnvironmentVariableName);
+            writer.Write7BitEncodedInt(LineNumber);
+            writer.Write7BitEncodedInt(ColumnNumber);
+            writer.WriteOptionalString(File);
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+            EnvironmentVariableName = reader.ReadString();
+            LineNumber = reader.Read7BitEncodedInt();
+            ColumnNumber = reader.Read7BitEncodedInt();
+            File = reader.ReadOptionalString() ?? string.Empty;
+        }
     }
 }
diff --git a/src/Framework/ErrorUtilities.cs b/src/Framework/ErrorUtilities.cs
index 2cfa8db5559..670ab89f4fc 100644
--- a/src/Framework/ErrorUtilities.cs
+++ b/src/Framework/ErrorUtilities.cs
@@ -2,8 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-
-#nullable disable
+using System.Diagnostics.CodeAnalysis;
 
 namespace Microsoft.Build.Framework
 {
@@ -22,11 +21,11 @@ internal class FrameworkErrorUtilities
         /// </summary>
         /// <param name="condition"></param>
         /// <param name="unformattedMessage"></param>
-        internal static void VerifyThrow(bool condition, string unformattedMessage)
+        internal static void VerifyThrow([DoesNotReturnIf(false)] bool condition, string unformattedMessage)
         {
             if (!condition)
             {
-                ThrowInternalError(unformattedMessage, null, null);
+                ThrowInternalError(unformattedMessage, innerException: null, args: null);
             }
         }
 
@@ -37,9 +36,9 @@ internal static void VerifyThrow(bool condition, string unformattedMessage)
         /// </summary>
         /// <param name="parameter">The value of the argument.</param>
         /// <param name="parameterName">Parameter that should not be null.</param>
-        internal static void VerifyThrowInternalNull(object parameter, string parameterName)
+        internal static void VerifyThrowInternalNull([NotNull] object? parameter, string parameterName)
         {
-            if (parameter == null)
+            if (parameter is null)
             {
                 ThrowInternalError("{0} unexpectedly null", innerException: null, args: parameterName);
             }
@@ -49,9 +48,14 @@ internal static void VerifyThrowInternalNull(object parameter, string parameterN
         /// Throws InternalErrorException.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
-        internal static void ThrowInternalError(string message, Exception innerException, params object[] args)
+        [DoesNotReturn]
+        internal static void ThrowInternalError(string message, Exception? innerException, params object?[]? args)
         {
-            throw new InternalErrorException(string.Format(message, args), innerException);
+            throw new InternalErrorException(
+                args is null ?
+                    message :
+                    string.Format(message, args),
+                innerException);
         }
     }
 }
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index 966f51bd5c4..7884bde35af 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -193,17 +193,98 @@ public void RegisterImmutableDirectory(string? directory)
             }
         }
 
-        private static string EnsureTrailingSlash(string fileSpec)
+        public void RegisterFrameworkLocations(Func<string, string?> getPropertyValue)
+        {
+            // Register toolset paths into list of immutable directories
+            // example: C:\Windows\Microsoft.NET\Framework
+            string? frameworksPathPrefix32 = GetExistingRootOrNull(getPropertyValue("MSBuildFrameworkToolsPath32")?.Trim());
+            RegisterImmutableDirectory(frameworksPathPrefix32);
+            // example: C:\Windows\Microsoft.NET\Framework64
+            string? frameworksPathPrefix64 = GetExistingRootOrNull(getPropertyValue("MSBuildFrameworkToolsPath64")?.Trim());
+            RegisterImmutableDirectory(frameworksPathPrefix64);
+            // example: C:\Windows\Microsoft.NET\FrameworkArm64
+            string? frameworksPathPrefixArm64 = GetExistingRootOrNull(getPropertyValue("MSBuildFrameworkToolsPathArm64")?.Trim());
+            RegisterImmutableDirectory(frameworksPathPrefixArm64);
+        }
+
+        public void RegisterKnownImmutableLocations(Func<string, string?> getPropertyValue)
+        {
+            // example: C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.7.2
+            RegisterImmutableDirectory(getPropertyValue("FrameworkPathOverride")?.Trim());
+            // example: C:\Program Files\dotnet\
+            RegisterImmutableDirectory(getPropertyValue("NetCoreRoot")?.Trim());
+            // example: C:\Users\<username>\.nuget\packages\
+            RegisterImmutableDirectory(getPropertyValue("NuGetPackageFolders")?.Trim());
+        }
+
+        private static string? GetExistingRootOrNull(string? path)
         {
-            if (fileSpec.Length >= 1)
+            if (!string.IsNullOrEmpty(path))
             {
-                char lastChar = fileSpec[fileSpec.Length - 1];
-                if (lastChar != Path.DirectorySeparatorChar && lastChar != Path.AltDirectorySeparatorChar)
+                try
+                {
+                    path = Directory.GetParent(EnsureNoTrailingSlash(path!))?.FullName;
+
+                    if (!Directory.Exists(path))
+                    {
+                        path = null;
+                    }
+                }
+                catch
                 {
-                    fileSpec += Path.DirectorySeparatorChar;
+                    path = null;
                 }
             }
 
+            return path;
+        }
+
+        /// <summary>
+        /// Ensures the path does not have a trailing slash.
+        /// </summary>
+        private static string EnsureNoTrailingSlash(string path)
+        {
+            path = FixFilePath(path);
+            if (EndsWithSlash(path))
+            {
+                path = path.Substring(0, path.Length - 1);
+            }
+
+            return path;
+        }
+
+        private static string FixFilePath(string path)
+        {
+            return string.IsNullOrEmpty(path) || Path.DirectorySeparatorChar == '\\' ? path : path.Replace('\\', '/'); // .Replace("//", "/");
+        }
+
+        /// <summary>
+        /// Indicates if the given file-spec ends with a slash.
+        /// </summary>
+        /// <param name="fileSpec">The file spec.</param>
+        /// <returns>true, if file-spec has trailing slash</returns>
+        private static bool EndsWithSlash(string fileSpec)
+        {
+            return (fileSpec.Length > 0) && IsSlash(fileSpec[fileSpec.Length - 1]);
+        }
+
+        /// <summary>
+        /// Indicates if the given character is a slash.
+        /// </summary>
+        /// <param name="c"></param>
+        /// <returns>true, if slash</returns>
+        private static bool IsSlash(char c)
+        {
+            return (c == Path.DirectorySeparatorChar) || (c == Path.AltDirectorySeparatorChar);
+        }
+
+        private static string EnsureTrailingSlash(string fileSpec)
+        {
+            if (fileSpec.Length >= 1 && !EndsWithSlash(fileSpec))
+            {
+                fileSpec += Path.DirectorySeparatorChar;
+            }
+
             return fileSpec;
         }
 
diff --git a/src/Framework/IEventSource.cs b/src/Framework/IEventSource.cs
index 8e5402b6fd3..2439db58eea 100644
--- a/src/Framework/IEventSource.cs
+++ b/src/Framework/IEventSource.cs
@@ -37,6 +37,11 @@ namespace Microsoft.Build.Framework
     /// </summary>
     public delegate void BuildFinishedEventHandler(object sender, BuildFinishedEventArgs e);
 
+    /// <summary>
+    /// Type of handler for BuildCanceledEvent events
+    /// </summary>
+    public delegate void BuildCanceledEventHandler(object sender, BuildCanceledEventArgs e);
+
     /// <summary>
     /// Type of handler for ProjectStarted events
     /// </summary>
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index edb6e96dfc7..edf5b47765e 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -319,6 +319,19 @@ void TranslateArray<T>(ref T[] array)
         /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
         void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer);
 
+        /// <summary>
+        /// Translates a dictionary of { string, string } adding additional entries.
+        /// </summary>
+        /// <param name="dictionary">The dictionary to be translated.</param>
+        /// <param name="comparer">The comparer used to instantiate the dictionary.</param>
+        /// <param name="additionalEntries">Additional entries to be translated</param>
+        /// <param name="additionalEntriesKeys">Additional entries keys</param>
+        /// <remarks>
+        /// This overload is needed for a workaround concerning serializing BuildResult with a version.
+        /// It serializes/deserializes additional entries together with the main dictionary.
+        /// </remarks>
+        void TranslateDictionary(ref Dictionary<string, string> dictionary, IEqualityComparer<string> comparer, ref Dictionary<string, string> additionalEntries, HashSet<string> additionalEntriesKeys);
+
         void TranslateDictionary(ref IDictionary<string, string> dictionary, NodePacketCollectionCreator<IDictionary<string, string>> collectionCreator);
 
         void TranslateDictionary(ref Dictionary<string, DateTime> dictionary, StringComparer comparer);
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 3cd7934c726..63888fd973b 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -594,25 +594,70 @@ private static void SetMaxPath()
         }
     }
 
-    internal static bool IsMaxPathLegacyWindows()
+    internal enum LongPathsStatus
+    {
+        /// <summary>
+        ///  The registry key is set to 0 or does not exist.
+        /// </summary>
+        Disabled,
+
+        /// <summary>
+        /// The registry key does not exist.
+        /// </summary>
+        Missing,
+
+        /// <summary>
+        /// The registry key is set to 1.
+        /// </summary>
+        Enabled,
+
+        /// <summary>
+        /// Not on Windows.
+        /// </summary>
+        NotApplicable,
+    }
+
+    internal static LongPathsStatus IsLongPathsEnabled()
     {
+        if (!IsWindows)
+        {
+            return LongPathsStatus.NotApplicable;
+        }
+
         try
         {
-            return IsWindows && !IsLongPathsEnabledRegistry();
+            return IsLongPathsEnabledRegistry();
         }
         catch
         {
-            return true;
+            return LongPathsStatus.Disabled;
         }
     }
 
+    internal static bool IsMaxPathLegacyWindows()
+    {
+        var longPathsStatus = IsLongPathsEnabled();
+        return longPathsStatus == LongPathsStatus.Disabled || longPathsStatus == LongPathsStatus.Missing;
+    }
+
     [SupportedOSPlatform("windows")]
-    private static bool IsLongPathsEnabledRegistry()
+    private static LongPathsStatus IsLongPathsEnabledRegistry()
     {
         using (RegistryKey fileSystemKey = Registry.LocalMachine.OpenSubKey(WINDOWS_FILE_SYSTEM_REGISTRY_KEY))
         {
-            object longPathsEnabledValue = fileSystemKey?.GetValue(WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME, 0);
-            return fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == 1;
+            object longPathsEnabledValue = fileSystemKey?.GetValue(WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME, -1);
+            if (fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == -1)
+            {
+                return LongPathsStatus.Missing;
+            }
+            else if (fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == 1)
+            {
+                return LongPathsStatus.Enabled;
+            }
+            else
+            { 
+                return LongPathsStatus.Disabled;
+            }
         }
     }
 
diff --git a/src/Framework/TargetBuiltReason.cs b/src/Framework/TargetBuiltReason.cs
index b00d1eff6c7..d83710653c2 100644
--- a/src/Framework/TargetBuiltReason.cs
+++ b/src/Framework/TargetBuiltReason.cs
@@ -28,6 +28,21 @@ public enum TargetBuiltReason
         /// <summary>
         /// The target was part of the parent's AfterTargets list.
         /// </summary>
-        AfterTargets
+        AfterTargets,
+
+        /// <summary>
+        /// The target was defined as an initial target of the project.
+        /// </summary>
+        InitialTargets,
+
+        /// <summary>
+        /// The target was one of the default targets of the project.
+        /// </summary>
+        DefaultTargets,
+
+        /// <summary>
+        /// The target was one of the targets explicitly called to be built.
+        /// </summary>
+        EntryTargets,
     }
 }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 8e9d1e09d00..cc0ef31eee8 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -110,11 +110,8 @@ public Traits()
         /// <summary>
         /// Log all environment variables whether or not they are used in a build in the binary log.
         /// </summary>
-        public static bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"))
-#if !TASKHOST
-            && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4)
-#endif
-            ;
+        public static bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"));
+
         /// <summary>
         /// Log property tracking information.
         /// </summary>
@@ -359,6 +356,14 @@ public bool? LogPropertiesAndItemsAfterEvaluation
         /// </remarks>
         public readonly bool UseMinimalResxParsingInCoreScenarios = Environment.GetEnvironmentVariable("MSBUILDUSEMINIMALRESX") == "1";
 
+        /// <summary>
+        /// Escape hatch to ensure msbuild produces the compatible build results cache without versioning.
+        /// </summary>
+        /// <remarks>
+        /// Escape hatch for problems arising from https://github.com/dotnet/msbuild/issues/10208.
+        /// </remarks>
+        public readonly bool DoNotVersionBuildResult = Environment.GetEnvironmentVariable("MSBUILDDONOTVERSIONBUILDRESULT") == "1";
+
         private bool _sdkReferencePropertyExpansionInitialized;
         private SdkReferencePropertyExpansionMode? _sdkReferencePropertyExpansionValue;
 
diff --git a/src/MSBuild.Bootstrap.Utils/MSBuild.Bootstrap.Utils.csproj b/src/MSBuild.Bootstrap.Utils/MSBuild.Bootstrap.Utils.csproj
new file mode 100644
index 00000000000..7539d0dcedb
--- /dev/null
+++ b/src/MSBuild.Bootstrap.Utils/MSBuild.Bootstrap.Utils.csproj
@@ -0,0 +1,10 @@
+<Project Sdk="Microsoft.NET.Sdk">
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="Microsoft.Build.Utilities.Core" VersionOverride="15.5.180" ExcludeAssets="runtime" PrivateAssets="all" />
+  </ItemGroup>
+
+</Project>
\ No newline at end of file
diff --git a/src/MSBuild.Bootstrap.Utils/Tasks/InstallDotNetCoreTask.cs b/src/MSBuild.Bootstrap.Utils/Tasks/InstallDotNetCoreTask.cs
new file mode 100644
index 00000000000..0eda643f491
--- /dev/null
+++ b/src/MSBuild.Bootstrap.Utils/Tasks/InstallDotNetCoreTask.cs
@@ -0,0 +1,172 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.IO;
+using System.Net.Http;
+using System.Runtime.InteropServices;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
+
+using AsyncTasks = System.Threading.Tasks;
+
+namespace MSBuild.Bootstrap.Utils.Tasks
+{
+    /// <summary>
+    /// This task is designed to automate the installation of .NET Core SDK.
+    /// It downloads the appropriate installation script and executes it to install the specified version of .NET Core SDK.
+    /// </summary>
+    public sealed class InstallDotNetCoreTask : ToolTask
+    {
+        private const string ScriptName = "dotnet-install";
+
+        /// <summary>
+        /// Initializes a new instance of the <see cref="InstallDotNetCoreTask"/> class.
+        /// </summary>
+        public InstallDotNetCoreTask()
+        {
+            InstallDir = string.Empty;
+            DotNetInstallScriptRootPath = string.Empty;
+            Version = string.Empty;
+        }
+
+        /// <summary>
+        /// Gets or sets the directory where the .NET Core SDK should be installed. This property is required.
+        /// </summary>
+        [Required]
+        public string InstallDir { get; set; }
+
+        /// <summary>
+        /// Gets or sets the root path where the .NET Core installation script is located. This property is required.
+        /// </summary>
+        [Required]
+        public string DotNetInstallScriptRootPath { get; set; }
+
+        /// <summary>
+        /// Gets or sets the version of the .NET Core SDK to be installed. This property is required.
+        /// </summary>
+        [Required]
+        public string Version { get; set; }
+
+        /// <summary>
+        /// Gets or sets the base URL for downloading the .NET Core installation script. The default value is "https://dot.net/v1/".
+        /// </summary>
+        public string DotNetInstallBaseUrl { get; set; } = "https://dot.net/v1/";
+
+        private bool IsWindows => RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
+
+        protected override string ToolName => IsWindows ? "powershell.exe" : "/bin/bash";
+
+        /// <summary>
+        /// Executes the task, downloading and running the .NET Core installation script.
+        /// </summary>
+        /// <returns>True if the task succeeded; otherwise, false.</returns>
+        public override bool Execute()
+        {
+            if (Directory.Exists(Path.Combine(InstallDir, "sdk", Version)))
+            {
+                // no need to download sdk again, it exists locally
+                return true;
+            }
+
+            ScriptExecutionSettings executionSettings = SetupScriptsExecutionSettings();
+            if (!File.Exists(executionSettings.ScriptsFullPath))
+            {
+                AsyncTasks.Task.Run(() => DownloadScriptAsync(executionSettings.ScriptName, executionSettings.ScriptsFullPath)).GetAwaiter().GetResult();
+            }
+
+            MakeScriptExecutable(executionSettings.ScriptsFullPath);
+
+            return RunScript(executionSettings);
+        }
+
+        protected override string GenerateFullPathToTool() => ToolName;
+
+        /// <summary>
+        /// Downloads the .NET Core installation script asynchronously from the specified URL.
+        /// </summary>
+        /// <param name="scriptName">The name of the script to download.</param>
+        /// <param name="scriptPath">The path where the script will be saved.</param>
+        private async AsyncTasks.Task DownloadScriptAsync(string scriptName, string scriptPath)
+        {
+            using (HttpClient client = new HttpClient())
+            {
+                HttpResponseMessage response = await client.GetAsync($"{DotNetInstallBaseUrl}{scriptName}").ConfigureAwait(false);
+                if (response.IsSuccessStatusCode)
+                {
+                    string scriptContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
+                    if (!string.IsNullOrEmpty(scriptContent))
+                    {
+                        File.WriteAllText(scriptPath, scriptContent);
+                    }
+                }
+                else
+                {
+                    Log.LogError($"Install-scripts download from {DotNetInstallBaseUrl} error. Status code: {response.StatusCode}.");
+                }
+            }
+        }
+
+        /// <summary>
+        /// Makes the installation script executable on non-Windows platforms.
+        /// </summary>
+        /// <param name="scriptPath">The path of the script to make executable.</param>
+        private void MakeScriptExecutable(string scriptPath)
+        {
+            if (!IsWindows)
+            {
+                int exitCode = ExecuteTool("/bin/chmod", string.Empty, $"+x {scriptPath}");
+                if (exitCode != 0)
+                {
+                    Log.LogError($"Install-scripts can not be made executable due to the errors reported above.");
+                }
+            }
+        }
+
+        /// <summary>
+        /// Runs the .NET Core installation script with the specified settings.
+        /// </summary>
+        /// <param name="executionSettings">The settings required for script execution.</param>
+        /// <returns>True if the script executed successfully; otherwise, false.</returns>
+        private bool RunScript(ScriptExecutionSettings executionSettings)
+        {
+            if (!Log.HasLoggedErrors)
+            {
+                int exitCode = ExecuteTool(ToolName, string.Empty, executionSettings.ExecutableArgs);
+
+                if (exitCode != 0)
+                {
+                    Log.LogError($"Install-scripts was not executed successfully.");
+                }
+            }
+
+            return !Log.HasLoggedErrors;
+        }
+
+        /// <summary>
+        /// Sets up the settings required for executing the .NET Core installation script.
+        /// </summary>
+        /// <returns>The settings required for script execution.</returns>
+        private ScriptExecutionSettings SetupScriptsExecutionSettings()
+        {
+            string scriptExtension = IsWindows ? "ps1" : "sh";
+            string scriptPath = Path.Combine(DotNetInstallScriptRootPath, $"{ScriptName}.{scriptExtension}");
+            string scriptArgs = IsWindows
+                ? $"-NoProfile -ExecutionPolicy Bypass -File {scriptPath} -Version {Version} -InstallDir {InstallDir}"
+                : $"{scriptPath} --version {Version} --install-dir {InstallDir}";
+
+            return new ScriptExecutionSettings($"{ScriptName}.{scriptExtension}", scriptPath, scriptArgs);
+        }
+
+        /// <summary>
+        /// A private struct to hold settings for script execution.
+        /// </summary>
+        private readonly struct ScriptExecutionSettings(string scriptName, string scriptsFullPath, string executableArgs)
+        {
+            public string ScriptName { get; } = scriptName;
+
+            public string ScriptsFullPath { get; } = scriptsFullPath;
+
+            public string ExecutableArgs { get; } = executableArgs;
+        }
+    }
+}
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 8a2a558e452..1d116d117d2 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -50,4 +50,4 @@
 
   <Import Project="$(RepoRoot)eng\BootStrapMsBuild.targets" />
 
-</Project>
+</Project>
\ No newline at end of file
diff --git a/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets b/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets
deleted file mode 100644
index 3571d7e37f5..00000000000
--- a/src/MSBuild.Bootstrap/RedirectNuGetConsoleProcess.After.Microsoft.Common.targets
+++ /dev/null
@@ -1,23 +0,0 @@
-<Project>
-  <!-- The CoreCLR flavor of NuGet.Build.Tasks.Console.exe looks for dotnet under "..\..\dotnet", so we need to redirect it for the bootstrap to the currently executing dotnet.exe.
-       See: https://github.com/NuGet/NuGet.Client/blob/91f6fdb26b09e16c4520b1d13ee30bb38172a7bd/src/NuGet.Core/NuGet.Build.Tasks/StaticGraphRestoreTaskBase.cs#L240-L252 -->
-  <UsingTask
-    TaskName="GetCurrentProcessFileName"
-    TaskFactory="RoslynCodeTaskFactory"
-    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
-    <ParameterGroup>
-      <CurrentProcessFileName ParameterType="System.String" Output="true" />
-    </ParameterGroup>
-    <Task>
-      <Using Namespace="System.Diagnostics" />
-      <Code Type="Fragment" Language="cs"><![CDATA[
-      CurrentProcessFileName = Process.GetCurrentProcess().MainModule.FileName;
-      ]]></Code>
-    </Task>
-  </UsingTask>
-  <Target Name="RedirectNuGetConsoleProcess" BeforeTargets="Restore">
-    <GetCurrentProcessFileName>
-      <Output TaskParameter="CurrentProcessFileName" PropertyName="NuGetConsoleProcessFileName" />
-    </GetCurrentProcessFileName>
-  </Target>
-</Project>
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Linux.verified.txt
new file mode 100644
index 00000000000..690f858d262
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Linux.verified.txt
@@ -0,0 +1,11 @@
+﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 1 in x ms.
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 2 in x ms.
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 3 in x ms.
+  project [31;1mfailed with 3 warning(s)[m (0.2s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 1 in x ms.
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 2 in x ms.
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 3 in x ms.
+[?25l[1F
+[?25h
+Build [31;1mfailed with 3 warning(s)[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.OSX.verified.txt
new file mode 100644
index 00000000000..2d3f5c696c9
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.OSX.verified.txt
@@ -0,0 +1,10 @@
+﻿directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 1 in x ms.
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 2 in x ms.
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 3 in x ms.
+  project [31;1mfailed with 3 warning(s)[m (0.2s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 1 in x ms.
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 2 in x ms.
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 3 in x ms.
+[?25l[1F
+[?25h
+Build [31;1mfailed with 3 warning(s)[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Windows.verified.txt
new file mode 100644
index 00000000000..690f858d262
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintCopyTaskRetryWarningAsImmediateMessage_Failed.Windows.verified.txt
@@ -0,0 +1,11 @@
+﻿]9;4;3;\directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 1 in x ms.
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 2 in x ms.
+directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 3 in x ms.
+  project [31;1mfailed with 3 warning(s)[m (0.2s)
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 1 in x ms.
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 2 in x ms.
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mMSB3026[m: MSB3026: Could not copy "sourcePath" to "destinationPath". Beginning retry 3 in x ms.
+[?25l[1F
+[?25h
+Build [31;1mfailed with 3 warning(s)[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Linux.verified.txt
new file mode 100644
index 00000000000..1aa3b2a7204
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Linux.verified.txt
@@ -0,0 +1,5 @@
+]9;4;3;\  㐇𠁠𪨰𫠊𫦠𮚮⿕ [32;1msucceeded[m (0.2s) → ]8;;file:///src/проектТерминал\/src/проектТерминал/㐇𠁠𪨰𫠊𫦠𮚮⿕.dll]8;;\
+[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.OSX.verified.txt
new file mode 100644
index 00000000000..3308b91e6d7
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.OSX.verified.txt
@@ -0,0 +1,4 @@
+  㐇𠁠𪨰𫠊𫦠𮚮⿕ [32;1msucceeded[m (0.2s) → ]8;;file:///src/проектТерминал\/src/проектТерминал/㐇𠁠𪨰𫠊𫦠𮚮⿕.dll]8;;\
+[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Windows.verified.txt
new file mode 100644
index 00000000000..85a9e20d1e6
--- /dev/null
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintProjectOutputDirectoryLink.Windows.verified.txt
@@ -0,0 +1,5 @@
+﻿]9;4;3;\  㐇𠁠𪨰𫠊𫦠𮚮⿕ [32;1msucceeded[m (0.2s) → ]8;;file:///C:/src/проектТерминал\C:\src\проектТерминал\㐇𠁠𪨰𫠊𫦠𮚮⿕.dll]8;;\
+[?25l[1F
+[?25h
+Build [32;1msucceeded[m in 5.0s
+]9;4;0;\
\ No newline at end of file
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index 7f89f347c25..87f64ade8b0 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -38,6 +38,7 @@ public class TerminalLogger_Tests : IEventSource, IDisposable
 
         private readonly string _projectFile = NativeMethods.IsUnixLike ? "/src/project.proj" : @"C:\src\project.proj";
         private readonly string _projectFile2 = NativeMethods.IsUnixLike ? "/src/project2.proj" : @"C:\src\project2.proj";
+        private readonly string _projectFileWithNonAnsiSymbols = NativeMethods.IsUnixLike ? "/src/проектТерминал/㐇𠁠𪨰𫠊𫦠𮚮⿕.proj" : @"C:\src\проектТерминал\㐇𠁠𪨰𫠊𫦠𮚮⿕.proj";
 
         private StringWriter _outputWriter = new();
 
@@ -186,6 +187,16 @@ private BuildWarningEventArgs MakeWarningEventArgs(string warning)
             };
         }
 
+        private BuildWarningEventArgs MakeCopyRetryWarning(int retryCount)
+        {
+            return new BuildWarningEventArgs("", "MSB3026", "directory/file", 1, 2, 3, 4,
+                $"MSB3026: Could not copy \"sourcePath\" to \"destinationPath\". Beginning retry {retryCount} in x ms.",
+                null, null)
+            {
+                BuildEventContext = MakeBuildEventContext(),
+            };
+        }
+
         private BuildMessageEventArgs MakeMessageEventArgs(string message, MessageImportance importance)
         {
             return new BuildMessageEventArgs(message, "keyword", null, importance)
@@ -223,20 +234,22 @@ private BuildErrorEventArgs MakeErrorEventArgs(string error)
 
         #region Build summary tests
 
-        private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additionalCallbacks)
+        private void InvokeLoggerCallbacksForSimpleProject(bool succeeded, Action additionalCallbacks, string? projectFile = null)
         {
+            projectFile ??= _projectFile;
+
             BuildStarted?.Invoke(_eventSender, MakeBuildStartedEventArgs());
-            ProjectStarted?.Invoke(_eventSender, MakeProjectStartedEventArgs(_projectFile));
+            ProjectStarted?.Invoke(_eventSender, MakeProjectStartedEventArgs(projectFile));
 
-            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(_projectFile, "Build"));
-            TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(_projectFile, "Task"));
+            TargetStarted?.Invoke(_eventSender, MakeTargetStartedEventArgs(projectFile, "Build"));
+            TaskStarted?.Invoke(_eventSender, MakeTaskStartedEventArgs(projectFile, "Task"));
 
             additionalCallbacks();
 
-            TaskFinished?.Invoke(_eventSender, MakeTaskFinishedEventArgs(_projectFile, "Task", succeeded));
-            TargetFinished?.Invoke(_eventSender, MakeTargetFinishedEventArgs(_projectFile, "Build", succeeded));
+            TaskFinished?.Invoke(_eventSender, MakeTaskFinishedEventArgs(projectFile, "Task", succeeded));
+            TargetFinished?.Invoke(_eventSender, MakeTargetFinishedEventArgs(projectFile, "Build", succeeded));
 
-            ProjectFinished?.Invoke(_eventSender, MakeProjectFinishedEventArgs(_projectFile, succeeded));
+            ProjectFinished?.Invoke(_eventSender, MakeProjectFinishedEventArgs(projectFile, succeeded));
             BuildFinished?.Invoke(_eventSender, MakeBuildFinishedEventArgs(succeeded));
         }
 
@@ -320,6 +333,19 @@ public Task PrintImmediateWarningMessage_Succeeded()
             return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
         }
 
+        [Fact]
+        public Task PrintCopyTaskRetryWarningAsImmediateMessage_Failed()
+        {
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
+            {
+                WarningRaised?.Invoke(_eventSender, MakeCopyRetryWarning(1));
+                WarningRaised?.Invoke(_eventSender, MakeCopyRetryWarning(2));
+                WarningRaised?.Invoke(_eventSender, MakeCopyRetryWarning(3));
+            });
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
+
         [Fact]
         public Task PrintImmediateMessage_Success()
         {
@@ -426,6 +452,22 @@ public Task PrintBuildSummary_2Projects_FailedWithErrorsAndWarnings()
             return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
         }
 
+        [Fact]
+        public Task PrintProjectOutputDirectoryLink()
+        {
+            // Send message in order to set project output path
+            BuildMessageEventArgs e = MakeMessageEventArgs(
+                    $"㐇𠁠𪨰𫠊𫦠𮚮⿕ -> {_projectFileWithNonAnsiSymbols.Replace("proj", "dll")}",
+                    MessageImportance.High);
+            e.ProjectFile = _projectFileWithNonAnsiSymbols;
+
+            InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
+            {
+                MessageRaised?.Invoke(_eventSender, e);
+            }, _projectFileWithNonAnsiSymbols);
+
+            return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
+        }
 
         #endregion
 
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index c33b4e8da98..0ef451ba979 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -899,10 +899,8 @@ public void SetConsoleUICulture()
         }
 
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
+        [Fact]
+        public void ConsoleUIRespectsSDKLanguage()
         {
             if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && !EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding())
             {
@@ -923,18 +921,10 @@ public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
             {
                 // Set the UI language based on the SDK environment var.
                 testEnvironment.SetEnvironmentVariable(DOTNET_CLI_UI_LANGUAGE, "ja"); // Japanese chose arbitrarily.
-                ChangeWaves.ResetStateForTests();
-                if (!enableFeature)
-                {
-                    testEnvironment.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_8.ToString());
-                }
                 MSBuildApp.SetConsoleUI();
 
-                Assert.Equal(enableFeature ? new CultureInfo("ja") : CultureInfo.CurrentUICulture.GetConsoleFallbackUICulture(), thisThread.CurrentUICulture);
-                if (enableFeature)
-                {
-                    Assert.Equal(65001, Console.OutputEncoding.CodePage); // UTF-8 enabled for correct rendering.
-                }
+                Assert.Equal(new CultureInfo("ja"), thisThread.CurrentUICulture);
+                Assert.Equal(65001, Console.OutputEncoding.CodePage); // UTF-8 enabled for correct rendering.
             }
             finally
             {
@@ -956,7 +946,6 @@ public void ConsoleUIRespectsSDKLanguage(bool enableFeature)
         /// We shouldn't change the UI culture if the current UI culture is invariant.
         /// In other cases, we can get an exception on CultureInfo creation when System.Globalization.Invariant enabled.
         /// </summary>
-
         [Fact]
         public void SetConsoleUICultureInInvariantCulture()
         {
@@ -2633,11 +2622,11 @@ public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMe
         [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
         [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
 
-        [InlineData("/v:diagnostic /analyze", MessageImportance.Low)]
-        [InlineData("/v:detailed /analyze", MessageImportance.Low)]
-        [InlineData("/v:normal /analyze", MessageImportance.Normal)]
-        [InlineData("/v:minimal /analyze", MessageImportance.High)]
-        [InlineData("/v:quiet /analyze", MessageImportance.High)]
+        [InlineData("/v:diagnostic /check", MessageImportance.Low)]
+        [InlineData("/v:detailed /check", MessageImportance.Low)]
+        [InlineData("/v:normal /check", MessageImportance.Normal)]
+        [InlineData("/v:minimal /check", MessageImportance.High)]
+        [InlineData("/v:quiet /check", MessageImportance.High)]
 
         [InlineData("/v:diagnostic /tl", MessageImportance.Low)]
         [InlineData("/v:detailed /tl", MessageImportance.Low)]
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index e7800bdf4ca..ae5646ca7d1 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -99,7 +100,7 @@ internal enum ParameterizedSwitch
             WarningsNotAsErrors,
             WarningsAsMessages,
             BinaryLogger,
-            Analyze,
+            Check,
             Restore,
             ProfileEvaluation,
             RestoreProperty,
@@ -138,11 +139,13 @@ private struct ParameterlessSwitchInfo
             internal ParameterlessSwitchInfo(
                 string[] switchNames,
                 ParameterlessSwitch parameterlessSwitch,
-                string duplicateSwitchErrorMessage)
+                string duplicateSwitchErrorMessage,
+                string resourceId)
             {
                 this.switchNames = switchNames;
                 this.duplicateSwitchErrorMessage = duplicateSwitchErrorMessage;
                 this.parameterlessSwitch = parameterlessSwitch;
+                this.resourceId = resourceId;
             }
 
             // names of the switch (without leading switch indicator)
@@ -152,6 +155,7 @@ internal ParameterlessSwitchInfo(
             internal string duplicateSwitchErrorMessage;
             // the switch id
             internal ParameterlessSwitch parameterlessSwitch;
+            internal string resourceId;
         }
 
         /// <summary>
@@ -179,7 +183,8 @@ internal ParameterizedSwitchInfo(
                 bool multipleParametersAllowed,
                 string missingParametersErrorMessage,
                 bool unquoteParameters,
-                bool emptyParametersAllowed)
+                bool emptyParametersAllowed,
+                string resourceId)
             {
                 this.switchNames = switchNames;
                 this.duplicateSwitchErrorMessage = duplicateSwitchErrorMessage;
@@ -188,6 +193,7 @@ internal ParameterizedSwitchInfo(
                 this.unquoteParameters = unquoteParameters;
                 this.parameterizedSwitch = parameterizedSwitch;
                 this.emptyParametersAllowed = emptyParametersAllowed;
+                this.resourceId = resourceId;
             }
 
             internal string[] switchNames;
@@ -197,33 +203,34 @@ internal ParameterizedSwitchInfo(
             internal bool unquoteParameters;
             internal ParameterizedSwitch parameterizedSwitch;
             internal bool emptyParametersAllowed;
+            internal string resourceId;
         }
 
         // map switches that do not take parameters to their identifiers (taken from ParameterlessSwitch enum)
         // WARNING: keep this map in the same order as the ParameterlessSwitch enumeration
         private static readonly ParameterlessSwitchInfo[] s_parameterlessSwitchesMap =
         {
-            //---------------------------------------------------------------------------------------------------------------------------------------------------
-            //                                          Switch Names                        Switch Id                             Dup Error  Light up key
-            //---------------------------------------------------------------------------------------------------------------------------------------------------
-            new ParameterlessSwitchInfo(  new string[] { "help", "h", "?" },                         ParameterlessSwitch.Help,                  null),
-            new ParameterlessSwitchInfo(  new string[] { "version", "ver" },                         ParameterlessSwitch.Version,               null),
-            new ParameterlessSwitchInfo(  new string[] { "nologo" },                                 ParameterlessSwitch.NoLogo,                null),
-            new ParameterlessSwitchInfo(  new string[] { "noautoresponse", "noautorsp" },            ParameterlessSwitch.NoAutoResponse,        null),
-            new ParameterlessSwitchInfo(  new string[] { "noconsolelogger", "noconlog" },            ParameterlessSwitch.NoConsoleLogger,       null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger", "fl" },                       ParameterlessSwitch.FileLogger,            null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger1", "fl1" },                     ParameterlessSwitch.FileLogger1,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger2", "fl2" },                     ParameterlessSwitch.FileLogger2,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger3", "fl3" },                     ParameterlessSwitch.FileLogger3,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger4", "fl4" },                     ParameterlessSwitch.FileLogger4,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger5", "fl5" },                     ParameterlessSwitch.FileLogger5,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger6", "fl6" },                     ParameterlessSwitch.FileLogger6,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger7", "fl7" },                     ParameterlessSwitch.FileLogger7,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },                     ParameterlessSwitch.FileLogger8,           null),
-            new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },                     ParameterlessSwitch.FileLogger9,           null),
-            new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },           ParameterlessSwitch.DistributedFileLogger, null),
+            //----------------------------------------------------------------------------------------------------------------------------------------------------------
+            //                                          Switch Names                        Switch Id                             Dup Error  Light up key    resourceId
+            //----------------------------------------------------------------------------------------------------------------------------------------------------------
+            new ParameterlessSwitchInfo(  new string[] { "help", "h", "?" },                         ParameterlessSwitch.Help,                  null,       "HelpMessage_4_HelpSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "version", "ver" },                         ParameterlessSwitch.Version,               null,       "HelpMessage_6_VersionSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "nologo" },                                 ParameterlessSwitch.NoLogo,                null,       "HelpMessage_5_NoLogoSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "noautoresponse", "noautorsp" },            ParameterlessSwitch.NoAutoResponse,        null,       "HelpMessage_8_NoAutoResponseSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "noconsolelogger", "noconlog" },            ParameterlessSwitch.NoConsoleLogger,       null,       "HelpMessage_14_NoConsoleLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger", "fl" },                       ParameterlessSwitch.FileLogger,            null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger1", "fl1" },                     ParameterlessSwitch.FileLogger1,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger2", "fl2" },                     ParameterlessSwitch.FileLogger2,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger3", "fl3" },                     ParameterlessSwitch.FileLogger3,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger4", "fl4" },                     ParameterlessSwitch.FileLogger4,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger5", "fl5" },                     ParameterlessSwitch.FileLogger5,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger6", "fl6" },                     ParameterlessSwitch.FileLogger6,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger7", "fl7" },                     ParameterlessSwitch.FileLogger7,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },                     ParameterlessSwitch.FileLogger8,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },                     ParameterlessSwitch.FileLogger9,           null,       "HelpMessage_20_FileLoggerSwitch"),
+            new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },           ParameterlessSwitch.DistributedFileLogger, null,       "HelpMessage_21_DistributedFileLoggerSwitch"),
 #if DEBUG
-            new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },                 ParameterlessSwitch.WaitForDebugger,       null),
+            new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },                 ParameterlessSwitch.WaitForDebugger,       null,       null),
 #endif
         };
 
@@ -231,63 +238,65 @@ internal ParameterizedSwitchInfo(
         // WARNING: keep this map in the same order as the ParameterizedSwitch enumeration
         private static readonly ParameterizedSwitchInfo[] s_parameterizedSwitchesMap =
         {
-            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-            //                                          Switch Names                            Switch Id                                       Duplicate Switch Error          Multi Params?   Missing Parameters Error           Unquote?    Empty?
-            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-            new ParameterizedSwitchInfo(  new string[] { null },                                ParameterizedSwitch.Project,                    "DuplicateProjectSwitchError",  false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "target", "t"},                        ParameterizedSwitch.Target,                     null,                           true,           "MissingTargetError",                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "property", "p" },                     ParameterizedSwitch.Property,                   null,                           true,           "MissingPropertyError",                true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "logger", "l" },                       ParameterizedSwitch.Logger,                     null,                           false,          "MissingLoggerError",                  false,  false),
-            new ParameterizedSwitchInfo(  new string[] { "distributedlogger", "dl" },           ParameterizedSwitch.DistributedLogger,          null,                           false,          "MissingLoggerError",                  false,  false),
-            new ParameterizedSwitchInfo(  new string[] { "verbosity", "v" },                    ParameterizedSwitch.Verbosity,                  null,                           false,          "MissingVerbosityError",               true,   false),
+            //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+            //                                          Switch Names                            Switch Id                                       Duplicate Switch Error          Multi Params?   Missing Parameters Error           Unquote?    Empty?   reosurceId
+            //-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+            new ParameterizedSwitchInfo(  new string[] { null },                                ParameterizedSwitch.Project,                    "DuplicateProjectSwitchError",  false,          null,                                  true,   false,   null),
+            new ParameterizedSwitchInfo(  new string[] { "target", "t"},                        ParameterizedSwitch.Target,                     null,                           true,           "MissingTargetError",                  true,   false,   "HelpMessage_9_TargetSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "property", "p" },                     ParameterizedSwitch.Property,                   null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_10_PropertySwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "logger", "l" },                       ParameterizedSwitch.Logger,                     null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_11_LoggerSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "distributedlogger", "dl" },           ParameterizedSwitch.DistributedLogger,          null,                           false,          "MissingLoggerError",                  false,  false,   "HelpMessage_18_DistributedLoggerSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "verbosity", "v" },                    ParameterizedSwitch.Verbosity,                  null,                           false,          "MissingVerbosityError",               true,   false,   "HelpMessage_12_VerbositySwitch"),
 #if FEATURE_XML_SCHEMA_VALIDATION
-            new ParameterizedSwitchInfo(  new string[] { "validate", "val" },                   ParameterizedSwitch.Validate,                   null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "validate", "val" },                   ParameterizedSwitch.Validate,                   null,                           false,          null,                                  true,   false,   "HelpMessage_15_ValidateSwitch"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "consoleloggerparameters", "clp" },    ParameterizedSwitch.ConsoleLoggerParameters,    null,                           false,          "MissingConsoleLoggerParameterError",  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "nodemode", "nmode" },                 ParameterizedSwitch.NodeMode,                   null,                           false,          null,                                  false,  false),
-            new ParameterizedSwitchInfo(  new string[] { "maxcpucount", "m" },                  ParameterizedSwitch.MaxCPUCount,                null,                           false,          "MissingMaxCPUCountError",             true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "ignoreprojectextensions", "ignore" }, ParameterizedSwitch.IgnoreProjectExtensions,    null,                           true,           "MissingIgnoreProjectExtensionsError", true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "toolsversion","tv" },                 ParameterizedSwitch.ToolsVersion,               null,                           false,          "MissingToolsVersionError",            true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters", "flp" },       ParameterizedSwitch.FileLoggerParameters,       null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters1", "flp1" },     ParameterizedSwitch.FileLoggerParameters1,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters2", "flp2" },     ParameterizedSwitch.FileLoggerParameters2,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters3", "flp3" },     ParameterizedSwitch.FileLoggerParameters3,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters4", "flp4" },     ParameterizedSwitch.FileLoggerParameters4,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters5", "flp5" },     ParameterizedSwitch.FileLoggerParameters5,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters6", "flp6" },     ParameterizedSwitch.FileLoggerParameters6,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters7", "flp7" },     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters8", "flp8" },     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "consoleloggerparameters", "clp" },    ParameterizedSwitch.ConsoleLoggerParameters,    null,                           false,          "MissingConsoleLoggerParameterError",  true,   false,   "HelpMessage_13_ConsoleLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "nodemode", "nmode" },                 ParameterizedSwitch.NodeMode,                   null,                           false,          null,                                  false,  false,   null),
+            new ParameterizedSwitchInfo(  new string[] { "maxcpucount", "m" },                  ParameterizedSwitch.MaxCPUCount,                null,                           false,          "MissingMaxCPUCountError",             true,   false,   "HelpMessage_17_MaximumCPUSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "ignoreprojectextensions", "ignore" }, ParameterizedSwitch.IgnoreProjectExtensions,    null,                           true,           "MissingIgnoreProjectExtensionsError", true,   false,   "HelpMessage_19_IgnoreProjectExtensionsSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "toolsversion","tv" },                 ParameterizedSwitch.ToolsVersion,               null,                           false,          "MissingToolsVersionError",            true,   false,   "HelpMessage_23_ToolsVersionSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters", "flp" },       ParameterizedSwitch.FileLoggerParameters,       null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters1", "flp1" },     ParameterizedSwitch.FileLoggerParameters1,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters2", "flp2" },     ParameterizedSwitch.FileLoggerParameters2,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters3", "flp3" },     ParameterizedSwitch.FileLoggerParameters3,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters4", "flp4" },     ParameterizedSwitch.FileLoggerParameters4,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters5", "flp5" },     ParameterizedSwitch.FileLoggerParameters5,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters6", "flp6" },     ParameterizedSwitch.FileLoggerParameters6,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters7", "flp7" },     ParameterizedSwitch.FileLoggerParameters7,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters8", "flp8" },     ParameterizedSwitch.FileLoggerParameters8,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false,   "HelpMessage_22_FileLoggerParametersSwitch"),
             // To not break existing use, keep supporting live logger switches
-            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true),
-            new ParameterizedSwitchInfo(  new string[] { "terminalloggerparameters", "tlp" },   ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "warnaserror", "err" },                ParameterizedSwitch.WarningsAsErrors,           null,                           true,           null,                                  true,   true),
-            new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "analyze", },                     ParameterizedSwitch.Analyze,                    null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "interactive" },                       ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "isolateprojects", "isolate" },        ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true),
-            new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true),
+            new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true,    "HelpMessage_47_TerminalLoggerSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "terminalloggerparameters", "tlp" },   ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false,   "HelpMessage_48_TerminalLoggerParametersSwitch"),
+#if FEATURE_NODE_REUSE
+            new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false,   "HelpMessage_24_NodeReuse"),
+#endif
+            new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false,   "HelpMessage_25_PreprocessSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false,   "HelpMessage_38_TargetsSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "warnaserror", "err" },                ParameterizedSwitch.WarningsAsErrors,           null,                           true,           null,                                  true,   true,    "HelpMessage_28_WarnAsErrorSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "check", },                            ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   null),
+            new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "interactive" },                       ParameterizedSwitch.Interactive,                null,                           false,          null,                                  true,   false,   "HelpMessage_34_InteractiveSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "isolateprojects", "isolate" },        ParameterizedSwitch.IsolateProjects,            null,                           false,          null,                                  true,   false,   "HelpMessage_35_IsolateProjectsSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false,   "HelpMessage_36_GraphBuildSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true,    "HelpMessage_InputCachesFiles"),
+            new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true,    "HelpMessage_OutputCacheFile"),
 #if FEATURE_REPORTFILEACCESSES
-            new ParameterizedSwitchInfo(  new string[] { "reportfileaccesses" },                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "reportfileaccesses" },                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false,   "HelpMessage_42_ReportFileAccessesSwitch"),
 #endif
-            new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "getResultOutputFile" },               ParameterizedSwitch.GetResultOutputFile,        null,                           true,           "MissingGetResultFileError",           true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "featureavailability", "fa" },         ParameterizedSwitch.FeatureAvailability,        null,                           true,           "MissingFeatureAvailabilityError",     true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false,   "HelpMessage_39_LowPrioritySwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false,   "HelpMessage_41_QuestionSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false,   "HelpMessage_26_DetailedSummarySwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false,   "HelpMessage_43_GetPropertySwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",                 true,   false,   "HelpMessage_44_GetItemSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",         true,   false,   "HelpMessage_45_GetTargetResultSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "getResultOutputFile" },               ParameterizedSwitch.GetResultOutputFile,        null,                           true,           "MissingGetResultFileError",           true,   false,   "HelpMessage_51_GetResultOutputFileSwitch"),
+            new ParameterizedSwitchInfo(  new string[] { "featureAvailability", "fa" },         ParameterizedSwitch.FeatureAvailability,        null,                           true,           "MissingFeatureAvailabilityError",     true,   false,   "HelpMessage_46_FeatureAvailabilitySwitch")
         };
 
         /// <summary>
@@ -367,6 +376,40 @@ internal static bool IsParameterizedSwitch(
             return false;
         }
 
+        /// <summary>
+        /// Get the distinct parameterized switchs map resource ids.
+        /// </summary>
+        /// <returns>Parameterized switches map resource ids.</returns>
+        internal static IEnumerable<string> GetParameterizedSwitchResourceIds()
+        {
+            HashSet<string> parameterizedSwitchResourceIds = new HashSet<string>();
+            foreach (ParameterizedSwitchInfo parameterizedSwitch in s_parameterizedSwitchesMap)
+            {
+                string resourceId = parameterizedSwitch.resourceId;
+                if (!string.IsNullOrEmpty(resourceId) && parameterizedSwitchResourceIds.Add(resourceId))
+                {
+                    yield return resourceId;
+                }
+            }
+        }
+
+        /// <summary>
+        /// Get the distinct parameterless switchs map resource ids.
+        /// </summary>
+        /// <returns>Parameterless switchs map resource ids</returns>
+        internal static IEnumerable<string> GetParameterlessSwitchResourceIds()
+        {
+            HashSet<string> parameterlessSwitchResourceIds = new HashSet<string>();
+            foreach (ParameterlessSwitchInfo parameterlessSwitch in s_parameterlessSwitchesMap)
+            {
+                string resourceId = parameterlessSwitch.resourceId;
+                if (parameterlessSwitchResourceIds.Add(resourceId) && !string.IsNullOrEmpty(resourceId))
+                {
+                    yield return resourceId;
+                }
+            }
+        }
+
         /// <summary>
         /// This struct stores the details of a switch that doesn't take parameters that is detected on the command line.
         /// </summary>
@@ -413,12 +456,21 @@ internal CommandLineSwitches()
             {
                 Debug.Assert(i == (int)(s_parameterlessSwitchesMap[i].parameterlessSwitch),
                     "The map of parameterless switches must be ordered the same way as the ParameterlessSwitch enumeration.");
+                if (s_parameterlessSwitchesMap[i].parameterlessSwitch is not ParameterlessSwitch.WaitForDebugger)
+                {
+                    Debug.Assert(!string.IsNullOrEmpty(s_parameterlessSwitchesMap[i].resourceId), "All parameterless switches should be cross-checked against the help message strings");
+                }
             }
 
             for (int i = 0; i < s_parameterizedSwitchesMap.Length; i++)
             {
                 Debug.Assert(i == (int)(s_parameterizedSwitchesMap[i].parameterizedSwitch),
                     "The map of parameterized switches must be ordered the same way as the ParameterizedSwitch enumeration.");
+                if (s_parameterizedSwitchesMap[i].parameterizedSwitch is not ParameterizedSwitch.Project and
+                    not ParameterizedSwitch.NodeMode and not ParameterizedSwitch.Check)
+                {
+                    Debug.Assert(!string.IsNullOrEmpty(s_parameterizedSwitchesMap[i].resourceId), "All parameterized switches should be cross-checked against the help message strings except from project switch");
+                }
             }
 #endif
             _parameterlessSwitches = new DetectedParameterlessSwitch[(int)ParameterlessSwitch.NumberOfParameterlessSwitches];
diff --git a/src/MSBuild/JsonOutputFormatter.cs b/src/MSBuild/JsonOutputFormatter.cs
index 095f0761386..cdc166849ca 100644
--- a/src/MSBuild/JsonOutputFormatter.cs
+++ b/src/MSBuild/JsonOutputFormatter.cs
@@ -132,7 +132,7 @@ internal void AddTargetResultsInJsonFormat(string[] targetNames, BuildResult res
             JsonObject targetResultsNode = new();
             foreach (string targetName in targetNames)
             {
-                TargetResult targetResult = result.ResultsByTarget[targetName];
+                TargetResult targetResult = result.ResultsByTarget![targetName];
                 JsonObject targetResults = new();
                 targetResults["Result"] = targetResult.ResultCode.ToString();
                 JsonArray outputArray = new();
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 83b48d2558c..fba9b94c7bb 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1863,15 +1863,15 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="IsAotCompatible" _locComment="" -->Indicates whether a class library is compatible with native AOT. Setting to true will enable analyzers for trimming, single file, and AOT.</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="IsWebBootstrapper" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="IsWebBootstrapper" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="JCPA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="Keyword" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="LangVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="VBRuntime" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="Prefer32Bit" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="PreferNativeArm64" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="HighEntropyVA" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="LinkIncremental" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="Prefer32Bit" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="PreferNativeArm64" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="HighEntropyVA" type="msb:boolean" substitutionGroup="msb:Property"/>
+    <xs:element name="LinkIncremental" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestCertificateThumbprint" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ManifestKeyFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="MapFileExtensions" type="msb:boolean" substitutionGroup="msb:Property">
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 1129806b5c5..cd79aaebfba 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -929,6 +929,118 @@
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </comment>
   </data>
+  <data name="HelpMessage_43_GetPropertySwitch" Visibility="Public">
+    <value>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </value>
+    <comment>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
+  <data name="HelpMessage_44_GetItemSwitch" Visibility="Public">
+    <value>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </value>
+    <comment>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
+  <data name="HelpMessage_45_GetTargetResultSwitch" Visibility="Public">
+    <value>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </value>
+    <comment>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
+  <data name="HelpMessage_46_FeatureAvailabilitySwitch" Visibility="Public">
+    <value>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </value>
+    <comment>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
+  <data name="HelpMessage_47_TerminalLoggerSwitch" Visibility="Public">
+    <value>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </value>
+    <comment>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
+  <data name="HelpMessage_51_GetResultOutputFileSwitch" Visibility="Public">
+    <value>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </value>
+    <comment>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
+  <data name="HelpMessage_48_TerminalLoggerParametersSwitch" Visibility="Public">
+    <value>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </value>
+    <comment>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
   <data name="InvalidConfigurationFile" xml:space="preserve">
     <value>MSBUILD : Configuration error MSB1043: The application could not start. {0}</value>
     <comment>
@@ -1106,10 +1218,10 @@
     </comment>
   </data>
   <data name="MissingFeatureAvailabilityError" UESanitized="true" Visibility="Public">
-    <value>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</value>
+    <value>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</value>
     <comment>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
@@ -1282,7 +1394,7 @@
     <value>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</value>
     <comment>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
@@ -1373,9 +1485,6 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
-  <data name="AbortingBuild" xml:space="preserve">
-    <value>Attempting to cancel the build...</value>
-  </data>
   <data name="InvalidPreprocessPath" xml:space="preserve">
     <value>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</value>
     <comment>{StrBegin="MSBUILD : error MSB1047: "}</comment>
@@ -1661,6 +1770,19 @@
     <value>succeeded: {0}</value>
     <comment>{0} whole number</comment>
   </data>
+  <data name="LongPaths" xml:space="preserve">
+    <value>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</value>
+    <comment>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</comment>
+  </data>
+  <data name="LongPaths_Enabled" xml:space="preserve">
+    <value>enabled</value>
+  </data>
+  <data name="LongPaths_Disabled" xml:space="preserve">
+    <value>disabled</value>
+  </data>
+  <data name="LongPaths_Missing" xml:space="preserve">
+    <value>not set</value>
+  </data>
   <!-- **** TerminalLogger strings end **** -->
     <!--
         The command line message bucket is: MSB1001 - MSB1999
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index f417ee15051..2307688888d 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -129,6 +129,188 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     Vypíše hodnotu jedné nebo více zadaných vlastností
+                     po vyhodnocení bez provedení sestavení, nebo pokud je
+                     použita volba -targets nebo volba -getTargetResult,
+                     vypíše hodnoty po sestavení.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     Vypíše hodnotu jedné nebo více zadaných položek
+                     a jejich přidružená metadata po vyhodnocení bez
+                     provedení sestavení, nebo pokud je použita volba -targets
+                     nebo volba -getTargetResult, vypíše hodnoty
+                     po sestavení.
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     Vypíše výstupní hodnotu jednoho nebo více cílů a
+                     zadané cíle se provedou.
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     Zkontroluje dostupnost funkce. Výsledkem je jeden
+                     z řetězců Undefined, Available, NotAvailable a
+                     Preview.
+                     - Undefined – Dostupnost funkce je nedefinovaná
+                     (název funkce je pro kontrolu dostupnosti funkce
+                     neznámý).
+                     - NotAvailable – Funkce není k dispozici (na rozdíl
+                     od možnosti Undefined je název funkce nástroji pro
+                     kontrolu dostupnosti funkce znám a ten ví, že funkce není
+                     podporována aktuálním modulem MSBuild).
+                     - Available – Funkce je k dispozici.
+                     - Preview – Funkce je ve verzi Preview (není stabilní).
+                     (Krátký tvar: -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Povolí nebo zakáže protokolovací nástroj terminálu. Protokolovací nástroj
+                     terminálu poskytuje v konzole v reálném čase rozšířený výstup
+                     sestavení, který je logicky uspořádán podle projektů a je navržen tak,
+                     aby zvýrazňoval informace s možností reakce. Pokud chcete, aby byl protokolovací nástroj terminálu použit,
+                     pouze pokud není přesměrován standardní výstup, zadejte
+                     auto (nebo použijte volbu bez argumentů). Výstup neparsujte
+                     ani jinak nespoléhejte na to, že v budoucích verzích zůstane
+                     beze změny. Tato možnost je dostupná v MSBuildu 17.8 a
+                     novějších verzích.
+                     (Krátký tvar: -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parametry pro protokolovací nástroj terminálu. (Krátký tvar: -tlp)
+                     Dostupné parametry.
+                        default – Určuje výchozí chování protokolovacího
+                        nástroje terminálu. Vyžaduje jednu z následujících hodnot:
+                           - on, true vynutí použití TerminalLoggeru,
+                            i kdyby byl zakázaný.
+                           - off, false vynutí nepoužívání TerminalLoggeru,
+                            i kdyby byl povolený.
+                           - auto povolí TerminalLogger, když to terminál
+                            podporuje a relace nemá přesměrované
+                            stdout/stderr
+                        verbosity – Přepíše nastavení -verbosity pro tento
+                        protokolovací nástroj.
+                        showCommandLine – Zobrazí zprávy TaskCommandLineEvent.
+
+                      Příklad:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     Přesměruje výstup get* do souboru.
+
+                     Příklad:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     Tím se zapíše hodnota vlastnosti Bar do souboru Biz.txt.
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -161,6 +343,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">Na základě klíče registru Windows LongPathsEnabled má funkce LongPaths hodnotu {0}.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">zakázáno</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">povoleno</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">nenastaveno</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">MSBuild verze {0} pro {1}</target>
@@ -1342,11 +1544,11 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: Je nutné zadat název funkce pro přepínač dostupnosti funkcí.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: Je nutné zadat název funkce pro přepínač featureAvailability.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1444,7 +1646,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">MSBUILD : error MSB1066: Pokud používáte přepínač -terminalLoggerParameters, zadejte jeden nebo více parametrů pro terminálový protokolovací nástroj.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1804,11 +2006,6 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">Pokus o zrušení sestavování...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: Soubor, do kterého má být provedeno předběžné zpracování, není platný. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 50706b404dc..d18271f2f41 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -129,6 +129,188 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     Schreiben Sie den Wert einer oder mehrerer angegebener Eigenschaften
+                     nach der Auswertung aus, ohne den Build auszuführen, oder wenn entweder
+                     die Option "-getTargetResult" oder die Option "-getTargetResult" verwendet
+                     wird, schreiben Sie die Werte nach dem Build aus.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     Schreiben Sie den Wert eines oder mehrerer angegebener Elemente und
+                     die zugehörigen Metadaten nach der Auswertung ohne
+                     Ausführen des Builds aus, oder wenn entweder die Option "-targets"
+                     oder die Option "-getTargetResult" verwendet wird, schreiben Sie
+                     die Werte nach dem Build aus.
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     Schreiben Sie den Ausgabewert eines oder mehrerer Ziele aus und
+                     die angegebenen Ziele werden ausgeführt.
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     Überprüft die Verfügbarkeit von Features. Das Ergebnis ist eine der
+                     Zeichenfolgen "Undefined", "Available", "NotAvailable" und
+                     "Preview".
+                     –Undefinied: Die Verfügbarkeit des Features ist nicht definiert
+                     (der Featurename ist für den Prüfer der Featureverfügbarkeit
+                     unbekannt)
+                     -NotAvailable: Das Feature ist nicht verfügbar (im Gegensatz zu
+                     "Undefined", wo der Featurename für den Prüfer der Featureverfügbarkeit
+                     bekannt ist und er weiß, dass das Feature von der
+                     aktuellen MSBuild-Engine nicht unterstützt wird)
+                     -Available: Das Feature ist verfügbar
+                     -Preview: Das Feature befindet sich in der Vorschau (nicht stabil)
+                     (Kurzform: -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Aktiviert oder deaktiviert die Terminalprotokollierung. Terminal-Logger
+                     bietet verbesserte Buildausgabe auf der Konsole in Echtzeit,
+                     logisch nach Projekt organisiert und entwickelt, um
+                     verwertbare Informationen hervorzuheben. Geben Sie "auto" an (oder verwenden Sie die Option
+                     ohne Argumente), um den Terminal-Logger nur zu verwenden, wenn die
+                     Standardausgabe nicht umgeleitet wird. Analysieren Sie die Ausgabe nicht
+                     oder vertrauen Sie darauf, dass sie in zukünftigen
+                     Versionen unverändert bleibt. Diese Option ist in MSBuild 17.8 und
+                     später verfügbar.
+                     (Kurzform: -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameter für Terminal-Logger. (Kurzform: -tlp)
+                     Die verfügbaren Parameter.
+                        default: Gibt das Standardverhalten des Terminal-
+                        Loggers an. Erfordert einen der folgenden Werte:
+                           – "on", "true" erzwingt die Verwendung von TerminalLogger, auch
+                            wenn er deaktiviert werden sollte.
+                           – "off", "true" erzwingt die Nichtverwendung von TerminalLogger, auch
+                            wenn er aktiviert werden sollte.
+                           – "auto" aktiviert TerminalLogger, wenn das Terminal
+                            dies unterstützt, und die Sitzung nicht umgeleitet wurde
+                            stdout/stderr
+                        verbosity: Überschreiben Sie die Einstellung "-verbosity" für diesen
+                        Logger
+                        showCommandLine: TaskCommandLineEvent-Meldungen anzeigen
+
+                      Beispiel: 
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     Leiten Sie die Ausgabe von get* in eine Datei um.
+
+                     Beispiel: 
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     Dadurch wird der Wert der Eigenschaftsleiste in Biz.txt geschrieben.
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -161,6 +343,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">Basierend auf dem Windows-Registrierungsschlüssel LongPathsEnabled ist das Feature LongPaths {0}.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">deaktiviert</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">aktiviert</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">Nicht festgelegt</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">MSBuild-Version {0} für {1}</target>
@@ -1330,11 +1532,11 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: Es muss ein Featurename für den Featureverfügbarkeitsschalter angegeben werden.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: Es muss ein Featurename für den featureAvailability-Schalter angegeben werden.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1432,7 +1634,7 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">MSBUILD : error MSB1066: Geben Sie mindestens einen Parameter für die Terminalprotokollierung an, wenn Sie den Schalter "-terminalLoggerParameters" verwenden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1792,11 +1994,6 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">Es wird versucht, den Buildvorgang abzubrechen...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: Die vorzuverarbeitende Datei ist ungültig. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index e8e133d96d3..cd2d91be5ab 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -128,6 +128,188 @@ Esta marca es experimental y puede que no funcione según lo previsto.
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     Escriba el valor de una o varias propiedades especificadas
+                     después de la evaluación, sin ejecutar la compilación, o si se usa
+                     la opción -targets o la opción -getTargetResult,
+                     escriba los valores después de la compilación.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     Escriba el valor de uno o varios elementos especificados y
+                     sus metadatos asociados después de la evaluación sin
+                     ejecutar la compilación, o si se usa la opción -targets
+                     o la opción -getTargetResult, escriba
+                     los valores después de la compilación.
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     Escriba el valor de salida de uno o varios destinos y
+                     los destinos especificados se ejecutarán.
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     Compruebe la disponibilidad de la característica. El resultado es una de las
+                     cadenas "Undefined", "Available", "NotAvailable" y
+                     "Preview".
+                     - Undefined: la disponibilidad de la característica no está definida
+                     (el nombre de la característica es desconocido para el comprobador de disponibilidad
+                     de características)
+                     - NotAvailable: la característica no está disponible (a diferencia de
+                     Undefined, el nombre de la característica es conocido para el comprobador
+                     de disponibilidad de características y sabe que la característica no
+                     se admite en el motor de MSBuild actual)
+                     - Available: la característica está disponible
+                     - Preview: la característica está en versión preliminar (no estable)
+                     (Forma corta: -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Habilite o deshabilite el registrador de terminal. El registrador de terminal
+                     proporciona una salida de compilación mejorada en la consola en tiempo real,
+                     organizada lógicamente por proyecto y diseñada para resaltar
+                     la información accionable. Especifique auto (o use la opción
+                     sin argumentos) para utilizar el registrador de terminal solo si la
+                     salida estándar no se redirige. No analice la salida
+                     ni confíe en que permanezca sin cambios en versiones
+                     futuras. Esta opción está disponible en MSBuild 17.8 y
+                     posteriores.
+                     (Forma corta: -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parámetros para el registrador de terminal. (Forma corta: -tlp)
+                     Los parámetros disponibles.
+                        default--Especifica el comportamiento predeterminado del registrador
+                        de terminal. Requiere uno de los siguientes valores:
+                           - `on`, `true` fuerza el uso de TerminalLogger aunque
+                            esté deshabilitado.
+                           - `off`, `false` fuerza que no se utilice TerminalLogger
+                            aunque esté habilitado.
+                           - `auto` habilita TerminalLogger cuando el terminal
+                            lo admite y la sesión no ha redirigido
+                            stdout/stderr
+                        verbosity--Reemplaza el valor -verbosity de este
+                        registrador
+                        showCommandLine--Muestra los mensajes de TaskCommandLineEvent
+
+                      Ejemplo:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     Redirija la salida de get* a un archivo.
+
+                     Ejemplo:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     Esto escribe el valor de la propiedad Bar en Biz.txt.
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +342,26 @@ Esta marca es experimental y puede que no funcione según lo previsto.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">De acuerdo con la clave del Registro de Windows LongPathsEnabled, la característica LongPaths está {0}.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">deshabilitada</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">habilitada</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">sin establecer</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">Versión de MSBuild {0} para {1}</target>
@@ -1336,11 +1538,11 @@ Esta marca es experimental y puede que no funcione según lo previsto.
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: debe proporcionar un nombre de característica para el conmutador de disponibilidad de características.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: debe proporcionar un nombre de característica para el conmutador featureAvailability.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1438,7 +1640,7 @@ Esta marca es experimental y puede que no funcione según lo previsto.
         <target state="translated">MSBUILD : error MSB1066: Especifique uno o más parámetros para el registrador de terminales si utiliza la opción -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1798,11 +2000,6 @@ Esta marca es experimental y puede que no funcione según lo previsto.
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">Intentando cancelar la compilación...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: El archivo en el que se preprocesará no es válido. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index bf502af7f50..26e94894cf4 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -128,6 +128,189 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     Notez la valeur d’une ou de plusieurs propriétés spécifiées
+                     après l’évaluation, sans exécuter la build, ou si
+                     l’option -targets ou l’option -getTargetResult est
+                     utilisé, écrivez les valeurs après la génération.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     Notez la valeur d’un ou de plusieurs éléments spécifiés et
+                     leurs métadonnées associées après l’évaluation sans
+                     l’exécution de la build, ou si l’option -targets
+                     ou l’option -getTargetResult est utilisée, écrivez
+                     les valeurs après la génération.
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     Notez la valeur de sortie d’une ou de plusieurs cibles et
+                     les cibles spécifiées seront exécutées.
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     Vérifiez la disponibilité des fonctionnalités. Le résultat est l’une des
+                     chaînes « Undefined », « Available », « NotAvailable » et
+                     « Aperçu ».
+                     - Non défini : la disponibilité de la fonctionnalité n’est pas définie
+                     (le nom de la fonctionnalité est inconnu de la disponibilité des fonctionnalités
+                     vérificateur)
+                     - NotAvailable : la fonctionnalité n’est pas disponible (contrairement à
+                     Non défini, le nom de la fonctionnalité est connu de la fonctionnalité
+                     et sait que la fonctionnalité n’est pas
+                     prise en charge par le moteur MSBuild actuel)
+                     - Disponible : la fonctionnalité est disponible
+                     - Préversion : la fonctionnalité est en préversion (non stable)
+                     (Forme abrégée : -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Activez ou désactivez l’enregistreur d’événements du terminal. Enregistreur d’événements terminal
+                     fournit une sortie de build améliorée sur la console en temps réel,
+                     organisé logiquement par projet et conçu pour mettre en évidence
+                     les informations exploitables. Spécifier automatiquement (ou utiliser l’option
+                     sans arguments) pour utiliser l’enregistreur d’événements de terminal uniquement si le
+                     la sortie standard n’est pas redirigée. N’analysez pas la sortie
+                     ou reposez-vous sur le fait qu’il reste inchangé dans les
+futures
+                     versions. Cette option est disponible dans MSBuild 17.8 et
+                     ultérieures.
+                     (Forme abrégée : -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Paramètres de l’enregistreur d’événements de terminal. (Forme abrégée : -tlp)
+                     Paramètres disponibles.
+                        default --Spécifie le comportement par défaut du terminal
+                        enregistreur. Elle nécessite l’une des valeurs suivantes :
+                           - 'on', 'true' force TerminalLogger à être utilisé même
+                            quand il serait désactivé.
+                           - 'off', 'false' force TerminalLogger à ne pas être utilisé
+                            même lorsqu’il serait activé.
+                           - « auto » active TerminalLogger lorsque le terminal
+                            la prend en charge et la session n’a pas redirigée
+                            stdout/stderr
+                        verbosity--Remplacer le paramètre -verbosity pour cet
+                        enregistreur
+                        showCommandLine--Afficher les messages TaskCommandLineEvent
+
+                      Exemple :
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     Rediriger la sortie de get* vers un fichier.
+
+                     Exemple :
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     Cette opération écrit la valeur de la barre de propriétés dans Biz.txt.
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +343,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">D’après la clé de Registre Windows LongPathsEnabled, la fonctionnalité LongPaths est {0}.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">désactivé</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">activé</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">non défini</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">Version MSBuild {0} pour {1}</target>
@@ -1329,11 +1532,11 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: vous devez fournir un nom de fonctionnalité pour le commutateur featureavailability.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: doit fournir un nom de fonctionnalité pour le commutateur featureAvailability.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1431,7 +1634,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <target state="translated">MSBUILD : error MSB1066: spécifiez un ou plusieurs paramètres pour l’enregistreur d’événements de terminal si vous utilisez le commutateur -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1791,11 +1994,6 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">Tentative d'annulation de la génération en cours...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: Le fichier à prétraiter n'est pas valide. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 9963ca29c49..bc718c445d7 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -128,6 +128,189 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     Scrivere il valore di una o più proprietà specificate
+                     dopo la valutazione, senza eseguire la compilazione o se
+                     si usa sia l'opzione -targets che l’opzione -getTargetResult
+                     scrivere i valori dopo la compilazione.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     Scrivere il valore di uno o più elementi specificati e
+                     i metadati associati dopo la valutazione senza
+                     eseguire la compilazione o in caso si usi l’opzione -targets
+                     oppure l'opzione -getTargetResult, scrivere
+                     i valori dopo la compilazione.
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     Scrivere il valore di output di una o più destinazioni
+                     per eseguire le destinazioni specificate.
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     Verificare la disponibilità delle funzionalità. Il risultato è uno delle
+                     stringhe "Non definito", "Disponibile", "Non disponibile" e
+                     "Anteprima".
+                     - Non definito: la disponibilità della funzionalità non è definita
+                     (Il nome della funzionalità non è noto al controllo
+                     della disponibilità delle funzionalità)
+                     - Non disponibile: la funzionalità non è disponibile (a differenza di
+                     Non definito, dove il nome della funzionalità è noto al controllo della disponibilità della funzionalità
+,
+                     che sa che la funzionalità non è
+                     supportata dal motore MSBuild corrente)
+                     - Disponibile: la funzionalità è disponibile
+                     - Anteprima : la funzionalità è in anteprima (non stabile)
+                     (Forma breve: -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:automatico, attivato, disattivato]
+                     Abilitare o disabilitare il logger del terminale. Logger del terminale
+                     fornisce output di compilazione avanzati in tempo reale sulla console,
+                     organizzato in maniera logica in base al progetto e progettato per evidenziare
+                     dati analitici interattivi. Specificare automatico (o usare l'opzione
+                     senza argomenti) per usare il logger del terminale solo se l’
+                     output standard non viene reindirizzato. Non analizzare l'output
+                     oppure affidarsi al fatto che non verrà modificato nelle future
+                     versioni. Questa opzione è disponibile in MSBuild 17.8 e
+                     versioni successive.
+                     Forma breve: -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parametri per il logger del terminale. Forma breve: -tlp)
+                     Parametri disponibili.
+                        impostazione predefinita- Specifica il comportamento predefinito del terminale
+                        logger. Richiede uno dei valori seguenti:
+                           - 'attivato', 'vero' forza l'uso di TerminalLogger anche
+                            se venisse disabilitato.
+                           - 'disattivato', 'falso' forza l'uso di TerminalLogger anche
+                            se venisse abilitato.
+                           - 'automatico' abilita TerminalLogger quando il terminale
+                            lo supporta e la sessione non ha reindirizzato il livello di dettaglio
+                            stdout/stderr
+                        -- Eseguire l'override dell'impostazione del livello di dettaglio per questo
+                        logger
+                        showCommandLine--Mostra i messaggi TaskCommandLineEvent
+
+                      Esempio:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     Reindirizza l'output da get* in un file.
+
+                     Esempio:
+                     -getProperty:barra -getResultOutputFile:Biz.txt
+                     Il valore della barra delle proprietà viene scritto in Biz.txt.
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +343,26 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">In base alla chiave del Registro di sistema di Windows LongPathsEnabled, la funzionalità LongPaths è {0}.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">disabilitata</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">abilitata</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">non impostata</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">Versione di MSBuild {0} per {1}</target>
@@ -1340,11 +1543,11 @@ Nota: livello di dettaglio dei logger di file
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: È necessario fornire un nome funzionalità per il passaggio a disponibilità funzionalità.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: È necessario fornire un nome funzionalità per l’opzione featureAvailability.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1442,7 +1645,7 @@ Nota: livello di dettaglio dei logger di file
         <target state="translated">MSBUILD : error MSB1066: specificare uno o più parametri per il logger del terminale se si usa l'opzione -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1802,11 +2005,6 @@ Nota: livello di dettaglio dei logger di file
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">Tentativo di annullare la compilazione in corso...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: file da pre-elaborare non valido. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index e7954c3f91c..8d9e93d6915 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -128,6 +128,189 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                    1 つ以上の指定されたプロパティの値を書き出し
+                    評価後、ビルドを実行せずに、または
+                    -targets オプションまたは -getTargetResult オプションが
+                    使用して、ビルド後に値を書き出します。
+   </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                    1 つ以上の指定された項目の値を書き出し、
+                    評価後に関連付けられたメタデータを
+                    ビルドを実行せずに、または -targets オプション
+                    または -getTargetResult オプションが使用されている場合は、書き込み
+                    ビルド後の値。
+   </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                    1 つ以上のターゲットの出力値を書き出し、
+                    指定したターゲットが実行されます。
+   </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                    機能の可用性を確認します。結果は、次のいずれかになります。
+                    文字列 "Undefined"、"Available"、"NotAvailable"、および
+                    "Preview" です。
+                    - Undefined - 機能の可用性は未定義です
+                    (機能名が機能の可用性に関して不明です
+                    チェッカー)
+                    - NotAvailable - この機能は使用できません
+                    Undefined とは異なり、機能名は機能に認識されています
+                    可用性チェッカーは、この機能が
+                    現在の MSBuild エンジンでサポートされていないことを理解しています)
+                    - Available - この機能は使用可能です
+                    - Preview - 機能はプレビュー段階です (安定していません)
+                    (短い形式: -fa)
+   </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                    ターミナル ロガーを有効または無効にします。ターミナル ロガーは
+                    本体のビルド出力がリアルタイムで強化され、
+                    プロジェクトごとに論理的に整理され、強調表示するように設計されています
+                    アクション可能な情報です。auto を指定する (またはオプションを使用する)
+                    引数を指定せずに) ターミナル ロガーを使用する場合は、
+                    標準出力はリダイレクトされません。出力を解析しないでください
+                    それ以外の場合は、将来変更されずに残っている
+                    バージョン。このオプションは、MSBuild 17.8 以降で利用可能です
+                    以降で。
+                    (短い形式: -tl)
+   </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                    ターミナル ロガーへのパラメーター。(短い形式: -tlp) 
+                    使用可能なパラメーター。
+                       default -- ターミナル 
+ の既定の動作を指定します
+                       ロガー。次のいずれかの値が必要です:
+                          - `on`、`true` は TerminalLogger を強制的に使用します
+                           無効である場合も同様です。
+                          - `off`、`false` は TerminalLogger を使用しないように強制します
+                           有効である場合も同様です。
+                          - `auto` は、次の場合にターミナルで TerminalLogger を有効にします
+                           サポートされており、セッションがリダイレクトされていない場合です
+                           stdout/stderr
+                       verbosity-- 下記の verbosity 設定をオーバーライドします
+                       logger
+                       showCommandLine -- TaskCommandLineEvent メッセージを表示します
+
+                     例: 
+                       -tlp:default=auto;verbosity=diag;shownCommandLine
+   </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                    get* からの出力をファイルにリダイレクトします。
+
+                    例: 
+                    -getProperty:Bar -getResultOutputFile:Biz.txt
+                    これにより、プロパティ Bar の値が Biz.txt に書き込まれます。
+   </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +343,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">Windows レジストリ キー LongPathsEnabled に基づいて、LongPaths 機能は{0}です。</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">無効</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">有効</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">未設定</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">MSBuild のバージョン {0} ({1})</target>
@@ -1329,11 +1532,11 @@
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: featureavailability スイッチの機能名を指定する必要があります。</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: featureAvailability スイッチの機能名を指定する必要があります。</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1431,7 +1634,7 @@
         <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters スイッチを使用する場合は、このスイッチにターミナル ロガーのパラメーターを 1 つ以上指定してください</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1791,11 +1994,6 @@
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">ビルドを取り消そうとしています...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: 前処理するファイルが無効です。{0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index f995ca421bc..822652c6a46 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -128,6 +128,189 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     빌드를 실행하지 않고 평가 후
+                     지정된 속성 중 하나 이상의 값을 작성하거나,
+                     -targets 옵션 또는 -getTargetResult 옵션을 사용하는 경우
+                     빌드 후 값을 작성합니다.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     빌드를 실행하지 않고 평가 후
+                     지정된 항목 중 하나 이상의 값 및
+                     연결된 해당 메타데이터를 작성하거나,
+                     -targets 옵션 또는 -getTargetResult 옵션을 사용하는 경우
+                     빌드 후 값을 작성합니다.
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     대상 하나 이상의 출력 값을 작성하면
+                     지정된 대상이 실행됩니다.
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     기능 가용성을 확인합니다. 결과는
+                     문자열 "Undefined", "Available", "NotAvailable" 및
+                     "Preview" 중 하나입니다.
+                     - 정의되지 않음 - 기능의 가용성이 정의되지 않았습니다
+                     (기능 가용성 검사기에서 기능 이름을 인식할 수
+                     없음).
+                     - NotAvailable - 기능을 사용할 수 없습니다(
+                     정의되지 않음과는 달리, 기능 가용성 검사가에서 기능 이름을
+                     인식할 수 있으며 기능이 현재 MSBuild 엔진에서 지원되지
+                     않는 것으로 인식하고 있음).
+                     - Available - 기능을 사용할 수 있습니다.
+                     - Preview - 기능이 미리 보기 상태로 제공됩니다(안정적이지 않음).
+                     (약식: -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     터미널 로거를 사용하거나 사용하지 않도록 설정합니다. 터미널 로거
+                     는 콘솔에서 향상된 빌드 출력을 실시간으로 제공합니다.
+                     이러한 출력은 프로젝트별로 논리적으로 구성되고 실행 가능한 정보를
+                     강조 표시하도록 설계되어 있습니다. 자동을 지정(또는 인수 없이 옵션
+                     사용)하여 터미널 로거를 사용합니다. 단, 이 경우
+                     표준 출력이 리디렉션되지 않아야 합니다. 출력을 구문 분석하지 않습니다.
+                     그렇지 않을 경우 이후 버전에서 변경되지 않은 상태로
+                     유지됩니다. 이 옵션은 MSBuild 17.8 이상 버전에서
+                     제공됩니다.
+                     (약식: -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     터미널 로거에 대한 매개 변수입니다. (약식: -tlp)
+                     사용 가능한 매개 변수입니다.
+                        default--터미널의 기본 동작을 지정합니다.
+                        로거입니다. 다음 값 중 하나가 필요합니다.
+                           - 'on', 'true'는 terminalLogger를 사용하도록 강제하며,
+                            이는 사용하지 않도록 설정된 경우에도 마찬가지입니다.
+                           - 'off', 'false'는 terminalLogger를 사용하지 않도록 강제하며,
+                            이는 사용하도록 설정된 경우에도 마찬가지입니다.
+                           - 'auto'는 터미널이
+                            지원하고 세션이 리디렉션되지 않을 때 TerminalLogger를 사용하도록 설정합니다.
+                            stdout/stderr
+                        verbosity--이
+로거에 대한 -verbosity 설정을
+                        재정의합니다.
+                        showCommandLine--TaskCommandLineEvent 메시지를 표시합니다.
+
+                      예:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     get*에서 파일로 출력을 리디렉션합니다.
+
+                     예:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     그러면 속성 Bar의 값이 Biz.txt에 기록됩니다.
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +343,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">Windows 레지스트리 키 LongPathsEnabled에 따라 LongPaths 기능이 {0}입니다.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">사용 안 함</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">사용</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">설정 안 함</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">msbuild 버전 {0}({1}용)</target>
@@ -1329,11 +1532,11 @@
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: featureavailability 스위치에 대한 기능 이름을 제공해야 합니다.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: featureAvailability 스위치에 대한 기능 이름을 제공해야 합니다.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1431,7 +1634,7 @@
         <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters 스위치를 사용하는 경우 터미널 로거에 대해 하나 이상의 매개 변수를 지정하세요.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1791,11 +1994,6 @@
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">빌드를 취소하는 중...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: 전처리할 파일이 잘못되었습니다. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 6d1956125cd..d628509728e 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -128,6 +128,188 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     Zapisz wartość co najmniej jednej określonej właściwości
+                     po zakończeniu oceny, bez wykonywania kompilacji lub jeśli
+                     któraś z opcji -targets lub -getTargetResult jest
+                     użyta, zapisz wartości po kompilacji.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     Zapisz wartość co najmniej jednego określonego elementu i
+                     ich skojarzonych metadanych po ocenie bez
+                     wykonywania kompilacji lub jeśli jest użyta któraś z opcji -targets
+                     lub -getTargetResult, zapisz
+                     wartości po kompilacji.
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     Zapisz wartość wyjściową co najmniej jednego elementu docelowego, a
+                     określone elementy docelowe zostaną wykonane.
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     Sprawdź dostępność funkcji. Wynikiem jest jeden z
+                     ciągów „Undefined”, „Available”, „NotAvailable” i
+                     „Preview”.
+                     — Undefined — dostępność funkcji jest niezdefiniowana
+                     (nazwa funkcji jest nieznana dla dostępności funkcji
+                     kontroler)
+                     — NotAvailable — funkcja jest niedostępna (w przeciwieństwie do
+                     Undefined, nazwa funkcji jest znana kontrolerowi
+                     dostępności funkcji i wie on, że funkcja nie jest
+                     obsługiwana przez bieżący aparat MSBuild)
+                     — Available — funkcja jest dostępna
+                     — Preview — funkcja jest w wersji zapoznawczej (niestabilna)
+                     (Krótka forma: -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Włącz lub wyłącz rejestrator terminali. Rejestrator terminali
+                     udostępnia ulepszone dane wyjściowe kompilacji na konsoli w czasie rzeczywistym,
+                     uporządkowane logicznie według projektu i zaprojektowane do wyróżniania
+                     informacji umożliwiających podejmowanie działań. Określ auto (lub użyj opcji
+                     bez argumentów), aby używać rejestratora terminali tylko wtedy, gdy
+                     standardowe dane wyjściowe nie są przekierowywane. Nie analizowanie danych wyjściowych
+                     lub inaczej – poleganie na nich pozostanie niezmienione w przyszłych
+                     wersjach. Ta opcja jest dostępna w wersji MSBuild 17.8 i
+                     późniejszych.
+                     (Krótka forma: -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parametry rejestratora terminali. (Krótka forma: -tlp)
+                     Dostępne parametry.
+                        default-- określa domyślne zachowanie rejestratora
+                        terminalu. Wymaga jednej z następujących wartości:
+                           — „on”, „true” wymusza użycie elementu TerminalLogger nawet
+                            kiedy zostanie on wyłączony.
+                           — „off”, „false” wymusza nieużywanie elementu TerminalLogger
+                            nawet wtedy, gdy zostanie on włączony.
+                           — „auto” włącza element TerminalLogger, gdy terminal
+                            go obsługuje, a sesja nie została przekierowana
+                            stdout/stderr
+                        verbosity-- zastąp ustawienie -verbosity dla tego
+                        rejestratora
+                        showCommandLine-- pokaż komunikaty TaskCommandLineEvent
+
+                      Przykład:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     Przekieruj dane wyjściowe z polecenia get* do pliku.
+
+                     Przykład:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     Spowoduje to zapisywanie wartości paska właściwości w pliku Biz.txt.
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +342,26 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">Na podstawie klucza rejestru systemu Windows LongPathsEnabled funkcja LongPaths jest {0}.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">wyłączono</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">włączono</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">nie ustawiono</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">Wersja programu MSBuild {0} dla {1}</target>
@@ -1340,11 +1542,11 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: Należy podać nazwę funkcji dla przełącznika dostępności funkcji.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: należy podać nazwę funkcji dla przełącznika dostępności funkcji.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1442,7 +1644,7 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
         <target state="translated">MSBUILD : error MSB1066: W przypadku korzystania z przełącznika -terminalLoggerParameters określ co najmniej jeden parametr dla rejestratora terminalu</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1802,11 +2004,6 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">Trwa próba anulowania kompilacji...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: Plik, który ma zostać wstępnie przetworzony, jest nieprawidłowy. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 4e3266b9533..46b4219c1ce 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -128,6 +128,188 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     Grava o valor de uma ou mais propriedades especificadas
+                     após a avaliação, sem executar a compilação, ou se
+                     a opção -targets ou a opção -getTargetResult for
+                     for usada, escreva os valores após a compilação.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     Escreve o valor de um ou mais itens especificados e
+                     seus metadados associados após a avaliação sem
+                     executar a compilação, ou se a opção -targets
+                     ou a opção -getTargetResult for usada, escreva
+                     os valores após a compilação.
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     Escreve o valor da saída de um ou mais destinos e
+                     os destinos especificados serão executados.
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     Verifica a disponibilidade do recurso. O resultado é uma das 
+                     cadeias de caracteres "Indefinido", "Disponível", "Não Disponível" e
+                     "Visualizar".
+                     - Indefinido - a disponibilidade do recurso é indefinida
+                     (o nome do recurso é desconhecido para o verificador de disponibilidade do recurso
+                     verificador)
+                     - NotAvailable - o recurso não está disponível (ao contrário de
+                     Indefinido, o nome do recurso é conhecido pelo verificador de disponibilidade do recurso
+                     verificador de disponibilidade e ele sabe que o recurso não
+                     tem suporte pelo mecanismo MSBuild atual)
+                     - Disponível - o recurso está disponível
+                     - Visualização - o recurso está em pré-visualização (não é estável)
+                     (Forma abreviada: -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Habilitar ou desabilitar o registrador de terminal. O agente do terminal
+                     fornece saída de compilação aprimorada no console em tempo real,
+                     organizada logicamente por projeto e projetada para destacar
+                     informações acionáveis. Especificar automaticamente (ou use a opção
+                     sem argumentos) para usar o registrador de terminal somente se a
+                     a saída padrão não for redirecionada. Não analise a saída
+                     nem confie que ela permanecerá inalterada em futuras
+                     versões. Essa opção está disponível no MSBuild 17.8 e
+                     posterior.
+                     (Forma abreviada: -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parâmetros para o registrador de terminal. (Forma abreviada: -tlp)
+                     Os parâmetros disponíveis.
+                        default--Especifica o comportamento padrão do agente de
+                        terminal. Requer um dos seguintes valores:
+                           - `on`, `true` força o TerminalLogger a ser usado mesmo
+                            quando ele estiver desabilitado.
+                           - `off`, `false` força o TerminalLogger a não ser usado
+                            mesmo quando estiver habilitado.
+                           - `auto` ativa o TerminalLogger quando o terminal
+                            der suporte e a sessão não tiver redirecionado
+                            stdout/stderr
+                        verbosidade--Substitui a configuração de -verbosidade para esse
+                        agente
+                        showCommandLine--Mostra mensagens de TaskCommandLineEvent
+
+                      Exemplo:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     Redirecionar a saída de get* para um arquivo.
+
+                     Exemplo:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     Isso grava o valor da propriedade Bar em Biz.txt.
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +342,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">Com base na chave do Registro do Windows LongPathsEnabled, o recurso LongPaths é {0}.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">desabilitado</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">habilitado</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">não definido</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">Versão do MSBuild {0} para {1}</target>
@@ -1330,11 +1532,11 @@ arquivo de resposta.
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: deve ser fornecido um nome de recurso para a opção de disponibilidade de recursos.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: É necessário fornecer um nome de recurso para a chave featureAvailability.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1432,7 +1634,7 @@ arquivo de resposta.
         <target state="translated">MSBUILD : error MSB1066: Especifique um ou mais parâmetros para o agente de terminal se estiver usando a opção -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1792,11 +1994,6 @@ arquivo de resposta.
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">Tentando cancelar a compilação...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: O arquivo a ser pré-processado é inválido. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 2c27bb72d73..647519e7158 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -128,6 +128,188 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     Запишите значение одного или нескольких указанных свойств 
+                     после оценки, не выполняя сборку, или, если 
+                     опция -targets или опция -getTargetResult 
+                     используется, запишите значения после сборки.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     Запишите значение одного или нескольких указанных элементов и 
+                     связанных с ними метаданных после оценки без 
+                     выполнения сборки или, если используется опция -targets 
+                     или опция -getTargetResult, запишите 
+                     значения после сборки. 
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     Запишите выходное значение одной или нескольких целей и 
+                     указанные цели будут выполнены. 
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     Проверьте доступность функции. Результатом является одна из 
+                     строк "Неопределено", "Доступно", "Недоступно" и 
+                     "Предварительный просмотр". 
+                     - Не определено — доступность функции не определена 
+                     (имя функции неизвестно средству проверки доступности 
+                     функции) 
+                     - NotAvailable — функция недоступна (в отличие от 
+                     Не определено, имя функции известно средству проверки 
+                     доступности функции, и ему известно, что функция не 
+                     поддерживается текущим механизмом MSBuild) 
+                     - Доступно – функция доступна 
+                     - Предварительная версия — функция находится в предварительной версии (не стабильна) 
+                     (Short form: -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:авто,вкл,выкл] 
+                     Включите или отключите регистратор терминала. Регистратор терминала 
+                     обеспечивает расширенный вывод сборки на консоль в режиме реального времени, 
+                     логически организованный по проектам и предназначенный для выделения 
+                     полезной информации. Укажите авто (или используйте опцию 
+                     без аргументов), чтобы использовать регистратор терминала только в том случае, если 
+                     стандартный вывод не перенаправляется. Не анализируйте выходные данные 
+                     и не полагайтесь на то, что они останутся неизменными в будущих 
+                     версиях. Этот параметр будет доступен в MSBuild 17.8 и 
+                     позже. 
+                     (Short form: -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Параметры для логгера терминала. (Short form: -tlp)
+                     Доступные параметры. 
+                        по умолчанию — определяет поведение логгера 
+                        терминала. Требуется одно из следующих значений: 
+                           - `on`, `true` заставляет использовать TerminalLogger даже 
+                            когда он будет отключен. 
+                           - `off`, `false` запрещает использование TerminalLogger 
+                            даже если бы он был включен. 
+                           - `auto` включает TerminalLogger, когда терминал 
+                            поддерживает это, и в сеансе нет перенаправления
+                            stdout/stderr
+                        verbosity – Переопределить параметр -verbosity для этого 
+                        терминала 
+                        showCommandLine — Показать сообщения TaskCommandLineEvent 
+
+                      Пример: 
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     Перенаправить вывод get* в файл. 
+
+                     Пример:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     При этом значение свойства Bar будет записано в Biz.txt. 
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +342,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">На основе раздела реестра Windows LongPathsEnabled функция LongPaths имеет значение {0}.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">отключено</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">включено</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">не задано</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">Версия MSBuild {0} для {1}</target>
@@ -1328,11 +1530,11 @@
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: необходимо указать имя функции для переключения доступности функции.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: необходимо указать имя функции для переключателя FeatureAvailability.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1430,7 +1632,7 @@
         <target state="translated">MSBUILD : error MSB1066: укажите один или несколько параметров для регистратора терминала при использовании переключателя -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1790,11 +1992,6 @@
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">Попытка отменить сборку...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: недопустимый файл для предварительной обработки. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 86fc2093ac5..8db8d02b47a 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -128,6 +128,188 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                     Belirtilen bir veya daha fazla özelliğin değerini
+                     değerlendirmeden sonra, derlemeyi yürütmeden yaz veya
+                     -targets ya da -getTargetResult seçeneklerinden biri
+                     kullanıldıysa, değerleri derlemeden sonra yaz.
+    </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                     Belirtilen bir veya daha fazla öğenin değerini ve
+                     değerlendirmeden sonraki ilişkili meta değerini derlemeyi
+                     yürütmeden yaz veya -targets ya da -getTargetResult
+                     seçeneklerinden biri kullanıldıysa, değerleri
+                     derlemeden sonra yaz.
+    </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                     Bir veya daha fazla hedefin çıktı değerini yazın,
+                     belirtilen hedefler yürütülür.
+    </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                     Özellik kullanılabilirliğini denetle. Sonuç "Undefined",
+                     "Available", "NotAvailable" ve "Preview" dizelerinden
+                     biridir.
+                     - Undefined - özelliğin kullanılabilirliği tanımlanmamış
+                     (özelliğin adı özellik kullanılabilirliği tarafından
+                     bilinmiyor)
+                     - NotAvailable - özellik kullanılamıyor (Undefined’dan
+                     farklı olarak, özellik kullanılabilirliği denetleyicisi özelliğin adını
+                     biliyor ancak özelliğin geçerli MSBuild altyapısı tarafından
+                     desteklenmediğini de biliyor)
+                     - Available - özellik kullanılabilir
+                     - Önizleme - özellik önizleme aşamasında (kararlı değil)
+                     (Kısa biçimi: -fa)
+    </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                     Terminal günlükçüsünü etkinleştir veya devre dışı bırak. Terminal günlükçüsü
+                     konsolda gerçek zamanlı olarak gelişmiş derleme çıktısı sağlar,
+                     projeye göre mantıksal olarak düzenler ve eyleme
+                     dönüştürülebilir bilgileri vurgular. Sadece standart çıktı yeniden yönlendirilmiyorsa
+                     terminal günlükçüsünü kullanmak için otomatik olarak ayarlayın
+                     (veya bu seçeneği bağımsız değişken olmadan kullanın). Çıktı verilerini ayrıştırmayın
+                     veya gelecek sürümlerde değişmeden kalacak şekilde
+                     kullanın. Bu seçenek MSBuild 17.8 ve sonraki sürümlerde
+                     kullanılabilir.
+                     (Kısa biçimi: -tl)
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                     Terminal günlükçüsü için parametreler. (Kısa biçimi: -tlp)
+                     Mevcut parametreler.
+                        default--Terminalin davranışını varsayılan olarak ayarlar
+                        günlükçü. Şu değerlerden birini gerektirir: 
+                           - `on`, `true` TerminalLogger’ı devre dışı olsa bile
+                            kullanılmaya zorlar.
+                           - `on`, `true` TerminalLogger’ı etkinleştirilmiş olsa bile
+                            kullanılmamaya zorlar.
+                           - 'auto' terminal desteklediğinde ve oturumda
+                            yeniden yönlendirilmiş stdout/stderr bulunmadığında
+                            TerminalLogger’ı etkinleştirir
+                        verbosity--Bu günlükçü için -verbosity ayarını
+                        geçersiz kıl
+                        showCommandLine--TaskCommandLineEvent iletilerini göster
+
+                      Örnek:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                     get* çıktısını bir dosyaya yeniden yönlendir.
+
+                     Örnek:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     Bu, Bar özelliğinin değerini Biz.txt dosyasına yazar.
+    </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +342,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">Windows kayıt defteri anahtarı LongPathsEnabled ayarına bağlı olarak LongPaths özelliği {0}.</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">devre dışı</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">etkin</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">ayarlanmadı</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">{1} için MSBuild sürüm {0}</target>
@@ -1333,11 +1535,11 @@
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: Özellik kullanılabilirlik anahtarı için bir özellik adı belirtilmesi gerekli.</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: featureAvailability anahtarı için özellik adı belirtilmelidir.</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1435,7 +1637,7 @@
         <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters anahtarı kullanılıyorsa terminal günlükçüsü için bir veya birden çok parametre belirtin</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1795,11 +1997,6 @@
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">Oluşturma iptal edilmeye çalışılıyor...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: Ön işlem uygulanacak dosya geçerli değil. {0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 78c661b0857..ad8b40cb534 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -128,6 +128,188 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                    在计算后写出一个或多个指定属性的值，
+                    但不执行生成，或者如果使用的是
+                    -targets 选项或 -getTargetResult 选项，
+                    则在生成后写出这些值。
+   </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                    在计算后写出一个或多个指定项的值及其
+                    关联的元数据，但不
+                    执行生成，或者如果使用的是 -targets 选项
+                    或 -getTargetResult 选项，则在生成后写出
+                    这些值。
+   </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                    写出一个或多个目标的输出值，
+                    并且将执行指定的目标。
+   </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                    检查功能可用性。结果是以下字符串之一:
+                    "Undefined"、"Available"、"NotAvailable" 和
+                    "Preview"。
+                    - Undefined - 未定义功能的可用性
+                    (功能可用性检查器不知道
+                    该功能名称)
+                    - NotAvailable - 功能不可用(不同于
+                    Undefined，功能可用性检查器知道
+                    该功能名称，并且还知道该功能不
+                    受当前 MSBuild 引擎支持)
+                    - Available - 功能可用
+                    - Preview - 功能处于预览状态(不稳定)
+                    (缩写: -fa)
+   </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                    启用或禁用终端记录器。终端记录器
+                    在控制台上实时提供增强的生成输出，
+                    这些输出在逻辑上按项目进行整理，旨在突出显示
+                    可操作信息。指定 auto (或使用
+                    不带参数的选项)，仅在标准输出未重定向的情况下
+                    使用终端记录器。不要分析输出，
+                    也不要依赖于它在将来的版本中保持
+                    不变。此选项在 MSBuild 17.8 和
+                    更高版本中提供。
+                    (缩写: -tl)
+   </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                    终端记录器的参数。(缩写: -tlp)
+                    可用参数。
+                       default - 指定终端
+                       记录器的默认行为。它需要以下值之一:
+                          - `on`、`true` 可强制使用 TerminalLogger，
+                           即使它已禁用也是如此。
+                          - `off`、`false` 可强制不使用 TerminalLogger，
+                           即使它已启用也是如此。
+                          - `auto` 可在终端支持 TerminalLogger
+                           且会话没有重定向的 stdout/stderr 时
+                           启用 TerminalLogger
+                       verbosity - 替代此记录器的 -verbosity
+                       设置
+                       showCommandLine - 显示 TaskCommandLineEvent 消息
+
+                     示例:
+                       -tlp:default=auto;verbosity=diag;shownCommandLine
+   </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                    将 get* 的输出重定向到文件中。
+
+                    示例:
+                    -getProperty:Bar -getResultOutputFile:Biz.txt
+                    这会将属性 Bar 的值写入 Biz.txt。
+   </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +342,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">基于 Windows 注册表项 LongPathsEnabled，LongPaths 功能为 {0}。</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">已禁用</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">已启用</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">未设置</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">适用于 {1} MSBuild 版本 {0}</target>
@@ -1329,11 +1531,11 @@
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: 必须为功能可用性开关提供功能名称。</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: 必须为 featureAvailability 开关提供功能名称。</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1431,7 +1633,7 @@
         <target state="translated">MSBUILD : error MSB1066: 为终端记录器指定一个或多个参数 (如果使用 -terminalLoggerParameters 开关)</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1791,11 +1993,6 @@
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">正在尝试取消生成...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: 要预处理的文件无效。{0}</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 29c76948500..2efffebc5f8 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -128,6 +128,189 @@
         <note>
       LOCALIZATION: "-reportFileAccesses" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_43_GetPropertySwitch">
+        <source>  -getProperty:propertyName,...
+                     Write out the value of one or more specified properties
+                     after evaluation, without executing the build, or if either
+                     the -targets option or the -getTargetResult option is
+                     used, write out the values after the build.
+    </source>
+        <target state="translated">  -getProperty:propertyName,...
+                    於評估後，寫出一或多個指定屬性的值，以及
+                    但不執行建置；如有使用
+                    -targets 選項或 -getTargetResult 選項，
+                    便於建置之後，再寫出這些值。
+   </target>
+        <note>
+      LOCALIZATION: "-getProperty", "-targets" and "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_44_GetItemSwitch">
+        <source>  -getItem:itemName,...
+                     Write out the value of one or more specified items and
+                     their associated metadata after evaluation without
+                     executing the build, or if either the -targets option
+                     or the -getTargetResult option is used, write out
+                     the values after the build.
+    </source>
+        <target state="translated">  -getItem:itemName,...
+                    於評估後，寫出一或多個指定項目的值，以及
+                    其相關的中繼資料，但不
+                    執行建置；如有使用 -targets 選項
+                    或 -getTargetResult 選項，
+                    便於建置之後，再寫出這些值。
+   </target>
+        <note>
+      LOCALIZATION: "-getItem", "targets" and "getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_45_GetTargetResultSwitch">
+        <source>  -getTargetResult:targetName,...
+                     Write out the output value of one or more targets and
+                     the specified targets will be executed.
+    </source>
+        <target state="translated">  -getTargetResult:targetName,...
+                    寫出一或多個目標的輸出值，然後
+                    執行指定的目標。
+   </target>
+        <note>
+      LOCALIZATION: "-getTargetResult" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_46_FeatureAvailabilitySwitch">
+        <source>  -featureAvailability:featureName,...
+                     Check feature availability. The result is one of the
+                     strings "Undefined", "Available", "NotAvailable" and
+                     "Preview".
+                     - Undefined - the availability of the feature is undefined
+                     (the feature name is unknown to the feature availability
+                     checker)
+                     - NotAvailable - the feature is not available (unlike
+                     Undefined, the feature name is known to the feature
+                     availability checker and it knows the feature is not
+                     supported by current MSBuild engine)
+                     - Available - the feature is available
+                     - Preview - the feature is in preview (not stable)
+                     (Short form: -fa)
+    </source>
+        <target state="translated">  -featureAvailability:featureName,...
+                    檢查功能可用性。結果會是下列其中一個字串:
+                    “Undefined”、“Available”、“NotAvailable” 和
+                    "Preview"。
+                    - Undefined - 功能的可用性未定義
+                    (功能可用性檢查程式不知道
+                    該功能名稱)
+                    - NotAvailable - 此功能無法使用 (不同於
+                    Undefined，功能可用性檢查程式知道該功能名稱，
+                    並知道功能目前的
+                    MSBuild 引擎不支援該功能)
+                    - Available - 此功能可以使用
+                    - Preview - 此功能目前為預覽狀態 (不穩定)
+                    (簡短形式: -fa)
+   </target>
+        <note>
+      LOCALIZATION: "-featureAvailability", "-fa", "Undefined", "Available" "NotAvailable" and "Preview"should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_47_TerminalLoggerSwitch">
+        <source>  -terminalLogger[:auto,on,off]
+                     Enable or disable the terminal logger. Terminal logger
+                     provides enhanced build output on the console in real time,
+                     organized logically by project, and designed to highlight
+                     actionable information. Specify auto (or use the option
+                     without arguments) to use the terminal logger only if the
+                     standard output is not redirected. Don't parse the output
+                     or otherwise rely on it remaining unchanged in future
+                     versions. This option is available in MSBuild 17.8 and
+                     later.
+                     (Short form: -tl)
+    </source>
+        <target state="translated">  -terminalLogger[:auto,on,off]
+                    啟用或停用終端機記錄器。終端機記錄器
+                    會即時在主機上，提供更進一步的組建輸出，
+                    並依照專案的邏輯編排，並會醒目提示
+                    可採取動作的資訊。指定自動 (或只使用選項，
+                    不使用引數) 只在使用標準輸出
+                    未重新導向時，才使用終端機記錄器。不剖析輸出，
+                    或以其他方式據此在
+                    未來的版本中保持不變。此選項可在 MSBuild 17.8 和
+                    更新版本中使用。
+                    (簡短形式: -tl)
+   </target>
+        <note>
+      LOCALIZATION: "-terminalLogger", "-tl", and "auto" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_48_TerminalLoggerParametersSwitch">
+        <source>  -terminalLoggerParameters: &lt;parameters&gt;
+                     Parameters to terminal logger. (Short form: -tlp)
+                     The available parameters.
+                        default--Specifies the default behavior of the terminal
+                        logger. It requires one of the following values:
+                           - `on`, `true`  forces TerminalLogger to be used even
+                            when it would be disabled.
+                           - `off`, `false` forces TerminalLogger to not be used
+                            even when it would be enabled.
+                           - `auto` enables TerminalLogger when the terminal
+                            supports it and the session doesn't have redirected
+                            stdout/stderr
+                        verbosity--Override the -verbosity setting for this
+                        logger
+                        showCommandLine--Show TaskCommandLineEvent messages
+
+                      Example:
+                        -tlp:default=auto;verbosity=diag;shownCommandLine
+    </source>
+        <target state="translated">  -terminalLoggerParameters: &lt;parameters&gt;
+                    終端機記錄器的參數。(簡短形式: -tlp)
+                    可用的參數。
+                       default -- 指定終端機記錄器的預設值。
+                       其需要下列其中一值: 
+。
+                          - 'on'、'true' 會強制使用 TerminalLogger，即使
+                           其之後可能會停用。
+                          - 'off'、'false' 會強制使用 TerminalLogger，即使
+                           其之後可能會啟用。
+                          - `auto` 會啟用 terminalLogger，但終端機必須能夠
+                           提供支援，且工作階段未經重新導向
+                           stdout/stderr
+                       verbosity -- 覆寫上記錄器的
+                       -verbosity
+                       showCommandLine -- 顯示 TaskCommandLineEvent 訊息
+
+                     範例: 
+                       -tlp:default=auto;verbosity=diag;shownCommandLine
+    </target>
+        <note>
+      LOCALIZATION: "-terminalLoggerParameters", "-tlp", "default", "on", "true", "off", "false", "auto", "verbosity", "showCommandLine" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_51_GetResultOutputFileSwitch">
+        <source>  -getResultOutputFile:file
+                     Redirect output from get* into a file.
+
+                     Example:
+                     -getProperty:Bar -getResultOutputFile:Biz.txt
+                     This writes the value of property Bar into Biz.txt.
+    </source>
+        <target state="translated">  -getResultOutputFile:file
+                    將輸出從 get* 重新導向至檔案。
+
+                    範例: 
+                    -getProperty:Bar -getResultOutputFile:Biz.txt
+                    這會將屬性列的值寫入 Biz.txt。
+   </target>
+        <note>
+      LOCALIZATION: "-getResultOutputFile", "get*" and "-getProperty" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -160,6 +343,26 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="LongPaths">
+        <source>Based on the Windows registry key LongPathsEnabled, the LongPaths feature is {0}.</source>
+        <target state="translated">根據 Windows 登錄機碼 LongPathsEnabled，LongPaths 功能為 {0}。</target>
+        <note>"Windows" is the OS, "LongPathsEnabled" should not be localized, and {0} will be "enabled"/"disabled"/"not set"</note>
+      </trans-unit>
+      <trans-unit id="LongPaths_Disabled">
+        <source>disabled</source>
+        <target state="translated">已停用</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Enabled">
+        <source>enabled</source>
+        <target state="translated">已啟用</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="LongPaths_Missing">
+        <source>not set</source>
+        <target state="translated">未設定</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
         <target state="translated">{1} 的 MSBuild 版本 {0}</target>
@@ -1329,11 +1532,11 @@
         <note />
       </trans-unit>
       <trans-unit id="MissingFeatureAvailabilityError">
-        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureavailability switch.</source>
-        <target state="translated">MSBUILD : error MSB1067: 必須為功能可用性切換提供功能名稱。</target>
+        <source>MSBUILD : error MSB1067: Must provide a feature name for the featureAvailability switch.</source>
+        <target state="translated">MSBUILD : error MSB1067: 必須提供 featureAvailability 切換的功能名稱。</target>
         <note>
-      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureavailability". The user must pass in an actual feature name
-      following the switch, as in "msbuild.exe -featureavailability:blah".
+      {StrBegin="MSBUILD : error MSB1067: "}UE: This happens if the user does something like "msbuild.exe -featureAvailability". The user must pass in an actual feature name
+      following the switch, as in "msbuild.exe -featureAvailability:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
@@ -1431,7 +1634,7 @@
         <target state="translated">MSBUILD : error MSB1066: 如果使用 -terminalLoggerParameters 參數，請為終端機記錄器指定一或多個參數</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
-      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      UE: This happens if the user does something like "msbuild.exe -terminalLoggerParameters:". The user must pass in one or more parameters
       after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
@@ -1791,11 +1994,6 @@
      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
   </note>
       </trans-unit>
-      <trans-unit id="AbortingBuild">
-        <source>Attempting to cancel the build...</source>
-        <target state="translated">正在嘗試取消建置...</target>
-        <note />
-      </trans-unit>
       <trans-unit id="InvalidPreprocessPath">
         <source>MSBUILD : error MSB1047: File to preprocess to is not valid. {0}</source>
         <target state="translated">MSBUILD : error MSB1047: 要前置處理的目地檔案無效。{0}</target>
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index 64fe4a5a594..bcae846e898 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -229,8 +229,7 @@ public TerminalLogger()
         Terminal = new Terminal();
     }
 
-    public TerminalLogger(LoggerVerbosity verbosity)
-        : this()
+    public TerminalLogger(LoggerVerbosity verbosity) : this()
     {
         Verbosity = verbosity;
     }
@@ -273,6 +272,7 @@ public void Initialize(IEventSource eventSource)
         eventSource.TargetStarted += TargetStarted;
         eventSource.TargetFinished += TargetFinished;
         eventSource.TaskStarted += TaskStarted;
+        eventSource.StatusEventRaised += StatusEventRaised;
 
         eventSource.MessageRaised += MessageRaised;
         eventSource.WarningRaised += WarningRaised;
@@ -284,6 +284,7 @@ public void Initialize(IEventSource eventSource)
         }
     }
 
+
     /// <summary>
     /// Parses out the logger parameters from the Parameters string.
     /// </summary>
@@ -398,14 +399,14 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
 
         Terminal.BeginUpdate();
         try
-        { 
+        {
             if (Verbosity > LoggerVerbosity.Quiet)
             {
                 string duration = (e.Timestamp - _buildStartTime).TotalSeconds.ToString("F1");
                 string buildResult = RenderBuildResult(e.Succeeded, _buildErrorsCount, _buildWarningsCount);
 
                 Terminal.WriteLine("");
-                if(_testRunSummaries.Any())
+                if (_testRunSummaries.Any())
                 {
                     var total = _testRunSummaries.Sum(t => t.Total);
                     var failed = _testRunSummaries.Sum(t => t.Failed);
@@ -462,6 +463,14 @@ private void BuildFinished(object sender, BuildFinishedEventArgs e)
         _testEndTime = null;
     }
 
+    private void StatusEventRaised(object sender, BuildStatusEventArgs e)
+    {
+        if (e is BuildCanceledEventArgs buildCanceledEventArgs)
+        {
+            RenderImmediateMessage(e.Message!);
+        }
+    }
+
     /// <summary>
     /// The <see cref="IEventSource.ProjectStarted"/> callback.
     /// </summary>
@@ -636,7 +645,9 @@ private void ProjectFinished(object sender, ProjectFinishedEventArgs e)
                             string urlString = url.ToString();
                             if (Uri.TryCreate(urlString, UriKind.Absolute, out Uri? uri))
                             {
-                                urlString = uri.AbsoluteUri;
+                                // url.ToString() un-escapes the URL which is needed for our case file://
+                                // but not valid for http://
+                                urlString = uri.ToString();
                             }
 
                             // If the output path is under the initial working directory, make the console output relative to that to save space.
@@ -864,7 +875,16 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
                                             : e.Timestamp > _testEndTime
                                                 ? e.Timestamp : _testEndTime;
                                 }
-                                
+
+                                break;
+                            }
+
+                        case "TLTESTOUTPUT":
+                            {
+                                if (e.Message != null && Verbosity > LoggerVerbosity.Quiet)
+                                {
+                                    RenderImmediateMessage(e.Message);
+                                }
                                 break;
                             }
                     }
@@ -903,7 +923,8 @@ private void WarningRaised(object sender, BuildWarningEventArgs e)
             && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project)
             && Verbosity > LoggerVerbosity.Quiet)
         {
-            if (!String.IsNullOrEmpty(e.Message) && IsImmediateMessage(e.Message!))
+            if ((!String.IsNullOrEmpty(e.Message) && IsImmediateMessage(e.Message!)) ||
+                IsImmediateWarning(e.Code))
             {
                 RenderImmediateMessage(FormatWarningMessage(e, Indentation));
             }
@@ -930,13 +951,16 @@ private bool IsImmediateMessage(string message) =>
         _immediateMessageKeywords.Any(imk => message.IndexOf(imk, StringComparison.OrdinalIgnoreCase) >= 0);
 #endif
 
+
+    private bool IsImmediateWarning(string code) => code == "MSB3026";
+
     /// <summary>
     /// The <see cref="IEventSource.ErrorRaised"/> callback.
     /// </summary>
     private void ErrorRaised(object sender, BuildErrorEventArgs e)
     {
         BuildEventContext? buildEventContext = e.BuildEventContext;
-        
+
         if (buildEventContext is not null
             && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project)
             && Verbosity > LoggerVerbosity.Quiet)
@@ -951,7 +975,7 @@ private void ErrorRaised(object sender, BuildErrorEventArgs e)
         }
     }
 
-#endregion
+    #endregion
 
     #region Refresher thread implementation
 
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 088d2c00179..017237c35d8 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -25,6 +25,7 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental;
+using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
@@ -246,7 +247,6 @@ string[] args
 
             int exitCode;
             if (
-                ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) &&
                 Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName) == "1" &&
                 !Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout &&
                 CanRunServerBasedOnCommandLineSwitches(
@@ -316,7 +316,7 @@ private static bool CanRunServerBasedOnCommandLineSwitches(
                     commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.NodeMode) ||
                     commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Version] ||
                     FileUtilities.IsBinaryLogFilename(projectFile) ||
-                    ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]) == false ||
+                    !ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]) ||
                     IsInteractiveBuild(commandLineSwitches))
                 {
                     canRunServer = false;
@@ -808,7 +808,7 @@ public static ExitType Execute(
                     // as if a build is happening
                     if (FileUtilities.IsBinaryLogFilename(projectFile))
                     {
-                        ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);
+                        ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount, isBuildCheckEnabled);
                     }
                     else if (outputPropertiesItemsOrTargetResults && FileUtilities.IsSolutionFilename(projectFile))
                     {
@@ -1145,8 +1145,8 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
                 return;
             }
 
-            Console.WriteLine(ResourceUtilities.GetResourceString("AbortingBuild"));
             s_buildCancellationSource.Cancel();
+            
 
             // The OS takes a lock in
             // kernel32.dll!_SetConsoleCtrlHandler, so if a task
@@ -1749,6 +1749,18 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
                     MessageImportance.Low),
             };
 
+            NativeMethodsShared.LongPathsStatus longPaths = NativeMethodsShared.IsLongPathsEnabled();
+            if (longPaths != NativeMethodsShared.LongPathsStatus.NotApplicable)
+            {
+                messages.Add(
+                    new BuildManager.DeferredBuildMessage(
+                        ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                            "LongPaths",
+                            ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                                "LongPaths_" + longPaths.ToString())),
+                        MessageImportance.Low));
+            }
+
             if (Traits.Instance.DebugEngine)
             {
                 messages.Add(
@@ -2503,6 +2515,11 @@ private static bool ProcessCommandLineSwitches(
 #endif
 
             bool useTerminalLogger = ProcessTerminalLoggerConfiguration(commandLineSwitches, out string aggregatedTerminalLoggerParameters);
+
+            // This is temporary until we can remove the need for the environment variable.
+            // DO NOT use this environment variable for any new features as it will be removed without further notice.
+            Environment.SetEnvironmentVariable("_MSBUILDTLENABLED", useTerminalLogger ? "1" : "0");
+
             DisplayVersionMessageIfNeeded(recursing, useTerminalLogger, commandLineSwitches);
 
             // Idle priority would prevent the build from proceeding as the user does normal actions.
@@ -2767,8 +2784,8 @@ private static bool ProcessCommandLineSwitches(
         private static bool IsBuildCheckEnabled(CommandLineSwitches commandLineSwitches)
         {
             // Opt-in behavior to be determined by: https://github.com/dotnet/msbuild/issues/9723
-            bool isAnalysisEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Analyze);
-            return isAnalysisEnabled;
+            bool isBuildCheckEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Check);
+            return isBuildCheckEnabled;
         }
 
         private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
@@ -3007,13 +3024,13 @@ private static string GetProjectDirectory(string[] projectSwitchParameters)
 
 
         /// <summary>
-        /// Identifies if there is rsp files near the project file 
+        /// Identifies if there is rsp files near the project file
         /// </summary>
         /// <returns>true if there autoresponse file was found</returns>
         private static bool CheckAndGatherProjectAutoResponseFile(CommandLineSwitches switchesFromAutoResponseFile, CommandLineSwitches commandLineSwitches, bool recursing, string commandLine)
         {
             bool found = false;
-           
+
             var projectDirectory = GetProjectDirectory(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Project]);
 
             if (!recursing && !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoAutoResponse])
@@ -4406,20 +4423,26 @@ private static void ReplayBinaryLog(
             string binaryLogFilePath,
             ILogger[] loggers,
             IEnumerable<DistributedLoggerRecord> distributedLoggerRecords,
-            int cpuCount)
+            int cpuCount,
+            bool isBuildCheckEnabled)
         {
+
             var replayEventSource = new BinaryLogReplayEventSource();
 
+            var eventSource = isBuildCheckEnabled ?
+                BuildCheckReplayModeConnector.GetMergedEventSource(BuildManager.DefaultBuildManager, replayEventSource) :
+                replayEventSource;
+
             foreach (var distributedLoggerRecord in distributedLoggerRecords)
             {
                 ILogger centralLogger = distributedLoggerRecord.CentralLogger;
                 if (centralLogger is INodeLogger nodeLogger)
                 {
-                    nodeLogger.Initialize(replayEventSource, cpuCount);
+                    nodeLogger.Initialize(eventSource, cpuCount);
                 }
                 else
                 {
-                    centralLogger?.Initialize(replayEventSource);
+                    centralLogger?.Initialize(eventSource);
                 }
             }
 
@@ -4427,11 +4450,11 @@ private static void ReplayBinaryLog(
             {
                 if (logger is INodeLogger nodeLogger)
                 {
-                    nodeLogger.Initialize(replayEventSource, cpuCount);
+                    nodeLogger.Initialize(eventSource, cpuCount);
                 }
                 else
                 {
-                    logger.Initialize(replayEventSource);
+                    logger.Initialize(eventSource);
                 }
             }
 
@@ -4543,51 +4566,15 @@ private static void ShowHelpMessage()
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_1_Syntax"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_2_Description"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_3_SwitchesHeader"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_9_TargetSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_10_PropertySwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_17_MaximumCPUSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_23_ToolsVersionSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_12_VerbositySwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_13_ConsoleLoggerParametersSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_14_NoConsoleLoggerSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_20_FileLoggerSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_22_FileLoggerParametersSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_18_DistributedLoggerSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_21_DistributedFileLoggerSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_11_LoggerSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_30_BinaryLoggerSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_28_WarnAsErrorSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_40_WarnNotAsErrorSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_29_WarnAsMessageSwitch"));
-#if FEATURE_XML_SCHEMA_VALIDATION
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_15_ValidateSwitch"));
-#endif
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_19_IgnoreProjectExtensionsSwitch"));
-#if FEATURE_NODE_REUSE // Do not advertise the switch when feature is off, even though we won't fail to parse it for compatibility with existing build scripts
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_24_NodeReuse"));
-#endif
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_25_PreprocessSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_38_TargetsSwitch"));
-
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_26_DetailedSummarySwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_31_RestoreSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_33_RestorePropertySwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_32_ProfilerSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_34_InteractiveSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_35_IsolateProjectsSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_InputCachesFiles"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_OutputCacheFile"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_36_GraphBuildSwitch"));
-#if FEATURE_REPORTFILEACCESSES
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_42_ReportFileAccessesSwitch"));
-#endif
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_39_LowPrioritySwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_41_QuestionSwitch"));
+            foreach (string parameterizedSwitchRsouceId in CommandLineSwitches.GetParameterizedSwitchResourceIds())
+            {
+                Console.WriteLine(AssemblyResources.GetString(parameterizedSwitchRsouceId));
+            }
+            foreach (string parameterlessSwitchRsouceId in CommandLineSwitches.GetParameterlessSwitchResourceIds())
+            {
+                Console.WriteLine(AssemblyResources.GetString(parameterlessSwitchRsouceId));
+            }
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_7_ResponseFile"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_8_NoAutoResponseSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_5_NoLogoSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_6_VersionSwitch"));
-            Console.WriteLine(AssemblyResources.GetString("HelpMessage_4_HelpSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_16_Examples"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_37_DocsLink"));
         }
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 38ae4cbb8d4..330ab7d914e 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -49,8 +49,8 @@
 
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
-          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.0" />
-          <codeBase version="6.0.0.0" href="..\Microsoft.IO.Redist.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.1" />
+          <codeBase version="6.0.0.1" href="..\Microsoft.IO.Redist.dll"/>
         </dependentAssembly>
 
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
@@ -134,8 +134,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.3" newVersion="8.0.0.3" />
-          <codeBase version="8.0.0.3" href="..\System.Text.Json.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.4" newVersion="8.0.0.4" />
+          <codeBase version="8.0.0.4" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 6fc1459176b..8372bfd8727 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -43,6 +43,10 @@
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.1" newVersion="6.0.0.1" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
@@ -90,7 +94,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.3" newVersion="8.0.0.3" />
+          <bindingRedirect oldVersion="0.0.0.0-8.0.0.4" newVersion="8.0.0.4" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 470c4c7dd7d..db9503bd9e5 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -40,10 +40,6 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
-    <!-- EnvironmentVariableReadEventArgs shouldn't be used in TaskHosts, but it means we need fewer ifdefs. -->
-    <Compile Include="..\Framework\EnvironmentVariableReadEventArgs.cs">
-      <Link>EnvironmentVariableReadEventArgs.cs</Link>
-    </Compile>
     <Compile Include="..\Framework\BuildEnvironmentState.cs">
       <Link>BuildEnvironmentState.cs</Link>
     </Compile>
@@ -66,6 +62,7 @@
       <Link>IExtendedBuildEventArgs.cs</Link>
     </Compile>
     <Compile Include="..\Framework\AssemblyUtilities.cs" />
+    <Compile Include="..\Framework\NullableAttributes.cs" />
     <Compile Include="..\Framework\ResponseFileUsedEventArgs.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CollectionHelpers.cs" />
diff --git a/src/Package/GetBinPaths.Arm64.targets b/src/Package/GetBinPaths.Arm64.targets
index 59e61789962..21a6684a86f 100644
--- a/src/Package/GetBinPaths.Arm64.targets
+++ b/src/Package/GetBinPaths.Arm64.targets
@@ -14,11 +14,6 @@
                       Private="false"
                       ReferenceOutputAssembly="false"
                       OutputItemType="FrameworkResolvedProjectReferencePath" />
-
-    <Arm64ProjectReference Include="$(MSBuildThisFileDirectory)\..\MSBuildTaskHost\MSBuildTaskHost.csproj"
-                      SetPlatform="Platform=arm64"
-                      OutputItemType="MSBuildTaskHostArm64ResolvedProjectReferencePath"
-                      GlobalPropertiesToRemove="TargetFramework" />
   </ItemGroup>
 
   <Target Name="SetBinPathsArm64" DependsOnTargets="ResolveProjectReferences">
@@ -34,8 +29,6 @@
     <PropertyGroup>
       <FrameworkBinPath>@(FrameworkResolvedProjectReferencePath->'%(RootDir)%(Directory)')</FrameworkBinPath>
       <Arm64BinPath>@(MSBuildArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</Arm64BinPath>
-      <MSBuildTaskHostArm64BinPath>@(MSBuildTaskHostArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostArm64BinPath>
-
     </PropertyGroup>
   </Target>
 
diff --git a/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj b/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
index 6b9d4cebbf8..2886ce40bc8 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
+++ b/src/Package/MSBuild.VSSetup.Arm64/MSBuild.VSSetup.Arm64.csproj
@@ -29,7 +29,6 @@
       <SwrProperty Include="Version=$(VsixVersion)" />
       <SwrProperty Include="FrameworkBinPath=$(FrameworkBinPath)" />
       <SwrProperty Include="Arm64BinPath=$(Arm64BinPath)" />
-      <SwrProperty Include="TaskHostArm64BinPath=$(MSBuildTaskHostArm64BinPath)" />
     </ItemGroup>
   </Target>
 
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index 9a6ef830231..41ccc2d7ed0 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -54,76 +54,63 @@ folder InstallDir:\MSBuild\Current\Bin\arm64\cs
   file source=$(Arm64BinPath)cs\MSBuild.resources.dll
   file source=$(Arm64BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)cs\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\de
   file source=$(Arm64BinPath)de\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)de\MSBuild.resources.dll
   file source=$(Arm64BinPath)de\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)de\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)de\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\es
   file source=$(Arm64BinPath)es\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)es\MSBuild.resources.dll
   file source=$(Arm64BinPath)es\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)es\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)es\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\fr
   file source=$(Arm64BinPath)fr\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)fr\MSBuild.resources.dll
   file source=$(Arm64BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)fr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\it
   file source=$(Arm64BinPath)it\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)it\MSBuild.resources.dll
   file source=$(Arm64BinPath)it\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)it\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)it\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ja
   file source=$(Arm64BinPath)ja\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)ja\MSBuild.resources.dll
   file source=$(Arm64BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)ja\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ko
   file source=$(Arm64BinPath)ko\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)ko\MSBuild.resources.dll
   file source=$(Arm64BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)ko\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pl
   file source=$(Arm64BinPath)pl\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)pl\MSBuild.resources.dll
   file source=$(Arm64BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)pl\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pt-BR
   file source=$(Arm64BinPath)pt-BR\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll
   file source=$(Arm64BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)pt-BR\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ru
   file source=$(Arm64BinPath)ru\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)ru\MSBuild.resources.dll
   file source=$(Arm64BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)ru\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\tr
   file source=$(Arm64BinPath)tr\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)tr\MSBuild.resources.dll
   file source=$(Arm64BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)tr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hans
   file source=$(Arm64BinPath)zh-Hans\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll
   file source=$(Arm64BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)zh-Hans\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hant
   file source=$(Arm64BinPath)zh-Hant\Microsoft.Build.resources.dll
   file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll
   file source=$(Arm64BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll
   file source=$(Arm64BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll
-  file source=$(TaskHostArm64BinPath)zh-Hant\MSBuildTaskHost.resources.dll
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 9bbd30e09c8..269be983424 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -4,13 +4,12 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
 using System.Threading;
 using Microsoft.Build.Framework;
 
-#nullable disable
-
 #if BUILDINGAPPXTASKS
 namespace Microsoft.Build.AppxPackage.Shared
 #else
@@ -24,7 +23,7 @@ internal static class ErrorUtilities
     {
         private static readonly bool s_enableMSBuildDebugTracing = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDENABLEDEBUGTRACING"));
 
-        public static void DebugTraceMessage(string category, string formatstring, params object[] parameters)
+        public static void DebugTraceMessage(string category, string formatstring, params object[]? parameters)
         {
             if (s_enableMSBuildDebugTracing)
             {
@@ -41,7 +40,7 @@ public static void DebugTraceMessage(string category, string formatstring, param
 
 #if !BUILDINGAPPXTASKS
 
-        internal static void VerifyThrowInternalError(bool condition, string message, params object[] args)
+        internal static void VerifyThrowInternalError([DoesNotReturnIf(false)] bool condition, string message, params object?[]? args)
         {
             if (!condition)
             {
@@ -53,7 +52,8 @@ internal static void VerifyThrowInternalError(bool condition, string message, pa
         /// Throws InternalErrorException.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
-        internal static void ThrowInternalError(string message, params object[] args)
+        [DoesNotReturn]
+        internal static void ThrowInternalError(string message, params object?[]? args)
         {
             throw new InternalErrorException(ResourceUtilities.FormatString(message, args));
         }
@@ -62,7 +62,8 @@ internal static void ThrowInternalError(string message, params object[] args)
         /// Throws InternalErrorException.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
-        internal static void ThrowInternalError(string message, Exception innerException, params object[] args)
+        [DoesNotReturn]
+        internal static void ThrowInternalError(string message, Exception? innerException, params object?[]? args)
         {
             throw new InternalErrorException(ResourceUtilities.FormatString(message, args), innerException);
         }
@@ -72,6 +73,7 @@ internal static void ThrowInternalError(string message, Exception innerException
         /// Indicates the code path followed should not have been possible.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
+        [DoesNotReturn]
         internal static void ThrowInternalErrorUnreachable()
         {
             throw new InternalErrorException("Unreachable?");
@@ -82,7 +84,7 @@ internal static void ThrowInternalErrorUnreachable()
         /// Indicates the code path followed should not have been possible.
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
         /// </summary>
-        internal static void VerifyThrowInternalErrorUnreachable(bool condition)
+        internal static void VerifyThrowInternalErrorUnreachable([DoesNotReturnIf(false)] bool condition)
         {
             if (!condition)
             {
@@ -101,7 +103,7 @@ internal static void ThrowIfTypeDoesNotImplementToString(object param)
             // Check it has a real implementation of ToString()
             if (String.Equals(param.GetType().ToString(), param.ToString(), StringComparison.Ordinal))
             {
-                ThrowInternalError("This type does not implement ToString() properly {0}", param.GetType().FullName);
+                ThrowInternalError("This type does not implement ToString() properly {0}", param.GetType().FullName!);
             }
 #endif
         }
@@ -113,9 +115,9 @@ internal static void ThrowIfTypeDoesNotImplementToString(object param)
         /// </summary>
         /// <param name="parameter">The value of the argument.</param>
         /// <param name="parameterName">Parameter that should not be null</param>
-        internal static void VerifyThrowInternalNull(object parameter, string parameterName)
+        internal static void VerifyThrowInternalNull([NotNull] object? parameter, string parameterName)
         {
-            if (parameter == null)
+            if (parameter is null)
             {
                 ThrowInternalError("{0} unexpectedly null", parameterName);
             }
@@ -144,7 +146,7 @@ internal static void VerifyThrowInternalLockHeld(object locker)
         /// </summary>
         /// <param name="parameterValue">The value of the argument.</param>
         /// <param name="parameterName">Parameter that should not be null or zero length</param>
-        internal static void VerifyThrowInternalLength(string parameterValue, string parameterName)
+        internal static void VerifyThrowInternalLength([NotNull] string? parameterValue, string parameterName)
         {
             VerifyThrowInternalNull(parameterValue, parameterName);
 
@@ -154,7 +156,7 @@ internal static void VerifyThrowInternalLength(string parameterValue, string par
             }
         }
 
-        public static void VerifyThrowInternalLength<T>(T[] parameterValue, string parameterName)
+        public static void VerifyThrowInternalLength<T>([NotNull] T[]? parameterValue, string parameterName)
         {
             VerifyThrowInternalNull(parameterValue, parameterName);
 
@@ -185,7 +187,7 @@ internal static void VerifyThrowInternalRooted(string value)
         /// code somewhere. This should not be used to throw errors based on bad
         /// user input or anything that the user did wrong.
         /// </summary>
-        internal static void VerifyThrow(bool condition, string unformattedMessage)
+        internal static void VerifyThrow([DoesNotReturnIf(false)] bool condition, string unformattedMessage)
         {
             if (!condition)
             {
@@ -196,7 +198,7 @@ internal static void VerifyThrow(bool condition, string unformattedMessage)
         /// <summary>
         /// Overload for one string format argument.
         /// </summary>
-        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0)
+        internal static void VerifyThrow([DoesNotReturnIf(false)] bool condition, string unformattedMessage, object arg0)
         {
             if (!condition)
             {
@@ -207,7 +209,7 @@ internal static void VerifyThrow(bool condition, string unformattedMessage, obje
         /// <summary>
         /// Overload for two string format arguments.
         /// </summary>
-        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1)
+        internal static void VerifyThrow([DoesNotReturnIf(false)] bool condition, string unformattedMessage, object arg0, object arg1)
         {
             if (!condition)
             {
@@ -218,7 +220,7 @@ internal static void VerifyThrow(bool condition, string unformattedMessage, obje
         /// <summary>
         /// Overload for three string format arguments.
         /// </summary>
-        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2)
+        internal static void VerifyThrow([DoesNotReturnIf(false)] bool condition, string unformattedMessage, object arg0, object arg1, object arg2)
         {
             if (!condition)
             {
@@ -229,7 +231,7 @@ internal static void VerifyThrow(bool condition, string unformattedMessage, obje
         /// <summary>
         /// Overload for four string format arguments.
         /// </summary>
-        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3)
+        internal static void VerifyThrow([DoesNotReturnIf(false)] bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3)
         {
             if (!condition)
             {
@@ -242,7 +244,8 @@ internal static void VerifyThrow(bool condition, string unformattedMessage, obje
         /// </summary>
         /// <param name="resourceName">Resource to use in the exception</param>
         /// <param name="args">Formatting args.</param>
-        internal static void ThrowInvalidOperation(string resourceName, params object[] args)
+        [DoesNotReturn]
+        internal static void ThrowInvalidOperation(string resourceName, params object?[]? args)
         {
             throw new InvalidOperationException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, args));
         }
@@ -250,7 +253,7 @@ internal static void ThrowInvalidOperation(string resourceName, params object[]
         /// <summary>
         /// Throws an InvalidOperationException if the given condition is false.
         /// </summary>
-        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName)
+        internal static void VerifyThrowInvalidOperation([DoesNotReturnIf(false)] bool condition, string resourceName)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
             if (!condition)
@@ -262,7 +265,7 @@ internal static void VerifyThrowInvalidOperation(bool condition, string resource
         /// <summary>
         /// Overload for one string format argument.
         /// </summary>
-        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0)
+        internal static void VerifyThrowInvalidOperation([DoesNotReturnIf(false)] bool condition, string resourceName, object arg0)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
             // PERF NOTE: check the condition here instead of pushing it into
@@ -277,7 +280,7 @@ internal static void VerifyThrowInvalidOperation(bool condition, string resource
         /// <summary>
         /// Overload for two string format arguments.
         /// </summary>
-        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1)
+        internal static void VerifyThrowInvalidOperation([DoesNotReturnIf(false)] bool condition, string resourceName, object arg0, object arg1)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
             // PERF NOTE: check the condition here instead of pushing it into
@@ -292,7 +295,7 @@ internal static void VerifyThrowInvalidOperation(bool condition, string resource
         /// <summary>
         /// Overload for three string format arguments.
         /// </summary>
-        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2)
+        internal static void VerifyThrowInvalidOperation([DoesNotReturnIf(false)] bool condition, string resourceName, object arg0, object arg1, object arg2)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
             // PERF NOTE: check the condition here instead of pushing it into
@@ -307,7 +310,7 @@ internal static void VerifyThrowInvalidOperation(bool condition, string resource
         /// <summary>
         /// Overload for four string format arguments.
         /// </summary>
-        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3)
+        internal static void VerifyThrowInvalidOperation([DoesNotReturnIf(false)] bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
 
@@ -327,7 +330,8 @@ internal static void VerifyThrowInvalidOperation(bool condition, string resource
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
         /// </summary>
-        internal static void ThrowArgument(string resourceName, params object[] args)
+        [DoesNotReturn]
+        internal static void ThrowArgument(string resourceName, params object?[]? args)
         {
             ThrowArgument(null, resourceName, args);
         }
@@ -345,7 +349,8 @@ internal static void ThrowArgument(string resourceName, params object[] args)
         /// <param name="innerException">Can be null.</param>
         /// <param name="resourceName"></param>
         /// <param name="args"></param>
-        internal static void ThrowArgument(Exception innerException, string resourceName, params object[] args)
+        [DoesNotReturn]
+        internal static void ThrowArgument(Exception? innerException, string resourceName, params object?[]? args)
         {
             throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, args), innerException);
         }
@@ -353,7 +358,7 @@ internal static void ThrowArgument(Exception innerException, string resourceName
         /// <summary>
         /// Throws an ArgumentException if the given condition is false.
         /// </summary>
-        internal static void VerifyThrowArgument(bool condition, string resourceName)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, string resourceName)
         {
             VerifyThrowArgument(condition, null, resourceName);
         }
@@ -361,7 +366,7 @@ internal static void VerifyThrowArgument(bool condition, string resourceName)
         /// <summary>
         /// Overload for one string format argument.
         /// </summary>
-        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, string resourceName, object arg0)
         {
             VerifyThrowArgument(condition, null, resourceName, arg0);
         }
@@ -369,7 +374,7 @@ internal static void VerifyThrowArgument(bool condition, string resourceName, ob
         /// <summary>
         /// Overload for two string format arguments.
         /// </summary>
-        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, string resourceName, object arg0, object arg1)
         {
             VerifyThrowArgument(condition, null, resourceName, arg0, arg1);
         }
@@ -377,7 +382,7 @@ internal static void VerifyThrowArgument(bool condition, string resourceName, ob
         /// <summary>
         /// Overload for three string format arguments.
         /// </summary>
-        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, string resourceName, object arg0, object arg1, object arg2)
         {
             VerifyThrowArgument(condition, null, resourceName, arg0, arg1, arg2);
         }
@@ -385,7 +390,7 @@ internal static void VerifyThrowArgument(bool condition, string resourceName, ob
         /// <summary>
         /// Overload for four string format arguments.
         /// </summary>
-        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3)
         {
             VerifyThrowArgument(condition, null, resourceName, arg0, arg1, arg2, arg3);
         }
@@ -397,7 +402,7 @@ internal static void VerifyThrowArgument(bool condition, string resourceName, ob
         /// <param name="condition"></param>
         /// <param name="innerException">Can be null.</param>
         /// <param name="resourceName"></param>
-        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, Exception? innerException, string resourceName)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
             if (!condition)
@@ -409,7 +414,7 @@ internal static void VerifyThrowArgument(bool condition, Exception innerExceptio
         /// <summary>
         /// Overload for one string format argument.
         /// </summary>
-        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, Exception? innerException, string resourceName, object arg0)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
 
@@ -422,7 +427,7 @@ internal static void VerifyThrowArgument(bool condition, Exception innerExceptio
         /// <summary>
         /// Overload for two string format arguments.
         /// </summary>
-        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, Exception? innerException, string resourceName, object arg0, object arg1)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
 
@@ -435,7 +440,7 @@ internal static void VerifyThrowArgument(bool condition, Exception innerExceptio
         /// <summary>
         /// Overload for three string format arguments.
         /// </summary>
-        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, Exception? innerException, string resourceName, object arg0, object arg1, object arg2)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
 
@@ -448,7 +453,7 @@ internal static void VerifyThrowArgument(bool condition, Exception innerExceptio
         /// <summary>
         /// Overload for four string format arguments.
         /// </summary>
-        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3)
+        internal static void VerifyThrowArgument([DoesNotReturnIf(false)] bool condition, Exception? innerException, string resourceName, object arg0, object arg1, object arg2, object arg3)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
 
@@ -461,6 +466,7 @@ internal static void VerifyThrowArgument(bool condition, Exception innerExceptio
         /// <summary>
         /// Throws an argument out of range exception.
         /// </summary>
+        [DoesNotReturn]
         internal static void ThrowArgumentOutOfRange(string parameterName)
         {
             throw new ArgumentOutOfRangeException(parameterName);
@@ -470,7 +476,7 @@ internal static void ThrowArgumentOutOfRange(string parameterName)
         /// Throws an ArgumentOutOfRangeException using the given parameter name
         /// if the condition is false.
         /// </summary>
-        internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName)
+        internal static void VerifyThrowArgumentOutOfRange([DoesNotReturnIf(false)] bool condition, string parameterName)
         {
             if (!condition)
             {
@@ -482,7 +488,7 @@ internal static void VerifyThrowArgumentOutOfRange(bool condition, string parame
         /// Throws an ArgumentNullException if the given string parameter is null
         /// and ArgumentException if it has zero length.
         /// </summary>
-        internal static void VerifyThrowArgumentLength(string parameter, string parameterName)
+        internal static void VerifyThrowArgumentLength([NotNull] string? parameter, string parameterName)
         {
             VerifyThrowArgumentNull(parameter, parameterName);
 
@@ -497,7 +503,7 @@ internal static void VerifyThrowArgumentLength(string parameter, string paramete
         /// Throws an ArgumentNullException if the given collection is null
         /// and ArgumentException if it has zero length.
         /// </summary>
-        internal static void VerifyThrowArgumentLength<T>(IReadOnlyCollection<T> parameter, string parameterName)
+        internal static void VerifyThrowArgumentLength<T>([NotNull] IReadOnlyCollection<T> parameter, string parameterName)
         {
             VerifyThrowArgumentNull(parameter, parameterName);
 
@@ -510,7 +516,7 @@ internal static void VerifyThrowArgumentLength<T>(IReadOnlyCollection<T> paramet
         /// <summary>
         /// Throws an ArgumentException if the given collection is not null but of zero length.
         /// </summary>
-        internal static void VerifyThrowArgumentLengthIfNotNull<T>(IReadOnlyCollection<T> parameter, string parameterName)
+        internal static void VerifyThrowArgumentLengthIfNotNull<T>([MaybeNull] IReadOnlyCollection<T>? parameter, string parameterName)
         {
             if (parameter?.Count == 0)
             {
@@ -518,6 +524,8 @@ internal static void VerifyThrowArgumentLengthIfNotNull<T>(IReadOnlyCollection<T
             }
         }
 #endif
+
+        [DoesNotReturn]
         private static void ThrowArgumentLength(string parameterName)
         {
             throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
@@ -527,7 +535,7 @@ private static void ThrowArgumentLength(string parameterName)
         /// Throws an ArgumentNullException if the given string parameter is null
         /// and ArgumentException if it has zero length.
         /// </summary>
-        internal static void VerifyThrowArgumentInvalidPath(string parameter, string parameterName)
+        internal static void VerifyThrowArgumentInvalidPath([NotNull] string parameter, string parameterName)
         {
             VerifyThrowArgumentNull(parameter, parameterName);
 
@@ -541,7 +549,7 @@ internal static void VerifyThrowArgumentInvalidPath(string parameter, string par
         /// Throws an ArgumentException if the string has zero length, unless it is
         /// null, in which case no exception is thrown.
         /// </summary>
-        internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName)
+        internal static void VerifyThrowArgumentLengthIfNotNull(string? parameter, string parameterName)
         {
             if (parameter?.Length == 0)
             {
@@ -552,7 +560,7 @@ internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string
         /// <summary>
         /// Throws an ArgumentNullException if the given parameter is null.
         /// </summary>
-        internal static void VerifyThrowArgumentNull(object parameter, string parameterName)
+        internal static void VerifyThrowArgumentNull([NotNull] object? parameter, string parameterName)
         {
             VerifyThrowArgumentNull(parameter, parameterName, "Shared.ParameterCannotBeNull");
         }
@@ -560,36 +568,23 @@ internal static void VerifyThrowArgumentNull(object parameter, string parameterN
         /// <summary>
         /// Throws an ArgumentNullException if the given parameter is null.
         /// </summary>
-        internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName)
+        internal static void VerifyThrowArgumentNull([NotNull] object? parameter, string parameterName, string resourceName)
         {
             ResourceUtilities.VerifyResourceStringExists(resourceName);
-            if (parameter == null)
+            if (parameter is null)
             {
                 ThrowArgumentNull(parameterName, resourceName);
             }
         }
 
-        internal static void ThrowArgumentNull(string parameterName, string resourceName)
+        [DoesNotReturn]
+        internal static void ThrowArgumentNull(string? parameterName, string resourceName)
         {
             // Most ArgumentNullException overloads append its own rather clunky multi-line message. So use the one overload that doesn't.
-            throw new ArgumentNullException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, parameterName), (Exception)null);
-        }
-
-        /// <summary>
-        /// Verifies the given arrays are not null and have the same length
-        /// </summary>
-        internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name)
-        {
-            VerifyThrowArgumentNull(parameter1, parameter1Name);
-            VerifyThrowArgumentNull(parameter2, parameter2Name);
-
-            if (parameter1.Length != parameter2.Length)
-            {
-                ThrowArgument("Shared.ParametersMustHaveTheSameLength", parameter1Name, parameter2Name);
-            }
+            throw new ArgumentNullException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(resourceName, parameterName), (Exception?)null);
         }
 
-        internal static void VerifyThrowObjectDisposed(bool condition, string objectName)
+        internal static void VerifyThrowObjectDisposed([DoesNotReturnIf(false)] bool condition, string objectName)
         {
             if (!condition)
             {
@@ -597,6 +592,7 @@ internal static void VerifyThrowObjectDisposed(bool condition, string objectName
             }
         }
 
+        [DoesNotReturn]
         internal static void ThrowObjectDisposed(string objectName)
         {
             throw new ObjectDisposedException(objectName);
@@ -610,7 +606,7 @@ internal static void ThrowObjectDisposed(string objectName)
         /// <exception cref="ArgumentException">If there is insufficient capacity to copy the collection contents into <paramref name="array"/>
         /// when starting at <paramref name="arrayIndex"/>.</exception>
         internal static void VerifyCollectionCopyToArguments<T>(
-            T[] array,
+            [NotNull] T[]? array,
             string arrayParameterName,
             int arrayIndex,
             string arrayIndexParameterName,
diff --git a/src/Shared/IElementLocation.cs b/src/Shared/IElementLocation.cs
index 6353e3d17fb..b85a483a2e5 100644
--- a/src/Shared/IElementLocation.cs
+++ b/src/Shared/IElementLocation.cs
@@ -7,15 +7,20 @@
 
 namespace Microsoft.Build.Shared
 {
+    internal interface IElementLocation : IMSBuildElementLocation, ITranslatable { }
+
     /// <summary>
     /// Represents the location information for error reporting purposes.  This is normally used to
     /// associate a run-time error with the original XML.
     /// This is not used for arbitrary errors from tasks, which store location in a BuildXXXXEventArgs.
     /// All implementations should be IMMUTABLE.
-    /// This is not public because the current implementation only provides correct data for unedited projects.
-    /// DO NOT make it public without considering a solution to this problem.
+    /// Any editing of the project XML through the MSBuild API's will invalidate locations in that XML until the XML is reloaded.
     /// </summary>
-    internal interface IElementLocation : ITranslatable
+    /// <remarks>
+    /// This is currently internal - but it is prepared to be made public once it will be needed by other public BuildCheck OM
+    /// (e.g. by property read/write OM)
+    /// </remarks>
+    public interface IMSBuildElementLocation
     {
         /// <summary>
         /// The file from which this particular element originated.  It may
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 3770b80c09d..bfb896a685b 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -11,7 +11,6 @@
 
 #if !TASKHOST
 using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 #endif
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
@@ -215,7 +214,7 @@ internal enum LoggingEventType : int
         /// Event is a <see cref="GeneratedFileUsedEventArgs"/>
         /// </summary>
         GeneratedFileUsedEvent = 34,
-        
+
         /// <summary>
         /// Event is <see cref="BuildCheckResultMessage"/>
         /// </summary>
@@ -240,6 +239,11 @@ internal enum LoggingEventType : int
         /// Event is <see cref="BuildCheckAcquisitionEventArgs"/>
         /// </summary>
         BuildCheckAcquisitionEvent = 39,
+
+        /// <summary>
+        /// Event is <see cref="BuildSubmissionStartedEventArgs"/>
+        /// </summary>
+        BuildSubmissionStartedEvent = 40,
     }
     #endregion
 
@@ -435,7 +439,6 @@ internal void WriteToStream(ITranslator translator)
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs
                     or ProjectEvaluationFinishedEventArgs
-                    or EnvironmentVariableReadEventArgs
                     or ResponseFileUsedEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
@@ -623,8 +626,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
-                LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
-                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),               
+                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),
 
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.AssemblyLoadEvent => new AssemblyLoadBuildEventArgs(),
@@ -652,6 +654,8 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.BuildCheckErrorEvent => new BuildCheckResultError(),
                 LoggingEventType.BuildCheckAcquisitionEvent => new BuildCheckAcquisitionEventArgs(),
                 LoggingEventType.BuildCheckTracingEvent => new BuildCheckTracingEventArgs(),
+                LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
+                LoggingEventType.BuildSubmissionStartedEvent => new BuildSubmissionStartedEventArgs(),
 #endif
                 _ => throw new InternalErrorException("Should not get to the default of GetBuildEventArgFromId ID: " + _eventType)
             };
@@ -787,6 +791,14 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildCheckTracingEvent;
             }
+            else if (eventType == typeof(EnvironmentVariableReadEventArgs))
+            {
+                return LoggingEventType.EnvironmentVariableReadEvent;
+            }
+            else if (eventType == typeof(BuildSubmissionStartedEventArgs))
+            {
+                return LoggingEventType.BuildSubmissionStartedEvent;
+            }
 #endif
             else if (eventType == typeof(TargetStartedEventArgs))
             {
@@ -820,10 +832,6 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildErrorEvent;
             }
-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))
-            {
-                return LoggingEventType.EnvironmentVariableReadEvent;
-            }
             else if (eventType == typeof(ResponseFileUsedEventArgs))
             {
                 return LoggingEventType.ResponseFileUsedEvent;
@@ -879,36 +887,12 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.BuildWarningEvent:
                     WriteBuildWarningEventToStream((BuildWarningEventArgs)buildEvent, translator);
                     break;
-                case LoggingEventType.EnvironmentVariableReadEvent:
-                    WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);
-                    break;
                 default:
                     ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
                     break;
             }
         }
 
-        /// <summary>
-        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being
-        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.
-        /// </summary>
-        private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)
-        {
-            string name = environmentVariableReadEventArgs.EnvironmentVariableName;
-            MessageImportance importance = environmentVariableReadEventArgs.Importance;
-
-            translator.Translate(ref name);
-            translator.TranslateEnum(ref importance, (int)importance);
-
-#if !CLR2COMPATIBILITY
-            DateTime timestamp = environmentVariableReadEventArgs.RawTimestamp;
-            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
-
-            translator.Translate(ref timestamp);
-            translator.Translate(ref context);
-#endif
-        }
-
         #region Writes to Stream
 
         /// <summary>
@@ -1241,35 +1225,10 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
                 LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.ResponseFileUsedEvent => ReadResponseFileUsedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),
                 _ => null,
             };
         }
 
-        /// <summary>
-        /// Read and reconstruct an EnvironmentVariableReadEventArgs from the stream. This message should never be called from a TaskHost, so although the context translation does not work, that's ok.
-        /// </summary>
-        private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
-        {
-            string environmentVariableName = null;
-            MessageImportance importance = default;
-
-            translator.Translate(ref environmentVariableName);
-            translator.TranslateEnum(ref importance, (int)importance);
-
-            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message, helpKeyword, senderName, importance);
-
-#if !CLR2COMPATIBILITY
-            DateTime timestamp = default;
-            BuildEventContext context = null;
-            translator.Translate(ref timestamp);
-            translator.Translate(ref context);
-            args.RawTimestamp = timestamp;
-            args.BuildEventContext = context;
-#endif
-            return args;
-        }
-
         /// <summary>
         /// Read and reconstruct a BuildWarningEventArgs from the stream
         /// </summary>
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index 9bde8a4db14..e2ebdff4f85 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -56,14 +56,11 @@ public MSBuildLoadContext(string assemblyPath)
                 return null;
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            // respect plugin.dll.json with the AssemblyDependencyResolver
+            string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
+            if (assemblyPath != null)
             {
-                // respect plugin.dll.json with the AssemblyDependencyResolver
-                string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
-                if (assemblyPath != null)
-                {
-                    return LoadFromAssemblyPath(assemblyPath);
-                }
+                return LoadFromAssemblyPath(assemblyPath);
             }
 
             // Fall back to the older MSBuild-on-Core behavior to continue to support
@@ -113,13 +110,10 @@ public MSBuildLoadContext(string assemblyPath)
 
         protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
+            if (libraryPath != null)
             {
-                string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
-                if (libraryPath != null)
-                {
-                    return LoadUnmanagedDllFromPath(libraryPath);
-                }
+                return LoadUnmanagedDllFromPath(libraryPath);
             }
 
             return base.LoadUnmanagedDll(unmanagedDllName);
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 4595adaba62..187a7a43e4b 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -238,24 +238,10 @@ public void Translate(ITranslator translator)
                     TranslatePrimitiveTypeArray(translator);
                     break;
                 case TaskParameterType.ValueType:
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                    {
                         TranslateValueType(translator);
-                    }
-                    else
-                    {
-                        translator.TranslateDotNet(ref _wrappedParameter);
-                    }
                     break;
                 case TaskParameterType.ValueTypeArray:
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                    {
                         TranslateValueTypeArray(translator);
-                    }
-                    else
-                    {
-                        translator.TranslateDotNet(ref _wrappedParameter);
-                    }
                     break;
                 case TaskParameterType.ITaskItem:
                     TranslateITaskItem(translator);
diff --git a/src/Shared/UnitTests/ErrorUtilities_Tests.cs b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
index c3ac1d5a7be..3fc2ee07aff 100644
--- a/src/Shared/UnitTests/ErrorUtilities_Tests.cs
+++ b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
@@ -70,38 +70,5 @@ public void VerifyThrow4True()
             // This shouldn't throw.
             ErrorUtilities.VerifyThrow(true, "{0}{1}{2}{3}", "a", "b", "c", "d");
         }
-
-        [Fact]
-        public void VerifyThrowArgumentArraysSameLength1()
-        {
-            Assert.Throws<ArgumentNullException>(() =>
-            {
-                ErrorUtilities.VerifyThrowArgumentArraysSameLength(null, new string[1], string.Empty, string.Empty);
-            });
-        }
-
-        [Fact]
-        public void VerifyThrowArgumentArraysSameLength2()
-        {
-            Assert.Throws<ArgumentNullException>(() =>
-            {
-                ErrorUtilities.VerifyThrowArgumentArraysSameLength(new string[1], null, string.Empty, string.Empty);
-            });
-        }
-
-        [Fact]
-        public void VerifyThrowArgumentArraysSameLength3()
-        {
-            Assert.Throws<ArgumentException>(() =>
-            {
-                ErrorUtilities.VerifyThrowArgumentArraysSameLength(new string[1], new string[2], string.Empty, string.Empty);
-            });
-        }
-
-        [Fact]
-        public void VerifyThrowArgumentArraysSameLength4()
-        {
-            ErrorUtilities.VerifyThrowArgumentArraysSameLength(new string[1], new string[1], string.Empty, string.Empty);
-        }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index f8cc28a2fa4..b8cf7e10aa4 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -1258,14 +1258,11 @@ private void ResolveReference(
             Reference reference)
         {
             bool isImmutableFrameworkReference = false;
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+            // For a path to be an immutable reference, it must be externally resolved and has a FrameworkReferenceName defined.
+            if (assemblyName == null && !string.IsNullOrEmpty(rawFileNameCandidate) && reference.IsPrimary && reference.ExternallyResolved)
             {
-                // For a path to be an immutable reference, it must be externally resolved and has a FrameworkReferenceName defined.
-                if (assemblyName == null && !string.IsNullOrEmpty(rawFileNameCandidate) && reference.IsPrimary && reference.ExternallyResolved)
-                {
-                    string frameworkReferenceName = reference.PrimarySourceItem.GetMetadata(ItemMetadataNames.frameworkReferenceName);
-                    isImmutableFrameworkReference = !string.IsNullOrEmpty(frameworkReferenceName);
-                }
+                string frameworkReferenceName = reference.PrimarySourceItem.GetMetadata(ItemMetadataNames.frameworkReferenceName);
+                isImmutableFrameworkReference = !string.IsNullOrEmpty(frameworkReferenceName);
             }
 
             // Now, resolve this reference.
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index accb98d7438..c22ab73bc9f 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -2121,7 +2121,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
                     // Skip this check if the public key attribute is "0", as this means we're expecting the public key
                     // comparison to be skipped at install time because the file is signed by an MS trusted cert.
-                    if (publicKeyAttribute.Value.Equals("0", StringComparison.OrdinalIgnoreCase) == false &&
+                    if (!publicKeyAttribute.Value.Equals("0", StringComparison.OrdinalIgnoreCase) &&
                         publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index c51b3db6e91..bc2dc2279a9 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -287,8 +287,7 @@ private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, p
                 MakeFileWriteable(destinationFileState, true);
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) &&
-                Traits.Instance.EscapeHatches.CopyWithoutDelete != true &&
+            if (!Traits.Instance.EscapeHatches.CopyWithoutDelete &&
                 destinationFileState.FileExists &&
                 !destinationFileState.IsReadOnly)
             {
@@ -970,7 +969,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                         retries++;
                         Log.LogWarningWithCodeFromResources("Copy.Retrying", sourceFileState.Name,
                             destinationFileState.Name, retries, RetryDelayMilliseconds, e.Message,
-                            GetLockedFileMessage(destinationFileState.Name));
+                            LockCheck.GetLockedFileMessage(destinationFileState.Name));
 
                         // if we have to retry for some reason, wipe the state -- it may not be correct anymore.
                         destinationFileState.Reset();
@@ -982,7 +981,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                     {
                         // Exception message is logged in caller
                         Log.LogErrorWithCodeFromResources("Copy.ExceededRetries", sourceFileState.Name,
-                            destinationFileState.Name, Retries, GetLockedFileMessage(destinationFileState.Name));
+                            destinationFileState.Name, Retries, LockCheck.GetLockedFileMessage(destinationFileState.Name));
                         throw;
                     }
                     else
@@ -996,7 +995,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                     retries++;
                     Log.LogWarningWithCodeFromResources("Copy.Retrying", sourceFileState.Name,
                         destinationFileState.Name, retries, RetryDelayMilliseconds, String.Empty /* no details */,
-                        GetLockedFileMessage(destinationFileState.Name));
+                        LockCheck.GetLockedFileMessage(destinationFileState.Name));
 
                     // if we have to retry for some reason, wipe the state -- it may not be correct anymore.
                     destinationFileState.Reset();
@@ -1006,7 +1005,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                 else if (Retries > 0)
                 {
                     Log.LogErrorWithCodeFromResources("Copy.ExceededRetries", sourceFileState.Name,
-                        destinationFileState.Name, Retries, GetLockedFileMessage(destinationFileState.Name));
+                        destinationFileState.Name, Retries, LockCheck.GetLockedFileMessage(destinationFileState.Name));
                     return false;
                 }
                 else
@@ -1019,20 +1018,6 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
             return false;
         }
 
-        /// <summary>
-        /// Try to get a message to inform the user which processes have a lock on a given file.
-        /// </summary>
-        private static string GetLockedFileMessage(string file)
-        {
-            string message = string.Empty;
-            if (NativeMethodsShared.IsWindows)
-            {
-                message = LockCheck.GetLockedFileMessage(file);
-            }
-
-            return message;
-        }
-
         /// <summary>
         /// Standard entry point.
         /// </summary>
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index 476c2b52ae6..e37a9bcf300 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -23,7 +23,9 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal static class CultureInfoCache
     {
+#if !NET5_0_OR_GREATER
         private static readonly Lazy<HashSet<string>> ValidCultureNames = new Lazy<HashSet<string>>(() => InitializeValidCultureNames());
+#endif
 
         // https://docs.microsoft.com/en-gb/windows/desktop/Intl/using-pseudo-locales-for-localization-testing
         // These pseudo-locales are available in versions of Windows from Vista and later.
@@ -62,22 +64,20 @@ private static HashSet<string> InitializeValidCultureNames()
         internal static bool IsValidCultureString(string name)
         {
 #if NET5_0_OR_GREATER
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            try
             {
-                try
-                {
-                    // GetCultureInfo throws if the culture doesn't exist
-                    CultureInfo.GetCultureInfo(name, predefinedOnly: true);
-                    return true;
-                }
-                catch
-                {
-                    // Second attempt: try pseudolocales (see above)
-                    return pseudoLocales.Contains(name, StringComparer.OrdinalIgnoreCase);
-                }
+                // GetCultureInfo throws if the culture doesn't exist
+                CultureInfo.GetCultureInfo(name, predefinedOnly: true);
+                return true;
             }
-#endif
+            catch
+            {
+                // Second attempt: try pseudolocales (see above)
+                return pseudoLocales.Contains(name, StringComparer.OrdinalIgnoreCase);
+            }
+#else
             return ValidCultureNames.Value.Contains(name);
+#endif
         }
 
 #if !FEATURE_CULTUREINFO_GETCULTURES
diff --git a/src/Tasks/Delete.cs b/src/Tasks/Delete.cs
index 55e935ee475..e10ad4f733f 100644
--- a/src/Tasks/Delete.cs
+++ b/src/Tasks/Delete.cs
@@ -146,17 +146,18 @@ public override bool Execute()
                     }
                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                     {
+                        string lockedFileMessage = LockCheck.GetLockedFileMessage(file?.ItemSpec ?? string.Empty);
                         if (retries < Retries)
                         {
                             retries++;
-                            Log.LogWarningWithCodeFromResources("Delete.Retrying", file.ToString(), retries, RetryDelayMilliseconds, e.Message);
+                            Log.LogWarningWithCodeFromResources("Delete.Retrying", file.ToString(), retries, RetryDelayMilliseconds, e.Message, lockedFileMessage);
 
                             Thread.Sleep(RetryDelayMilliseconds);
                             continue;
                         }
                         else
                         {
-                            LogError(file, e);
+                            LogError(file, e, lockedFileMessage);
                             // Add on failure to avoid reattempting
                             deletedFilesSet.Add(file.ItemSpec);
                         }
@@ -173,15 +174,16 @@ public override bool Execute()
         /// </summary>
         /// <param name="file">The file that wasn't deleted.</param>
         /// <param name="e">The exception.</param>
-        private void LogError(ITaskItem file, Exception e)
+        /// <param name="lockedFileMessage">Message from <see cref="LockCheck"/>.</param>
+        private void LogError(ITaskItem file, Exception e, string lockedFileMessage)
         {
             if (TreatErrorsAsWarnings)
             {
-                Log.LogWarningWithCodeFromResources("Delete.Error", file.ItemSpec, e.Message);
+                Log.LogWarningWithCodeFromResources("Delete.Error", file.ItemSpec, e.Message, lockedFileMessage);
             }
             else
             {
-                Log.LogErrorWithCodeFromResources("Delete.Error", file.ItemSpec, e.Message);
+                Log.LogErrorWithCodeFromResources("Delete.Error", file.ItemSpec, e.Message, lockedFileMessage);
             }
         }
 
diff --git a/src/Tasks/FileIO/WriteLinesToFile.cs b/src/Tasks/FileIO/WriteLinesToFile.cs
index 33c272c6987..f2cbc19bb42 100644
--- a/src/Tasks/FileIO/WriteLinesToFile.cs
+++ b/src/Tasks/FileIO/WriteLinesToFile.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -148,7 +149,8 @@ public override bool Execute()
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
-                    Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorOrWarning", File.ItemSpec, e.Message);
+                    string lockedFileMessage = LockCheck.GetLockedFileMessage(File.ItemSpec);
+                    Log.LogErrorWithCodeFromResources("WriteLinesToFile.ErrorOrWarning", File.ItemSpec, e.Message, lockedFileMessage);
                     success = false;
                 }
             }
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index fe77d0e5f63..a58209b9053 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -619,11 +619,7 @@ private bool WriteManifest()
             }
             catch (Exception ex)
             {
-                string lockedFileMessage = string.Empty;
-                if (NativeMethodsShared.IsWindows)
-                {
-                    lockedFileMessage = LockCheck.GetLockedFileMessage(OutputManifest.ItemSpec);
-                }
+                string lockedFileMessage = LockCheck.GetLockedFileMessage(OutputManifest.ItemSpec);
                 Log.LogErrorWithCodeFromResources("GenerateManifest.WriteOutputManifestFailed", OutputManifest.ItemSpec, ex.Message, lockedFileMessage);
 
                 return false;
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index ea271573fd0..d1d6f8f7bc6 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -121,12 +121,7 @@ public override bool Execute()
 
         private HashAlgorithm CreateHashAlgorithm()
         {
-            return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) ?
-                SHA256.Create() :
-#pragma warning disable CA5350
-                // Kept for back compatibility reasons when chnange wave is opted-out
-                SHA1.Create();
-#pragma warning restore CA5350
+            return SHA256.Create();
         }
 
         /// <summary>
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index 8776175eddc..bc10cb1d02c 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -500,7 +500,7 @@ private void ReadTrustInfo(string xml)
             // Partial trust is not supported on .NET Core.
             // Fail if loaded manifest does not specify full-trust.
             // It can happen if manifest is manually modifed.
-            if (unrestrictedAttribute == null || (false == Boolean.Parse(unrestrictedAttribute.Value)))
+            if (unrestrictedAttribute == null || (!Boolean.Parse(unrestrictedAttribute.Value)))
             {
                 throw new ArgumentException("Partial trust is not supported.");
             }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 5bdaff55739..de91092b31e 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -251,7 +251,6 @@
     <Compile Include="LC.cs" />
     <Compile Include="ListOperators\FindUnderPath.cs" />
     <Compile Include="ListOperators\RemoveDuplicates.cs" />
-    <Compile Include="LockCheck.cs" />
     <Compile Include="MakeDir.cs" />
     <Compile Include="ManifestUtil\*.cs" Exclude="ManifestUtil\CngLightup.cs" />
     <Compile Include="Message.cs" />
@@ -433,12 +432,6 @@
     <Content Include="Microsoft.Common.props">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
-    <!-- For .NET Core, Microsoft.Common.props needs to be in version subfolder for bootstrap build, but in MSBuild exe
-         path for some tests.  So include it twice. -->
-    <Content Include="Microsoft.Common.props" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-      <Link>Current\Microsoft.Common.props</Link>
-    </Content>
     <Content Include="Microsoft.Common.tasks">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 9850e8cc161..811dcdc42cc 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -48,7 +48,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <!-- Extract necessary information for SetPlatform negotiation -->
         <!-- This target does not run for cpp projects. -->
         <IsVcxOrNativeProj>false</IsVcxOrNativeProj>
-        <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
+        <Platform>$(Platform)</Platform>
         <Platforms>$(Platforms)</Platforms>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 4080585a710..b7e42801af8 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1551,8 +1551,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <Target Name="IgnoreJavaScriptOutputAssembly"
-    BeforeTargets="AssignProjectConfiguration"
-    Condition="$([MSBuild]::AreFeaturesEnabled('17.8'))">
+    BeforeTargets="AssignProjectConfiguration">
       <ItemGroup>
         <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
           <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
@@ -1985,7 +1984,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <IsRidAgnostic>@(_TargetFrameworkInfo->'%(IsRidAgnostic)')</IsRidAgnostic>
         <!-- Extract necessary information for SetPlatform negotiation -->
         <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
-        <Platform Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">$(Platform)</Platform>
+        <Platform>$(Platform)</Platform>
         <Platforms>$(Platforms)</Platforms>
         <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
              Build the `Platforms` property from that. -->
@@ -2172,10 +2171,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_ResolvedProjectReferencePaths>
     </ItemGroup>
 
-    <!-- Issue a warning for each non-existent project. -->
+    <!-- Issue a warning or error for each non-existent project. -->
     <Warning
         Text="The referenced project '%(_MSBuildProjectReferenceNonexistent.Identity)' does not exist."
-        Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != ''"/>
+        Code="MSB9008"
+        Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != '' and '$(ErrorOnMissingProjectReference)' != 'True'"/>
+
+    <Error
+        Text="The referenced project '%(_MSBuildProjectReferenceNonexistent.Identity)' does not exist."
+        Code="MSB9008"
+        Condition="'@(ProjectReferenceWithConfiguration)' != '' and '@(_MSBuildProjectReferenceNonexistent)' != '' and '$(ErrorOnMissingProjectReference)' == 'True'"/>
 
   </Target>
 
@@ -2207,10 +2212,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     metadata.
     ============================================================
     -->
-  <PropertyGroup>
-    <GetTargetPathDependsOn>$(GetTargetPathDependsOn)</GetTargetPathDependsOn>
-  </PropertyGroup>
-
   <Target
       Name="GetTargetPath"
       DependsOnTargets="$(GetTargetPathDependsOn)"
@@ -2736,7 +2737,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
      <FindInvalidProjectReferences
          TargetPlatformVersion="$(TargetPlatformVersion)"
          TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
-         ProjectReferences="@(TargetPathWithTargetPlatformMoniker)">
+         ProjectReferences="@(_ProjectReferenceTargetPlatformMonikers)">
        <Output TaskParameter="InvalidReferences" ItemName="InvalidProjectReferences" />
      </FindInvalidProjectReferences>
 
@@ -2753,7 +2754,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       BuildInParallel="$(BuildInParallel)"
       ContinueOnError="!$(BuildingProject)"
       RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove)$(_GlobalPropertiesToRemoveFromProjectReferences)">
-      <Output TaskParameter="TargetOutputs" ItemName="TargetPathWithTargetPlatformMoniker" />
+      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetPlatformMonikers" />
     </MSBuild>
   </Target>
 
@@ -4551,7 +4552,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_ClickOnceTransitiveContentItemsTemp>
       <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
 
-      <!-- 
+      <!--
         ClickOnce content items is union of transitive content items and content items from this project.
         We also exclude content items from this project that have set CopyToPublishDirectory to Never.
       -->
@@ -5945,7 +5946,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <DeploymentComputeClickOnceManifestInfoDependsOn>
       CleanPublishFolder;
       $(_RecursiveTargetForContentCopying);
-      _DeploymentGenerateTrustInfo
+      _DeploymentGenerateTrustInfo;
       $(DeploymentComputeClickOnceManifestInfoDependsOn)
     </DeploymentComputeClickOnceManifestInfoDependsOn>
   </PropertyGroup>
@@ -6887,9 +6888,20 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <PropertyGroup>
     <MsAppxPackageTargets Condition="'$(MsAppxPackageTargets)'==''">$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\Microsoft.AppXPackage.Targets</MsAppxPackageTargets>
+
+    <!-- Opt-out switch to allow disabling importing the 'AppxPackage' targets for UWP class libraries using modern .NET -->
+    <EnableAppxPackageTargetsForUwpClassLibraries Condition="'$(EnableAppxPackageTargetsForUwpClassLibraries)' == ''">true</EnableAppxPackageTargetsForUwpClassLibraries>
   </PropertyGroup>
 
-  <Import Project="$(MsAppxPackageTargets)" Condition="'$(WindowsAppContainer)' == 'true' and Exists('$(MsAppxPackageTargets)')" />
+  <!--
+    We want to import the 'AppXPackage' .targets in two scenarios:
+      - For legacy UWP, in all cases (original behavior). These projects will always set 'WindowsAppContainer' by default.
+      - For UWP (XAML) apps and libraries on modern .NET, we only enable this for class libraries. This allows the existing
+        .appx tooling to take care of generating .pri resources without the need to pull in WinAppSDK or other external tools.
+        We cannot use this for applications, because the rest of that tooling is not capable of handling modern .NET projects.
+        In that case, we either leverage the tooling in WinAppSDK, or DesktopBridge (via a .wapproj project for packaging).
+  -->
+  <Import Project="$(MsAppxPackageTargets)" Condition="('$(WindowsAppContainer)' == 'true' or ('$(UseUwpTools)' == 'true' and '$(OutputType)' == 'Library' and '$(EnableAppxPackageTargetsForUwpClassLibraries)' != 'false')) and Exists('$(MsAppxPackageTargets)')" />
 
   <!-- This import is temporary and will be removed once it is moved into the silverlight targets -->
   <Import Project="$(MSBuildToolsPath)\Microsoft.Data.Entity.targets" Condition="'$(TargetFrameworkIdentifier)' == 'Silverlight' and Exists('$(MSBuildToolsPath)\Microsoft.Data.Entity.targets')"/>
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 35018eb1918..98e70e97581 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -104,6 +104,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.ZipDirectory"                          AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
   <!-- Roslyn tasks are now in an assembly owned and shipped by Roslyn -->
+  <!-- NOTE: Keep in sync with SDK: src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.Sdk.targets -->
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly"           AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Csc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
   <UsingTask TaskName="Microsoft.CodeAnalysis.BuildTasks.Vbc"                       AssemblyFile="$(RoslynTargetsPath)\Microsoft.Build.Tasks.CodeAnalysis.dll" />
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index e0a628370f8..b3d87dbb516 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -134,7 +134,7 @@ public override bool Execute()
                     }
                     catch (ArgumentException e)
                     {
-                        Log.LogErrorWithCodeFromResources("Move.Error", SourceFiles[i].ItemSpec, DestinationFolder.ItemSpec, e.Message);
+                        Log.LogErrorWithCodeFromResources("Move.Error", SourceFiles[i].ItemSpec, DestinationFolder.ItemSpec, e.Message, string.Empty);
 
                         // Clear the outputs.
                         DestinationFiles = Array.Empty<ITaskItem>();
@@ -169,7 +169,8 @@ public override bool Execute()
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
-                    Log.LogErrorWithCodeFromResources("Move.Error", sourceFile, destinationFile, e.Message);
+                    string lockedFileMessage = LockCheck.GetLockedFileMessage(sourceFile);
+                    Log.LogErrorWithCodeFromResources("Move.Error", sourceFile, destinationFile, e.Message, lockedFileMessage);
                     success = false;
 
                     // Continue with the rest of the list
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 7761f84804a..bf8c6e49134 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -275,11 +275,11 @@
   </data>
   <data name="Copy.Retrying">
     <value>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</value>
-    <comment>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</comment>
+    <comment>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</comment>
   </data>
   <data name="Copy.ExceededRetries">
     <value>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</value>
-    <comment>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</comment>
+    <comment>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</comment>
   </data>
   <data name="Copy.InvalidRetryCount">
     <value>MSB3028: {0} is an invalid retry count. Value must not be negative.</value>
@@ -293,9 +293,6 @@
     <value>MSB3030: Could not copy the file "{0}" because it was not found.</value>
     <comment>{StrBegin="MSB3030: "} LOCALIZATION: {0} is a number.</comment>
   </data>
-  <data name="Task.FileLocked">
-    <value>The file is locked by: "{0}"</value>
-  </data>
 
   <!--
         The CreateItem message bucket is: MSB3031 - MSB3040
@@ -366,15 +363,15 @@
     <value>Deleting file "{0}".</value>
   </data>
   <data name="Delete.Error">
-    <value>MSB3061: Unable to delete file "{0}". {1}</value>
+    <value>MSB3061: Unable to delete file "{0}". {1} {2}</value>
     <comment>{StrBegin="MSB3061: "}</comment>
   </data>
   <data name="Delete.SkippingNonexistentFile">
     <value>File "{0}" doesn't exist. Skipping.</value>
   </data>
   <data name="Delete.Retrying">
-    <value>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</value>
-    <comment>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</comment>
+    <value>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</value>
+    <comment>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</comment>
   </data>
   <data name="Delete.InvalidRetryCount">
     <value>MSB3028: {0} is an invalid retry count. Value must not be negative.</value>
@@ -1239,7 +1236,7 @@
     <comment>{StrBegin="MSB3676: "}</comment>
   </data>
   <data name="Move.Error">
-    <value>MSB3677: Unable to move file "{0}" to "{1}". {2}</value>
+    <value>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</value>
     <comment>{StrBegin="MSB3677: "}</comment>
   </data>
   <data name="Move.ExactlyOneTypeOfDestination">
@@ -2094,7 +2091,7 @@
     <comment>{StrBegin="MSB3371: "}</comment>
   </data>
   <data name="Touch.CannotMakeFileWritable">
-    <value>MSB3372: The file "{0}" cannot be made writable. {1}</value>
+    <value>MSB3372: The file "{0}" cannot be made writable. {1} {2}</value>
     <comment>{StrBegin="MSB3372: "}</comment>
   </data>
   <data name="Touch.CannotRestoreAttributes">
@@ -2102,7 +2099,7 @@
     <comment>{StrBegin="MSB3373: "}</comment>
   </data>
   <data name="Touch.CannotTouch">
-    <value>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</value>
+    <value>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</value>
     <comment>{StrBegin="MSB3374: "}</comment>
   </data>
   <data name="Touch.CreatingFile">
@@ -2188,7 +2185,7 @@
         If this bucket overflows, pls. contact 'vsppbdev'.
   -->
   <data name="WriteLinesToFile.ErrorOrWarning">
-    <value>MSB3491: Could not write lines to file "{0}". {1}</value>
+    <value>MSB3491: Could not write lines to file "{0}". {1} {2}</value>
     <comment>{StrBegin="MSB3491: "}</comment>
   </data>
   <data name="WriteLinesToFile.ErrorReadingFile">
@@ -2430,7 +2427,7 @@
       <comment>{StrBegin="MSB3712: "}</comment>
     </data>
     <data name="WriteCodeFragment.CouldNotWriteOutput" xml:space="preserve">
-      <value>MSB3713: The file "{0}" could not be created. {1}</value>
+      <value>MSB3713: The file "{0}" could not be created. {1} {2}</value>
       <comment>{StrBegin="MSB3713: "}</comment>
     </data>
     <data name="WriteCodeFragment.SkippedNumberedParameter" xml:space="preserve">
@@ -2871,7 +2868,7 @@
     <comment>{StrBegin="MSB3934: "}</comment>
   </data>
   <data name="Unzip.ErrorCouldNotMakeFileWriteable">
-    <value>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</value>
+    <value>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</value>
     <comment>{StrBegin="MSB3935: "}</comment>
   </data>
   <data name="Unzip.ErrorCouldNotExtractFile">
@@ -2912,7 +2909,7 @@
     <comment>{StrBegin="MSB3942: "}</comment>
   </data>
   <data name="ZipDirectory.ErrorFailed">
-    <value>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</value>
+    <value>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</value>
     <comment>{StrBegin="MSB3943: "}</comment>
   </data>
   <data name="ZipDirectory.Comment">
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 8bb9db37186..ca58a4b9539 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: Soubor {0} nelze zkopírovat do umístění {1}. Za {3} ms bude zahájeno opakování {2}. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: Soubor {0} nelze zkopírovat do umístění {1}. Byl překročen počet opakování {2}. Nezdařilo se. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: Nelze odstranit soubor {0}. {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: Nelze odstranit soubor {0}. {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: Nelze odstranit soubor „{0}“. Začátek {1} opakování za {2}ms {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: Nelze odstranit soubor {0}. Začátek opakování {1} za {2} ms. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: Soubor {0} nelze přesunout do umístění {1}. {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: Soubor {0} nelze přesunout do umístění {1}. {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: Nebyl zadán veřejný klíč nezbytný ke zpožděnému podepsání.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Soubor uzamkl(a): {0}.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: Úloha {0} se nepodporuje ve verzi MSBuildu pro .NET Core. Použijte prosím verzi MSBuildu pro .NET Framework. Další podrobnosti najdete na stránce https://aka.ms/msbuild/MSB4803.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: Soubor {0} nelze nastavit pro zápis. {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: Soubor {0} nelze nastavit pro zápis. {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: Nelze nastavit čas posledního otevření či zápisu u souboru {0}. {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: Nelze nastavit čas posledního otevření či zápisu u souboru {0}. {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: Soubor {0} se nepodařilo rozzipovat, protože cílový soubor {1} je jen pro čtení a nebylo možné ho nastavit jako zapisovatelný. {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: Soubor {0} se nepodařilo rozzipovat, protože cílový soubor {1} je jen pro čtení a nebylo možné ho nastavit jako zapisovatelný.  {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: Nelze zapsat řádky do souboru {0}. {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: Nelze zapsat řádky do souboru {0}. {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: Soubor {0} nelze vytvořit. {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: Soubor {0} nelze vytvořit. {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: Adresář {0} se nepodařilo zazipovat do souboru {1}. {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: Adresář {0} se nepodařilo zazipovat do souboru {1}.  {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 65661176521..e5c8bc876c8 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: "{0}" konnte nicht in "{1}" kopiert werden. Wiederholung {2} wird in {3} ms gestartet. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: "{0}" konnte nicht in "{1}" kopiert werden. Die zulässige Anzahl von Wiederholungen von {2} wurde überschritten. Fehler. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: Die Datei "{0}" kann nicht gelöscht werden. {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: Die Datei „{0}“ kann nicht gelöscht werden. {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: Die Datei "{0}" konnte nicht gelöscht werden. Wiederholungsversuch {1} wird in {2}ms gestartet. {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: Die Datei „{0}“ konnte nicht gelöscht werden. Wiederholungsversuch {1} in {2} Mins. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: Die Datei "{0}" kann nicht in "{1}" verschoben werden. {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: Die Datei „{0}“ kann nicht in „{1}“ verschoben werden. {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: Der für die verzögerte Signierung erforderliche öffentliche Schlüssel wurde nicht angegeben.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Die Datei wird durch "{0}" gesperrt.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: Die Aufgabe "{0}" wird für die .NET Core-Version von MSBuild nicht unterstützt. Verwenden Sie die .NET Framework-Version von MSBuild. Weitere Informationen finden Sie unter https://aka.ms/msbuild/MSB4803.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: Der Schreibschutz für die Datei "{0}" kann nicht aufgehoben werden. {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: Die Datei „{0}“ kann nicht beschreibbar gemacht werden. {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: Die Zeit für den letzten Zugriff/Schreibzugriff auf die Datei "{0}" kann nicht festgelegt werden. {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: Der letzte Zugriff/Zeitpunkt des letzten Schreibvorgangs für die Datei „{0}“ kann nicht festgelegt werden. {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: Fehler beim Entzippen der Datei "{0}", weil die Zieldatei "{1}" schreibgeschützt ist und sie nicht in einen beschreibbaren Zustand umgewandelt werden konnte.  {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: Fehler beim Entzippen der Datei „{0}“, da die Zieldatei „{1}“ schreibgeschützt ist und nicht beschreibbar gemacht werden konnte.  {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: In die Datei "{0}" konnten keine Zeilen geschrieben werden. {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: Zeilen konnten nicht in die Datei „{0}“ geschrieben werden. {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: Die Datei "{0}" konnte nicht erstellt werden. {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: Die Datei „{0}“ konnte nicht erstellt werden. {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: Fehler beim Zippen des Verzeichnisses "{0}" in die Datei "{1}".  {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: Fehler beim Zippen des Verzeichnisses „{0}“ in die Datei „{1}“.  {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 26b96fb0e25..1348e2c1844 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: No se pudo copiar "{0}" en "{1}". Se iniciará el reintento {2} dentro de {3}ms. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: No se pudo copiar "{0}" en "{1}". Se superó el número de {2} reintentos. Error. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: No se puede eliminar el archivo "{0}". {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: No se puede eliminar el archivo "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: No se pudo eliminar el archivo "{0}". Iniciando reintento {1} en {2}ms. {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: No se pudo eliminar el archivo "{0}". Iniciando reintento{1} en {2}ms. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: No se puede mover el archivo "{0}" a "{1}". {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: No se puede mover el archivo "{0}" a "{1}". {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: No se especificó la clave pública necesaria para la firma retardada.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">El archivo se ha bloqueado por: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: No se admite la tarea "{0}" en la versión de MSBuild de .NET Core. Use la versión de MSBuild de .NET Framework. Vea https://aka.ms/msbuild/MSB4803 para obtener más información.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: El archivo "{0}" no puede convertirse en grabable. {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: El archivo "{0}" no se puede escribir. {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: No puede establecerse la hora del último acceso ni de la última escritura en el archivo "{0}". {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: No se puede establecer la hora de último acceso o última escritura en el archivo "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: No se pudo descomprimir el archivo "{0}" porque el archivo de destino "{1}" es de solo lectura y no se pudo cambiar para permitir la escritura.  {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: No se pudo descomprimir el archivo "{0}" porque el archivo de destino "{1}" es de solo lectura y no se pudo escribir.  {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: No se pudieron escribir líneas en el archivo "{0}". {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: No se pudieron escribir líneas en el archivo "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: No se pudo crear el archivo "{0}". {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: No se pudo crear el archivo "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: Error al comprimir el directorio "{0}" en el archivo "{1}".  {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: No se pudo comprimir el directorio "{0}" en el archivo "{1}".  {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index bf6f63d2eb9..ddd6039a684 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: Impossible de copier "{0}" vers "{1}". Nouvelle tentative de l'opération {2} dans {3} ms. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: Impossible de copier "{0}" vers "{1}". Dépassement du nombre maximal de nouvelles tentatives de {2}. Échec. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: Impossible de supprimer le fichier "{0}". {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: Impossible de supprimer le fichier « {0} ». {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: Impossible de supprimer le fichier "{0}« . Début du {1} de nouvelles tentatives en {2}ms. {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: Impossible de supprimer le fichier « {0} ». Début du {1} de nouvelles tentatives en {2} ms. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: Impossible de déplacer le fichier "{0}" vers "{1}". {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: Impossible de déplacer le fichier « {0} » vers « {1} ». {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: La clé publique nécessaire à la signature différée n'a pas été spécifiée.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Le fichier est verrouillé par : "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: La tâche "{0}" n'est pas prise en charge dans la version .NET Core de MSBuild. Utilisez la version du .NET Framework de MSBuild. Pour plus d'informations, consultez https://aka.ms/msbuild/MSB4803.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: Impossible de rendre le fichier "{0}" accessible en écriture. {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: Impossible de rendre le fichier « {0} » accessible en écriture. {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: Impossible de définir l'heure du dernier accès/de la dernière écriture pour le fichier "{0}". {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: Impossible de définir l’heure du dernier accès/de la dernière écriture pour le fichier « {0} ». {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: Échec de la décompression du fichier "{0}", car le fichier de destination "{1}" est en lecture seule et n'a pas pu être rendu accessible en écriture. {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: Échec de la décompression du fichier « {0} », car le fichier de destination « {1} » est en lecture seule et n’a pas pu être rendu accessible en écriture. {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: Impossible d'écrire des lignes dans le fichier "{0}". {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: Impossible d’écrire des lignes dans le fichier « {0} ». {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: Impossible de créer le fichier "{0}". {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: Impossible de créer le fichier « {0} ». {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: Échec de la compression du répertoire "{0}" dans le fichier "{1}". {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: Échec de la compression du répertoire « {0} » dans le fichier « {1} ». {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index b6dedbeb34d..12c155599d8 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: non è stato possibile copiare "{0}" in "{1}". Il tentativo numero {2} verrà avviato tra {3} ms. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: non è stato possibile copiare "{0}" in "{1}". È stato superato il numero massimo di tentativi, pari a {2}. L'operazione non è riuscita. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: non è possibile eliminare il file "{0}". {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: non è possibile eliminare il file "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: non è stato possibile eliminare il file "{0}". Inizio dei tentativi {1} in {2}ms. {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: non è stato possibile eliminare il file "{0}". Inizio dei tentativi {1} in {2}ms. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: non è possibile spostare il file "{0}" in "{1}". {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: non è possibile spostare il file "{0}" in "{1}". {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: chiave pubblica necessaria per la firma ritardata non specificata.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Il file è bloccato da: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: l'attività "{0}" non è supportata nella versione .NET Core di MSBuild. Usare la versione .NET Framework di MSBuild. Per altri dettagli, vedere https://aka.ms/msbuild/MSB4803.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: non è possibile rendere accessibile in scrittura il file "{0}". {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: non è possibile rendere accessibile in scrittura il file "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: non è possibile impostare l'ora dell'ultimo accesso o dell'ultima scrittura per il file "{0}". {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: non è possibile impostare l'ora dell'ultimo accesso o dell'ultima scrittura per il file "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: non è stato possibile decomprimere il file "{0}" perché il file di destinazione "{1}" è di sola lettura e non è possibile impostarlo come scrivibile. {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: non è  possibile decomprimere il file "{0}" perché il file di destinazione "{1}" è di sola lettura e non è possibile impostarlo come scrivibile. {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: non è stato possibile scrivere righe nel file "{0}". {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: non è possibile scrivere righe nel file "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: non è stato possibile creare il file "{0}". {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: non è possibile creare il file "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: non è stato possibile comprimere la directory "{0}" nel file "{1}". {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: non è possibile comprimere la directory "{0}" nel file "{1}". {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index ad9253819a8..6eb05bf4c12 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: "{0}" を "{1}" にコピーできませんでした。{3} ミリ秒以内に {2} 回目の再試行を開始します。{4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: "{0}" を "{1}" にコピーできませんでした。{2} 回の再試行回数を超えたため、失敗しました。{3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: ファイル "{0}" を削除できません。{1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: ファイル "{0}" を削除できません。{1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: ファイル "{0}" を削除できませんでした。{1} の再試行を {2}ミリ秒で開始します。{3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: ファイル "{0}" を削除できませんでした。{2} ミリ秒で再試行 {1} を開始しています。{3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: ファイル "{0}" を "{1}" に移動できません。{2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: ファイル "{0}" を "{1}" に移動できません。{2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: 遅延署名に必要な公開キーは指定されませんでした。</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">このファイルは "{0}" によってロックされています。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: タスク "{0}" は .NET Core バージョンの MSBuild ではサポートされていません。.NET Framework バージョンの MSBuild をご使用ください。詳細については、https://aka.ms/msbuild/MSB4803 をご覧ください。</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: ファイル "{0}" を書き込み可能にすることはできません。{1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: ファイル "{0}" を書き込み可能にすることはできません。{1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: ファイル "{0}" に最後にアクセスした、または書き込んだ時間を設定できません。{1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: ファイル "{0}" に最後にアクセスした、または書き込んだ時間を設定できません。{1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: 解凍先のファイル "{1}" が読み取り専用で、書き込み可能にすることができないため、ファイル "{0}" を解凍できませんでした。{2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: 解凍先のファイル "{0}" が読み取り専用で、書き込み可能にすることができないため、ファイル "{1}" を解凍できませんでした。{2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: 行をファイル "{0}" に書き込めませんでした。{1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: 行をファイル "{0}" に書き込めませんでした。{1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: ファイル "{0}" を作成できませんでした。{1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: ファイル "{0}" を作成できませんでした。{1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: ディレクトリ "{0}" をファイル "{1}" に zip 圧縮できませんでした。{2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: ディレクトリ "{0}" をファイル "{1}" に zip 圧縮できませんでした。{2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 602b92b7a00..2f1b4a995dc 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: "{0}"을(를) "{1}"(으)로 복사할 수 없습니다. {3}ms 안에 재시도 {2}을(를) 시작합니다. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: "{0}"을(를) "{1}"(으)로 복사할 수 없습니다. 재시도 횟수({2})를 초과하여 작업을 수행하지 못했습니다. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: "{0}" 파일을 삭제할 수 없습니다. {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: 파일 "{0}"을(를) 삭제할 수 없습니다. {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: "{0}" 파일을 삭제할 수 없습니다. {2} ms에서 다시 시도 {1}을(를) 시작합니다. {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: 파일 "{0}"을(를) 삭제할 수 없습니다. {2}ms 후 {1} 재시도를 시작하세요. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: "{0}" 파일을 "{1}"(으)로 이동할 수 없습니다. {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: 파일 "{0}"을(를) "{1}"(으)로 이동할 수 없습니다. {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: 서명 연기에 필요한 공개 키를 지정하지 않았습니다.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">파일이 "{0}"에 의해 잠겨 있습니다.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: "{0}" 작업은 MSBuild의 .NET Core 버전에서 지원되지 않습니다. MSBuild의 .NET Framework 버전을 사용하세요. 자세한 내용은 https://aka.ms/msbuild/MSB4803을 참조하세요.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: "{0}" 파일을 쓰기 가능하게 만들 수 없습니다. {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: "{0}" 파일을 쓰기 가능하게 만들 수 없습니다. {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: "{0}" 파일에 마지막으로 액세스한 시간 및 마지막으로 쓴 시간을 설정할 수 없습니다. {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: "{0}" 파일에 마지막으로 액세스한 시간 및 마지막으로 쓴 시간을 설정할 수 없습니다. {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: 대상 파일 "{1}"이(가) 읽기 전용이고 쓰기 가능하도록 만들 수 없기 때문에 파일 "{0}"의 압축을 풀지 못했습니다.  {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: 대상 파일 "{0}"이(가) 읽기 전용이고 쓰기 가능하도록 만들 수 없기 때문에 파일 "{1}"의 압축을 풀지 못했습니다.  {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: "{0}" 파일에 줄을 쓸 수 없습니다. {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: "{0}" 파일에 줄을 쓸 수 없습니다. {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: "{0}" 파일을 만들 수 없습니다. {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: "{0}" 파일을 만들 수 없습니다. {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: 디렉터리 "{0}"의 압축을 "{1}" 파일에 풀지 못했습니다.  {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: 디렉터리 "{0}"의 압축을 "{1}" 파일에 풀지 못했습니다.  {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 5444be59980..07ed19ed057 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: Nie można skopiować „{0}” do „{1}”. Ponowna próba {2} za {3} ms. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: Nie można skopiować „{0}” do „{1}”. Przekroczono liczbę ponownych prób {2}. Niepowodzenie. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: Nie można usunąć pliku „{0}”. {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: Nie można usunąć pliku „{0}”. {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: nie można usunąć pliku „{0}”. Rozpoczynanie ponawiania próby {1} za {2} ms. {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: nie można usunąć pliku „{0}”. Rozpoczynanie ponawiania próby {1} za {2} ms. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: Nie można przenieść pliku „{0}” to „{1}”. {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: Nie można przenieść pliku „{0}” do „{1}”. {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: Klucz publiczny jest niezbędny, ponieważ nie określono znaku opóźnienia.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Plik jest zablokowany przez: „{0}”</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: Zadanie „{0}” nie jest obsługiwane w wersji programu MSBuild dla platformy .NET Core. Użyj wersji programu MSBuild dla platformy .NET Framework. Zobacz https://aka.ms/msbuild/MSB4803, aby uzyskać więcej szczegółów.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: Plik „{0}” nie może być plikiem zapisywalnym. {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: Plik „{0}” nie może być plikiem zapisywalnym. {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: Nie można ustawić godziny ostatniego dostępu do pliku/zapisu w pliku „{0}”. {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: Nie można ustawić godziny ostatniego dostępu do pliku/zapisu w pliku „{0}”. {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: Nie można rozpakować pliku „{0}”, ponieważ plik docelowy „{1}” jest tylko do odczytu i nie można go udostępnić do zapisu. {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: Nie można rozpakować pliku „{0}”, ponieważ plik docelowy „{1}” jest tylko do odczytu i nie może być zapisywalny. {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: Nie można zapisać wierszy w pliku „{0}”. {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: Nie można zapisać wierszy w pliku „{0}”. {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: Nie można utworzyć pliku {0}. {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: Nie można utworzyć pliku „{0}”. {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: Nie można skompresować katalogu „{0}” do pliku „{1}”. {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: Nie można skompresować katalogu „{0}” do pliku „{1}”. {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 51d2f87ec55..928dc47fcf7 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: não foi possível copiar "{0}" para "{1}". Iniciando nova tentativa {2} em {3}ms. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: não foi possível copiar "{0}" para "{1}". Número de novas tentativas {2} excedido. Falha. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: Não é possível excluir o arquivo "{0}". {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: Não é possível excluir o arquivo "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: Não foi possível excluir o arquivo "{0}". Iniciando repetição {1} em {2} ms. {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: Não foi possível excluir o arquivo "{0}". Iniciando repetição {1} em {2} ms. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: Não é possível mover o arquivo "{0}" para "{1}". {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: Não é possível mover o arquivo "{0}" para "{1}". {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: Chave pública necessária, pois a assinatura atrasada não foi especificada.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">O arquivo é bloqueado por: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: a tarefa "{0}" não é compatível com a versão do .NET Core do MSBuild. Use a versão do .NET Framework do MSBuild. Confira https://aka.ms/msbuild/MSB4803 para obter mais detalhes.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: Não é possível tornar o arquivo "{0}" gravável. {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: Não é possível tornar o arquivo "{0}" gravável. {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: Não é possível definir o horário de último acesso/gravação no arquivo "{0}". {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: Não é possível definir o horário de último acesso/gravação no arquivo "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: Falha ao descompactar o arquivo "{0}" porque o arquivo de destino "{1}" é somente leitura e não pôde ser transformado em gravável. {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: Falha ao descompactar o arquivo "{0}" porque o arquivo de destino "{1}" é somente leitura e não pôde ser transformado em gravável.  {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: Não foi possível gravar linhas no arquivo "{0}". {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: Não foi possível gravar linhas no arquivo "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: Não foi possível criar o arquivo "{0}". {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: Não foi possível criar o arquivo "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: Falha ao zipar o diretório "{0}" no arquivo "{1}". {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: Falha ao compactar o diretório "{0}" no arquivo "{1}".  {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index bfe3ff60874..00e0d2a824f 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: не удалось скопировать "{0}" в "{1}". Повторная попытка {2} начнется через {3} мс. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: не удалось скопировать "{0}" в "{1}". Превышено допустимое число повторных попыток ({2}). Произошел сбой. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: Не удается удалить файл "{0}". {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: не удается удалить файл "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: не удалось удалить файл "{0}". Запуск повторной попытки {1} через {2} мс. {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: не удалось удалить файл "{0}". Запуск повторной попытки {1} через {2} мс. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: Не удалось переименовать файл "{0}" в "{1}". {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: не удается переместить файл "{0}" в "{1}". {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: Не указан публичный ключ, необходимый для отложенной подписи.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">"{0}" блокирует этот файл</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: задача "{0}" не поддерживается в MSBuild версии .NET Core. Используйте MSBuild версии .NET Framework. Дополнительные сведения: https://aka.ms/msbuild/MSB4803.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: Не удается сделать файл "{0}" доступным для записи. {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: невозможно сделать файл "{0}" доступным для записи. {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: Не удалось задать время последнего доступа/последней записи для файла "{0}". {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: невозможно настроить время последнего доступа/последней записи для файла "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: не удалось распаковать файл "{0}", так как файл назначения "{1}" доступен только для чтения и его нельзя открыть для записи. {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: не удалось распаковать файл "{0}", так как конечный файл "{1}" доступен только для чтения и его нельзя сделать доступным для записи. {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: Не удалось записать строки в файл "{0}". {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: не удалось записать строки в файл "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: не удалось создать файл "{0}". {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: не удалось создать файл "{0}". {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: не удалось упаковать каталог "{0}" в файл "{1}". {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: не удалось упаковать каталог "{0}" в файл "{1}".  {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 3239df495ae..10e5d0a18b4 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: "{0}", "{1}" üzerine kopyalanamadı. {2} numaralı yeniden denemeye {3} ms içinde başlanacak. {4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: "{0}", "{1}" üzerine kopyalanamadı. {2} yeniden deneme sayısı aşıldı. Başarısız oldu. {3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: "{0}" dosyası silinemiyor. {1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: "{0}" dosyası silinemiyor. {1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: "{0}" dosyası silinemedi. {1}. yeniden deneme {2} ms içinde başlıyor. {3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: "{0}" dosyası silinemedi. {1} {2} dakika içinde yeniden denenecek. {3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: "{0}" dosyası "{1}" üzerine taşınamıyor. {2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: "{0}" dosyası "{1}" üzerine taşınamıyor. {2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: Gecikmeli imzalama için gerekli olan ortak anahtar belirtilmemiş.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">Dosya şunun tarafından kilitlendi: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: MSBuild’in .NET Core sürümünde "{0}" görevi desteklenmiyor. Lütfen MSBuild’in .NET Framework sürümünü kullanın. Daha ayrıntılı bilgi için bkz. https://aka.ms/msbuild/MSB4803.</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: "{0}" dosyası yazılabilir yapılamadı. {1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: "{0}" dosyası yazılabilir yapılamadı. {1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: "{0}" dosyası için son erişim/son yazma zamanı ayarlanamıyor. {1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: "{0}" dosyası için son erişim/son yazma zamanı ayarlanamıyor. {1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: "{1}" hedef dosyası salt okunur olduğundan ve yazılabilir hale getirilemediğinden "{0}" dosyasının sıkıştırması açılamadı. {2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: "{0}" hedef dosyası salt okunur olduğundan ve yazılabilir hale getirilemediğinden "{1}" dosyasının sıkıştırması açılamadı. {2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: Satırlar "{0}" dosyasına yazılamadı. {1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: Satırlar "{0}" dosyasına yazılamadı. {1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: "{0}" dosyası oluşturulamadı. {1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: "{0}" dosyası oluşturulamadı. {1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: "{0}" dizini "{1}" dosyasına sıkıştırılamadı. {2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: "{0}" dizini "{1}" dosyasına sıkıştırılamadı. {2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 4a16a34cc82..3150a4a48be 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: 无法将“{0}”复制到“{1}”。{3} 毫秒后将开始第 {2} 次重试。{4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: 无法将“{0}”复制到“{1}”。超出了重试计数 {2}。失败。{3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: 无法删除文件“{0}”。{1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: 无法删除文件“{0}”。{1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: 无法删除文件“{0}”。 {2} 毫秒后开始重试 {1}。{3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: 无法删除文件“{0}”。{2} 毫秒后开始重试 {1} 次。{3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: 无法将文件“{0}”移动到“{1}”。{2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: 无法将文件“{0}”移动到“{1}”。{2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: 未指定延迟签名所需的公钥。</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">文件被“{0}”锁定。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: .NET Core 版本的 MSBuild 不支持“{0}”。请使用 .NET Framework 版本的 MSBuild。有关更多详细信息，请参阅 https://aka.ms/msbuild/MSB4803。</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: 无法使文件“{0}”可写。{1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: 无法将文件“{0}”设为可写。{1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: 无法设置文件“{0}”的上次访问/写入时间。{1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: 无法设置文件“{0}”的上次访问/写入时间。{1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: 未能解压缩文件“{0}”，因为目标文件“{1}”是只读文件，无法写入。{2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: 未能解压缩文件“{0}”，因为目标文件“{1}”是只读文件，无法设为可写。{2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: 未能向文件“{0}”写入命令行。{1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: 未能向文件“{0}”写入行。{1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: 未能创建文件“{0}”。{1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: 无法创建文件“{0}”。{1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: 未能将目录“{0}”压缩到文件“{1}”。{2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: 未能将目录“{0}”压缩为文件“{1}”。{2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 2ef9b7e4e22..1750cb66c52 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -274,12 +274,12 @@
       <trans-unit id="Copy.Retrying">
         <source>MSB3026: Could not copy "{0}" to "{1}". Beginning retry {2} in {3}ms. {4} {5}</source>
         <target state="translated">MSB3026: 無法將 "{0}" 複製到 "{1}"。即將在 {3} 毫秒內重試 {2} 次。{4} {5}</target>
-        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3026: "} LOCALIZATION: {0} and {1} are paths. {2} and {3} are numbers. {4} is an optional localized message. {5} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.ExceededRetries">
         <source>MSB3027: Could not copy "{0}" to "{1}". Exceeded retry count of {2}. Failed. {3}</source>
         <target state="translated">MSB3027: 無法將 "{0}" 複製到 "{1}"。已超過重試次數 {2}。失敗。{3}</target>
-        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Copy.FileLocked ("The file is locked by: "{0}"")</note>
+        <note>{StrBegin="MSB3027: "} LOCALIZATION: {0} and {1} are paths. {2} is a number. {3} is either empty or a string from Utilities LockCheck.FileLocked ("The file is locked by: "{0}"")</note>
       </trans-unit>
       <trans-unit id="Copy.InvalidRetryCount">
         <source>MSB3028: {0} is an invalid retry count. Value must not be negative.</source>
@@ -357,8 +357,8 @@
         <note />
       </trans-unit>
       <trans-unit id="Delete.Error">
-        <source>MSB3061: Unable to delete file "{0}". {1}</source>
-        <target state="translated">MSB3061: 無法刪除檔案 "{0}"。{1}</target>
+        <source>MSB3061: Unable to delete file "{0}". {1} {2}</source>
+        <target state="translated">MSB3061: 無法刪除檔案 "{0}"。{1} {2}</target>
         <note>{StrBegin="MSB3061: "}</note>
       </trans-unit>
       <trans-unit id="Delete.InvalidRetryCount">
@@ -372,9 +372,9 @@
         <note>{StrBegin="MSB3029: "} LOCALIZATION: {0} is a number.</note>
       </trans-unit>
       <trans-unit id="Delete.Retrying">
-        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3}</source>
-        <target state="translated">MSB3062: 無法刪除檔案 "{0}"。將在 {2} 毫秒內開始重試 {1}。{3}</target>
-        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message.</note>
+        <source>MSB3062: Could not delete file "{0}". Beginning retry {1} in {2}ms. {3} {4}</source>
+        <target state="translated">MSB3062: 無法刪除檔案 "{0}"。在 {2} 毫秒內開始重試 {1}。{3} {4}</target>
+        <note>{StrBegin="MSB3062: "} LOCALIZATION: {0} are paths. {1} and {2} are numbers. {3} is an optional localized message, {4} is message from LockCheck.</note>
       </trans-unit>
       <trans-unit id="Delete.SkippingNonexistentFile">
         <source>File "{0}" doesn't exist. Skipping.</source>
@@ -1519,8 +1519,8 @@
         <note>{StrBegin="MSB3676: "}</note>
       </trans-unit>
       <trans-unit id="Move.Error">
-        <source>MSB3677: Unable to move file "{0}" to "{1}". {2}</source>
-        <target state="translated">MSB3677: 無法將檔案 "{0}" 移至 "{1}"。{2}</target>
+        <source>MSB3677: Unable to move file "{0}" to "{1}". {2} {3}</source>
+        <target state="translated">MSB3677: 無法將檔案 "{0}" 移至 "{1}"。{2} {3}</target>
         <note>{StrBegin="MSB3677: "}</note>
       </trans-unit>
       <trans-unit id="Move.ExactlyOneTypeOfDestination">
@@ -2564,11 +2564,6 @@
         <target state="translated">MSB3353: 未指定延遲簽署所需的公開金鑰。</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
-      <trans-unit id="Task.FileLocked">
-        <source>The file is locked by: "{0}"</source>
-        <target state="translated">檔案鎖定者: "{0}"</target>
-        <note />
-      </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
         <source>MSB4803: The task "{0}" is not supported on the .NET Core version of MSBuild. Please use the .NET Framework version of MSBuild. See https://aka.ms/msbuild/MSB4803 for further details.</source>
         <target state="translated">MSB4803: MSBuild 的 .NET Core 版本不支援工作 "{0}"。請使用 MSBuild 的 .NET Framework 版本。如需進一步的詳細資料，請參閱 https://aka.ms/msbuild/MSB4803。</target>
@@ -2590,8 +2585,8 @@
         <note>{StrBegin="MSB3371: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotMakeFileWritable">
-        <source>MSB3372: The file "{0}" cannot be made writable. {1}</source>
-        <target state="translated">MSB3372: 無法讓檔案 "{0}" 變成可以寫入。{1}</target>
+        <source>MSB3372: The file "{0}" cannot be made writable. {1} {2}</source>
+        <target state="translated">MSB3372: 無法讓檔案 "{0}" 變成可以寫入。{1} {2}</target>
         <note>{StrBegin="MSB3372: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotRestoreAttributes">
@@ -2600,8 +2595,8 @@
         <note>{StrBegin="MSB3373: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CannotTouch">
-        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1}</source>
-        <target state="translated">MSB3374: 無法設定檔案 "{0}" 上次存取/寫入的時間。{1}</target>
+        <source>MSB3374: The last access/last write time on file "{0}" cannot be set. {1} {2}</source>
+        <target state="translated">MSB3374: 無法設定檔案 "{0}" 上次存取/寫入的時間。{1} {2}</target>
         <note>{StrBegin="MSB3374: "}</note>
       </trans-unit>
       <trans-unit id="Touch.CreatingFile">
@@ -2695,8 +2690,8 @@
         <note>{StrBegin="MSB3936: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotMakeFileWriteable">
-        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2}</source>
-        <target state="translated">MSB3935: 因為目的地檔案 "{1}" 是唯讀檔案，而無法設定為可寫入，所以無法解壓縮檔案 "{0}"。{2}</target>
+        <source>MSB3935: Failed to unzip file "{0}" because destination file "{1}" is read-only and could not be made writable.  {2} {3}</source>
+        <target state="translated">MSB3935: 因為目的地檔案 "{0}" 是唯讀檔案，而無法設定為可寫入，所以無法解壓縮檔案 "{1}"。{2} {3}</target>
         <note>{StrBegin="MSB3935: "}</note>
       </trans-unit>
       <trans-unit id="Unzip.ErrorCouldNotOpenFile">
@@ -2780,8 +2775,8 @@
         <note>{StrBegin="MSB3715: "}</note>
       </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorOrWarning">
-        <source>MSB3491: Could not write lines to file "{0}". {1}</source>
-        <target state="translated">MSB3491: 無法將行寫入檔案 "{0}"。{1}</target>
+        <source>MSB3491: Could not write lines to file "{0}". {1} {2}</source>
+        <target state="translated">MSB3491: 無法將行寫入檔案 "{0}"。{1} {2}</target>
         <note>{StrBegin="MSB3491: "}</note>
       </trans-unit>
       <trans-unit id="GetReferenceAssemblyPaths.InvalidTargetFrameworkMoniker">
@@ -3050,8 +3045,8 @@
         <note>{StrBegin="MSB3712: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotWriteOutput">
-        <source>MSB3713: The file "{0}" could not be created. {1}</source>
-        <target state="translated">MSB3713: 無法建立檔案 "{0}"。{1}</target>
+        <source>MSB3713: The file "{0}" could not be created. {1} {2}</source>
+        <target state="translated">MSB3713: 無法建立檔案 "{0}"。{1} {2}</target>
         <note>{StrBegin="MSB3713: "}</note>
       </trans-unit>
       <trans-unit id="WriteCodeFragment.SkippedNumberedParameter">
@@ -3500,8 +3495,8 @@
         <note>{StrBegin="MSB3941: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFailed">
-        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2}</source>
-        <target state="translated">MSB3943: 無法將目錄 "{0}" 壓縮至檔案 "{1}"。{2}</target>
+        <source>MSB3943: Failed to zip directory "{0}" to file "{1}".  {2} {3}</source>
+        <target state="translated">MSB3943: 無法將目錄 "{0}" 壓縮至檔案 "{1}"。{2} {3}</target>
         <note>{StrBegin="MSB3943: "}</note>
       </trans-unit>
       <trans-unit id="ZipDirectory.ErrorFileExists">
diff --git a/src/Tasks/Touch.cs b/src/Tasks/Touch.cs
index 8ab11f27c8f..6b66ec1e769 100644
--- a/src/Tasks/Touch.cs
+++ b/src/Tasks/Touch.cs
@@ -8,6 +8,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -246,7 +247,8 @@ private bool TouchFile(
                     }
                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                     {
-                        Log.LogErrorWithCodeFromResources("Touch.CannotMakeFileWritable", file, e.Message);
+                        string lockedFileMessage = LockCheck.GetLockedFileMessage(file);
+                        Log.LogErrorWithCodeFromResources("Touch.CannotMakeFileWritable", file, e.Message, lockedFileMessage);
                         return false;
                     }
                 }
@@ -261,7 +263,8 @@ private bool TouchFile(
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                Log.LogErrorWithCodeFromResources("Touch.CannotTouch", file, e.Message);
+                string lockedFileMessage = LockCheck.GetLockedFileMessage(file);
+                Log.LogErrorWithCodeFromResources("Touch.CannotTouch", file, e.Message, lockedFileMessage);
                 return false;
             }
             finally
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 6590a161c43..ff6a99fbd48 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -221,7 +221,8 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
                     }
                     catch (Exception e)
                     {
-                        Log.LogErrorWithCodeFromResources("Unzip.ErrorCouldNotMakeFileWriteable", zipArchiveEntry.FullName, destinationPath.FullName, e.Message);
+                        string lockedFileMessage = LockCheck.GetLockedFileMessage(destinationPath.FullName);
+                        Log.LogErrorWithCodeFromResources("Unzip.ErrorCouldNotMakeFileWriteable", zipArchiveEntry.FullName, destinationPath.FullName, e.Message, lockedFileMessage);
                         continue;
                     }
                 }
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 81b2c4d9497..79efdf61495 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -119,7 +119,9 @@ public override bool Execute()
             }
             catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
             {
-                Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotWriteOutput", (OutputFile == null) ? String.Empty : OutputFile.ItemSpec, ex.Message);
+                string itemSpec = OutputFile?.ItemSpec ?? String.Empty;
+                string lockedFileMessage = LockCheck.GetLockedFileMessage(itemSpec);
+                Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotWriteOutput", itemSpec, ex.Message, lockedFileMessage);
                 return false;
             }
 
diff --git a/src/Tasks/ZipDirectory.cs b/src/Tasks/ZipDirectory.cs
index 96544d528a9..20a78e8f3a4 100644
--- a/src/Tasks/ZipDirectory.cs
+++ b/src/Tasks/ZipDirectory.cs
@@ -5,6 +5,7 @@
 using System.IO;
 using System.IO.Compression;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -66,7 +67,8 @@ public override bool Execute()
                     }
                     catch (Exception e)
                     {
-                        Log.LogErrorWithCodeFromResources("ZipDirectory.ErrorFailed", sourceDirectory.FullName, destinationFile.FullName, e.Message);
+                        string lockedFileMessage = LockCheck.GetLockedFileMessage(destinationFile.FullName);
+                        Log.LogErrorWithCodeFromResources("ZipDirectory.ErrorFailed", sourceDirectory.FullName, destinationFile.FullName, e.Message, lockedFileMessage);
 
                         return false;
                     }
@@ -86,7 +88,7 @@ public override bool Execute()
                 }
                 catch (Exception e)
                 {
-                    Log.LogErrorWithCodeFromResources("ZipDirectory.ErrorFailed", sourceDirectory.FullName, destinationFile.FullName, e.Message);
+                    Log.LogErrorWithCodeFromResources("ZipDirectory.ErrorFailed", sourceDirectory.FullName, destinationFile.FullName, e.Message, string.Empty);
                 }
             }
             finally
diff --git a/src/UnitTests.Shared/BootstrapLocationAttribute.cs b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
index 7f8627a69b3..7dfeb62ce64 100644
--- a/src/UnitTests.Shared/BootstrapLocationAttribute.cs
+++ b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
@@ -6,8 +6,9 @@
 namespace Microsoft.Build.UnitTests.Shared;
 
 [System.AttributeUsage(System.AttributeTargets.Assembly)]
-internal sealed class BootstrapLocationAttribute(string bootstrapMsbuildBinaryLocation)
-    : System.Attribute
+internal sealed class BootstrapLocationAttribute(string bootstrapMsBuildBinaryLocation, string bootstrapSdkVersion) : System.Attribute
 {
-    public string BootstrapMsbuildBinaryLocation { get; } = bootstrapMsbuildBinaryLocation;
+    public string BootstrapMsBuildBinaryLocation { get; } = bootstrapMsBuildBinaryLocation;
+
+    public string BootstrapSdkVersion { get; } = bootstrapSdkVersion;
 }
diff --git a/src/UnitTests.Shared/EnvironmentProvider.cs b/src/UnitTests.Shared/EnvironmentProvider.cs
index 4ca3c276867..c0a7fcaddc4 100644
--- a/src/UnitTests.Shared/EnvironmentProvider.cs
+++ b/src/UnitTests.Shared/EnvironmentProvider.cs
@@ -74,7 +74,7 @@ private IEnumerable<string> SearchPaths
             string? environmentOverride = _getEnvironmentVariable(Constants.DotnetMsbuildSdkResolverCliDir);
             if (!string.IsNullOrEmpty(environmentOverride))
             {
-                return Path.Combine(environmentOverride, Constants.DotNet + Constants.ExeSuffix);
+                return GetDotnetExePathFromFolder(environmentOverride);
             }
 
             string? dotnetExe = _getCurrentProcessPath();
@@ -105,6 +105,8 @@ private IEnumerable<string> SearchPaths
             return dotnetExe;
         }
 
+        public static string? GetDotnetExePathFromFolder(string? netRootFolder) => Path.Combine(netRootFolder ?? string.Empty, Constants.DotNet + Constants.ExeSuffix);
+
         public static string? GetDotnetExePath(Func<string, string?>? getEnvironmentVariable = null)
         {
             if (getEnvironmentVariable == null)
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index fee3abf670f..74fa38bee83 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -30,9 +30,18 @@
 
   <Import Project="..\..\eng\BootStrapMsBuild.props" />
 
+  <PropertyGroup Condition="$(TargetFramework.StartsWith('net4'))">
+    <TestBootstrapBinaryDestination>$(BootstrapDestination)Current\Bin</TestBootstrapBinaryDestination>
+  </PropertyGroup>
+
+  <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
+    <TestBootstrapBinaryDestination>$(ArtifactsBinDir)bootstrap\core</TestBootstrapBinaryDestination>
+  </PropertyGroup>
+
   <ItemGroup>
     <AssemblyAttribute Include="Microsoft.Build.UnitTests.Shared.BootstrapLocationAttribute">
-      <_Parameter1>$(BootstrapBinaryDestination)</_Parameter1>
+      <_Parameter1>$(TestBootstrapBinaryDestination)</_Parameter1>
+      <_Parameter2>$(BootstrapSdkVersion)</_Parameter2>
     </AssemblyAttribute>
   </ItemGroup>
 </Project>
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 8264bc07be9..4f76371d8b1 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -63,10 +63,10 @@ public static string ExecBootstrapedMSBuild(
             BootstrapLocationAttribute attribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
                                                    ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
 
-            string binaryFolder = attribute.BootstrapMsbuildBinaryLocation;
+            string binaryFolder = attribute.BootstrapMsBuildBinaryLocation;
 #if NET
-            string pathToExecutable = EnvironmentProvider.GetDotnetExePath()!;
-            msbuildParameters = Path.Combine(binaryFolder, "MSBuild.dll") + " " + msbuildParameters;
+            string pathToExecutable = EnvironmentProvider.GetDotnetExePathFromFolder(binaryFolder);
+            msbuildParameters = Path.Combine(binaryFolder, "sdk", attribute.BootstrapSdkVersion, "MSBuild.dll") + " " + msbuildParameters;
 #else
             string pathToExecutable = Path.Combine(binaryFolder, "MSBuild.exe");
 #endif
diff --git a/src/UnitTests.Shared/TestEnvironment.cs b/src/UnitTests.Shared/TestEnvironment.cs
index d961178b298..045fce7ffb9 100644
--- a/src/UnitTests.Shared/TestEnvironment.cs
+++ b/src/UnitTests.Shared/TestEnvironment.cs
@@ -442,6 +442,11 @@ void AssertDictionaryInclusion(IDictionary superset, IDictionary subset, string
             {
                 foreach (var key in subset.Keys)
                 {
+                    if (key is "_MSBUILDTLENABLED")
+                    {
+                        continue;
+                    }
+
                     // workaround for https://github.com/dotnet/msbuild/pull/3866
                     // if the initial environment had empty keys, then MSBuild will accidentally remove them via Environment.SetEnvironmentVariable
                     if (operation != "removed" || !string.IsNullOrEmpty((string)subset[key]))
diff --git a/src/Utilities.UnitTests/MuxLogger_Tests.cs b/src/Utilities.UnitTests/MuxLogger_Tests.cs
index ee3441facfc..db440177756 100644
--- a/src/Utilities.UnitTests/MuxLogger_Tests.cs
+++ b/src/Utilities.UnitTests/MuxLogger_Tests.cs
@@ -125,7 +125,10 @@ public void BuildWithMuxLoggerEquivalentToNormalLogger()
             mockLogger2.BuildFinishedEvents.Count.ShouldBeGreaterThan(0);
             mockLogger.BuildFinishedEvents.Count.ShouldBe(mockLogger2.BuildFinishedEvents.Count);
             mockLogger.BuildFinishedEvents[0].Succeeded.ShouldBe(mockLogger2.BuildFinishedEvents[0].Succeeded);
-            mockLogger.FullLog.ShouldBe(mockLogger2.FullLog);
+
+            // This test was changed to not compare new lines because of https://github.com/dotnet/msbuild/issues/10493
+            // It will need to be changed once we fix the root cause of the issue
+            mockLogger.FullLog.Replace(Environment.NewLine, "").ShouldBe(mockLogger2.FullLog.Replace(Environment.NewLine, ""));
         }
 
         /// <summary>
diff --git a/src/Tasks/LockCheck.cs b/src/Utilities/LockCheck.cs
similarity index 91%
rename from src/Tasks/LockCheck.cs
rename to src/Utilities/LockCheck.cs
index c2d068d33b1..c2de1dfaa65 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Utilities/LockCheck.cs
@@ -12,10 +12,14 @@
 
 #nullable disable
 
-namespace Microsoft.Build.Tasks
+namespace Microsoft.Build.Utilities
 {
-    [SupportedOSPlatform("windows")]
-    internal class LockCheck
+    /// <summary>
+    /// This class implements checking what processes are locking a file on Windows.
+    /// It uses the Restart Manager API to do this. Other platforms are skipped.
+    /// Use the method <see cref="GetLockedFileMessage"/> to get a message to inform the user which processes have a lock on a given file.
+    /// </summary>
+    public static class LockCheck
     {
         [Flags]
         internal enum ApplicationStatus
@@ -111,7 +115,7 @@ private static extern unsafe int RmStartSession(
         private static extern int RmEndSession(uint pSessionHandle);
 
         [DllImport(RestartManagerDll, CharSet = CharSet.Unicode)]
-        public static extern int RmGetList(uint dwSessionHandle,
+        internal static extern int RmGetList(uint dwSessionHandle,
             out uint pnProcInfoNeeded,
             ref uint pnProcInfo,
             [In, Out] RM_PROCESS_INFO[] rgAffectedApps,
@@ -247,21 +251,30 @@ internal static string GetProcessesLockingFile(string filePath)
         }
 
         /// <summary>
-        /// Try to get a message to inform the user which processes have a lock on a given file.
+        /// Try to get a message to inform the user which processes have a lock on a given file. On Windows it uses the Restart Manager API.
         /// </summary>
-        internal static string GetLockedFileMessage(string file)
+        /// <param name="filePath">The path of the file to check.</param>
+        /// <returns>A message to inform the user which processes have a lock on the file if known, <see cref="string.Empty"/> otherwise. Always returns <see cref="string.Empty"/> on operating systems other than Windows.</returns>
+        public static string GetLockedFileMessage(string filePath)
+        {
+            if (NativeMethodsShared.IsWindows)
+            {
+                return GetLockedFileMessageWindows(filePath);
+            }
+            return string.Empty;
+        }
+
+        [SupportedOSPlatform("windows")]
+        private static string GetLockedFileMessageWindows(string filePath)
         {
             string message = string.Empty;
 
             try
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
-                {
-                    var processes = GetProcessesLockingFile(file);
-                    message = !string.IsNullOrEmpty(processes)
-                        ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("Task.FileLocked", processes)
-                        : String.Empty;
-                }
+                var processes = GetProcessesLockingFile(filePath);
+                message = !string.IsNullOrEmpty(processes)
+                    ? ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("LockCheck.FileLocked", processes)
+                    : String.Empty;
             }
             catch (Exception)
             {
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index aac2626cb09..966c169c409 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
diff --git a/src/Utilities/Resources/Strings.resx b/src/Utilities/Resources/Strings.resx
index 1bbcf8ce260..d691fe4b3b9 100644
--- a/src/Utilities/Resources/Strings.resx
+++ b/src/Utilities/Resources/Strings.resx
@@ -293,6 +293,9 @@
   <data name="ToolTask.InvalidTerminationTimeout" xml:space="preserve">
     <value>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</value>
   </data>
+  <data name="LockCheck.FileLocked">
+    <value>The file is locked by: "{0}"</value>
+  </data>
   <!--
         The Utilities message bucket is: MSB6001 - MSB6200
 
diff --git a/src/Utilities/Resources/xlf/Strings.cs.xlf b/src/Utilities/Resources/xlf/Strings.cs.xlf
index 472924ca574..8a895210fbc 100644
--- a/src/Utilities/Resources/xlf/Strings.cs.xlf
+++ b/src/Utilities/Resources/xlf/Strings.cs.xlf
@@ -27,6 +27,11 @@
         <target state="translated">Příkaz byl ukončen s kódem {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Soubor uzamkl(a): {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Nepovedlo se najít soubor manifestu platformy v umístění {0}.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.de.xlf b/src/Utilities/Resources/xlf/Strings.de.xlf
index ae6c7f1d318..995aabdfbe9 100644
--- a/src/Utilities/Resources/xlf/Strings.de.xlf
+++ b/src/Utilities/Resources/xlf/Strings.de.xlf
@@ -27,6 +27,11 @@
         <target state="translated">Der Befehl wurde mit dem Code {0} beendet.</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Die Datei wird durch "{0}" gesperrt.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Plattform-Manifestdatei in "{0}" nicht gefunden.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.es.xlf b/src/Utilities/Resources/xlf/Strings.es.xlf
index fb3fb6346d2..a3ac640b024 100644
--- a/src/Utilities/Resources/xlf/Strings.es.xlf
+++ b/src/Utilities/Resources/xlf/Strings.es.xlf
@@ -27,6 +27,11 @@
         <target state="translated">El comando salió con el código {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">El archivo se ha bloqueado por: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: No se ha podido encontrar el archivo de manifiesto de plataforma en "{0}".</target>
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index b5081267c27..b6a4c7717de 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -27,6 +27,11 @@
         <target state="translated">La commande s'est arrêtée avec le code {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Le fichier est verrouillé par : "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Impossible de trouver le fichier manifeste de la plateforme dans "{0}".</target>
diff --git a/src/Utilities/Resources/xlf/Strings.it.xlf b/src/Utilities/Resources/xlf/Strings.it.xlf
index a6f2388b69c..4a3c4bae142 100644
--- a/src/Utilities/Resources/xlf/Strings.it.xlf
+++ b/src/Utilities/Resources/xlf/Strings.it.xlf
@@ -27,6 +27,11 @@
         <target state="translated">Uscita dal comando con codice {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Il file è bloccato da: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: il file manifesto della piattaforma non è stato trovato in "{0}".</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ja.xlf b/src/Utilities/Resources/xlf/Strings.ja.xlf
index 82696e9d9f3..b3547a59a26 100644
--- a/src/Utilities/Resources/xlf/Strings.ja.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ja.xlf
@@ -27,6 +27,11 @@
         <target state="translated">コマンドはコード {0} で終了しました。</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">このファイルは "{0}" によってロックされています。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: "{0}" にプラットフォームのマニフェスト ファイルが見つかりませんでした。</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ko.xlf b/src/Utilities/Resources/xlf/Strings.ko.xlf
index 2de87f94e2b..12567b44897 100644
--- a/src/Utilities/Resources/xlf/Strings.ko.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ko.xlf
@@ -27,6 +27,11 @@
         <target state="translated">명령이 종료되었습니다(코드: {0}).</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">파일이 "{0}"에 의해 잠겨 있습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: "{0}"에서 플랫폼 매니페스트 파일을 찾을 수 없습니다.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pl.xlf b/src/Utilities/Resources/xlf/Strings.pl.xlf
index 0be09edd704..a626748a37d 100644
--- a/src/Utilities/Resources/xlf/Strings.pl.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pl.xlf
@@ -27,6 +27,11 @@
         <target state="translated">Polecenie zostało zakończone z kodem {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Plik jest zablokowany przez: „{0}”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: nie można odnaleźć pliku manifestu platformy w lokalizacji „{0}”.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
index 031011afb81..192420e0674 100644
--- a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
@@ -27,6 +27,11 @@
         <target state="translated">O comando foi encerrado com o código {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">O arquivo é bloqueado por: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: não foi possível encontrar o arquivo de manifesto da plataforma em "{0}".</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ru.xlf b/src/Utilities/Resources/xlf/Strings.ru.xlf
index af05a69213a..e66fd0170c0 100644
--- a/src/Utilities/Resources/xlf/Strings.ru.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ru.xlf
@@ -27,6 +27,11 @@
         <target state="translated">Выход из команды с кодом "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">"{0}" блокирует этот файл</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: не удалось найти файл манифеста платформы по адресу "{0}".</target>
diff --git a/src/Utilities/Resources/xlf/Strings.tr.xlf b/src/Utilities/Resources/xlf/Strings.tr.xlf
index a2d9744fdbc..6c8baf7d49f 100644
--- a/src/Utilities/Resources/xlf/Strings.tr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.tr.xlf
@@ -27,6 +27,11 @@
         <target state="translated">Komuttan {0} koduyla çıkıldı.</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">Dosya şunun tarafından kilitlendi: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: Platform bildirim dosyası, "{0}" konumunda bulunamadı.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
index ae68e2fdab0..3528fc721db 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
@@ -27,6 +27,11 @@
         <target state="translated">命令已退出，代码为 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">文件被“{0}”锁定。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: 找不到“{0}”中的平台清单文件。</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index 347b5ed842b..a65e99a4f73 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -27,6 +27,11 @@
         <target state="translated">命令以返回碼 {0} 結束。</target>
         <note />
       </trans-unit>
+      <trans-unit id="LockCheck.FileLocked">
+        <source>The file is locked by: "{0}"</source>
+        <target state="translated">檔案鎖定者: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="PlatformManifest.MissingPlatformXml">
         <source>MSB6010: Could not find platform manifest file at "{0}".</source>
         <target state="translated">MSB6010: 在 "{0}" 找不到平台資訊清單檔案。</target>
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index a4f1f9295aa..20510c33d8b 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2460,7 +2460,7 @@ private static IEnumerable<TargetPlatformSDK> RetrieveTargetPlatformList(string[
                     var monikers = new Dictionary<TargetPlatformSDK, TargetPlatformSDK>();
                     GatherSDKListFromDirectory(sdkDiskRoots, monikers);
 
-                    if (NativeMethodsShared.IsWindows && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+                    if (NativeMethodsShared.IsWindows)
                     {
                         GatherSDKListFromRegistry(registryRoot, monikers);
                     }
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 2443ff50c43..fe6ab5d92ed 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -380,7 +380,7 @@ protected virtual void ProcessStarted() { }
         /// <returns>true, if successful</returns>
         protected internal virtual bool ValidateParameters()
         {
-            if (TaskProcessTerminationTimeout < -1 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+            if (TaskProcessTerminationTimeout < -1)
             {
                 Log.LogWarningWithCodeFromResources("ToolTask.InvalidTerminationTimeout", TaskProcessTerminationTimeout);
                 return false;
@@ -694,7 +694,7 @@ protected virtual ProcessStartInfo GetProcessStartInfo(
         /// <summary>
         /// We expect tasks to override this method if they need information about the tool process or its process events during task execution.
         /// Implementation should make sure that the task is started in this method.
-        /// Starts the process during task execution. 
+        /// Starts the process during task execution.
         /// </summary>
         /// <param name="proc">Fully populated <see cref="Process"/> instance representing the tool process to be started.</param>
         /// <returns>A started process. This could be <paramref name="proc"/> or another <see cref="Process"/> instance.</returns>
@@ -1000,7 +1000,7 @@ private void KillToolProcessOnTimeout(Process proc, bool isBeingCancelled)
                     LogShared.LogWarningWithCodeFromResources("Shared.KillingProcessByCancellation", processName);
                 }
 
-                int timeout = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && TaskProcessTerminationTimeout >= -1 ? TaskProcessTerminationTimeout : 5000;
+                int timeout = TaskProcessTerminationTimeout >= -1 ? TaskProcessTerminationTimeout : 5000;
                 string timeoutFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDTOOLTASKCANCELPROCESSWAITTIMEOUT");
                 if (timeoutFromEnvironment != null)
                 {
diff --git a/template_feed/README.md b/template_feed/README.md
index f2b021d3647..f6bd358ffcd 100644
--- a/template_feed/README.md
+++ b/template_feed/README.md
@@ -1,9 +1,9 @@
-## MSBuild Custom Analyzer Template Package
+## MSBuild Custom Check Template Package
 
-The package contains the template designed to streamline the creation of MSBuild analyzer libraries.
+The package contains the template designed to streamline the creation of MSBuild check libraries.
 | Template name | Short name | Description|
 |---|---|---|
-|MSBuild Custom Analyzer Template|`msbuildanalyzer`|A project for creating a MSBuild analyzer library that targets .NET Standard.|
+|MSBuild Custom Check Template|`msbuildcheck`|A project for creating a MSBuild check library that targets .NET Standard.|
 
 The package is available for download from nuget.org.
 Please feel to contribute or provide the feedback in discussions or via opening the issue in dotnet/msbuild repo.
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
deleted file mode 100644
index 8bd2d1853e3..00000000000
--- a/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
+++ /dev/null
@@ -1,49 +0,0 @@
-{
-    "$schema": "http://json.schemastore.org/template",
-    "author": "Microsoft",
-    "classifications": [
-      "Common",
-      "Library"
-    ],
-    "name": "MSBuild custom analyzer skeleton project.",
-    "generatorVersions": "[1.0.0.0-*)",
-    "description": "A project for creating a MSBuild analyzer library that targets .NET Standard",
-    "groupIdentity": "Microsoft.AnalyzerTemplate",
-    "identity": "Microsoft.AnalyzerTemplate",
-    "shortName": "msbuildanalyzer",
-    "tags": {
-      "language": "C#",
-      "type": "project"
-    },
-    "sourceName": "Company.AnalyzerTemplate",
-    "preferNameDirectory": true,
-    "primaryOutputs": [
-      {
-        "path": "Company.AnalyzerTemplate.csproj"
-      }
-   ],
-   "symbols": {
-    "MicrosoftBuildVersion": {
-      "type": "parameter",
-      "description": "Overrides the default Microsoft.Build version where analyzer's interfaces are placed",
-      "datatype": "text",
-      "defaultValue": "17.11.0",
-      "replaces": "1.0.0-MicrosoftBuildPackageVersion",
-      "displayName": "Microsoft.Build default package version override"
-    }
-   },
-    "postActions": [
-      {
-        "id": "restore",
-        "condition": "(!skipRestore)",
-        "description": "Restore NuGet packages required by this project.",
-        "manualInstructions": [
-          {
-            "text": "Run 'dotnet restore'"
-          }
-        ],
-        "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
-        "continueOnError": true
-      }
-    ]
-  }
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props b/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
deleted file mode 100644
index 5a606b3cac6..00000000000
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-  <ItemGroup>
-    <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
-  </ItemGroup>
-</Project>
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/README.md b/template_feed/content/Microsoft.AnalyzerTemplate/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/template_feed/content/Microsoft.AnalyzerTemplate/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
new file mode 100644
index 00000000000..3647f61a8dc
--- /dev/null
+++ b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
@@ -0,0 +1,49 @@
+{
+  "$schema": "http://json.schemastore.org/template",
+  "author": "Microsoft",
+  "classifications": [
+    "Common",
+    "Library"
+  ],
+  "name": "MSBuild custom check skeleton project.",
+  "generatorVersions": "[1.0.0.0-*)",
+  "description": "A project for creating a MSBuild check library that targets .NET Standard",
+  "groupIdentity": "Microsoft.CheckTemplate",
+  "identity": "Microsoft.CheckTemplate",
+  "shortName": "msbuildcheck",
+  "tags": {
+    "language": "C#",
+    "type": "project"
+  },
+  "sourceName": "Company.CheckTemplate",
+  "preferNameDirectory": true,
+  "primaryOutputs": [
+    {
+      "path": "Company.CheckTemplate.csproj"
+    }
+  ],
+  "symbols": {
+    "MicrosoftBuildVersion": {
+      "type": "parameter",
+      "description": "Overrides the default Microsoft.Build version where check's interfaces are placed",
+      "datatype": "text",
+      "defaultValue": "17.12.0",
+      "replaces": "1.0.0-MicrosoftBuildPackageVersion",
+      "displayName": "Microsoft.Build default package version override"
+    }
+  },
+  "postActions": [
+    {
+      "id": "restore",
+      "condition": "(!skipRestore)",
+      "description": "Restore NuGet packages required by this project.",
+      "manualInstructions": [
+        {
+          "text": "Run 'dotnet restore'"
+        }
+      ],
+      "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
+      "continueOnError": true
+    }
+  ]
+}
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/content/Microsoft.CheckTemplate/Check1.cs
similarity index 59%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
rename to template_feed/content/Microsoft.CheckTemplate/Check1.cs
index 78dae77947b..2a44afef40c 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
+++ b/template_feed/content/Microsoft.CheckTemplate/Check1.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using System.Collections.Generic;
 
-namespace Company.AnalyzerTemplate
+namespace Company.CheckTemplate
 {
-    public sealed class Analyzer1 : BuildAnalyzer
+    public sealed class Check1 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static BuildCheckRule SupportedRule = new CheckRule(
             "X01234",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new BuildCheckConfiguration());
 
-        public override string FriendlyName => "Company.Analyzer1";
+        public override string FriendlyName => "Company.Check1";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
 
@@ -28,7 +28,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
similarity index 94%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
rename to template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
index 33d8c992326..009b2ad1fe0 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
+++ b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
@@ -10,7 +10,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="Company.AnalyzerTemplate.props" Pack="true" PackagePath="build\Company.AnalyzerTemplate.props" />
+    <None Include="Company.CheckTemplate.props" Pack="true" PackagePath="build\Company.CheckTemplate.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
new file mode 100644
index 00000000000..167b0912cf7
--- /dev/null
+++ b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.CheckTemplate.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props b/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props
new file mode 100644
index 00000000000..c6d3f5fb1e5
--- /dev/null
+++ b/template_feed/content/Microsoft.CheckTemplate/Directory.Packages.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <ItemGroup>
+    <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/template_feed/content/Microsoft.CheckTemplate/README.md b/template_feed/content/Microsoft.CheckTemplate/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/template_feed/content/Microsoft.CheckTemplate/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
