diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index fe8274a6e9e..fa2b3791aea 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 
 namespace Microsoft.Build.Execution
@@ -881,7 +882,7 @@ private static bool CheckMSBuildExeExistsAt(string path)
                 return true;
             }
 
-            if (File.Exists(path))
+            if (FileSystems.Default.FileExists(path))
             {
                 s_msbuildExeKnownToExistAt = path;
                 return true;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 77f14ac3ff3..788bdf9f461 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -18,6 +18,7 @@
 
 using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
 using System.Threading.Tasks;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd
@@ -450,7 +451,7 @@ private int LaunchNode(string msbuildLocation, string commandLineArgs)
             // Should always have been set already.
             ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, "msbuildLocation");
 
-            if (!File.Exists(msbuildLocation))
+            if (!FileSystems.Default.FileExists(msbuildLocation))
             {
                 throw new BuildAbortedException(ResourceUtilities.FormatResourceString("CouldNotFindMSBuildExe", msbuildLocation));
             }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index 28c5475fe86..f75a3652197 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -8,6 +8,7 @@
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 // NOTE: This is nearly identical to the MSBuild task in Microsoft.Build.Tasks.  We are deprecating that task,
 // so this is the governing implementation.
@@ -322,7 +323,7 @@ public async Task<bool> ExecuteInternal()
                     break;
                 }
 
-                if (File.Exists(projectPath) || (_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Build))
+                if (FileSystems.Default.FileExists(projectPath) || (_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Build))
                 {
                     if (FileUtilities.IsVCProjFilename(projectPath))
                     {
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 00c3b059ad2..acb68604883 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -144,7 +145,7 @@ public void ReadPlan(int submissionId, ILoggingService loggingService, BuildEven
                 return;
             }
 
-            if (!File.Exists(planName))
+            if (!FileSystems.Default.FileExists(planName))
             {
                 return;
             }
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 4a390571255..1df8ccb387b 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -10,6 +10,7 @@
 using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -840,7 +841,7 @@ internal string GetCacheFile()
         internal void ClearCacheFile()
         {
             string cacheFile = GetCacheFile();
-            if (File.Exists(cacheFile))
+            if (FileSystems.Default.FileExists(cacheFile))
             {
                 FileUtilities.DeleteNoThrow(cacheFile);
             }
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 47e24b6fdc0..f5f5f5573da 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -8,6 +8,7 @@
 using System.IO;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Execution
 {
@@ -590,7 +591,7 @@ internal void CacheIfPossible()
         internal void ClearCachedFiles()
         {
             string resultsDirectory = TargetResult.GetCacheDirectory(_configurationId, "None" /*Does not matter because we just need the directory name not the file*/);
-            if (Directory.Exists(resultsDirectory))
+            if (FileSystems.Default.DirectoryExists(resultsDirectory))
             {
                 FileUtilities.DeleteDirectoryNoThrow(resultsDirectory, true /*recursive*/);
             }
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 29eb418968c..930cd5743bf 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using System.Diagnostics.CodeAnalysis;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Execution
 {
@@ -274,7 +275,7 @@ private static INodePacketTranslator GetResultsCacheTranslator(int configId, str
             if (direction == TranslationDirection.WriteToStream)
             {
                 Directory.CreateDirectory(Path.GetDirectoryName(cacheFile));
-                if (File.Exists(cacheFile))
+                if (FileSystems.Default.FileExists(cacheFile))
                 {
                     // If the file already exists, then we have cached this once before.  No need to cache it again since it cannot have changed.
                     return null;
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 45e43e6b165..40df42c5d47 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -17,6 +17,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Shared.FileSystem;
 #if (!STANDALONEBUILD)
 using Microsoft.Internal.Performance;
 #if MSBUILDENABLEVSPROFILING 
@@ -1589,7 +1590,7 @@ public void Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting =
         /// </summary>
         public void ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(File.Exists(path), "FileToReloadFromDoesNotExist", path);
+            ErrorUtilities.VerifyThrowInvalidOperation(FileSystems.Default.FileExists(path), "FileToReloadFromDoesNotExist", path);
 
             XmlDocumentWithLocation DocumentProducer(bool shouldPreserveFormatting) => LoadDocument(path, shouldPreserveFormatting);
             ReloadFrom(DocumentProducer, throwIfUnsavedChanges, preserveFormatting);
@@ -1861,7 +1862,7 @@ internal static bool IsEmptyXmlFile(string path)
             //
             const int maxSizeToConsiderEmpty = 100;
 
-            if (!File.Exists(path))
+            if (!FileSystems.Default.FileExists(path))
             {
                 // Non-existent files are not treated as empty
                 //
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 0a8269e5e0a..e1fbe059242 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -1008,7 +1008,7 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
                                 }
                                 else
                                 {
-                                    overrideDirectoryExists = Directory.Exists(_overrideTasksPath);
+                                    overrideDirectoryExists = FileSystems.Default.DirectoryExists(_overrideTasksPath);
                                 }
                             }
 
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 8bc2e15553e..6dfef1c027e 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -10,7 +10,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
-
+using Microsoft.Build.Shared.FileSystem;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 
@@ -257,7 +257,7 @@ private static Configuration ReadApplicationConfiguration()
             // When running from the command-line or from VS, use the msbuild.exe.config file.
             if (BuildEnvironmentHelper.Instance.Mode != BuildEnvironmentMode.None &&
                 !BuildEnvironmentHelper.Instance.RunningTests &&
-                File.Exists(BuildEnvironmentHelper.Instance.CurrentMSBuildConfigurationFile))
+                FileSystems.Default.FileExists(BuildEnvironmentHelper.Instance.CurrentMSBuildConfigurationFile))
             {
                 var configFile = new ExeConfigurationFileMap { ExeConfigFilename = BuildEnvironmentHelper.Instance.CurrentMSBuildConfigurationFile };
                 return ConfigurationManager.OpenMappedExeConfiguration(configFile, ConfigurationUserLevel.None);
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index d546e77d5fb..8a92bcb2b47 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Shared.FileSystem;
 using error = Microsoft.Build.Shared.ErrorUtilities;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
@@ -192,7 +193,7 @@ ToolsetDefinitionLocations locations
 
                         // Other toolsets are installed in the xbuild directory
                         var xbuildToolsetsDir = Path.Combine(libraryPath, $"xbuild{Path.DirectorySeparatorChar}");
-                        if (Directory.Exists(xbuildToolsetsDir))
+                        if (FileSystems.Default.DirectoryExists(xbuildToolsetsDir))
                         {
                             var r = new Regex(Regex.Escape(xbuildToolsetsDir) + @"\d+\.\d+");
                             foreach (var d in Directory.GetDirectories(xbuildToolsetsDir).Where(d => r.IsMatch(d)))
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index f2522087ef5..7c9d853280e 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -2379,7 +2379,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                         // Perhaps the import tag has a typo in, for example.
 
                         // There's a specific message for file not existing
-                        if (!File.Exists(importFileUnescaped))
+                        if (!FileSystems.Default.FileExists(importFileUnescaped))
                         {
                             bool ignoreMissingImportsFlagSet = (_loadSettings & ProjectLoadSettings.IgnoreMissingImports) != 0;
                             if (!throwOnFileNotExistsError || ignoreMissingImportsFlagSet)
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 76057e100a1..9e5b377165b 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -3,6 +3,7 @@
 using System.IO.Compression;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Logging
 {
@@ -152,7 +153,7 @@ public void Shutdown()
 
                     // It is possible that the archive couldn't be created for some reason.
                     // Only embed it if it actually exists.
-                    if (File.Exists(archiveFilePath))
+                    if (FileSystems.Default.FileExists(archiveFilePath))
                     {
                         eventArgsWriter.WriteBlob(BinaryLogRecordKind.ProjectImportArchive, File.ReadAllBytes(archiveFilePath));
                         File.Delete(archiveFilePath);
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index 44d941972df..86fe234f2b9 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -8,6 +8,7 @@
 using System.Xml.Schema;
 
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.CommandLine
 {
@@ -45,7 +46,7 @@ string binPath
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
             }
 
-            if (File.Exists(schemaFile))
+            if (FileSystems.Default.FileExists(schemaFile))
             {
                 // Print the schema file we're using, particularly since it can vary 
                 // according to the toolset being used
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 305acb0a096..c61540a14ef 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -23,7 +23,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
-
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 #if (!STANDALONEBUILD)
 using Microsoft.Internal.Performance;
@@ -252,7 +252,7 @@ private static string[] ConstructArrayArg(string[] args)
         /// </comments>
         static private void AppendOutputFile(string path, Int64 elapsedTime)
         {
-            if (!File.Exists(path))
+            if (!FileSystems.Default.FileExists(path))
             {
                 using (StreamWriter sw = File.CreateText(path))
                 {
@@ -1650,7 +1650,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
                 {
                     commandLineSwitches.SetSwitchError("MissingResponseFileError", unquotedCommandLineArg);
                 }
-                else if (!File.Exists(responseFile))
+                else if (!FileSystems.Default.FileExists(responseFile))
                 {
                     commandLineSwitches.SetParameterError("ResponseFileNotFoundError", unquotedCommandLineArg);
                 }
@@ -1851,7 +1851,7 @@ private static bool GatherAutoResponseFileSwitchesFromFullPath(string autoRespon
             bool found = false;
 
             // if the auto-response file does not exist, only use the switches on the command line
-            if (File.Exists(autoResponseFile))
+            if (FileSystems.Default.FileExists(autoResponseFile))
             {
                 found = true;
                 GatherResponseFileSwitch("@" + autoResponseFile, switchesFromAutoResponseFile);
@@ -2479,7 +2479,7 @@ DirectoryGetFiles getFiles
             {
                 projectFile = FileUtilities.FixFilePath(parameters[0]);
 
-                if (Directory.Exists(projectFile))
+                if (FileSystems.Default.DirectoryExists(projectFile))
                 {
                     // If the project file is actually a directory then change the directory to be searched
                     // and null out the project file
@@ -2488,7 +2488,7 @@ DirectoryGetFiles getFiles
                 }
                 else
                 {
-                    InitializationException.VerifyThrow(File.Exists(projectFile), "ProjectNotFoundError", projectFile);
+                    InitializationException.VerifyThrow(FileSystems.Default.FileExists(projectFile), "ProjectNotFoundError", projectFile);
                 }
             }
 
@@ -3275,7 +3275,7 @@ private static LoggerDescription ParseLoggingParameter(string parameter, string
 
             // figure out whether the assembly's identity (strong/weak name), or its filename/path is provided
             string testFile = FileUtilities.FixFilePath(loggerAssemblySpec);
-            if (File.Exists(testFile))
+            if (FileSystems.Default.FileExists(testFile))
             {
                 loggerAssemblyFile = testFile;
             }
@@ -3426,7 +3426,7 @@ private static string ProcessValidateSwitch(string[] parameters)
             {
                 InitializationException.VerifyThrow(schemaFile == null, "MultipleSchemasError", parameter);
                 string fileName = FileUtilities.FixFilePath(parameter);
-                InitializationException.VerifyThrow(File.Exists(fileName), "SchemaNotFoundError", fileName);
+                InitializationException.VerifyThrow(FileSystems.Default.FileExists(fileName), "SchemaNotFoundError", fileName);
 
                 schemaFile = Path.Combine(Directory.GetCurrentDirectory(), fileName);
             }
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 969f8e6593e..567c177122b 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -8,6 +8,7 @@
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
 using System.Threading;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
 {
@@ -191,8 +192,8 @@ private static BuildEnvironment TryFromMSBuildAssembly()
 
             // We're not in VS, check for MSBuild.exe / dll to consider this a standalone environment.
             string msBuildPath = null;
-            if (File.Exists(msBuildExe)) msBuildPath = msBuildExe;
-            else if (File.Exists(msBuildDll)) msBuildPath = msBuildDll;
+            if (FileSystems.Default.FileExists(msBuildExe)) msBuildPath = msBuildExe;
+            else if (FileSystems.Default.FileExists(msBuildDll)) msBuildPath = msBuildDll;
 
             if (!string.IsNullOrEmpty(msBuildPath))
             {
@@ -215,7 +216,7 @@ private static BuildEnvironment TryFromMSBuildAssemblyUnderVisualStudio(string m
                 Regex.IsMatch(msbuildAssembly, $@".*\\MSBuild\\{CurrentToolsVersion}\\Bin\\.*", RegexOptions.IgnoreCase))
             {
                 // In a Visual Studio path we must have MSBuild.exe
-                if (File.Exists(msbuildExe))
+                if (FileSystems.Default.FileExists(msbuildExe))
                 {
                     return new BuildEnvironment(
                         BuildEnvironmentMode.VisualStudio,
@@ -243,7 +244,7 @@ private static BuildEnvironment TryFromDevConsole()
             var vsVersion = s_getEnvironmentVariable("VisualStudioVersion");
 
             if (string.IsNullOrEmpty(vsInstallDir) || string.IsNullOrEmpty(vsVersion) ||
-                vsVersion != CurrentVisualStudioVersion || !Directory.Exists(vsInstallDir)) return null;
+                vsVersion != CurrentVisualStudioVersion || !FileSystems.Default.DirectoryExists(vsInstallDir)) return null;
 
             return new BuildEnvironment(
                 BuildEnvironmentMode.VisualStudio,
@@ -264,7 +265,7 @@ private static BuildEnvironment TryFromSetupApi()
 
             Version v = new Version(CurrentVisualStudioVersion);
             var instances = s_getVisualStudioInstances()
-                .Where(i => i.Version.Major == v.Major && Directory.Exists(i.Path))
+                .Where(i => i.Version.Major == v.Major && FileSystems.Default.DirectoryExists(i.Path))
                 .ToList();
 
             if (instances.Count == 0) return null;
@@ -300,7 +301,7 @@ private static BuildEnvironment TryFromAppContextBaseDirectory()
 
         private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePath)
         {
-            if (!string.IsNullOrEmpty(msBuildExePath) && File.Exists(msBuildExePath))
+            if (!string.IsNullOrEmpty(msBuildExePath) && FileSystems.Default.FileExists(msBuildExePath))
             {
                 // MSBuild.exe was found outside of Visual Studio. Assume Standalone mode.
                 return new BuildEnvironment(
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index d538c7a09e6..18ab7163f70 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -6,6 +6,7 @@
 using System.IO;
 using System.Reflection;
 using System.Runtime.Loader;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
 {
@@ -117,7 +118,7 @@ private Assembly TryResolveAssembly(AssemblyLoadContext context, AssemblyName as
                                 cultureSubfolder,
                                 $"{assemblyName.Name}.{extension}");
                             if (IsAssemblyAlreadyLoaded(candidatePath) ||
-                                !File.Exists(candidatePath))
+                                !FileSystems.Default.FileExists(candidatePath))
                             {
                                 continue;
                             }
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index 29e7add0515..e9417f5ae71 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -14,6 +14,7 @@ namespace Microsoft.Build.AppxPackage.Shared
 using System.Security;
 using System.Threading;
 using System.Xml;
+using Microsoft.Build.Shared.FileSystem;
 #if FEATURE_VARIOUS_EXCEPTIONS
 using System.Xml.Schema;
 using System.Runtime.Serialization;
@@ -324,7 +325,7 @@ internal static void DumpExceptionToFile(Exception ex)
 
                     // For some reason we get Watson buckets because GetTempPath gives us a folder here that doesn't exist.
                     // Either because %TMP% is misdefined, or because they deleted the temp folder during the build.
-                    if (!Directory.Exists(DebugDumpPath))
+                    if (!FileSystems.Default.DirectoryExists(DebugDumpPath))
                     {
                         // If this throws, no sense catching it, we can't log it now, and we're here
                         // because we're a child node with no console to log to, so die
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index ac2d3d37588..1c5918e58bb 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -155,7 +155,7 @@ internal static void ClearCacheDirectory()
         {
             string cacheDirectory = GetCacheDirectory();
 
-            if (Directory.Exists(cacheDirectory))
+            if (DefaultFileSystem.DirectoryExists(cacheDirectory))
             {
                 DeleteDirectoryNoThrow(cacheDirectory, true);
             }
@@ -417,13 +417,13 @@ internal static bool LooksLikeUnixFilePath(string value, string baseDirectory =
                 firstSlash = value.Substring(1).IndexOf('/') + 1;
             }
 
-            if (firstSlash > 0 && Directory.Exists(Path.Combine(baseDirectory, value.Substring(0, firstSlash))))
+            if (firstSlash > 0 && DefaultFileSystem.DirectoryExists(Path.Combine(baseDirectory, value.Substring(0, firstSlash))))
             {
                 return true;
             }
 
             // Check for actual files or directories under / that get missed by the above logic
-            if (firstSlash == 0 && value[0] == '/' && (Directory.Exists(value) || File.Exists(value)))
+            if (firstSlash == 0 && value[0] == '/' && DefaultFileSystem.DirectoryEntryExists(value))
             {
                 return true;
             }
@@ -640,7 +640,7 @@ internal static void DeleteDirectoryNoThrow(string path, bool recursive, int ret
             {
                 try
                 {
-                    if (Directory.Exists(path))
+                    if (DefaultFileSystem.DirectoryExists(path))
                     {
                         Directory.Delete(path, recursive);
                         break;
@@ -1150,7 +1150,7 @@ internal static string GetDirectoryNameOfFileAbove(string startingDirectory, str
                 // If we successfully locate the file in the directory that we're
                 // looking in, simply return that location. Otherwise we'll
                 // keep moving up the tree.
-                if (File.Exists(possibleFileDirectory))
+                if (DefaultFileSystem.FileExists(possibleFileDirectory))
                 {
                     // We've found the file, return the directory we found it in
                     return lookInDirectory;
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 4c972f5d1dc..f213d87d771 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -19,6 +19,7 @@
 #endif
 using System.Reflection;
 using System.Runtime.InteropServices;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
 {
@@ -864,7 +865,7 @@ internal static string GenerateProgramFilesReferenceAssemblyRoot()
             if (!String.IsNullOrEmpty(combinedPath))
             {
                 combinedPath = Path.GetFullPath(combinedPath);
-                if (Directory.Exists(combinedPath))
+                if (FileSystems.Default.DirectoryExists(combinedPath))
                 {
                     return combinedPath;
                 }
@@ -1041,7 +1042,7 @@ private static string GenerateReferenceAssemblyDirectory(string versionPrefix)
             string programFilesReferenceAssemblyDirectory = Path.Combine(programFilesReferenceAssemblyLocation, versionPrefix);
             string referenceAssemblyDirectory = null;
 
-            if (Directory.Exists(programFilesReferenceAssemblyDirectory))
+            if (FileSystems.Default.DirectoryExists(programFilesReferenceAssemblyDirectory))
             {
                 referenceAssemblyDirectory = programFilesReferenceAssemblyDirectory;
             }
@@ -1339,7 +1340,7 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                 // .net was improperly uninstalled: msbuild.exe isn't there
                 if (this._hasMsBuild &&
                     generatedPathToDotNetFramework != null &&
-                    !File.Exists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")))
+                    !FileSystems.Default.FileExists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")))
                 {
                     return null;
                 }
@@ -1375,7 +1376,7 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
                         frameworkPath = Path.Combine(frameworkPath, this.Version.ToString());
                     }
 
-                    if (!string.IsNullOrEmpty(frameworkPath) && Directory.Exists(frameworkPath))
+                    if (!string.IsNullOrEmpty(frameworkPath) && FileSystems.Default.DirectoryExists(frameworkPath))
                     {
                         generatedPathToDotNetFrameworkSdkTools = frameworkPath;
                     }
@@ -1477,7 +1478,7 @@ public virtual string GetPathToDotNetFrameworkReferenceAssemblies()
                     // when a user requests the 40 reference assembly path we don't need to read the redist list because we will not be chaining so we may as well just
                     // generate the path and save us some time.
                     string referencePath = GenerateReferenceAssemblyPath(FrameworkLocationHelper.programFilesReferenceAssemblyLocation, this.FrameworkName);
-                    if (Directory.Exists(referencePath))
+                    if (FileSystems.Default.DirectoryExists(referencePath))
                     {
                         this._pathToDotNetFrameworkReferenceAssemblies = FileUtilities.EnsureTrailingSlash(referencePath);
                     }
diff --git a/src/Shared/InprocTrackingNativeMethods.cs b/src/Shared/InprocTrackingNativeMethods.cs
index 250d599cf98..d3057c584f0 100644
--- a/src/Shared/InprocTrackingNativeMethods.cs
+++ b/src/Shared/InprocTrackingNativeMethods.cs
@@ -10,6 +10,7 @@
 using System.Runtime.ConstrainedExecution;
 #endif
 using System.Security;
+using Microsoft.Build.Shared.FileSystem;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -207,7 +208,7 @@ private static void LoadFileTrackerDll()
                 string buildToolsPath = FrameworkLocationHelper.GeneratePathToBuildToolsForToolsVersion(MSBuildConstants.CurrentToolsVersion, DotNetFrameworkArchitecture.Current);
                 string fileTrackerPath = Path.Combine(buildToolsPath, fileTrackerDllName.Value);
 
-                if (!File.Exists(fileTrackerPath))
+                if (!FileSystems.Default.FileExists(fileTrackerPath))
                 {
                     throw new DllNotFoundException(fileTrackerDllName.Value);
                 }
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index 509d70772e3..0f97710e210 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -15,6 +15,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
 {
@@ -529,7 +530,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         // to unescape first.
                         string unescapedItemSpec = EscapingUtilities.UnescapeAll(itemSpec);
 
-                        if (File.Exists(unescapedItemSpec))
+                        if (FileSystems.Default.FileExists(unescapedItemSpec))
                         {
                             modifiedItemSpec = File.GetCreationTime(unescapedItemSpec).ToString(FileTimeFormat, null);
                         }
@@ -545,7 +546,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                         // to unescape first.
                         string unescapedItemSpec = EscapingUtilities.UnescapeAll(itemSpec);
 
-                        if (File.Exists(unescapedItemSpec))
+                        if (FileSystems.Default.FileExists(unescapedItemSpec))
                         {
                             modifiedItemSpec = File.GetLastAccessTime(unescapedItemSpec).ToString(FileTimeFormat, null);
                         }
diff --git a/src/Shared/TaskEngineAssemblyResolver.cs b/src/Shared/TaskEngineAssemblyResolver.cs
index 10d55873287..91aef3e99f7 100644
--- a/src/Shared/TaskEngineAssemblyResolver.cs
+++ b/src/Shared/TaskEngineAssemblyResolver.cs
@@ -11,6 +11,7 @@
 using System.Runtime.Loader;
 #endif
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -101,7 +102,7 @@ private Assembly ResolveAssembly(AssemblyLoadContext assemblyLoadContext, Assemb
             // Is this our task assembly?
             if (_taskAssemblyFile != null)
             {
-                if (File.Exists(_taskAssemblyFile))
+                if (FileSystems.Default.FileExists(_taskAssemblyFile))
                 {
                     try
                     {
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index b8c5ea329af..7a53225e159 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -4,6 +4,7 @@
 using System;
 using System.IO;
 using System.Runtime.CompilerServices;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
 {
@@ -91,7 +92,7 @@ internal static string GetTemporaryFile(string directory, string extension, bool
 
                 string file = Path.Combine(directory, $"tmp{Guid.NewGuid():N}{extension}");
 
-                ErrorUtilities.VerifyThrow(!File.Exists(file), "Guid should be unique");
+                ErrorUtilities.VerifyThrow(!FileSystems.Default.FileExists(file), "Guid should be unique");
 
                 if (createFile)
                 {
@@ -133,7 +134,7 @@ public TempWorkingDirectory(string sourcePath, [CallerMemberName] string name =
                     ? GetTemporaryDirectory()
                     : System.IO.Path.Combine(System.IO.Path.GetTempPath(), name);
 
-                if (Directory.Exists(Path))
+                if (FileSystems.Default.DirectoryExists(Path))
                 {
                     Directory.Delete(Path, true);
                 }
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 7b697faeab7..53ed7e01fb3 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -9,6 +9,7 @@
 using System.IO;
 using System.Reflection;
 using System.Threading;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
 {
@@ -168,7 +169,7 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
                     var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
                         Path.GetFileName(assemblyLoadInfo.AssemblyFile));
 
-                    if (File.Exists(assemblyNameInExecutableDirectory))
+                    if (FileSystems.Default.FileExists(assemblyNameInExecutableDirectory))
                     {
                         var simpleName = Path.GetFileNameWithoutExtension(assemblyLoadInfo.AssemblyFile);
                         loadedAssembly = Assembly.Load(new AssemblyName(simpleName));
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index b20f56ec391..44bc4fd9d9b 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -17,6 +17,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
@@ -530,7 +531,7 @@ internal static void AssertFileExistsInTempProjectDirectory(string fileRelativeP
                 message = fileRelativePath + " doesn't exist, but it should.";
             }
 
-            Assert.True(File.Exists(Path.Combine(TempProjectDir, fileRelativePath)), message);
+            Assert.True(FileSystems.Default.FileExists(Path.Combine(TempProjectDir, fileRelativePath)), message);
         }
 
         /// <summary>
@@ -816,7 +817,7 @@ internal static void DeleteDirectory(string dir)
             {
                 try
                 {
-                    if (Directory.Exists(dir))
+                    if (FileSystems.Default.DirectoryExists(dir))
                     {
                         foreach (string directory in Directory.GetDirectories(dir))
                         {
@@ -1031,7 +1032,7 @@ internal static void DeleteTempFiles(string[] files)
         {
             for (int i = 0; i < files.Length; i++)
             {
-                if (File.Exists(files[i])) File.Delete(files[i]);
+                if (FileSystems.Default.FileExists(files[i])) File.Delete(files[i]);
             }
         }
 
@@ -1462,7 +1463,7 @@ internal static string[] CreateFilesInDirectory(string rootDirectory, params str
                 return null;
             }
 
-            Assert.True(Directory.Exists(rootDirectory), $"Directory {rootDirectory} does not exist");
+            Assert.True(FileSystems.Default.DirectoryExists(rootDirectory), $"Directory {rootDirectory} does not exist");
 
             var result = new string[files.Length];
 
@@ -1479,10 +1480,10 @@ internal static string[] CreateFilesInDirectory(string rootDirectory, params str
                 var directoryName = Path.GetDirectoryName(fullPath);
 
                 Directory.CreateDirectory(directoryName);
-                Assert.True(Directory.Exists(directoryName));
+                Assert.True(FileSystems.Default.DirectoryExists(directoryName));
 
                 File.WriteAllText(fullPath, string.Empty);
-                Assert.True(File.Exists(fullPath));
+                Assert.True(FileSystems.Default.FileExists(fullPath));
 
                 result[i] = fullPath;
             }
@@ -1514,13 +1515,13 @@ internal static void DeleteFiles(params string[] paths)
         {
             foreach (string path in paths)
             {
-                if (File.Exists(path))
+                if (FileSystems.Default.FileExists(path))
                 {
                     File.Delete(path);
                 }
 
                 string directory = Path.GetDirectoryName(path);
-                if (Directory.Exists(directory) && (Directory.GetFileSystemEntries(directory).Length == 0))
+                if (FileSystems.Default.DirectoryExists(directory) && (Directory.GetFileSystemEntries(directory).Length == 0))
                 {
                     Directory.Delete(directory);
                 }
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index fef900ac3a1..4ce8b02ae0e 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -5,6 +5,7 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Xml.Linq;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.UnitTests;
 using Xunit;
 
@@ -84,7 +85,7 @@ private static void SetDotnetHostPath(TestEnvironment testEnvironment)
         while (currentFolder != null)
         {
             string potentialVersionsPropsPath = Path.Combine(currentFolder, "build", "Versions.props");
-            if (File.Exists(potentialVersionsPropsPath))
+            if (FileSystems.Default.FileExists(potentialVersionsPropsPath))
             {
                 var doc = XDocument.Load(potentialVersionsPropsPath);
                 var ns = doc.Root.Name.Namespace;
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index da5464dcbfa..0e3079821c7 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -9,6 +9,7 @@
 using System.Linq;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -266,7 +267,7 @@ public TransientTestFolder CreateFolder(string folderPath = null, bool createFol
         {
             var folder = WithTransientTestState(new TransientTestFolder(folderPath, createFolder));
 
-            Assert.True(!(createFolder ^ Directory.Exists(folder.FolderPath)));
+            Assert.True(!(createFolder ^ FileSystems.Default.DirectoryExists(folder.FolderPath)));
 
             return folder;
         }
@@ -534,7 +535,7 @@ public override void Revert()
             {
                 if (_expectedAsOutput)
                 {
-                    Assert.True(File.Exists(Path), $"A file expected as an output does not exist: {Path}");
+                    Assert.True(FileSystems.Default.FileExists(Path), $"A file expected as an output does not exist: {Path}");
                 }
             }
             finally
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 4766031c628..f5bba332f0b 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -5,6 +5,7 @@
 using System.IO;
 
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -303,7 +304,7 @@ protected override string GenerateFullPathToTool()
                 pathToTool = ToolLocationHelper.GetPathToDotNetFrameworkFile(ToolExe, TargetDotNetFrameworkVersion.Latest);
             }
 
-            if (String.IsNullOrEmpty(pathToTool) || !File.Exists(pathToTool))
+            if (String.IsNullOrEmpty(pathToTool) || !FileSystems.Default.FileExists(pathToTool))
             {
                 pathToTool = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, ProcessorArchitecture.CurrentProcessArchitecture, SdkToolsPath, ToolExe, Log, true);
             }
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index 2e9f83d0cec..2cffd6254a4 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -10,6 +10,7 @@
 using System.Threading.Tasks;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 using ProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 
@@ -128,7 +129,7 @@ private void LazyInitialize()
                     {
                         // This should never happen. Microsoft.Common.CurrentVersion.targets will not specify a AssemblyFoldersFromConfig search path
                         // if the specified (or default) file is not found.
-                        ErrorUtilities.VerifyThrow(File.Exists(_assemblyFolderConfigFile),
+                        ErrorUtilities.VerifyThrow(FileSystems.Default.FileExists(_assemblyFolderConfigFile),
                             $"The AssemblyFolders config file specified does not exist: {_assemblyFolderConfigFile}");
 
                         try
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 10f37ef326a..36c1642828d 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -13,6 +13,7 @@
 using System.Text;
 
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 #if !FEATURE_ASSEMBLY_LOADFROM || MONO
 using System.Reflection.PortableExecutable;
 using System.Reflection.Metadata;
@@ -94,7 +95,7 @@ private static Assembly ReflectionOnlyAssemblyResolve(object sender, ResolveEven
 
                 try
                 {
-                    if (File.Exists(newLocation))
+                    if (FileSystems.Default.FileExists(newLocation))
                     {
                         assembly = Assembly.ReflectionOnlyLoadFrom(newLocation);
                     }
@@ -817,7 +818,7 @@ public static string GetRuntimeVersion(string path)
         {
             using (var sr = new BinaryReader(File.OpenRead(path)))
             {
-                if (!File.Exists(path))
+                if (!FileSystems.Default.FileExists(path))
                 {
                     return string.Empty;
                 }
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 0a64f0a899e..7014c037a74 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Reflection;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -103,7 +104,7 @@ public override bool Execute()
 
             var writeOutput = true;
 
-            if(File.Exists(OutputAppConfigFile.ItemSpec))
+            if(FileSystems.Default.FileExists(OutputAppConfigFile.ItemSpec))
             {
                 try
                 {
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index 390a7d3a3af..d6d3e0ae209 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -6,6 +6,7 @@
 using System.IO;
 using System.Collections.Generic;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Win32;
 
 namespace Microsoft.Build.Tasks
@@ -65,7 +66,7 @@ Dictionary<string, string> directories
                             if (product.ValueCount > 0)
                             {
                                 string folder = (string)product.GetValue("");
-                                if (Directory.Exists(folder))
+                                if (FileSystems.Default.DirectoryExists(folder))
                                 {
                                     string regkeyAlias = aliasKey + "\\" + productName;
                                     directories[regkeyAlias] = folder;
diff --git a/src/Tasks/AxTlbBaseReference.cs b/src/Tasks/AxTlbBaseReference.cs
index bea3cab734b..39f3871bcf1 100644
--- a/src/Tasks/AxTlbBaseReference.cs
+++ b/src/Tasks/AxTlbBaseReference.cs
@@ -8,6 +8,7 @@
 using System.Text;
 
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -122,7 +123,7 @@ internal override bool FindExistingWrapper(out ComReferenceWrapperInfo wrapperIn
             string wrapperPath = GetWrapperPath();
 
             // now see if the wrapper assembly actually exists
-            if (!File.Exists(wrapperPath))
+            if (!FileSystems.Default.FileExists(wrapperPath))
             {
                 return false;
             }
@@ -144,7 +145,7 @@ protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, Da
             }
 
             // if wrapper doesn't exist, wrapper is obviously not up to date
-            if (!File.Exists(wrapperInfo.path))
+            if (!FileSystems.Default.FileExists(wrapperInfo.path))
             {
                 return false;
             }
diff --git a/src/Tasks/AxTlbBaseTask.cs b/src/Tasks/AxTlbBaseTask.cs
index 6adac846bce..06937af99a7 100644
--- a/src/Tasks/AxTlbBaseTask.cs
+++ b/src/Tasks/AxTlbBaseTask.cs
@@ -4,6 +4,7 @@
 using System;
 using System.IO;
 using System.Reflection;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -127,8 +128,8 @@ protected override bool ValidateParameters()
         {
             // Verify that a path for the tool exists -- if the tool doesn't exist in it 
             // we'll worry about that later
-            if ((String.IsNullOrEmpty(ToolPath) || !Directory.Exists(ToolPath)) &&
-                (String.IsNullOrEmpty(SdkToolsPath) || !Directory.Exists(SdkToolsPath)))
+            if ((String.IsNullOrEmpty(ToolPath) || !FileSystems.Default.DirectoryExists(ToolPath)) &&
+                (String.IsNullOrEmpty(SdkToolsPath) || !FileSystems.Default.DirectoryExists(SdkToolsPath)))
             {
                 Log.LogErrorWithCodeFromResources("AxTlbBaseTask.SdkOrToolPathNotSpecifiedOrInvalid", SdkToolsPath ?? "", ToolPath ?? "");
                 return false;
@@ -181,7 +182,7 @@ private bool ValidateStrongNameParameters()
             // Make sure that if KeyFile is defined, it's a real file.
             if (!String.IsNullOrEmpty(KeyFile))
             {
-                if (File.Exists(KeyFile))
+                if (FileSystems.Default.FileExists(KeyFile))
                 {
                     keyFileExists = true;
                 }
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index aed21ea2d9c..9643e6b811a 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -16,6 +16,7 @@
 using System.Xml;
 using System.Xml.XPath;
 using System.Xml.Xsl;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
 {
@@ -352,7 +353,7 @@ private bool CopySetupToOutputDirectory(BuildSettings settings, string strOutput
             string bootstrapperPath = BootstrapperPath;
             string setupSourceFile = System.IO.Path.Combine(bootstrapperPath, SETUP_BIN);
 
-            if (!File.Exists(setupSourceFile))
+            if (!FileSystems.Default.FileExists(setupSourceFile))
             {
                 _results.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.MissingSetupBin", SETUP_BIN, bootstrapperPath));
                 return false;
@@ -511,13 +512,13 @@ private void RefreshResources()
             string startDirectory = System.IO.Path.Combine(BootstrapperPath, RESOURCES_PATH);
             _cultures.Clear();
 
-            if (Directory.Exists(startDirectory))
+            if (FileSystems.Default.DirectoryExists(startDirectory))
             {
                 foreach (string subDirectory in Directory.GetDirectories(startDirectory))
                 {
                     string resourceDirectory = System.IO.Path.Combine(startDirectory, subDirectory);
                     string resourceFile = System.IO.Path.Combine(resourceDirectory, SETUP_RESOURCES_FILE);
-                    if (File.Exists(resourceFile))
+                    if (FileSystems.Default.FileExists(resourceFile))
                     {
                         var resourceDoc = new XmlDocument();
                         try
@@ -577,7 +578,7 @@ private void RefreshProducts()
             XmlElement rootElement = _document.CreateElement("Products", BOOTSTRAPPER_NAMESPACE);
             string packagePath = PackagePath;
 
-            if (Directory.Exists(packagePath))
+            if (FileSystems.Default.DirectoryExists(packagePath))
             {
                 foreach (string strSubDirectory in Directory.GetDirectories(packagePath))
                 {
@@ -784,8 +785,8 @@ private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFil
                 // set up our validation logic by detecting the trace-switch enabled and whether or
                 //   not our files exist.
                 bool validate = true;
-                bool fileExists = File.Exists(filePath);
-                bool schemaExists = File.Exists(schemaPath);
+                bool fileExists = FileSystems.Default.FileExists(filePath);
+                bool schemaExists = FileSystems.Default.FileExists(schemaPath);
 
                 // if we're being asked to validate but we can't find the schema file, then
                 //   output something useful to tell user that we can't find the schema.
@@ -949,7 +950,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement)
                                 string strLangManifestFilename = System.IO.Path.Combine(strLanguageDirectory, CHILD_MANIFEST_FILE);
                                 string strLangManifestSchemaFileName = System.IO.Path.Combine(SchemaPath, MANIFEST_FILE_SCHEMA);
 
-                                if (File.Exists(strLangManifestFilename))
+                                if (FileSystems.Default.FileExists(strLangManifestFilename))
                                 {
                                     // Load Package.xml
                                     XmlValidationResults packageValidationResults = new XmlValidationResults(strLangManifestFilename);
@@ -1458,7 +1459,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                         {
                             if (resourceUpdater != null)
                             {
-                                if (!File.Exists(packageFileSource.Value))
+                                if (!FileSystems.Default.FileExists(packageFileSource.Value))
                                 {
                                     _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.PackageResourceFileNotFound", packageFileSource.Value, builder.Name));
                                     fSucceeded = false;
@@ -1476,7 +1477,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                                     string strDestinationFileName = System.IO.Path.Combine(settings.OutputPath, packageFileDestination.Value);
                                     try
                                     {
-                                        if (!File.Exists(packageFileSource.Value))
+                                        if (!FileSystems.Default.FileExists(packageFileSource.Value))
                                         {
                                             _results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Error, "GenerateBootstrapper.PackageFileNotFound", packageFileDestination.Value, builder.Name));
                                             fSucceeded = false;
@@ -1529,7 +1530,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                 // Add the Eula attribute correctly
                 if (eulas != null && !String.IsNullOrEmpty(eulaAttribute?.Value))
                 {
-                    if (File.Exists(eulaAttribute.Value))
+                    if (FileSystems.Default.FileExists(eulaAttribute.Value))
                     {
                         string key = GetFileHash(eulaAttribute.Value);
                         if (eulas.TryGetValue(key, out KeyValuePair<string, string> eulaInfo))
@@ -1587,7 +1588,7 @@ private static string ReadAttribute(XmlNode node, string strAttributeName)
 
         private static void EnsureFolderExists(string strFolderPath)
         {
-            if (!Directory.Exists(strFolderPath))
+            if (!FileSystems.Default.DirectoryExists(strFolderPath))
             {
                 Directory.CreateDirectory(strFolderPath);
             }
@@ -2045,7 +2046,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
             XmlAttribute hashAttribute = packageFileNode.Attributes[HASH_ATTRIBUTE];
             XmlAttribute publicKeyAttribute = packageFileNode.Attributes[PUBLICKEY_ATTRIBUTE];
 
-            if (File.Exists(fileSource))
+            if (FileSystems.Default.FileExists(fileSource))
             {
                 string publicKey = GetPublicKeyOfFile(fileSource);
                 if (hashAttribute == null && publicKeyAttribute == null)
@@ -2111,7 +2112,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
 
         private static string GetPublicKeyOfFile(string fileSource)
         {
-            if (File.Exists(fileSource))
+            if (FileSystems.Default.FileExists(fileSource))
             {
                 try
                 {
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 7924f390287..d718bfdad0d 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -637,7 +638,7 @@ private void AddReferenceAssemblyToReferenceList(List<string> referenceAssemblyL
                 {
                     try
                     {
-                        bool fileExists = File.Exists(referenceAssembly);
+                        bool fileExists = FileSystems.Default.FileExists(referenceAssembly);
                         if (!fileExists)
                         {
                             if (!referenceAssembly.EndsWith(".dll", StringComparison.OrdinalIgnoreCase) || !referenceAssembly.EndsWith(".exe", StringComparison.OrdinalIgnoreCase))
@@ -657,10 +658,10 @@ private void AddReferenceAssemblyToReferenceList(List<string> referenceAssemblyL
                                         NativeMethodsShared.FrameworkCurrentPath,
                                         "Facades",
                                         Path.GetFileName(referenceAssembly));
-                                    if (!File.Exists(path))
+                                    if (!FileSystems.Default.FileExists(path))
                                     {
                                         var newPath = path + ".dll";
-                                        path = !File.Exists(newPath) ? path + ".exe" : newPath;
+                                        path = !FileSystems.Default.FileExists(newPath) ? path + ".exe" : newPath;
                                     }
                                     candidateAssembly = Assembly.UnsafeLoadFrom(path);
                                     if (candidateAssembly != null)
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 3ca42c108ea..3c44e727b7c 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -225,7 +226,7 @@ FileState destinationFileState  // The destination file
 
             if (!string.IsNullOrEmpty(destinationFolder) && !_directoriesKnownToExist.ContainsKey(destinationFolder))
             {
-                if (!Directory.Exists(destinationFolder))
+                if (!FileSystems.Default.DirectoryExists(destinationFolder))
                 {
                     Log.LogMessageFromResources(MessageImportance.Normal, "Copy.CreatesDirectory", destinationFolder);
                     Directory.CreateDirectory(destinationFolder);
@@ -761,7 +762,7 @@ e is NotSupportedException || // Colon in the middle of the path
                         }
                     }
 
-                    if (e is IOException && DestinationFolder != null && File.Exists(DestinationFolder.ItemSpec))
+                    if (e is IOException && DestinationFolder != null && FileSystems.Default.FileExists(DestinationFolder.ItemSpec))
                     {
                         // We failed to create the DestinationFolder because it's an existing file. No sense retrying.
                         // We don't check for this case upstream because it'd be another hit to the filesystem.
diff --git a/src/Tasks/Delete.cs b/src/Tasks/Delete.cs
index 9bbb55ea8ba..0e14335050c 100644
--- a/src/Tasks/Delete.cs
+++ b/src/Tasks/Delete.cs
@@ -6,6 +6,7 @@
 using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -72,7 +73,7 @@ public override bool Execute()
                     // For speed, eliminate duplicates caused by poor targets authoring
                     if (!deletedFilesSet.Contains(file.ItemSpec))
                     {
-                        if (File.Exists(file.ItemSpec))
+                        if (FileSystems.Default.FileExists(file.ItemSpec))
                         {
                             // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
                             Log.LogMessageFromResources(MessageImportance.Normal, "Delete.DeletingFile", file.ItemSpec);
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index ce8c8f44f55..67b4b936a7c 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -5,6 +5,7 @@
 using System.IO;
 
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -58,7 +59,7 @@ internal DependencyFile(string filename)
         {
             this.filename = FileUtilities.FixFilePath(filename);
 
-            if (File.Exists(FileName))
+            if (FileSystems.Default.FileExists(FileName))
             {
                 lastModified = File.GetLastWriteTime(FileName);
                 exists = true;
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index a77de72294b..0e9070cd62b 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -8,6 +8,7 @@
 using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -520,7 +521,7 @@ protected override string GenerateFullPathToTool()
                 // Work around https://github.com/Microsoft/msbuild/issues/2273 and
                 // https://github.com/dotnet/corefx/issues/19110, which result in
                 // a bad path being returned above on Nano Server SKUs of Windows.
-                if (!File.Exists(systemCmd))
+                if (!FileSystems.Default.FileExists(systemCmd))
                 {
                     return Environment.GetEnvironmentVariable("ComSpec");
                 }
@@ -545,7 +546,7 @@ protected override string GetWorkingDirectory()
             // If the working directory is UNC, we're going to use "pushd" in the batch file to set it.
             // If it's invalid, pushd won't fail: it will just go ahead and use the system folder.
             // So verify it's valid here.
-            if (!Directory.Exists(_workingDirectory))
+            if (!FileSystems.Default.DirectoryExists(_workingDirectory))
             {
                 throw new DirectoryNotFoundException(ResourceUtilities.FormatResourceString("Exec.InvalidWorkingDirectory", _workingDirectory));
             }
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index 735e4d6d4f2..143edeaa254 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -7,6 +7,7 @@
 using System.Security.Cryptography;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -68,7 +69,7 @@ public override bool Execute()
 
             foreach (var file in Files)
             {
-                if (!File.Exists(file.ItemSpec))
+                if (!FileSystems.Default.FileExists(file.ItemSpec))
                 {
                     Log.LogErrorFromResources("FileHash.FileNotFound", file.ItemSpec);
                 }
diff --git a/src/Tasks/FileIO/ReadLinesFromFile.cs b/src/Tasks/FileIO/ReadLinesFromFile.cs
index 43ecea0cc01..7b01578a1e0 100644
--- a/src/Tasks/FileIO/ReadLinesFromFile.cs
+++ b/src/Tasks/FileIO/ReadLinesFromFile.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -35,7 +36,7 @@ public override bool Execute()
             bool success = true;
             if (File != null)
             {
-                if (System.IO.File.Exists(File.ItemSpec))
+                if (FileSystems.Default.FileExists(File.ItemSpec))
                 {
                     try
                     {
diff --git a/src/Tasks/FileIO/VerifyFileHash.cs b/src/Tasks/FileIO/VerifyFileHash.cs
index 30bc893dc5b..658e9bd1c6b 100644
--- a/src/Tasks/FileIO/VerifyFileHash.cs
+++ b/src/Tasks/FileIO/VerifyFileHash.cs
@@ -5,6 +5,7 @@
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -37,7 +38,7 @@ public sealed class VerifyFileHash : TaskExtension
 
         public override bool Execute()
         {
-            if (!System.IO.File.Exists(File))
+            if (!FileSystems.Default.FileExists(File))
             {
                 Log.LogErrorFromResources("FileHash.FileNotFound", File);
                 return false;
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index a5f5da81804..d02a14ee27e 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -5,6 +5,7 @@
 using System.IO;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -139,13 +140,13 @@ public FileDirInfo(string filename)
                     else
                     {
                         // Check if we have a directory
-                        IsDirectory = Directory.Exists(_filename);
+                        IsDirectory = FileSystems.Default.DirectoryExists(_filename);
                         Exists = IsDirectory;
 
                         // If not exists, see if this is a file
                         if (!Exists)
                         {
-                            Exists = File.Exists(_filename);
+                            Exists = FileSystems.Default.FileExists(_filename);
                         }
 
                         if (IsDirectory)
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 673b76ebd5e..d9813594192 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -40,6 +40,7 @@
 
 using Microsoft.Build.Utilities;
 using System.Xml.Linq;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -1010,7 +1011,7 @@ private bool TransformResourceFilesUsingResGen(List<ITaskItem> inputsToProcess,
                 {
                     foreach (ITaskItem outputFile in outputFiles)
                     {
-                        if (!File.Exists(outputFile.ItemSpec))
+                        if (!FileSystems.Default.FileExists(outputFile.ItemSpec))
                         {
                             _unsuccessfullyCreatedOutFiles.Add(outputFile.ItemSpec);
                         }
@@ -1049,7 +1050,7 @@ private bool TransformResourceFilesUsingResGen(List<ITaskItem> inputsToProcess,
                     {
                         foreach (ITaskItem outputFile in outputFiles)
                         {
-                            if (!File.Exists(outputFile.ItemSpec))
+                            if (!FileSystems.Default.FileExists(outputFile.ItemSpec))
                             {
                                 _unsuccessfullyCreatedOutFiles.Add(outputFile.ItemSpec);
                             }
@@ -1260,7 +1261,7 @@ private void GetResourcesToProcess(out List<ITaskItem> inputsToProcess, out List
                 Sources[i].CopyMetadataTo(OutputResources[i]);
                 Sources[i].SetMetadata("OutputResource", OutputResources[i].ItemSpec);
 
-                if (!File.Exists(Sources[i].ItemSpec))
+                if (!FileSystems.Default.FileExists(Sources[i].ItemSpec))
                 {
                     // Error but continue with the files that do exist
                     Log.LogErrorWithCodeFromResources("GenerateResource.ResourceNotFound", Sources[i].ItemSpec);
@@ -1285,7 +1286,7 @@ private void GetResourcesToProcess(out List<ITaskItem> inputsToProcess, out List
             {
                 // We're generating a STR class file, so there must be exactly one input resource file.
                 // If that resource file itself is out of date, the STR class file is going to get generated anyway.
-                if (nothingOutOfDate && File.Exists(Sources[0].ItemSpec))
+                if (nothingOutOfDate && FileSystems.Default.FileExists(Sources[0].ItemSpec))
                 {
                     GetStronglyTypedResourceToProcess(ref inputsToProcess, ref outputsToProcess);
                 }
@@ -2383,7 +2384,7 @@ internal Assembly ResolveAssembly(object sender, ResolveEventArgs args)
                         ITaskItem assemblyFile = _assemblyFiles[i];
                         _assemblyNames[i] = null;
 
-                        if (assemblyFile.ItemSpec != null && File.Exists(assemblyFile.ItemSpec))
+                        if (assemblyFile.ItemSpec != null && FileSystems.Default.FileExists(assemblyFile.ItemSpec))
                         {
                             string fusionName = assemblyFile.GetMetadata(ItemMetadataNames.fusionName);
                             if (!String.IsNullOrEmpty(fusionName))
@@ -2563,7 +2564,7 @@ e is SerializationException ||
                         currentOutputDirectory = Path.Combine(priDirectory,
                             reader.cultureName ?? String.Empty);
 
-                        if (!Directory.Exists(currentOutputDirectory))
+                        if (!FileSystems.Default.DirectoryExists(currentOutputDirectory))
                         {
                             currentOutputDirectoryAlreadyExisted = false;
                             Directory.CreateDirectory(currentOutputDirectory);
@@ -2633,7 +2634,7 @@ e is SerializationException ||
                         _logger.LogErrorWithCodeFromResources("GenerateResource.CannotWriteSTRFile",
                             _stronglyTypedFilename, e.Message);
 
-                        if (File.Exists(outFileOrDir)
+                        if (FileSystems.Default.FileExists(outFileOrDir)
                             && GetFormat(inFile) != Format.Assembly
                             // outFileOrDir is a directory when the input file is an assembly
                             && GetFormat(outFileOrDir) != Format.Assembly)
@@ -2655,7 +2656,7 @@ e is SerializationException ||
                 {
                     _logger.LogErrorWithCodeFromResources("GenerateResource.CannotWriteOutput",
                         FileUtilities.GetFullPathNoThrow(currentOutputFile), io.Message);
-                    if (File.Exists(currentOutputFile))
+                    if (FileSystems.Default.FileExists(currentOutputFile))
                     {
                         if (GetFormat(currentOutputFile) != Format.Assembly)
                             // Never delete an assembly since we don't ever actually write to assemblies.
@@ -2744,7 +2745,7 @@ private string EnsurePathIsShortEnough(string currentOutputFile, string currentO
             if (!success)
             {
                 string shorterPath = Path.Combine(outputDirectory ?? String.Empty, cultureName ?? String.Empty);
-                if (!Directory.Exists(shorterPath))
+                if (!FileSystems.Default.DirectoryExists(shorterPath))
                 {
                     Directory.CreateDirectory(shorterPath);
                 }
@@ -2946,7 +2947,7 @@ private void ReadResources(String filename, bool shouldUseSourcePath, String out
         internal void ReadAssemblyResources(String name, String outFileOrDir)
         {
             // If something else in the solution failed to build...
-            if (!File.Exists(name))
+            if (!FileSystems.Default.FileExists(name))
             {
                 _logger.LogErrorWithCodeFromResources("GenerateResource.MissingFile", name);
                 return;
diff --git a/src/Tasks/GenerateTrustInfo.cs b/src/Tasks/GenerateTrustInfo.cs
index 434d7ef1616..a8e07666114 100644
--- a/src/Tasks/GenerateTrustInfo.cs
+++ b/src/Tasks/GenerateTrustInfo.cs
@@ -4,6 +4,7 @@
 using System;
 using System.IO;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 
@@ -42,7 +43,7 @@ public override bool Execute()
             }
 
             // Read trust-info from app.manifest
-            if (BaseManifest != null && File.Exists(BaseManifest.ItemSpec))
+            if (BaseManifest != null && FileSystems.Default.FileExists(BaseManifest.ItemSpec))
             {
                 try
                 {
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index b9de0666df1..951935aed40 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -14,6 +14,7 @@
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -1100,7 +1101,7 @@ internal bool IsAssemblyListCacheFileUpToDate(string sdkIdentity, string sdkRoot
                     currentAssembly = Assembly.GetExecutingAssembly().CodeBase;
                     var codeBase = new Uri(currentAssembly);
                     DateTime currentCodeLastWriteTime = File.GetLastWriteTimeUtc(codeBase.LocalPath);
-                    if (File.Exists(referencesCacheFile) && currentCodeLastWriteTime < referencesCacheFileLastWriteTimeUtc)
+                    if (FileSystems.Default.FileExists(referencesCacheFile) && currentCodeLastWriteTime < referencesCacheFileLastWriteTimeUtc)
                     {
                         return true;
                     }
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index ba5b91afb4d..abe5664e78d 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -7,6 +7,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -286,7 +287,7 @@ public override bool Execute()
                     break;
                 }
 
-                if (File.Exists(projectPath) || (_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Build))
+                if (FileSystems.Default.FileExists(projectPath) || (_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Build))
                 {
                     if (FileUtilities.IsVCProjFilename(projectPath))
                     {
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index e17fd0d64da..0c09b3e58d9 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -13,6 +13,7 @@
 using System.Text.RegularExpressions;
 using System.Xml;
 using System.Xml.Serialization;
+using Microsoft.Build.Shared.FileSystem;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
@@ -179,7 +180,7 @@ public static AssemblyIdentity FromAssemblyName(string assemblyName)
         /// <returns>The assembly identity of the specified file.</returns>
         public static AssemblyIdentity FromManifest(string path)
         {
-            if (!File.Exists(path))
+            if (!FileSystems.Default.FileExists(path))
             {
                 return null;
             }
@@ -252,7 +253,7 @@ private static AssemblyIdentity FromManifest(XmlDocument document)
         /// <returns>The assembly identity of the specified file.</returns>
         public static AssemblyIdentity FromManagedAssembly(string path)
         {
-            if (!File.Exists(path))
+            if (!FileSystems.Default.FileExists(path))
             {
                 return null;
             }
@@ -290,7 +291,7 @@ public static AssemblyIdentity FromManagedAssembly(string path)
         /// <returns>The assembly identity of the specified file.</returns>
         public static AssemblyIdentity FromNativeAssembly(string path)
         {
-            if (!File.Exists(path))
+            if (!FileSystems.Default.FileExists(path))
             {
                 return null;
             }
@@ -316,7 +317,7 @@ public static AssemblyIdentity FromNativeAssembly(string path)
         /// <returns>The assembly identity of the specified file.</returns>
         public static AssemblyIdentity FromFile(string path)
         {
-            if (!File.Exists(path))
+            if (!FileSystems.Default.FileExists(path))
             {
                 return null;
             }
@@ -513,14 +514,14 @@ internal string Resolve(string[] searchPaths, bool specificVersion)
             {
                 string file = String.Format(CultureInfo.InvariantCulture, "{0}.dll", _name);
                 string path = Path.Combine(searchPath, file);
-                if (File.Exists(path) && IsEqual(this, FromFile(path), specificVersion))
+                if (FileSystems.Default.FileExists(path) && IsEqual(this, FromFile(path), specificVersion))
                 {
                     return path;
                 }
 
                 file = String.Format(CultureInfo.InvariantCulture, "{0}.manifest", _name);
                 path = Path.Combine(searchPath, file);
-                if (File.Exists(path) && IsEqual(this, FromManifest(path), specificVersion))
+                if (FileSystems.Default.FileExists(path) && IsEqual(this, FromManifest(path), specificVersion))
                 {
                     return path;
                 }
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index 3136826605e..da358580c54 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Utilities;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using System.Collections.Generic;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -144,7 +145,7 @@ private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkName
                 // Get the redistlist file path
                 string redistListFilePath = GetRedistListFilePath(referenceAssemblyPath);
 
-                if (File.Exists(redistListFilePath))
+                if (FileSystems.Default.FileExists(redistListFilePath))
                 {
                     installableFramework = GetInstallableFramework(redistListFilePath);
                 }
@@ -579,7 +580,7 @@ private void ValidateEntryPoint()
                 {
                     manifestPath = Path.Combine(Path.GetDirectoryName(SourcePath), _entryPoint.TargetPath);
                 }
-                if (File.Exists(manifestPath))
+                if (FileSystems.Default.FileExists(manifestPath))
                 {
                     ApplicationManifest entryPointManifest = ManifestReader.ReadManifest(manifestPath, false) as ApplicationManifest;
                     if (entryPointManifest != null)
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 771ae51b7dc..d6c882667d7 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -11,6 +11,7 @@
 using System.Xml;
 using System.Xml.Serialization;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -293,7 +294,7 @@ private static string ResolvePath(string path, string[] searchPaths)
             }
             if (Path.IsPathRooted(path))
             {
-                if (File.Exists(path))
+                if (FileSystems.Default.FileExists(path))
                 {
                     return path;
                 }
@@ -310,7 +311,7 @@ private static string ResolvePath(string path, string[] searchPaths)
                 {
                     string resolvedPath = Path.Combine(searchPath, path);
                     resolvedPath = Path.GetFullPath(resolvedPath);
-                    if (File.Exists(resolvedPath))
+                    if (FileSystems.Default.FileExists(resolvedPath))
                     {
                         return resolvedPath;
                     }
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index cd8f40c729b..7b1f7021809 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -21,6 +21,7 @@
 using System.Security.Policy;
 using System.Text;
 using System.Xml;
+using Microsoft.Build.Shared.FileSystem;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
@@ -162,7 +163,7 @@ private static XmlElement GetXmlElement(string targetZone, FrameworkNameVersioni
                 string path = Path.Combine(paths[0], PermissionSetsFolder);
 
                 // PermissionSets folder doesn't exit
-                if (Directory.Exists(path))
+                if (FileSystems.Default.DirectoryExists(path))
                 {
                     string[] files = Directory.GetFiles(path, "*.xml");
                     var filesInfo = new FileInfo[files.Length];
@@ -581,7 +582,7 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
                 throw new ArgumentNullException(nameof(path));
             }
 
-            if (!File.Exists(path))
+            if (!FileSystems.Default.FileExists(path))
             {
                 throw new FileNotFoundException(String.Format(CultureInfo.InvariantCulture, resources.GetString("SecurityUtil.SignTargetNotFound"), path), path);
             }
@@ -709,12 +710,12 @@ internal static string GetPathToTool(System.Resources.ResourceManager resources)
         {
 #pragma warning disable 618 // Disabling warning on using internal ToolLocationHelper API. At some point we should migrate this.
             string toolPath = ToolLocationHelper.GetPathToWindowsSdkFile(ToolName, TargetDotNetFrameworkVersion.VersionLatest, VisualStudioVersion.VersionLatest);
-            if (toolPath == null || !File.Exists(toolPath))
+            if (toolPath == null || !FileSystems.Default.FileExists(toolPath))
             {
                 toolPath = ToolLocationHelper.GetPathToWindowsSdkFile(ToolName, TargetDotNetFrameworkVersion.Version45,
                     VisualStudioVersion.Version110);
             }
-            if (toolPath == null || !File.Exists(toolPath))
+            if (toolPath == null || !FileSystems.Default.FileExists(toolPath))
             {
                 var pathToDotNetFrameworkSdk = ToolLocationHelper.GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion.Version40, VisualStudioVersion.Version100);
                 if (pathToDotNetFrameworkSdk != null)
@@ -722,15 +723,15 @@ internal static string GetPathToTool(System.Resources.ResourceManager resources)
                     toolPath = Path.Combine(pathToDotNetFrameworkSdk, "bin", ToolName);
                 }
             }
-            if (toolPath == null || !File.Exists(toolPath))
+            if (toolPath == null || !FileSystems.Default.FileExists(toolPath))
             {
                 toolPath = GetVersionIndependentToolPath(ToolName);
             }
-            if (toolPath == null || !File.Exists(toolPath))
+            if (toolPath == null || !FileSystems.Default.FileExists(toolPath))
             {
                 toolPath = Path.Combine(Directory.GetCurrentDirectory(), ToolName);
             }
-            if (!File.Exists(toolPath))
+            if (!FileSystems.Default.FileExists(toolPath))
             {
                 throw new ApplicationException(String.Format(CultureInfo.CurrentCulture,
                     resources.GetString("SecurityUtil.SigntoolNotFound"), toolPath));
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index 11afbd9d3a3..e5a0d7aa194 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -11,6 +11,7 @@
 using System.Security;
 using System.Security.Permissions;
 using System.Xml;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -597,7 +598,7 @@ public void WriteManifest(string path)
             Stream s = null;
             try
             {
-                if (File.Exists(path))
+                if (FileSystems.Default.FileExists(path))
                 {
                     s = File.Open(path, FileMode.Open, FileAccess.ReadWrite, FileShare.None);
                 }
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 8135a2c1684..2792b65ab4f 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -16,6 +16,7 @@
 using System.Security;
 using System.Security.Cryptography;
 using System.Text;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
@@ -215,7 +216,7 @@ private static string GetLogPath()
         {
             if (!logging) return null;
             string logPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), @"Microsoft\VisualStudio\8.0\VSPLOG");
-            if (!Directory.Exists(logPath))
+            if (!FileSystems.Default.DirectoryExists(logPath))
                 Directory.CreateDirectory(logPath);
             return logPath;
         }
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index 18c87c33a1e..a9136d0a089 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -7,6 +7,7 @@
 using System.Runtime.InteropServices;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -193,13 +194,13 @@ private bool MoveFileWithLogging
             string destinationFile
         )
         {
-            if (Directory.Exists(destinationFile))
+            if (FileSystems.Default.DirectoryExists(destinationFile))
             {
                 Log.LogErrorWithCodeFromResources("Move.DestinationIsDirectory", sourceFile, destinationFile);
                 return false;
             }
 
-            if (Directory.Exists(sourceFile))
+            if (FileSystems.Default.DirectoryExists(sourceFile))
             {
                 // If the source file passed in is actually a directory instead of a file, log a nice
                 // error telling the user so.  Otherwise, .NET Framework's File.Move method will throw
@@ -209,21 +210,21 @@ string destinationFile
             }
 
             // Check the source exists.
-            if (!File.Exists(sourceFile))
+            if (!FileSystems.Default.FileExists(sourceFile))
             {
                 Log.LogErrorWithCodeFromResources("Move.SourceDoesNotExist", sourceFile);
                 return false;
             }
 
             // We can't ovewrite a file unless it's writeable
-            if (OverwriteReadOnlyFiles && File.Exists(destinationFile))
+            if (OverwriteReadOnlyFiles && FileSystems.Default.FileExists(destinationFile))
             {
                 MakeWriteableIfReadOnly(destinationFile);
             }
 
             string destinationFolder = Path.GetDirectoryName(destinationFile);
 
-            if (!string.IsNullOrEmpty(destinationFolder) && !Directory.Exists(destinationFolder))
+            if (!string.IsNullOrEmpty(destinationFolder) && !FileSystems.Default.DirectoryExists(destinationFolder))
             {
                 Log.LogMessageFromResources(MessageImportance.Normal, "Move.CreatesDirectory", destinationFolder);
                 Directory.CreateDirectory(destinationFolder);
@@ -258,7 +259,7 @@ string destinationFile
             // If the destination file exists, then make sure it's read-write.
             // The File.Move command copies attributes, but our move needs to
             // leave the file writeable.
-            if (File.Exists(destinationFile))
+            if (FileSystems.Default.FileExists(destinationFile))
             {
                 // Make it writable
                 MakeWriteableIfReadOnly(destinationFile);
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index dddb4c473b8..cbe129db78b 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -13,6 +13,7 @@
 using System.Linq;
 using System.Runtime.ExceptionServices;
 using System.Text.RegularExpressions;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -855,12 +856,12 @@ internal static bool MoveFileEx(string existingFileName, string newFileName, Mov
                 return MoveFileExWindows(existingFileName, newFileName, flags);
             }
 
-            if (!File.Exists(existingFileName))
+            if (!FileSystems.Default.FileExists(existingFileName))
             {
                 return false;
             }
 
-            var targetExists = File.Exists(newFileName);
+            var targetExists = FileSystems.Default.FileExists(newFileName);
 
             if (targetExists
                 && ((flags & MoveFileFlags.MOVEFILE_REPLACE_EXISTING) != MoveFileFlags.MOVEFILE_REPLACE_EXISTING))
@@ -1532,7 +1533,7 @@ private void InitializeEnum(String assemblyName)
                 }
                 else
                 {
-                    if (Directory.Exists(s_gacPath))
+                    if (FileSystems.Default.DirectoryExists(s_gacPath))
                     {
                         if (!string.IsNullOrWhiteSpace(assemblyName))
                         {
@@ -1658,7 +1659,7 @@ public static string AssemblyPathFromStrongName(string strongName)
                 var path = Path.Combine(s_gacPath, assemblyNameVersion.Name);
 
                 // See if we can find the name as a directory in the GAC
-                if (Directory.Exists(path))
+                if (FileSystems.Default.DirectoryExists(path))
                 {
                     // Since we have a strong name, create the path to the dll
                     path = Path.Combine(
@@ -1671,7 +1672,7 @@ public static string AssemblyPathFromStrongName(string strongName)
                                 .Aggregate(new StringBuilder(), (builder, v) => builder.Append(v.ToString("x2")))),
                         assemblyNameVersion.Name + ".dll");
 
-                    if (File.Exists(path))
+                    if (FileSystems.Default.FileExists(path))
                     {
                         return path;
                     }
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 23f68c2281c..317e63ca0a4 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -14,6 +14,7 @@
 using System.Xml;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -297,7 +298,7 @@ public static string[] GetRedistListPathsFromDisk(string frameworkDirectory)
                 {
                     string redistDirectory = Path.Combine(frameworkDirectory, RedistListFolder);
 
-                    if (Directory.Exists(redistDirectory))
+                    if (FileSystems.Default.DirectoryExists(redistDirectory))
                     {
                         results = Directory.GetFiles(redistDirectory, MatchPattern);
                         s_redistListPathCache.Add(frameworkDirectory, results);
@@ -1018,7 +1019,7 @@ public string[] GetSubsetListPathsFromDisk(string frameworkDirectory)
                         foreach (string subsetName in _subsetToSearchFor)
                         {
                             string subsetFilePath = Path.Combine(subsetDirectory, subsetName + ".xml");
-                            if (File.Exists(subsetFilePath))
+                            if (FileSystems.Default.FileExists(subsetFilePath))
                             {
                                 subsetFilesForFrameworkDirectory.Add(subsetFilePath);
                             }
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 25a24d0dc8a..b0965b91798 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -13,6 +13,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -204,7 +205,7 @@ private bool Register(string assemblyPath, string typeLibPath)
 
             Log.LogMessageFromResources(MessageImportance.Low, "RegisterAssembly.RegisteringAssembly", assemblyPath);
 
-            if (!File.Exists(assemblyPath))
+            if (!FileSystems.Default.FileExists(assemblyPath))
             {
                 Log.LogErrorWithCodeFromResources("RegisterAssembly.RegisterAsmFileDoesNotExist", assemblyPath);
                 return false;
@@ -232,7 +233,7 @@ private bool Register(string assemblyPath, string typeLibPath)
                 Log.LogMessageFromResources(MessageImportance.Low, "RegisterAssembly.RegisteringTypeLib", typeLibPath);
 
                 // only regenerate the type lib if necessary
-                if ((!File.Exists(typeLibPath)) ||
+                if ((!FileSystems.Default.FileExists(typeLibPath)) ||
                     (File.GetLastWriteTime(typeLibPath) < File.GetLastWriteTime(assemblyPath)))
                 {
                     // Regenerate the type library
diff --git a/src/Tasks/RemoveDir.cs b/src/Tasks/RemoveDir.cs
index 5da0df72abd..f802cbfc70d 100644
--- a/src/Tasks/RemoveDir.cs
+++ b/src/Tasks/RemoveDir.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -50,7 +51,7 @@ public override bool Execute()
 
             foreach (ITaskItem directory in Directories)
             {
-                if (Directory.Exists(directory.ItemSpec))
+                if (FileSystems.Default.DirectoryExists(directory.ItemSpec))
                 {
                     // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
                     Log.LogMessageFromResources(MessageImportance.Normal, "RemoveDir.Removing", directory.ItemSpec);
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 7dc520f3f4c..08df15001b4 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -8,6 +8,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 using CodeDomProvider = System.CodeDom.Compiler.CodeDomProvider;
@@ -254,7 +255,7 @@ public override bool Execute()
 
                         for (int i = 0; i < outputFiles.Length; i++)
                         {
-                            if (File.Exists(outputFiles[i].ItemSpec))
+                            if (FileSystems.Default.FileExists(outputFiles[i].ItemSpec))
                             {
                                 successfullyGenerated.Add(outputFiles[i]);
                             }
@@ -271,7 +272,7 @@ public override bool Execute()
                     // was in fact generated
                     if (!success)
                     {
-                        if (!File.Exists(outputFile.ItemSpec))
+                        if (!FileSystems.Default.FileExists(outputFile.ItemSpec))
                         {
                             OutputFiles = Array.Empty<ITaskItem>();
                         }
@@ -434,8 +435,8 @@ protected override bool ValidateParameters()
 
                 // Verify that the ToolPath exists -- if the tool doesn't exist in it 
                 // we'll worry about that later
-                if ((String.IsNullOrEmpty(ToolPath) || !Directory.Exists(ToolPath)) &&
-                    (String.IsNullOrEmpty(SdkToolsPath) || !Directory.Exists(SdkToolsPath)))
+                if ((String.IsNullOrEmpty(ToolPath) || !FileSystems.Default.DirectoryExists(ToolPath)) &&
+                    (String.IsNullOrEmpty(SdkToolsPath) || !FileSystems.Default.DirectoryExists(SdkToolsPath)))
                 {
                     Log.LogErrorWithCodeFromResources("ResGen.SdkOrToolPathNotSpecifiedOrInvalid", SdkToolsPath ?? "", ToolPath ?? "");
                     return false;
@@ -502,7 +503,7 @@ private string GenerateResGenFullPath()
                     {
                         pathToTool = Path.Combine(ToolPath, ToolExe);
 
-                        if (!File.Exists(pathToTool))
+                        if (!FileSystems.Default.FileExists(pathToTool))
                         {
                             pathToTool = null;
                         }
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 0a964b68c2d..216831a1c32 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -10,6 +10,7 @@
 using System.Xml;
 
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -201,7 +202,7 @@ internal ResXFile(string filename, string baseLinkedFileDirectory) : base(filena
                 //
                 // filename is the filename of the .resx file that is to be examined.
 
-                if (File.Exists(FileName))
+                if (FileSystems.Default.FileExists(FileName))
                 {
                     linkedFiles = GetLinkedFiles(filename, baseLinkedFileDirectory);
                 }
diff --git a/src/Tasks/ResolveCodeAnalysisRuleSet.cs b/src/Tasks/ResolveCodeAnalysisRuleSet.cs
index d99bca4b50e..35b4c7f6f2b 100644
--- a/src/Tasks/ResolveCodeAnalysisRuleSet.cs
+++ b/src/Tasks/ResolveCodeAnalysisRuleSet.cs
@@ -3,6 +3,7 @@
 
 using System.IO;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -81,7 +82,7 @@ private string GetResolvedRuleSetPath()
                 if (!string.IsNullOrEmpty(MSBuildProjectDirectory))
                 {
                     string fullName = Path.Combine(MSBuildProjectDirectory, CodeAnalysisRuleSet);
-                    if (File.Exists(fullName))
+                    if (FileSystems.Default.FileExists(fullName))
                     {
                         return CodeAnalysisRuleSet;
                     }
@@ -93,7 +94,7 @@ private string GetResolvedRuleSetPath()
                     foreach (string directory in CodeAnalysisRuleSetDirectories)
                     {
                         string fullName = Path.Combine(directory, CodeAnalysisRuleSet);
-                        if (File.Exists(fullName))
+                        if (FileSystems.Default.FileExists(fullName))
                         {
                             return fullName;
                         }
@@ -106,13 +107,13 @@ private string GetResolvedRuleSetPath()
                 if (!string.IsNullOrEmpty(MSBuildProjectDirectory))
                 {
                     string fullName = Path.Combine(MSBuildProjectDirectory, CodeAnalysisRuleSet);
-                    if (File.Exists(fullName))
+                    if (FileSystems.Default.FileExists(fullName))
                     {
                         return CodeAnalysisRuleSet;
                     }
                 }
             }
-            else if (File.Exists(CodeAnalysisRuleSet))
+            else if (FileSystems.Default.FileExists(CodeAnalysisRuleSet))
             {
                 // This is a full path.
                 return CodeAnalysisRuleSet;
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index 4f2041ecbe3..bc9b0393007 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -9,6 +9,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 #if FEATURE_PFX_SIGNING
 using Microsoft.Runtime.Hosting;
 #endif
@@ -201,7 +202,7 @@ private bool ResolveManifestKey()
             {
 #if FEATURE_PFX_SIGNING
                 // if the cert isn't on disk, we can't import it
-                if (!File.Exists(CertificateFile))
+                if (!FileSystems.Default.FileExists(CertificateFile))
                 {
                     Log.LogErrorWithCodeFromResources("ResolveKeySource.CertificateNotInStore");
                 }
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index e4e9855120a..e2cac016858 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -8,6 +8,7 @@
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Utilities;
 
@@ -109,7 +110,7 @@ public override bool Execute()
                 ITaskItem item = NativeReferences[reference];
                 string path = item.GetMetadata("HintPath");
                 // If no HintPath then fallback to trying to resolve from the assembly identity...
-                if (String.IsNullOrEmpty(path) || !File.Exists(path))
+                if (String.IsNullOrEmpty(path) || !FileSystems.Default.FileExists(path))
                 {
                     AssemblyIdentity ai = AssemblyIdentity.FromAssemblyName(item.ItemSpec);
                     if (ai != null)
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 6fcfb7044e4..f8a1b576636 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -16,6 +16,7 @@
 using System.Text;
 using System.Xml;
 using System.Xml.Linq;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -526,7 +527,7 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC
             foreach (string reference in references)
             {
                 // The user specified a full path to an assembly, so there is no need to resolve
-                if (File.Exists(reference))
+                if (FileSystems.Default.FileExists(reference))
                 {
                     // The path could be relative like ..\Assembly.dll so we need to get the full path
                     resolvedAssemblyReferences.Add(Path.GetFullPath(reference));
@@ -712,12 +713,12 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
             }
             finally
             {
-                if (File.Exists(assemblyPath))
+                if (FileSystems.Default.FileExists(assemblyPath))
                 {
                     File.Delete(assemblyPath);
                 }
 
-                if (deleteSourceCodeFile && File.Exists(sourceCodePath))
+                if (deleteSourceCodeFile && FileSystems.Default.FileExists(sourceCodePath))
                 {
                     File.Delete(sourceCodePath);
                 }
diff --git a/src/Tasks/SGen.cs b/src/Tasks/SGen.cs
index 666b6e6a630..7443426468a 100644
--- a/src/Tasks/SGen.cs
+++ b/src/Tasks/SGen.cs
@@ -6,6 +6,7 @@
 using System.Diagnostics;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -186,7 +187,7 @@ protected override string GenerateFullPathToTool()
                 pathToTool = ToolLocationHelper.GetPathToDotNetFrameworkFile(ToolExe, TargetDotNetFrameworkVersion.Latest);
             }
 
-            if (String.IsNullOrEmpty(pathToTool) || !File.Exists(pathToTool))
+            if (String.IsNullOrEmpty(pathToTool) || !FileSystems.Default.FileExists(pathToTool))
             {
                 pathToTool = SdkToolsPathUtility.GeneratePathToTool(SdkToolsPathUtility.FileInfoExists, ProcessorArchitecture.CurrentProcessArchitecture, SdkToolsPath, ToolExe, Log, true);
             }
@@ -204,7 +205,7 @@ protected override bool ValidateParameters()
             {
                 foreach (string reference in References)
                 {
-                    if (!File.Exists(reference))
+                    if (!FileSystems.Default.FileExists(reference))
                     {
                         Log.LogErrorWithCodeFromResources("SGen.ResourceNotFound", reference);
                         return false;
@@ -293,7 +294,7 @@ protected override string GenerateCommandLineCommands()
                     commandLineBuilder.AppendNestedSwitch("/compiler:", "/platform:", Platform);
                 }
 
-                serializationAssemblyPathExists = File.Exists(SerializationAssemblyPath);
+                serializationAssemblyPathExists = FileSystems.Default.FileExists(SerializationAssemblyPath);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
diff --git a/src/Tasks/SdkToolsPathUtility.cs b/src/Tasks/SdkToolsPathUtility.cs
index f35d6f66133..cf37031dcda 100644
--- a/src/Tasks/SdkToolsPathUtility.cs
+++ b/src/Tasks/SdkToolsPathUtility.cs
@@ -149,7 +149,7 @@ internal static string FindSDKToolUsingToolsLocationHelper(string toolName)
         /// <summary>
         /// Provide a method which can be used with a delegate to provide a specific FileExists behavior.
         ///
-        /// Use FileInfo instead of File.Exists(...) because the latter fails silently (by design) if CAS
+        /// Use FileInfo instead of FileSystems.Default.FileExists(...) because the latter fails silently (by design) if CAS
         /// doesn't grant access. We want the security exception if there is going to be one.
         /// </summary>
         /// <returns>True if the file exists. False if it does not</returns>
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index b4bb27e28fe..3d17a4967a4 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -6,6 +6,7 @@
 using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -35,7 +36,7 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
             {
                 if (!string.IsNullOrEmpty(stateFile))
                 {
-                    if (File.Exists(stateFile))
+                    if (FileSystems.Default.FileExists(stateFile))
                     {
                         File.Delete(stateFile);
                     }
@@ -71,7 +72,7 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
             // then we create one.  
             try
             {
-                if (!string.IsNullOrEmpty(stateFile) && File.Exists(stateFile))
+                if (!string.IsNullOrEmpty(stateFile) && FileSystems.Default.FileExists(stateFile))
                 {
                     using (FileStream s = new FileStream(stateFile, FileMode.Open))
                     {
@@ -133,7 +134,7 @@ internal static void DeleteFile(string stateFile, TaskLoggingHelper log)
             {
                 if (!string.IsNullOrEmpty(stateFile))
                 {
-                    if (File.Exists(stateFile))
+                    if (FileSystems.Default.FileExists(stateFile))
                     {
                         File.Delete(stateFile);
                     }
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 56b2d97c712..208fccd1cf7 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -13,6 +13,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -144,7 +145,7 @@ private bool Unregister(string assemblyPath, string typeLibPath)
 
             Log.LogMessageFromResources(MessageImportance.Low, "UnregisterAssembly.UnregisteringAssembly", assemblyPath);
 
-            if (File.Exists(assemblyPath))
+            if (FileSystems.Default.FileExists(assemblyPath))
             {
                 try
                 {
@@ -218,7 +219,7 @@ private bool Unregister(string assemblyPath, string typeLibPath)
 
             Log.LogMessageFromResources(MessageImportance.Low, "UnregisterAssembly.UnregisteringTypeLib", typeLibPath);
 
-            if (File.Exists(typeLibPath))
+            if (FileSystems.Default.FileExists(typeLibPath))
             {
                 try
                 {
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 8caf51b4130..c623c837519 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -8,6 +8,7 @@
 using System.IO.Compression;
 using System.Linq;
 using System.Threading;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Tasks
 {
@@ -75,7 +76,7 @@ public override bool Execute()
             {
                 foreach (ITaskItem sourceFile in SourceFiles.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
                 {
-                    if (!File.Exists(sourceFile.ItemSpec))
+                    if (!FileSystems.Default.FileExists(sourceFile.ItemSpec))
                     {
                         Log.LogErrorFromResources("Unzip.ErrorFileDoesNotExist", sourceFile.ItemSpec);
                         continue;
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index 473185b4a9f..91c32347714 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -8,7 +8,7 @@
 using System.Xaml;
 using System.IO;
 using Microsoft.Build.Shared;
-
+using Microsoft.Build.Shared.FileSystem;
 using XamlTypes = Microsoft.Build.Framework.XamlTypes;
 
 namespace Microsoft.Build.Tasks.Xaml
@@ -145,7 +145,7 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
             {
                 // valid *absolute* file path
 
-                if (!File.Exists(contentOrFile))
+                if (!FileSystems.Default.FileExists(contentOrFile))
                     throw new ArgumentException(ResourceUtilities.FormatResourceString("Xaml.RuleFileNotFound", contentOrFile));
 
                 return ParseXamlDocument(new StreamReader(contentOrFile), desiredRule);
@@ -157,7 +157,7 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
                 // Unable to convert to a path, parse as XML
                 return ParseXamlDocument(new StringReader(contentOrFile), desiredRule);
 
-            if (File.Exists(maybeFullPath))
+            if (FileSystems.Default.FileExists(maybeFullPath))
                 // file found, parse as a file
                 return ParseXamlDocument(new StreamReader(maybeFullPath), desiredRule);
 
diff --git a/src/Utilities/PlatformManifest.cs b/src/Utilities/PlatformManifest.cs
index e283370fb02..53bb4d1f277 100644
--- a/src/Utilities/PlatformManifest.cs
+++ b/src/Utilities/PlatformManifest.cs
@@ -6,6 +6,7 @@
 using System.Xml;
 using System.Collections.Generic;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Utilities
 {
@@ -90,7 +91,7 @@ private void LoadManifestFile()
             {
                 string platformManifestPath = Path.Combine(_pathToManifest, "Platform.xml");
 
-                if (File.Exists(platformManifestPath))
+                if (FileSystems.Default.FileExists(platformManifestPath))
                 {
                     XmlDocument doc = new XmlDocument();
                     XmlReaderSettings readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
diff --git a/src/Utilities/SDKManifest.cs b/src/Utilities/SDKManifest.cs
index 871eaebcb0c..da9c9085073 100644
--- a/src/Utilities/SDKManifest.cs
+++ b/src/Utilities/SDKManifest.cs
@@ -9,6 +9,7 @@
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Utilities
 {
@@ -309,7 +310,7 @@ private void LoadManifestFile()
 
             try
             {
-                if (File.Exists(sdkManifestPath))
+                if (FileSystems.Default.FileExists(sdkManifestPath))
                 {
                     XmlDocument doc = new XmlDocument();
                     XmlReaderSettings readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index ee7f658cbf9..d979132daab 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -18,6 +18,7 @@
 using UtilitiesDotNetFrameworkArchitecture = Microsoft.Build.Utilities.DotNetFrameworkArchitecture;
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
 using System.Collections.ObjectModel;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyFoldersFromConfig;
 
 namespace Microsoft.Build.Utilities
@@ -824,7 +825,7 @@ public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, strin
                         propsFileLocation = Path.Combine(sdkRoot, designTimeFolderName, commonConfigurationFolderName, neutralArchitectureName, targetPlatformIdentifier, targetPlatformVersion);
                     }
 
-                    if (Directory.Exists(propsFileLocation))
+                    if (FileSystems.Default.DirectoryExists(propsFileLocation))
                     {
                         return propsFileLocation;
                     }
@@ -1016,7 +1017,7 @@ private static string[] GetLegacyTargetPlatformReferences(string targetPlatformI
                 {
                     winmdLocation = Path.Combine(sdkRoot, referencesFolderName, commonConfigurationFolderName, neutralArchitectureName);
 
-                    if (!Directory.Exists(winmdLocation))
+                    if (!FileSystems.Default.DirectoryExists(winmdLocation))
                     {
                         ErrorUtilities.DebugTraceMessage("GetLegacyTargetPlatformReferences", "Target platform location '{0}' did not exist", winmdLocation);
                         winmdLocation = null;
@@ -1116,7 +1117,7 @@ internal static string[] GetApiContractReferences(IEnumerable<ApiContract> apiCo
                 ErrorUtilities.DebugTraceMessage("GetApiContractReferences", "Gathering contract references for contract with name '{0}' and version '{1}", contract.Name, contract.Version);
                 string contractPath = Path.Combine(referencesRoot, contract.Name, contract.Version);
 
-                if (Directory.Exists(contractPath))
+                if (FileSystems.Default.DirectoryExists(contractPath))
                 {
                     string[] winmdPaths = Directory.GetFiles(contractPath, "*.winmd");
 
@@ -1620,7 +1621,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
             // return that directory.
             foreach (string referenceAssemblyDirectory in referenceAssemblyDirectories)
             {
-                if (File.Exists(Path.Combine(referenceAssemblyDirectory, "mscorlib.dll")))
+                if (FileSystems.Default.FileExists(Path.Combine(referenceAssemblyDirectory, "mscorlib.dll")))
                 {
                     // We found the framework reference assembly directory with mscorlib in it
                     // that's our standard lib path, so return it, with no trailing slash.
@@ -1694,7 +1695,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
                 }
 
                 string legacyMsCorlib20Path = FrameworkLocationHelper.GetPathToDotNetFrameworkV20(targetedArchitecture);
-                if (legacyMsCorlib20Path != null && File.Exists(Path.Combine(legacyMsCorlib20Path, "mscorlib.dll")))
+                if (legacyMsCorlib20Path != null && FileSystems.Default.FileExists(Path.Combine(legacyMsCorlib20Path, "mscorlib.dll")))
                 {
                     // We found the framework reference assembly directory with mscorlib in it
                     // that's our standard lib path, so return it, with no trailing slash.
@@ -1711,7 +1712,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
             // return that directory.
             foreach (string referenceAssemblyDirectory in referenceAssemblyDirectories)
             {
-                if (File.Exists(Path.Combine(referenceAssemblyDirectory, "mscorlib.dll")))
+                if (FileSystems.Default.FileExists(Path.Combine(referenceAssemblyDirectory, "mscorlib.dll")))
                 {
                     // We found the framework reference assembly directory with mscorlib in it
                     // that's our standard lib path, so return it, with no trailing slash.
@@ -2191,7 +2192,7 @@ private static IList<string> GetPathAndChainReferenceAssemblyLocations(string ta
             var referencePaths = new List<string>();
 
             string path = FrameworkLocationHelper.GenerateReferenceAssemblyPath(targetFrameworkRootPath, frameworkName);
-            if (Directory.Exists(path))
+            if (FileSystems.Default.DirectoryExists(path))
             {
                 referencePaths.Add(path);
 
@@ -2214,7 +2215,7 @@ private static IList<string> GetPathAndChainReferenceAssemblyLocations(string ta
                             {
                                 // On Mono, some directories contain Facades subdirectory with valid assemblies
                                 var facades = Path.Combine(path, "Facades");
-                                if (Directory.Exists(Path.Combine(path, "Facades")))
+                                if (FileSystems.Default.DirectoryExists(Path.Combine(path, "Facades")))
                                 {
                                     referencePaths.Add(facades);
                                 }
@@ -2498,7 +2499,7 @@ internal static void GatherSDKListFromDirectory(List<string> diskroots, Dictiona
                             string platformSDKManifest = Path.Combine(platformSDKDirectory, "SDKManifest.xml");
 
                             // If we are gathering the sdk platform manifests then check to see if there is a sdk manifest in the directory if not then skip over it as a platform sdk
-                            bool platformSDKManifestExists = File.Exists(platformSDKManifest);
+                            bool platformSDKManifestExists = FileSystems.Default.FileExists(platformSDKManifest);
                             if (targetPlatformSDK == null && !platformSDKs.TryGetValue(platformSDKKey, out targetPlatformSDK))
                             {
                                 targetPlatformSDK = new TargetPlatformSDK(platformSDKKey.TargetPlatformIdentifier, platformSDKKey.TargetPlatformVersion, platformSDKManifestExists ? platformSDKDirectory : null);
@@ -2770,7 +2771,7 @@ private static void GetDefaultSDKDiskRoots(List<string> diskRoots)
                 if (userLocalAppData.Length > 0)
                 {
                     string localAppdataFolder = Path.Combine(userLocalAppData, "Microsoft SDKs");
-                    if (Directory.Exists(localAppdataFolder))
+                    if (FileSystems.Default.DirectoryExists(localAppdataFolder))
                     {
                         diskRoots.Add(localAppdataFolder);
                     }
@@ -2986,7 +2987,7 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
             string redistFile = Path.Combine(redistListFolder, "FrameworkList.xml");
 
             // If the redist list does not exist then the entire chain is incorrect.
-            if (!File.Exists(redistFile))
+            if (!FileSystems.Default.FileExists(redistFile))
             {
                 // Under MONO a directory may chain to one that has no redist list
                 var chainReference = NativeMethodsShared.IsMono ? string.Empty : null;
@@ -3081,13 +3082,13 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
                     pathToReturn = Path.GetFullPath(pathToReturn);
 
                     // The directory which we are chaining to does not exist, return null indicating the chain is incorrect.
-                    if (!Directory.Exists(pathToReturn))
+                    if (!FileSystems.Default.DirectoryExists(pathToReturn))
                     {
                         pathToReturn = null;
                     }
                 }
                 // We may also have a redirect path
-                else if (!string.IsNullOrEmpty(redirectPath) && Directory.Exists(redirectPath))
+                else if (!string.IsNullOrEmpty(redirectPath) && FileSystems.Default.DirectoryExists(redirectPath))
                 {
                     pathToReturn = redirectPath;
                 }
@@ -3242,7 +3243,7 @@ internal static string GetPathToDotNetFrameworkSdkFile(string fileName, string p
 
             string filePath = Path.Combine(pathToSdk, fileName);
 
-            // Use FileInfo instead of File.Exists(...) because the latter fails silently (by design) if CAS
+            // Use FileInfo instead of FileSystems.Default.FileExists(...) because the latter fails silently (by design) if CAS
             // doesn't grant access. We want the security exception if there is going to be one.
             bool exists = new FileInfo(filePath).Exists;
             if (!exists)
@@ -3415,7 +3416,7 @@ private static string GetPathToWindowsSdkFile(string fileName, string pathToSdk,
 
             string filePath = Path.Combine(pathToSdk, fileName);
 
-            // Use FileInfo instead of File.Exists(...) because the latter fails silently (by design) if CAS
+            // Use FileInfo instead of FileSystems.Default.FileExists(...) because the latter fails silently (by design) if CAS
             // doesn't grant access. We want the security exception if there is going to be one.
             bool exists = new FileInfo(filePath).Exists;
             if (!exists)
@@ -3482,7 +3483,7 @@ public static string GetPathToBuildToolsFile(string fileName, string toolsVersio
             {
                 toolPath = Path.Combine(toolPath, fileName);
 
-                if (!File.Exists(toolPath))
+                if (!FileSystems.Default.FileExists(toolPath))
                 {
                     toolPath = null;
                 }
@@ -3703,7 +3704,7 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                     string dotNetFx20Path = GetPathToDotNetFramework(TargetDotNetFrameworkVersion.Version20);
                     if (dotNetFx20Path != null)
                     {
-                        if (Directory.Exists(dotNetFx20Path))
+                        if (FileSystems.Default.DirectoryExists(dotNetFx20Path))
                         {
                             frameworkIdentifiers.Add(FrameworkLocationHelper.dotNetFrameworkIdentifier);
                         }
@@ -3855,14 +3856,14 @@ private static IList<string> GetFx35AndEarlierVersions(string frameworkReference
 
                 // check v30
                 string dotNextFx30RefPath = Path.Combine(frameworkReferenceRoot, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV30);
-                if (Directory.Exists(dotNextFx30RefPath))
+                if (FileSystems.Default.DirectoryExists(dotNextFx30RefPath))
                 {
                     versions.Add(FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV30);
                 }
 
                 // check v35
                 string dotNextFx35RefPath = Path.Combine(frameworkReferenceRoot, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV35);
-                if (Directory.Exists(dotNextFx35RefPath))
+                if (FileSystems.Default.DirectoryExists(dotNextFx35RefPath))
                 {
                     versions.Add(FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV35);
                 }
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 4c5dee8a4f8..e851539ee53 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -14,6 +14,7 @@
 using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Utilities
 {
@@ -452,7 +453,7 @@ private string ComputePathToTool()
                 pathToTool = Path.Combine(ToolPath, ToolExe);
             }
 
-            if (string.IsNullOrWhiteSpace(pathToTool) || ToolPath == null && !File.Exists(pathToTool))
+            if (string.IsNullOrWhiteSpace(pathToTool) || ToolPath == null && !FileSystems.Default.FileExists(pathToTool))
             {
                 // Otherwise, try to find the tool ourselves.
                 pathToTool = GenerateFullPathToTool();
@@ -473,7 +474,7 @@ private string ComputePathToTool()
                 bool isOnlyFileName = Path.GetFileName(pathToTool).Length == pathToTool.Length;
                 if (!isOnlyFileName)
                 {
-                    bool isExistingFile = File.Exists(pathToTool);
+                    bool isExistingFile = FileSystems.Default.FileExists(pathToTool);
                     if (!isExistingFile)
                     {
                         LogPrivate.LogErrorWithCodeFromResources("ToolTask.ToolExecutableNotFound", pathToTool);
@@ -1257,7 +1258,7 @@ internal static string FindOnPath(string filename)
                     try
                     {
                         // The PATH can contain anything, including bad characters
-                        return Directory.Exists(path);
+                        return FileSystems.Default.DirectoryExists(path);
                     }
                     catch (Exception)
                     {
@@ -1265,7 +1266,7 @@ internal static string FindOnPath(string filename)
                     }
                 })
                 .Select(folderPath => Path.Combine(folderPath, filename))
-                .FirstOrDefault(fullPath => !string.IsNullOrEmpty(fullPath) && File.Exists(fullPath));
+                .FirstOrDefault(fullPath => !string.IsNullOrEmpty(fullPath) && FileSystems.Default.FileExists(fullPath));
         }
 
         #endregion
@@ -1525,7 +1526,7 @@ public override bool Execute()
             finally
             {
                 // Clean up after ourselves.
-                if (_temporaryBatchFile != null && File.Exists(_temporaryBatchFile))
+                if (_temporaryBatchFile != null && FileSystems.Default.FileExists(_temporaryBatchFile))
                 {
                     DeleteTempFile(_temporaryBatchFile);
                 }
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index 76c0134d366..39ebba2332a 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -11,6 +11,7 @@
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 #if FEATURE_FILE_TRACKER
 
@@ -381,7 +382,7 @@ public static string FindTrackerOnPath()
 
                     trackerPath = Path.Combine(trackerPath, s_TrackerFilename);
 
-                    if (File.Exists(trackerPath))
+                    if (FileSystems.Default.FileExists(trackerPath))
                     {
                         return trackerPath;
                     }
@@ -481,7 +482,7 @@ private static string GetPath(string filename, ExecutableType toolType, string r
             {
                 trackerPath = Path.Combine(rootPath, filename);
 
-                if (!File.Exists(trackerPath))
+                if (!FileSystems.Default.FileExists(trackerPath))
                 {
                     // if an override path was specified, that's it -- we don't want to fall back if the file
                     // is not found there.
@@ -529,7 +530,7 @@ private static string GetPath(string filename, DotNetFrameworkArchitecture bitne
                 string progfilesPath = Path.Combine(FrameworkLocationHelper.GenerateProgramFiles32(),
                     "MSBuild", MSBuildConstants.CurrentProductVersion, "FileTracker", s_FileTrackerFilename);
 
-                if (File.Exists(progfilesPath))
+                if (FileSystems.Default.FileExists(progfilesPath))
                 {
                     return progfilesPath;
                 }
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 01f82fe60d7..88b60b0dfc8 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -10,6 +10,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 #if FEATURE_FILE_TRACKER
 
@@ -651,7 +652,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
             else if (_tlogMarker != string.Empty)
             {
                 string markerDirectory = Path.GetDirectoryName(_tlogMarker);
-                if (!Directory.Exists(markerDirectory))
+                if (!FileSystems.Default.DirectoryExists(markerDirectory))
                 {
                     Directory.CreateDirectory(markerDirectory);
                 }
diff --git a/src/Utilities/TrackedDependencies/TrackedDependencies.cs b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
index 62b3a3f8034..802f2164d3a 100644
--- a/src/Utilities/TrackedDependencies/TrackedDependencies.cs
+++ b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
@@ -6,6 +6,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Utilities
 {
@@ -39,7 +40,7 @@ public static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                     // Very often with TLog files we're talking about
                     // a directory and a simply wildcarded filename
                     // Optimize for that case here.
-                    if (!FileMatcher.HasWildcards(directoryName) && Directory.Exists(directoryName))
+                    if (!FileMatcher.HasWildcards(directoryName) && FileSystems.Default.DirectoryExists(directoryName))
                     {
                         files = Directory.GetFiles(directoryName, searchPattern);
                     }
