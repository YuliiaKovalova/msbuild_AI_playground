diff --git a/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md b/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md
index b6980de5753..664a99fa185 100644
--- a/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md
+++ b/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md
@@ -10,9 +10,9 @@ labels: needs-triage
 
 <!--
 * Here are some useful links to help you figure out what's wrong.
-* Our wiki: https://github.com/microsoft/msbuild/blob/master/documentation/wiki/Home.md
-* General Help: https://github.com/microsoft/msbuild/blob/master/documentation/wiki/Something's-wrong-in-my-build.md
-* Tips & Tricks: https://github.com/microsoft/msbuild/blob/master/documentation/wiki/MSBuild-Tips-%26-Tricks.md
+* Our documentation: https://github.com/dotnet/msbuild/blob/main/documentation/README.md
+* General Help: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Something's-wrong-in-my-build.md
+* Tips & Tricks: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/MSBuild-Tips-%26-Tricks.md
 -->
 
 ### Issue Description
@@ -50,4 +50,4 @@ If you want to share one just with Microsoft, you can [report a problem through
 <!--
 * We ask that you first browse the above links, as your question may already have been answered.
 * Be as detailed as you can with these questions.
--->
\ No newline at end of file
+-->
diff --git a/documentation/specs/project-cache.md b/documentation/specs/project-cache.md
index 6a0095354ca..7c3a2fad63a 100644
--- a/documentation/specs/project-cache.md
+++ b/documentation/specs/project-cache.md
@@ -1,10 +1,10 @@
 # Summary
 
-Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).
+Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md#weakness-of-the-old-model-caching-and-distributability).
 
 # Motivation
 
-As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
+As the introduction to [static graph](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
 
 Visual Studio is one beneficiary. This plugin inverts dependencies among build systems: instead of higher level build engines ([Cloudbuild](https://www.microsoft.com/research/publication/cloudbuild-microsofts-distributed-and-caching-build-service/), [Anybuild](https://github.com/AnyBuild/AnyBuild), [BuildXL](https://github.com/microsoft/BuildXL), etc) calling into MSBuild, MSBuild calls into them, keeping MSBuild's external APIs and command line arguments largely unchanged and thus reusable by Visual Studio.
 
@@ -78,7 +78,7 @@ This change also simplifies and unifies user experiences. MSBuild works the same
   - On cache hits, MSBuild skips the project, but needs a BuildResult with target results to send back to the [Scheduler](https://github.com/dotnet/msbuild/blob/d39f2e4f5f3d461bc456f9abed9adec4a2f0f542/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L25).
   - Plugins have three options:
     - Worst: plugins fake the build results for each target. We consider this brittle since the plugins will have to be updated whenever the build logic changes.
-    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/ProjectReference-Protocol.md) for more details.
+    - Better: plugins tell MSBuild to run a proxy target as a replacement for the expensive target (e.g. it tells MSBuild to run `GetTargetPath` and use those results for the Build target). See the [ProjectReference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/ProjectReference-Protocol.md) for more details.
       - Proxy target assumptions:
         - They are very fast and only retrieve items and properties from the evaluated state (like `GetTargetPath`).
         - They do not mutate state (file system, environment variables, etc).
@@ -105,7 +105,7 @@ This change also simplifies and unifies user experiences. MSBuild works the same
   - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.
 - Slow connections. In a coffee shop it might be faster to build everything instead of downloading from the cache. Consider racing plugin checks and building: if the bottom up build traversal reaches a node that's still querying the cache, cancel the cache query and build the node instead.
 - Inferring what targets to run on each node when using /graph
-  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/master/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
+  - Msbuild /graph requires that the [target inference protocol](https://github.com/dotnet/msbuild/blob/main/documentation/specs/static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
 - Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.
 
 # Future work
diff --git a/documentation/specs/single-project-isolated-builds.md b/documentation/specs/single-project-isolated-builds.md
index c2a70c47c03..e3f8b94670d 100644
--- a/documentation/specs/single-project-isolated-builds.md
+++ b/documentation/specs/single-project-isolated-builds.md
@@ -12,7 +12,7 @@ The presence of either input or output caches turns on [isolated build constrain
 
 ## Input / Output cache implementation
 <!-- cache structure -->
-The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/dotnet/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22).
+The cache files contain the serialized state of MSBuild's [ConfigCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCache.cs) and [ResultsCache](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCache.cs). These two caches have been traditionally used by the engine to cache build results. For example, it is these caches which ensure that a target is only built once per build submission. The `ConfigCache` entries are instances of [BuildRequestConfiguration](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs#L25). The `ResultsCache` entries are instances of [BuildResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/BuildResult.cs#L34), which contain or more instances of [TargetResult](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Shared/TargetResult.cs#L22).
 
 One can view the two caches as the following mapping: `(project path, global properties) -> results`. `(project path, global properties)` is represented by a `BuildRequestConfiguration`, and the results are represented by `BuildResult` and `TargetResult`.
 
@@ -30,7 +30,7 @@ The following constraints are enforced during cache aggregation:
 The output cache file **only contains results for additional work performed in the current BeginBuild / EndBuild session**. Entries from input caches are not transferred to the output cache.
 
 <!-- How input / output cache entries are separated with the override caches -->
-Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/dotnet/msbuild/blob/master/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
+Entries that make it into the output cache file are separated from entries serialized from input cache files via the use of [ConfigCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [ResultsCacheWithOverride](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). These are composite caches. Each contains two underlying caches: a cache where input caches files are loaded into (called the override cache), and a cache where new results are written into (called the current cache). Cache reads are satisified from both underlying caches (override cache is queried first, current cache is queried second). Writes are only written to the current cache, never into the override cache. The output cache file only contains the serialized current cache, and not the override cache, thus ensuring that only newly built results are serialized in the output cache file. It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache read.
 
 ## Isolation implementation
 
diff --git a/documentation/specs/task-isolation-and-dependencies.md b/documentation/specs/task-isolation-and-dependencies.md
index f130c37e8a4..2ec96c8eb18 100644
--- a/documentation/specs/task-isolation-and-dependencies.md
+++ b/documentation/specs/task-isolation-and-dependencies.md
@@ -23,7 +23,7 @@ We also want to load groups of tasks which belong together into the same ALC (fo
 
 # Task dependency resolution
 ## Problem definition
-Tasks with complex and specifically platform specific dependencies don't work out of the box. For example if a task uses [`LibGit2Sharp`](https://www.nuget.org/packages/LibGit2Sharp) package it will not work as is. `LibGit2Sharp` has native dependencies which are platform specific. While the package carries all of them, there's no built in support for the task to load the right ones. For example [source link](https://github.com/dotnet/sourcelink/blob/master/src/Microsoft.Build.Tasks.Git/GitLoaderContext.cs) runs into this problem.
+Tasks with complex and specifically platform specific dependencies don't work out of the box. For example if a task uses [`LibGit2Sharp`](https://www.nuget.org/packages/LibGit2Sharp) package it will not work as is. `LibGit2Sharp` has native dependencies which are platform specific. While the package carries all of them, there's no built in support for the task to load the right ones. For example [source link](https://github.com/dotnet/sourcelink/blob/29b3197e824c05d03427c05d56700e4c704233e4/src/Microsoft.Build.Tasks.Git/GitLoaderContext.cs) runs into this problem.
 
 ## Solution
 .NET Core uses `.deps.json` files to describe dependencies of components. It would be natural to treat task assemblies as components and use associated .deps.json file to determine their dependencies. This would make the system work nicely end to end with the .NET Core CLI/SDK and VS integration.
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
index a71155be41e..43134c57c3b 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
@@ -1,6 +1,6 @@
 # Building MSBuild for the .NET Framework
 
-These instructions refer to working with the `master` branch.
+These instructions refer to working with the `main` branch.
 
 ## Required Software
 
diff --git a/documentation/wiki/Contributing-Code.md b/documentation/wiki/Contributing-Code.md
index 690cf797972..c71172b8305 100644
--- a/documentation/wiki/Contributing-Code.md
+++ b/documentation/wiki/Contributing-Code.md
@@ -5,7 +5,7 @@ Because our focus right now is on maintaining backwards compatibility, the team
 
 - Contributions must be discussed with the team first, or they will likely be declined. As our process matures and our experience grows, the team expects to take larger contributions.
 - Only contributions referencing an approved Issue will be accepted.
-- Pull requests that do not merge easily with the tip of the master branch will be declined. The author will be asked to merge with tip and submit a new pull request.
+- Pull requests that do not merge easily with the tip of the main branch will be declined. The author will be asked to merge with tip and submit a new pull request.
 - Submissions must meet functional and performance expectations, including scenarios for which the team doesn't yet have open source tests. This means you may be asked to fix and resubmit your pull request against a new open test case if it fails one of these tests.
 - Submissions must follow the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
 
diff --git a/documentation/wiki/Localization.md b/documentation/wiki/Localization.md
index 919d9f4a883..5ea4d4cf835 100644
--- a/documentation/wiki/Localization.md
+++ b/documentation/wiki/Localization.md
@@ -21,8 +21,8 @@
 
 ## Process for interacting with the localization team
 
-- 3 weeks cadence for master, initiated by loc team
-- on demand for master / release branches, initiated by msbuild team
+- 3 weeks cadence for main, initiated by loc team
+- on demand for main / release branches, initiated by msbuild team
 
 ## Contributing a better translation
 
diff --git a/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs b/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs
index e998e35d8c8..6f5fd31c934 100644
--- a/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs
+++ b/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.UnitTests
     public class DebugUtils_Tests
     {
         [Fact]
-        public void DumpExceptionToFileShouldWriteInTempPathByDefault()
+        public void DumpExceptionToFileShouldWriteInDebugDumpPath()
         {
             var exceptionFilesBefore = Directory.GetFiles(ExceptionHandling.DebugDumpPath, "MSBuild_*failure.txt");
 
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index bc58b185039..73e28782ed8 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -216,7 +216,7 @@ public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
         }
 
-        [Fact]
+        [RequiresSymbolicLinksFact]
         public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
         {
             string testFileName = "foobar.txt";
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 05d920b732b..f7493839380 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -122,6 +122,9 @@
     <Compile Include="..\Shared\UnitTests\LongPathSupportDisabledFactAttribute.cs">
       <Link>Shared\LongPathSupportDisabledFactAttribute.cs</Link>
     </Compile>
+    <Compile Include="..\UnitTests.Shared\RequiresSymbolicLinksFactAttribute.cs">
+      <Link>RequiresSymbolicLinksFactAttribute.cs</Link>
+    </Compile>
 
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 9b2de23aa47..2af7392c4d2 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -20,8 +20,8 @@ internal enum ChangeWaveConversionState
     /// Coupled together with the MSBUILDDISABLEFEATURESFROMVERSION environment variable,
     /// this class acts as a way to make risky changes while giving customers an opt-out.
     /// </summary>
-    /// See docs here: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves.md
-    /// For dev docs: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves-Dev.md
+    /// See docs here: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves.md
+    /// For dev docs: https://github.com/dotnet/msbuild/blob/main/documentation/wiki/ChangeWaves-Dev.md
     internal class ChangeWaves
     {
         internal static readonly Version Wave17_2 = new Version(17, 2);
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index bdf84b30922..85fbdddd446 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -1017,7 +1017,7 @@ internal static MemoryStatus GetMemoryStatus()
         return null;
     }
 
-    internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)
+    internal static bool MakeSymbolicLink(string newFileName, string existingFileName, ref string errorMessage)
     {
         bool symbolicLinkCreated;
         if (IsWindows)
@@ -1029,12 +1029,12 @@ internal static bool MakeSymbolicLink(string newFileName, string exitingFileName
                 flags |= SymbolicLink.AllowUnprivilegedCreate;
             }
 
-            symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, flags);
+            symbolicLinkCreated = CreateSymbolicLink(newFileName, existingFileName, flags);
             errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
         }
         else
         {
-            symbolicLinkCreated = symlink(exitingFileName, newFileName) == 0;
+            symbolicLinkCreated = symlink(existingFileName, newFileName) == 0;
             errorMessage = symbolicLinkCreated ? null : Marshal.GetLastWin32Error().ToString();
         }
 
diff --git a/src/MSBuild/LiveLogger/ANSIBuilder.cs b/src/MSBuild/LiveLogger/ANSIBuilder.cs
index 7ea63b39940..369be7d5bea 100644
--- a/src/MSBuild/LiveLogger/ANSIBuilder.cs
+++ b/src/MSBuild/LiveLogger/ANSIBuilder.cs
@@ -427,16 +427,7 @@ public static string Spinner(int n)
 
             public static string ProgressBar(float percentage, int width = 10, char completedChar = '█', char remainingChar = '░')
             {
-                string result = String.Empty;
-                for (int i = 0; i < (int)Math.Floor(width * percentage); i++)
-                {
-                    result += completedChar;
-                }
-                for (int i = (int)Math.Floor(width * percentage); i < width; i++)
-                {
-                    result += remainingChar;
-                }
-                return result;
+                return new string(completedChar, (int)Math.Floor(width * percentage)) + new string(remainingChar, width - (int)Math.Floor(width * percentage));
             }
 
             public static string Bell()
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
index 1dcbe2080bb..14a6d8b77fa 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -12,11 +12,13 @@ internal class LiveLogger : ILogger
     {
         private Dictionary<int, ProjectNode> projects = new Dictionary<int, ProjectNode>();
 
-        private bool Succeeded;
-        public string Parameters { get; set; }
-        public int StartedProjects = 0;
-        public int FinishedProjects = 0;
+        private bool succeeded;
+        private int startedProjects = 0;
+        private int finishedProjects = 0;
+        private Dictionary<string, int> blockedProjects = new();
+
         public LoggerVerbosity Verbosity { get; set; }
+        public string Parameters { get; set; }
 
         public LiveLogger()
         {
@@ -55,6 +57,10 @@ private void Render()
             TerminalBuffer.Initialize();
             // TODO: Fix. First line does not appear at top. Leaving empty line for now
             TerminalBuffer.WriteNewLine(string.Empty);
+
+            // Top line indicates the number of finished projects.
+            TerminalBuffer.FinishedProjects = this.finishedProjects;
+
             // First render
             TerminalBuffer.Render();
             int i = 0;
@@ -66,11 +72,14 @@ private void Render()
                 // Use task delay to avoid blocking the task, so that keyboard input is listened continously
                 Task.Delay((i / 60) * 1_000).ContinueWith((t) =>
                 {
+                    TerminalBuffer.FinishedProjects = this.finishedProjects;
+
                     // Rerender projects only when needed
                     foreach (var project in projects)
                     {
                         project.Value.Log();
                     }
+
                     // Rerender buffer
                     TerminalBuffer.Render();
                 });
@@ -100,7 +109,7 @@ private void Render()
 
         private void UpdateFooter()
         {
-            float percentage = (float)FinishedProjects / StartedProjects;
+            float percentage = startedProjects == 0 ? 0.0f : (float)finishedProjects / startedProjects;
             TerminalBuffer.FooterText = ANSIBuilder.Alignment.SpaceBetween(
                 $"Build progress (approx.) [{ANSIBuilder.Graphics.ProgressBar(percentage)}]",
                 ANSIBuilder.Formatting.Italic(ANSIBuilder.Formatting.Dim("[Up][Down] Scroll")),
@@ -114,27 +123,28 @@ private void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
 
         private void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
         {
-            Succeeded = e.Succeeded;
+            succeeded = e.Succeeded;
         }
 
         // Project
         private void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
         {
-            StartedProjects++;
+            startedProjects++;
+
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            // If id already exists...
-            if (projects.ContainsKey(id))
+
+            // If id does not exist...
+            if (!projects.ContainsKey(id))
             {
-                return;
+                // Add project
+                ProjectNode node = new(e)
+                {
+                    ShouldRerender = true,
+                };
+                projects[id] = node;
+                UpdateFooter();
             }
-            // Add project
-            ProjectNode node = new ProjectNode(e);
-            projects[id] = node;
-            // Log
-            // Update footer
-            UpdateFooter();
-            node.ShouldRerender = true;
         }
 
         private void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
@@ -145,11 +155,12 @@ private void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs
             {
                 return;
             }
+
             // Update line
             node.Finished = true;
-            FinishedProjects++;
-            UpdateFooter();
             node.ShouldRerender = true;
+            finishedProjects++;
+            UpdateFooter();
         }
 
         // Target
@@ -194,10 +205,30 @@ private void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
             node.AddTask(e);
             // Log
             node.ShouldRerender = true;
+
+            if (e.TaskName.Equals("MSBuild"))
+            {
+                TerminalBufferLine? line = null; // TerminalBuffer.WriteNewLineAfterMidpoint($"{e.ProjectFile} is blocked by the MSBuild task.");
+                if (line is not null)
+                {
+                    blockedProjects[e.ProjectFile] = line.Id;
+                }
+            }
         }
 
         private void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
         {
+            if (e.TaskName.Equals("MSBuild"))
+            {
+                if (blockedProjects.TryGetValue(e.ProjectFile, out int lineId))
+                {
+                    TerminalBuffer.DeleteLine(lineId);
+                    if (projects.TryGetValue(e.BuildEventContext!.ProjectInstanceId, out ProjectNode? node))
+                    {
+                        node.ShouldRerender = true;
+                    }
+                }
+            }
         }
 
         // Raised messages, warnings and errors
@@ -277,7 +308,7 @@ public void Shutdown()
 
             // Emmpty line
             Console.WriteLine();
-            if (Succeeded)
+            if (succeeded)
             {
                 Console.WriteLine(ANSIBuilder.Formatting.Color("Build succeeded.", ANSIBuilder.Formatting.ForegroundColor.Green));
                 Console.WriteLine($"\t{warningCount} Warning(s)");
diff --git a/src/MSBuild/LiveLogger/ProjectNode.cs b/src/MSBuild/LiveLogger/ProjectNode.cs
index 6dfd396ded4..967f9aca210 100644
--- a/src/MSBuild/LiveLogger/ProjectNode.cs
+++ b/src/MSBuild/LiveLogger/ProjectNode.cs
@@ -93,7 +93,7 @@ public void Log()
             // Create or update line
             if (Line is null)
             {
-                Line = TerminalBuffer.WriteNewLine(lineContents, false);
+                Line = TerminalBuffer.WriteNewLineBeforeMidpoint(lineContents, false);
             }
             else
             {
@@ -108,8 +108,15 @@ public void Log()
                     TerminalBuffer.DeleteLine(CurrentTargetLine.Id);
                 }
 
-                foreach (MessageNode node in AdditionalDetails.ToList())
+                bool foundErrorOrWarning = false;
+
+                foreach (MessageNode node in AdditionalDetails)
                 {
+                    if (node.Type != MessageNode.MessageType.HighPriorityMessage)
+                    {
+                        foundErrorOrWarning = true;
+                    }
+
                     // Only delete high priority messages
                     if (node.Type != MessageNode.MessageType.HighPriorityMessage)
                     {
@@ -121,6 +128,20 @@ public void Log()
                         TerminalBuffer.DeleteLine(node.Line.Id);
                     }
                 }
+
+                if (!foundErrorOrWarning && this.Line is not null)
+                {
+                    foreach (MessageNode node in AdditionalDetails)
+                    {
+                        int? id = node.Line?.Id;
+                        if (id is not null)
+                        {
+                            TerminalBuffer.DeleteLine(id.Value);
+                        }
+                    }
+
+                    TerminalBuffer.DeleteLine(this.Line.Id);
+                }
             }
 
             // Current target details
diff --git a/src/MSBuild/LiveLogger/TerminalBuffer.cs b/src/MSBuild/LiveLogger/TerminalBuffer.cs
index 16c0bc08c41..a6bc8290748 100644
--- a/src/MSBuild/LiveLogger/TerminalBuffer.cs
+++ b/src/MSBuild/LiveLogger/TerminalBuffer.cs
@@ -4,7 +4,9 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Runtime.CompilerServices;
 using System.Text;
+using static System.Net.Mime.MediaTypeNames;
 
 namespace Microsoft.Build.Logging.LiveLogger
 {
@@ -65,6 +67,8 @@ internal class TerminalBuffer
         internal static bool IsTerminated = false;
         internal static bool ShouldRerender = true;
         internal static OverallBuildState topBarColor = OverallBuildState.None;
+        internal static int FinishedProjects = 0;
+        private static int midLineId;
         internal static int ScrollableAreaHeight
         {
             get
@@ -79,6 +83,10 @@ public static void Initialize()
             Console.OutputEncoding = Encoding.UTF8;
             Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
             Console.Write(ANSIBuilder.Cursor.Invisible());
+            // TerminalBufferLine midLine = new(new string('-', Console.BufferWidth), true);
+            // WriteNewLine(midLine);
+            // midLineId = midLine.Id;
+            midLineId = -1;
         }
 
         public static void Terminate()
@@ -108,7 +116,7 @@ public static void Render()
                 topBarColor == OverallBuildState.Warning ? ANSIBuilder.Formatting.ForegroundColor.Yellow :
                 ANSIBuilder.Formatting.ForegroundColor.White;
 
-            string text = "MSBuild - Build in progress";
+            string text = $"MSBuild - Build in progress - {FinishedProjects} finished projects";
             text =
                 topBarColor == OverallBuildState.Error ? $"{errorSymbol} {text} {errorSymbol}" :
                 topBarColor == OverallBuildState.Warning ? $"{warningSymbol} {text} {warningSymbol}" :
@@ -119,8 +127,11 @@ public static void Render()
                 ANSIBuilder.Cursor.Home() +
                 ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center(text)), ANSIBuilder.Formatting.BackgroundColor.Black, desiredColor) +
                 // Write footer
-                ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) + ANSIBuilder.Eraser.LineCursorToEnd() +
-                new string('-', Console.BufferWidth) + '\n' + FooterText);
+                ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
+                    ANSIBuilder.Eraser.LineCursorToEnd() +
+                    new string('-', Console.BufferWidth) +
+                    Environment.NewLine +
+                    FooterText);
 
             if (Lines.Count == 0)
             {
@@ -207,7 +218,7 @@ public static int GetLineIndexById(int lineId)
                     return null;
                 }
                 // Get line end index
-                Lines.Insert(lineIndex, line);
+                Lines.Insert(lineIndex + 1, line);
             }
             else
             {
@@ -216,6 +227,27 @@ public static int GetLineIndexById(int lineId)
             return line;
         }
 
+        public static TerminalBufferLine? WriteNewLineAfterMidpoint(string text, bool shouldWrapLines = false)
+        {
+            TerminalBufferLine line = new(text, shouldWrapLines);
+            return WriteNewLineAfter(midLineId, line);
+        }
+
+        public static TerminalBufferLine? WriteNewLineBeforeMidpoint(string text, bool shouldWrapLines)
+        {
+            TerminalBufferLine line = new(text, shouldWrapLines);
+            int lineIndex = GetLineIndexById(midLineId);
+            if (lineIndex == -1)
+            {
+                WriteNewLine(line);
+                return null;
+            }
+
+            Lines.Insert(lineIndex, line);
+
+            return line;
+        }
+
         public static TerminalBufferLine? WriteNewLine(string text)
         {
             return WriteNewLine(text, true);
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index fa13e50f7d1..b10887f23c3 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -674,12 +674,69 @@ internal static int GetIntegerVariableOrDefault(string environmentVariable, int
             return defaultValue;
         }
 
+        /// <summary>
+        /// Writes trace information to a log file
+        /// </summary>
+        internal static void Trace<T>(string format, T arg0)
+        {
+            Trace(nodeId: -1, format, arg0);
+        }
+
+        /// <summary>
+        /// Writes trace information to a log file
+        /// </summary>
+        internal static void Trace<T>(int nodeId, string format, T arg0)
+        {
+            if (s_trace)
+            {
+                TraceCore(nodeId, string.Format(format, arg0));
+            }
+        }
+
+        /// <summary>
+        /// Writes trace information to a log file
+        /// </summary>
+        internal static void Trace<T0, T1>(string format, T0 arg0, T1 arg1)
+        {
+            Trace(nodeId: -1, format, arg0, arg1);
+        }
+
+        /// <summary>
+        /// Writes trace information to a log file
+        /// </summary>
+        internal static void Trace<T0, T1>(int nodeId, string format, T0 arg0, T1 arg1)
+        {
+            if (s_trace)
+            {
+                TraceCore(nodeId, string.Format(format, arg0, arg1));
+            }
+        }
+
+        /// <summary>
+        /// Writes trace information to a log file
+        /// </summary>
+        internal static void Trace<T0, T1, T2>(string format, T0 arg0, T1 arg1, T2 arg2)
+        {
+            Trace(nodeId: -1, format, arg0, arg1, arg2);
+        }
+
+        /// <summary>
+        /// Writes trace information to a log file
+        /// </summary>
+        internal static void Trace<T0, T1, T2>(int nodeId, string format, T0 arg0, T1 arg1, T2 arg2)
+        {
+            if (s_trace)
+            {
+                TraceCore(nodeId, string.Format(format, arg0, arg1, arg2));
+            }
+        }
+
         /// <summary>
         /// Writes trace information to a log file
         /// </summary>
         internal static void Trace(string format, params object[] args)
         {
-            Trace(/* nodeId */ -1, format, args);
+            Trace(nodeId: -1, format, args);
         }
 
         /// <summary>
@@ -689,49 +746,65 @@ internal static void Trace(int nodeId, string format, params object[] args)
         {
             if (s_trace)
             {
-                lock (s_traceLock)
-                {
-                    s_debugDumpPath ??=
+                string message = string.Format(CultureInfo.CurrentCulture, format, args);
+                TraceCore(nodeId, message);
+            }
+        }
+
+        internal static void Trace(int nodeId, string message)
+        {
+            if (s_trace)
+            {
+                TraceCore(nodeId, message);
+            }
+        }
+
+        /// <summary>
+        /// Writes trace information to a log file
+        /// </summary>
+        private static void TraceCore(int nodeId, string message)
+        {
+            lock (s_traceLock)
+            {
+                s_debugDumpPath ??=
 #if CLR2COMPATIBILITY
-                        Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                    Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
                         DebugUtils.DebugPath;
 #endif
 
-                    if (String.IsNullOrEmpty(s_debugDumpPath))
-                    {
-                        s_debugDumpPath = FileUtilities.TempFileDirectory;
-                    }
-                    else
-                    {
-                        Directory.CreateDirectory(s_debugDumpPath);
-                    }
+                if (String.IsNullOrEmpty(s_debugDumpPath))
+                {
+                    s_debugDumpPath = FileUtilities.TempFileDirectory;
+                }
+                else
+                {
+                    Directory.CreateDirectory(s_debugDumpPath);
+                }
 
-                    try
+                try
+                {
+                    string fileName = @"MSBuild_CommTrace_PID_{0}";
+                    if (nodeId != -1)
                     {
-                        string fileName = @"MSBuild_CommTrace_PID_{0}";
-                        if (nodeId != -1)
-                        {
-                            fileName += "_node_" + nodeId;
-                        }
+                        fileName += "_node_" + nodeId;
+                    }
 
-                        fileName += ".txt";
+                    fileName += ".txt";
 
-                        using (StreamWriter file = FileUtilities.OpenWrite(
-                            String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId), append: true))
-                        {
-                            string message = String.Format(CultureInfo.CurrentCulture, format, args);
-                            long now = DateTime.UtcNow.Ticks;
-                            float millisecondsSinceLastLog = (float)(now - s_lastLoggedTicks) / 10000L;
-                            s_lastLoggedTicks = now;
-                            file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog, message);
-                        }
-                    }
-                    catch (IOException)
+                    using (StreamWriter file = FileUtilities.OpenWrite(
+                        String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId), append: true))
                     {
-                        // Ignore
+                        long now = DateTime.UtcNow.Ticks;
+                        float millisecondsSinceLastLog = (float)(now - s_lastLoggedTicks) / 10000L;
+                        s_lastLoggedTicks = now;
+                        file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog, message);
                     }
                 }
+                catch (IOException)
+                {
+                    // Ignore
+                }
             }
         }
 
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 660dbd5327d..36613d4cd52 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -2311,7 +2311,7 @@ private static bool IsFullFileSystemScan(int directoryPartIndex, int directoryPa
         /// Returns true if the given character is a valid drive letter.
         /// </summary>
         /// <remarks>
-        /// Copied from https://github.com/dotnet/corefx/blob/master/src/Common/src/System/IO/PathInternal.Windows.cs#L77-L83
+        /// Copied from https://github.com/dotnet/corefx/blob/b8b81a66738bb10ef0790023598396861d92b2c4/src/Common/src/System/IO/PathInternal.Windows.cs#L53-L59
         /// </remarks>
         private static bool IsValidDriveChar(char value)
         {
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index b8c1416aa96..a4f1fbba057 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -69,7 +69,7 @@ public void GetFilesPatternMatching(string pattern, int expectedMatchCount)
         }
 
 #if FEATURE_SYMLINK_TARGET
-        [Fact]
+        [RequiresSymbolicLinksFact]
         public void DoNotFollowRecursiveSymlinks()
         {
             TransientTestFolder testFolder = _env.CreateFolder();
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index eac251335ed..d4caedaabbf 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -2380,7 +2380,7 @@ public CopySymbolicLink_Tests(ITestOutputHelper testOutputHelper)
         /// <summary>
         /// DestinationFolder should work.
         /// </summary>
-        [Fact]
+        [RequiresSymbolicLinksFact]
         public void CopyToDestinationFolderWithSymbolicLinkCheck()
         {
             string sourceFile = FileUtilities.GetTemporaryFile();
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index e8e1b49e6ba..473207bfe6f 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -59,10 +59,10 @@
     <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
-    
     <Compile Include="..\Shared\UnitTests\LongPathSupportDisabledFactAttribute.cs">
       <Link>Shared\LongPathSupportDisabledFactAttribute.cs</Link>
     </Compile>
+    <Compile Include="..\UnitTests.Shared\RequiresSymbolicLinksFactAttribute.cs" />
 
     <EmbeddedResource Include="SampleResx" />
     <EmbeddedResource Include="AssemblyDependency\CacheFileSamples\Microsoft.VisualStudio.LanguageServices.Implementation.csprojAssemblyReference.cache" />
diff --git a/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs b/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
new file mode 100644
index 00000000000..4e53459f155
--- /dev/null
+++ b/src/UnitTests.Shared/RequiresSymbolicLinksFactAttribute.cs
@@ -0,0 +1,55 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+
+using Microsoft.Build.Shared;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    /// A custom <see cref="FactAttribute"/> that skips the test if the OS doesn't support creating symlinks.
+    /// </summary>
+    public sealed class RequiresSymbolicLinksFactAttribute : FactAttribute
+    {
+        private static readonly bool s_runningInAzurePipeline =
+            bool.TryParse(Environment.GetEnvironmentVariable("TF_BUILD"), out bool value) && value;
+
+        public RequiresSymbolicLinksFactAttribute()
+        {
+            if (s_runningInAzurePipeline || !NativeMethodsShared.IsWindows)
+            {
+                return;
+            }
+
+            // In Windows, a process can create symlinks only if it has sufficient permissions.
+            // We simply try to create one and if it fails we skip the test.
+            string sourceFile = FileUtilities.GetTemporaryFile();
+            string destinationFile = FileUtilities.GetTemporaryFile();
+            try
+            {
+                File.Create(sourceFile).Dispose();
+
+                string? errorMessage = null;
+                if (!NativeMethodsShared.MakeSymbolicLink(destinationFile, sourceFile, ref errorMessage))
+                {
+                    Skip = "Requires permission to create symbolic links. Need to be run elevated or under development mode " +
+                        "(https://learn.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development).";
+                }
+            }
+            finally
+            {
+                if (File.Exists(sourceFile))
+                {
+                    File.Delete(sourceFile);
+                }
+                if (File.Exists(destinationFile))
+                {
+                    File.Delete(destinationFile);
+                }
+            }
+        }
+    }
+}
