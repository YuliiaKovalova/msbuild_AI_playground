diff --git a/documentation/release-checklist.md b/documentation/release-checklist.md
new file mode 100644
index 00000000000..4f00f360e55
--- /dev/null
+++ b/documentation/release-checklist.md
@@ -0,0 +1,78 @@
+# MSBuild Release Checklist {{THIS_RELEASE_VERSION}}
+
+## At any time
+
+- [ ] Create a new issue to track the release checklist, with this checklist copied into the issue.
+  - [ ] Replace `{{PREVIOUS_RELEASE_VERSION}}` with the previous release version, for example `17.9`
+  - [ ] Replace `{{THIS_RELEASE_VERSION}}` with the current release version, for example `17.10`
+  - [ ] Replace `{{NEXT_VERSION}}` with the next release version, for example `17.11`
+- [ ]  Create `vs{{THIS_RELEASE_VERSION}}` branch
+- [ ]  Create darc channel for `VS {{NEXT_VERSION}}` if it doesn't already exist \
+`darc add-channel --name "VS {{NEXT_VERSION}}"`
+- [ ]  Ping internal "First Responders" Teams channel to get the new channel made available as a promotion target (e.g. dotnet/arcade#12150): {{URL_OF_CHANNEL_PROMOTION_PR}}
+
+## At release time
+
+- [ ] If the release is being cut more than a few days before the VS-side snap, do these two steps. Otherwise check them off.
+  - [ ]  Modify the VS insertion so that it flows from MSBuild `vs{{THIS_RELEASE_VERSION}}` to VS `main` [in the MSBuild-release-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=1319&view=mine&_a=releases) Edit -> Schedule set under Artifacts -> disable toggle
+AND
+  - [ ]  Disable automated run of [the MSBuild-main-branch release definition](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) (because our {{NEXT_VERSION}} builds don't have a place to go in VS yet)
+- [ ]  Remove the `main` to old release channel ({{THIS_RELEASE_VERSION}}) default channel \
+`darc delete-default-channel --repo https://github.com/dotnet/msbuild --branch main --channel "VS {{THIS_RELEASE_VERSION}}"`
+- [ ]  Associate the `main` branch with the next release channel \
+`darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch main --repo https://github.com/dotnet/msbuild`
+- [ ]  Check subscriptions for the forward-looking channel `VS {{NEXT_VERSION}}` and update as necessary (for instance, SDK's `main` branch should usually be updated, whereas release branches often should not be \
+`darc get-subscriptions --exact --source-repo https://github.com/dotnet/msbuild --channel "VS {{THIS_RELEASE_VERSION}}"`
+- [ ]  Update channel VS {{THIS_RELEASE_VERSION}} to VS {{NEXT_VERSION}} for the sdk main subscription and any others from the previous step
+`darc update-subscription --id sdk_main_branch_id`
+- [ ]  Ensure that the current release channel `VS {{THIS_RELEASE_VERSION}}` is associated with the correct release branch\
+`darc get-default-channels --source-repo https://github.com/dotnet/msbuild --branch vs{{THIS_RELEASE_VERSION}}` \
+if it is not, `darc add-default-channel  --channel "VS {{THIS_RELEASE_VERSION}}" --branch vs{{THIS_RELEASE_VERSION}} --repo https://github.com/dotnet/msbuild`
+- [ ]  If the branch was created before the fork: fast-forward merge the correct commit (the one that is currently inserted to VS main) to the `vs{{THIS_RELEASE_VERSION}}` branch \
+e.g.: `git push upstream 2e6f2ff7ea311214255b6b2ca5cc0554fba1b345:refs/heads/vs17.10` \
+_(This is for the case where we create the branch too early and want it to be based actually on a different commit. If you waited until a good point in time with `main` in a clean state, just branch off and you are done. The branch should point to a good, recent spot, so the final-branding PR goes in on top of the right set of commits.)_
+- [ ]  Update the branch merge flow in `dotnet/versions` to have the currently-in-servicing branches: {{URL_OF_VERSIONS_PR}}
+- [ ]  Fix OptProf data flow for the new vs{{THIS_RELEASE_VERSION}} branch
+  - [ ] Manually run [OptProf data collection](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=17389) pipeline for vs{{THIS_RELEASE_VERSION}} ('Run pipeline' in upper right)
+  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} without OptProf (set `SkipApplyOptimizationData` variable in 'Advanced options' section of the 'Run pipeline' menu to `true`)
+  - [ ] Run the [official build](https://devdiv.visualstudio.com/DevDiv/_build?definitionId=9434) for vs{{THIS_RELEASE_VERSION}} with no extra customization - OptProf should succeed now
+- [ ]  Create {{NEXT_VERSION}} branding PR (in main): {{URL_OF_NEXT_VERSION_BRANDING_PR}}
+- [ ]  Create {{THIS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to add localization for {{THIS_RELEASE_VERSION}}): {{URL_OF_LOCALIZATION_TICKET}}
+https://ceapex.visualstudio.com/CEINTL/_workitems/edit/957875 (DONE)
+- [ ]  Enable {{THIS_RELEASE_VERSION}} localization - by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{THIS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `true`
+- [ ]  Disable {{PREVIOUS_RELEASE_VERSION}} localization -  by setting [`EnableReleaseOneLocBuild`](https://github.com/dotnet/msbuild/blob/vs{{PREVIOUS_RELEASE_VERSION}}/.vsts-dotnet.yml) to `false` clarify with @JanKrivanek
+- [ ]  Merge {{NEXT_VERSION}} branding PR
+- [ ]  Create and merge PR including public API baseline package version change (see https://github.com/dotnet/msbuild/pull/8116#discussion_r1049386978): #8949
+- [ ]  When VS main snaps to {{THIS_RELEASE_VERSION}} and updates its version to {{NEXT_VERSION}}, modify the VS insertion so that it flows from MSBuild main to VS main.
+- [ ]  Create {{PREVIOUS_RELEASE_VERSION}} localization ticket: https://aka.ms/ceChangeLocConfig (requesting to remove localization for {{PREVIOUS_RELEASE_VERSION}})
+{{URL_OF_LOCALIZATION_DISABLE_TICKET}}
+- [ ]  Remove MSBuild main from the experimental VS insertion flow.
+- [ ]  Update the [release-branch insertion release definition](https://dev.azure.com/devdiv/DevDiv/_releaseDefinition?definitionId=2153&_a=definition-variables) to have `InsertTargetBranch` `rel/d{{THIS_RELEASE_VERSION}}`.
+- [ ]  Turn [the release pipeline](https://dev.azure.com/devdiv/DevDiv/_release?definitionId=2153&view=mine&_a=releases) back on.
+- [ ]  Prepare final branding PR for `vs{{THIS_RELEASE_VERSION}}`: {{URL_OF_FINAL_BRANDING_PR}}
+- [ ]  Merge final branding to `vs{{THIS_RELEASE_VERSION}}` branch
+- [ ]  Update perfstar MSBuild insertions configuration: [example PR](https://dev.azure.com/devdiv/DevDiv/_git/dotnet-perfstar/pullrequest/522843): {{URL_OF_PERFSTAR_PR}}
+- [ ] Note down the build (will be helpful for requesting nuget packages publishing): {{URL_OF_BUILD}}
+- [ ] Get M2 or QB approval as necessary per the VS schedule
+- [ ]  Merge to VS (babysit the automatically generated VS insertion PR https://devdiv.visualstudio.com/DevDiv/_git/VS/pullrequests for the MSBuild commit noted in above step): {{URL_OF_VS_INSERTION}}
+- [ ] Update the PackageValidationBaselineVersion to the latest released version ({{THIS_RELEASE_VERSION}}.0) - this might require temporary addition of the [build artifacts feed](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) as the new version is not yet added to the official feeds (this is post release). This can trigger a high severity CG error (https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/secure-supply-chain/how-to-securely-configure-package-source-files) - however it should be fine to keep this temporary feed untill the release.
+
+## ASAP On/After GA:
+
+Timing based on the [(Microsoft-internal) release schedule](https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/10097/Dev17-Release).
+
+- [ ]  Push packages to nuget.org (not currently automated, contact dnceng - search "Publish MSBuild 17.6 to NuGet.org" email subject for template).
+- [ ]  Publish docs: submit reference request at https://aka.ms/publishondocs
+  - Click on the link labeled *Request – Reference Publishing*
+  - You can use existing [ticket](https://dev.azure.com/msft-skilling/Content/_workitems/edit/183613) as a reference
+- [ ] Remove the temporarily added [build feed from `nuget.config`](https://github.com/dotnet/msbuild/blob/29397b577e3ec0fe0c7650c3ab0400909655dc88/NuGet.config#L9) if it was added in the `Update the PackageValidationBaselineVersion` step
+- [ ]  Update `main` subscriptions to the new channel (this can be done before or after release - depending on when the source repos from our previous - VS {{THIS_RELEASE_VERSION}} - channle start to publish in the next - VS {{NEXT_VERSION}} - channel) \
+`darc get-subscriptions --exact --target-repo https://github.com/dotnet/msbuild --target-branch main`
+- [ ]  Create the {{THIS_RELEASE_VERSION}} release
+  - [ ]  Create tag (can be done upfront)
+  ```
+  git checkout <commit noted above>
+  git tag v{{THIS_RELEASE_VERSION}}.3
+  git push upstream v{{THIS_RELEASE_VERSION}}.3
+  ```
+  - [ ]  Create Release in Github with `Create Release from Tag` GH option (https://github.com/dotnet/msbuild/releases/new?tag=v17.9.3) - the release notes can be prepopulated (`Generate Release Notes`)
diff --git a/documentation/specs/proposed/BuildCheck-feature-threat-model.md b/documentation/specs/proposed/BuildCheck-feature-threat-model.md
index 2a0f91d11f6..feeb937433a 100644
--- a/documentation/specs/proposed/BuildCheck-feature-threat-model.md
+++ b/documentation/specs/proposed/BuildCheck-feature-threat-model.md
@@ -30,9 +30,10 @@ Custom BuildCheck analyzers are executed during build. If bad external actors in
 
 #### Mitigation
 
-Custom analyzers are delivered as regular nuget packages by MSBuild `<PackageReference />` element. This way custom analyzer packages will be included in the generated SBOM and Component Government can detect and warn about known malicious custom analyzers.
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
-It is identical to Roslyn analyzers or any other nuget package, for that matter.
+Custom analyzers are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
+Users is expected to implement process to detect and warn about known malicious custom analyzers.
 
 ## Execution
 
@@ -42,14 +43,14 @@ Custom BuildCheck analyzers are executed during build. If bad external actors in
 
 #### Mitigation
 
-Identical to mitigation of threat [Supply chain attack on custom analyzer](#threat-supply-chain-attack-on-custom-analyzer).
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
 ### Threat: Third-Party Vulnerabilities
 Vulnerabilities in custom analyzer or its dependencies.
 
 #### Mitigation
 
-Custom analyzers are delivered as regular NuGet packages by MSBuild `<PackageReference />` element. This way custom analyzer packages will be included in the generated SBOM and Component Government can detect and warn about known malicious custom analyzers.
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
 ## Configuration
 
@@ -70,9 +71,7 @@ Malicious actors can define analyzer ID to be identical or like existing well kn
 
 #### Mitigation
 
-Main mitigation relays on nuget packages component governance.
-
-BuildCheck also disallow duplicated analyzer IDs and do not allow well known prefixes, for example `microsoft-\*`, in custom analyzers.
+Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
 ## Declaration
 
@@ -83,5 +82,3 @@ Threat actor can write malicious analyzer registration property function in proj
 #### Mitigation
 
 This threat is out of scope of this document, as this requires malicious modification of source code (repository) making these sources untrusted.
-
-It is mentioned here, as a note that we have thought about it.
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 7744d96a090..c30d03cea0f 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -27,6 +27,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Log TaskParameterEvent for scalar parameters](https://github.com/dotnet/msbuild/pull/9908)
 - [Convert.ToString during a property evaluation uses the InvariantCulture for all types](https://github.com/dotnet/msbuild/pull/9874)
 - [Fix oversharing of build results in ResultsCache](https://github.com/dotnet/msbuild/pull/9987)
+- [Add ParameterName and PropertyName to TaskParameterEventArgs](https://github.com/dotnet/msbuild/pull/10130)
 
 ### 17.10
 - [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index d7932be5d22..2d939a0f9d5 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -67,14 +67,14 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24225.1">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24266.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>67d23f4ba1813b315e7e33c71d18b63475f5c5f8</Sha>
+      <Sha>e6f70c7dd528f05cd28cec2a179d58c22e91d9ac</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24225.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24266.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>67d23f4ba1813b315e7e33c71d18b63475f5c5f8</Sha>
+      <Sha>e6f70c7dd528f05cd28cec2a179d58c22e91d9ac</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
@@ -91,14 +91,14 @@
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>fb50d1a45ed10b39b5f335bc3a4bdcaea9b951cf</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24230.3">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24259.10">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>abc35d6d16eb3c0c0aafd67734f01217047a3c90</Sha>
+      <Sha>6a0e23ee35042a881060eb97dea37dd7cc51db88</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24225.1">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24266.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>67d23f4ba1813b315e7e33c71d18b63475f5c5f8</Sha>
+      <Sha>e6f70c7dd528f05cd28cec2a179d58c22e91d9ac</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 6c011cfc85b..36fb2fe10bd 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,10 +48,10 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24225.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24266.3</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24230.3</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24259.10</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.10.0-preview.2.97</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
diff --git a/eng/common/templates-official/job/source-index-stage1.yml b/eng/common/templates-official/job/source-index-stage1.yml
index f0513aee5b0..43ee0c202fc 100644
--- a/eng/common/templates-official/job/source-index-stage1.yml
+++ b/eng/common/templates-official/job/source-index-stage1.yml
@@ -1,6 +1,7 @@
 parameters:
   runAsPublic: false
-  sourceIndexPackageVersion: 1.0.1-20230228.2
+  sourceIndexUploadPackageVersion: 2.0.0-20240502.12
+  sourceIndexProcessBinlogPackageVersion: 1.0.1-20240129.2
   sourceIndexPackageSource: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json
   sourceIndexBuildCommand: powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "eng/common/build.ps1 -restore -build -binarylog -ci"
   preSteps: []
@@ -14,15 +15,15 @@ jobs:
   dependsOn: ${{ parameters.dependsOn }}
   condition: ${{ parameters.condition }}
   variables:
-  - name: SourceIndexPackageVersion
-    value: ${{ parameters.sourceIndexPackageVersion }}
+  - name: SourceIndexUploadPackageVersion
+    value: ${{ parameters.sourceIndexUploadPackageVersion }}
+  - name: SourceIndexProcessBinlogPackageVersion
+    value: ${{ parameters.sourceIndexProcessBinlogPackageVersion }}
   - name: SourceIndexPackageSource
     value: ${{ parameters.sourceIndexPackageSource }}
   - name: BinlogPath
     value: ${{ parameters.binlogPath }}
-  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - group: source-dot-net stage1 variables
-  - template: /eng/common/templates-official/variables/pool-providers.yml
+  - template: /eng/common/templates/variables/pool-providers.yml
 
   ${{ if ne(parameters.pool, '') }}:
     pool: ${{ parameters.pool }}
@@ -33,24 +34,23 @@ jobs:
         demands: ImageOverride -equals windows.vs2019.amd64.open
       ${{ if eq(variables['System.TeamProject'], 'internal') }}:
         name: $(DncEngInternalBuildPool)
-        image: windows.vs2022.amd64
-        os: windows
+        demands: ImageOverride -equals windows.vs2019.amd64
 
   steps:
   - ${{ each preStep in parameters.preSteps }}:
     - ${{ preStep }}
 
   - task: UseDotNet@2
-    displayName: Use .NET Core SDK 6
+    displayName: Use .NET 8 SDK
     inputs:
       packageType: sdk
-      version: 6.0.x
+      version: 8.0.x
       installationPath: $(Agent.TempDirectory)/dotnet
       workingDirectory: $(Agent.TempDirectory)
 
   - script: |
-      $(Agent.TempDirectory)/dotnet/dotnet tool install BinLogToSln --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
-      $(Agent.TempDirectory)/dotnet/dotnet tool install UploadIndexStage1 --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
+      $(Agent.TempDirectory)/dotnet/dotnet tool install BinLogToSln --version $(sourceIndexProcessBinlogPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
+      $(Agent.TempDirectory)/dotnet/dotnet tool install UploadIndexStage1 --version $(sourceIndexUploadPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
     displayName: Download Tools
     # Set working directory to temp directory so 'dotnet' doesn't try to use global.json and use the repo's sdk.
     workingDirectory: $(Agent.TempDirectory)
@@ -62,7 +62,24 @@ jobs:
     displayName: Process Binlog into indexable sln
 
   - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name)
-      displayName: Upload stage1 artifacts to source index
-      env:
-        BLOB_CONTAINER_URL: $(source-dot-net-stage1-blob-container-url)
+    - task: AzureCLI@2
+      displayName: Get stage 1 auth token
+      inputs:
+        azureSubscription: 'SourceDotNet Stage1 Publish'
+        addSpnToEnvironment: true
+        scriptType: 'ps'
+        scriptLocation: 'inlineScript'
+        inlineScript: |
+          echo "##vso[task.setvariable variable=ARM_CLIENT_ID]$env:servicePrincipalId"
+          echo "##vso[task.setvariable variable=ARM_ID_TOKEN]$env:idToken"
+          echo "##vso[task.setvariable variable=ARM_TENANT_ID]$env:tenantId"
+
+    - script: |
+        echo "Client ID: $(ARM_CLIENT_ID)"
+        echo "ID Token: $(ARM_ID_TOKEN)"
+        echo "Tenant ID: $(ARM_TENANT_ID)"
+        az login --service-principal -u $(ARM_CLIENT_ID) --tenant $(ARM_TENANT_ID) --allow-no-subscriptions --federated-token $(ARM_ID_TOKEN)
+      displayName: "Login to Azure"
+
+    - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name) -s netsourceindexstage1 -b stage1
+      displayName: Upload stage1 artifacts to source index
\ No newline at end of file
diff --git a/eng/common/templates/job/source-index-stage1.yml b/eng/common/templates/job/source-index-stage1.yml
index b98202aa02d..43ee0c202fc 100644
--- a/eng/common/templates/job/source-index-stage1.yml
+++ b/eng/common/templates/job/source-index-stage1.yml
@@ -1,6 +1,7 @@
 parameters:
   runAsPublic: false
-  sourceIndexPackageVersion: 1.0.1-20230228.2
+  sourceIndexUploadPackageVersion: 2.0.0-20240502.12
+  sourceIndexProcessBinlogPackageVersion: 1.0.1-20240129.2
   sourceIndexPackageSource: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json
   sourceIndexBuildCommand: powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "eng/common/build.ps1 -restore -build -binarylog -ci"
   preSteps: []
@@ -14,14 +15,14 @@ jobs:
   dependsOn: ${{ parameters.dependsOn }}
   condition: ${{ parameters.condition }}
   variables:
-  - name: SourceIndexPackageVersion
-    value: ${{ parameters.sourceIndexPackageVersion }}
+  - name: SourceIndexUploadPackageVersion
+    value: ${{ parameters.sourceIndexUploadPackageVersion }}
+  - name: SourceIndexProcessBinlogPackageVersion
+    value: ${{ parameters.sourceIndexProcessBinlogPackageVersion }}
   - name: SourceIndexPackageSource
     value: ${{ parameters.sourceIndexPackageSource }}
   - name: BinlogPath
     value: ${{ parameters.binlogPath }}
-  - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - group: source-dot-net stage1 variables
   - template: /eng/common/templates/variables/pool-providers.yml
 
   ${{ if ne(parameters.pool, '') }}:
@@ -40,16 +41,16 @@ jobs:
     - ${{ preStep }}
 
   - task: UseDotNet@2
-    displayName: Use .NET Core SDK 6
+    displayName: Use .NET 8 SDK
     inputs:
       packageType: sdk
-      version: 6.0.x
+      version: 8.0.x
       installationPath: $(Agent.TempDirectory)/dotnet
       workingDirectory: $(Agent.TempDirectory)
 
   - script: |
-      $(Agent.TempDirectory)/dotnet/dotnet tool install BinLogToSln --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
-      $(Agent.TempDirectory)/dotnet/dotnet tool install UploadIndexStage1 --version $(SourceIndexPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
+      $(Agent.TempDirectory)/dotnet/dotnet tool install BinLogToSln --version $(sourceIndexProcessBinlogPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
+      $(Agent.TempDirectory)/dotnet/dotnet tool install UploadIndexStage1 --version $(sourceIndexUploadPackageVersion) --add-source $(SourceIndexPackageSource) --tool-path $(Agent.TempDirectory)/.source-index/tools
     displayName: Download Tools
     # Set working directory to temp directory so 'dotnet' doesn't try to use global.json and use the repo's sdk.
     workingDirectory: $(Agent.TempDirectory)
@@ -61,7 +62,24 @@ jobs:
     displayName: Process Binlog into indexable sln
 
   - ${{ if and(eq(parameters.runAsPublic, 'false'), ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
-    - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name)
-      displayName: Upload stage1 artifacts to source index
-      env:
-        BLOB_CONTAINER_URL: $(source-dot-net-stage1-blob-container-url)
+    - task: AzureCLI@2
+      displayName: Get stage 1 auth token
+      inputs:
+        azureSubscription: 'SourceDotNet Stage1 Publish'
+        addSpnToEnvironment: true
+        scriptType: 'ps'
+        scriptLocation: 'inlineScript'
+        inlineScript: |
+          echo "##vso[task.setvariable variable=ARM_CLIENT_ID]$env:servicePrincipalId"
+          echo "##vso[task.setvariable variable=ARM_ID_TOKEN]$env:idToken"
+          echo "##vso[task.setvariable variable=ARM_TENANT_ID]$env:tenantId"
+
+    - script: |
+        echo "Client ID: $(ARM_CLIENT_ID)"
+        echo "ID Token: $(ARM_ID_TOKEN)"
+        echo "Tenant ID: $(ARM_TENANT_ID)"
+        az login --service-principal -u $(ARM_CLIENT_ID) --tenant $(ARM_TENANT_ID) --allow-no-subscriptions --federated-token $(ARM_ID_TOKEN)
+      displayName: "Login to Azure"
+
+    - script: $(Agent.TempDirectory)/.source-index/tools/UploadIndexStage1 -i .source-index/stage1output -n $(Build.Repository.Name) -s netsourceindexstage1 -b stage1
+      displayName: Upload stage1 artifacts to source index
\ No newline at end of file
diff --git a/global.json b/global.json
index f5c0c2e630c..e798a223e55 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.8.5"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24225.1"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24266.3"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
index 8cfb2d4a575..a0d79660060 100644
--- a/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BatchingEngine_Tests.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -52,7 +53,11 @@ public void GetBuckets()
             properties.Set(ProjectPropertyInstance.Create("UnitTests", "unittests.foo"));
             properties.Set(ProjectPropertyInstance.Create("OBJ", "obj"));
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                MockElementLocation.Instance,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             Assert.Equal(5, buckets.Count);
 
@@ -62,7 +67,14 @@ public void GetBuckets()
                 XmlAttribute tempXmlAttribute = (new XmlDocument()).CreateAttribute("attrib");
                 tempXmlAttribute.Value = "'$(Obj)'=='obj'";
 
-                Assert.True(ConditionEvaluator.EvaluateCondition(tempXmlAttribute.Value, ParserOptions.AllowAll, bucket.Expander, ExpanderOptions.ExpandAll, Directory.GetCurrentDirectory(), MockElementLocation.Instance, null, new BuildEventContext(1, 2, 3, 4), FileSystems.Default));
+                Assert.True(ConditionEvaluator.EvaluateCondition(
+                    tempXmlAttribute.Value,
+                    ParserOptions.AllowAll,
+                    bucket.Expander, ExpanderOptions.ExpandAll,
+                    Directory.GetCurrentDirectory(),
+                    MockElementLocation.Instance,
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
                 Assert.Equal("a.doc;b.doc;c.doc;d.doc;e.doc", bucket.Expander.ExpandIntoStringAndUnescape("@(doc)", ExpanderOptions.ExpandItems, MockElementLocation.Instance));
                 Assert.Equal("unittests.foo", bucket.Expander.ExpandIntoStringAndUnescape("$(bogus)$(UNITTESTS)", ExpanderOptions.ExpandPropertiesAndMetadata, MockElementLocation.Instance));
             }
@@ -130,7 +142,11 @@ public void ValidUnqualifiedMetadataReference()
 
             PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), null);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                null,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             Assert.Equal(2, buckets.Count);
         }
 
@@ -164,7 +180,11 @@ public void InvalidUnqualifiedMetadataReference()
 
                 // This is expected to throw because not all items contain a value for metadata "Culture".
                 // Only a.foo has a Culture metadata.  b.foo does not.
-                BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+                BatchingEngine.PrepareBatchingBuckets(
+                    parameters,
+                    CreateLookup(itemsByType, properties),
+                    MockElementLocation.Instance,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             });
         }
         /// <summary>
@@ -185,7 +205,11 @@ public void NoItemsConsumed()
                 PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
                 // This is expected to throw because we have no idea what item list %(Culture) refers to.
-                BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), MockElementLocation.Instance);
+                BatchingEngine.PrepareBatchingBuckets(
+                    parameters,
+                    CreateLookup(itemsByType, properties),
+                    MockElementLocation.Instance,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             });
         }
         /// <summary>
@@ -211,7 +235,11 @@ public void Regress_Mutation_DuplicateBatchingBucketsAreFoldedTogether()
 
             PropertyDictionary<ProjectPropertyInstance> properties = new PropertyDictionary<ProjectPropertyInstance>();
 
-            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(parameters, CreateLookup(itemsByType, properties), null);
+            List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(
+                parameters,
+                CreateLookup(itemsByType, properties),
+                null,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             // If duplicate buckets have been folded correctly, then there will be exactly one bucket here
             // containing both a.foo and b.foo.
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 66a27a4e9d6..f94ef7e8ec0 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -83,7 +83,7 @@ public void TestConstructorNullTarget()
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
                 Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-                TargetEntry entry = new TargetEntry(requestEntry, this, null, lookup, null, TargetBuiltReason.None, _host, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, null, lookup, null, TargetBuiltReason.None, _host, null, false);
             });
         }
         /// <summary>
@@ -97,7 +97,7 @@ public void TestConstructorNullLookup()
                 ProjectInstance project = CreateTestProject(true /* Returns enabled */);
                 BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
-                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), null, null, TargetBuiltReason.None, _host, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), null, null, TargetBuiltReason.None, _host, null, false);
             });
         }
         /// <summary>
@@ -113,7 +113,7 @@ public void TestConstructorNullHost()
                 BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
 
                 Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), lookup, null, TargetBuiltReason.None, null, false);
+                TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification("Empty", null), lookup, null, TargetBuiltReason.None, null, null, false);
             });
         }
         /// <summary>
@@ -1025,7 +1025,7 @@ private TargetEntry CreateStandardTargetEntry(ProjectInstance project, string ta
             BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[] { "foo" }), config);
 
             Lookup lookup = new Lookup(new ItemDictionary<ProjectItemInstance>(project.Items), new PropertyDictionary<ProjectPropertyInstance>(project.Properties));
-            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(targetName, project.Targets[targetName].Location), lookup, null, TargetBuiltReason.None, _host, false);
+            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(targetName, project.Targets[targetName].Location), lookup, null, TargetBuiltReason.None, _host, null, false);
             return entry;
         }
 
@@ -1041,7 +1041,7 @@ private TargetEntry CreateStandardTargetEntry(ProjectInstance project, string ta
             BuildRequestConfiguration config = new BuildRequestConfiguration(1, new BuildRequestData("foo", new Dictionary<string, string>(), "foo", Array.Empty<string>(), null), "2.0");
             config.Project = project;
             BuildRequestEntry requestEntry = new BuildRequestEntry(CreateNewBuildRequest(1, new string[1] { "foo" }), config);
-            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(target, project.Targets[target].Location), baseEntry.Lookup, baseEntry, TargetBuiltReason.None, _host, false);
+            TargetEntry entry = new TargetEntry(requestEntry, this, new TargetSpecification(target, project.Targets[target].Location), baseEntry.Lookup, baseEntry, TargetBuiltReason.None, _host, null, false);
             return entry;
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index cd2a93acc25..d764e74ffc5 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -570,6 +570,7 @@ private DependencyAnalysisResult PerformDependencyAnalysisTestHelper(
 
                 // now do the dependency analysis
                 ItemBucket itemBucket = new ItemBucket(null, null, new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
+                itemBucket.Initialize(null);
                 TargetUpToDateChecker analyzer = new TargetUpToDateChecker(p, p.Targets["Build"], _mockHost, BuildEventContext.Invalid);
 
                 return analyzer.PerformDependencyAnalysis(itemBucket, false, out changedTargetInputs, out upToDateTargetInputs);
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index ba22e2beed0..cdd57796d4d 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1284,6 +1284,7 @@ private void InitializeHost(bool throwOnExecute)
             _twoItems = new ITaskItem[] { new TaskItem(item), new TaskItem(item2) };
 
             _bucket = new ItemBucket(Array.Empty<string>(), new Dictionary<string, string>(), new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
+            _bucket.Initialize(null);
             _host.FindTask(null);
             _host.InitializeForBatch(talc, _bucket, null);
             _parametersSetOnTask = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index 1e8bcaf1f14..91d8bec792d 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Engine.UnitTests.TestComparers;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -2184,8 +2185,7 @@ internal TaskRegistry CreateTaskRegistryAndRegisterTasks(List<ProjectUsingTaskEl
 
             string currentDir = Directory.GetCurrentDirectory();
             TaskRegistry.InitializeTaskRegistryFromUsingTaskElements(
-                _loggingService,
-                _loggerContext,
+                _targetLoggingContext,
                 usingTaskElements.Select(el => (el, currentDir)),
                 registry,
                 RegistryExpander,
@@ -2249,7 +2249,11 @@ internal static Expander<ProjectPropertyInstance, ProjectItemInstance> GetExpand
             secondaryItemsByName.ImportItems(thirdItemGroup);
             secondaryItemsByName.ImportItems(trueItemGroup);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, secondaryItemsByName, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                secondaryItemsByName,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
             return expander;
         }
 
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index cb60a9f2d42..bd03a54d29a 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -650,12 +650,14 @@ public void RoundtripTaskParameterEventArgs()
                 new TaskItemData("ItemSpec1", null),
                 new TaskItemData("ItemSpec2", Enumerable.Range(1,3).ToDictionary(i => i.ToString(), i => i.ToString() + "value"))
             };
-            var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ItemName", items, true, DateTime.MinValue);
+            var args = new TaskParameterEventArgs(TaskParameterMessageKind.TaskOutput, "ParameterName1", "PropertyName1", "ItemName1", items, true, DateTime.MinValue);
             args.LineNumber = 265;
             args.ColumnNumber = 6;
 
             Roundtrip(args,
                 e => e.Kind.ToString(),
+                e => e.ParameterName,
+                e => e.PropertyName,
                 e => e.ItemType,
                 e => e.LogItemMetadata.ToString(),
                 e => e.LineNumber.ToString(),
diff --git a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
index 882753a8a50..4866a721238 100644
--- a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
@@ -180,7 +180,7 @@ public void ImportProperties()
         public void DeepClone()
         {
             CopyOnWritePropertyDictionary<MockValue> source = CreateInstance("a", "b", "c");
-            CopyOnWritePropertyDictionary<MockValue> clone = source.DeepClone();
+            CopyOnWritePropertyDictionary<MockValue> clone = (CopyOnWritePropertyDictionary<MockValue>)source.DeepClone();
 
             source.ShouldBe(clone);
             source.ShouldNotBeSameAs(clone);
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index b33fd7a00ce..f9157225a69 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -6,8 +6,10 @@
 using System.IO;
 using System.Text.RegularExpressions;
 using System.Xml;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -34,9 +36,9 @@ public void OverrideTasksAreFoundInOverridePath()
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             Toolset t = new Toolset("toolsversionname", dir, new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), overrideDir, new DirectoryExists(this.directoryExists));
 
-            LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
 
             string[] expectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "e1", "g1", "g2", "g3" };
             string[] expectedOverrideTasks = { "a1" /* special because it is in the override tasks file as well as in the tasks file*/, "oa1", "oa2", "og1", "ooo" };
@@ -79,8 +81,10 @@ public void OverrideTaskPathIsRelative()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", "msbuildoverridetasks");
@@ -96,8 +100,9 @@ public void OverrideTaskPathHasInvalidChars()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             mockLogger.AssertLogContains("MSB4194");
@@ -113,8 +118,9 @@ public void OverrideTaskPathHasTooLongOfAPath()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", tooLong);
@@ -131,8 +137,9 @@ public void OverrideTaskPathIsNotFound()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
 
-            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(service, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), e.ProjectRootElementCache);
+            TaskRegistry taskoverrideRegistry = (TaskRegistry)t.GetOverrideTaskRegistry(loggingContext, e.ProjectRootElementCache);
             Assert.NotNull(taskoverrideRegistry);
             Assert.Empty(taskoverrideRegistry.TaskRegistrations);
             string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", "k:\\Thecatinthehat");
@@ -153,7 +160,8 @@ public void DefaultTasksAreFoundInToolsPath()
                 null,
                 new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(null, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             string[] expectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "e1", "g1", "g2", "g3" };
             string[] unexpectedRegisteredTasks = { "c1", "d1", "f1", "11", "12", "13", "21" };
@@ -178,10 +186,11 @@ public void WarningLoggedIfNoDefaultTasksFound()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
 
             Toolset t = new Toolset("toolsversionname", "c:\\directory1\\directory2\\doesntexist", new PropertyDictionary<ProjectPropertyInstance>(), new ProjectCollection(), new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, BuildEventContext.Invalid, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             string[] unexpectedRegisteredTasks = { "a1", "a2", "a3", "a4", "b1", "c1", "d1", "e1", "f1", "g1", "g2", "g3", "11", "12", "13", "21" };
 
@@ -201,9 +210,10 @@ public void InvalidToolPath()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
             Toolset t = new Toolset("toolsversionname", "invalid||path", new PropertyDictionary<ProjectPropertyInstance>(), p, new DirectoryGetFiles(this.getFiles), new LoadXmlFromPath(this.loadXmlFromPath), null, new DirectoryExists(this.directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(service, BuildEventContext.Invalid, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             Console.WriteLine(mockLogger.FullLog);
             Assert.Equal(1, mockLogger.WarningCount); // "Expected a warning for invalid character in toolpath"
@@ -221,19 +231,18 @@ public void VerifyTasksFilesAreInSortedOrder()
             MockLogger mockLogger = new MockLogger();
             LoggingService service = (LoggingService)LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.RegisterLogger(mockLogger);
+            LoggingContext loggingContext = new TestLoggingContext(service, BuildEventContext.Invalid);
             string dir = NativeMethodsShared.IsWindows ? "c:\\directory1\\directory2" : "/directory1/directory2";
             string overrideDir = NativeMethodsShared.IsWindows ? "c:\\msbuildoverridetasks" : "/msbuildoverridetasks";
             string[] foundFiles = Toolset.GetTaskFiles(
                 new DirectoryGetFiles(this.getFiles),
-                service,
-                BuildEventContext.Invalid,
+                loggingContext,
                 "*.tasks",
                 dir,
                 String.Empty);
             string[] foundoverrideFiles = Toolset.GetTaskFiles(
                 new DirectoryGetFiles(this.getFiles),
-                service,
-                BuildEventContext.Invalid,
+                loggingContext,
                 "*.overridetasks",
                 overrideDir,
                 String.Empty);
@@ -894,7 +903,9 @@ public void InlineTasksInDotTasksFile()
                 null,
                 new DirectoryExists(directoryExists));
 
-            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(null, new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4), ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
+            LoggingContext loggingContext = TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, 4));
+
+            TaskRegistry taskRegistry = (TaskRegistry)t.GetTaskRegistry(loggingContext, ProjectCollection.GlobalProjectCollection.ProjectRootElementCache);
 
             // Did not crash due to trying to expand items without having items
         }
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 286d08a84a5..ce49dc0d6b7 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -12,6 +12,7 @@
 
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -4385,9 +4386,8 @@ public void VerifyConditionEvaluatorResetStateOnFailure()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
                 Assert.True(false, "Expect exception due to the value of property \"TargetOSFamily\" is not a number.");
             }
             catch (InvalidProjectFileException e)
@@ -4404,9 +4404,8 @@ public void VerifyConditionEvaluatorResetStateOnFailure()
                 ExpanderOptions.ExpandProperties,
                 Directory.GetCurrentDirectory(),
                 MockElementLocation.Instance,
-                null,
-                new BuildEventContext(1, 2, 3, 4),
-                FileSystems.Default));
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
         }
 
         /// <summary>
@@ -4991,7 +4990,6 @@ public void VerifyLogPropertyReassignment()
                       && r.Message.StartsWith($"{
                           ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                               "PropertyReassignment", propertyName, propertyNewValue, propertyOldValue, string.Empty)}"));
-                logger.BuildMessageEvents.ShouldBeOfTypes(new[] { typeof(PropertyReassignmentEventArgs) });
             }
         }
 
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index f47f94fd217..25187464656 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -95,7 +95,11 @@ public void ExpandAllIntoTaskItems3()
             itemsByType.ImportItems(ig);
             itemsByType.ImportItems(ig2);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, itemsByType, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                itemsByType,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             IList<TaskItem> itemsOut = expander.ExpandIntoTaskItemsLeaveEscaped("foo;bar;@(compile);@(resource)", ExpanderOptions.ExpandPropertiesAndItems, MockElementLocation.Instance);
 
@@ -802,7 +806,11 @@ private Expander<ProjectPropertyInstance, ProjectItemInstance> CreateExpander()
             ig.Add(i0);
             ig.Add(i1);
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, ig, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(
+                pg,
+                ig,
+                FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
 
             return expander;
         }
@@ -2271,9 +2279,8 @@ public void PropertyFunctionInCondition()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default));
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
             Assert.True(
                 ConditionEvaluator.EvaluateCondition(
                     @"'$(PathRoot.EndsWith(" + Path.DirectorySeparatorChar + "))' == 'false'",
@@ -2282,9 +2289,8 @@ public void PropertyFunctionInCondition()
                     ExpanderOptions.ExpandProperties,
                     Directory.GetCurrentDirectory(),
                     MockElementLocation.Instance,
-                    null,
-                    new BuildEventContext(1, 2, 3, 4),
-                    FileSystems.Default));
+                    FileSystems.Default,
+                    new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4))));
         }
 
         /// <summary>
@@ -5083,8 +5089,8 @@ public void PropertyFunctionRegisterBuildCheck()
                     new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
                 var dummyAssemblyFile = env.CreateFile(env.CreateFolder(), "test.dll");
 
-                var result = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default)
-                    .ExpandIntoStringLeaveEscaped($"$([MSBuild]::RegisterBuildCheck({dummyAssemblyFile.Path}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance, loggingContext);
+                var result = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), FileSystems.Default, loggingContext)
+                    .ExpandIntoStringLeaveEscaped($"$([MSBuild]::RegisterBuildCheck({dummyAssemblyFile.Path}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
 
                 result.ShouldBe(Boolean.TrueString);
                 _ = logger.AllBuildEvents.Select(be => be.ShouldBeOfType<BuildCheckAcquisitionEventArgs>());
diff --git a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
index 856de263ffe..06b32c45258 100644
--- a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
@@ -4,7 +4,9 @@
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.UnitTests.BackEnd;
@@ -87,7 +89,11 @@ private ProjectInstanceExpander CreateExpander(Dictionary<string, string[]> item
         {
             var itemDictionary = ToItemDictionary(items);
 
-            return new ProjectInstanceExpander(new PropertyDictionary<ProjectPropertyInstance>(), itemDictionary, (IFileSystem)FileSystems.Default);
+            return new ProjectInstanceExpander(
+                new PropertyDictionary<ProjectPropertyInstance>(),
+                itemDictionary,
+                (IFileSystem)FileSystems.Default,
+                new TestLoggingContext(null!, new BuildEventContext(1, 2, 3, 4)));
         }
 
         private static ItemDictionary<ProjectItemInstance> ToItemDictionary(Dictionary<string, string[]> itemTypes)
diff --git a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
index 8ede8eec729..f9de1bc6144 100644
--- a/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/UsedUninitializedProperties_Tests.cs
@@ -1,6 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.Build.Engine.UnitTests;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 
@@ -13,7 +15,7 @@ public sealed class UsedUninitializedProperties_Tests
     [Fact]
     public void Basics()
     {
-        UsedUninitializedProperties props = new();
+        PropertiesUseTracker props = new(TestLoggingContext.CreateTestContext(new BuildEventContext(1, 2, 3, 4)));
 
         Assert.False(props.TryGetPropertyElementLocation("Hello", out IElementLocation? elementLocation));
         Assert.Null(elementLocation);
diff --git a/src/Build.UnitTests/ExpressionTree_Tests.cs b/src/Build.UnitTests/ExpressionTree_Tests.cs
index 70ce8bb76d5..1c730e8d38d 100644
--- a/src/Build.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTree_Tests.cs
@@ -99,7 +99,7 @@ public void FunctionTests()
         {
             Parser p = new Parser();
             GenericExpressionNode tree;
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
             expander.Metadata = new StringMetadataTable(null);
             bool value;
 
@@ -149,7 +149,7 @@ public void PropertyTests()
             propertyBag.Set(ProjectPropertyInstance.Create("x86", "x86"));
             propertyBag.Set(ProjectPropertyInstance.Create("no", "no"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
             AssertParseEvaluate(p, "$(foo)", expander, true);
             AssertParseEvaluate(p, "!$(foo)", expander, false);
             // Test properties with strings
@@ -187,7 +187,7 @@ public void ItemListTests()
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "baz.cs", parentProject.FullPath));
             itemBag.Add(new ProjectItemInstance(parentProject, "Boolean", "true", parentProject.FullPath));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "@(Compile) == 'foo.cs;bar.cs;baz.cs'", expander, true);
             AssertParseEvaluate(p, "@(Compile,' ') == 'foo.cs bar.cs baz.cs'", expander, true);
@@ -230,7 +230,7 @@ public void StringExpansionTests()
             propertyBag.Set(ProjectPropertyInstance.Create("AnotherTestQuote", "Here's Johnny!"));
             propertyBag.Set(ProjectPropertyInstance.Create("Atsign", "Test the @ replacement"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "'simplestring: true foo.cs;bar.cs;baz.cs' == '$(simple): $(foo) @(compile)'", expander, true);
             AssertParseEvaluate(p, "'$(c1) $(c2)' == 'Another (complex) one. Another (complex) one.'", expander, true);
@@ -262,7 +262,7 @@ public void ComplexTests()
             propertyBag.Set(ProjectPropertyInstance.Create("c1", "Another (complex) one."));
             propertyBag.Set(ProjectPropertyInstance.Create("c2", "Another (complex) one."));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "(($(foo) != 'two' and $(bar)) and 5 >= 1) or $(one) == 1", expander, true);
             AssertParseEvaluate(p, "(($(foo) != 'twoo' or !$(bar)) and 5 >= 1) or $(two) == 1", expander, true);
@@ -283,7 +283,7 @@ public void InvalidItemInConditionEvaluation()
 
             PropertyDictionary<ProjectPropertyInstance> propertyBag = new PropertyDictionary<ProjectPropertyInstance>();
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluateThrow(p, "@(Compile) > 0", expander, null);
         }
@@ -312,7 +312,7 @@ public void OldSyntaxTests()
             propertyBag.Set(ProjectPropertyInstance.Create("c1", "Another (complex) one."));
             propertyBag.Set(ProjectPropertyInstance.Create("c2", "Another (complex) one."));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, itemBag, FileSystems.Default, null);
 
             AssertParseEvaluate(p, "(($(foo) != 'two' and $(bar)) and 5 >= 1) or $(one) == 1", expander, true);
         }
@@ -329,7 +329,7 @@ public void ConditionedPropertyUpdateTests()
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "bar.cs", parentProject.FullPath));
             itemBag.Add(new ProjectItemInstance(parentProject, "Compile", "baz.cs", parentProject.FullPath));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(new PropertyDictionary<ProjectPropertyInstance>(), itemBag, FileSystems.Default, null);
             Dictionary<string, List<string>> conditionedProperties = new Dictionary<string, List<string>>();
             ConditionEvaluator.IConditionEvaluationState state =
                                new ConditionEvaluator.ConditionEvaluationState<ProjectPropertyInstance, ProjectItemInstance>(
@@ -416,7 +416,7 @@ public void NotTests()
             propertyBag.Set(ProjectPropertyInstance.Create("foo", "4"));
             propertyBag.Set(ProjectPropertyInstance.Create("bar", "32"));
 
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, new ItemDictionary<ProjectItemInstance>(), FileSystems.Default, null);
 
             AssertParseEvaluate(p, "!true", expander, false);
             AssertParseEvaluate(p, "!(true)", expander, false);
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 9a9cc0eb4ca..c17a194274c 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -194,7 +194,7 @@ public void Metadata()
             item.MetadataCount.ShouldBe(s_builtInMetadataNames.Length + 2);
             item.DirectMetadataCount.ShouldBe(1);
 
-            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
             metadata.Count.ShouldBe(2);
             metadata["a"].EvaluatedValue.ShouldBe("override");
             metadata["b"].EvaluatedValue.ShouldBe("base");
diff --git a/src/Build.UnitTests/TestLoggingContext.cs b/src/Build.UnitTests/TestLoggingContext.cs
new file mode 100644
index 00000000000..756f61b8284
--- /dev/null
+++ b/src/Build.UnitTests/TestLoggingContext.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Engine.UnitTests
+{
+    internal sealed class TestLoggingContext : LoggingContext
+    {
+        public TestLoggingContext(ILoggingService? loggingService, BuildEventContext eventContext) : base(
+            loggingService ?? Build.BackEnd.Logging.LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1), eventContext)
+        {
+            IsValid = true;
+        }
+
+        public static LoggingContext CreateTestContext(BuildEventContext buildEventContext)
+        {
+            return new TestLoggingContext(null, buildEventContext);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 826fbadef56..9657019dc00 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -231,7 +231,7 @@ public class BuildParameters : ITranslatable
         /// </summary>
         public BuildParameters()
         {
-            Initialize(Utilities.GetEnvironmentProperties(), new ProjectRootElementCache(false), null);
+            Initialize(Utilities.GetEnvironmentProperties(makeReadOnly: false), new ProjectRootElementCache(false), null);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Caching/IConfigCache.cs b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
index 83b13f615fe..599a86d4c1d 100644
--- a/src/Build/BackEnd/Components/Caching/IConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
@@ -54,7 +54,7 @@ BuildRequestConfiguration this[int configId]
         BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
 
         /// <summary>
-        /// Gets a matching configuration.  If no such configration exists, one is created and optionally loaded.
+        /// Gets a matching configuration. If no such configuration exists, one is created and optionally loaded.
         /// </summary>
         /// <param name="configMetadata">The configuration metadata to match.</param>
         /// <param name="callback">Callback to be invoked if the configuration does not exist.</param>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index 646381478b9..40b58682006 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -80,9 +81,10 @@ internal static class BatchingEngine
         internal static List<ItemBucket> PrepareBatchingBuckets(
             List<string> batchableObjectParameters,
             Lookup lookup,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
-            return PrepareBatchingBuckets(batchableObjectParameters, lookup, null, elementLocation);
+            return PrepareBatchingBuckets(batchableObjectParameters, lookup, null, elementLocation, loggingContext);
         }
 
         /// <summary>
@@ -94,12 +96,14 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
         /// <param name="lookup"></param>
         /// <param name="implicitBatchableItemType">Any item type that can be considered an implicit input to this batchable object.
         /// This is useful for items inside targets, where the item name is plainly an item type that's an "input" to the object.</param>
+        /// <param name="loggingContext"></param>
         /// <returns>List containing ItemBucket objects, each one representing an execution batch.</returns>
         internal static List<ItemBucket> PrepareBatchingBuckets(
             List<string> batchableObjectParameters,
             Lookup lookup,
             string implicitBatchableItemType,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
             if (batchableObjectParameters == null)
             {
@@ -160,7 +164,7 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
                 {
                     // If the batchable object consumes item metadata as well as items to be batched,
                     // we need to partition the items consumed by the object.
-                    buckets = BucketConsumedItems(lookup, itemListsToBeBatched, consumedMetadataReferences, elementLocation);
+                    buckets = BucketConsumedItems(lookup, itemListsToBeBatched, consumedMetadataReferences, elementLocation, loggingContext);
                 }
             }
 
@@ -170,7 +174,12 @@ internal static List<ItemBucket> PrepareBatchingBuckets(
             {
                 // create a default bucket that references the project items and properties -- this way we always have a bucket
                 buckets = new List<ItemBucket>(1);
-                buckets.Add(new ItemBucket(null, null, lookup, buckets.Count));
+                var bucket = new ItemBucket(null, null, lookup, buckets.Count);
+                if (loggingContext != null)
+                {
+                    bucket.Initialize(loggingContext);
+                }
+                buckets.Add(bucket);
             }
 
             return buckets;
@@ -292,7 +301,8 @@ private static List<ItemBucket> BucketConsumedItems(
             Lookup lookup,
             Dictionary<string, ICollection<ProjectItemInstance>> itemListsToBeBatched,
             Dictionary<string, MetadataReference> consumedMetadataReferences,
-            ElementLocation elementLocation)
+            ElementLocation elementLocation,
+            LoggingContext loggingContext)
         {
             ErrorUtilities.VerifyThrow(itemListsToBeBatched.Count > 0, "Need item types consumed by the batchable object.");
             ErrorUtilities.VerifyThrow(consumedMetadataReferences.Count > 0, "Need item metadata consumed by the batchable object.");
@@ -330,6 +340,10 @@ private static List<ItemBucket> BucketConsumedItems(
                         if (matchingBucket == null)
                         {
                             matchingBucket = new ItemBucket(itemListsToBeBatched.Keys, itemMetadataValues, lookup, buckets.Count);
+                            if (loggingContext != null)
+                            {
+                                matchingBucket.Initialize(loggingContext);
+                            }
 
                             // make sure to put the new bucket into the appropriate location
                             // in the sorted list as indicated by the binary search
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 08cc3e9f5e0..e5d09b99d8a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -58,7 +58,7 @@ internal override void ExecuteTask(Lookup lookup)
                 {
                     List<string> parameterValues = new List<string>();
                     GetBatchableValuesFromBuildItemGroupChild(parameterValues, child);
-                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, child.ItemType, _taskInstance.Location);
+                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, child.ItemType, _taskInstance.Location, LoggingContext);
 
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
@@ -70,9 +70,8 @@ internal override void ExecuteTask(Lookup lookup)
                             ExpanderOptions.ExpandAll,
                             Project.Directory,
                             child.ConditionLocation,
-                            LoggingContext.LoggingService,
-                            LoggingContext.BuildEventContext,
-                            FileSystems.Default);
+                            FileSystems.Default,
+                            LoggingContext);
 
                         if (condition)
                         {
@@ -83,7 +82,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.KeepMetadata))
                             {
-                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation, LoggingContext).ToList();
+                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation).ToList();
                                 if (keepMetadataEvaluated.Count > 0)
                                 {
                                     keepMetadata = new HashSet<string>(keepMetadataEvaluated);
@@ -92,7 +91,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.RemoveMetadata))
                             {
-                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation, LoggingContext).ToList();
+                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation).ToList();
                                 if (removeMetadataEvaluated.Count > 0)
                                 {
                                     removeMetadata = new HashSet<string>(removeMetadataEvaluated);
@@ -101,7 +100,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.MatchOnMetadata))
                             {
-                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation, LoggingContext).ToList();
+                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation).ToList();
                                 if (matchOnMetadataEvaluated.Count > 0)
                                 {
                                     matchOnMetadata = new HashSet<string>(matchOnMetadataEvaluated);
@@ -177,8 +176,6 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     ExpanderOptions.ExpandAll,
                     Project.Directory,
                     metadataInstance.Location,
-                    LoggingContext.LoggingService,
-                    LoggingContext.BuildEventContext,
                     FileSystems.Default,
                     loggingContext: loggingContext);
 
@@ -194,7 +191,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                         expanderOptions |= ExpanderOptions.LogOnItemMetadataSelfReference;
                     }
 
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, expanderOptions, metadataInstance.Location);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -216,15 +213,16 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 ExpanderOptions.ExpandAll,
                 Project.Directory,
                 child.KeepDuplicatesLocation,
-                LoggingContext.LoggingService,
-                LoggingContext.BuildEventContext,
-                FileSystems.Default);
+                FileSystems.Default,
+                LoggingContext);
 
             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
                 ItemGroupLoggingHelper.LogTaskParameter(
                     LoggingContext,
                     TaskParameterMessageKind.AddItem,
+                    parameterName: null,
+                    propertyName: null,
                     child.ItemType,
                     itemsToAdd,
                     logItemMetadata: true,
@@ -255,7 +253,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
-                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander, LoggingContext);
+                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
             }
             else
             {
@@ -269,6 +267,8 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     ItemGroupLoggingHelper.LogTaskParameter(
                         LoggingContext,
                         TaskParameterMessageKind.RemoveItem,
+                        parameterName: null,
+                        propertyName: null,
                         child.ItemType,
                         itemsToRemove,
                         logItemMetadata: true,
@@ -325,14 +325,12 @@ private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     ExpanderOptions.ExpandAll,
                     Project.Directory,
                     metadataInstance.ConditionLocation,
-                    LoggingContext.LoggingService,
-                    LoggingContext.BuildEventContext,
                     FileSystems.Default,
                     loggingContext: loggingContext);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
                     metadataToSet[metadataInstance.Name] = Lookup.MetadataModification.CreateFromNewValue(evaluatedValue);
                 }
             }
@@ -387,7 +385,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
             // Expand properties and metadata in Include
-            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation, loggingContext);
+            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation);
 
             if (evaluatedInclude.Length == 0)
             {
@@ -398,7 +396,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             var excludes = ImmutableList<string>.Empty.ToBuilder();
             if (originalItem.Exclude.Length > 0)
             {
-                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation, loggingContext);
+                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation);
 
                 if (evaluatedExclude.Length > 0)
                 {
@@ -459,7 +457,8 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
                             includeSplit /* before wildcard expansion */,
                             null,
                             null,
-                            originalItem.Location.File));
+                            originalItem.Location.File,
+                            useItemDefinitionsWithoutModification: false));
                     }
                 }
             }
@@ -537,14 +536,12 @@ private HashSet<string> EvaluateExcludePaths(IReadOnlyList<string> excludes, Ele
         /// <param name="specification">The specification to match against the items.</param>
         /// <param name="specificationLocation">The specification to match against the provided items</param>
         /// <param name="expander">The expander to use</param>
-        /// <param name="loggingContext">Context for logging</param>
         /// <returns>A list of matching items</returns>
         private List<ProjectItemInstance> FindItemsMatchingSpecification(
             ICollection<ProjectItemInstance> items,
             string specification,
             ElementLocation specificationLocation,
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
-            LoggingContext loggingContext = null)
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
             if (items.Count == 0 || specification.Length == 0)
             {
@@ -556,7 +553,7 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification(
             HashSet<string> specificationsToFind = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             // Split by semicolons
-            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation, loggingContext);
+            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation);
 
             foreach (string piece in specificationPieces)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index df32111f095..deae62102f0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -10,6 +10,7 @@
 #endif
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -35,6 +36,7 @@ internal static class ItemGroupLoggingHelper
         internal static string ItemGroupIncludeLogMessagePrefix = ResourceUtilities.GetResourceString("ItemGroupIncludeLogMessagePrefix");
         internal static string ItemGroupRemoveLogMessage = ResourceUtilities.GetResourceString("ItemGroupRemoveLogMessage");
         internal static string OutputItemParameterMessagePrefix = ResourceUtilities.GetResourceString("OutputItemParameterMessagePrefix");
+        internal static string OutputPropertyLogMessagePrefix = ResourceUtilities.GetResourceString("OutputPropertyLogMessagePrefix");
         internal static string TaskParameterPrefix = ResourceUtilities.GetResourceString("TaskParameterPrefix");
         internal static string SkipTargetUpToDateInputs = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("SkipTargetUpToDateInputs", string.Empty);
         internal static string SkipTargetUpToDateOutputs = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("SkipTargetUpToDateOutputs", string.Empty);
@@ -255,6 +257,8 @@ private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, ob
         internal static void LogTaskParameter(
             LoggingContext loggingContext,
             TaskParameterMessageKind messageKind,
+            string parameterName,
+            string propertyName,
             string itemType,
             IList items,
             bool logItemMetadata,
@@ -263,6 +267,8 @@ internal static void LogTaskParameter(
             var args = CreateTaskParameterEventArgs(
                 loggingContext.BuildEventContext,
                 messageKind,
+                parameterName,
+                propertyName,
                 itemType,
                 items,
                 logItemMetadata,
@@ -276,6 +282,8 @@ internal static void LogTaskParameter(
         internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
             BuildEventContext buildEventContext,
             TaskParameterMessageKind messageKind,
+            string parameterName,
+            string propertyName,
             string itemType,
             IList items,
             bool logItemMetadata,
@@ -290,6 +298,8 @@ internal static TaskParameterEventArgs CreateTaskParameterEventArgs(
 
             var args = new TaskParameterEventArgs(
                 messageKind,
+                parameterName,
+                propertyName,
                 itemType,
                 items,
                 logItemMetadata,
@@ -355,26 +365,23 @@ private static void CreateItemsSnapshot(ref IList items)
 #endif
 
         internal static string GetTaskParameterText(TaskParameterEventArgs args)
-            => GetTaskParameterText(args.Kind, args.ItemType, args.Items, args.LogItemMetadata);
-
-        internal static string GetTaskParameterText(TaskParameterMessageKind messageKind, string itemType, IList items, bool logItemMetadata)
         {
-            var resourceText = messageKind switch
+            var resourceText = args.Kind switch
             {
                 TaskParameterMessageKind.AddItem => ItemGroupIncludeLogMessagePrefix,
                 TaskParameterMessageKind.RemoveItem => ItemGroupRemoveLogMessage,
                 TaskParameterMessageKind.TaskInput => TaskParameterPrefix,
-                TaskParameterMessageKind.TaskOutput => OutputItemParameterMessagePrefix,
+                TaskParameterMessageKind.TaskOutput => args.PropertyName is null ? OutputItemParameterMessagePrefix : OutputPropertyLogMessagePrefix,
                 TaskParameterMessageKind.SkippedTargetInputs => SkipTargetUpToDateInputs,
                 TaskParameterMessageKind.SkippedTargetOutputs => SkipTargetUpToDateOutputs,
-                _ => throw new NotImplementedException($"Unsupported {nameof(TaskParameterMessageKind)} value: {messageKind}")
+                _ => throw new NotImplementedException($"Unsupported {nameof(TaskParameterMessageKind)} value: {args.Kind}")
             };
 
             var itemGroupText = GetParameterText(
                 resourceText,
-                itemType,
-                items,
-                logItemMetadata);
+                args.PropertyName ?? args.ItemType,
+                args.Items,
+                args.LogItemMetadata);
             return itemGroupText;
         }
     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
index 419ff97e0bd..18d85f2323c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/PropertyGroupIntrinsicTask.cs
@@ -52,7 +52,7 @@ internal override void ExecuteTask(Lookup lookup)
                     // Find all the metadata references in order to create buckets
                     List<string> parameterValues = new List<string>();
                     GetBatchableValuesFromProperty(parameterValues, property);
-                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, property.Location);
+                    buckets = BatchingEngine.PrepareBatchingBuckets(parameterValues, lookup, property.Location, LoggingContext);
 
                     // "Execute" each bucket
                     foreach (ItemBucket bucket in buckets)
@@ -64,9 +64,8 @@ internal override void ExecuteTask(Lookup lookup)
                             ExpanderOptions.ExpandAll,
                             Project.Directory,
                             property.ConditionLocation,
-                            LoggingContext.LoggingService,
-                            LoggingContext.BuildEventContext,
-                            FileSystems.Default);
+                            FileSystems.Default,
+                            LoggingContext);
 
                         if (condition)
                         {
@@ -78,7 +77,12 @@ internal override void ExecuteTask(Lookup lookup)
                                 "CannotModifyReservedProperty",
                                 property.Name);
 
+                            bucket.Expander.PropertiesUseTracker.CurrentlyEvaluatingPropertyElementName = property.Name;
+                            bucket.Expander.PropertiesUseTracker.PropertyReadContext =
+                                PropertyReadContext.PropertyEvaluation;
+
                             string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(property.Value, ExpanderOptions.ExpandAll, property.Location);
+                            bucket.Expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(property, evaluatedValue, LoggingContext);
 
                             if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents)
                             {
@@ -97,6 +101,8 @@ internal override void ExecuteTask(Lookup lookup)
                         foreach (ItemBucket bucket in buckets)
                         {
                             bucket.LeaveScope();
+                            // We are now done processing this property - so no need to pop its previous context.
+                            bucket.Expander.PropertiesUseTracker.ResetPropertyReadContext(pop: false);
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index 21650e6448f..950b2848a68 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -3,6 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
+using System.Diagnostics;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -30,12 +33,12 @@ internal sealed class ItemBucket : IComparable
         /// <summary>
         /// Metadata in this bucket
         /// </summary>
-        private Dictionary<string, string> _metadata;
+        private readonly Dictionary<string, string> _metadata;
 
         /// <summary>
         /// The items for this bucket.
         /// </summary>
-        private Lookup _lookup;
+        private readonly Lookup _lookup;
 
         /// <summary>
         /// When buckets are being created for batching purposes, this indicates which order the
@@ -44,22 +47,23 @@ internal sealed class ItemBucket : IComparable
         /// bucket created gets bucketSequenceNumber=0, the second bucket created gets
         /// bucketSequenceNumber=1, etc.
         /// </summary>
-        private int _bucketSequenceNumber;
+        private readonly int _bucketSequenceNumber;
 
         /// <summary>
         /// The entry we enter when we create the bucket.
         /// </summary>
-        private Lookup.Scope _lookupEntry;
+        private readonly Lookup.Scope _lookupEntry;
 
         #endregion
 
         #region Constructors
 
         /// <summary>
-        /// Private default constructor disallows parameterless instantiation.
+        /// Private constructor for creating comparison bucket.
         /// </summary>
-        private ItemBucket()
+        private ItemBucket(Dictionary<string, string> metadata)
         {
+            _metadata = metadata;
             // do nothing
         }
 
@@ -95,11 +99,19 @@ internal ItemBucket(
             }
 
             _metadata = metadata;
-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(metadata), FileSystems.Default);
 
             _bucketSequenceNumber = bucketSequenceNumber;
         }
 
+        /// <summary>
+        /// Updates the logging context that this bucket is going to use.
+        /// </summary>
+        /// <param name="loggingContext"></param>
+        internal void Initialize(LoggingContext loggingContext)
+        {
+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(_lookup, _lookup, new StringMetadataTable(_metadata), FileSystems.Default, loggingContext);
+        }
+
         #endregion
 
         #region Comparison methods
@@ -131,8 +143,7 @@ public int CompareTo(object obj)
         /// <returns>An item bucket that is invalid for everything except comparisons.</returns>
         internal static ItemBucket GetDummyBucketForComparisons(Dictionary<string, string> metadata)
         {
-            ItemBucket bucket = new ItemBucket();
-            bucket._metadata = metadata;
+            ItemBucket bucket = new ItemBucket(metadata);
 
             return bucket;
         }
@@ -147,6 +158,7 @@ internal Expander<ProjectPropertyInstance, ProjectItemInstance> Expander
         {
             get
             {
+                Debug.Assert(_expander != null, "ItemBucket.Initialize was not properly called");
                 return _expander;
             }
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index bb3f3c87d9e..6ff9319f3eb 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -737,7 +737,7 @@ private async Task<bool> PushTargets(IList<TargetSpecification> targets, TargetE
 
                 // Add to the list of targets to push.  We don't actually put it on the stack here because we could run into a circular dependency
                 // during this loop, in which case the target stack would be out of whack.
-                TargetEntry newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, buildReason, _componentHost, stopProcessingOnCompletion);
+                TargetEntry newEntry = new TargetEntry(_requestEntry, this as ITargetBuilderCallback, targetSpecification, baseLookup, parentTargetEntry, buildReason, _componentHost, _projectLoggingContext, stopProcessingOnCompletion);
                 newEntry.ErrorTarget = addAsErrorTarget;
                 targetsToPush.Add(newEntry);
                 stopProcessingOnCompletion = false; // The first target on the stack (the last one to be run) always inherits the stopProcessing flag.
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index bbfc80ae5d9..cc277b9d048 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -7,6 +7,7 @@
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
@@ -162,8 +163,17 @@ internal class TargetEntry : IEquatable<TargetEntry>
         /// <param name="parentTarget">The parent of this entry, if any.</param>
         /// <param name="buildReason">The reason the parent built this target.</param>
         /// <param name="host">The Build Component Host to use.</param>
+        /// <param name="loggingContext"></param>
         /// <param name="stopProcessingOnCompletion">True if the target builder should stop processing the current target stack when this target is complete.</param>
-        internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, TargetBuiltReason buildReason, IBuildComponentHost host, bool stopProcessingOnCompletion)
+        internal TargetEntry(
+            BuildRequestEntry requestEntry,
+            ITargetBuilderCallback targetBuilderCallback,
+            TargetSpecification targetSpecification,
+            Lookup baseLookup, TargetEntry parentTarget,
+            TargetBuiltReason buildReason,
+            IBuildComponentHost host,
+            LoggingContext loggingContext,
+            bool stopProcessingOnCompletion)
         {
             ErrorUtilities.VerifyThrowArgumentNull(requestEntry, nameof(requestEntry));
             ErrorUtilities.VerifyThrowArgumentNull(targetBuilderCallback, nameof(targetBuilderCallback));
@@ -176,7 +186,7 @@ internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targ
             _targetSpecification = targetSpecification;
             _parentTarget = parentTarget;
             _buildReason = buildReason;
-            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(baseLookup, baseLookup, FileSystems.Default);
+            _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(baseLookup, baseLookup, FileSystems.Default, loggingContext);
             _state = TargetEntryState.Dependencies;
             _baseLookup = baseLookup;
             _host = host;
@@ -351,8 +361,6 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 ExpanderOptions.ExpandPropertiesAndItems,
                 _requestEntry.ProjectRootDirectory,
                 _target.ConditionLocation,
-                projectLoggingContext.LoggingService,
-                projectLoggingContext.BuildEventContext,
                 FileSystems.Default,
                 loggingContext: projectLoggingContext);
 
@@ -393,7 +401,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 return new List<TargetSpecification>();
             }
 
-            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation, projectLoggingContext);
+            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation);
             List<TargetSpecification> dependencyTargets = new List<TargetSpecification>();
             foreach (string escapedDependency in dependencies)
             {
@@ -420,7 +428,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
 
                 // Generate the batching buckets.  Note that each bucket will get a lookup based on the baseLookup.  This lookup will be in its
                 // own scope, which we will collapse back down into the baseLookup at the bottom of the function.
-                List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
+                List<ItemBucket> buckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location, null);
 
                 WorkUnitResult aggregateResult = new WorkUnitResult();
                 TargetLoggingContext targetLoggingContext = null;
@@ -445,6 +453,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                     }
 
                     targetLoggingContext = projectLoggingContext.LogTargetBatchStarted(projectFullPath, _target, parentTargetName, _buildReason);
+                    bucket.Initialize(targetLoggingContext);
                     WorkUnitResult bucketResult = null;
                     targetSuccess = false;
 
@@ -612,14 +621,14 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                  ExpanderOptions.ExpandPropertiesAndItems,
                                  requestEntry.ProjectRootDirectory,
                                  _target.KeepDuplicateOutputsLocation,
-                                 projectLoggingContext.LoggingService,
-                                 projectLoggingContext.BuildEventContext, FileSystems.Default);
+                                 FileSystems.Default,
+                                 projectLoggingContext);
 
                         // NOTE: we need to gather the outputs in batches, because the output specification may reference item metadata
                         // Also, we are using the baseLookup, which has possibly had changes made to it since the project started.  Because of this, the
                         // set of outputs calculated here may differ from those which would have been calculated at the beginning of the target.  It is
                         // assumed the user intended this.
-                        List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location);
+                        List<ItemBucket> batchingBuckets = BatchingEngine.PrepareBatchingBuckets(GetBatchableParametersForTarget(), _baseLookup, _target.Location, targetLoggingContext);
 
                         if (keepDupes)
                         {
@@ -704,8 +713,8 @@ internal List<TargetSpecification> GetErrorTargets(ProjectLoggingContext project
                     ExpanderOptions.ExpandPropertiesAndItems,
                     _requestEntry.ProjectRootDirectory,
                     errorTargetInstance.ConditionLocation,
-                    projectLoggingContext.LoggingService,
-                    projectLoggingContext.BuildEventContext, FileSystems.Default);
+                    FileSystems.Default,
+                    projectLoggingContext);
 
                 if (condition)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index 4b40715d67b..9940131c9e9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -368,6 +368,8 @@ private void LogUniqueInputsAndOutputs()
             var args = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 _buildEventContext,
                 TaskParameterMessageKind.SkippedTargetInputs,
+                parameterName: null,
+                propertyName: null,
                 itemType: null,
                 _uniqueTargetInputs.Keys.ToArray(),
                 logItemMetadata: false,
@@ -377,6 +379,8 @@ private void LogUniqueInputsAndOutputs()
             args = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 _buildEventContext,
                 TaskParameterMessageKind.SkippedTargetOutputs,
+                parameterName: null,
+                propertyName: null,
                 itemType: null,
                 _uniqueTargetOutputs.Keys.ToArray(),
                 logItemMetadata: false,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 485ee854f73..6bc0dd7fc23 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -313,7 +313,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 }
 
                 List<string> taskParameterValues = CreateListOfParameterValues();
-                buckets = BatchingEngine.PrepareBatchingBuckets(taskParameterValues, lookup, _targetChildInstance.Location);
+                buckets = BatchingEngine.PrepareBatchingBuckets(taskParameterValues, lookup, _targetChildInstance.Location, _targetLoggingContext);
 
                 Dictionary<string, string> lookupHash = null;
 
@@ -379,8 +379,6 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 ExpanderOptions.ExpandAll,
                 _buildRequestEntry.ProjectRootDirectory,
                 _targetChildInstance.ConditionLocation,
-                _targetLoggingContext.LoggingService,
-                _targetLoggingContext.BuildEventContext,
                 FileSystems.Default,
                 loggingContext: _targetLoggingContext);
 
@@ -614,7 +612,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation, loggingContext: _targetLoggingContext);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
@@ -1080,9 +1078,8 @@ private bool GatherTaskOutputs(TaskExecutionHost taskExecutionHost, TaskExecutio
                     ExpanderOptions.ExpandAll,
                     _buildRequestEntry.ProjectRootDirectory,
                     taskOutputSpecification.ConditionLocation,
-                    _targetLoggingContext.LoggingService,
-                    _targetLoggingContext.BuildEventContext,
-                    FileSystems.Default);
+                    FileSystems.Default,
+                    _targetLoggingContext);
 
                 if (condition)
                 {
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index fdff89eb618..1a2ba345658 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -1177,7 +1177,7 @@ private bool InitializeTaskScalarParameter(
                 else
                 {
                     // Expand out all the metadata, properties, and item vectors in the string.
-                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation, _targetLoggingContext);
+                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
 
                     if (expandedParameterValue.Length == 0)
                     {
@@ -1317,10 +1317,14 @@ private bool InternalSetTaskParameter(
                     // Structured logging for all parameters that have logging enabled and are not empty lists.
                     if (parameterValueAsList?.Count > 0 || (parameterValueAsList == null && !legacyBehavior))
                     {
+                        // Note: We're setting TaskParameterEventArgs.ItemType to parameter name for backward compatibility with
+                        // older loggers and binlog viewers.
                         ItemGroupLoggingHelper.LogTaskParameter(
                             _taskLoggingContext,
                             TaskParameterMessageKind.TaskInput,
-                            parameter.Name,
+                            parameterName: parameter.Name,
+                            propertyName: null,
+                            itemType: parameter.Name,
                             parameterValueAsList ?? new object[] { parameterValue },
                             parameter.LogItemMetadata);
                     }
@@ -1429,7 +1433,9 @@ static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary c
                         ItemGroupLoggingHelper.LogTaskParameter(
                             _taskLoggingContext,
                             TaskParameterMessageKind.TaskOutput,
-                            outputTargetName,
+                            parameterName: parameter.Name,
+                            propertyName: null,
+                            itemType: outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
                     }
@@ -1470,7 +1476,23 @@ static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary c
                         var outputString = joinedOutputs.ToString();
                         if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
                         {
-                            _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
+                            {
+                                // Note: We're setting TaskParameterEventArgs.ItemType to property name for backward compatibility with
+                                // older loggers and binlog viewers.
+                                ItemGroupLoggingHelper.LogTaskParameter(
+                                    _taskLoggingContext,
+                                    TaskParameterMessageKind.TaskOutput,
+                                    parameterName: parameter.Name,
+                                    propertyName: outputTargetName,
+                                    itemType: outputTargetName,
+                                    new object[] { outputString },
+                                    parameter.LogItemMetadata);
+                            }
+                            else
+                            {
+                                _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            }
                         }
 
                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));
@@ -1505,7 +1527,9 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         ItemGroupLoggingHelper.LogTaskParameter(
                             _taskLoggingContext,
                             TaskParameterMessageKind.TaskOutput,
-                            outputTargetName,
+                            parameterName: parameter.Name,
+                            propertyName: null,
+                            itemType: outputTargetName,
                             outputs,
                             parameter.LogItemMetadata);
                     }
@@ -1539,7 +1563,23 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         var outputString = joinedOutputs.ToString();
                         if (LogTaskInputs && !_taskLoggingContext.LoggingService.OnlyLogCriticalEvents)
                         {
-                            _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12))
+                            {
+                                // Note: We're setting TaskParameterEventArgs.ItemType to property name for backward compatibility with
+                                // older loggers and binlog viewers.
+                                ItemGroupLoggingHelper.LogTaskParameter(
+                                    _taskLoggingContext,
+                                    TaskParameterMessageKind.TaskOutput,
+                                    parameterName: parameter.Name,
+                                    propertyName: outputTargetName,
+                                    itemType: outputTargetName,
+                                    new object[] { outputString },
+                                    parameter.LogItemMetadata);
+                            }
+                            else
+                            {
+                                _taskLoggingContext.LogComment(MessageImportance.Low, "OutputPropertyLogMessage", outputTargetName, outputString);
+                            }
                         }
 
                         _batchBucket.Lookup.SetProperty(ProjectPropertyInstance.Create(outputTargetName, outputString, parameterLocation, _projectInstance.IsImmutable));
diff --git a/src/Build/BuildCheck/.editorconfig b/src/Build/BuildCheck/.editorconfig
new file mode 100644
index 00000000000..731ad1c1785
--- /dev/null
+++ b/src/Build/BuildCheck/.editorconfig
@@ -0,0 +1,2 @@
+[*.cs]
+csharp_style_namespace_declarations = file_scoped:warning
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
index 4940db20fd1..ab817077725 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
@@ -1,6 +1,10 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
@@ -42,4 +46,73 @@ public class BuildAnalyzerConfiguration
     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
     /// </summary>
     public bool? IsEnabled { get; internal init; }
+
+    /// <summary>
+    /// Creates a <see cref="BuildAnalyzerConfiguration"/> object based on the provided configuration dictionary.
+    /// If the BuildAnalyzerConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
+    /// If parsing failed the value will be equal to null.
+    /// </summary>
+    /// <param name="configDictionary">The configuration dictionary containing the settings for the build analyzer. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
+    /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
+    internal static BuildAnalyzerConfiguration Create(Dictionary<string, string>? configDictionary)
+    {
+        return new()
+        {
+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,
+            Severity = TryExtractValue(nameof(Severity), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,
+            IsEnabled = TryExtractValue(nameof(IsEnabled), configDictionary, out bool isEnabled) ? isEnabled : null,
+        };
+    }
+
+    private static bool TryExtractValue<T>(string key, Dictionary<string, string>? config, out T value) where T : struct, Enum
+    {
+        value = default;
+
+        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
+        {
+            return false;
+        }
+
+        var isParsed = Enum.TryParse(stringValue, true, out value);
+
+        if (!isParsed)
+        {
+            ThrowIncorrectValueException(key, stringValue);
+        }
+
+        return isParsed;
+    }
+
+    private static bool TryExtractValue(string key, Dictionary<string, string>? config, out bool value)
+    {
+        value = default;
+
+        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
+        {
+            return false;
+        }
+
+        bool isParsed = false;
+        
+        if (bool.TryParse(stringValue, out bool boolValue))
+        {
+            value = boolValue;
+            isParsed = true;
+        }
+        
+        if (!isParsed)
+        {
+            ThrowIncorrectValueException(key, stringValue);
+        }
+
+        return isParsed;
+    }
+
+    private static void ThrowIncorrectValueException(string key, string value)
+    {
+        // TODO: It will be nice to have the filename where the incorrect configuration was placed. 
+        throw new BuildCheckConfigurationException(
+                $"Incorrect value provided in config for key {key}: '{value}'",
+                buildCheckConfigurationErrorScope: BuildCheckConfigurationErrorScope.EditorConfigParser);
+    }
 }
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
index 81576a42fb5..3ecdd7c6527 100644
--- a/src/Build/BuildCheck/API/ConfigurationContext.cs
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -20,19 +20,9 @@ private ConfigurationContext(CustomConfigurationData[] customConfigurationData)
 
     internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData)
     {
-        if (!customConfigurationData.Any(BuildCheck.CustomConfigurationData.NotNull))
-        {
-            return Null;
-        }
-
-        return new ConfigurationContext(
-            customConfigurationData
-                .Where(BuildCheck.CustomConfigurationData.NotNull)
-                .ToArray());
+        return new ConfigurationContext(customConfigurationData);
     }
 
-    internal static ConfigurationContext Null { get; } = new(Array.Empty<CustomConfigurationData>());
-
     /// <summary>
     /// Custom configuration data - per each rule that has some specified.
     /// </summary>
diff --git a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
index 04cdf5aa87f..d8ad5a396ef 100644
--- a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
+++ b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
@@ -9,4 +9,5 @@ public interface IBuildCheckRegistrationContext
 {
     void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
     void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+    void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction);
 }
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index 673c98919a4..ee755cc7352 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -42,18 +42,17 @@ public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisiti
             assembly = Assembly.LoadFrom(analyzerAcquisitionData.AssemblyPath);
 #endif
 
-            IEnumerable<Type> analyzerTypes = assembly.GetExportedTypes().Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t));
+            IList<Type> availableTypes = assembly.GetExportedTypes();
+            IList<Type> analyzerTypes = availableTypes.Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t)).ToArray();
 
-            foreach (Type analyzerType in analyzerTypes)
+            foreach (Type analyzerCandidate in analyzerTypes)
             {
-                if (Activator.CreateInstance(analyzerType) is BuildAnalyzer instance)
-                {
-                    analyzersFactories.Add(() => instance);
-                }
-                else
-                {
-                    throw new InvalidOperationException($"Failed to create an instance of type {analyzerType.FullName} as BuildAnalyzer.");
-                }
+                analyzersFactories.Add(() => (BuildAnalyzer)Activator.CreateInstance(analyzerCandidate)!);
+            }
+
+            if (availableTypes.Count != analyzerTypes.Count)
+            {
+                availableTypes.Except(analyzerTypes).ToList().ForEach(t => _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerBaseTypeNotAssignable", t.Name, t.Assembly));
             }
         }
         catch (ReflectionTypeLoadException ex)
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
index 7bf3702aa4f..a09866ebb22 100644
--- a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
+++ b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
@@ -21,7 +21,7 @@ internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
 
     public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } =[SupportedRule];
+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 838a5454ca8..32078038875 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -15,11 +15,19 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// </summary>
 internal sealed class BuildCheckCentralContext
 {
+    private readonly ConfigurationProvider _configurationProvider;
+
+    internal BuildCheckCentralContext(ConfigurationProvider configurationProvider)
+    {
+        _configurationProvider = configurationProvider;
+    }
+
     private record CallbackRegistry(
         List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>)> EvaluatedPropertiesActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions)
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions,
+        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<TaskInvocationAnalysisData>>)> TaskInvocationActions)
     {
-        public CallbackRegistry() : this([],[]) { }
+        public CallbackRegistry() : this([], [], []) { }
     }
 
     // In a future we can have callbacks per project as well
@@ -27,8 +35,9 @@ public CallbackRegistry() : this([],[]) { }
 
     // This we can potentially use to subscribe for receiving evaluated props in the
     //  build event args. However - this needs to be done early on, when analyzers might not be known yet
-    internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Any();
-    internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Any();
+    internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Count > 0;
+    internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Count > 0;
+    internal bool HasTaskInvocationActions => _globalCallbacks.TaskInvocationActions.Count > 0;
 
     internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
         // Here we might want to communicate to node that props need to be sent.
@@ -38,6 +47,9 @@ internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, A
     internal void RegisterParsedItemsAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
         => RegisterAction(analyzer, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
 
+    internal void RegisterTaskInvocationAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
+        => RegisterAction(analyzer, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
+
     private void RegisterAction<T>(
         BuildAnalyzerWrapper wrappedAnalyzer,
         Action<BuildCheckDataContext<T>> handler,
@@ -60,6 +72,7 @@ internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
     {
         _globalCallbacks.EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == analyzer);
         _globalCallbacks.ParsedItemsActions.RemoveAll(a => a.Item1 == analyzer);
+        _globalCallbacks.TaskInvocationActions.RemoveAll(a => a.Item1 == analyzer);
     }
 
     internal void RunEvaluatedPropertiesActions(
@@ -78,6 +91,14 @@ internal void RunParsedItemsActions(
         => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsAnalysisData,
             loggingContext, resultHandler);
 
+    internal void RunTaskInvocationActions(
+        TaskInvocationAnalysisData taskInvocationAnalysisData,
+        LoggingContext loggingContext,
+        Action<BuildAnalyzerWrapper, LoggingContext, BuildAnalyzerConfigurationInternal[], BuildCheckResult>
+            resultHandler)
+        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationAnalysisData,
+            loggingContext, resultHandler);
+
     private void RunRegisteredActions<T>(
         List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
         T analysisData,
@@ -112,7 +133,7 @@ private void RunRegisteredActions<T>(
                 else
                 {
                     configPerRule =
-                        ConfigurationProvider.GetMergedConfigurations(projectFullPath,
+                        _configurationProvider.GetMergedConfigurations(projectFullPath,
                             analyzerCallback.Item1.BuildAnalyzer);
                     if (configPerRule.All(c => !c.IsEnabled))
                     {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs
new file mode 100644
index 00000000000..9c4c06511be
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs
@@ -0,0 +1,17 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+internal enum BuildCheckConfigurationErrorScope
+{
+    /// <summary>
+    /// Error related to the single rule.
+    /// </summary>
+    SingleRule,
+
+    /// <summary>
+    /// Error related to the parsing of .editorconfig file. 
+    /// </summary>
+    EditorConfigParser
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
index ed795891df5..69f3335681d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -15,7 +15,15 @@ internal sealed class BuildCheckConfigurationException : Exception
     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
     /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
     /// </summary>
-    public BuildCheckConfigurationException(string message) : base(message)
+    internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;
+
+    public BuildCheckConfigurationException(string message, Exception innerException, BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message, innerException)
+    {
+        this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
+    }
+
+    public BuildCheckConfigurationException(string message, BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message)
     {
+        this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 678949cea33..7dad5f0c4da 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -36,6 +36,10 @@ public void Initialize(IEventSource eventSource)
         eventSource.AnyEventRaised += EventSource_AnyEventRaised;
         eventSource.BuildFinished += EventSource_BuildFinished;
 
+        if (eventSource is IEventSource3 eventSource3)
+        {
+            eventSource3.IncludeTaskInputs();
+        }
         if (eventSource is IEventSource4 eventSource4)
         {
             eventSource4.IncludeEvaluationPropertiesAndItems();
@@ -74,6 +78,27 @@ private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
         }
     }
 
+    private void HandleTaskStartedEvent(TaskStartedEventArgs eventArgs)
+    {
+        _buildCheckManager.ProcessTaskStartedEventArgs(
+            _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
+            eventArgs);
+    }
+
+    private void HandleTaskFinishedEvent(TaskFinishedEventArgs eventArgs)
+    {
+        _buildCheckManager.ProcessTaskFinishedEventArgs(
+            _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
+            eventArgs);
+    }
+
+    private void HandleTaskParameterEvent(TaskParameterEventArgs eventArgs)
+    {
+        _buildCheckManager.ProcessTaskParameterEventArgs(
+            _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
+            eventArgs);
+    }
+
     private bool IsMetaProjFile(string? projectFile) => !string.IsNullOrEmpty(projectFile) && projectFile!.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase);
 
     private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
@@ -137,6 +162,9 @@ private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData
         { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => _buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
         { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => HandleBuildCheckTracingEvent((BuildCheckTracingEventArgs)e) },
         { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData(), GetBuildEventContext(e)) },
+        { typeof(TaskStartedEventArgs), (BuildEventArgs e) => HandleTaskStartedEvent((TaskStartedEventArgs)e) },
+        { typeof(TaskFinishedEventArgs), (BuildEventArgs e) => HandleTaskFinishedEvent((TaskFinishedEventArgs)e) },
+        { typeof(TaskParameterEventArgs), (BuildEventArgs e) => HandleTaskParameterEvent((TaskParameterEventArgs)e) },
     };
 
     private BuildEventContext GetBuildEventContext(BuildEventArgs e) => e.BuildEventContext
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
index a4c4793c7e6..76ac5ec7767 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
@@ -18,4 +18,9 @@ public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAn
     {
         buildCheckCentralContext.RegisterParsedItemsAction(analyzerWrapper, parsedItemsAction);
     }
+
+    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
+    {
+        buildCheckCentralContext.RegisterTaskInvocationAction(analyzerWrapper, taskInvocationAction);
+    }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index e1704ea15f9..f76b6434356 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -64,7 +64,8 @@ public void InitializeComponent(IBuildComponentHost host)
     internal sealed class BuildCheckManager : IBuildCheckManager
     {
         private readonly TracingReporter _tracingReporter = new TracingReporter();
-        private readonly BuildCheckCentralContext _buildCheckCentralContext = new();
+        private readonly ConfigurationProvider _configurationProvider = new ConfigurationProvider();
+        private readonly BuildCheckCentralContext _buildCheckCentralContext;
         private readonly ILoggingService _loggingService;
         private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
@@ -76,6 +77,7 @@ internal BuildCheckManager(ILoggingService loggingService)
             _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule(loggingService);
             _loggingService = loggingService;
+            _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
         }
 
@@ -137,11 +139,23 @@ private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzer
             []
         ];
 
+        /// <summary>
+        /// For tests only. TODO: Remove when analyzer acquisition is done.
+        /// </summary>
+        internal static (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][]? s_testFactoriesPerDataSource;
+
         private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
         {
             _analyzersRegistry.AddRange(
                 s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
                     .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+
+            if (s_testFactoriesPerDataSource is not null)
+            {
+                _analyzersRegistry.AddRange(
+                    s_testFactoriesPerDataSource[(int)buildCheckDataSource]
+                        .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+            }
         }
 
         /// <summary>
@@ -201,7 +215,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
             if (analyzerFactoryContext.MaterializedAnalyzer == null)
             {
                 BuildAnalyzerConfiguration[] userConfigs =
-                    ConfigurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
                 if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
                 {
@@ -210,7 +224,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                 }
 
                 CustomConfigurationData[] customConfigData =
-                    ConfigurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData);
 
@@ -234,7 +248,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                         $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
                 }
 
-                configurations = ConfigurationProvider.GetMergedConfigurations(userConfigs, analyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, analyzer);
 
                 // technically all analyzers rules could be disabled, but that would mean
                 // that the provided 'IsEnabledByDefault' value wasn't correct - the only
@@ -249,9 +263,9 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
             {
                 wrapper = analyzerFactoryContext.MaterializedAnalyzer;
 
-                configurations = ConfigurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
 
-                ConfigurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
+                _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
                     analyzerFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
@@ -312,6 +326,24 @@ public void ProcessEvaluationFinishedEventArgs(
             => _buildEventsProcessor
                 .ProcessEvaluationFinishedEventArgs(buildAnalysisContext, evaluationFinishedEventArgs);
 
+        public void ProcessTaskStartedEventArgs(
+            AnalyzerLoggingContext buildAnalysisContext,
+            TaskStartedEventArgs taskStartedEventArgs)
+            => _buildEventsProcessor
+                .ProcessTaskStartedEventArgs(buildAnalysisContext, taskStartedEventArgs);
+
+        public void ProcessTaskFinishedEventArgs(
+            AnalyzerLoggingContext buildAnalysisContext,
+            TaskFinishedEventArgs taskFinishedEventArgs)
+            => _buildEventsProcessor
+                .ProcessTaskFinishedEventArgs(buildAnalysisContext, taskFinishedEventArgs);
+
+        public void ProcessTaskParameterEventArgs(
+            AnalyzerLoggingContext buildAnalysisContext,
+            TaskParameterEventArgs taskParameterEventArgs)
+            => _buildEventsProcessor
+                .ProcessTaskParameterEventArgs(buildAnalysisContext, taskParameterEventArgs);
+
         public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats()
         {
             foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index 16218c7417d..aa804067b60 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -25,9 +25,27 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralContext)
 {
+    /// <summary>
+    /// Represents a task currently being executed.
+    /// </summary>
+    /// <remarks>
+    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="AnalysisData"/>
+    /// is immutable.
+    /// </remarks>
+    private struct ExecutingTaskData
+    {
+        public TaskInvocationAnalysisData AnalysisData;
+        public Dictionary<string, TaskInvocationAnalysisData.TaskParameter> TaskParameters;
+    }
+
     private readonly SimpleProjectRootElementCache _cache = new SimpleProjectRootElementCache();
     private readonly BuildCheckCentralContext _buildCheckCentralContext = buildCheckCentralContext;
 
+    /// <summary>
+    /// Keeps track of in-flight tasks. Keyed by task ID as passed in <see cref="BuildEventContext.TaskId"/>.
+    /// </summary>
+    private readonly Dictionary<int, ExecutingTaskData> _tasksBeingExecuted = [];
+
     // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
     internal void ProcessEvaluationFinishedEventArgs(
         AnalyzerLoggingContext buildAnalysisContext,
@@ -55,6 +73,95 @@ internal void ProcessEvaluationFinishedEventArgs(
         }
     }
 
+    internal void ProcessTaskStartedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskStartedEventArgs taskStartedEventArgs)
+    {
+        if (!_buildCheckCentralContext.HasTaskInvocationActions)
+        {
+            // No analyzer is interested in task invocation actions -> nothing to do.
+            return;
+        }
+
+        if (taskStartedEventArgs.BuildEventContext is not null)
+        {
+            ElementLocation invocationLocation = ElementLocation.Create(
+                taskStartedEventArgs.TaskFile,
+                taskStartedEventArgs.LineNumber,
+                taskStartedEventArgs.ColumnNumber);
+
+            // Add a new entry to _tasksBeingExecuted. TaskParameters are initialized empty and will be recorded
+            // based on TaskParameterEventArgs we receive later.
+            Dictionary<string, TaskInvocationAnalysisData.TaskParameter> taskParameters = new();
+
+            ExecutingTaskData taskData = new()
+            {
+                TaskParameters = taskParameters,
+                AnalysisData = new(
+                    projectFilePath: taskStartedEventArgs.ProjectFile!,
+                    taskInvocationLocation: invocationLocation,
+                    taskName: taskStartedEventArgs.TaskName,
+                    taskAssemblyLocation: taskStartedEventArgs.TaskAssemblyLocation,
+                    parameters: taskParameters),
+            };
+
+            _tasksBeingExecuted.Add(taskStartedEventArgs.BuildEventContext.TaskId, taskData);
+        }
+    }
+
+    internal void ProcessTaskFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskFinishedEventArgs taskFinishedEventArgs)
+    {
+        if (!_buildCheckCentralContext.HasTaskInvocationActions)
+        {
+            // No analyzer is interested in task invocation actions -> nothing to do.
+            return;
+        }
+
+        if (taskFinishedEventArgs.BuildEventContext is not null &&
+            _tasksBeingExecuted.TryGetValue(taskFinishedEventArgs.BuildEventContext.TaskId, out ExecutingTaskData taskData))
+        {
+            // All task parameters have been recorded by now so remove the task from the dictionary and fire the registered build check actions.
+            _tasksBeingExecuted.Remove(taskFinishedEventArgs.BuildEventContext.TaskId);
+            _buildCheckCentralContext.RunTaskInvocationActions(taskData.AnalysisData, buildAnalysisContext, ReportResult);
+        }
+    }
+
+    internal void ProcessTaskParameterEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskParameterEventArgs taskParameterEventArgs)
+    {
+        if (!_buildCheckCentralContext.HasTaskInvocationActions)
+        {
+            // No analyzer is interested in task invocation actions -> nothing to do.
+            return;
+        }
+
+        bool isOutput;
+        switch (taskParameterEventArgs.Kind)
+        {
+            case TaskParameterMessageKind.TaskInput: isOutput = false; break;
+            case TaskParameterMessageKind.TaskOutput: isOutput = true; break;
+            default: return;
+        }
+
+        if (taskParameterEventArgs.BuildEventContext is not null &&
+            _tasksBeingExecuted.TryGetValue(taskParameterEventArgs.BuildEventContext.TaskId, out ExecutingTaskData taskData))
+        {
+            // Add the parameter name and value to the matching entry in _tasksBeingExecuted. Parameters come typed as IList
+            // but it's more natural to pass them as scalar values so we unwrap one-element lists.
+            string parameterName = taskParameterEventArgs.ParameterName;
+            object? parameterValue = taskParameterEventArgs.Items?.Count switch
+            {
+                1 => taskParameterEventArgs.Items[0],
+                _ => taskParameterEventArgs.Items,
+            };
+
+            taskData.TaskParameters[parameterName] = new TaskInvocationAnalysisData.TaskParameter(parameterValue, isOutput);
+        }
+    }
+
     private static void ReportResult(
         BuildAnalyzerWrapper analyzerWrapper,
         LoggingContext loggingContext,
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index fe563a087f6..ab2e298879b 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -3,72 +3,39 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.IO;
 using System.Linq;
-using System.Text;
-using System.Text.Json.Serialization;
-using System.Text.Json;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
 using Microsoft.Build.Experimental.BuildCheck;
-using System.Configuration;
+using System.Collections.Concurrent;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-
-// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)
-// Tracked via: https://github.com/dotnet/msbuild/issues/9828
-internal static class ConfigurationProvider
+internal sealed class ConfigurationProvider
 {
-    // We might want to have a mechanism for removing unneeded configurations
-    //  (disabled rules and analyzers that need to run in different node)
-    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();
-
-    // This is just a testing implementation for quicker unblock of testing.
-    // Real implementation will use .editorconfig file.
-    // Sample json:
-    /////*lang=json,strict*/
-    ////"""
-    ////    {
-    ////        "ABC123": {
-    ////            "IsEnabled": true,
-    ////            "Severity": "Info"
-    ////        },
-    ////        "COND0543": {
-    ////            "IsEnabled": false,
-    ////            "Severity": "Error",
-    ////    		"EvaluationAnalysisScope": "AnalyzedProjectOnly",
-    ////    		"CustomSwitch": "QWERTY"
-    ////        },
-    ////        "BLA": {
-    ////            "IsEnabled": false
-    ////        }
-    ////    }
-    ////    """
-    //
-    // Plus there will need to be a mechanism of distinguishing different configs in different folders
-    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?
-    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()
-    {
-        const string configFileName = "editorconfig.json";
-        string configPath = configFileName;
+    private readonly EditorConfigParser _editorConfigParser = new EditorConfigParser();
 
-        if (!File.Exists(configPath))
-        {
-            // This is just a dummy implementation for testing purposes
-            var dir = Environment.CurrentDirectory;
-            configPath = Path.Combine(dir, configFileName);
+    private const string BuildCheck_ConfigurationKey = "build_check";
 
-            if (!File.Exists(configPath))
-            {
-                return new Dictionary<string, BuildAnalyzerConfiguration>();
-            }
-        }
+    /// <summary>
+    /// The dictionary used for storing the BuildAnalyzerConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, BuildAnalyzerConfiguration> _buildAnalyzerConfiguration = new ConcurrentDictionary<string, BuildAnalyzerConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
-        var json = File.ReadAllText(configPath);
-        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };
-        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??
-               new Dictionary<string, BuildAnalyzerConfiguration>();
-    }
+    /// <summary>
+    /// The dictionary used for storing the key-value pairs retrieved from the .editorconfigs for specific projectfile. The key is equal to projectFullPath.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, Dictionary<string, string>> _editorConfigData = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.InvariantCultureIgnoreCase);
+
+    /// <summary>
+    /// The dictionary used for storing the CustomConfigurationData per ruleId. The key is equal to ruleId.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, CustomConfigurationData> _customConfigurationData = new ConcurrentDictionary<string, CustomConfigurationData>(StringComparer.InvariantCultureIgnoreCase);
+
+    private readonly string[] _infrastructureConfigurationKeys = new string[] {
+        nameof(BuildAnalyzerConfiguration.EvaluationAnalysisScope).ToLower(),
+        nameof(BuildAnalyzerConfiguration.IsEnabled).ToLower(),
+        nameof(BuildAnalyzerConfiguration.Severity).ToLower()
+    };
 
     /// <summary>
     /// Gets the user specified unrecognized configuration for the given analyzer rule.
@@ -80,39 +47,82 @@ private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration(
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
     {
-        return CustomConfigurationData.Null;
+        var configuration = GetConfiguration(projectFullPath, ruleId);
+
+        if (configuration is null)
+        {
+            return CustomConfigurationData.Null;
+        }
+
+        // remove the infrastructure owned key names
+        foreach (var infraConfigurationKey in _infrastructureConfigurationKeys)
+        {
+            configuration.Remove(infraConfigurationKey);
+        }
+
+        if (!configuration.Any())
+        {
+            return CustomConfigurationData.Null;
+        }
+
+        var data = new CustomConfigurationData(ruleId, configuration);
+
+        if (!_customConfigurationData.ContainsKey(ruleId))
+        {
+            _customConfigurationData[ruleId] = data;
+        }
+
+        return data;
     }
 
     /// <summary>
-    /// 
+    /// Verifies if previously fetched custom configurations are equal to current one. 
     /// </summary>
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <throws><see cref="BuildCheckConfigurationException"/> If CustomConfigurationData differs in a build for a same ruleId</throws>
     /// <returns></returns>
-    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
+    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
     {
-        // TBD
+        var configuration = GetCustomConfiguration(projectFullPath, ruleId);
+        VerifyCustomConfigurationEquality(ruleId, configuration);
     }
 
-    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+    internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurationData configurationData)
+    {
+        if (_customConfigurationData.TryGetValue(ruleId, out var storedConfiguration))
+        {
+            if (!storedConfiguration.Equals(configurationData))
+            {
+                throw new BuildCheckConfigurationException("Custom configuration should be equal between projects");
+            }
+        }
+    }
+
+    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         string projectFullPath,
         BuildAnalyzer analyzer)
         => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
 
-    public static BuildAnalyzerConfiguration[] GetUserConfigurations(
+    internal BuildAnalyzerConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
 
-    public static CustomConfigurationData[] GetCustomConfigurations(
+    /// <summary>
+    /// Retrieve array of CustomConfigurationData for a given projectPath and ruleIds
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleIds"></param>
+    /// <returns></returns>
+    public CustomConfigurationData[] GetCustomConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         BuildAnalyzerConfiguration[] userConfigs,
         BuildAnalyzer analyzer)
     {
@@ -120,7 +130,7 @@ public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
-            configurations[idx] = ConfigurationProvider.MergeConfiguration(
+            configurations[idx] = MergeConfiguration(
                 analyzer.SupportedRules[idx].Id,
                 analyzer.SupportedRules[idx].DefaultConfiguration,
                 userConfigs[idx]);
@@ -129,7 +139,7 @@ public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         return configurations;
     }
 
-    private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
+    private TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
     {
         TConfig[] configurations = new TConfig[ruleIds.Count];
         for (int i = 0; i < ruleIds.Count; i++)
@@ -140,6 +150,72 @@ private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPat
         return configurations;
     }
 
+
+    /// <summary>
+    /// Generates a new dictionary that contains the key-value pairs from the original dictionary if the key starts with 'keyFilter'.
+    /// If updateKey is set to 'true', the keys of the new dictionary will not include keyFilter.
+    /// </summary>
+    /// <param name="keyFilter"></param>
+    /// <param name="originalConfiguration"></param>
+    /// <param name="updateKey"></param>
+    /// <returns></returns>
+    private Dictionary<string, string> FilterDictionaryByKeys(string keyFilter, Dictionary<string, string> originalConfiguration, bool updateKey = false)
+    {
+        var filteredConfig = new Dictionary<string, string>();
+
+        foreach (var kv in originalConfiguration)
+        {
+            if (kv.Key.StartsWith(keyFilter, StringComparison.OrdinalIgnoreCase))
+            {
+                var newKey = kv.Key;
+                if (updateKey)
+                {
+                    newKey = kv.Key.Substring(keyFilter.Length);
+                }
+
+                filteredConfig[newKey] = kv.Value;
+            }
+        }
+
+        return filteredConfig;
+    }
+
+    /// <summary>
+    /// Fetches the .editorconfig data in form of Key-Value pair.
+    /// Resulted dictionary will contain only BuildCheck related rules.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <returns></returns>
+    /// <exception cref="BuildCheckConfigurationException"></exception>
+    private Dictionary<string, string> FetchEditorConfigRules(string projectFullPath)
+    {
+        var editorConfigRules = _editorConfigData.GetOrAdd(projectFullPath, (key) =>
+        {
+            Dictionary<string, string> config;
+            try
+            {
+                config = _editorConfigParser.Parse(projectFullPath);
+            }
+            catch (Exception exception)
+            {
+                throw new BuildCheckConfigurationException($"Parsing editorConfig data failed", exception, BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+
+            // clear the dictionary from the key-value pairs not BuildCheck related and
+            // store the data so there is no need to parse the .editorconfigs all over again
+            Dictionary<string, string> filteredData = FilterDictionaryByKeys($"{BuildCheck_ConfigurationKey}.", config);
+            return filteredData;
+        });
+        
+        return editorConfigRules;
+    }
+
+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)
+    {
+        var config = FetchEditorConfigRules(projectFullPath);
+        return FilterDictionaryByKeys($"{BuildCheck_ConfigurationKey}.{ruleId}.", config, updateKey: true);
+    }
+
     /// <summary>
     /// Gets effective user specified (or default) configuration for the given analyzer rule.
     /// The configuration values CAN be null upon this operation.
@@ -150,14 +226,24 @@ private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPat
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
     {
-        if (!_editorConfig.TryGetValue(ruleId, out BuildAnalyzerConfiguration? editorConfig))
+        var cacheKey = $"{ruleId}-{projectFullPath}";
+
+        var editorConfigValue = _buildAnalyzerConfiguration.GetOrAdd(cacheKey, (key) =>
         {
-            editorConfig = BuildAnalyzerConfiguration.Null;
-        }
+            BuildAnalyzerConfiguration? editorConfig = BuildAnalyzerConfiguration.Null;
+            var config = GetConfiguration(projectFullPath, ruleId);
+
+            if (config.Any())
+            {
+                editorConfig = BuildAnalyzerConfiguration.Create(config);
+            }
+
+            return editorConfig;
+        });
 
-        return editorConfig;
+        return editorConfigValue;
     }
 
     /// <summary>
@@ -167,10 +253,10 @@ public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFull
     /// <param name="projectFullPath"></param>
     /// <param name="analyzerRule"></param>
     /// <returns></returns>
-    public static BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
+    internal BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
         => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
 
-    public static BuildAnalyzerConfigurationInternal MergeConfiguration(
+    internal BuildAnalyzerConfigurationInternal MergeConfiguration(
         string ruleId,
         BuildAnalyzerConfiguration defaultConfig,
         BuildAnalyzerConfiguration editorConfig)
@@ -180,13 +266,13 @@ public static BuildAnalyzerConfigurationInternal MergeConfiguration(
             isEnabled: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.IsEnabled),
             severity: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.Severity));
 
-    private static BuildAnalyzerConfigurationInternal GetMergedConfiguration(
+    private BuildAnalyzerConfigurationInternal GetMergedConfiguration(
         string projectFullPath,
         string ruleId,
         BuildAnalyzerConfiguration defaultConfig)
         => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
 
-    private static T GetConfigValue<T>(
+    private T GetConfigValue<T>(
         BuildAnalyzerConfiguration editorConfigValue,
         BuildAnalyzerConfiguration defaultValue,
         Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
index d200d48ee66..afd3645cf2e 100644
--- a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -15,17 +15,27 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 ///  that were attribute to a particular rule, but were not recognized by the infrastructure.
 /// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
 /// </summary>
-/// <param name="ruleId"></param>
-public class CustomConfigurationData(string ruleId)
+public sealed class CustomConfigurationData
 {
     public static CustomConfigurationData Null { get; } = new(string.Empty);
 
     public static bool NotNull(CustomConfigurationData data) => !Null.Equals(data);
 
+    public CustomConfigurationData(string ruleId)
+    {
+        RuleId = ruleId;
+    }
+
+    public CustomConfigurationData(string ruleId, Dictionary<string, string> properties)
+    {
+        RuleId = ruleId;
+        ConfigurationData = properties;
+    }
+
     /// <summary>
     /// Identifier of the rule that the configuration data is for.
     /// </summary>
-    public string RuleId { get; init; } = ruleId;
+    public string RuleId { get; init; }
 
     /// <summary>
     /// Key-value pairs of unstructured data from .editorconfig file.
@@ -50,15 +60,43 @@ public override bool Equals(object? obj)
             return true;
         }
 
-        if (obj.GetType() != this.GetType())
+        if (obj is not CustomConfigurationData)
         {
             return false;
         }
 
-        return Equals((CustomConfigurationData)obj);
-    }
+        var customConfigObj = (CustomConfigurationData) obj;
 
-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);
+        if (customConfigObj.RuleId != RuleId)
+        {
+            return false;
+        }
 
-    public override int GetHashCode() => (ConfigurationData != null ? ConfigurationData.GetHashCode() : 0);
+        // validate keys and values
+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null && ConfigurationData.Count == customConfigObj.ConfigurationData.Count)
+        {
+            foreach (var keyVal in customConfigObj.ConfigurationData)
+            {
+                if (!ConfigurationData.TryGetValue(keyVal.Key, out var value) || value != keyVal.Value)
+                {
+                    return false;
+                }
+            }
+        }
+        else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)
+        {
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+
+        return true;
+    }
+
+    public override int GetHashCode()
+    {
+        throw new NotImplementedException("CustomConfigurationData does not implement GetHashCode method");
+    }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
new file mode 100644
index 00000000000..d2f93664369
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -0,0 +1,184 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Code and logic is copied from the https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.cs
+// with slight changes like:
+//  1. Remove dependency from Source text.
+//  2. Remove support of globalconfig
+//  3. Remove the FilePath and receive only the text
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal partial class EditorConfigFile
+{
+    // Matches EditorConfig section header such as "[*.{js,py}]", see https://editorconfig.org for details
+    private const string s_sectionMatcherPattern = @"^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$";
+
+    // Matches EditorConfig property such as "indent_style = space", see https://editorconfig.org for details
+    private const string s_propertyMatcherPattern = @"^\s*([\w\.\-_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$";
+
+#if NETCOREAPP
+
+[GeneratedRegex(s_sectionMatcherPattern)]
+private static partial Regex GetSectionMatcherRegex();
+
+[GeneratedRegex(s_propertyMatcherPattern)]
+private static partial Regex GetPropertyMatcherRegex();
+
+#else
+    private static readonly Regex s_sectionMatcher = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
+
+    private static readonly Regex s_propertyMatcher = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
+
+    private static Regex GetSectionMatcherRegex() => s_sectionMatcher;
+
+    private static Regex GetPropertyMatcherRegex() => s_propertyMatcher;
+
+#endif
+
+    internal Section GlobalSection { get; }
+
+    internal ImmutableArray<Section> NamedSections { get; }
+
+    /// <summary>
+    /// Gets whether this editorconfig is a topmost editorconfig.
+    /// </summary>
+    internal bool IsRoot => GlobalSection.Properties.TryGetValue("root", out string? val) && val?.ToLower() == "true";
+
+    private EditorConfigFile(
+        Section globalSection,
+        ImmutableArray<Section> namedSections)
+    {
+        GlobalSection = globalSection;
+        NamedSections = namedSections;
+    }
+
+    /// <summary>
+    /// Parses an editor config file text located at the given path. No parsing
+    /// errors are reported. If any line contains a parse error, it is dropped.
+    /// </summary>
+    internal static EditorConfigFile Parse(string text)
+    {
+        Section? globalSection = null;
+        var namedSectionBuilder = ImmutableArray.CreateBuilder<Section>();
+
+        // N.B. The editorconfig documentation is quite loose on property interpretation.
+        // Specifically, it says:
+        //      Currently all properties and values are case-insensitive.
+        //      They are lowercased when parsed.
+        // To accommodate this, we use a lower case Unicode mapping when adding to the
+        // dictionary, but we also use a case-insensitive key comparer when doing lookups
+        var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>(StringComparer.OrdinalIgnoreCase);
+        string activeSectionName = "";
+        var lines = string.IsNullOrEmpty(text) ? Array.Empty<string>() : text.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
+
+        foreach(var line in lines)
+        {
+            if (string.IsNullOrWhiteSpace(line))
+            {
+                continue;
+            }
+
+            if (IsComment(line))
+            {
+                continue;
+            }
+
+            var sectionMatches = GetSectionMatcherRegex().Matches(line);
+            if (sectionMatches.Count > 0 && sectionMatches[0].Groups.Count > 0)
+            {
+                addNewSection();
+
+                var sectionName = sectionMatches[0].Groups[1].Value;
+                Debug.Assert(!string.IsNullOrEmpty(sectionName));
+
+                activeSectionName = sectionName;
+                activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>();
+                continue;
+            }
+
+            var propMatches = GetPropertyMatcherRegex().Matches(line);
+            if (propMatches.Count > 0 && propMatches[0].Groups.Count > 1)
+            {
+                var key = propMatches[0].Groups[1].Value.ToLower();
+                var value = propMatches[0].Groups[2].Value;
+
+                Debug.Assert(!string.IsNullOrEmpty(key));
+                Debug.Assert(key == key.Trim());
+                Debug.Assert(value == value?.Trim());
+
+                activeSectionProperties[key] = value ?? "";
+                continue;
+            }
+        }
+
+        // Add the last section
+        addNewSection();
+
+        return new EditorConfigFile(globalSection!, namedSectionBuilder.ToImmutable());
+
+        void addNewSection()
+        {
+            // Close out the previous section
+            var previousSection = new Section(activeSectionName, activeSectionProperties.ToImmutable());
+            if (activeSectionName == "")
+            {
+                // This is the global section
+                globalSection = previousSection;
+            }
+            else
+            {
+                namedSectionBuilder.Add(previousSection);
+            }
+        }
+    }
+
+    private static bool IsComment(string line)
+    {
+        foreach (char c in line)
+        {
+            if (!char.IsWhiteSpace(c))
+            {
+                return c == '#' || c == ';';
+            }
+        }
+
+        return false;
+    }
+
+    /// <summary>
+    /// Represents a named section of the editorconfig file, which consists of a name followed by a set
+    /// of key-value pairs.
+    /// </summary>
+    internal sealed class Section
+    {
+        public Section(string name, ImmutableDictionary<string, string> properties)
+        {
+            Name = name;
+            Properties = properties;
+        }
+
+        /// <summary>
+        /// For regular files, the name as present directly in the section specification of the editorconfig file. For sections in
+        /// global configs, this is the unescaped full file path.
+        /// </summary>
+        public string Name { get; }
+
+        /// <summary>
+        /// Keys and values for this section. All keys are lower-cased according to the
+        /// EditorConfig specification and keys are compared case-insensitively. 
+        /// </summary>
+        public ImmutableDictionary<string, string> Properties { get; }
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
new file mode 100644
index 00000000000..60df42cb36d
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
@@ -0,0 +1,614 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Copied from https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.SectionNameMatching.cs
+// with some changes to make it quicker to integrate into the MSBuild.
+// Changes:
+//  1. ArrayBuilder was replaced with List.
+//  2. Exceptions. Wrap in try/catch blocks for proper reporting
+
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal class EditorConfigGlobsMatcher
+{
+    internal readonly struct SectionNameMatcher
+    {
+        private readonly ImmutableArray<(int minValue, int maxValue)> _numberRangePairs;
+
+        internal Regex Regex { get; }
+
+        internal SectionNameMatcher(
+            Regex regex,
+            ImmutableArray<(int minValue, int maxValue)> numberRangePairs)
+        {
+            Debug.Assert(regex.GetGroupNumbers().Length - 1 == numberRangePairs.Length);
+            Regex = regex;
+            _numberRangePairs = numberRangePairs;
+        }
+
+        internal bool IsMatch(string s)
+        {
+            if (_numberRangePairs.IsEmpty)
+            {
+                return Regex.IsMatch(s);
+            }
+
+            var match = Regex.Match(s);
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            Debug.Assert(match.Groups.Count - 1 == _numberRangePairs.Length);
+            for (int i = 0; i < _numberRangePairs.Length; i++)
+            {
+                var (minValue, maxValue) = _numberRangePairs[i];
+                // Index 0 is the whole regex
+                if (!int.TryParse(match.Groups[i + 1].Value, out int matchedNum) ||
+                    matchedNum < minValue ||
+                    matchedNum > maxValue)
+                {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    /// <summary>
+    /// Takes a <see cref="EditorConfigFile.Section.Name"/> and creates a matcher that
+    /// matches the given language. Returns null if the section name is
+    /// invalid.
+    /// </summary>
+    internal static SectionNameMatcher? TryCreateSectionNameMatcher(string sectionName)
+    {
+        // An editorconfig section name is a language for recognizing file paths
+        // defined by the following grammar:
+        //
+        // <path> ::= <path-list>
+        // <path-list> ::= <path-item> | <path-item> <path-list>
+        // <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+        // <char> ::= any unicode character
+        // <choice> ::= "{" <choice-list> "}"
+        // <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+        // <range> ::= "{" <integer> ".." <integer> "}"
+        // <integer> ::= "-" <digit-list> | <digit-list>
+        // <digit-list> ::= <digit> | <digit> <digit-list>
+        // <digit> ::= 0-9
+
+        var sb = new StringBuilder();
+        sb.Append('^');
+
+        // EditorConfig matching depends on the whether or not there are
+        // directory separators and where they are located in the section
+        // name. Specifically, the editorconfig core parser says:
+        // https://github.com/editorconfig/editorconfig-core-c/blob/5d3996811e962a717a7d7fdd0a941192382241a7/src/lib/editorconfig.c#L231
+        //
+        //     Pattern would be:
+        //     /dir/of/editorconfig/file[double_star]/[section] if section does not contain '/',
+        //     /dir/of/editorconfig/file[section] if section starts with a '/', or
+        //     /dir/of/editorconfig/file/[section] if section contains '/' but does not start with '/'.
+
+        if (!sectionName.Contains("/"))
+        {
+            sb.Append(".*/");
+        }
+        else if (sectionName[0] != '/')
+        {
+            sb.Append('/');
+        }
+
+        var lexer = new SectionNameLexer(sectionName);
+        var numberRangePairs = new List<(int minValue, int maxValue)>();
+        if (!TryCompilePathList(ref lexer, sb, parsingChoice: false, numberRangePairs))
+        {
+            numberRangePairs.Clear();
+            return null;
+        }
+        sb.Append('$');
+
+
+        var imArray = ImmutableArray.CreateBuilder<(int, int)>(numberRangePairs is null ? 0 : numberRangePairs.Count);
+        if (numberRangePairs?.Count > 0)
+        {
+            imArray.AddRange(numberRangePairs);
+        }
+
+        return new SectionNameMatcher(
+            new Regex(sb.ToString(), RegexOptions.Compiled),
+            imArray.ToImmutableArray());
+    }
+
+    internal static string UnescapeSectionName(string sectionName)
+    {
+        var sb = new StringBuilder();
+        SectionNameLexer lexer = new SectionNameLexer(sectionName);
+        while (!lexer.IsDone)
+        {
+            var tokenKind = lexer.Lex();
+            if (tokenKind == TokenKind.SimpleCharacter)
+            {
+                sb.Append(lexer.EatCurrentCharacter());
+            }
+            else
+            {
+                // We only call this on strings that were already passed through IsAbsoluteEditorConfigPath, so
+                // we shouldn't have any other token kinds here.
+                throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+        return sb.ToString();
+    }
+
+    internal static bool IsAbsoluteEditorConfigPath(string sectionName)
+    {
+        // NOTE: editorconfig paths must use '/' as a directory separator character on all OS.
+
+        // on all unix systems this is thus a simple test: does the path start with '/'
+        // and contain no special chars?
+
+        // on windows, a path can be either drive rooted or not (e.g. start with 'c:' or just '')
+        // in addition to being absolute or relative.
+        // for example c:myfile.cs is a relative path, but rooted on drive c:
+        // /myfile2.cs is an absolute path but rooted to the current drive.
+
+        // in addition there are UNC paths and volume guids (see https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats)
+        // but these start with \\ (and thus '/' in editor config terminology)
+
+        // in this implementation we choose to ignore the drive root for the purposes of
+        // determining validity. On windows c:/file.cs and /file.cs are both assumed to be
+        // valid absolute paths, even though the second one is technically relative to
+        // the current drive of the compiler working directory. 
+
+        // Note that this check has no impact on config correctness. Files on windows
+        // will still be compared using their full path (including drive root) so it's
+        // not possible to target the wrong file. It's just possible that the user won't
+        // receive a warning that this section is ignored on windows in this edge case.
+
+        SectionNameLexer nameLexer = new SectionNameLexer(sectionName);
+        bool sawStartChar = false;
+        int logicalIndex = 0;
+        while (!nameLexer.IsDone)
+        {
+            if (nameLexer.Lex() != TokenKind.SimpleCharacter)
+            {
+                return false;
+            }
+            var simpleChar = nameLexer.EatCurrentCharacter();
+
+            // check the path starts with '/'
+            if (logicalIndex == 0)
+            {
+                if (simpleChar == '/')
+                {
+                    sawStartChar = true;
+                }
+                else if (Path.DirectorySeparatorChar == '/')
+                {
+                    return false;
+                }
+            }
+            // on windows we get a second chance to find the start char
+            else if (!sawStartChar && Path.DirectorySeparatorChar == '\\')
+            {
+                if (logicalIndex == 1 && simpleChar != ':')
+                {
+                    return false;
+                }
+                else if (logicalIndex == 2)
+                {
+                    if (simpleChar != '/')
+                    {
+                        return false;
+                    }
+                    else
+                    {
+                        sawStartChar = true;
+                    }
+                }
+            }
+            logicalIndex++;
+        }
+        return sawStartChar;
+    }
+
+
+    /// <summary>
+    /// <![CDATA[
+    /// <path-list> ::= <path-item> | <path-item> <path-list>
+    /// <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+    /// <char> ::= any unicode character
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompilePathList(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        bool parsingChoice,
+        List<(int minValue, int maxValue)> numberRangePairs)
+    {
+        while (!lexer.IsDone)
+        {
+            var tokenKind = lexer.Lex();
+            switch (tokenKind)
+            {
+                case TokenKind.BadToken:
+                    // Parsing failure
+                    return false;
+                case TokenKind.SimpleCharacter:
+                    // Matches just this character
+                    sb.Append(Regex.Escape(lexer.EatCurrentCharacter().ToString()));
+                    break;
+                case TokenKind.Question:
+                    // '?' matches any single character
+                    sb.Append('.');
+                    break;
+                case TokenKind.Star:
+                    // Matches any string of characters except directory separator
+                    // Directory separator is defined in editorconfig spec as '/'
+                    sb.Append("[^/]*");
+                    break;
+                case TokenKind.StarStar:
+                    // Matches any string of characters
+                    sb.Append(".*");
+                    break;
+                case TokenKind.OpenCurly:
+                    // Back up token stream. The following helpers all expect a '{'
+                    lexer.Position--;
+                    // This is ambiguous between {num..num} and {item1,item2}
+                    // We need to look ahead to disambiguate. Looking for {num..num}
+                    // is easier because it can't be recursive.
+                    (string numStart, string numEnd)? rangeOpt = TryParseNumberRange(ref lexer);
+                    if (rangeOpt is null)
+                    {
+                        // Not a number range. Try a choice expression
+                        if (!TryCompileChoice(ref lexer, sb, numberRangePairs))
+                        {
+                            return false;
+                        }
+                        // Keep looping. There may be more after the '}'.
+                        break;
+                    }
+                    else
+                    {
+                        (string numStart, string numEnd) = rangeOpt.GetValueOrDefault();
+                        if (int.TryParse(numStart, out var intStart) && int.TryParse(numEnd, out var intEnd))
+                        {
+                            var pair = intStart < intEnd ? (intStart, intEnd) : (intEnd, intStart);
+                            numberRangePairs.Add(pair);
+                            // Group allowing any digit sequence. The validity will be checked outside of the regex
+                            sb.Append("(-?[0-9]+)");
+                            // Keep looping
+                            break;
+                        }
+                        return false;
+                    }
+                case TokenKind.CloseCurly:
+                    // Either the end of a choice, or a failed parse
+                    return parsingChoice;
+                case TokenKind.Comma:
+                    // The end of a choice section, or a failed parse
+                    return parsingChoice;
+                case TokenKind.OpenBracket:
+                    sb.Append('[');
+                    if (!TryCompileCharacterClass(ref lexer, sb))
+                    {
+                        return false;
+                    }
+                    break;
+                default:
+                    throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+        // If we're parsing a choice we should not exit without a closing '}'
+        return !parsingChoice;
+    }
+
+    /// <summary>
+    /// Compile a globbing character class of the form [...]. Returns true if
+    /// the character class was successfully compiled. False if there was a syntax
+    /// error. The starting character is expected to be directly after the '['.
+    /// </summary>
+    private static bool TryCompileCharacterClass(ref SectionNameLexer lexer, StringBuilder sb)
+    {
+        // [...] should match any of the characters in the brackets, with special
+        // behavior for four characters: '!' immediately after the opening bracket
+        // implies the negation of the character class, '-' implies matching
+        // between the locale-dependent range of the previous and next characters,
+        // '\' escapes the following character, and ']' ends the range
+        if (!lexer.IsDone && lexer.CurrentCharacter == '!')
+        {
+            sb.Append('^');
+            lexer.Position++;
+        }
+        while (!lexer.IsDone)
+        {
+            var currentChar = lexer.EatCurrentCharacter();
+            switch (currentChar)
+            {
+                case '-':
+                    // '-' means the same thing in regex as it does in the glob, so
+                    // put it in verbatim
+                    sb.Append(currentChar);
+                    break;
+
+                case '\\':
+                    // Escape the next char
+                    if (lexer.IsDone)
+                    {
+                        return false;
+                    }
+                    sb.Append('\\');
+                    sb.Append(lexer.EatCurrentCharacter());
+                    break;
+
+                case ']':
+                    sb.Append(currentChar);
+                    return true;
+
+                default:
+                    sb.Append(Regex.Escape(currentChar.ToString()));
+                    break;
+            }
+        }
+        // Stream ended without a closing bracket
+        return false;
+    }
+
+    /// <summary>
+    /// Parses choice defined by the following grammar:
+    /// <![CDATA[
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompileChoice(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        List<(int, int)> numberRangePairs)
+    {
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
+            return false;
+        }
+
+        // Start a non-capturing group for the choice
+        sb.Append("(?:");
+
+        // We start immediately after a '{'
+        // Try to compile the nested <path-list>
+        while (TryCompilePathList(ref lexer, sb, parsingChoice: true, numberRangePairs))
+        {
+            // If we've successfully compiled a <path-list> the last token should
+            // have been a ',' or a '}'
+            char lastChar = lexer[lexer.Position - 1];
+            if (lastChar == ',')
+            {
+                // Another option
+                sb.Append('|');
+            }
+            else if (lastChar == '}')
+            {
+                // Close out the capture group
+                sb.Append(')');
+                return true;
+            }
+            else
+            {
+                throw new BuildCheckConfigurationException($"UnexpectedValue: {lastChar}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+
+        // Propagate failure
+        return false;
+    }
+
+    /// <summary>
+    /// Parses range defined by the following grammar.
+    /// <![CDATA[
+    /// <range> ::= "{" <integer> ".." <integer> "}"
+    /// <integer> ::= "-" <digit-list> | <digit-list>
+    /// <digit-list> ::= <digit> | <digit> <digit-list>
+    /// <digit> ::= 0-9
+    /// ]]>
+    /// </summary>
+    private static (string numStart, string numEnd)? TryParseNumberRange(ref SectionNameLexer lexer)
+    {
+        var saved = lexer.Position;
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
+            lexer.Position = saved;
+            return null;
+        }
+
+        var numStart = lexer.TryLexNumber();
+        if (numStart is null)
+        {
+            // Not a number
+            lexer.Position = saved;
+            return null;
+        }
+
+        // The next two characters must be ".."
+        if (!lexer.TryEatCurrentCharacter(out char c) || c != '.' ||
+            !lexer.TryEatCurrentCharacter(out c) || c != '.')
+        {
+            lexer.Position = saved;
+            return null;
+        }
+
+        // Now another number
+        var numEnd = lexer.TryLexNumber();
+        if (numEnd is null || lexer.IsDone || lexer.Lex() != TokenKind.CloseCurly)
+        {
+            // Not a number or no '}'
+            lexer.Position = saved;
+            return null;
+        }
+
+        return (numStart, numEnd);
+    }
+
+    private struct SectionNameLexer
+    {
+        private readonly string _sectionName;
+
+        internal int Position { get; set; }
+
+        internal SectionNameLexer(string sectionName)
+        {
+            _sectionName = sectionName;
+            Position = 0;
+        }
+
+        internal bool IsDone => Position >= _sectionName.Length;
+
+        internal TokenKind Lex()
+        {
+            int lexemeStart = Position;
+            switch (_sectionName[Position])
+            {
+                case '*':
+                    {
+                        int nextPos = Position + 1;
+                        if (nextPos < _sectionName.Length &&
+                            _sectionName[nextPos] == '*')
+                        {
+                            Position += 2;
+                            return TokenKind.StarStar;
+                        }
+                        else
+                        {
+                            Position++;
+                            return TokenKind.Star;
+                        }
+                    }
+
+                case '?':
+                    Position++;
+                    return TokenKind.Question;
+
+                case '{':
+                    Position++;
+                    return TokenKind.OpenCurly;
+
+                case ',':
+                    Position++;
+                    return TokenKind.Comma;
+
+                case '}':
+                    Position++;
+                    return TokenKind.CloseCurly;
+
+                case '[':
+                    Position++;
+                    return TokenKind.OpenBracket;
+
+                case '\\':
+                    {
+                        // Backslash escapes the next character
+                        Position++;
+                        if (IsDone)
+                        {
+                            return TokenKind.BadToken;
+                        }
+
+                        return TokenKind.SimpleCharacter;
+                    }
+
+                default:
+                    // Don't increment position, since caller needs to fetch the character
+                    return TokenKind.SimpleCharacter;
+            }
+        }
+
+        internal char CurrentCharacter => _sectionName[Position];
+
+        /// <summary>
+        /// Call after getting <see cref="TokenKind.SimpleCharacter" /> from <see cref="Lex()" />
+        /// </summary>
+        internal char EatCurrentCharacter() => _sectionName[Position++];
+
+        /// <summary>
+        /// Returns false if there are no more characters in the lex stream.
+        /// Otherwise, produces the next character in the stream and returns true.
+        /// </summary>
+        internal bool TryEatCurrentCharacter(out char nextChar)
+        {
+            if (IsDone)
+            {
+                nextChar = default;
+                return false;
+            }
+            else
+            {
+                nextChar = EatCurrentCharacter();
+                return true;
+            }
+        }
+
+        internal char this[int position] => _sectionName[position];
+
+        /// <summary>
+        /// Returns the string representation of a decimal integer, or null if
+        /// the current lexeme is not an integer.
+        /// </summary>
+        internal string? TryLexNumber()
+        {
+            bool start = true;
+            var sb = new StringBuilder();
+
+            while (!IsDone)
+            {
+                char currentChar = CurrentCharacter;
+                if (start && currentChar == '-')
+                {
+                    Position++;
+                    sb.Append('-');
+                }
+                else if (char.IsDigit(currentChar))
+                {
+                    Position++;
+                    sb.Append(currentChar);
+                }
+                else
+                {
+                    break;
+                }
+                start = false;
+            }
+
+            var str = sb.ToString();
+            return str.Length == 0 || str == "-"
+                ? null
+                : str;
+        }
+    }
+
+    private enum TokenKind
+    {
+        BadToken,
+        SimpleCharacter,
+        Star,
+        StarStar,
+        Question,
+        OpenCurly,
+        CloseCurly,
+        Comma,
+        DoubleDot,
+        OpenBracket,
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
new file mode 100644
index 00000000000..76baa1f1e66
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -0,0 +1,104 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Drawing.Design;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Shared;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal sealed class EditorConfigParser
+{
+    private const string EditorconfigFile = ".editorconfig";
+
+    /// <summary>
+    /// Cache layer of the parsed editor configs the key is the path to the .editorconfig file.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, EditorConfigFile> _editorConfigFileCache = new ConcurrentDictionary<string, EditorConfigFile>(StringComparer.InvariantCultureIgnoreCase);
+
+    internal Dictionary<string, string> Parse(string filePath)
+    {
+        var editorConfigs = DiscoverEditorConfigFiles(filePath);
+        return MergeEditorConfigFiles(editorConfigs, filePath);
+    }
+
+    /// <summary>
+    /// Fetches the list of EditorconfigFile ordered from the nearest to the filePath.
+    /// </summary>
+    /// <param name="filePath"></param>
+    internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
+    {
+        var editorConfigDataFromFilesList = new List<EditorConfigFile>();
+
+        var directoryOfTheProject = Path.GetDirectoryName(filePath);
+        // The method will look for the file in parent directory if not found in current until found or the directory is root. 
+        var editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);
+
+        while (editorConfigFilePath != string.Empty)
+        {
+            var editorConfig = _editorConfigFileCache.GetOrAdd(editorConfigFilePath, (key) =>
+            {
+                using (FileStream stream = new FileStream(editorConfigFilePath, FileMode.Open, System.IO.FileAccess.Read, FileShare.Read))
+                {
+                    using StreamReader sr = new StreamReader(editorConfigFilePath);
+                    var editorConfigfileContent = sr.ReadToEnd();
+                    return EditorConfigFile.Parse(editorConfigfileContent);
+                }
+            });
+
+            editorConfigDataFromFilesList.Add(editorConfig);
+
+            if (editorConfig.IsRoot)
+            {
+                break;
+            }
+            else
+            {
+                // search in upper directory
+                editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, Path.GetDirectoryName(Path.GetDirectoryName(editorConfigFilePath)));
+            }
+        }
+
+        return editorConfigDataFromFilesList;
+    }
+
+    /// <summary>
+    /// Retrieves the config dictionary from the sections that matched the filePath. 
+    /// </summary>
+    /// <param name="editorConfigFiles"></param>
+    /// <param name="filePath"></param>
+    internal Dictionary<string, string> MergeEditorConfigFiles(List<EditorConfigFile> editorConfigFiles, string filePath)
+    {
+        var resultingDictionary = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
+
+        for (int i = editorConfigFiles.Count - 1; i >= 0; i--)
+        {
+            foreach (var section in editorConfigFiles[i].NamedSections)
+            {
+                SectionNameMatcher? sectionNameMatcher = TryCreateSectionNameMatcher(section.Name);
+                if (sectionNameMatcher != null)
+                {
+                    if (sectionNameMatcher.Value.IsMatch(NormalizeWithForwardSlash(filePath)))
+                    {
+                        foreach (var property in section.Properties)
+                        {
+                            resultingDictionary[property.Key] = property.Value;
+                        }
+                    }
+                }
+            }
+        }
+        
+        return resultingDictionary;
+    }
+
+    internal static string NormalizeWithForwardSlash(string p) => Path.DirectorySeparatorChar == '/' ? p : p.Replace(Path.DirectorySeparatorChar, '/');
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
new file mode 100644
index 00000000000..e19b61c2c40
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
@@ -0,0 +1,98 @@
+﻿# EditorConfigParser
+
+Logic of parsing and matching copied from Roslyn implementation.
+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324
+
+
+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. 
+
+Configuration divided into two categories: 
+- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope
+- Custom configuration, any other config specified by user for this particular rule
+
+### Example
+For the file/folder structure: 
+```
+├── folder1/
+│   └── .editorconfig
+│   └── folder2/
+        ├── folder3/
+        │   └── .editorconfig
+        │   └── test.proj
+        └── .editorconfig
+```
+
+we want to fetch configuration for the project: /full/path/folder1/folder2/folder3/test.proj 
+
+Infra related and custom configuration flows have one common logic: Fetching the configs from editorconfig
+
+```
+while(editorConfig is not root && parent directory exists){
+        collect, parse editorconfigs 
+}
+
+list<editorConfig>{
+    folder1/folder2/folder3/.editorconfig
+    folder1/folder2/.editorconfig
+    folder1/.editorconfig
+}
+```
+Reverse the order and collect all matching section key-value pairs into new dictionary
+Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)
+
+The implementation differs depending on category: 
+ - Infra related config: Merges the configuration retrieved from configuration module with default values (respecting the specified configs in editorconfig) 
+ - Custom configuration: Remove all infra related keys from dictionary
+
+Four levels of cache introduced: 
+- When retrieving and parsing the editor config -> Parsed results are saved into dictionary: editorconfigPath = ParsedEditorConfig
+- When retrieving and merging the editor config data for project -> Parsed and merged results are saved into dictionary: projectFilePath = MargedData of ParsedEditorConfig
+- When retrieving Infra related config: ruleId-projectPath = BuildConfigInstance
+- CustomConfigurationData: In order to verify that the config data is the same between projects
+
+Usage examples (API)
+
+```
+var editorConfigParser = new EditorConfigParser();
+editorConfigParser.Parse("path/to/the/file")
+```
+
+The snippet above will return all applied key-value Dictionary<string, string> pairs collected from .editorconfig files
+
+Currently EditorConfigParser is used by [ConfigurationProvider](https://github.com/dotnet/msbuild/blob/e0dfb8d1ce5fc1de5153e65ea04c66a6dcac6279/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs#L129).
+
+#### Cache lifetime
+The lifetime of the cached configuration is defined by the usage of the instance of ConfigurationProvider. The instance of the ConfigurationProvider is created per BuildCheckManager.
+Lifecycle of BuildCheckManager could be found [here](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#handling-the-distributed-model)
+
+
+#### Custom configuration data
+CustomConfigurationData is propogated to the BuildCheck Analyzer instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
+during the initialization of the [BuildAnalyzer](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildAnalyzer.cs#L36).
+
+
+#### Example of consuming the CustomConfigurationData
+The `Initialize` method of BuildCheck Analyzer:
+```C#
+public override void Initialize(ConfigurationContext configurationContext)
+{
+    Console.WriteLine(configurationContext.CustomConfigurationData.Count);
+    for (int i = 0; i < configurationContext.CustomConfigurationData.Count; i++)
+    {
+        var customConfigPerRule = configurationContext.CustomConfigurationData[i]; 
+        Console.WriteLine(customConfigPerRule.RuleId); 
+
+        if (customConfigPerRule.ConfigurationData is not null) // null when the configuration was not provided from editorconfig
+        {
+            foreach (var kv in customConfigPerRule.ConfigurationData)
+            {
+                Console.WriteLine($"{kv.Key}------{kv.Value}");
+            }
+        }
+        else
+        {
+            Console.WriteLine($"The data is null for index: {i}");
+        }
+    }
+}
+```
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index f375b192bcc..9f39f8dcb69 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -40,6 +40,18 @@ void ProcessEvaluationFinishedEventArgs(
         AnalyzerLoggingContext buildAnalysisContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
 
+    void ProcessTaskStartedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskStartedEventArgs taskStartedEventArgs);
+
+    void ProcessTaskFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskFinishedEventArgs taskFinishedEventArgs);
+
+    void ProcessTaskParameterEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
+        TaskParameterEventArgs taskParameterEventArgs);
+
     void SetDataSource(BuildCheckDataSource buildCheckDataSource);
 
     void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext);
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index ae5ea663dbd..a0136eafac8 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -27,6 +27,21 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
     {
     }
 
+    public void ProcessTaskStartedEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+        TaskStartedEventArgs taskStartedEventArgs)
+    {
+    }
+
+    public void ProcessTaskFinishedEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+        TaskFinishedEventArgs taskFinishedEventArgs)
+    {
+    }
+
+    public void ProcessTaskParameterEventArgs(AnalyzerLoggingContext buildAnalysisContext,
+        TaskParameterEventArgs taskParameterEventArgs)
+    {
+    }
+
     public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, BuildEventContext buildEventContext) 
     {
     }
@@ -60,4 +75,13 @@ public void ResumeProject(BuildCheckDataSource buildCheckDataSource, BuildEventC
     }
 
     public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats() => new Dictionary<string, TimeSpan>();
+
+    public void StartTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskStartedEventArgs eventArgs)
+    { }
+
+    public void EndTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskFinishedEventArgs eventArgs)
+    { }
+
+    public void ProcessTaskParameter(BuildCheckDataSource buildCheckDataSource, TaskParameterEventArgs eventArg)
+    { }
 }
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index 57524436851..f0623e4a822 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Base for a data passed from infrastructure to build analyzers.
 /// </summary>
-/// <param name="projectFilePath">Currently build project.</param>
+/// <param name="projectFilePath">Currently built project.</param>
 public abstract class AnalysisData(string projectFilePath)
 {
     /// <summary>
diff --git a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
index a6b34446258..86598ada553 100644
--- a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
+++ b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 
@@ -53,3 +50,53 @@ internal ParsedItemsAnalysisData(
 
     public ItemsHolder ItemsHolder { get; }
 }
+
+/// <summary>
+/// BuildCheck OM data representing a task executed by a project.
+/// </summary>
+public sealed class TaskInvocationAnalysisData : AnalysisData
+{
+    /// <summary>
+    /// Represents an input or output parameter of a task.
+    /// </summary>
+    /// <param name="Value">The value passed to (when <paramref name="IsOutput"/> is false) or from
+    /// (when <paramref name="IsOutput"/> is true) a task. This object can be of any type supported
+    /// in task parameters: <see cref="Framework.ITaskItem"/>, <see cref="Framework.ITaskItem"/>[],
+    /// bool, string, or anything else convertible to/from string.</param>
+    /// <param name="IsOutput">True for output parameters, false for input parameters.</param>
+    public record class TaskParameter(object? Value, bool IsOutput);
+
+    internal TaskInvocationAnalysisData(
+        string projectFilePath,
+        ElementLocation taskInvocationLocation,
+        string taskName,
+        string taskAssemblyLocation,
+        IReadOnlyDictionary<string, TaskParameter> parameters)
+        : base(projectFilePath)
+    {
+        TaskInvocationLocation = taskInvocationLocation;
+        TaskName = taskName;
+        TaskAssemblyLocation = taskAssemblyLocation;
+        Parameters = parameters;
+    }
+
+    /// <summary>
+    /// The project file and line/column number where the task is invoked.
+    /// </summary>
+    public ElementLocation TaskInvocationLocation { get; }
+
+    /// <summary>
+    /// Name of the task.
+    /// </summary>
+    public string TaskName { get; }
+
+    /// <summary>
+    /// The location of the assembly containing the implementation of the task.
+    /// </summary>
+    public string TaskAssemblyLocation { get; }
+
+    /// <summary>
+    /// The parameters of the task, keyed by parameter name.
+    /// </summary>
+    public IReadOnlyDictionary<string, TaskParameter> Parameters { get; }
+}
diff --git a/src/Build/BuildCheck/Utilities/Constants.cs b/src/Build/BuildCheck/Utilities/Constants.cs
index 8ba5eaf65f6..50a3d1bc63c 100644
--- a/src/Build/BuildCheck/Utilities/Constants.cs
+++ b/src/Build/BuildCheck/Utilities/Constants.cs
@@ -7,13 +7,12 @@
 using System.Text;
 using System.Threading.Tasks;
 
-namespace Microsoft.Build.Experimental.BuildCheck.Utilities
+namespace Microsoft.Build.Experimental.BuildCheck.Utilities;
+
+/// <summary>
+/// Constants to be shared within BuildCheck infrastructure
+/// </summary>
+internal static class BuildCheckConstants
 {
-    /// <summary>
-    /// Constants to be shared within BuildCheck infrastructure
-    /// </summary>
-    internal static class BuildCheckConstants
-    {
-        internal const string infraStatPrefix = "infrastructureStat_";
-    }
+    internal const string infraStatPrefix = "infrastructureStat_";
 }
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 76e975fe3c3..44e7fe20555 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -36,18 +36,18 @@ namespace Microsoft.Build.Collections
     /// </remarks>
     /// <typeparam name="T">Property or Metadata class type to store</typeparam>
     [DebuggerDisplay("#Entries={Count}")]
-    internal sealed class CopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatable<CopyOnWritePropertyDictionary<T>>, IDictionary<string, T>
+    internal sealed class CopyOnWritePropertyDictionary<T> : ICopyOnWritePropertyDictionary<T>, IEquatable<CopyOnWritePropertyDictionary<T>>
         where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
     {
         private static readonly ImmutableDictionary<string, T> NameComparerDictionaryPrototype = ImmutableDictionary.Create<string, T>(MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
-        /// Backing dictionary
+        /// Backing dictionary.
         /// </summary>
         private ImmutableDictionary<string, T> _backing;
 
         /// <summary>
-        /// Creates empty dictionary
+        /// Creates empty dictionary.
         /// </summary>
         public CopyOnWritePropertyDictionary()
         {
@@ -55,7 +55,7 @@ public CopyOnWritePropertyDictionary()
         }
 
         /// <summary>
-        /// Cloning constructor, with deferred cloning semantics
+        /// Cloning constructor, with deferred cloning semantics.
         /// </summary>
         private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         {
@@ -63,12 +63,12 @@ private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         }
 
         /// <summary>
-        /// Accessor for the list of property names
+        /// Accessor for the list of property names.
         /// </summary>
         ICollection<string> IDictionary<string, T>.Keys => ((IDictionary<string, T>)_backing).Keys;
 
         /// <summary>
-        /// Accessor for the list of properties
+        /// Accessor for the list of properties.
         /// </summary>
         ICollection<T> IDictionary<string, T>.Values => ((IDictionary<string, T>)_backing).Values;
 
@@ -115,6 +115,16 @@ public T this[string name]
         /// </summary>
         public bool Contains(string name) => _backing.ContainsKey(name);
 
+        public string GetEscapedValue(string name)
+        {
+            if (_backing.TryGetValue(name, out T value))
+            {
+                return value?.EscapedValue;
+            }
+
+            return null;
+        }
+
         /// <summary>
         /// Empties the collection
         /// </summary>
@@ -134,7 +144,7 @@ public void Clear()
         /// </summary>
         IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
-        #region IEquatable<PropertyDictionary<T>> Members
+        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
 
         /// <summary>
         /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
@@ -180,6 +190,56 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
 
         #endregion
 
+        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
+
+        /// <summary>
+        /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
+        /// same values as the other, unequal otherwise.
+        /// </summary>
+        /// <param name="other">The dictionary to which this should be compared</param>
+        /// <returns>True if they are equivalent, false otherwise.</returns>
+        public bool Equals(ICopyOnWritePropertyDictionary<T> other)
+        {
+            if (other == null)
+            {
+                return false;
+            }
+
+            ImmutableDictionary<string, T> thisBacking = _backing;
+            IDictionary<string, T> otherDict = other;
+
+            if (other is CopyOnWritePropertyDictionary<T> otherCopyOnWritePropertyDictionary)
+            {
+                // If the backing collections are the same, we are equal.
+                // Note that with this check, we intentionally avoid the common reference
+                // comparison between 'this' and 'other'.
+                if (ReferenceEquals(thisBacking, otherCopyOnWritePropertyDictionary._backing))
+                {
+                    return true;
+                }
+
+                otherDict = otherCopyOnWritePropertyDictionary._backing;
+            }
+
+            if (thisBacking.Count != otherDict.Count)
+            {
+                return false;
+            }
+
+            foreach (T thisProp in thisBacking.Values)
+            {
+                if (!otherDict.TryGetValue(thisProp.Key, out T thatProp) ||
+                    !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
+        #endregion
+
         #region IDictionary<string,T> Members
 
         /// <summary>
@@ -274,7 +334,7 @@ public bool Remove(string name)
         /// Overwrites any property with the same name already in the collection.
         /// To remove a property, use Remove(...) instead.
         /// </summary>
-        internal void Set(T projectProperty)
+        public void Set(T projectProperty)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectProperty, nameof(projectProperty));
 
@@ -285,7 +345,7 @@ internal void Set(T projectProperty)
         /// Adds the specified properties to this dictionary.
         /// </summary>
         /// <param name="other">An enumerator over the properties to add.</param>
-        internal void ImportProperties(IEnumerable<T> other)
+        public void ImportProperties(IEnumerable<T> other)
         {
             _backing = _backing.SetItems(Items());
 
@@ -302,7 +362,7 @@ IEnumerable<KeyValuePair<string, T>> Items()
         /// Clone. As we're copy on write, this
         /// should be cheap.
         /// </summary>
-        internal CopyOnWritePropertyDictionary<T> DeepClone()
+        public ICopyOnWritePropertyDictionary<T> DeepClone()
         {
             return new CopyOnWritePropertyDictionary<T>(this);
         }
diff --git a/src/Build/Collections/ICopyOnWritePropertyDictionary.cs b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
new file mode 100644
index 00000000000..310476fa83b
--- /dev/null
+++ b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
@@ -0,0 +1,65 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using Microsoft.Build.Shared;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// An interface that represents a dictionary of unordered property or metadata name/value pairs with copy-on-write semantics.
+    /// </summary>
+    /// <remarks>
+    /// The value that this adds over IDictionary&lt;string, T&gt; is:
+    ///     - supports copy on write
+    ///     - enforces that key = T.Name
+    ///     - default enumerator is over values
+    ///     - (marginal) enforces the correct key comparer
+    ///
+    /// Really a Dictionary&lt;string, T&gt; where the key (the name) is obtained from IKeyed.Key.
+    /// Is not observable, so if clients wish to observe modifications they must mediate them themselves and
+    /// either not expose this collection or expose it through a readonly wrapper.
+    ///
+    /// This collection is safe for concurrent readers and a single writer.
+    /// </remarks>
+    /// <typeparam name="T">Property or Metadata class type to store</typeparam>
+    internal interface ICopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatable<ICopyOnWritePropertyDictionary<T>>, IDictionary<string, T>
+        where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
+    {
+        /// <summary>
+        /// Returns true if a property with the specified name is present in the collection, otherwise false.
+        /// </summary>
+        bool Contains(string name);
+
+        /// <summary>
+        /// Add the specified property to the collection.
+        /// Overwrites any property with the same name already in the collection.
+        /// To remove a property, use Remove(...) instead.
+        /// </summary>
+        void Set(T projectProperty);
+
+        /// <summary>
+        /// Adds the specified properties to this dictionary.
+        /// </summary>
+        /// <param name="other">An enumerator over the properties to add.</param>
+        void ImportProperties(IEnumerable<T> other);
+
+        /// <summary>
+        /// Clone. As we're copy on write, this should be cheap.
+        /// </summary>
+        ICopyOnWritePropertyDictionary<T> DeepClone();
+
+        /// <summary>
+        /// <typeparamref name="T"/> must implement <see cref="IKeyed"/>, which means it contains an
+        /// EscapedValue. This method allows retrieving the EscapedValue of an object in the dictionary
+        /// directly.
+        /// </summary>
+        string GetEscapedValue(string name);
+    }
+}
diff --git a/src/Build/Collections/IMultiDictionary.cs b/src/Build/Collections/IMultiDictionary.cs
new file mode 100644
index 00000000000..1fece50dc23
--- /dev/null
+++ b/src/Build/Collections/IMultiDictionary.cs
@@ -0,0 +1,24 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Represents a dictionary that can hold more than one distinct value with the same key.
+    /// All keys must have at least one value: null values are currently rejected.
+    /// </summary>
+    /// <typeparam name="K">Type of key</typeparam>
+    /// <typeparam name="V">Type of value</typeparam>
+    internal interface IMultiDictionary<K, V>
+        where K : class
+        where V : class
+    {
+        IEnumerable<V> this[K key] { get; }
+    }
+}
diff --git a/src/Build/Collections/MultiDictionary.cs b/src/Build/Collections/MultiDictionary.cs
index b2fc7427261..ef8c02c8c8e 100644
--- a/src/Build/Collections/MultiDictionary.cs
+++ b/src/Build/Collections/MultiDictionary.cs
@@ -22,7 +22,7 @@ namespace Microsoft.Build.Collections
     /// <typeparam name="K">Type of key</typeparam>
     /// <typeparam name="V">Type of value</typeparam>
     [DebuggerDisplay("#Keys={KeyCount} #Values={ValueCount}")]
-    internal class MultiDictionary<K, V>
+    internal class MultiDictionary<K, V> : IMultiDictionary<K, V>
         where K : class
         where V : class
     {
@@ -86,7 +86,7 @@ internal MultiDictionary(IEqualityComparer<K> keyComparer)
         /// <summary>
         /// Enumerator over values that have the specified key.
         /// </summary>
-        internal IEnumerable<V> this[K key]
+        public IEnumerable<V> this[K key]
         {
             get
             {
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 26be27d807b..c105e12083b 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -42,14 +42,14 @@ internal sealed class PropertyDictionary<T> : IEnumerable<T>, IEquatable<Propert
         /// Backing dictionary
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
-        private readonly IRetrievableEntryHashSet<T> _properties;
+        private readonly IRetrievableValuedEntryHashSet<T> _properties;
 
         /// <summary>
         /// Creates empty dictionary
         /// </summary>
         public PropertyDictionary()
         {
-            _properties = new RetrievableEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new RetrievableValuedEntryHashSet<T>(MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -57,7 +57,7 @@ public PropertyDictionary()
         /// </summary>
         internal PropertyDictionary(int capacity)
         {
-            _properties = new RetrievableEntryHashSet<T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
+            _properties = new RetrievableValuedEntryHashSet<T>(capacity, MSBuildNameIgnoreCaseComparer.Default);
         }
 
         /// <summary>
@@ -77,7 +77,7 @@ internal PropertyDictionary(IEnumerable<T> elements)
         /// </summary>
         internal PropertyDictionary(MSBuildNameIgnoreCaseComparer comparer)
         {
-            _properties = new RetrievableEntryHashSet<T>(comparer);
+            _properties = new RetrievableValuedEntryHashSet<T>(comparer);
         }
 
         /// <summary>
@@ -96,7 +96,7 @@ internal PropertyDictionary(int capacity, IEnumerable<T> elements)
         /// Initializes a new instance of the <see cref="PropertyDictionary{T}"/> class.
         /// </summary>
         /// <param name="propertiesHashSet">The collection of properties to use.</param>
-        internal PropertyDictionary(IRetrievableEntryHashSet<T> propertiesHashSet)
+        internal PropertyDictionary(IRetrievableValuedEntryHashSet<T> propertiesHashSet)
         {
             _properties = propertiesHashSet;
         }
@@ -324,6 +324,24 @@ public T Get(string keyString, int startIndex, int endIndex)
             return GetProperty(keyString, startIndex, endIndex);
         }
 
+        /// <summary>
+        /// Gets the unescaped value of a particular property.
+        /// </summary>
+        /// <param name="propertyName">The name of the property whose value is sought.</param>
+        /// <param name="unescapedValue">The out parameter by which a successfully retrieved value is returned.</param>
+        /// <returns>True if a property with a matching name was found. False otherwise.</returns>
+        public bool TryGetPropertyUnescapedValue(string propertyName, out string unescapedValue)
+        {
+            if (_properties.TryGetEscapedValue(propertyName, out string escapedValue) && escapedValue != null)
+            {
+                unescapedValue = EscapingUtilities.UnescapeAll(escapedValue);
+                return true;
+            }
+
+            unescapedValue = null;
+            return false;
+        }
+
         #region IDictionary<string,T> Members
 
         /// <summary>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
index 3100e7914a8..4d271575848 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableEntryHashSet.cs
@@ -8,6 +8,12 @@
 
 namespace Microsoft.Build.Collections
 {
+    /// <summary>
+    /// Represents a hash set mapping string to <typeparamref name="T"/>, with the specialization that
+    /// value lookup supports using substrings of a provided key without requiring instantiating the substring
+    /// (in order to avoid the memory usage of string allocation).
+    /// </summary>
+    /// <typeparam name="T">The type of data the hash set contains (which must be <see cref="IKeyed"/>).</typeparam>
     internal interface IRetrievableEntryHashSet<T> :
         ICollection<T>,
         ISerializable,
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
new file mode 100644
index 00000000000..e3b10556772
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
@@ -0,0 +1,34 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Runtime.Serialization;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// Like <see cref="IRetrievableEntryHashSet{T}"/>, this represents a hash set mapping string to <typeparamref name="T"/>
+    /// with the specialization that value lookup supports using substrings of a provided key without requiring instantiating
+    /// the substring (in order to avoid the memory usage of string allocation).
+    ///
+    /// This interface extends the functionality of <see cref="IRetrievableEntryHashSet{T}"/> by introducing the ability
+    /// to directly retrieve the Value of an instance of T instead of retrieving the instance of T itself. Implementations of
+    /// this interface can avoid the cost of allocating an instance of <typeparamref name="T"/> when the caller requests only
+    /// the Value.
+    /// </summary>
+    /// <typeparam name="T">The type of data the hash set contains (which must be
+    /// <see cref="IKeyed"/> and also <see cref="IValued"/>).</typeparam>
+    internal interface IRetrievableValuedEntryHashSet<T> : IRetrievableEntryHashSet<T>
+        where T : class, IKeyed, IValued
+    {
+        /// <summary>
+        /// Gets the <see cref="IValued.EscapedValue"/> of the item whose <see cref="IKeyed.Key"/> matches <paramref name="key"/>.
+        /// </summary>
+        /// <param name="key">The key of the item whose value is sought.</param>
+        /// <param name="escapedValue">The out parameter by which a successfully retrieved <see cref="IValued.EscapedValue"/> is returned.</param>
+        /// <returns>True if an item whose <see cref="IKeyed.Key"/> matches <paramref name="key"/> was found. False otherwise.</returns>
+        bool TryGetEscapedValue(string key, out string escapedValue);
+    }
+}
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
similarity index 99%
rename from src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
rename to src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
index e6160cec90f..dc8d96f9f7c 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableEntryHashSet.cs
@@ -320,7 +320,7 @@ public bool TryGetValue(string key, out T item)
         /// Gets the item if any with the given name
         /// </summary>
         /// <param name="key">key to check for containment</param>
-        /// <returns>true if item contained; false if not</returns>
+        /// <returns>The item, if it was found. Otherwise, default(T).</returns>
         public T Get(string key)
         {
             return GetCore(key, 0, key?.Length ?? 0);
diff --git a/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
new file mode 100644
index 00000000000..c45da4e12b6
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
@@ -0,0 +1,53 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+#nullable disable
+
+namespace Microsoft.Build.Collections
+{
+    /// <inheritdoc />
+    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]
+    [DebuggerDisplay("Count = {Count}")]
+#if FEATURE_SECURITY_PERMISSIONS
+    [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
+#endif
+    internal class RetrievableValuedEntryHashSet<T> : RetrievableEntryHashSet<T>, IRetrievableValuedEntryHashSet<T>
+        where T : class, IKeyed, IValued
+    {
+        /// <summary>
+        /// Initializes a new instance of the RetrievableValuedEntryHashSet class.
+        /// </summary>
+        /// <param name="comparer">A comparer with which the items' <see cref="IKeyed.Key"/> key values are compared.</param>
+        public RetrievableValuedEntryHashSet(IEqualityComparer<string> comparer)
+            : base(comparer)
+        {
+        }
+
+        /// <summary>
+        /// Initializes a new instance of the RetrievableValuedEntryHashSet class.
+        /// </summary>
+        /// <param name="suggestedCapacity">A value suggesting a good approximate minimum size for the initial collection.</param>
+        /// <param name="comparer">A comparer with which the items' <see cref="IKeyed.Key"/> key values are compared.</param>
+        public RetrievableValuedEntryHashSet(int suggestedCapacity, IEqualityComparer<string> comparer)
+            : base(suggestedCapacity, comparer)
+        {
+        }
+
+        /// <inheritdoc />
+        public bool TryGetEscapedValue(string key, out string escapedValue)
+        {
+            if (TryGetValue(key, out T item) && item != null)
+            {
+                escapedValue = item.EscapedValue;
+                return true;
+            }
+
+            escapedValue = null;
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Construction/ProjectPropertyElement.cs b/src/Build/Construction/ProjectPropertyElement.cs
index c9020db30ba..8929dea6406 100644
--- a/src/Build/Construction/ProjectPropertyElement.cs
+++ b/src/Build/Construction/ProjectPropertyElement.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
 using Microsoft.Build.ObjectModelRemoting;
 using Microsoft.Build.Shared;
@@ -20,7 +21,7 @@ namespace Microsoft.Build.Construction
     /// So the CM only represents Normal properties.
     /// </remarks>
     [DebuggerDisplay("{Name} Value={Value} Condition={Condition}")]
-    public class ProjectPropertyElement : ProjectElement
+    public class ProjectPropertyElement : ProjectElement, IPropertyElementWithLocation
     {
         internal ProjectPropertyElementLink PropertyLink => (ProjectPropertyElementLink)Link;
 
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 791c88c741c..741babe959c 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -4263,7 +4263,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Prepares the data object for evaluation.
             /// </summary>
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
             {
                 DefaultTargets = null;
                 Properties = new PropertyDictionary<ProjectProperty>();
@@ -4271,7 +4271,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, Evaluation
                 Items = new ItemDictionary<ProjectItem>();
                 ItemsIgnoringCondition = new ItemDictionary<ProjectItem>();
                 ItemsByEvaluatedIncludeCache = new MultiDictionary<string, ProjectItem>(StringComparer.OrdinalIgnoreCase);
-                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext);
+                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext, loggingContext);
                 ItemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinition>(MSBuildNameIgnoreCaseComparer.Default);
                 Targets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
                 ImportClosure = new List<ResolvedImport>();
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 11dd0a1143d..cf70b8f41fa 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -887,6 +887,21 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
         /// Returns the property dictionary containing the properties representing the environment.
         /// </summary>
         internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
+        {
+            get
+            {
+                // Retrieves the environment properties.
+                // This is only done once, when the project collection is created. Any subsequent
+                // environment changes will be ignored. Child nodes will be passed this set
+                // of properties in their build parameters.
+                return new PropertyDictionary<ProjectPropertyInstance>(SharedReadOnlyEnvironmentProperties);
+            }
+        }
+
+        /// <summary>
+        /// Returns a shared immutable property dictionary containing the properties representing the environment.
+        /// </summary>
+        internal PropertyDictionary<ProjectPropertyInstance> SharedReadOnlyEnvironmentProperties
         {
             get
             {
@@ -898,7 +913,7 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                 {
                     if (_environmentProperties != null)
                     {
-                        return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
+                        return _environmentProperties;
                     }
                 }
 
@@ -906,9 +921,9 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                 {
                     if (_environmentProperties == null)
                     {
-                        _environmentProperties = Utilities.GetEnvironmentProperties();
+                        _environmentProperties = Utilities.GetEnvironmentProperties(makeReadOnly: true);
                     }
-                    return new PropertyDictionary<ProjectPropertyInstance>(_environmentProperties);
+                    return _environmentProperties;
                 }
             }
         }
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index bf9ae352007..eee61cb02f5 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -9,6 +9,7 @@
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
@@ -685,7 +686,7 @@ internal static Toolset FactoryForDeserialization(ITranslator translator)
         /// <summary>
         /// Given a search path and a task pattern get a list of task or override task files.
         /// </summary>
-        internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskPattern, string searchPath, string taskFileWarning)
+        internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, LoggingContext loggingContext, string taskPattern, string searchPath, string taskFileWarning)
         {
             string[] defaultTasksFiles = null;
 
@@ -703,8 +704,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
                 if (defaultTasksFiles.Length == 0)
                 {
-                    loggingServices.LogWarning(
-                        buildEventContext,
+                    loggingContext.LogWarning(
                         null,
                         new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                         taskFileWarning,
@@ -715,8 +715,7 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogWarning(
-                    buildEventContext,
+                loggingContext.LogWarning(
                     null,
                     new BuildEventFileInfo(/* this warning truly does not involve any file */ String.Empty),
                     taskFileWarning,
@@ -819,13 +818,12 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         /// <summary>
         /// Return a task registry stub for the tasks in the *.tasks file for this toolset
         /// </summary>
-        /// <param name="loggingServices">The logging services used to log during task registration.</param>
-        /// <param name="buildEventContext">The build event context used to log during task registration.</param>
+        /// <param name="loggingContext">The logging context used to log during task registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         /// <returns>The task registry</returns>
-        internal TaskRegistry GetTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        internal TaskRegistry GetTaskRegistry(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
-            RegisterDefaultTasks(loggingServices, buildEventContext, projectRootElementCache);
+            RegisterDefaultTasks(loggingContext, projectRootElementCache);
             return _defaultTaskRegistry;
         }
 
@@ -846,13 +844,12 @@ internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary<st
         /// <summary>
         /// Return a task registry for the override tasks in the *.overridetasks file for this toolset
         /// </summary>
-        /// <param name="loggingServices">The logging services used to log during task registration.</param>
-        /// <param name="buildEventContext">The build event context used to log during task registration.</param>
+        /// <param name="loggingContext">The logging context used to log during task registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
         /// <returns>The task registry</returns>
-        internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        internal TaskRegistry GetOverrideTaskRegistry(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
-            RegisterOverrideTasks(loggingServices, buildEventContext, projectRootElementCache);
+            RegisterOverrideTasks(loggingContext, projectRootElementCache);
             return _overrideTaskRegistry;
         }
 
@@ -867,10 +864,9 @@ internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, B
         /// 3) comment tags are always ignored regardless of their placement
         /// 4) the rest of the tags are expected to be &lt;UsingTask&gt; tags
         /// </remarks>
-        /// <param name="loggingServices">The logging services to use to log during this registration.</param>
-        /// <param name="buildEventContext">The build event context to use to log during this registration.</param>
+        /// <param name="loggingContext">The logging context to use to log during this registration.</param>
         /// <param name="projectRootElementCache">The <see cref="ProjectRootElementCache"/> to use.</param>
-        private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        private void RegisterDefaultTasks(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
             if (!_defaultTasksRegistrationAttempted)
             {
@@ -878,10 +874,10 @@ private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventCon
                 {
                     _defaultTaskRegistry = new TaskRegistry(projectRootElementCache);
 
-                    InitializeProperties(loggingServices, buildEventContext);
+                    InitializeProperties(loggingContext);
 
-                    string[] defaultTasksFiles = GetTaskFiles(_getFiles, loggingServices, buildEventContext, DefaultTasksFilePattern, ToolsPath, "DefaultTasksFileLoadFailureWarning");
-                    LoadAndRegisterFromTasksFile(defaultTasksFiles, loggingServices, buildEventContext, "DefaultTasksFileFailure", projectRootElementCache, _defaultTaskRegistry);
+                    string[] defaultTasksFiles = GetTaskFiles(_getFiles, loggingContext, DefaultTasksFilePattern, ToolsPath, "DefaultTasksFileLoadFailureWarning");
+                    LoadAndRegisterFromTasksFile(defaultTasksFiles, loggingContext, "DefaultTasksFileFailure", projectRootElementCache, _defaultTaskRegistry);
                 }
                 finally
                 {
@@ -893,7 +889,7 @@ private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventCon
         /// <summary>
         /// Initialize the properties which are used to evaluate the tasks files.
         /// </summary>
-        private void InitializeProperties(ILoggingService loggingServices, BuildEventContext buildEventContext)
+        private void InitializeProperties(LoggingContext loggingContext)
         {
             if (_expander != null)
             {
@@ -965,18 +961,18 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
 
                 propertyBag.ImportProperties(_globalProperties);
 
-                _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, FileSystems.Default);
+                _expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(propertyBag, FileSystems.Default, loggingContext);
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogError(buildEventContext, new BuildEventFileInfo(/* this warning truly does not involve any file it is just gathering properties */String.Empty), "TasksPropertyBagError", e.Message);
+                loggingContext.LogError(new BuildEventFileInfo(/* this warning truly does not involve any file it is just gathering properties */String.Empty), "TasksPropertyBagError", e.Message);
             }
         }
 
         /// <summary>
         /// Used to load information about MSBuild override tasks i.e. tasks that override tasks declared in tasks or project files.
         /// </summary>
-        private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache)
+        private void RegisterOverrideTasks(LoggingContext loggingContext, ProjectRootElementCacheBase projectRootElementCache)
         {
             if (!_overrideTasksRegistrationAttempted)
             {
@@ -1005,23 +1001,23 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
                             if (!overrideDirectoryExists)
                             {
                                 string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskNotRootedPath", _overrideTasksPath);
-                                loggingServices.LogWarning(buildEventContext, null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
+                                loggingContext.LogWarning(null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
                             }
                         }
                     }
                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                     {
                         string rootedPathMessage = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OverrideTaskProblemWithPath", _overrideTasksPath, e.Message);
-                        loggingServices.LogWarning(buildEventContext, null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
+                        loggingContext.LogWarning(null, new BuildEventFileInfo(String.Empty /* this warning truly does not involve any file*/), "OverrideTasksFileFailure", rootedPathMessage);
                     }
 
                     if (overrideDirectoryExists)
                     {
-                        InitializeProperties(loggingServices, buildEventContext);
-                        string[] overrideTasksFiles = GetTaskFiles(_getFiles, loggingServices, buildEventContext, OverrideTasksFilePattern, _overrideTasksPath, "OverrideTasksFileLoadFailureWarning");
+                        InitializeProperties(loggingContext);
+                        string[] overrideTasksFiles = GetTaskFiles(_getFiles, loggingContext, OverrideTasksFilePattern, _overrideTasksPath, "OverrideTasksFileLoadFailureWarning");
 
                         // Load and register any override tasks
-                        LoadAndRegisterFromTasksFile(overrideTasksFiles, loggingServices, buildEventContext, "OverrideTasksFileFailure", projectRootElementCache, _overrideTaskRegistry);
+                        LoadAndRegisterFromTasksFile(overrideTasksFiles, loggingContext, "OverrideTasksFileFailure", projectRootElementCache, _overrideTaskRegistry);
                     }
                 }
                 finally
@@ -1034,14 +1030,13 @@ private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventCo
         /// <summary>
         /// Do the actual loading of the tasks or override tasks file and register the tasks in the task registry
         /// </summary>
-        private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry)
+        private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, LoggingContext loggingContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry)
         {
             string currentTasksFile = null;
             try
             {
                 TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<ProjectPropertyInstance, ProjectItemInstance>(
-                    loggingServices,
-                    buildEventContext,
+                    loggingContext,
                     EnumerateTasksRegistrations(),
                     registry,
                     _expander,
@@ -1056,7 +1051,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
             }
             catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
             {
-                loggingServices.LogError(buildEventContext, new BuildEventFileInfo(currentTasksFile),
+                loggingContext.LogError(new BuildEventFileInfo(currentTasksFile),
                     taskFileError, e.Message);
             }
 
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 1d231597726..f7918c19052 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -186,11 +186,9 @@ internal static bool EvaluateCondition<P, I>(
             ExpanderOptions expanderOptions,
             string evaluationDirectory,
             ElementLocation elementLocation,
-            ILoggingService loggingServices,
-            BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase? projectRootElementCache = null,
-            LoggingContext? loggingContext = null)
+            LoggingContext? loggingContext,
+            ProjectRootElementCacheBase? projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -202,11 +200,9 @@ internal static bool EvaluateCondition<P, I>(
                 conditionedPropertiesTable: null /* do not collect conditioned properties */,
                 evaluationDirectory,
                 elementLocation,
-                loggingServices,
-                buildEventContext,
                 fileSystem,
-                projectRootElementCache,
-                loggingContext);
+                loggingContext,
+                projectRootElementCache);
         }
 
         /// <summary>
@@ -224,18 +220,15 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
             Dictionary<string, List<string>>? conditionedPropertiesTable,
             string evaluationDirectory,
             ElementLocation elementLocation,
-            ILoggingService loggingServices,
-            BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase? projectRootElementCache = null,
-            LoggingContext? loggingContext = null)
+            LoggingContext? loggingContext,
+            ProjectRootElementCacheBase? projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
             ErrorUtilities.VerifyThrowArgumentNull(condition, nameof(condition));
             ErrorUtilities.VerifyThrowArgumentNull(expander, nameof(expander));
             ErrorUtilities.VerifyThrowArgumentLength(evaluationDirectory, nameof(evaluationDirectory));
-            ErrorUtilities.VerifyThrowArgumentNull(buildEventContext, nameof(buildEventContext));
 
             // An empty condition is equivalent to a "true" condition.
             if (condition.Length == 0)
@@ -263,8 +256,8 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                 var conditionParser = new Parser();
 
                 #region REMOVE_COMPAT_WARNING
-                conditionParser.LoggingServices = loggingServices;
-                conditionParser.LogBuildEventContext = buildEventContext;
+                conditionParser.LoggingServices = loggingContext?.LoggingService;
+                conditionParser.LogBuildEventContext = loggingContext?.BuildEventContext ?? BuildEventContext.Invalid;
                 #endregion
 
                 parsedExpression = conditionParser.Parse(condition, options, elementLocation);
@@ -282,13 +275,14 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                 fileSystem,
                 projectRootElementCache);
 
+            expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
             // We are evaluating this expression now and it can cache some state for the duration,
             // so we don't want multiple threads working on the same expression
             lock (parsedExpression)
             {
                 try
                 {
-                    result = parsedExpression.Evaluate(state, loggingContext);
+                    result = parsedExpression.Evaluate(state);
                 }
                 finally
                 {
@@ -298,6 +292,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>(
                         // Finished using the expression tree. Add it back to the pool so other threads can use it.
                         expressionPool.Push(parsedExpression);
                     }
+                    expander.PropertiesUseTracker.ResetPropertyReadContext();
                 }
             }
 
@@ -350,6 +345,8 @@ internal interface IConditionEvaluationState
 
             ElementLocation ElementLocation { get; }
 
+            PropertiesUseTracker PropertiesUseTracker { get; }
+
             /// <summary>
             ///     Table of conditioned properties and their values.
             ///     Used to populate configuration lists in some project systems.
@@ -362,7 +359,7 @@ internal interface IConditionEvaluationState
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null);
+            string ExpandIntoStringBreakEarly(string expression);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -372,7 +369,7 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression, LoggingContext? loggingContext = null);
+            string ExpandIntoString(string expression);
 
             /// <summary>
             ///     PRE cache
@@ -403,6 +400,8 @@ internal class ConditionEvaluationState<P, I> : IConditionEvaluationState
 
             public ElementLocation ElementLocation { get; }
 
+            public PropertiesUseTracker PropertiesUseTracker => _expander.PropertiesUseTracker;
+
             public IFileSystem FileSystem { get; }
 
             /// <summary>
@@ -447,13 +446,9 @@ internal ConditionEvaluationState(
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression, LoggingContext? loggingContext = null)
+            public string ExpandIntoStringBreakEarly(string expression)
             {
-                var originalValue = _expander.WarnForUninitializedProperties;
-
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation, loggingContext);
-
-                _expander.WarnForUninitializedProperties = originalValue;
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation);
 
                 return expression;
             }
@@ -465,12 +460,8 @@ public string ExpandIntoStringBreakEarly(string expression, LoggingContext? logg
             /// <returns>A list of items.</returns>
             public IList<TaskItem> ExpandIntoTaskItems(string expression)
             {
-                var originalValue = _expander.WarnForUninitializedProperties;
-
                 var items = _expander.ExpandIntoTaskItemsLeaveEscaped(expression, _expanderOptions, ElementLocation);
 
-                _expander.WarnForUninitializedProperties = originalValue;
-
                 return items;
             }
 
@@ -478,15 +469,10 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// Expands the specified expression into a string.
             /// </summary>
             /// <param name="expression">The expression to expand.</param>
-            /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression, LoggingContext? loggingContext = null)
+            public string ExpandIntoString(string expression)
             {
-                var originalValue = _expander.WarnForUninitializedProperties;
-
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation, loggingContext);
-
-                _expander.WarnForUninitializedProperties = originalValue;
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation);
 
                 return expression;
             }
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index ce021dc2f10..1303731a2f6 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -19,9 +19,9 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
@@ -38,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                          state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index e16e7537379..6d7b27eb243 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -30,7 +30,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// <summary>
         /// Evaluate node as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index 3d0d6d99456..e8a7858d415 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -14,9 +14,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null);
-        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null);
-        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -25,7 +25,7 @@ internal abstract class GenericExpressionNode
         /// to empty than to fully evaluate it.)
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             return false;
         }
@@ -34,7 +34,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
         /// <summary>
         /// Value before any item and property expressions are expanded
@@ -42,6 +42,12 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// <returns></returns>
         internal abstract string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
+        /// <summary>
+        /// Checks if value is empty before any item and property expressions are expanded
+        /// </summary>
+        /// <returns></returns>
+        internal abstract bool IsUnexpandedValueEmpty();
+
         /// <summary>
         /// If any expression nodes cache any state for the duration of evaluation,
         /// now's the time to clean it up
@@ -52,17 +58,16 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// The main evaluate entry point for expression trees
         /// </summary>
         /// <param name="state"></param>
-        /// <param name="loggingContext"></param>
         /// <returns></returns>
-        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ConditionNotBooleanDetail",
                     state.Condition,
-                    GetExpandedValue(state, loggingContext));
+                    GetExpandedValue(state));
             }
 
             return boolValue;
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 208794b3603..f398e8d740a 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -37,7 +37,7 @@ internal abstract class MultipleComparisonNode : OperatorExpressionNode
         /// Order in which comparisons are attempted is numeric, boolean, then string.
         /// Updates conditioned properties table.
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             ProjectErrorUtilities.VerifyThrowInvalidProject(
                 LeftChild != null && RightChild != null,
@@ -51,8 +51,18 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' "
             // which is a performance advantage if @(X) is a huge item list.
-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
-            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
+
+            // This is the possible case of an expression similar to '$(a)' == '', where a usage of uninitialized
+            //  property is reasonable and should not be flagged by uninitialized reads detection.
+            // So if at least one side is empty, we know to signal to PropertiesUseTracker to not flag in this scope.
+            // The other side might not be property at all - that's fine, as then PropertiesUseTracker won't be even called.
+            if (LeftChild.IsUnexpandedValueEmpty() || RightChild.IsUnexpandedValueEmpty())
+            {
+                state.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluationWithOneSideEmpty;
+            }
+
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
             if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
@@ -69,13 +79,13 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 // is 17.0).
                 return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue, loggingContext) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue, loggingContext))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
             {
                 return Compare(leftBoolValue, rightBoolValue);
             }
 
-            string leftExpandedValue = LeftChild.GetExpandedValue(state, loggingContext);
-            string rightExpandedValue = RightChild.GetExpandedValue(state, loggingContext);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state);
+            string rightExpandedValue = RightChild.GetExpandedValue(state);
 
             ProjectErrorUtilities.VerifyThrowInvalidProject(
                 leftExpandedValue != null && rightExpandedValue != null,
@@ -85,6 +95,9 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
 
             UpdateConditionedProperties(state);
 
+            // reset back the property read context (it's no longer a condition with one side empty)
+            state.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
+
             return Compare(leftExpandedValue, rightExpandedValue);
         }
 
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 71dec16ec3d..66bfc64c1c2 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -19,9 +19,9 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
@@ -42,12 +42,15 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
             return "!" + LeftChild.GetUnexpandedValue(state);
         }
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty() => false;
+
         /// <summary>
         /// Returns expanded value with '!' prepended. Useful for error messages.
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
-            return "!" + LeftChild.GetExpandedValue(state, loggingContext);
+            return "!" + LeftChild.GetExpandedValue(state);
         }
 
         internal override string DebuggerDisplay => $"(not {LeftChild.DebuggerDisplay})";
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index a371e9a0850..fb6cc3b3a71 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -38,7 +38,7 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
             bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
@@ -53,7 +53,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     state.Condition,
                     /* helpfully display unexpanded token and expanded result in error message */
                     isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                    isLeftNum ? RightChild.GetExpandedValue(state, loggingContext) : LeftChild.GetExpandedValue(state, loggingContext));
+                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
             }
 
             return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index acfdd72bce9..6089e5dd255 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -3,11 +3,8 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -16,29 +13,34 @@ namespace Microsoft.Build.Evaluation
     [DebuggerDisplay("{DebuggerDisplay,nq}")]
     internal sealed class NumericExpressionNode : OperandExpressionNode
     {
-        private string _value;
+        private readonly string _value;
 
         internal NumericExpressionNode(string value)
         {
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(value), "NumericExpressionNode cannot have empty value");
             _value = value;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version? result)
         {
             return Version.TryParse(_value, out result);
         }
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty()
+            => false;
+
         /// <summary>
         /// Get the unexpanded value
         /// </summary>
@@ -50,7 +52,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Get the expanded value
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return _value;
         }
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 2c172a9af0a..55cf768c60b 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -3,6 +3,7 @@
 
 using System;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
 
 #nullable disable
 
@@ -13,21 +14,21 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            result = BoolEvaluate(state, loggingContext);
+            result = BoolEvaluate(state);
             return true;
         }
 
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             result = default;
             return false;
@@ -37,11 +38,15 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return null;
         }
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty()
+            => (LeftChild?.IsUnexpandedValueEmpty() ?? true) && (RightChild?.IsUnexpandedValueEmpty() ?? true);
+
         /// <summary>
         /// Value before any item and property expressions are expanded
         /// </summary>
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index 9d4add7436e..dae691252e2 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -19,15 +19,15 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ExpressionDoesNotEvaluateToBoolean",
                     LeftChild.GetUnexpandedValue(state),
-                    LeftChild.GetExpandedValue(state, loggingContext),
+                    LeftChild.GetExpandedValue(state),
                     state.Condition);
             }
 
@@ -38,7 +38,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                         state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 2c3dcc080df..f66e2d5efee 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -31,34 +31,34 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state, loggingContext), out result);
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state, loggingContext), out result);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
             }
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return Version.TryParse(GetExpandedValue(state, loggingContext), out result);
+                return Version.TryParse(GetExpandedValue(state), out result);
             }
         }
 
@@ -69,7 +69,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// to empty than to fully evaluate it.
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
@@ -94,7 +94,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
                             break;
                     }
 
-                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value, loggingContext);
+                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
 
                     if (expandBreakEarly == null)
                     {
@@ -117,6 +117,10 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
         }
 
 
+        /// <inheritdoc cref="GenericExpressionNode"/>
+        internal override bool IsUnexpandedValueEmpty() 
+            => string.IsNullOrEmpty(_value);
+
         /// <summary>
         /// Value before any item and property expressions are expanded
         /// </summary>
@@ -130,13 +134,13 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
                 if (_expandable)
                 {
-                    _cachedExpandedValue = state.ExpandIntoString(_value, loggingContext);
+                    _cachedExpandedValue = state.ExpandIntoString(_value);
                 }
                 else
                 {
@@ -169,7 +173,7 @@ internal override void ResetState()
         /// but now cause the project to throw InvalidProjectException when
         /// ToolsVersion is "Current". https://github.com/dotnet/msbuild/issues/4150
         /// </remarks>
-        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (!_shouldBeTreatedAsVisualStudioVersion.HasValue)
             {
@@ -177,7 +181,7 @@ private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionE
 
                 // Do this check first, because if it's not (common) we can early-out and the next
                 // expansion will be cheap because this will populate the cached expanded value.
-                if (string.Equals(GetExpandedValue(state, loggingContext), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
+                if (string.Equals(GetExpandedValue(state), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
                 {
                     // and it is just an expansion of MSBuildToolsVersion
                     _shouldBeTreatedAsVisualStudioVersion = string.Equals(_value, "$(MSBuildToolsVersion)", StringComparison.OrdinalIgnoreCase);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 85447378533..b82733a9d8e 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.BackEnd.Components.RequestBuilder;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -223,12 +224,8 @@ private Evaluator(
                 buildEventContext,
                 string.IsNullOrEmpty(projectRootElement.ProjectFileLocation.File) ? "(null)" : projectRootElement.ProjectFileLocation.File);
 
-            // If someone sets the 'MsBuildLogPropertyTracking' environment variable to a non-zero value, wrap property accesses for event reporting.
-            if (Traits.Instance.LogPropertyTracking > 0)
-            {
-                // Wrap the IEvaluatorData<> object passed in.
-                data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
-            }
+            // Wrap the IEvaluatorData<> object passed in.
+            data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
 
             // If the host wishes to provide a directory cache for this evaluation, create a new EvaluationContext with the right file system.
             _evaluationContext = evaluationContext;
@@ -240,12 +237,10 @@ private Evaluator(
             }
 
             // Create containers for the evaluation results
-            data.InitializeForEvaluation(toolsetProvider, _evaluationContext);
+            data.InitializeForEvaluation(toolsetProvider, _evaluationContext, _evaluationLoggingContext);
 
             _expander = new Expander<P, I>(data, data, _evaluationContext, _evaluationLoggingContext);
 
-            // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
-            _expander.WarnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
             _data = data;
             _itemGroupElements = new List<ProjectItemGroupElement>();
             _itemDefinitionGroupElements = new List<ProjectItemDefinitionGroupElement>();
@@ -713,8 +708,7 @@ private void Evaluate()
                 {
                     // Evaluate the usingtask and add the result into the data passed in
                     TaskRegistry.InitializeTaskRegistryFromUsingTaskElements<P, I>(
-                        _evaluationLoggingContext.LoggingService,
-                        _evaluationLoggingContext.BuildEventContext,
+                        _evaluationLoggingContext,
                         _usingTaskElements.Select(p => (p.Value, p.Key)),
                         _data.TaskRegistry,
                         _expander,
@@ -860,12 +854,12 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
             using (_evaluationProfiler.TrackFile(currentProjectOrImport.FullPath))
             {
                 // We accumulate InitialTargets from the project and each import
-                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation, _evaluationLoggingContext);
+                var initialTargets = _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.InitialTargets, ExpanderOptions.ExpandProperties, currentProjectOrImport.InitialTargetsLocation);
                 _initialTargetsList.AddRange(initialTargets);
 
                 if (!Traits.Instance.EscapeHatches.IgnoreTreatAsLocalProperty)
                 {
-                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation, _evaluationLoggingContext))
+                    foreach (string propertyName in _expander.ExpandIntoStringListLeaveEscaped(currentProjectOrImport.TreatAsLocalProperty, ExpanderOptions.ExpandProperties, currentProjectOrImport.TreatAsLocalPropertyLocation))
                     {
                         XmlUtilities.VerifyThrowProjectValidElementName(propertyName, currentProjectOrImport.Location);
                         _data.GlobalPropertiesToTreatAsLocal.Add(propertyName);
@@ -1051,8 +1045,8 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
         /// </summary>
         private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets, Dictionary<string, List<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget)
         {
-            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation, _evaluationLoggingContext);
-            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation, _evaluationLoggingContext);
+            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation);
+            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation);
 
             foreach (string beforeTarget in beforeTargets)
             {
@@ -1285,90 +1279,23 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                     return;
                 }
 
+                _expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.ConditionEvaluation;
                 if (!EvaluateConditionCollectingConditionedProperties(propertyElement, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties))
                 {
                     return;
                 }
 
+                _expander.PropertiesUseTracker.PropertyReadContext = PropertyReadContext.PropertyEvaluation;
+
                 // Set the name of the property we are currently evaluating so when we are checking to see if we want to add the property to the list of usedUninitialized properties we can not add the property if
                 // it is the same as what we are setting the value on. Note: This needs to be set before we expand the property we are currently setting.
-                _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
-
-                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location, _evaluationLoggingContext);
-
-                // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
-                // during evaluation.
-                if (evaluatedValue.Length > 0 && _expander.WarnForUninitializedProperties)
-                {
-                    // Is the property we are currently setting in the list of properties which have been used but not initialized
-                    IElementLocation elementWhichUsedProperty;
-                    bool isPropertyInList = _expander.UsedUninitializedProperties.TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
-
-                    if (isPropertyInList)
-                    {
-                        // Once we are going to warn for a property once, remove it from the list so we do not add it again.
-                        _expander.UsedUninitializedProperties.RemoveProperty(propertyElement.Name);
-                        _evaluationLoggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty.LocationString);
-                    }
-                }
-
-                _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = null;
-
-                if (Traits.Instance.LogPropertyTracking == 0)
-                {
-                    P predecessor = _data.GetProperty(propertyElement.Name);
-                    P property = _data.SetProperty(propertyElement, evaluatedValue);
-
-                    if (predecessor != null)
-                    {
-                        LogPropertyReassignment(predecessor, property, propertyElement.Location.LocationString);
-                    }
-                }
-                else
-                {
-                    _data.SetProperty(propertyElement, evaluatedValue);
-                }
-            }
-        }
+                _expander.PropertiesUseTracker.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
 
-        private void LogPropertyReassignment(P predecessor, P property, string location)
-        {
-            string newValue = property.EvaluatedValue;
-            string oldValue = predecessor?.EvaluatedValue;
-
-            if (string.Equals(property.Name, "MSBuildAllProjects", StringComparison.OrdinalIgnoreCase))
-            {
-                // There's a huge perf cost to logging this and it increases the binlog size significantly.
-                // Meanwhile the usefulness of logging this is very low.
-                return;
-            }
+                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location);
 
-            if (newValue != oldValue)
-            {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
-                {
-                    var args = new PropertyReassignmentEventArgs(
-                        property.Name,
-                        oldValue,
-                        newValue,
-                        location,
-                        message: null)
-                    {
-                        BuildEventContext = _evaluationLoggingContext.BuildEventContext,
-                    };
+                _expander.PropertiesUseTracker.CheckPreexistingUndefinedUsage(propertyElement, evaluatedValue, _evaluationLoggingContext);
 
-                    _evaluationLoggingContext.LogBuildEvent(args);
-                }
-                else
-                {
-                    _evaluationLoggingContext.LogComment(
-                        MessageImportance.Low,
-                        "PropertyReassignment",
-                        property.Name,
-                        newValue,
-                        oldValue,
-                        location);
-                }
+                _data.SetProperty(propertyElement, evaluatedValue);
             }
         }
 
@@ -2035,7 +1962,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
         {
             imports = null;
 
-            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation, _evaluationLoggingContext);
+            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
@@ -2459,8 +2386,6 @@ private bool EvaluateCondition(ProjectElement element, string condition, Expande
                     expanderOptions,
                     GetCurrentDirectoryForConditionEvaluation(element),
                     element.ConditionLocation,
-                    _evaluationLoggingContext.LoggingService,
-                    _evaluationLoggingContext.BuildEventContext,
                     _evaluationContext.FileSystem,
                     loggingContext: _evaluationLoggingContext);
 
@@ -2498,9 +2423,8 @@ private bool EvaluateConditionCollectingConditionedProperties(ProjectElement ele
                     _data.ConditionedProperties,
                     GetCurrentDirectoryForConditionEvaluation(element),
                     element.ConditionLocation,
-                    _evaluationLoggingContext.LoggingService,
-                    _evaluationLoggingContext.BuildEventContext,
                     _evaluationContext.FileSystem,
+                    _evaluationLoggingContext,
                     projectRootElementCache);
 
                 return result;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index e67785390a4..c64d877596a 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -307,7 +307,7 @@ private void FlushFirstValueIfNeeded()
         /// <summary>
         /// Set of properties which are null during expansion.
         /// </summary>
-        private UsedUninitializedProperties _usedUninitializedProperties;
+        private PropertiesUseTracker _propertiesUseTracker;
 
         private readonly IFileSystem _fileSystem;
 
@@ -318,25 +318,42 @@ private void FlushFirstValueIfNeeded()
         /// </summary>
         internal EvaluationContext EvaluationContext { get; }
 
+        private Expander(IPropertyProvider<P> properties, LoggingContext loggingContext)
+        {
+            _properties = properties;
+            _propertiesUseTracker = new PropertiesUseTracker(loggingContext);
+            _loggingContext = loggingContext;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties to use.
         /// Properties may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
+        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, loggingContext)
         {
-            _properties = properties;
-            _usedUninitializedProperties = new UsedUninitializedProperties();
             _fileSystem = fileSystem;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties to use.
+        /// Properties may be null.
+        ///
+        /// Used for tests and for ToolsetReader - that operates agnostic on the project
+        ///   - so no logging context is passed, and no BuildCheck analysis will be executed.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
+        : this(properties, fileSystem, null)
+        { }
+
         /// <summary>
         /// Creates an expander passing it some properties to use and the evaluation context.
         /// Properties may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext,
+            LoggingContext loggingContext)
+            : this(properties, loggingContext)
         {
-            _properties = properties;
-            _usedUninitializedProperties = new UsedUninitializedProperties();
             _fileSystem = evaluationContext.FileSystem;
             EvaluationContext = evaluationContext;
         }
@@ -345,8 +362,8 @@ internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationC
         /// Creates an expander passing it some properties and items to use.
         /// Either or both may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFileSystem fileSystem)
-            : this(properties, fileSystem)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, fileSystem, loggingContext)
         {
             _items = items;
         }
@@ -356,45 +373,57 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFile
         /// Creates an expander passing it some properties and items to use, and the evaluation context.
         /// Either or both may be null.
         /// </summary>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext)
-            : this(properties, evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext, LoggingContext loggingContext)
+            : this(properties, evaluationContext, loggingContext)
         {
             _items = items;
         }
 
         /// <summary>
-        /// Initializes a new instance of the <see cref="Expander{P, I}"/> class with the specified property provider, item provider, evaluation context, and logging context.
+        /// Creates an expander passing it some properties, items, and/or metadata to use.
+        /// Any or all may be null.
         /// </summary>
-        /// <param name="properties">The property provider supplying properties for expansion.</param>
-        /// <param name="items">The item provider supplying items for expansion.</param>
-        /// <param name="evaluationContext">The evaluation context used during expansion.</param>
-        /// <param name="loggingContext">The logging context used for logging or emmitting events during expansion.</param>
-        /// <exception cref="ArgumentNullException">Thrown when either <paramref name="properties"/> or <paramref name="evaluationContext"/> is null.</exception>
-        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext, LoggingContext loggingContext)
-            : this(properties, evaluationContext)
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem, LoggingContext loggingContext)
+            : this(properties, items, fileSystem, loggingContext)
         {
-            _items = items;
-            _loggingContext = loggingContext;
+            _metadata = metadata;
         }
 
         /// <summary>
         /// Creates an expander passing it some properties, items, and/or metadata to use.
         /// Any or all may be null.
+        ///
+        /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
+        ///  - BuildCheck analysis won't be executed for those.
+        /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
+        /// 
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMetadataTable metadata, IFileSystem fileSystem)
-            : this(properties, items, fileSystem)
+            : this(properties, items, fileSystem, null)
         {
             _metadata = metadata;
         }
 
+        private Expander(
+            IPropertyProvider<P> properties,
+            IItemProvider<I> items,
+            IMetadataTable metadata,
+            IFileSystem fileSystem,
+            EvaluationContext evaluationContext,
+            LoggingContext loggingContext)
+            : this(properties, items, metadata, fileSystem, loggingContext)
+        {
+            EvaluationContext = evaluationContext;
+        }
+
         /// <summary>
-        /// Whether to warn when we set a property for the first time, after it was previously used.
-        /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.
+        /// Recreates the expander with passed in logging context
         /// </summary>
-        internal bool WarnForUninitializedProperties
+        /// <param name="loggingContext"></param>
+        /// <returns></returns>
+        internal Expander<P, I> WithLoggingContext(LoggingContext loggingContext)
         {
-            get { return _usedUninitializedProperties.Warn; }
-            set { _usedUninitializedProperties.Warn = value; }
+            return new Expander<P, I>(_properties, _items, _metadata, _fileSystem, EvaluationContext, loggingContext);
         }
 
         /// <summary>
@@ -411,10 +440,10 @@ internal IMetadataTable Metadata
         /// If a property is expanded but evaluates to null then it is considered to be un-initialized.
         /// We want to keep track of these properties so that we can warn if the property gets set later on.
         /// </summary>
-        internal UsedUninitializedProperties UsedUninitializedProperties
+        internal PropertiesUseTracker PropertiesUseTracker
         {
-            get { return _usedUninitializedProperties; }
-            set { _usedUninitializedProperties = value; }
+            get { return _propertiesUseTracker; }
+            set { _propertiesUseTracker = value; }
         }
 
         /// <summary>
@@ -443,9 +472,9 @@ internal static bool ExpressionContainsItemVector(string expression)
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
-            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext);
+            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
 
             return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
@@ -457,7 +486,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             if (expression.Length == 0)
             {
@@ -466,8 +495,8 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
-            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, loggingContext);
-            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
+            string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation, _loggingContext);
+            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
@@ -488,7 +517,7 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string metaExpanded = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
+            return PropertyExpander<P>.ExpandPropertiesLeaveTypedAndEscaped(metaExpanded, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
         }
 
         /// <summary>
@@ -497,11 +526,11 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             ErrorUtilities.VerifyThrow((options & ExpanderOptions.BreakOnNotEmpty) == 0, "not supported");
 
-            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext));
+            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation));
         }
 
         /// <summary>
@@ -536,7 +565,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             expression = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
+            expression = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(expression, _properties, options, elementLocation, _propertiesUseTracker, _fileSystem);
             expression = FileUtilities.MaybeAdjustFilePath(expression);
 
             List<T> result = new List<T>();
@@ -1121,9 +1150,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                PropertiesUseTracker propertiesUseTracker,
+                IFileSystem fileSystem)
             {
                 return
                     ConvertToString(
@@ -1132,9 +1160,8 @@ internal static string ExpandPropertiesLeaveEscaped(
                             properties,
                             options,
                             elementLocation,
-                            usedUninitializedProperties,
-                            fileSystem,
-                            loggingContext));
+                            propertiesUseTracker,
+                            fileSystem));
             }
 
             /// <summary>
@@ -1159,9 +1186,8 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                PropertiesUseTracker propertiesUseTracker,
+                IFileSystem fileSystem)
             {
                 if (((options & ExpanderOptions.ExpandProperties) == 0) || String.IsNullOrEmpty(expression))
                 {
@@ -1270,13 +1296,12 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                                 properties,
                                 options,
                                 elementLocation,
-                                usedUninitializedProperties,
-                                fileSystem,
-                                loggingContext);
+                                propertiesUseTracker,
+                                fileSystem);
                         }
                         else // This is a regular property
                         {
-                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties, loggingContext);
+                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, propertiesUseTracker);
                         }
 
                         if (propertyValue != null)
@@ -1319,9 +1344,8 @@ internal static object ExpandPropertyBody(
                 IPropertyProvider<T> properties,
                 ExpanderOptions options,
                 IElementLocation elementLocation,
-                UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext)
+                PropertiesUseTracker propertiesUseTracker,
+                IFileSystem fileSystem)
             {
                 Function<T> function = null;
                 string propertyName = propertyBody;
@@ -1351,9 +1375,9 @@ internal static object ExpandPropertyBody(
                             propertyBody,
                             elementLocation,
                             propertyValue,
-                            usedUninitializedProperties,
+                            propertiesUseTracker,
                             fileSystem,
-                            loggingContext);
+                            propertiesUseTracker.LoggingContext);
 
                         // We may not have been able to parse out a function
                         if (function != null)
@@ -1381,7 +1405,7 @@ internal static object ExpandPropertyBody(
                         }
                         else
                         {
-                            propertyValue = LookupProperty(properties, propertyBody, 0, indexerStart - 1, elementLocation, usedUninitializedProperties);
+                            propertyValue = LookupProperty(properties, propertyBody, 0, indexerStart - 1, elementLocation, propertiesUseTracker);
                             propertyBody = propertyBody.Substring(indexerStart);
 
                             // recurse so that the function representing the indexer can be executed on the property value
@@ -1391,9 +1415,8 @@ internal static object ExpandPropertyBody(
                                 properties,
                                 options,
                                 elementLocation,
-                                usedUninitializedProperties,
-                                fileSystem,
-                                loggingContext);
+                                propertiesUseTracker,
+                                fileSystem);
                         }
                     }
                     else
@@ -1410,7 +1433,7 @@ internal static object ExpandPropertyBody(
                 // doesn't exist in the collection, and we're not executing a static function
                 if (!String.IsNullOrEmpty(propertyName))
                 {
-                    propertyValue = LookupProperty(properties, propertyName, elementLocation, usedUninitializedProperties);
+                    propertyValue = LookupProperty(properties, propertyName, elementLocation, propertiesUseTracker);
                 }
 
                 if (function != null)
@@ -1517,21 +1540,26 @@ internal static string ConvertToString(object valueToConvert)
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, PropertiesUseTracker propertiesUseTracker)
             {
-                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, usedUninitializedProperties);
+                return LookupProperty(properties, propertyName, 0, propertyName.Length - 1, elementLocation, propertiesUseTracker);
             }
 
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, PropertiesUseTracker propertiesUseTracker)
             {
                 T property = properties.GetProperty(propertyName, startIndex, endIndex);
 
                 object propertyValue;
 
-                if (property == null && ((endIndex - startIndex) >= 7) && MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7))
+                bool isArtifical = property == null && ((endIndex - startIndex) >= 7) &&
+                                   MSBuildNameIgnoreCaseComparer.Default.Equals("MSBuild", propertyName, startIndex, 7);
+
+                propertiesUseTracker.TrackRead(propertyName, startIndex, endIndex, elementLocation, property == null, isArtifical);
+                
+                if (isArtifical)
                 {
                     // It could be one of the MSBuildThisFileXXXX properties,
                     // whose values vary according to the file they are in.
@@ -1546,31 +1574,13 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 }
                 else if (property == null)
                 {
-                    // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
-                    //
-                    // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
-                    // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
-                    //
-                    // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
-                    // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
-                    if (usedUninitializedProperties.Warn && usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName != null)
-                    {
-                        // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
-                        if (!MSBuildNameIgnoreCaseComparer.Default.Equals(usedUninitializedProperties.CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
-                        {
-                            usedUninitializedProperties.TryAdd(
-                                propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
-                                elementLocation);
-                        }
-                    }
-
                     propertyValue = String.Empty;
                 }
                 else
                 {
                     if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)
                     {
-                        environmentDerivedProperty.loggingContext = loggingContext;
+                        environmentDerivedProperty.loggingContext = propertiesUseTracker.LoggingContext;
                     }
 
                     propertyValue = property.EvaluatedValueEscaped;
@@ -2755,7 +2765,7 @@ internal static IEnumerable<KeyValuePair<string, S>> ExecuteStringFunction(
                             arguments,
                             BindingFlags.Public | BindingFlags.InvokeMethod,
                             string.Empty,
-                            expander.UsedUninitializedProperties,
+                            expander.PropertiesUseTracker,
                             expander._fileSystem,
                             expander._loggingContext);
 
@@ -3187,7 +3197,7 @@ private struct FunctionBuilder<T>
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
-            public UsedUninitializedProperties UsedUninitializedProperties { get; set; }
+            public PropertiesUseTracker PropertiesUseTracker { get; set; }
 
             internal readonly Function<T> Build()
             {
@@ -3199,7 +3209,7 @@ internal readonly Function<T> Build()
                     Arguments,
                     BindingFlags,
                     Remainder,
-                    UsedUninitializedProperties,
+                    PropertiesUseTracker,
                     FileSystem,
                     LoggingContext);
             }
@@ -3251,7 +3261,7 @@ internal class Function<T>
             /// <summary>
             /// List of properties which have been used but have not been initialized yet.
             /// </summary>
-            private readonly UsedUninitializedProperties _usedUninitializedProperties;
+            private PropertiesUseTracker _propertiesUseTracker;
 
             private readonly IFileSystem _fileSystem;
 
@@ -3268,7 +3278,7 @@ internal Function(
                 string[] arguments,
                 BindingFlags bindingFlags,
                 string remainder,
-                UsedUninitializedProperties usedUninitializedProperties,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem,
                 LoggingContext loggingContext)
             {
@@ -3287,7 +3297,7 @@ internal Function(
                 _receiverType = receiverType;
                 _bindingFlags = bindingFlags;
                 _remainder = remainder;
-                _usedUninitializedProperties = usedUninitializedProperties;
+                _propertiesUseTracker = propertiesUseTracker;
                 _fileSystem = fileSystem;
                 _loggingContext = loggingContext;
             }
@@ -3311,7 +3321,7 @@ internal static Function<T> ExtractPropertyFunction(
                 string expressionFunction,
                 IElementLocation elementLocation,
                 object propertyValue,
-                UsedUninitializedProperties usedUnInitializedProperties,
+                PropertiesUseTracker propertiesUseTracker,
                 IFileSystem fileSystem,
                 LoggingContext loggingContext)
             {
@@ -3335,7 +3345,7 @@ internal static Function<T> ExtractPropertyFunction(
                 ProjectErrorUtilities.VerifyThrowInvalidProject(!expressionRoot.IsEmpty, elementLocation, "InvalidFunctionPropertyExpression", expressionFunction, String.Empty);
 
                 functionBuilder.Expression = expressionFunction;
-                functionBuilder.UsedUninitializedProperties = usedUnInitializedProperties;
+                functionBuilder.PropertiesUseTracker = propertiesUseTracker;
 
                 // This is a static method call
                 // A static method is the content that follows the last "::", the rest being the type
@@ -3487,7 +3497,7 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                             properties,
                             options,
                             elementLocation,
-                            _usedUninitializedProperties,
+                            _propertiesUseTracker,
                             _fileSystem);
 
                         if (argument is string argumentValue)
@@ -3621,9 +3631,8 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
                         properties,
                         options,
                         elementLocation,
-                        _usedUninitializedProperties,
-                        _fileSystem,
-                        _loggingContext);
+                        _propertiesUseTracker,
+                        _fileSystem);
                 }
 
                 // Exceptions coming from the actual function called are wrapped in a TargetInvocationException
@@ -5490,64 +5499,6 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
     }
 
 #nullable enable
-    /// <summary>
-    /// This class wraps information about properties which have been used before they are initialized.
-    /// </summary>
-    internal sealed class UsedUninitializedProperties
-    {
-        /// <summary>
-        /// Lazily allocated collection of properties and the element which used them.
-        /// </summary>
-        private Dictionary<string, IElementLocation>? _properties;
-
-        internal void TryAdd(string propertyName, IElementLocation elementLocation)
-        {
-            if (_properties is null)
-            {
-                _properties = new(StringComparer.OrdinalIgnoreCase);
-            }
-            else if (_properties.ContainsKey(propertyName))
-            {
-                return;
-            }
-
-            _properties.Add(propertyName, elementLocation);
-        }
-
-        internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
-        {
-            if (_properties is null)
-            {
-                elementLocation = null;
-                return false;
-            }
-
-            return _properties.TryGetValue(propertyName, out elementLocation);
-        }
-
-        internal void RemoveProperty(string propertyName)
-        {
-            _properties?.Remove(propertyName);
-        }
-
-        /// <summary>
-        ///  Are we currently supposed to warn if we used an uninitialized property.
-        /// </summary>
-        internal bool Warn
-        {
-            get;
-            set;
-        }
-
-        /// <summary>
-        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
-        /// </summary>
-        internal string? CurrentlyEvaluatingPropertyElementName
-        {
-            get;
-            set;
-        }
-    }
 
     internal static class IntrinsicFunctionOverload
     {
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 4d5b2ea8e98..12d42a71ea9 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -212,7 +213,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Prepares the data block for a new evaluation pass
         /// </summary>
-        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
+        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext);
 
         /// <summary>
         /// Indicates to the data block that evaluation has completed,
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index c45edf0764b..e9b381b5aa1 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -157,23 +157,21 @@ private bool InitReferencedItemsIfNecessary()
         /// <param name="itemSpecLocation">The xml location the itemspec comes from</param>
         /// <param name="projectDirectory">The directory that the project is in.</param>
         /// <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
-        /// <param name="loggingContext">Context in which to log</param>
         public ItemSpec(
             string itemSpec,
             Expander<P, I> expander,
             IElementLocation itemSpecLocation,
             string projectDirectory,
-            bool expandProperties = true,
-            LoggingContext loggingContext = null)
+            bool expandProperties = true)
         {
             ItemSpecString = itemSpec;
             Expander = expander;
             ItemSpecLocation = itemSpecLocation;
 
-            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties, loggingContext);
+            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties);
         }
 
-        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext)
+        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
         {
             // Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
@@ -189,8 +187,7 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                 evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(
                     ItemSpecString,
                     ExpanderOptions.ExpandProperties,
-                    itemSpecLocation,
-                    loggingContext);
+                    itemSpecLocation);
             }
 
             var semicolonCount = 0;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 79cd844c167..248945f74fd 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -291,9 +291,9 @@ public ProjectTargetInstance GetTarget(string targetName)
                 return _wrappedData.GetTarget(targetName);
             }
 
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
             {
-                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext);
+                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext, loggingContext);
             }
 
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index d40ea3145fa..bc35e8ce8b8 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -109,14 +109,14 @@ protected override ImmutableArray<I> SelectItems(OrderedItemDataCollection.Build
                                 MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory ?? string.Empty, glob, string.Join(", ", excludePatternsForGlobs));
                             }
 
-                            using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
+                            using (_lazyEvaluator?._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
                             {
                                 includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
                                     _rootDirectory,
                                     glob,
                                     excludePatternsForGlobs,
                                     fileMatcher: FileMatcher,
-                                    loggingMechanism: _lazyEvaluator._loggingContext,
+                                    loggingMechanism: _lazyEvaluator?._loggingContext,
                                     includeLocation: _itemElement.IncludeLocation,
                                     excludeLocation: _itemElement.ExcludeLocation);
                             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 6bf5b325d63..56d1c41e44e 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -248,7 +248,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                                 continue;
                             }
 
-                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location, _lazyEvaluator._loggingContext);
+                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location);
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index bb298ee7662..4b658abbecf 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -54,7 +54,7 @@ public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> ite
             _outerEvaluatorData = data;
             _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext, loggingContext);
             _evaluatorData = new EvaluatorData(_outerEvaluatorData, _itemLists);
-            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
+            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext, loggingContext);
             _itemFactory = itemFactory;
             _loggingContext = loggingContext;
             _evaluationProfiler = evaluationProfiler;
@@ -90,8 +90,6 @@ private static bool EvaluateCondition(
                     expanderOptions,
                     GetCurrentDirectoryForConditionEvaluation(element, lazyEvaluator),
                     element.ConditionLocation,
-                    lazyEvaluator._loggingContext.LoggingService,
-                    lazyEvaluator._loggingContext.BuildEventContext,
                     lazyEvaluator.FileSystem,
                     loggingContext: lazyEvaluator._loggingContext);
                 MSBuildEventSource.Log.EvaluateConditionStop(condition, result);
@@ -619,7 +617,7 @@ private RemoveOperation BuildRemoveOperation(string rootDirectory, ProjectItemEl
 
         private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder builder)
         {
-            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory, loggingContext: _loggingContext);
+            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory);
 
             foreach (ItemSpecFragment fragment in builder.ItemSpec.Fragments)
             {
@@ -630,7 +628,7 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
             }
         }
 
-        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander, LoggingContext loggingContext = null)
+        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander)
         {
             // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
             // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
@@ -644,8 +642,7 @@ private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(IColle
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Value,
                     expanderOptions,
-                    metadatumElement.Location,
-                    loggingContext);
+                    metadatumElement.Location);
 
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Condition,
@@ -660,7 +657,7 @@ private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBu
             {
                 operationBuilder.Metadata.AddRange(itemElement.Metadata);
 
-                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander, _loggingContext));
+                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander));
                 if (itemsAndMetadataFound.Items != null)
                 {
                     foreach (var itemType in itemsAndMetadataFound.Items)
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 0a910c0a334..143587d96ee 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -273,7 +273,7 @@ internal override ProjectRootElement Get(string projectFile, OpenProjectRootElem
             try
             {
                 // We are about to load. Take a per-file lock to prevent multiple threads from duplicating the work multiple times.
-                object perFileLock = _fileLoadLocks.GetOrAdd(projectFile, () => new object());
+                object perFileLock = _fileLoadLocks.GetOrAdd(projectFile, static _ => new object());
                 lock (perFileLock)
                 {
                     // Call GetOrLoad again, this time with the OpenProjectRootElement callback.
diff --git a/src/Build/Evaluation/PropertiesUseTracker.cs b/src/Build/Evaluation/PropertiesUseTracker.cs
new file mode 100644
index 00000000000..b88423adff1
--- /dev/null
+++ b/src/Build/Evaluation/PropertiesUseTracker.cs
@@ -0,0 +1,158 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics.CodeAnalysis;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+#nullable enable
+
+namespace Microsoft.Build.Evaluation;
+
+/// <summary>
+/// This class tracks reads of properties - so that it can detect uninitialized usages
+///  and so that it can forward the accessing information to further interested consumers (e.g. BuildCheck).
+/// </summary>
+internal sealed class PropertiesUseTracker
+{
+    internal LoggingContext LoggingContext { get; init; }
+
+    public PropertiesUseTracker(LoggingContext loggingContext) => LoggingContext = loggingContext;
+
+    /// <summary>
+    /// Whether to warn when we set a property for the first time, after it was previously used.
+    /// Default is false, unless MSBUILDWARNONUNINITIALIZEDPROPERTY is set.
+    /// </summary>
+    // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
+    private bool _warnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
+
+    /// <summary>
+    /// Lazily allocated collection of properties and the element which used them.
+    /// </summary>
+    private Dictionary<string, IElementLocation>? _properties;
+
+    internal void TrackRead(string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, bool isUninitialized, bool isArtificial)
+    {
+        if (isArtificial || !isUninitialized)
+        {
+            return;
+        }
+
+        // We have evaluated a property to null. We now need to see if we need to add it to the list of properties which are used before they have been initialized
+        //
+        // We also do not want to add the property to the list if the environment variable is not set, also we do not want to add the property to the list if we are currently
+        // evaluating a condition because a common pattern for msbuild projects is to see if the property evaluates to empty and then set a value as this would cause a considerable number of false positives.   <A Condition="'$(A)' == ''">default</A>
+        //
+        // Another pattern used is where a property concatenates with other values,  <a>$(a);something</a> however we do not want to add the a element to the list because again this would make a number of
+        // false positives. Therefore we check to see what element we are currently evaluating and if it is the same as our property we do not add the property to the list.
+
+        // here handle null probably (or otherwise execution)
+        if (_warnForUninitializedProperties && CurrentlyEvaluatingPropertyElementName != null)
+        {
+            // Check to see if the property name does not match the property we are currently evaluating, note the property we are currently evaluating in the element name, this means no $( or )
+            if (!MSBuildNameIgnoreCaseComparer.Default.Equals(CurrentlyEvaluatingPropertyElementName, propertyName, startIndex, endIndex - startIndex + 1))
+            {
+                TryAdd(
+                    propertyName: propertyName.Substring(startIndex, endIndex - startIndex + 1),
+                    elementLocation);
+            }
+        }
+    }
+
+    internal void TryAdd(string propertyName, IElementLocation elementLocation)
+    {
+        if (_properties is null)
+        {
+            _properties = new(StringComparer.OrdinalIgnoreCase);
+        }
+        else if (_properties.ContainsKey(propertyName))
+        {
+            return;
+        }
+
+        _properties.Add(propertyName, elementLocation);
+    }
+
+    internal bool TryGetPropertyElementLocation(string propertyName, [NotNullWhen(returnValue: true)] out IElementLocation? elementLocation)
+    {
+        if (_properties is null)
+        {
+            elementLocation = null;
+            return false;
+        }
+
+        return _properties.TryGetValue(propertyName, out elementLocation);
+    }
+
+    internal void RemoveProperty(string propertyName)
+    {
+        _properties?.Remove(propertyName);
+    }
+
+    /// <summary>
+    ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
+    /// </summary>
+    internal string? CurrentlyEvaluatingPropertyElementName
+    {
+        get;
+        set;
+    }
+
+    internal void CheckPreexistingUndefinedUsage(IPropertyElementWithLocation propertyElement, string evaluatedValue, LoggingContext loggingContext)
+    {
+        // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
+        // during evaluation.
+        if (evaluatedValue.Length > 0 && _warnForUninitializedProperties)
+        {
+            // Is the property we are currently setting in the list of properties which have been used but not initialized
+            IElementLocation? elementWhichUsedProperty;
+            bool isPropertyInList = TryGetPropertyElementLocation(propertyElement.Name, out elementWhichUsedProperty);
+
+            if (isPropertyInList)
+            {
+                // Once we are going to warn for a property once, remove it from the list so we do not add it again.
+                RemoveProperty(propertyElement.Name);
+                loggingContext.LogWarning(null, new BuildEventFileInfo(propertyElement.Location), "UsedUninitializedProperty", propertyElement.Name, elementWhichUsedProperty?.LocationString);
+            }
+        }
+
+        CurrentlyEvaluatingPropertyElementName = null;
+        PropertyReadContext = PropertyReadContext.Other;
+    }
+
+    private PropertyReadContext _propertyReadContext;
+    private PropertyReadContext _previousPropertyReadContext = PropertyReadContext.Other;
+    internal PropertyReadContext PropertyReadContext
+    {
+        private get => _propertyReadContext;
+        set
+        {
+            _previousPropertyReadContext = _propertyReadContext;
+            _propertyReadContext = value;
+        }
+    }
+
+    internal void ResetPropertyReadContext(bool pop = true)
+    {
+        _propertyReadContext = pop ? _previousPropertyReadContext : PropertyReadContext.Other;
+        _previousPropertyReadContext = PropertyReadContext.Other;
+    }
+}
+
+/// <summary>
+/// Type of the context in which a property is read.
+/// </summary>
+internal enum PropertyReadContext
+{
+    // we are not interested in distinguishing the item read etc.
+    Other,
+    ConditionEvaluation,
+    ConditionEvaluationWithOneSideEmpty,
+    PropertyEvaluation,
+    PropertyEvaluationSelf,
+}
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 51117c2d7c1..4b2cd613881 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
@@ -13,8 +14,6 @@
 using Microsoft.Build.Shared;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
-#nullable disable
-
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
@@ -61,7 +60,11 @@ public PropertyTrackingEvaluatorDataWrapper(IEvaluatorData<P, I, M, D> dataToWra
         public P GetProperty(string name)
         {
             P prop = _wrapped.GetProperty(name);
-            this.TrackPropertyRead(name, prop);
+            if (IsPropertyReadTrackingRequested)
+            {
+                this.TrackPropertyRead(name, prop);
+            }
+
             return prop;
         }
 
@@ -72,22 +75,26 @@ public P GetProperty(string name)
         public P GetProperty(string name, int startIndex, int endIndex)
         {
             P prop = _wrapped.GetProperty(name, startIndex, endIndex);
-            this.TrackPropertyRead(name.Substring(startIndex, endIndex - startIndex + 1), prop);
+            if (IsPropertyReadTrackingRequested)
+            {
+                this.TrackPropertyRead(name.Substring(startIndex, endIndex - startIndex + 1), prop);
+            }
+
             return prop;
         }
 
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext? loggingContext = null)
         {
-            P originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, loggingContext);
+            P? originalProperty = _wrapped.GetProperty(name);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, _evaluationLoggingContext);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
-                string.Empty,
+                null,
                 this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable));
 
             return newProperty;
@@ -102,17 +109,18 @@ public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalPro
         /// </summary>
         public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
         {
-            P originalProperty = _wrapped.GetProperty(propertyElement.Name);
+            P? originalProperty = _wrapped.GetProperty(propertyElement.Name);
             P newProperty = _wrapped.SetProperty(propertyElement, evaluatedValueEscaped);
 
             this.TrackPropertyWrite(
                 originalProperty,
                 newProperty,
-                propertyElement.Location.LocationString,
+                propertyElement.Location,
                 PropertySource.Xml);
 
             return newProperty;
         }
+
         #endregion
 
         #region IEvaluatorData<> members that are forwarded directly to wrapped object.
@@ -137,7 +145,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         public IItemDictionary<I> Items => _wrapped.Items;
         public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
         public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
-        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext);
+        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext, loggingContext);
         public void FinishEvaluation() => _wrapped.FinishEvaluation();
         public void AddItem(I item) => _wrapped.AddItem(item);
         public void AddItemIgnoringCondition(I item) => _wrapped.AddItemIgnoringCondition(item);
@@ -155,6 +163,16 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         #endregion
 
         #region Private Methods...
+
+        private bool IsPropertyReadTrackingRequested
+            => IsEnvironmentVariableReadTrackingRequested ||
+               (_settings & PropertyTrackingSetting.UninitializedPropertyRead) ==
+               PropertyTrackingSetting.UninitializedPropertyRead;
+
+        private bool IsEnvironmentVariableReadTrackingRequested
+            => (_settings & PropertyTrackingSetting.EnvironmentVariableRead) ==
+               PropertyTrackingSetting.EnvironmentVariableRead;
+
         /// <summary>
         /// Logic containing what to do when a property is read.
         /// </summary>
@@ -172,7 +190,7 @@ private void TrackPropertyRead(string name, P property)
 
             // If a property matches the name of an environment variable, but has NOT been overwritten by a non-environment-variable property
             // track it as an environment variable read.
-            if (_wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && !_overwrittenEnvironmentVariables.Contains(name))
+            if (IsEnvironmentVariableReadTrackingRequested && _wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && !_overwrittenEnvironmentVariables.Contains(name))
             {
                 this.TrackEnvironmentVariableRead(name);
             }
@@ -220,16 +238,10 @@ private void TrackUninitializedPropertyRead(string name)
             _evaluationLoggingContext.LogBuildEvent(args);
         }
 
-        private void TrackPropertyWrite(P predecessor, P property, string location, PropertySource source)
+        private void TrackPropertyWrite(P? predecessor, P property, IElementLocation? location, PropertySource source)
         {
             string name = property.Name;
 
-            // If this property was an environment variable but no longer is, track it.
-            if (_wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && source != PropertySource.EnvironmentVariable)
-            {
-                _overwrittenEnvironmentVariables.Add(name);
-            }
-
             if (predecessor == null)
             {
                 // If this property had no previous value, then track an initial value.
@@ -238,7 +250,13 @@ private void TrackPropertyWrite(P predecessor, P property, string location, Prop
             else
             {
                 // There was a previous value, and it might have been changed. Track that.
-                TrackPropertyReassignment(predecessor, property, location);
+                TrackPropertyReassignment(predecessor, property, location?.LocationString);
+            }
+
+            // If this property was an environment variable but no longer is, track it.
+            if (IsEnvironmentVariableReadTrackingRequested && _wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && source != PropertySource.EnvironmentVariable)
+            {
+                _overwrittenEnvironmentVariables.Add(name);
             }
         }
 
@@ -270,14 +288,9 @@ private void TrackPropertyInitialValueSet(P property, PropertySource source)
         /// <param name="predecessor">The property's preceding state. Null if none.</param>
         /// <param name="property">The property's current state.</param>
         /// <param name="location">The location of this property's reassignment.</param>
-        private void TrackPropertyReassignment(P predecessor, P property, string location)
+        private void TrackPropertyReassignment(P? predecessor, P property, string? location)
         {
-            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment)
-            {
-                return;
-            }
-
-            if (string.Equals(property.Name, "MSBuildAllProjects", StringComparison.OrdinalIgnoreCase))
+            if (MSBuildNameIgnoreCaseComparer.Default.Equals(property.Name, "MSBuildAllProjects"))
             {
                 // There's a huge perf cost to logging this and it increases the binlog size significantly.
                 // Meanwhile the usefulness of logging this is very low.
@@ -285,21 +298,37 @@ private void TrackPropertyReassignment(P predecessor, P property, string locatio
             }
 
             string newValue = property.EvaluatedValue;
-            string oldValue = predecessor.EvaluatedValue;
+            string? oldValue = predecessor?.EvaluatedValue;
             if (newValue == oldValue)
             {
                 return;
             }
 
-            var args = new PropertyReassignmentEventArgs(
-                property.Name,
-                oldValue,
-                newValue,
-                location,
-                message: null);
-            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
-
-            _evaluationLoggingContext.LogBuildEvent(args);
+            // Either we want to specifically track property reassignments
+            // or we do not want to track nothing - in which case the prop reassignment is enabled by default.
+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) == PropertyTrackingSetting.PropertyReassignment ||
+                (_settings == 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)))
+            {
+                var args = new PropertyReassignmentEventArgs(
+                        property.Name,
+                        oldValue,
+                        newValue,
+                        location,
+                        message: null)
+                    { BuildEventContext = _evaluationLoggingContext.BuildEventContext, };
+
+                _evaluationLoggingContext.LogBuildEvent(args);
+            }
+            else
+            {
+                _evaluationLoggingContext.LogComment(
+                    MessageImportance.Low,
+                    "PropertyReassignment",
+                    property.Name,
+                    newValue,
+                    oldValue,
+                    location);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Instance/IImmutableInstanceProvider.cs b/src/Build/Instance/IImmutableInstanceProvider.cs
index a862a12cf13..4b39fc66288 100644
--- a/src/Build/Instance/IImmutableInstanceProvider.cs
+++ b/src/Build/Instance/IImmutableInstanceProvider.cs
@@ -9,6 +9,19 @@ namespace Microsoft.Build.Execution
     /// <typeparam name="T">The Instance type.</typeparam>
     internal interface IImmutableInstanceProvider<T>
     {
-        T ImmutableInstance { get; set; }
+        /// <summary>
+        /// Gets the Immutable Instance.
+        /// </summary>
+        T ImmutableInstance { get; }
+
+        /// <summary>
+        /// If the ImmutableInstance has not already been set, then this
+        /// method sets the ImmutableInstance to the requested value.
+        /// An already set ImmutableInstance is never replaced.
+        /// </summary>
+        /// <param name="instance">An instance that will be set as the immutable instance, provided that
+        /// the immutable instance has not already been set.</param>
+        /// <returns>The immutable instance, which may or may not be the supplied <paramref name="instance"/>.</returns>
+        T GetOrSetImmutableInstance(T instance);
     }
 }
diff --git a/src/Build/Instance/IPropertyElementWithLocation.cs b/src/Build/Instance/IPropertyElementWithLocation.cs
new file mode 100644
index 00000000000..f77282d9590
--- /dev/null
+++ b/src/Build/Instance/IPropertyElementWithLocation.cs
@@ -0,0 +1,28 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.Construction;
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Represents a xml node in a project file that defines a property.
+    /// </summary>
+    internal interface IPropertyElementWithLocation
+    {
+        /// <summary>
+        /// Name of the property.
+        /// </summary>
+        string Name { get; }
+
+        /// <summary>
+        /// Unevaluated value of the property.
+        /// </summary>
+        string Value { get; }
+
+        /// <summary>
+        /// Location of the property element within build scripts.
+        /// </summary>
+        ElementLocation Location { get; }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
index ae164108704..f15fd45f63e 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableElementCollectionConverter.cs
@@ -6,11 +6,8 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Data;
 using System.Runtime.Serialization;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Instance
@@ -18,20 +15,19 @@ namespace Microsoft.Build.Instance
     /// <summary>
     /// A specialized collection used when element data originates in an immutable Project.
     /// </summary>
-    internal sealed class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
+    internal class ImmutableElementCollectionConverter<TCached, T> : IRetrievableEntryHashSet<T>
         where T : class, IKeyed
     {
-        private readonly IDictionary<string, TCached> _projectElements;
-        private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+        protected readonly IDictionary<string, TCached> _projectElements;
         private readonly ValuesCollection _values;
 
         public ImmutableElementCollectionConverter(
             IDictionary<string, TCached> projectElements,
-            IDictionary<(string, int, int), TCached> constrainedProjectElements)
+            IDictionary<(string, int, int), TCached> constrainedProjectElements,
+            Func<TCached, T> convertElement)
         {
             _projectElements = projectElements;
-            _constrainedProjectElements = constrainedProjectElements;
-            _values = new ValuesCollection(_projectElements, _constrainedProjectElements);
+            _values = new ValuesCollection(_projectElements, constrainedProjectElements, convertElement);
         }
 
         public T this[string key]
@@ -110,13 +106,16 @@ private sealed class ValuesCollection : ICollection<T>
         {
             private readonly IDictionary<string, TCached> _projectElements;
             private readonly IDictionary<(string, int, int), TCached> _constrainedProjectElements;
+            private readonly Func<TCached, T> _getElementInstance;
 
             public ValuesCollection(
                 IDictionary<string, TCached> projectElements,
-                IDictionary<(string, int, int), TCached> constrainedProjectElements)
+                IDictionary<(string, int, int), TCached> constrainedProjectElements,
+                Func<TCached, T> getElementInstance)
             {
                 _projectElements = projectElements;
                 _constrainedProjectElements = constrainedProjectElements;
+                _getElementInstance = getElementInstance;
             }
 
             public int Count => _projectElements.Count;
@@ -155,7 +154,7 @@ public void CopyTo(T[] array, int arrayIndex, int count)
                 int endIndex = arrayIndex + count;
                 foreach (var item in _projectElements.Values)
                 {
-                    array[index] = GetElementInstance(item);
+                    array[index] = _getElementInstance(item);
                     ++index;
                     if (index >= endIndex)
                     {
@@ -171,7 +170,7 @@ public void CopyTo(KeyValuePair<string, T>[] array, int arrayIndex)
                 int index = arrayIndex;
                 foreach (var item in _projectElements.Values)
                 {
-                    var itemInstance = GetElementInstance(item);
+                    var itemInstance = _getElementInstance(item);
                     array[index] = new KeyValuePair<string, T>(itemInstance.Key, itemInstance);
                     ++index;
                 }
@@ -181,7 +180,7 @@ public IEnumerator<T> GetEnumerator()
             {
                 foreach (var item in _projectElements.Values)
                 {
-                    yield return GetElementInstance(item);
+                    yield return _getElementInstance(item);
                 }
             }
 
@@ -189,7 +188,7 @@ public IEnumerator<KeyValuePair<string, T>> GetKvpEnumerator()
             {
                 foreach (var kvp in _projectElements)
                 {
-                    T instance = GetElementInstance(kvp.Value);
+                    T instance = _getElementInstance(kvp.Value);
                     yield return new KeyValuePair<string, T>(kvp.Key, instance);
                 }
             }
@@ -200,7 +199,7 @@ IEnumerator IEnumerable.GetEnumerator()
             {
                 foreach (var item in _projectElements.Values)
                 {
-                    yield return GetElementInstance(item);
+                    yield return _getElementInstance(item);
                 }
             }
 
@@ -208,7 +207,7 @@ public T Get(string key)
             {
                 if (_projectElements.TryGetValue(key, out TCached element))
                 {
-                    return GetElementInstance(element);
+                    return _getElementInstance(element);
                 }
 
                 return null;
@@ -216,9 +215,14 @@ public T Get(string key)
 
             public T Get(string keyString, int startIndex, int length)
             {
+                if (_constrainedProjectElements == null)
+                {
+                    return Get(keyString);
+                }
+
                 if (_constrainedProjectElements.TryGetValue((keyString, startIndex, length), out TCached element))
                 {
-                    return GetElementInstance(element);
+                    return _getElementInstance(element);
                 }
 
                 return null;
@@ -232,19 +236,9 @@ public bool TryGetValue(string key, out T value)
                     return false;
                 }
 
-                value = GetElementInstance(element);
+                value = _getElementInstance(element);
                 return value != null;
             }
-
-            private T GetElementInstance(TCached element)
-            {
-                if (element is IImmutableInstanceProvider<T> instanceProvider)
-                {
-                    return instanceProvider.ImmutableInstance;
-                }
-
-                return null;
-            }
         }
     }
 }
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
new file mode 100644
index 00000000000..b5579adf088
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
@@ -0,0 +1,251 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.CodeDom;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Runtime.Serialization;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
+
+#nullable disable
+
+namespace Microsoft.Build.Instance.ImmutableProjectCollections
+{
+    /// <summary>
+    /// A collection representing the set of Global ProjectPropertyInstance objects.
+    /// </summary>
+    /// <remarks>This class is used only when the containing ProjectInstance originates from an
+    /// immutable linked project source. It's specialized in order to reduce required allocations
+    /// by instead relying on the linked project source's collection of global properties
+    /// (the IDictionary _globalProperties) and the ProjectInstance's collection of all
+    /// properties (the PropertyDictionary _allProperties). When a property is requested,
+    /// _globalProperties is checked to determine whether the named property is actually
+    /// a global property and, if it is, then instance is retrieved from _allProperties.
+    /// </remarks>
+    internal class ImmutableGlobalPropertiesCollectionConverter : IRetrievableEntryHashSet<ProjectPropertyInstance>
+    {
+        private readonly IDictionary<string, string> _globalProperties;
+        private readonly PropertyDictionary<ProjectPropertyInstance> _allProperties;
+        private readonly ValuesCollection _values;
+
+        public ImmutableGlobalPropertiesCollectionConverter(
+            IDictionary<string, string> globalProperties,
+            PropertyDictionary<ProjectPropertyInstance> allProperties)
+        {
+            _globalProperties = globalProperties;
+            _allProperties = allProperties;
+            _values = new ValuesCollection(this);
+        }
+
+        public ProjectPropertyInstance this[string key]
+        {
+            set => throw new NotSupportedException();
+            get
+            {
+                if (_globalProperties.ContainsKey(key))
+                {
+                    return _allProperties[key];
+                }
+
+                return null;
+            }
+        }
+
+        public int Count => _globalProperties.Count;
+
+        public bool IsReadOnly => true;
+
+        public ICollection<string> Keys => _globalProperties.Keys;
+
+        public ICollection<ProjectPropertyInstance> Values => _values;
+
+        public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+        public void Add(string key, ProjectPropertyInstance value) => throw new NotSupportedException();
+
+        public void Add(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public bool Contains(ProjectPropertyInstance item) => _values.Contains(item);
+
+        public bool Contains(KeyValuePair<string, ProjectPropertyInstance> itemKvp) => _values.Contains(itemKvp.Value);
+
+        public bool ContainsKey(string key) => _globalProperties.ContainsKey(key);
+
+        public void CopyTo(ProjectPropertyInstance[] array) => _values.CopyTo(array, arrayIndex: 0);
+
+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex) => _values.CopyTo(array, arrayIndex);
+
+        public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count) => _values.CopyTo(array, arrayIndex, count);
+
+        public void CopyTo(KeyValuePair<string, ProjectPropertyInstance>[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _globalProperties.Count);
+
+            int currentIndex = arrayIndex;
+            foreach (var itemKey in _globalProperties.Keys)
+            {
+                ProjectPropertyInstance instance = _allProperties[itemKey];
+                if (instance != null)
+                {
+                    array[currentIndex] = new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);
+                    ++currentIndex;
+                }
+            }
+        }
+
+        public ProjectPropertyInstance Get(string key)
+        {
+            return this[key];
+        }
+
+        public ProjectPropertyInstance Get(string key, int index, int length)
+        {
+            // The PropertyDictionary containing all of the properties can efficiently
+            // look up the requested property while honoring the specific index and length
+            // constraints. We then just have to verify that it's one of the global properties.
+            ProjectPropertyInstance actualProperty = _allProperties.Get(key, index, length);
+            if (actualProperty != null && _globalProperties.ContainsKey(actualProperty.Name))
+            {
+                return actualProperty;
+            }
+
+            return null;
+        }
+
+        public IEnumerator<ProjectPropertyInstance> GetEnumerator() => _values.GetEnumerator();
+
+        public void GetObjectData(SerializationInfo info, StreamingContext context) => throw new NotSupportedException();
+
+        public void OnDeserialization(object sender) => throw new NotSupportedException();
+
+        public bool Remove(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+        public bool Remove(string key) => throw new NotSupportedException();
+
+        public bool Remove(KeyValuePair<string, ProjectPropertyInstance> item) => throw new NotSupportedException();
+
+        public void TrimExcess()
+        {
+        }
+
+        public bool TryGetValue(string key, out ProjectPropertyInstance value)
+        {
+            ProjectPropertyInstance instance = Get(key);
+            value = instance;
+            return instance != null;
+        }
+
+        public void UnionWith(IEnumerable<ProjectPropertyInstance> other) => throw new NotSupportedException();
+
+        IEnumerator<KeyValuePair<string, ProjectPropertyInstance>> IEnumerable<KeyValuePair<string, ProjectPropertyInstance>>.GetEnumerator()
+        {
+            foreach (var itemKey in _globalProperties.Keys)
+            {
+                ProjectPropertyInstance instance = _allProperties[itemKey];
+                if (instance != null)
+                {
+                    yield return new KeyValuePair<string, ProjectPropertyInstance>(itemKey, instance);
+                }
+            }
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => _values.GetEnumerator();
+
+        private class ValuesCollection : ICollection<ProjectPropertyInstance>
+        {
+            private readonly ImmutableGlobalPropertiesCollectionConverter _parent;
+
+            public ValuesCollection(ImmutableGlobalPropertiesCollectionConverter parent)
+            {
+                _parent = parent;
+            }
+
+            public int Count => _parent._globalProperties.Count;
+
+            public bool IsReadOnly => true;
+
+            public void Add(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+            public void Clear() => throw new NotSupportedException();
+
+            public bool Remove(ProjectPropertyInstance item) => throw new NotSupportedException();
+
+            public bool Contains(ProjectPropertyInstance item)
+            {
+                if (!_parent._globalProperties.ContainsKey(item.Name))
+                {
+                    return false;
+                }
+
+                ProjectPropertyInstance actualInstance = _parent._allProperties[item.Name];
+
+                if (actualInstance == null)
+                {
+                    return false;
+                }
+
+                return actualInstance.Equals(item);
+            }
+
+            public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex)
+            {
+                CopyTo(array, arrayIndex, _parent._globalProperties.Count);
+            }
+
+            public void CopyTo(ProjectPropertyInstance[] array, int arrayIndex, int count)
+            {
+                ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _parent._globalProperties.Count);
+
+                int currentIndex = arrayIndex;
+                int currentCount = 0;
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    if (currentCount >= count)
+                    {
+                        return;
+                    }
+
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        array[currentIndex] = instance;
+                        ++currentIndex;
+                        ++currentCount;
+                    }
+                }
+            }
+
+            public IEnumerator<ProjectPropertyInstance> GetEnumerator()
+            {
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                foreach (var itemKey in _parent._globalProperties.Keys)
+                {
+                    ProjectPropertyInstance instance = _parent._allProperties[itemKey];
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
new file mode 100644
index 00000000000..1a1d499b0aa
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
@@ -0,0 +1,182 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutableItemDefinitionsListConverter<TCached, T> : IList<T>
+        where T : IKeyed
+        where TCached : IKeyed
+    {
+        private readonly IList<TCached>? _itemList;
+        private readonly TCached? _itemTypeDefinition;
+        private readonly Func<TCached, T> _getInstance;
+
+        public ImmutableItemDefinitionsListConverter(
+            IList<TCached>? itemList,
+            TCached? itemTypeDefinition,
+            Func<TCached, T> getInstance)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(getInstance, nameof(getInstance));
+
+            _itemList = itemList;
+            _itemTypeDefinition = itemTypeDefinition;
+            _getInstance = getInstance;
+        }
+
+        public T this[int index]
+        {
+            set => throw new NotSupportedException();
+            get
+            {
+                if (_itemList == null)
+                {
+                    if (index != 0 || _itemTypeDefinition == null)
+                    {
+                        throw new IndexOutOfRangeException();
+                    }
+
+                    return _getInstance(_itemTypeDefinition);
+                }
+
+                if (index > _itemList.Count)
+                {
+                    throw new IndexOutOfRangeException();
+                }
+
+                if (index == _itemList.Count)
+                {
+                    if (_itemTypeDefinition == null)
+                    {
+                        throw new IndexOutOfRangeException();
+                    }
+
+                    return _getInstance(_itemTypeDefinition);
+                }
+
+                return _getInstance(_itemList[index]);
+            }
+        }
+
+        public int Count => (_itemList == null ? 0 : _itemList.Count) + (_itemTypeDefinition == null ? 0 : 1);
+
+        public bool IsReadOnly => true;
+
+        public void Add(T item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public void Insert(int index, T item) => throw new NotSupportedException();
+
+        public bool Remove(T item) => throw new NotSupportedException();
+
+        public void RemoveAt(int index) => throw new NotSupportedException();
+
+        public bool Contains(T item)
+        {
+            return IndexOf(item) >= 0;
+        }
+
+        public void CopyTo(T[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), Count);
+
+            int currentIndex = arrayIndex;
+            void PutItemIntoArray(TCached item)
+            {
+                array[currentIndex] = _getInstance(item);
+                ++currentIndex;
+            }
+
+            if (_itemList != null)
+            {
+                foreach (var item in _itemList)
+                {
+                    PutItemIntoArray(item);
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                PutItemIntoArray(_itemTypeDefinition);
+            }
+        }
+
+        public IEnumerator<T> GetEnumerator() => GetEnumeratorImpl();
+
+        public int IndexOf(T item)
+        {
+            int currentIndex = 0;
+            if (_itemList != null)
+            {
+                foreach (var cachedItem in _itemList)
+                {
+                    if (IsMatchingItem(cachedItem, item))
+                    {
+                        return currentIndex;
+                    }
+
+                    ++currentIndex;
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                if (IsMatchingItem(_itemTypeDefinition, item))
+                {
+                    return currentIndex;
+                }
+            }
+
+            return -1;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator() => GetEnumeratorImpl();
+
+        private bool IsMatchingItem(TCached cachedItem, T item)
+        {
+            if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.Key, item.Key))
+            {
+                T? foundItem = _getInstance(cachedItem);
+                if (foundItem is not null && foundItem.Equals(item))
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        private IEnumerator<T> GetEnumeratorImpl()
+        {
+            if (_itemList != null)
+            {
+                foreach (var item in _itemList)
+                {
+                    T? instance = _getInstance(item);
+                    if (instance != null)
+                    {
+                        yield return instance;
+                    }
+                }
+            }
+
+            if (_itemTypeDefinition != null)
+            {
+                T? instance = _getInstance(_itemTypeDefinition);
+                if (instance != null)
+                {
+                    yield return instance;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
index 74919a57b97..de2d06522ae 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
@@ -19,29 +19,28 @@ namespace Microsoft.Build.Instance
     /// </summary>
     internal sealed class ImmutableItemDictionary<TCached, T> : IItemDictionary<T>
         where T : class, IKeyed, IItem
+        where TCached : IKeyed, IItem
     {
         private readonly IDictionary<string, ICollection<TCached>> _itemsByType;
-        private readonly ICollection<T> _allItems;
-
-        public ImmutableItemDictionary(IDictionary<string, ICollection<TCached>> itemsByType, ICollection<TCached> allItems)
+        private readonly ICollection<TCached> _allCachedItems;
+        private readonly Func<TCached, T?> _getInstance;
+        private readonly Func<T, string?> _getItemType;
+
+        public ImmutableItemDictionary(
+            ICollection<TCached> allItems,
+            IDictionary<string, ICollection<TCached>> itemsByType,
+            Func<TCached, T?> getInstance,
+            Func<T, string?> getItemType)
         {
-            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
-
             if (allItems == null)
             {
                 throw new ArgumentNullException(nameof(allItems));
             }
 
-            var convertedItems = new HashSet<T>(allItems.Count);
-            foreach (var item in allItems)
-            {
-                T? instance = GetInstance(item);
-                if (instance != null)
-                {
-                    convertedItems.Add(instance);
-                }
-            }
-            _allItems = new ReadOnlyCollection<T>(convertedItems);
+            _allCachedItems = allItems;
+            _itemsByType = itemsByType ?? throw new ArgumentNullException(nameof(itemsByType));
+            _getInstance = getInstance;
+            _getItemType = getItemType;
         }
 
         /// <inheritdoc />
@@ -54,12 +53,12 @@ public ICollection<T> this[string itemType]
                     return Array.Empty<T>();
                 }
 
-                return new ListConverter(itemType, _allItems, list);
+                return new ListConverter(itemType, list, _getInstance);
             }
         }
 
         /// <inheritdoc />
-        public int Count => _allItems.Count;
+        public int Count => _allCachedItems.Count;
 
         /// <inheritdoc />
         public ICollection<string> ItemTypes => _itemsByType.Keys;
@@ -77,7 +76,22 @@ public ICollection<T> this[string itemType]
         public void Clear() => throw new NotSupportedException();
 
         /// <inheritdoc />
-        public bool Contains(T projectItem) => _allItems.Contains(projectItem);
+        public bool Contains(T projectItem)
+        {
+            if (projectItem == null)
+            {
+                return false;
+            }
+
+            string? itemType = _getItemType(projectItem);
+            if (itemType == null)
+            {
+                return false;
+            }
+
+            ICollection<T> items = GetItems(itemType);
+            return items.Contains(projectItem);
+        }
 
         /// <inheritdoc />
         public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallback)
@@ -90,31 +104,55 @@ public void EnumerateItemsPerType(Action<string, IEnumerable<T>> itemTypeCallbac
                     continue;
                 }
 
-                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, _allItems, kvp.Value));
+                itemTypeCallback(kvp.Key, new ListConverter(kvp.Key, kvp.Value, _getInstance));
             }
         }
 
         /// <inheritdoc />
         public IEnumerable<TResult> GetCopyOnReadEnumerable<TResult>(Func<T, TResult> selector)
         {
-            foreach (var item in _allItems)
+            foreach (var cachedItem in _allCachedItems)
             {
-                yield return selector(item);
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return selector(item);
+                }
             }
         }
 
         /// <inheritdoc />
-        public IEnumerator<T> GetEnumerator() => _allItems.GetEnumerator();
+        public IEnumerator<T> GetEnumerator()
+        {
+            foreach (var cachedItem in _allCachedItems)
+            {
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return item;
+                }
+            }
+        }
 
         /// <inheritdoc />
-        IEnumerator IEnumerable.GetEnumerator() => _allItems.GetEnumerator();
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            foreach (var cachedItem in _allCachedItems)
+            {
+                T? item = _getInstance(cachedItem);
+                if (item is not null)
+                {
+                    yield return item;
+                }
+            }
+        }
 
         /// <inheritdoc />
         public ICollection<T> GetItems(string itemType)
         {
             if (_itemsByType.TryGetValue(itemType, out ICollection<TCached>? items))
             {
-                return new ListConverter(itemType, _allItems, items);
+                return new ListConverter(itemType, items, _getInstance);
             }
 
             return Array.Empty<T>();
@@ -138,27 +176,17 @@ public ICollection<T> GetItems(string itemType)
         /// <inheritdoc />
         public void Replace(T existingItem, T newItem) => throw new NotSupportedException();
 
-        private static T? GetInstance(TCached item)
-        {
-            if (item is IImmutableInstanceProvider<T> instanceProvider)
-            {
-                return instanceProvider.ImmutableInstance;
-            }
-
-            return null;
-        }
-
         private sealed class ListConverter : ICollection<T>
         {
             private readonly string _itemType;
-            private readonly ICollection<T> _allItems;
             private readonly ICollection<TCached> _list;
+            private readonly Func<TCached, T?> _getInstance;
 
-            public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCached> list)
+            public ListConverter(string itemType, ICollection<TCached> list, Func<TCached, T?> getInstance)
             {
                 _itemType = itemType;
-                _allItems = allItems;
                 _list = list;
+                _getInstance = getInstance;
             }
 
             public int Count => _list.Count;
@@ -173,8 +201,20 @@ public ListConverter(string itemType, ICollection<T> allItems, ICollection<TCach
 
             public bool Contains(T item)
             {
-                return MSBuildNameIgnoreCaseComparer.Default.Equals(item.Key, _itemType) &&
-                       _allItems.Contains(item);
+                return _list.Any(
+                    cachedItem =>
+                    {
+                        if (MSBuildNameIgnoreCaseComparer.Default.Equals(cachedItem.EvaluatedIncludeEscaped, item.EvaluatedIncludeEscaped))
+                        {
+                            T? foundItem = _getInstance(cachedItem);
+                            if (foundItem is not null && foundItem.Equals(item))
+                            {
+                                return true;
+                            }
+                        }
+
+                        return false;
+                    });
             }
 
             public void CopyTo(T[] array, int arrayIndex)
@@ -184,7 +224,7 @@ public void CopyTo(T[] array, int arrayIndex)
                 int currentIndex = arrayIndex;
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         array[currentIndex] = instance;
@@ -197,7 +237,7 @@ public IEnumerator<T> GetEnumerator()
             {
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         yield return instance;
@@ -209,7 +249,7 @@ IEnumerator IEnumerable.GetEnumerator()
             {
                 foreach (var item in _list)
                 {
-                    T? instance = GetInstance(item);
+                    T? instance = _getInstance(item);
                     if (instance != null)
                     {
                         yield return instance;
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
new file mode 100644
index 00000000000..1b11db2341a
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+
+namespace Microsoft.Build.Instance.ImmutableProjectCollections
+{
+    internal class ImmutableLinkedMultiDictionaryConverter<K, VCached, V> : IMultiDictionary<K, V>
+        where K : class
+        where V : class
+        where VCached : class
+    {
+        private readonly Func<K, IEnumerable<VCached>> _getCachedValues;
+        private readonly Func<VCached, V> _getInstance;
+
+        public ImmutableLinkedMultiDictionaryConverter(Func<K, IEnumerable<VCached>> getCachedValues, Func<VCached, V> getInstance)
+        {
+            _getCachedValues = getCachedValues;
+            _getInstance = getInstance;
+        }
+
+        public IEnumerable<V> this[K key]
+        {
+            get
+            {
+                IEnumerable<VCached> cachedValues = _getCachedValues(key);
+                if (cachedValues != null)
+                {
+                    foreach (var cachedValue in cachedValues)
+                    {
+                        yield return _getInstance(cachedValue);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
new file mode 100644
index 00000000000..27610c71543
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
@@ -0,0 +1,72 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutablePropertyCollectionConverter<TCached, T> : ImmutableElementCollectionConverter<TCached, T>, ICopyOnWritePropertyDictionary<T>
+        where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
+        where TCached : class, IValued, IEquatable<TCached>
+    {
+        public ImmutablePropertyCollectionConverter(IDictionary<string, TCached> properties, Func<TCached, T> convertProperty)
+            : base(properties, constrainedProjectElements: null, convertProperty)
+        {
+        }
+
+        public bool Contains(string name) => ContainsKey(name);
+
+        public string? GetEscapedValue(string name)
+        {
+            if (_projectElements.TryGetValue(name, out TCached? value))
+            {
+                return value?.EscapedValue;
+            }
+
+            return null;
+        }
+
+        public ICopyOnWritePropertyDictionary<T> DeepClone() => this;
+
+        public void ImportProperties(IEnumerable<T> other) => throw new NotSupportedException();
+
+        public void Set(T projectProperty) => throw new NotSupportedException();
+
+        public bool Equals(ICopyOnWritePropertyDictionary<T>? other)
+        {
+            if (other == null || Count != other.Count)
+            {
+                return false;
+            }
+
+            if (other is ImmutablePropertyCollectionConverter<TCached, T> otherImmutableDict)
+            {
+                // When comparing to another CollectionConverter we compare the TCached values
+                // in order to avoid causing the instantiation of each T instance.
+                foreach (var propKvp in _projectElements)
+                {
+                    if (!otherImmutableDict._projectElements.TryGetValue(propKvp.Key, out TCached? otherProperty) ||
+                        !EqualityComparer<TCached>.Default.Equals(propKvp.Value, otherProperty))
+                    {
+                        return false;
+                    }
+                }
+            }
+            else
+            {
+                foreach (T thisProp in Values)
+                {
+                    if (!other.TryGetValue(thisProp.Key, out T? thatProp) ||
+                        !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs
new file mode 100644
index 00000000000..89e12f7c0a1
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableStringValuedListConverter.cs
@@ -0,0 +1,99 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Instance
+{
+    internal class ImmutableStringValuedListConverter<T> : IList<string>, IReadOnlyList<string>
+    {
+        private readonly IList<T> _itemList;
+        private readonly Func<T, string> _getStringValue;
+
+        public ImmutableStringValuedListConverter(IList<T> itemList, Func<T, string> getStringValue)
+        {
+            _itemList = itemList;
+            _getStringValue = getStringValue;
+        }
+
+        public string this[int index]
+        {
+            set => throw new NotSupportedException();
+            get => _getStringValue(_itemList[index]);
+        }
+
+        public int Count => _itemList.Count;
+
+        public bool IsReadOnly => true;
+
+        public void Add(string item) => throw new NotSupportedException();
+
+        public void Clear() => throw new NotSupportedException();
+
+        public void Insert(int index, string item) => throw new NotSupportedException();
+
+        public bool Remove(string item) => throw new NotSupportedException();
+
+        public void RemoveAt(int index) => throw new NotSupportedException();
+
+        public bool Contains(string item)
+        {
+            return IndexOf(item) >= 0;
+        }
+
+        public void CopyTo(string[] array, int arrayIndex)
+        {
+            ErrorUtilities.VerifyCollectionCopyToArguments(array, nameof(array), arrayIndex, nameof(arrayIndex), _itemList.Count);
+
+            int currentIndex = arrayIndex;
+            foreach (var item in _itemList)
+            {
+                array[currentIndex] = _getStringValue(item);
+                ++currentIndex;
+            }
+        }
+
+        public IEnumerator<string> GetEnumerator()
+        {
+            foreach (var item in _itemList)
+            {
+                string? stringValue = _getStringValue(item);
+                if (stringValue != null)
+                {
+                    yield return stringValue;
+                }
+            }
+        }
+
+        public int IndexOf(string item)
+        {
+            for (int i = 0; i < _itemList.Count; ++i)
+            {
+                T cachedItem = _itemList[i];
+                string stringValue = _getStringValue(cachedItem);
+                if (MSBuildNameIgnoreCaseComparer.Default.Equals(stringValue, item))
+                {
+                    return i;
+                }
+            }
+
+            return -1;
+        }
+
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            foreach (var item in _itemList)
+            {
+                string? instance = _getStringValue(item);
+                if (instance != null)
+                {
+                    yield return instance;
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs
new file mode 100644
index 00000000000..5477ba57c28
--- /dev/null
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableValuedElementCollectionConverter.cs
@@ -0,0 +1,37 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Collections;
+
+namespace Microsoft.Build.Instance
+{
+    /// <inheritdoc />
+    internal sealed class ImmutableValuedElementCollectionConverter<TCached, T> : ImmutableElementCollectionConverter<TCached, T>, IRetrievableValuedEntryHashSet<T>
+        where T : class, IKeyed, IValued
+        where TCached : IValued
+    {
+        public ImmutableValuedElementCollectionConverter(
+            IDictionary<string, TCached> projectElements,
+            IDictionary<(string, int, int), TCached> constrainedProjectElements,
+            Func<TCached, T> convertElement)
+            : base(projectElements, constrainedProjectElements, convertElement)
+        {
+        }
+
+        public bool TryGetEscapedValue(string key, out string escapedValue)
+        {
+            if (_projectElements.TryGetValue(key, out TCached value) && value != null)
+            {
+                escapedValue = value.EscapedValue;
+                return true;
+            }
+
+            escapedValue = null;
+            return false;
+        }
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 32a408a5ca4..1c3be29274f 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Experimental.BuildCheck.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
@@ -22,6 +23,7 @@
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Instance;
+using Microsoft.Build.Instance.ImmutableProjectCollections;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -92,9 +94,9 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
 
         private List<string> _initialTargets;
 
-        private List<string> _importPaths;
+        private IList<string> _importPaths;
 
-        private List<string> _importPathsIncludingDuplicates;
+        private IList<string> _importPathsIncludingDuplicates;
 
         /// <summary>
         /// The global properties evaluation occurred with.
@@ -131,7 +133,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// <summary>
         /// Items organized by evaluatedInclude value
         /// </summary>
-        private MultiDictionary<string, ProjectItemInstance> _itemsByEvaluatedInclude;
+        private IMultiDictionary<string, ProjectItemInstance> _itemsByEvaluatedInclude;
 
         /// <summary>
         /// The project's root directory, for evaluation of relative paths and
@@ -434,41 +436,41 @@ private ProjectInstance(Project linkedProject, bool fastItemLookupNeeded)
             EvaluationId = linkedProject.EvaluationCounter;
 
             // ProjectProperties
-            InitializeImmutableProjectPropertyInstances(linkedProject.Properties);
-            var projectPropertiesConverter = GetImmutableElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(linkedProject.Properties);
-            _properties = new PropertyDictionary<ProjectPropertyInstance>(projectPropertiesConverter);
+            _properties = GetImmutablePropertyDictionaryFromImmutableProject(linkedProject);
 
             // ProjectItemDefinitions
-            InitializeImmutableProjectItemDefinitionInstances(linkedProject.ItemDefinitions);
-            _itemDefinitions = GetImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(linkedProject.ItemDefinitions);
+            _itemDefinitions = GetImmutableItemDefinitionsHashSetFromImmutableProject(linkedProject);
 
             // ProjectItems
-            InitializeImmutableProjectItemInstances(linkedProject.Items);
-            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
-            _items = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(itemsByType, linkedProject.Items);
+            _items = GetImmutableItemsDictionaryFromImmutableProject(linkedProject, this);
 
             // ItemsByEvaluatedInclude
             if (fastItemLookupNeeded)
             {
-                _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
-                foreach (var item in linkedProject.Items)
-                {
-                    if (item is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
-                    {
-                        _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, immutableInstanceProvider.ImmutableInstance);
-                    }
-                }
+                _itemsByEvaluatedInclude = new ImmutableLinkedMultiDictionaryConverter<string, ProjectItem, ProjectItemInstance>(
+                                                linkedProject.GetItemsByEvaluatedInclude,
+                                                item => ConvertCachedProjectItemToInstance(linkedProject, this, item));
             }
 
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(linkedProject.GlobalPropertiesCount);
-            foreach (var property in linkedProject.GlobalPropertiesEnumerable)
-            {
-                _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
-            }
+            // GlobalProperties
+            var globalPropertiesRetrievableHashSet = new ImmutableGlobalPropertiesCollectionConverter(linkedProject.GlobalProperties, _properties);
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(globalPropertiesRetrievableHashSet);
+
+            // EnvironmentVariableProperties
+            _environmentVariableProperties = linkedProject.ProjectCollection.SharedReadOnlyEnvironmentProperties;
 
-            CreateEnvironmentVariablePropertiesSnapshot(linkedProject.ProjectCollection.EnvironmentProperties);
-            CreateTargetsSnapshot(linkedProject.Targets, null, null, null, null);
-            CreateImportsSnapshot(linkedProject.Imports, linkedProject.ImportsIncludingDuplicates);
+            // Targets
+            _targets = linkedProject.Targets;
+            InitializeTargetsData(null, null, null, null);
+
+            // Imports
+            var importsListConverter = new ImmutableStringValuedListConverter<ResolvedImport>(linkedProject.Imports, GetImportFullPath);
+            _importPaths = importsListConverter;
+            ImportPaths = importsListConverter;
+
+            importsListConverter = new ImmutableStringValuedListConverter<ResolvedImport>(linkedProject.ImportsIncludingDuplicates, GetImportFullPath);
+            _importPathsIncludingDuplicates = importsListConverter;
+            ImportPathsIncludingDuplicates = importsListConverter;
 
             Toolset = linkedProject.ProjectCollection.GetToolset(linkedProject.ToolsVersion);
             SubToolsetVersion = linkedProject.SubToolsetVersion;
@@ -549,9 +551,9 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
             this.TaskRegistry = projectToInheritFrom.TaskRegistry;
             _isImmutable = projectToInheritFrom._isImmutable;
             _importPaths = projectToInheritFrom._importPaths;
-            ImportPaths = _importPaths.AsReadOnly();
+            ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
             _importPathsIncludingDuplicates = projectToInheritFrom._importPathsIncludingDuplicates;
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
@@ -753,9 +755,9 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                 _itemDefinitions = that._itemDefinitions;
                 _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
                 _importPaths = that._importPaths;
-                ImportPaths = _importPaths.AsReadOnly();
+                ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
                 _importPathsIncludingDuplicates = that._importPathsIncludingDuplicates;
-                ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+                ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
 
                 this.EvaluatedItemElements = that.EvaluatedItemElements;
 
@@ -898,9 +900,145 @@ public static ProjectInstance FromImmutableProjectSource(Project project, Projec
             return new ProjectInstance(project, fastItemLookupNeeded);
         }
 
-        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
-            ICollection<TCached> elementsCollection)
-            where T : class, IKeyed
+        private static IRetrievableEntryHashSet<ProjectItemDefinitionInstance> GetImmutableItemDefinitionsHashSetFromImmutableProject(Project linkedProject)
+        {
+            IDictionary<string, ProjectItemDefinition> linkedProjectItemDefinitions = linkedProject.ItemDefinitions;
+            VerifyCollectionImplementsRequiredDictionaryInterfaces(
+                linkedProjectItemDefinitions,
+                out IDictionary<string, ProjectItemDefinition> elementsDictionary,
+                out IDictionary<(string, int, int), ProjectItemDefinition> constrainedElementsDictionary);
+
+            var hashSet = new ImmutableElementCollectionConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(
+                                elementsDictionary,
+                                constrainedElementsDictionary,
+                                ConvertCachedItemDefinitionToInstance);
+
+            return hashSet;
+        }
+
+        private static ImmutableItemDictionary<ProjectItem, ProjectItemInstance> GetImmutableItemsDictionaryFromImmutableProject(
+            Project linkedProject,
+            ProjectInstance owningProjectInstance)
+        {
+            var itemsByType = linkedProject.Items as IDictionary<string, ICollection<ProjectItem>>;
+            if (itemsByType == null)
+            {
+                throw new ArgumentException(nameof(linkedProject));
+            }
+
+            Func<ProjectItem, ProjectItemInstance> convertCachedItemToInstance =
+                projectItem => ConvertCachedProjectItemToInstance(linkedProject, owningProjectInstance, projectItem);
+
+            var itemDictionary = new ImmutableItemDictionary<ProjectItem, ProjectItemInstance>(
+                linkedProject.Items,
+                itemsByType,
+                convertCachedItemToInstance,
+                projectItemInstance => projectItemInstance.ItemType);
+
+            return itemDictionary;
+        }
+
+        private static ProjectItemInstance ConvertCachedProjectItemToInstance(
+            Project linkedProject,
+            ProjectInstance owningProjectInstance,
+            ProjectItem projectItem)
+        {
+            ProjectItemInstance result = null;
+            if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    var newInstance = InstantiateProjectItemInstanceFromImmutableProjectSource(
+                        linkedProject,
+                        owningProjectInstance,
+                        projectItem);
+
+                    result = instanceProvider.GetOrSetImmutableInstance(newInstance);
+                }
+            }
+
+            return result;
+        }
+
+        private static ProjectItemDefinitionInstance ConvertCachedItemDefinitionToInstance(ProjectItemDefinition projectItemDefinition)
+        {
+            ProjectItemDefinitionInstance result = null;
+
+            if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    IDictionary<string, ProjectMetadataInstance> metadata = null;
+                    if (projectItemDefinition.Metadata is IDictionary<string, ProjectMetadata> linkedMetadataDict)
+                    {
+                        metadata = new ImmutableElementCollectionConverter<ProjectMetadata, ProjectMetadataInstance>(
+                                        linkedMetadataDict,
+                                        constrainedProjectElements: null,
+                                        ConvertCachedProjectMetadataToInstance);
+                    }
+
+                    result = instanceProvider.GetOrSetImmutableInstance(
+                        new ProjectItemDefinitionInstance(projectItemDefinition.ItemType, metadata));
+                }
+            }
+
+            return result;
+        }
+
+        private static ProjectMetadataInstance ConvertCachedProjectMetadataToInstance(ProjectMetadata projectMetadata)
+        {
+            ProjectMetadataInstance result = null;
+
+            if (projectMetadata is IImmutableInstanceProvider<ProjectMetadataInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    result = instanceProvider.GetOrSetImmutableInstance(new ProjectMetadataInstance(projectMetadata));
+                }
+            }
+
+            return result;
+        }
+
+        private static PropertyDictionary<ProjectPropertyInstance> GetImmutablePropertyDictionaryFromImmutableProject(Project linkedProject)
+        {
+            ICollection<ProjectProperty> linkedProjectProperties = linkedProject.Properties;
+            VerifyCollectionImplementsRequiredDictionaryInterfaces(
+                linkedProjectProperties,
+                out IDictionary<string, ProjectProperty> elementsDictionary,
+                out IDictionary<(string, int, int), ProjectProperty> constrainedElementsDictionary);
+
+            var hashSet = new ImmutableValuedElementCollectionConverter<ProjectProperty, ProjectPropertyInstance>(
+                                elementsDictionary,
+                                constrainedElementsDictionary,
+                                ConvertCachedPropertyToInstance);
+
+            return new PropertyDictionary<ProjectPropertyInstance>(hashSet);
+        }
+
+        private static ProjectPropertyInstance ConvertCachedPropertyToInstance(ProjectProperty property)
+        {
+            ProjectPropertyInstance result = null;
+
+            if (property is IImmutableInstanceProvider<ProjectPropertyInstance> instanceProvider)
+            {
+                result = instanceProvider.ImmutableInstance;
+                if (result == null)
+                {
+                    result = instanceProvider.GetOrSetImmutableInstance(InstantiateProjectPropertyInstance(property, isImmutable: true));
+                }
+            }
+
+            return result;
+        }
+
+        private static void VerifyCollectionImplementsRequiredDictionaryInterfaces<TCached>(
+            object elementsCollection,
+            out IDictionary<string, TCached> elementsDictionary,
+            out IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
         {
             // The elementsCollection we receive here is implemented in CPS as a special collection
             // that is both IDictionary<string, TCached> and also IDictionary<(string, int, int), TCached>.
@@ -911,25 +1049,14 @@ private static ImmutableElementCollectionConverter<TCached, T> GetImmutableEleme
             // represents the elementsCollection as an IRetrievableEntryHashSet<T>.
             // That IRetrievableEntryHashSet is then used either directly or as a backing source for
             // another collection wrapper (e.g. PropertyDictionary).
-            if (elementsCollection is not IDictionary<string, TCached> elementsDictionary ||
-                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
+            if (elementsCollection is not IDictionary<string, TCached> elementsDict ||
+                elementsCollection is not IDictionary<(string, int, int), TCached> constrainedElementsDict)
             {
                 throw new ArgumentException(nameof(elementsCollection));
             }
 
-            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
-        }
-
-        private static ImmutableElementCollectionConverter<TCached, T> GetImmutableElementCollectionConverter<TCached, T>(
-            IDictionary<string, TCached> elementsDictionary)
-            where T : class, IKeyed
-        {
-            if (elementsDictionary is not IDictionary<(string, int, int), TCached> constrainedElementsDictionary)
-            {
-                throw new ArgumentException(nameof(elementsDictionary));
-            }
-
-            return new ImmutableElementCollectionConverter<TCached, T>(elementsDictionary, constrainedElementsDictionary);
+            elementsDictionary = elementsDict;
+            constrainedElementsDictionary = constrainedElementsDict;
         }
 
         /// <summary>
@@ -1556,7 +1683,7 @@ ICollection<ProjectItemInstance> IItemProvider<ProjectItemInstance>.GetItems(str
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
         void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.
-            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
+            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext, LoggingContext loggingContext)
         {
             // All been done in the constructor.  We don't allow re-evaluation of project instances.
         }
@@ -1764,10 +1891,12 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         /// </remarks>
         public string GetPropertyValue(string name)
         {
-            ProjectPropertyInstance property = _properties[name];
-            string value = (property == null) ? String.Empty : property.EvaluatedValue;
+            if (!_properties.TryGetPropertyUnescapedValue(name, out string unescapedValue))
+            {
+                unescapedValue = String.Empty;
+            }
 
-            return value;
+            return unescapedValue;
         }
 
         /// <summary>
@@ -2089,7 +2218,7 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<Fo
         /// </comment>
         public string ExpandString(string unexpandedValue)
         {
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default, _loggingContext);
 
             string result = expander.ExpandIntoStringAndUnescape(unexpandedValue, ExpanderOptions.ExpandPropertiesAndItems, ProjectFileLocation);
 
@@ -2107,7 +2236,7 @@ public string ExpandString(string unexpandedValue)
         /// </comment>
         public bool EvaluateCondition(string condition)
         {
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default);
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(this, this, FileSystems.Default, _loggingContext);
 
             bool result = ConditionEvaluator.EvaluateCondition(
                 condition,
@@ -2116,9 +2245,8 @@ public bool EvaluateCondition(string condition)
                 ExpanderOptions.ExpandPropertiesAndItems,
                 Directory,
                 ProjectFileLocation,
-                null /* no logging service */,
-                BuildEventContext.Invalid,
-                FileSystems.Default);
+                FileSystems.Default,
+                null /* no logging context */);
 
             return result;
         }
@@ -2859,28 +2987,6 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
             }
         }
 
-        private static void InitializeImmutableProjectItemDefinitionInstances(IDictionary<string, ProjectItemDefinition> projectItemDefinitions)
-        {
-            foreach (var projectItemDefinition in projectItemDefinitions.Values)
-            {
-                if (projectItemDefinition is IImmutableInstanceProvider<ProjectItemDefinitionInstance> immutableInstanceProvider)
-                {
-                    immutableInstanceProvider.ImmutableInstance = new ProjectItemDefinitionInstance(projectItemDefinition);
-                }
-            }
-        }
-
-        private static void InitializeImmutableProjectPropertyInstances(ICollection<ProjectProperty> projectProperties)
-        {
-            foreach (var projectProperty in projectProperties)
-            {
-                if (projectProperty is IImmutableInstanceProvider<ProjectPropertyInstance> immutableInstanceProvider)
-                {
-                    immutableInstanceProvider.ImmutableInstance = InstantiateProjectPropertyInstance(projectProperty, isImmutable: true);
-                }
-            }
-        }
-
         private static ProjectPropertyInstance InstantiateProjectPropertyInstance(ProjectProperty property, bool isImmutable)
         {
             // Allow reserved property names, since this is how they are added to the project instance.
@@ -2894,6 +3000,12 @@ private static ProjectPropertyInstance InstantiateProjectPropertyInstance(Projec
             return instance;
         }
 
+        /// <summary>
+        /// Logging context - set during the evaluation.
+        /// Can be null - especially if the project was fetched from the cache.
+        /// </summary>
+        private LoggingContext _loggingContext;
+
         /// <summary>
         /// Common code for the constructors that evaluate directly.
         /// Global properties may be null.
@@ -2926,15 +3038,15 @@ private void Initialize(
             _actualTargets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
             _targets = new ObjectModel.ReadOnlyDictionary<string, ProjectTargetInstance>(_actualTargets);
             _importPaths = new List<string>();
-            ImportPaths = _importPaths.AsReadOnly();
+            ImportPaths = new ObjectModel.ReadOnlyCollection<string>(_importPaths);
             _importPathsIncludingDuplicates = new List<string>();
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            ImportPathsIncludingDuplicates = new ObjectModel.ReadOnlyCollection<string>(_importPathsIncludingDuplicates);
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>((globalProperties == null) ? 0 : globalProperties.Count);
             _environmentVariableProperties = buildParameters.EnvironmentPropertiesInternal;
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
             _hostServices = buildParameters.HostServices;
             this.ProjectRootElementCache = buildParameters.ProjectRootElementCache;
-
+            _loggingContext = new AnalyzerLoggingContext(loggingService, buildEventContext);
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
             _explicitToolsVersionSpecified = (explicitToolsVersion != null);
@@ -3045,8 +3157,16 @@ private void CreateTargetsSnapshot(
             // ProjectTargetInstances are immutable so only the dictionary must be cloned
             _targets = CreateCloneDictionary(targets);
 
-            this.DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
-            this.InitialTargets = defaultTargets == null ? new List<string>(0) : new List<string>(initialTargets);
+            InitializeTargetsData(defaultTargets, initialTargets, beforeTargets, afterTargets);
+        }
+
+        private void InitializeTargetsData(List<string> defaultTargets,
+            List<string> initialTargets,
+            IDictionary<string, List<TargetSpecification>> beforeTargets,
+            IDictionary<string, List<TargetSpecification>> afterTargets)
+        {
+            DefaultTargets = defaultTargets == null ? new List<string>(0) : new List<string>(defaultTargets);
+            InitialTargets = initialTargets == null ? new List<string>(0) : new List<string>(initialTargets);
             ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(beforeTargets, StringComparer.OrdinalIgnoreCase);
             ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(afterTargets, StringComparer.OrdinalIgnoreCase);
         }
@@ -3056,29 +3176,31 @@ private void CreateTargetsSnapshot(
         /// </summary>
         private void CreateImportsSnapshot(IList<ResolvedImport> importClosure, IList<ResolvedImport> importClosureWithDuplicates)
         {
-            _importPaths = new List<string>(Math.Max(0, importClosure.Count - 1) /* outer project */);
+            var importPaths = new List<string>(Math.Max(0, importClosure.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosure)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
                 {
-                    _importPaths.Add(resolvedImport.ImportedProject.FullPath);
+                    importPaths.Add(resolvedImport.ImportedProject.FullPath);
                 }
             }
 
-            ImportPaths = _importPaths.AsReadOnly();
+            _importPaths = importPaths;
+            ImportPaths = importPaths.AsReadOnly();
 
-            _importPathsIncludingDuplicates = new List<string>(Math.Max(0, importClosureWithDuplicates.Count - 1) /* outer project */);
+            var importPathsIncludingDuplicates = new List<string>(Math.Max(0, importClosureWithDuplicates.Count - 1) /* outer project */);
             foreach (var resolvedImport in importClosureWithDuplicates)
             {
                 // Exclude outer project itself
                 if (resolvedImport.ImportingElement != null)
                 {
-                    _importPathsIncludingDuplicates.Add(resolvedImport.ImportedProject.FullPath);
+                    importPathsIncludingDuplicates.Add(resolvedImport.ImportedProject.FullPath);
                 }
             }
 
-            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+            _importPathsIncludingDuplicates = importPathsIncludingDuplicates;
+            ImportPathsIncludingDuplicates = importPathsIncludingDuplicates.AsReadOnly();
         }
 
         /// <summary>
@@ -3117,11 +3239,13 @@ private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache,
                 return;
             }
 
-            _itemsByEvaluatedInclude = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
+            var multiDictionary = new MultiDictionary<string, ProjectItemInstance>(StringComparer.OrdinalIgnoreCase);
             foreach (var item in items)
             {
-                _itemsByEvaluatedInclude.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
+                multiDictionary.Add(item.EvaluatedInclude, projectItemToInstanceMap[item]);
             }
+
+            _itemsByEvaluatedInclude = multiDictionary;
         }
 
         /// <summary>
@@ -3143,22 +3267,9 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollec
             return projectItemToInstanceMap;
         }
 
-        private void InitializeImmutableProjectItemInstances(ICollection<ProjectItem> projectItems)
-        {
-            foreach (var projectItem in projectItems)
-            {
-                if (projectItem is IImmutableInstanceProvider<ProjectItemInstance> immutableInstanceProvider)
-                {
-                    ProjectItemInstance instance = InstantiateProjectItemInstance(projectItem);
-                    immutableInstanceProvider.ImmutableInstance = instance;
-                }
-            }
-        }
-
         private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
         {
             List<ProjectItemDefinitionInstance> inheritedItemDefinitions = null;
-
             if (item.InheritedItemDefinitions != null)
             {
                 inheritedItemDefinitions = new List<ProjectItemDefinitionInstance>(item.InheritedItemDefinitions.Count);
@@ -3172,7 +3283,6 @@ private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
             }
 
             CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
-
             if (item.DirectMetadata != null)
             {
                 directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
@@ -3181,16 +3291,87 @@ private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
                 directMetadata.ImportProperties(projectMetadataInstances);
             }
 
+            GetEvaluatedIncludesFromProjectItem(
+                item,
+                out string evaluatedIncludeEscaped,
+                out string evaluatedIncludeBeforeWildcardExpansionEscaped);
+
+            var instance = new ProjectItemInstance(
+                this,
+                item.ItemType,
+                evaluatedIncludeEscaped,
+                evaluatedIncludeBeforeWildcardExpansionEscaped,
+                directMetadata,
+                inheritedItemDefinitions,
+                item.Xml.ContainingProject.EscapedFullPath,
+                useItemDefinitionsWithoutModification: false);
+
+            return instance;
+        }
+
+        private static void GetEvaluatedIncludesFromProjectItem(
+            ProjectItem item,
+            out string evaluatedIncludeEscaped,
+            out string evaluatedIncludeBeforeWildcardExpansionEscaped)
+        {
             // For externally constructed ProjectItem, fall back to the publicly available EvaluateInclude
-            var evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
+            evaluatedIncludeEscaped = ((IItem)item).EvaluatedIncludeEscaped;
             evaluatedIncludeEscaped ??= item.EvaluatedInclude;
-            var evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
+            evaluatedIncludeBeforeWildcardExpansionEscaped = item.EvaluatedIncludeBeforeWildcardExpansionEscaped;
             evaluatedIncludeBeforeWildcardExpansionEscaped ??= item.EvaluatedInclude;
+        }
+
+        private static ProjectItemInstance InstantiateProjectItemInstanceFromImmutableProjectSource(
+            Project linkedProject,
+            ProjectInstance projectInstance,
+            ProjectItem item)
+        {
+            linkedProject.ItemDefinitions.TryGetValue(item.ItemType, out ProjectItemDefinition itemTypeDefinition);
+
+            IList<ProjectItemDefinitionInstance> inheritedItemDefinitions =
+                new ImmutableItemDefinitionsListConverter<ProjectItemDefinition, ProjectItemDefinitionInstance>(
+                    item.InheritedItemDefinitions,
+                    itemTypeDefinition,
+                    ConvertCachedItemDefinitionToInstance);
 
-            ProjectItemInstance instance = new ProjectItemInstance(this, item.ItemType, evaluatedIncludeEscaped, evaluatedIncludeBeforeWildcardExpansionEscaped, directMetadata, inheritedItemDefinitions, item.Xml.ContainingProject.EscapedFullPath);
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
+            if (item.DirectMetadata is not null)
+            {
+                if (item.DirectMetadata is IDictionary<string, ProjectMetadata> metadataDict)
+                {
+                    directMetadata = new ImmutablePropertyCollectionConverter<ProjectMetadata, ProjectMetadataInstance>(metadataDict, ConvertCachedProjectMetadataToInstance);
+                }
+                else
+                {
+                    directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+
+                    IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
+                    directMetadata.ImportProperties(projectMetadataInstances);
+                }
+            }
+
+            GetEvaluatedIncludesFromProjectItem(
+                item,
+                out string evaluatedIncludeEscaped,
+                out string evaluatedIncludeBeforeWildcardExpansionEscaped);
+
+            ProjectItemInstance instance = new ProjectItemInstance(
+                projectInstance,
+                item.ItemType,
+                evaluatedIncludeEscaped,
+                evaluatedIncludeBeforeWildcardExpansionEscaped,
+                directMetadata,
+                inheritedItemDefinitions,
+                item.Xml.ContainingProject.EscapedFullPath,
+                useItemDefinitionsWithoutModification: true);
             return instance;
         }
 
+        private static string GetImportFullPath(ResolvedImport import)
+        {
+            return import.ImportedProject.FullPath;
+        }
+
         /// <summary>
         /// Create ItemDefinitions snapshot
         /// </summary>
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index fa41b3882ec..2051107c8bd 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Instance;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -31,9 +32,8 @@ public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefini
         /// <summary>
         /// Collection of metadata that link the XML metadata and instance metadata
         /// Since evaluation has occurred, this is an unordered collection.
-        /// Is never null or empty.
         /// </summary>
-        private CopyOnWritePropertyDictionary<ProjectMetadataInstance> _metadata;
+        private IDictionary<string, ProjectMetadataInstance> _metadata;
 
         /// <summary>
         /// Constructs an empty project item definition instance.
@@ -58,13 +58,25 @@ internal ProjectItemDefinitionInstance(ProjectItemDefinition itemDefinition)
         {
             if (itemDefinition.MetadataCount > 0)
             {
-                _metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-
+                var copyOnWriteMetadataDictionary = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                 IEnumerable<ProjectMetadataInstance> projectMetadataInstances = itemDefinition.Metadata.Select(originalMetadata => new ProjectMetadataInstance(originalMetadata));
-                _metadata.ImportProperties(projectMetadataInstances);
+                copyOnWriteMetadataDictionary.ImportProperties(projectMetadataInstances);
+
+                _metadata = copyOnWriteMetadataDictionary;
             }
         }
 
+        /// <summary>
+        /// Initializes a new instance of the <see cref="ProjectItemDefinitionInstance"/> class.
+        /// </summary>
+        /// <param name="itemType">The type of item this definition object represents.</param>
+        /// <param name="metadata">A (possibly null) collection of the metadata associated with this item definition.</param>
+        internal ProjectItemDefinitionInstance(string itemType, IDictionary<string, ProjectMetadataInstance> metadata)
+            : this(itemType)
+        {
+            _metadata = metadata;
+        }
+
         private ProjectItemDefinitionInstance()
         {
         }
@@ -95,7 +107,7 @@ public ICollection<ProjectMetadataInstance> Metadata
                     return ReadOnlyEmptyCollection<ProjectMetadataInstance>.Instance;
                 }
 
-                return new ReadOnlyCollection<ProjectMetadataInstance>(_metadata);
+                return new ReadOnlyCollection<ProjectMetadataInstance>(_metadata.Values);
             }
         }
 
@@ -110,21 +122,7 @@ public int MetadataCount
         /// <summary>
         /// Names of all metadata on this item definition
         /// </summary>
-        public IEnumerable<string> MetadataNames
-        {
-            get
-            {
-                if (_metadata == null)
-                {
-                    yield break;
-                }
-
-                foreach (ProjectMetadataInstance metadatum in _metadata)
-                {
-                    yield return metadatum.Name;
-                }
-            }
-        }
+        public IEnumerable<string> MetadataNames => _metadata == null ? Enumerable.Empty<string>() : _metadata.Keys;
 
         /// <summary>
         /// Implementation of IKeyed exposing the item type, so these
@@ -213,8 +211,9 @@ internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElem
         {
             ProjectItemDefinitionElement element = parent.ContainingProject.CreateItemDefinitionElement(ItemType);
             parent.AppendChild(element);
-            foreach (ProjectMetadataInstance metadataInstance in _metadata)
+            foreach (var kvp in _metadata)
             {
+                ProjectMetadataInstance metadataInstance = kvp.Value;
                 element.AddMetadata(metadataInstance.Name, metadataInstance.EvaluatedValue);
             }
 
@@ -224,7 +223,7 @@ internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElem
         void ITranslatable.Translate(ITranslator translator)
         {
             translator.Translate(ref _itemType);
-            translator.TranslateDictionary(ref _metadata, ProjectMetadataInstance.FactoryForDeserialization);
+            translator.TranslateDictionary(ref _metadata, ProjectMetadataInstance.FactoryForDeserialization, CreateMetadataCollection);
         }
 
         internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITranslator translator)
@@ -236,5 +235,10 @@ internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITransla
         }
 
         string IItemTypeDefinition.ItemType => _itemType;
+
+        private static IDictionary<string, ProjectMetadataInstance> CreateMetadataCollection(int capacity)
+        {
+            return new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+        }
     }
 }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index cf6fc186770..5769a0fa12e 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -77,7 +77,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// Mutability follows the project.
         /// </summary>
         internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, string definingFileEscaped)
-            : this(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, null /* no direct metadata */, null /* need to add item definition metadata */, definingFileEscaped)
+            : this(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, null /* no direct metadata */, null /* need to add item definition metadata */, definingFileEscaped, useItemDefinitionsWithoutModification: false)
         {
         }
 
@@ -94,9 +94,17 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// <remarks>
         /// Not public since the only creation scenario is setting on a project.
         /// </remarks>
-        internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata, List<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped)
+        internal ProjectItemInstance(
+            ProjectInstance project,
+            string itemType,
+            string includeEscaped,
+            string includeBeforeWildcardExpansionEscaped,
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+            IList<ProjectItemDefinitionInstance> itemDefinitions,
+            string definingFileEscaped,
+            bool useItemDefinitionsWithoutModification)
         {
-            CommonConstructor(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, directMetadata, itemDefinitions, definingFileEscaped);
+            CommonConstructor(project, itemType, includeEscaped, includeBeforeWildcardExpansionEscaped, directMetadata, itemDefinitions, definingFileEscaped, useItemDefinitionsWithoutModification);
         }
 
         /// <summary>
@@ -121,7 +129,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
                 metadata.ImportProperties(directMetadataInstances);
             }
 
-            CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped);
+            CommonConstructor(project, itemType, includeEscaped, includeEscaped, metadata, null /* need to add item definition metadata */, definingFileEscaped, useItemDefinitionsWithoutModification: false);
         }
 
         /// <summary>
@@ -615,7 +623,7 @@ internal static ProjectItemInstance FactoryForDeserialization(ITranslator transl
         /// Add a metadata with the specified names and values.
         /// Overwrites any metadata with the same name already in the collection.
         /// </summary>
-        internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataDictionary)
+        internal void SetMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataDictionary)
         {
             _project.VerifyThrowNotImmutable();
 
@@ -682,33 +690,53 @@ internal ProjectItemElement ToProjectItemElement(ProjectElementContainer parent)
         /// Inherited item definition metadata may be null. It is assumed to ALREADY HAVE BEEN CLONED.
         /// Mutability follows the project.
         /// </summary>
-        private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUse, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata, List<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped)
+        private void CommonConstructor(
+            ProjectInstance projectToUse,
+            string itemTypeToUse,
+            string includeEscaped,
+            string includeBeforeWildcardExpansionEscaped,
+            ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+            IList<ProjectItemDefinitionInstance> itemDefinitions,
+            string definingFileEscaped,
+            bool useItemDefinitionsWithoutModification)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectToUse, "project");
             ErrorUtilities.VerifyThrowArgumentLength(itemTypeToUse, "itemType");
             XmlUtilities.VerifyThrowArgumentValidElementName(itemTypeToUse);
             ErrorUtilities.VerifyThrowArgument(!XMakeElements.ReservedItemNames.Contains(itemTypeToUse), "OM_ReservedName", itemTypeToUse);
 
-            // TaskItems don't have an item type. So for their benefit, we have to lookup and add the regular item definition.
-            List<ProjectItemDefinitionInstance> inheritedItemDefinitions = (itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(itemDefinitions);
+            IList<ProjectItemDefinitionInstance> inheritedItemDefinitions;
+            if (itemDefinitions == null || !useItemDefinitionsWithoutModification)
+            {
+                // TaskItems don't have an item type. So for their benefit, we have to lookup and add the regular item definition.
+                inheritedItemDefinitions = (itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(itemDefinitions);
 
-            ProjectItemDefinitionInstance itemDefinition;
-            if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
+                ProjectItemDefinitionInstance itemDefinition;
+                if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
+                {
+                    inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
+                    inheritedItemDefinitions.Add(itemDefinition);
+                }
+            }
+            else
             {
-                inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
-                inheritedItemDefinitions.Add(itemDefinition);
+                // In this case the caller specifying useItemDefinitionsWithoutModification is guaranteeing that
+                // the itemDefinitions collection contains all necessary definitions (including the definition
+                // associated with itemTypeToUse) and, for performance reasons, the provided (immutable) collection
+                // should be used as is.
+                inheritedItemDefinitions = itemDefinitions;
             }
 
             _project = projectToUse;
             _itemType = itemTypeToUse;
             _taskItem = new TaskItem(
-                                        includeEscaped,
-                                        includeBeforeWildcardExpansionEscaped,
-                                        directMetadata?.DeepClone(), // copy on write!
-                                        inheritedItemDefinitions,
-                                        _project.Directory,
-                                        _project.IsImmutable,
-                                        definingFileEscaped);
+                            includeEscaped,
+                            includeBeforeWildcardExpansionEscaped,
+                            directMetadata?.DeepClone(), // copy on write!
+                            inheritedItemDefinitions,
+                            _project.Directory,
+                            _project.IsImmutable,
+                            definingFileEscaped);
         }
 
         /// <summary>
@@ -751,7 +779,7 @@ internal sealed class TaskItem :
             /// Lazily created, as there are huge numbers of items generated in
             /// a build that have no metadata at all.
             /// </remarks>
-            private CopyOnWritePropertyDictionary<ProjectMetadataInstance> _directMetadata;
+            private ICopyOnWritePropertyDictionary<ProjectMetadataInstance> _directMetadata;
 
             /// <summary>
             /// Cached value of the fullpath metadata. All other metadata are computed on demand.
@@ -765,7 +793,7 @@ internal sealed class TaskItem :
             /// be item definitions inherited from items that were
             /// used to create this item.
             /// </summary>
-            private List<ProjectItemDefinitionInstance> _itemDefinitions;
+            private IList<ProjectItemDefinitionInstance> _itemDefinitions;
 
             /// <summary>
             /// Directory of the associated project. If this is available,
@@ -794,8 +822,8 @@ internal TaskItem(string includeEscaped, string definingFileEscaped)
             internal TaskItem(
                               string includeEscaped,
                               string includeBeforeWildcardExpansionEscaped,
-                              CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
-                              List<ProjectItemDefinitionInstance> itemDefinitions,
+                              ICopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata,
+                              IList<ProjectItemDefinitionInstance> itemDefinitions,
                               string projectDirectory,
                               bool immutable,
                               string definingFileEscaped) // the actual project file (or import) that defines this item.
@@ -909,11 +937,11 @@ public ICollection MetadataNames
             {
                 get
                 {
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
+                    ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
 
                     List<string> names = new List<string>(capacity: metadataCollection.Count + FileUtilities.ItemSpecModifiers.All.Length);
 
-                    foreach (ProjectMetadataInstance metadatum in metadataCollection)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadataCollection)
                     {
                         names.Add(metadatum.Name);
                     }
@@ -1058,11 +1086,11 @@ public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
             /// </summary>
             /// <param name="list">The source list to return metadata from.</param>
             /// <returns>An array of string key-value pairs representing metadata.</returns>
-            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
                 var result = new List<KeyValuePair<string, string>>(list.Count);
 
-                foreach (var projectMetadataInstance in list)
+                foreach (var projectMetadataInstance in list.Values)
                 {
                     if (projectMetadataInstance != null)
                     {
@@ -1074,9 +1102,9 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(CopyOnW
                 return result.ToArray();
             }
 
-            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+            private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
-                foreach (var projectMetadataInstance in list)
+                foreach (var projectMetadataInstance in list.Values)
                 {
                     if (projectMetadataInstance != null)
                     {
@@ -1093,7 +1121,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(CopyOnWriteP
             /// This is a read-only collection. To modify the metadata, use <see cref="SetMetadata(string, string)"/>.
             /// Computed, not necessarily fast.
             /// </summary>
-            internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollection
+            internal ICopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollection
             {
                 get
                 {
@@ -1137,7 +1165,7 @@ IEnumerable<ProjectMetadataInstance> metaData()
                         // Finally any direct metadata win.
                         if (_directMetadata != null)
                         {
-                            foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                            foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)_directMetadata)
                             {
                                 if (metadatum != null)
                                 {
@@ -1287,16 +1315,16 @@ public string GetMetadataEscaped(string metadataName)
                     ErrorUtilities.VerifyThrowArgumentLength(metadataName, nameof(metadataName));
                 }
 
-                ProjectMetadataInstance metadatum;
                 if (_directMetadata != null)
                 {
-                    metadatum = _directMetadata[metadataName];
-                    if (metadatum != null)
+                    string escapedValue = _directMetadata.GetEscapedValue(metadataName);
+                    if (escapedValue != null)
                     {
-                        return metadatum.EvaluatedValueEscaped;
+                        return escapedValue;
                     }
                 }
 
+                ProjectMetadataInstance metadatum;
                 metadatum = GetItemDefinitionMetadata(metadataName);
 
                 if (metadatum != null && Expander<ProjectProperty, ProjectItem>.ExpressionMayContainExpandableExpressions(metadatum.EvaluatedValueEscaped))
@@ -1404,7 +1432,10 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                     }
                     else if (_itemDefinitions != null)
                     {
-                        destinationAsTaskItem._itemDefinitions.AddRange(_itemDefinitions);
+                        foreach (var itemDefinition in _itemDefinitions)
+                        {
+                            destinationAsTaskItem._itemDefinitions.Add(itemDefinition);
+                        }
                     }
                 }
                 else if (destinationItem is IMetadataContainer destinationItemAsMetadataContainer)
@@ -1428,7 +1459,7 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                 else
                 {
                     // OK, most likely the destination item was a Microsoft.Build.Utilities.TaskItem.
-                    foreach (ProjectMetadataInstance metadatum in MetadataCollection)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)MetadataCollection)
                     {
                         // When copying metadata, we do NOT overwrite metadata already on the destination item.
                         string destinationValue = destinationItem.GetMetadata(metadatum.Name);
@@ -1460,7 +1491,7 @@ public IDictionary CloneCustomMetadata()
                 var metadata = MetadataCollection;
                 Dictionary<string, string> clonedMetadata = new Dictionary<string, string>(metadata.Count, MSBuildNameIgnoreCaseComparer.Default);
 
-                foreach (ProjectMetadataInstance metadatum in metadata)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadata)
                 {
                     clonedMetadata[metadatum.Name] = metadatum.EvaluatedValue;
                 }
@@ -1477,7 +1508,7 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
             {
                 Dictionary<string, string> clonedMetadata = new Dictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
 
-                foreach (ProjectMetadataInstance metadatum in MetadataCollection)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)MetadataCollection)
                 {
                     clonedMetadata[metadatum.Name] = metadatum.EvaluatedValueEscaped;
                 }
@@ -1501,8 +1532,17 @@ void ITranslatable.Translate(ITranslator translator)
                 translator.Translate(ref _isImmutable);
                 translator.Translate(ref _definingFileEscaped);
 
-                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
-                translator.TranslateDictionary(ref _directMetadata, ProjectMetadataInstance.FactoryForDeserialization);
+                TranslatorHelpers.Translate(
+                    translator,
+                    ref _itemDefinitions,
+                    ProjectItemDefinitionInstance.FactoryForDeserialization,
+                    (capacity) => new List<ProjectItemDefinitionInstance>(capacity));
+
+                TranslatorHelpers.TranslateDictionary(
+                    translator,
+                    ref _directMetadata,
+                    ProjectMetadataInstance.FactoryForDeserialization,
+                    (capacity) => new CopyOnWritePropertyDictionary<ProjectMetadataInstance>());
 
                 if (_itemDefinitions?.Count == 0)
                 {
@@ -1580,7 +1620,8 @@ public bool Equals(TaskItem other)
                 // the set of metadata names on 'this', to avoid computing the full metadata collection
                 // of both 'this' and 'other'. Once we have the names for 'this', we enumerate 'other'
                 // and ensure the names we see there are set-equal to the names we produce here.
-                var thisNames = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                int capacity = _itemDefinitions?.Count ?? 0 + _directMetadata?.Count ?? 0;
+                var thisNames = new HashSet<string>(capacity, MSBuildNameIgnoreCaseComparer.Default);
 
                 if (_itemDefinitions is not null)
                 {
@@ -1592,20 +1633,20 @@ public bool Equals(TaskItem other)
 
                 if (_directMetadata is not null)
                 {
-                    foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)_directMetadata)
                     {
                         thisNames.Add(metadatum.Name);
                     }
                 }
 
-                CopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
+                ICopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
 
                 if (otherMetadata.Count != thisNames.Count)
                 {
                     return false;
                 }
 
-                foreach (ProjectMetadataInstance metadatum in otherMetadata)
+                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)otherMetadata)
                 {
                     string name = metadatum.Name;
 
@@ -1702,7 +1743,11 @@ private void ReadInternString(ITranslator translator, LookasideStringInterner in
             /// </summary>
             internal void TranslateWithInterning(ITranslator translator, LookasideStringInterner interner)
             {
-                translator.Translate(ref _itemDefinitions, ProjectItemDefinitionInstance.FactoryForDeserialization);
+                TranslatorHelpers.Translate(
+                    translator,
+                    ref _itemDefinitions,
+                    ProjectItemDefinitionInstance.FactoryForDeserialization,
+                    (capacity) => new List<ProjectItemDefinitionInstance>(capacity));
                 translator.Translate(ref _isImmutable);
                 translator.Translate(ref _includeEscaped);
 
@@ -1711,14 +1756,14 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                     WriteInternString(translator, interner, ref _includeBeforeWildcardExpansionEscaped);
                     WriteInternString(translator, interner, ref _definingFileEscaped);
 
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
+                    ICopyOnWritePropertyDictionary<ProjectMetadataInstance> temp = MetadataCollection;
 
                     // Intern the metadata
                     if (translator.TranslateNullable(temp))
                     {
                         int count = temp.Count;
                         translator.Writer.Write(count);
-                        foreach (ProjectMetadataInstance metadatum in temp)
+                        foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)temp)
                         {
                             int key = interner.Intern(metadatum.Name);
                             int value = interner.Intern(metadatum.EvaluatedValueEscaped);
@@ -1779,7 +1824,7 @@ internal ProjectMetadataInstance GetMetadataObject(string name)
             /// Add a metadata with the specified name and value.
             /// Overwrites any metadata with the same name already in the collection.
             /// </summary>
-            internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata)
+            internal void SetMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata)
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
@@ -2051,7 +2096,7 @@ private ProjectItemInstance CreateItem(string includeEscaped, string includeBefo
                         itemDefinitionsClone.Add(sourceItemDefinition);
                     }
 
-                    return new ProjectItemInstance(_project, ItemType, includeEscaped, includeBeforeWildcardExpansionEscaped, source._taskItem._directMetadata, itemDefinitionsClone, definingProject);
+                    return new ProjectItemInstance(_project, ItemType, includeEscaped, includeBeforeWildcardExpansionEscaped, source._taskItem._directMetadata, itemDefinitionsClone, definingProject, useItemDefinitionsWithoutModification: false);
                 }
             }
 
diff --git a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
index 6eb9b3f1972..5ce7695e734 100644
--- a/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyGroupTaskPropertyInstance.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Execution
     /// Immutable.
     /// </summary>
     [DebuggerDisplay("{_name}={Value} Condition={_condition}")]
-    public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable
+    public class ProjectPropertyGroupTaskPropertyInstance : ITranslatable, IPropertyElementWithLocation
     {
         /// <summary>
         /// Name of the property
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 5b65829e926..598819b3cd4 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -11,6 +11,7 @@
 using System.Reflection;
 using System.Threading;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
@@ -249,8 +250,7 @@ internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskReg
         /// <typeparam name="P">A type derived from IProperty</typeparam>
         /// <typeparam name="I">A type derived from IItem</typeparam>
         internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
-            ILoggingService loggingService,
-            BuildEventContext buildEventContext,
+            LoggingContext loggingContext,
             IEnumerable<(ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile)> registrations,
             TaskRegistry taskRegistry,
             Expander<P, I> expander,
@@ -262,8 +262,7 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
             foreach ((ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile) registration in registrations)
             {
                 RegisterTasksFromUsingTaskElement(
-                    loggingService,
-                    buildEventContext,
+                    loggingContext,
                     registration.directoryOfImportingFile,
                     registration.projectUsingTaskXml,
                     taskRegistry,
@@ -284,8 +283,7 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
         /// <typeparam name="I">A type derived from IItem</typeparam>
         private static void RegisterTasksFromUsingTaskElement
             <P, I>(
-            ILoggingService loggingService,
-            BuildEventContext buildEventContext,
+            LoggingContext loggingContext,
             string directoryOfImportingFile,
             ProjectUsingTaskElement projectUsingTaskXml,
             TaskRegistry taskRegistry,
@@ -307,9 +305,8 @@ private static void RegisterTasksFromUsingTaskElement
                     expanderOptions,
                     projectUsingTaskXml.ContainingProject.DirectoryPath,
                     projectUsingTaskXml.ConditionLocation,
-                    loggingService,
-                    buildEventContext,
-                    fileSystem))
+                    fileSystem,
+                    loggingContext))
             {
                 return;
             }
@@ -444,7 +441,7 @@ private static void RegisterTasksFromUsingTaskElement
                 taskFactoryParameters.Add(XMakeAttributes.architecture, architecture == String.Empty ? XMakeAttributes.MSBuildArchitectureValues.any : architecture);
             }
 
-            taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingService, buildEventContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
+            taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
         }
 
         private static Dictionary<string, string> CreateTaskFactoryParametersDictionary(int? initialCount = null)
@@ -547,7 +544,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // Try the override task registry first
             if (_toolset != null)
             {
-                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext, RootElementCache);
+                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext, RootElementCache);
                 taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
             }
 
@@ -606,7 +603,7 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             // If we didn't find the task but we have a fallback registry in the toolset state, try that one.
             if (taskRecord == null && _toolset != null)
             {
-                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext, RootElementCache);
+                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext, RootElementCache);
                 taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
             }
 
@@ -687,8 +684,7 @@ private void RegisterTask(
             string taskFactory,
             Dictionary<string, string> taskFactoryParameters,
             RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord,
-            ILoggingService loggingService,
-            BuildEventContext context,
+            LoggingContext loggingContext,
             ProjectUsingTaskElement projectUsingTaskInXml,
             bool overrideTask = false)
         {
@@ -733,7 +729,7 @@ private void RegisterTask(
                     {
                         if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))
                         {
-                            loggingService.LogError(context, null, new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
+                            loggingContext.LogError(new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
                             break;
                         }
                     }
@@ -745,7 +741,7 @@ private void RegisterTask(
                     List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();
                     unqualifiedTaskNameMatches.Add(newRecord);
                     _overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);
-                    loggingService.LogComment(context, MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
+                    loggingContext.LogComment(MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
                 }
             }
 
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index a7b005a1925..d4c37461938 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -71,6 +71,8 @@ public sealed class BinaryLogger : ILogger
         //   - GeneratedFileUsedEventArgs exposed for brief period of time (so let's continue with 20)
         // version 20:
         //   - TaskStartedEventArgs: Added TaskAssemblyLocation property
+        // version 21:
+        //   - TaskParameterEventArgs: Added ParameterName and PropertyName properties
 
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
@@ -78,7 +80,7 @@ public sealed class BinaryLogger : ILogger
 
         // The current version of the binary log representation.
         // Changes with each update of the binary log format.
-        internal const int FileFormatVersion = 20;
+        internal const int FileFormatVersion = 21;
 
         // The minimum version of the binary log reader that can read log of above version.
         // This should be changed only when the binary log format is changed in a way that would prevent it from being
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 03ce7bed76c..358c410265f 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -1022,10 +1022,15 @@ private BuildEventArgs ReadTaskParameterEventArgs()
             var kind = (TaskParameterMessageKind)ReadInt32();
             var itemType = ReadDeduplicatedString();
             var items = ReadTaskItemList() as IList;
+            var (parameterName, propertyName) = _fileFormatVersion >= 21
+                ? (ReadDeduplicatedString(), ReadDeduplicatedString())
+                : (null, null);
 
             var e = ItemGroupLoggingHelper.CreateTaskParameterEventArgs(
                 fields.BuildEventContext,
                 kind,
+                parameterName,
+                propertyName,
                 itemType,
                 items,
                 logItemMetadata: true,
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index dd6fe2c9e2b..e86902ae882 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -572,6 +572,8 @@ private BinaryLogRecordKind Write(TaskParameterEventArgs e)
             Write((int)e.Kind);
             WriteDeduplicatedString(e.ItemType);
             WriteTaskItemList(e.Items, e.LogItemMetadata);
+            WriteDeduplicatedString(e.ParameterName);
+            WriteDeduplicatedString(e.PropertyName);
             if (e.Kind == TaskParameterMessageKind.AddItem
                || e.Kind == TaskParameterMessageKind.TaskOutput)
             {
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index fe0d399962e..d1f5cb0dd29 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -30,10 +30,7 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
-
-    <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
-    <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
 
@@ -50,6 +47,8 @@
     <PackageReference Include="System.Memory" />
     <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Json" />
+    <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Threading.Tasks.Dataflow" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
@@ -167,6 +166,10 @@
     <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManager.cs" />
     <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManagerProvider.cs" />
     <Compile Include="BuildCheck\Infrastructure\TracingReporter.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigFile.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigGlobsMatcher.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigParser.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationErrorScope.cs" />
     <Compile Include="BuildCheck\OM\BuildCheckDataContext.cs" />
     <Compile Include="BuildCheck\API\BuildAnalyzer.cs" />
     <Compile Include="BuildCheck\API\BuildAnalyzerConfiguration.cs" />
@@ -191,6 +194,7 @@
     <Compile Include="BuildCheck\Utilities\Constants.cs" />
     <Compile Include="BuildCheck\Utilities\EnumerableExtensions.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
+    <Compile Include="Evaluation\PropertiesUseTracker.cs" />
     <Compile Include="FileAccess\DesiredAccess.cs" />
     <Compile Include="FileAccess\FileAccessData.cs" />
     <Compile Include="FileAccess\FlagsAndAttributes.cs" />
@@ -199,6 +203,7 @@
     <Compile Include="FileAccess\RequestedAccess.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContext.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContextFactory.cs" />
+    <Compile Include="Instance\IPropertyElementWithLocation.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -279,14 +284,6 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResultFactory.cs" />
     <Compile Include="BackEnd\Node\LoggingNodeConfiguration.cs" />
     <Compile Include="BackEnd\Shared\ConfigurationMetadata.cs" />
-    <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
-    <Compile Include="Collections\ConcurrentStackExtensions.cs" />
-    <Compile Include="Collections\LookasideStringInterner.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSet.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
     <Compile Include="Construction\ImplicitImportLocation.cs" />
     <Compile Include="Construction\ProjectSdkElement.cs" />
     <Compile Include="Definition\ProjectOptions.cs" />
@@ -396,6 +393,9 @@
     <Compile Include="BackEnd\TaskExecutionHost\TaskExecutionHost.cs" />
     <!-- #### COLLECTIONS ### -->
     <Compile Include="..\Shared\CollectionHelpers.cs" />
+    <Compile Include="Collections\ArrayDictionary.cs" />
+    <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
+    <Compile Include="Collections\ConcurrentStackExtensions.cs" />
     <Compile Include="Collections\ConvertingEnumerable.cs" />
     <Compile Include="Collections\CopyOnReadEnumerable.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
@@ -405,17 +405,25 @@
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="Collections\HashTableUtility.cs" />
     <Compile Include="Collections\IConstrainableDictionary.cs" />
+    <Compile Include="Collections\ICopyOnWritePropertyDictionary.cs" />
     <Compile Include="Collections\IItemDictionary.cs" />
+    <Compile Include="Collections\IMultiDictionary.cs" />
     <Compile Include="Collections\ItemDictionary.cs" />
     <Compile Include="Collections\IImmutable.cs" />
     <Compile Include="Collections\MultiDictionary.cs" />
     <Compile Include="Collections\IValued.cs" />
+    <Compile Include="Collections\LookasideStringInterner.cs" />
     <Compile Include="Collections\PropertyDictionary.cs" />
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
     <Compile Include="Collections\ReadOnlyConvertingDictionary.cs" />
-    <!-- ######################## -->
+    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\IRetrievableValuedEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\RetrievableEntryHashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\RetrievableValuedEntryHashSet.cs" />
     <Compile Include="Collections\WeakValueDictionary.cs" />
-    <Compile Include="Collections\ArrayDictionary.cs" />
     <!-- #### CONSTRUCTION MODEL ### -->
     <Compile Include="Construction\ProjectElement.cs" />
     <Compile Include="Construction\ProjectElementContainer.cs" />
@@ -530,7 +538,13 @@
     <!-- #### INSTANCE MODEL ### -->
     <Compile Include="Instance\IImmutableInstanceProvider.cs" />
     <Compile Include="Instance\ImmutableProjectCollections\ImmutableElementCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableGlobalPropertiesCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDefinitionsListConverter.cs" />
     <Compile Include="Instance\ImmutableProjectCollections\ImmutableItemDictionary.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableLinkedMultiDictionaryConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutablePropertyCollectionConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableStringValuedListConverter.cs" />
+    <Compile Include="Instance\ImmutableProjectCollections\ImmutableValuedElementCollectionConverter.cs" />
     <Compile Include="Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="Instance\HostServices.cs" />
     <Compile Include="Instance\ProjectTargetInstanceChild.cs" />
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index c0165f577a5..4618292cc2d 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
+using System.Threading;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -234,18 +235,27 @@ public UsingTaskParameterGroupElement Create(UsingTaskParameterGroupElementLink
 
         #region Linked classes helpers
         // Using the pattern with overloaded classes that provide "Link" object so we ensure we do not increase the
-        // memory storage of original items (with the Link field) while it is small, some of the MSbuild items can be created
+        // memory storage of original items (with the Link field) while it is small, some of the MSBuild items can be created
         // in millions so it does adds up otherwise.
 
         private class LinkedProjectItem : ProjectItem, ILinkableObject, IImmutableInstanceProvider<ProjectItemInstance>
         {
+            private ProjectItemInstance _immutableInstance;
+
             internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemLink link)
                 : base(xml, project)
             {
                 Link = link;
             }
 
-            public ProjectItemInstance ImmutableInstance { get; set; }
+            public ProjectItemInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectItemInstance GetOrSetImmutableInstance(ProjectItemInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             internal override ProjectItemLink Link { get; }
 
@@ -254,32 +264,54 @@ internal LinkedProjectItem(ProjectItemElement xml, Project project, ProjectItemL
 
         private class LinkedProjectItemDefinition : ProjectItemDefinition, ILinkableObject, IImmutableInstanceProvider<ProjectItemDefinitionInstance>
         {
+            private ProjectItemDefinitionInstance _immutableInstance;
+
             internal LinkedProjectItemDefinition(ProjectItemDefinitionLink link, Project project, string itemType)
                 : base(project, itemType)
             {
                 Link = link;
             }
 
-            public ProjectItemDefinitionInstance ImmutableInstance { get; set; }
+            public ProjectItemDefinitionInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectItemDefinitionInstance GetOrSetImmutableInstance(ProjectItemDefinitionInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             internal override ProjectItemDefinitionLink Link { get; }
             object ILinkableObject.Link => Link;
         }
 
-        private class LinkedProjectMetadata : ProjectMetadata, ILinkableObject
+        private class LinkedProjectMetadata : ProjectMetadata, ILinkableObject, IImmutableInstanceProvider<ProjectMetadataInstance>
         {
+            private ProjectMetadataInstance _immutableInstance;
+
             internal LinkedProjectMetadata(object parent, ProjectMetadataLink link)
                 : base(parent, link.Xml)
             {
                 Link = link;
             }
 
+            public ProjectMetadataInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectMetadataInstance GetOrSetImmutableInstance(ProjectMetadataInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
+
             internal override ProjectMetadataLink Link { get; }
             object ILinkableObject.Link => Link;
         }
 
         private class LinkedProjectProperty : ProjectProperty, ILinkableObject, IImmutableInstanceProvider<ProjectPropertyInstance>
         {
+            private ProjectPropertyInstance _immutableInstance;
+
             internal ProjectPropertyLink Link { get; }
             object ILinkableObject.Link => Link;
 
@@ -295,7 +327,14 @@ internal LinkedProjectProperty(Project project, ProjectPropertyLink link)
                 Link = link;
             }
 
-            public ProjectPropertyInstance ImmutableInstance { get; set;  }
+            public ProjectPropertyInstance ImmutableInstance => _immutableInstance;
+
+            public ProjectPropertyInstance GetOrSetImmutableInstance(ProjectPropertyInstance instance)
+            {
+                Interlocked.CompareExchange(ref _immutableInstance, instance, null);
+
+                return _immutableInstance;
+            }
 
             public override string Name => Link.Name;
 
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 62bcd2464c3..c1fd804eefc 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1102,6 +1102,9 @@
   <data name="OutputItemParameterMessagePrefix" xml:space="preserve">
     <value>Output Item(s): </value>
   </data>
+  <data name="OutputPropertyLogMessagePrefix" xml:space="preserve">
+    <value>Output Property: </value>
+  </data>
   <data name="OutputPropertyLogMessage" xml:space="preserve">
     <value>Output Property: {0}={1}</value>
   </data>
@@ -2111,6 +2114,10 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Failed to find the specified custom analyzer assembly: {0}. Please check if it exists.</value>
     <comment>The message is emitted when the custom analyzer assembly can not be found.</comment>
   </data>
+  <data name="CustomAnalyzerBaseTypeNotAssignable" xml:space="preserve">
+    <value>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
+    <comment>The message is emitted when the custom analyzer assembly can not be successfully registered.</comment>
+  </data>
   <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
     <value>Task assembly was loaded from '{0}' while the desired location was '{1}'.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index cce18578077..12159a47bad 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Nepodařilo se najít zadané sestavení vlastního analyzátoru: {0}. Zkontrolujte prosím, jestli existuje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Nepodařilo se zaregistrovat vlastní analyzátor: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Metoda {0} se nedá zavolat s kolekcí, která obsahuje prázdné cílové názvy nebo názvy null.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Vytvořilo se přepsání pomocí úlohy: {0} v {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index d1aa6cbc8ec..b59ca9f4b29 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Analysetoolassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Fehler beim Registrieren des benutzerdefinierten Analysetools: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Die Methode "{0}" kann nicht mit einer Sammlung aufgerufen werden, die NULL oder leere Zielnamen enthält.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Außerkraftsetzung mit Task erstellt: {0} bei {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 90914c626ff..9fc0e2004c1 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -212,6 +212,11 @@
         <target state="translated">No se ha podido encontrar el ensamblado del analizador personalizado especificado: {0}. Compruebe si existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">No se ha podido registrar el analizador personalizado: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">No se puede llamar al método {0} con una colección que contiene nombres de destino nulos o vacíos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Se creó una invalidación mediante la tarea: {0} en {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 09bad2f7e80..173d20b8e80 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Impossible de trouver l’assemblée d'analyseur personnalisé spécifié : {0}. Vérifiez s’il existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Échec de l’inscription de l’analyseur personnalisé : {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Impossible d'appeler la méthode {0} avec une collection contenant des noms de cibles qui ont une valeur null ou qui sont vides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Remplacement créé à l’aide de la tâche : {0} au {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 8bf8eec2d8d..5fb9d863501 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Impossibile trovare l'assembly dell'analizzatore personalizzato specificato: {0}. Verificare se esiste.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Impossibile registrare l'analizzatore personalizzato: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Non è possibile chiamare il metodo {0} con una raccolta contenente nomi di destinazione Null o vuoti.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">È stata creata una sostituzione con l'attività: {0} in {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index fbdc02d0590..76d1dbb00f5 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -212,6 +212,11 @@
         <target state="translated">指定されたカスタム アナライザー アセンブリが見つかりませんでした: {0}。存在するかどうか確認してください。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">カスタム アナライザーを登録できませんでした: {0}</target>
@@ -393,6 +398,11 @@
         <target state="translated">Null または空のターゲット名を含むコレクションを指定してメソッド {0} を呼び出すことはできません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">タスクを使用してオーバーライドを作成しました: {1} の {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index dc7c94b9d2f..bd12b96bc04 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -212,6 +212,11 @@
         <target state="translated">지정한 사용자 지정 분석기 어셈블리를 찾지 못했습니다. {0}. 존재하는지 확인하세요.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">사용자 지정 분석기를 등록하지 못했습니다. {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">null 또는 빈 대상 이름을 포함하는 컬렉션을 사용하여 {0} 메서드를 호출할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">다음 작업을 사용하여 재정의를 만들었습니다. {1}의 {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index d8d09cb9c63..dbcd4c03be1 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Nie można odnaleźć określonego zestawu analizatora niestandardowego: {0}. Sprawdź, czy istnieje.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Nie można zarejestrować analizatora niestandardowego: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Metody {0} nie można wywołać przy użyciu kolekcji zawierającej nazwy docelowe o wartości null lub puste.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Utworzono zastąpienie przy użyciu zadania: {0} o {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 389700299cc..86f850fe194 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Falha ao localizar o assembly do analisador personalizado especificado: {0}. Verifique se existe.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Falha ao registrar o analisador personalizado: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">O método {0} não pode ser chamado com uma coleção que contém nomes de destino nulos ou vazios.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Criou uma substituição usando a tarefa: {0} em {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 5c04d7194eb..b188dc604e6 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Не удалось найти указанную сборку настраиваемого анализатора: {0}. Убедитесь, что она существует.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Не удалось зарегистрировать настраиваемый анализатор: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">Метод {0} не может быть вызван с коллекцией, содержащей целевые имена, которые пусты или равны NULL.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">Создано переопределение с помощью задачи {0} в {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index a9dc8a0e065..73d2817be15 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -212,6 +212,11 @@
         <target state="translated">Belirtilen {0} özel çözümleyici derlemesi bulunamadı. Lütfen var olup olmadığını kontrol edin.</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">Özel çözümleyici kaydedilemedi: {0}.</target>
@@ -393,6 +398,11 @@
         <target state="translated">{0} metosu null veya boş hedef adları içeren bir koleksiyonla çağrılamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">{0} görevi kullanılarak geçersiz kılma işlemi oluşturuldu, saat: {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 868e495f52b..1d0718316a0 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -212,6 +212,11 @@
         <target state="translated">找不到指定的自定义分析器程序集: {0}。请检查它是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">无法注册自定义分析器: {0}。</target>
@@ -393,6 +398,11 @@
         <target state="translated">无法使用包含 null 或空目标名称的集合调用方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用任务创建替代: {0} 位于 {1}</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index b31a9ad4517..4891c609ece 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -212,6 +212,11 @@
         <target state="translated">找不到指定的自訂分析器組件: {0}。請檢查它是否存在。</target>
         <note>The message is emitted when the custom analyzer assembly can not be found.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
+        <source>Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom analyzer type: {0} from the assembly: {1}. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
         <source>Failed to register the custom analyzer: {0}.</source>
         <target state="translated">無法登錄自訂分析器: {0}。</target>
@@ -393,6 +398,11 @@
         <target state="translated">無法使用內含 null 或空白目標名稱的集合呼叫方法 {0}。</target>
         <note />
       </trans-unit>
+      <trans-unit id="OutputPropertyLogMessagePrefix">
+        <source>Output Property: </source>
+        <target state="new">Output Property: </target>
+        <note />
+      </trans-unit>
       <trans-unit id="OverrideUsingTaskElementCreated">
         <source>Created an override using task: {0} at {1}</source>
         <target state="translated">已使用下列工作建立覆寫: 於 {1} 的 {0}</target>
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 67b454cc023..e8bf893be60 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -462,11 +462,11 @@ private static bool UsingDifferentToolsVersionFromProjectFile(string toolsVersio
         /// Retrieves properties derived from the current
         /// environment variables.
         /// </summary>
-        internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProperties()
+        internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProperties(bool makeReadOnly)
         {
             IDictionary<string, string> environmentVariablesBag = CommunicationsUtilities.GetEnvironmentVariables();
 
-            PropertyDictionary<ProjectPropertyInstance> environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(environmentVariablesBag.Count + 2);
+            var envPropertiesHashSet = new RetrievableValuedEntryHashSet<ProjectPropertyInstance>(environmentVariablesBag.Count + 2, MSBuildNameIgnoreCaseComparer.Default);
 
             // We set the MSBuildExtensionsPath variables here because we don't want to make them official
             // reserved properties; we need the ability for people to override our default in their
@@ -483,11 +483,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                                           ? Path.Combine(programFiles32, ReservedPropertyNames.extensionsPathSuffix)
                                           : programFiles32;
 #endif
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath32, extensionsPath32, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath32, extensionsPath32, true));
 
 #if !FEATURE_INSTALLED_MSBUILD
             string extensionsPath64 = extensionsPath;
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
 #else
             // "MSBuildExtensionsPath64". This points to whatever the value of "Program Files" environment variable is on a
             // 64-bit machine, and is empty on a 32-bit machine.
@@ -500,7 +500,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                                                   FrameworkLocationHelper.programFiles64,
                                                   ReservedPropertyNames.extensionsPathSuffix)
                                               : FrameworkLocationHelper.programFiles64;
-                environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
+                envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath64, extensionsPath64, true));
             }
 #endif
 
@@ -523,13 +523,13 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             }
 #endif
 
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath, extensionsPath, true));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.extensionsPath, extensionsPath, true));
 
             // Windows XP and Windows Server 2003 don't define LocalAppData in their environment.
             // We'll set it here if the environment doesn't have it so projects can reliably
             // depend on $(LocalAppData).
             string localAppData = String.Empty;
-            ProjectPropertyInstance localAppDataProp = environmentProperties.GetProperty(ReservedPropertyNames.localAppData);
+            ProjectPropertyInstance localAppDataProp = envPropertiesHashSet.Get(ReservedPropertyNames.localAppData);
             if (localAppDataProp != null)
             {
                 localAppData = localAppDataProp.EvaluatedValue;
@@ -551,11 +551,11 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
             }
 
 
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.localAppData, localAppData));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.localAppData, localAppData));
 
             // Add MSBuildUserExtensionsPath at $(LocalAppData)\Microsoft\MSBuild
             string userExtensionsPath = Path.Combine(localAppData, ReservedPropertyNames.userExtensionsPathSuffix);
-            environmentProperties.Set(ProjectPropertyInstance.Create(ReservedPropertyNames.userExtensionsPath, userExtensionsPath));
+            envPropertiesHashSet.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.userExtensionsPath, userExtensionsPath));
 
             foreach (KeyValuePair<string, string> environmentVariable in environmentVariablesBag)
             {
@@ -570,7 +570,7 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                 {
                     ProjectPropertyInstance environmentProperty = ProjectPropertyInstance.Create(environmentVariableName, environmentVariable.Value);
 
-                    environmentProperties.Set(environmentProperty);
+                    envPropertiesHashSet.Add(environmentProperty);
                 }
                 else
                 {
@@ -579,6 +579,12 @@ internal static PropertyDictionary<ProjectPropertyInstance> GetEnvironmentProper
                 }
             }
 
+            if (makeReadOnly)
+            {
+                envPropertiesHashSet.MakeReadOnly();
+            }
+
+            var environmentProperties = new PropertyDictionary<ProjectPropertyInstance>(envPropertiesHashSet);
             return environmentProperties;
         }
 
diff --git a/src/BuildCheck.UnitTests/AssemblyInfo.cs b/src/BuildCheck.UnitTests/AssemblyInfo.cs
index 3b5d7bbb185..5b383e24105 100644
--- a/src/BuildCheck.UnitTests/AssemblyInfo.cs
+++ b/src/BuildCheck.UnitTests/AssemblyInfo.cs
@@ -2,3 +2,13 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 global using NativeMethodsShared = Microsoft.Build.Framework.NativeMethods;
+
+namespace Microsoft.Build.UnitTests.Shared;
+
+[System.AttributeUsage(System.AttributeTargets.Assembly)]
+internal sealed class BootstrapLocationAttribute(string bootstrapRoot, string bootstrapMsbuildBinaryLocation)
+    : System.Attribute
+{
+    public string BootstrapRoot { get; } = bootstrapRoot;
+    public string BootstrapMsbuildBinaryLocation { get; } = bootstrapMsbuildBinaryLocation;
+}
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
index a3f8b019439..7bd57f8014b 100644
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
@@ -1,11 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Xunit;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
new file mode 100644
index 00000000000..edfdfaf4589
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
@@ -0,0 +1,113 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildAnalyzerConfiguration_Test
+{
+    [Fact]
+    public void CreateWithNull_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(null);
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Fact]
+    public void CreateWithEmpty_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", BuildAnalyzerResultSeverity.Error)]
+    [InlineData("info", BuildAnalyzerResultSeverity.Info)]
+    [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
+    [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
+    public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity" , parameter },
+        };
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("true", true)]
+    [InlineData("TRUE", true)]
+    [InlineData("false", false)]
+    [InlineData("FALSE", false)]
+    public void CreateBuildAnalyzerConfiguration_IsEnabled(string parameter, bool? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "isenabled" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.IsEnabled.ShouldBe(expected);
+
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("ProjectOnly", EvaluationAnalysisScope.ProjectOnly)]
+    [InlineData("ProjectWithImportsFromCurrentWorkTree", EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree)]
+    [InlineData("ProjectWithImportsWithoutSdks", EvaluationAnalysisScope.ProjectWithImportsWithoutSdks)]
+    [InlineData("ProjectWithAllImports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    [InlineData("projectwithallimports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string parameter, EvaluationAnalysisScope? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "evaluationanalysisscope" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.Severity.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("evaluationanalysisscope", "incorrec-value")]
+    [InlineData("isenabled", "incorrec-value")]
+    [InlineData("severity", "incorrec-value")]
+    public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { key , value },
+        };
+
+        var exception = Should.Throw<BuildCheckConfigurationException>(() => {
+            BuildAnalyzerConfiguration.Create(config);
+        });
+        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
new file mode 100644
index 00000000000..d559e1724b1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -0,0 +1,221 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class ConfigurationProvider_Tests
+{
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsEmptyConfig()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // empty
+        configs.ShouldBe(new Dictionary<string, string>());
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        configs.Keys.Count.ShouldBe(2);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+
+        configs["property2"].ShouldBe("value2");
+        configs["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationData()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        any_other_key1=any_other_value1
+        any_other_key2=any_other_value2
+        any_other_key3=any_other_value3
+        any_other_key3=any_other_value3
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var customConfiguration = configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+        var configs = customConfiguration.ConfigurationData;
+
+        configs!.Keys.Count().ShouldBe(3);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+        configs.ContainsKey("isenabled2").ShouldBeTrue();
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.Severity=Error
+        build_check.rule_id.EvaluationAnalysisScope=ProjectOnly
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var buildConfig = configurationProvider.GetUserConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        buildConfig.ShouldNotBeNull();
+
+        buildConfig.IsEnabled?.ShouldBeTrue();
+        buildConfig.Severity?.ShouldBe(BuildAnalyzerResultSeverity.Error);
+        buildConfig.EvaluationAnalysisScope?.ShouldBe(EvaluationAnalysisScope.ProjectOnly);
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentValues()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value2
+        build_check.rule_id.property2=value3
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=tru1
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentKeys()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.isEnabled3=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should fail, because the configs are the different
+        Should.NotThrow(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+}
diff --git a/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
new file mode 100644
index 00000000000..e8ff337e1a8
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
@@ -0,0 +1,140 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CustomConfigurationData_Tests
+{
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_NullInstance()
+    {
+        var customConfigurationData1 = CustomConfigurationData.Null;
+        var customConfigurationData2 = CustomConfigurationData.Null;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_SameInstance()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = customConfigurationData1;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_DifferentObjectType()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new object();
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_DifferentInstanceSameValues()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataSame()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferent()
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentKeys()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentValues()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataKeysOrderDiffers()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" },
+            { "key2", "val2" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" },
+            { "key1", "val1" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
new file mode 100644
index 00000000000..17bd60abbd1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
@@ -0,0 +1,119 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfigParser_Tests
+{
+    [Fact]
+    public void NoSectionConfigured_ResultsEmptyResultConfig()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file");
+        mergedResult.Keys.Count.ShouldBe(0);
+    }
+
+    [Fact]
+    public void ProperOrderOfconfiguration_ClosestToTheFileShouldBeApplied()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    [*]
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file.proj");
+        mergedResult.Keys.Count.ShouldBe(1);
+        mergedResult["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootTrue()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=should_not_be_respected_and_parsed
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj") ).ToList();
+        // should be one because root=true so we do not need to go further
+        listOfEditorConfigFile.Count.ShouldBe(1);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeTrue();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+        listOfEditorConfigFile[0].NamedSections[0].Properties["test_key"].ShouldBe("test_value_updated");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootFalse()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=will_be_there
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj")).ToList();
+
+        listOfEditorConfigFile.Count.ShouldBe(2);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeFalse();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
new file mode 100644
index 00000000000..1b1b0c5aaa4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -0,0 +1,1078 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+using Xunit;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+#nullable disable
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfig_Tests
+{
+
+    #region AssertEqualityComparer<T>
+    private sealed class AssertEqualityComparer<T> : IEqualityComparer<T>
+    {
+        public static readonly IEqualityComparer<T> Instance = new AssertEqualityComparer<T>();
+
+        private static bool CanBeNull()
+        {
+            var type = typeof(T);
+            return !type.GetTypeInfo().IsValueType ||
+                (type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
+        }
+
+        public static bool IsNull(T @object)
+        {
+            if (!CanBeNull())
+            {
+                return false;
+            }
+
+            return object.Equals(@object, default(T));
+        }
+
+        public static bool Equals(T left, T right)
+        {
+            return Instance.Equals(left, right);
+        }
+
+        bool IEqualityComparer<T>.Equals(T x, T y)
+        {
+            if (CanBeNull())
+            {
+                if (object.Equals(x, default(T)))
+                {
+                    return object.Equals(y, default(T));
+                }
+
+                if (object.Equals(y, default(T)))
+                {
+                    return false;
+                }
+            }
+
+            if (x.GetType() != y.GetType())
+            {
+                return false;
+            }
+
+            if (x is IEquatable<T> equatable)
+            {
+                return equatable.Equals(y);
+            }
+
+            if (x is IComparable<T> comparableT)
+            {
+                return comparableT.CompareTo(y) == 0;
+            }
+
+            if (x is IComparable comparable)
+            {
+                return comparable.CompareTo(y) == 0;
+            }
+
+            var enumerableX = x as IEnumerable;
+            var enumerableY = y as IEnumerable;
+
+            if (enumerableX != null && enumerableY != null)
+            {
+                var enumeratorX = enumerableX.GetEnumerator();
+                var enumeratorY = enumerableY.GetEnumerator();
+
+                while (true)
+                {
+                    bool hasNextX = enumeratorX.MoveNext();
+                    bool hasNextY = enumeratorY.MoveNext();
+
+                    if (!hasNextX || !hasNextY)
+                    {
+                        return hasNextX == hasNextY;
+                    }
+
+                    if (!Equals(enumeratorX.Current, enumeratorY.Current))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return object.Equals(x, y);
+        }
+
+        int IEqualityComparer<T>.GetHashCode(T obj)
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+    #endregion
+
+    // Section Matchin Test cases: https://github.com/dotnet/roslyn/blob/ba163e712b01358a217065eec8a4a82f94a7efd5/src/Compilers/Core/CodeAnalysisTest/Analyzers/AnalyzerConfigTests.cs#L337
+    #region Section Matching Tests
+    [Fact]
+    public void SimpleNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc").Value;
+        Assert.Equal("^.*/abc$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/aabc"));
+        Assert.False(matcher.IsMatch("/ abc"));
+        Assert.False(matcher.IsMatch("/cabc"));
+    }
+
+    [Fact]
+    public void StarOnlyMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*").Value;
+        Assert.Equal("^.*/[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/123"));
+        Assert.True(matcher.IsMatch("/abc/123"));
+    }
+
+    [Fact]
+    public void StarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.cs").Value;
+        Assert.Equal("^.*/[^/]*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/123.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+        // Only '/' is defined as a directory separator, so the caller
+        // is responsible for converting any other machine directory
+        // separators to '/' before matching
+        Assert.True(matcher.IsMatch("/dir\\subpath.cs"));
+
+        Assert.False(matcher.IsMatch("/abc.vb"));
+    }
+
+    [Fact]
+    public void StarStarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("**.cs").Value;
+        Assert.Equal("^.*/.*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+    }
+
+    [Fact]
+    public void EscapeDot()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("...").Value;
+        Assert.Equal("^.*/\\.\\.\\.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/..."));
+        Assert.True(matcher.IsMatch("/subdir/..."));
+        Assert.False(matcher.IsMatch("/aaa"));
+        Assert.False(matcher.IsMatch("/???"));
+        Assert.False(matcher.IsMatch("/abc"));
+    }
+
+    [Fact]
+    public void EndBackslashMatch()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc\\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void QuestionMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab?def").Value;
+        Assert.Equal("^.*/ab.def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcdef"));
+        Assert.True(matcher.IsMatch("/ab?def"));
+        Assert.True(matcher.IsMatch("/abzdef"));
+        Assert.True(matcher.IsMatch("/ab/def"));
+        Assert.True(matcher.IsMatch("/ab\\def"));
+    }
+
+    [Fact]
+    public void LiteralBackslash()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab\\\\c").Value;
+        Assert.Equal("^.*/ab\\\\c$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab\\c"));
+        Assert.False(matcher.IsMatch("/ab/c"));
+        Assert.False(matcher.IsMatch("/ab\\\\c"));
+    }
+
+    [Fact]
+    public void LiteralStars()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\***\\*\\**").Value;
+        Assert.Equal("^.*/\\*.*\\*\\*[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/*ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd*efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd**ef/gh"));
+    }
+
+    [Fact]
+    public void LiteralQuestions()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\??\\?*\\??").Value;
+        Assert.Equal("^.*/\\?.\\?[^/]*\\?.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/?a?cde?f"));
+        Assert.True(matcher.IsMatch("/???????f"));
+        Assert.False(matcher.IsMatch("/aaaaaaaa"));
+        Assert.False(matcher.IsMatch("/aa?cde?f"));
+        Assert.False(matcher.IsMatch("/?a?cdexf"));
+        Assert.False(matcher.IsMatch("/?axcde?f"));
+    }
+
+    [Fact]
+    public void LiteralBraces()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\{\\}def").Value;
+        Assert.Equal(@"^.*/abc\{}def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc{}def"));
+        Assert.True(matcher.IsMatch("/subdir/abc{}def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc}{def"));
+    }
+
+    [Fact]
+    public void LiteralComma()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\,def").Value;
+        Assert.Equal("^.*/abc,def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc,def"));
+        Assert.True(matcher.IsMatch("/subdir/abc,def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc\\,def"));
+        Assert.False(matcher.IsMatch("/abc`def"));
+    }
+
+    [Fact]
+    public void SimpleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.{cs,vb,fs}").Value;
+        Assert.Equal("^.*/[^/]*\\.(?:cs|vb|fs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.vb"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.cs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.vb"));
+        Assert.True(matcher.IsMatch("/subdir/abc.fs"));
+
+        Assert.False(matcher.IsMatch("/abcxcs"));
+        Assert.False(matcher.IsMatch("/abcxvb"));
+        Assert.False(matcher.IsMatch("/abcxfs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcb"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+    }
+
+    [Fact]
+    public void OneChoiceHasSlashes()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs,subdir/test.vb}").Value;
+        // This is an interesting case that may be counterintuitive.  A reasonable understanding
+        // of the section matching could interpret the choice as generating multiple identical
+        // sections, so [{a, b, c}] would be equivalent to [a] ... [b] ... [c] with all of the
+        // same properties in each section. This is somewhat true, but the rules of how the matching
+        // prefixes are constructed violate this assumption because they are defined as whether or
+        // not a section contains a slash, not whether any of the choices contain a slash. So while
+        // [*.cs] usually translates into '**/*.cs' because it contains no slashes, the slashes in
+        // the second choice make this into '/*.cs', effectively matching only files in the root
+        // directory of the match, instead of all subdirectories.
+        Assert.Equal("^/(?:[^/]*\\.cs|subdir/test\\.vb)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+
+        Assert.False(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("/subdir/subdir/test.vb"));
+        Assert.False(matcher.IsMatch("/test.vb"));
+    }
+
+    [Fact]
+    public void EmptyChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{}").Value;
+        Assert.Equal("^.*/(?:)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/"));
+        Assert.True(matcher.IsMatch("/subdir/"));
+        Assert.False(matcher.IsMatch("/."));
+        Assert.False(matcher.IsMatch("/anything"));
+    }
+
+    [Fact]
+    public void SingleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs}").Value;
+        Assert.Equal("^.*/(?:[^/]*\\.cs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("test.vb"));
+        Assert.False(matcher.IsMatch("testxcs"));
+    }
+
+    [Fact]
+    public void UnmatchedBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("{{{{}}");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CommaOutsideBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc,def");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void RecursiveChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{test{.cs,.vb},other.{a{bb,cc}}}").Value;
+        Assert.Equal("^.*/(?:test(?:\\.cs|\\.vb)|other\\.(?:a(?:bb|cc)))$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/test.vb"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+        Assert.True(matcher.IsMatch("/other.abb"));
+        Assert.True(matcher.IsMatch("/other.acc"));
+
+        Assert.False(matcher.IsMatch("/test.fs"));
+        Assert.False(matcher.IsMatch("/other.bbb"));
+        Assert.False(matcher.IsMatch("/other.ccc"));
+        Assert.False(matcher.IsMatch("/subdir/other.bbb"));
+        Assert.False(matcher.IsMatch("/subdir/other.ccc"));
+    }
+
+    [Fact]
+    public void DashChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{-}cd{-,}ef").Value;
+        Assert.Equal("^.*/ab(?:-)cd(?:-|)ef$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab-cd-ef"));
+        Assert.True(matcher.IsMatch("/ab-cdef"));
+
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/ab--cd-ef"));
+        Assert.False(matcher.IsMatch("/ab--cd--ef"));
+    }
+
+    [Fact]
+    public void MiddleMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{cs,vb,fs}cd").Value;
+        Assert.Equal("^.*/ab(?:cs|vb|fs)cd$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcscd"));
+        Assert.True(matcher.IsMatch("/abvbcd"));
+        Assert.True(matcher.IsMatch("/abfscd"));
+
+        Assert.False(matcher.IsMatch("/abcs"));
+        Assert.False(matcher.IsMatch("/abcd"));
+        Assert.False(matcher.IsMatch("/vbcd"));
+    }
+
+    private static IEnumerable<(string, string)> RangeAndInverse(string s1, string s2)
+    {
+        yield return (s1, s2);
+        yield return (s2, s1);
+    }
+
+    [Fact]
+    public void NumberMatch()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("0", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/000005"));
+            Assert.False(matcher.IsMatch("/-1"));
+            Assert.False(matcher.IsMatch("/-00000001"));
+            Assert.False(matcher.IsMatch("/11"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegativeRange()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "0"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.False(matcher.IsMatch("/1"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegToPos()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void MultipleNumberRanges()
+    {
+        foreach (var matchString in new[] { "a{-10..0}b{0..10}", "a{0..-10}b{10..0}" })
+        {
+            var matcher = TryCreateSectionNameMatcher(matchString).Value;
+
+            Assert.True(matcher.IsMatch("/a0b0"));
+            Assert.True(matcher.IsMatch("/a-5b0"));
+            Assert.True(matcher.IsMatch("/a-5b5"));
+            Assert.True(matcher.IsMatch("/a-5b10"));
+            Assert.True(matcher.IsMatch("/a-10b10"));
+            Assert.True(matcher.IsMatch("/a-10b0"));
+            Assert.True(matcher.IsMatch("/a-0b0"));
+            Assert.True(matcher.IsMatch("/a-0b-0"));
+
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-10b11"));
+        }
+    }
+
+    [Fact]
+    public void BadNumberRanges()
+    {
+        var matcherOpt = TryCreateSectionNameMatcher("{0..");
+
+        Assert.Null(matcherOpt);
+
+        var matcher = TryCreateSectionNameMatcher("{0..}").Value;
+
+        Assert.True(matcher.IsMatch("/0.."));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0."));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        matcher = TryCreateSectionNameMatcher("{0..A}").Value;
+        Assert.True(matcher.IsMatch("/0..A"));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        // The reference implementation uses atoi here so we can presume
+        // numbers out of range of Int32 are not well supported
+        matcherOpt = TryCreateSectionNameMatcher($"{{0..{UInt32.MaxValue}}}");
+
+        Assert.Null(matcherOpt);
+    }
+
+    [Fact]
+    public void CharacterClassSimple()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+    }
+
+    [Fact]
+    public void CharacterClassNegative()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[!cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[^cf]s$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/abc.cs"));
+        Assert.False(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.vs"));
+        Assert.True(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassCaret()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[^cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[\^cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.^s"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+        Assert.False(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[0-9]x").Value;
+        Assert.Equal("^.*/[0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassNegativeRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[!0-9]x").Value;
+        Assert.Equal("^.*/[^0-9]x$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/0x"));
+        Assert.False(matcher.IsMatch("/1x"));
+        Assert.False(matcher.IsMatch("/9x"));
+        Assert.True(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassRangeAndChoice()
+    {
+        var matcher = TryCreateSectionNameMatcher("[ab0-9]x").Value;
+        Assert.Equal("^.*/[ab0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ax"));
+        Assert.True(matcher.IsMatch("/bx"));
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/0ax"));
+    }
+
+    [Fact]
+    public void CharacterClassOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher("[");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapedOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\]");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapeAtEnd()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassOpenBracketInside()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[[a]bc").Value;
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/[bc"));
+        Assert.False(matcher.IsMatch("/ab"));
+        Assert.False(matcher.IsMatch("/[b"));
+        Assert.False(matcher.IsMatch("/bc"));
+        Assert.False(matcher.IsMatch("/ac"));
+        Assert.False(matcher.IsMatch("/[c"));
+
+        Assert.Equal(@"^.*/[\[a]bc$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassStartingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[-ac]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[-ac]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ac-]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[ac-]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndBracketAfter()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab]]cd").Value;
+
+        Assert.True(matcher.IsMatch("/a]cd"));
+        Assert.True(matcher.IsMatch("/b]cd"));
+        Assert.False(matcher.IsMatch("/acd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+        Assert.False(matcher.IsMatch("/acd"));
+
+        Assert.Equal(@"^.*/[ab]]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEscapeBackslash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab\\]cd").Value;
+
+        Assert.True(matcher.IsMatch("/acd"));
+        Assert.True(matcher.IsMatch("/bcd"));
+        Assert.True(matcher.IsMatch("/\\cd"));
+        Assert.False(matcher.IsMatch("/dcd"));
+        Assert.False(matcher.IsMatch("/\\\\cd"));
+        Assert.False(matcher.IsMatch("/cd"));
+
+        Assert.Equal(@"^.*/[ab\\]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void EscapeOpenBracket()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"ab\[cd").Value;
+
+        Assert.True(matcher.IsMatch("/ab[cd"));
+        Assert.False(matcher.IsMatch("/ab[[cd"));
+        Assert.False(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/abd"));
+
+        Assert.Equal(@"^.*/ab\[cd$", matcher.Regex.ToString());
+    }
+    #endregion
+
+    #region Parsing Tests
+
+    private static void SetEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null, string message = null)
+    {
+        var expectedSet = new HashSet<T>(expected, comparer);
+        var result = expected.Count() == actual.Count() && expectedSet.SetEquals(actual);
+        Assert.True(result, message);
+    }
+
+    private static void Equal<T>(
+        IEnumerable<T> expected,
+        IEnumerable<T> actual,
+        IEqualityComparer<T> comparer = null,
+        string message = null)
+    {
+        if (expected == null)
+        {
+            Assert.Null(actual);
+        }
+        else
+        {
+            Assert.NotNull(actual);
+        }
+
+        if (SequenceEqual(expected, actual, comparer))
+        {
+            return;
+        }
+
+        Assert.True(false, message);
+    }
+
+    private static bool SequenceEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null)
+    {
+        if (ReferenceEquals(expected, actual))
+        {
+            return true;
+        }
+
+        var enumerator1 = expected.GetEnumerator();
+        var enumerator2 = actual.GetEnumerator();
+
+        while (true)
+        {
+            var hasNext1 = enumerator1.MoveNext();
+            var hasNext2 = enumerator2.MoveNext();
+
+            if (hasNext1 != hasNext2)
+            {
+                return false;
+            }
+
+            if (!hasNext1)
+            {
+                break;
+            }
+
+            var value1 = enumerator1.Current;
+            var value2 = enumerator2.Current;
+
+            if (!(comparer != null ? comparer.Equals(value1, value2) : AssertEqualityComparer<T>.Equals(value1, value2)))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static KeyValuePair<K, V> Create<K, V>(K key, V value)
+    {
+        return new KeyValuePair<K, V>(key, value);
+    }
+
+    [Fact]
+    public void SimpleCase()
+    {
+        var config = EditorConfigFile.Parse("""
+root = true
+
+# Comment1
+# Comment2
+##################################
+
+my_global_prop = my_global_val
+
+[*.cs]
+my_prop = my_val
+""");
+        Assert.Equal("", config.GlobalSection.Name);
+        var properties = config.GlobalSection.Properties;
+
+        SetEqual(
+            new[] { Create("my_global_prop", "my_global_val") ,
+                    Create("root", "true") },
+            properties);
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("*.cs", namedSections[0].Name);
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            namedSections[0].Properties);
+        
+        Assert.True(config.IsRoot);
+    }
+
+    
+    [Fact]
+    // [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void ConfigWithEscapedValues()
+    {
+        var config = EditorConfigFile.Parse(@"is_global = true
+
+[c:/\{f\*i\?le1\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[c:/f\,ile\#2.cs]
+build_metadata.Compile.ToRetrieve = def456
+
+[c:/f\;i\!le\[3\].cs]
+build_metadata.Compile.ToRetrieve = ghi789
+");
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("c:/\\{f\\*i\\?le1\\}.cs", namedSections[0].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "abc123") },
+            namedSections[0].Properties);
+
+        Assert.Equal("c:/f\\,ile\\#2.cs", namedSections[1].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "def456") },
+            namedSections[1].Properties);
+
+        Assert.Equal("c:/f\\;i\\!le\\[3\\].cs", namedSections[2].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "ghi789") },
+            namedSections[2].Properties);
+    }
+
+    /*
+    [Fact]
+    [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void CanGetSectionsWithSpecialCharacters()
+    {
+        var config = ParseConfigFile(@"is_global = true
+
+[/home/foo/src/\{releaseid\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[/home/foo/src/Pages/\#foo/HomePage.cs]
+build_metadata.Compile.ToRetrieve = def456
+");
+
+        var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
+
+        var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
+        Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+
+        sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
+        Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+    }*/
+
+    [Fact]
+    public void MissingClosingBracket()
+    {
+        var config = EditorConfigFile.Parse(@"
+[*.cs
+my_prop = my_val");
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            properties);
+
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void EmptySection()
+    {
+        var config = EditorConfigFile.Parse(@"
+[]
+my_prop = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_val") }, properties);
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitivePropKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_PROP = my_VAL");
+        var properties = config.GlobalSection.Properties;
+
+        Assert.True(properties.TryGetValue("my_PrOp", out var val));
+        Assert.Equal("my_VAL", val);
+        Assert.Equal("my_prop", properties.Keys.Single());
+    }
+
+    // there is no reversed keys support for msbuild
+    /*[Fact]
+    public void NonReservedKeyPreservedCaseVal()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
+            config.GlobalSection.Properties);
+    }*/
+
+
+    [Fact]
+    public void DuplicateKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_prop = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void DuplicateKeysCasing()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_PROP = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void MissingKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+= my_val1
+my_prop = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val2") },
+            properties);
+    }
+
+    
+
+    [Fact]
+    public void MissingVal()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop1 =
+my_prop2 = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop1", ""),
+                    Create("my_prop2", "my_val") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void SpacesInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my prop1 = my_val1
+my_prop2 = my val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void EndOfLineComments()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop2 = my val2 # Comment");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsStartKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+@!$abc = my_val1
+@!$\# = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(0, properties.Count);
+    }
+
+    
+    [Fact]
+    public void EqualsAndColon()
+    {
+        var config = EditorConfigFile.Parse(@"
+my:key1 = my_val
+my_key2 = my:val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my", "key1 = my_val"),
+                    Create("my_key2", "my:val")},
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my@key1 = my_val
+my_key2 = my@val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_key2", "my@val") },
+            properties);
+    }
+    
+    [Fact]
+    public void LongLines()
+    {
+        // This example is described in the Python ConfigParser as allowing
+        // line continuation via the RFC 822 specification, section 3.1.1
+        // LONG HEADER FIELDS. The VS parser does not accept this as a
+        // valid parse for an editorconfig file. We follow similarly.
+        var config = EditorConfigFile.Parse(@"
+long: this value continues
+   in the next line");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("long", "this value continues") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitiveRoot()
+    {
+        var config = EditorConfigFile.Parse(@"
+RoOt = TruE");
+        Assert.True(config.IsRoot);
+    }
+
+
+    /*
+    Reserved values are not supported at the moment
+    [Fact]
+    public void ReservedValues()
+    {
+        int index = 0;
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
+        index = 0;
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+
+    /*
+    [Fact]
+    public void ReservedKeys()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+    #endregion
+}
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index b8f0baa6cc8..8ec267358ca 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -2,12 +2,11 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
 using System.Xml;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
-using Newtonsoft.Json.Linq;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -26,7 +25,9 @@ public EndToEndTests(ITestOutputHelper output)
         _env.WithEnvironmentInvariant();
     }
 
-    private static string TestAssetsRootPath { get; } = Path.Combine(Path.GetDirectoryName(typeof(EndToEndTests).Assembly.Location) ?? AppContext.BaseDirectory, "TestAssets");
+    private static string AssemblyLocation { get; } = Path.Combine(Path.GetDirectoryName(typeof(EndToEndTests).Assembly.Location) ?? AppContext.BaseDirectory);
+
+    private static string TestAssetsRootPath { get; } = Path.Combine(AssemblyLocation, "TestAssets");
 
     public void Dispose() => _env.Dispose();
 
@@ -220,53 +221,33 @@ private void PrepareSampleProjectsAndConfig(bool buildInOutOfProcessNode, out Tr
     }
 
     [Theory]
-    [InlineData(new[] { "CustomAnalyzer" }, "AnalysisCandidate", new[] { "CustomRule1", "CustomRule2" })]
-    [InlineData(new[] { "CustomAnalyzer", "CustomAnalyzer2" }, "AnalysisCandidateWithMultipleAnalyzersInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" })]
-    public void CustomAnalyzerTest(string[] customAnalyzerNames, string analysisCandidate, string[] expectedRegisteredRules)
+    [InlineData("AnalysisCandidate", new[] { "CustomRule1", "CustomRule2" })]
+    [InlineData("AnalysisCandidateWithMultipleAnalyzersInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
+    public void CustomAnalyzerTest(string analysisCandidate, string[] expectedRegisteredRules, bool expectedRejectedAnalyzers = false)
     {
         using (var env = TestEnvironment.Create())
         {
-            var candidatesNugetFullPaths = BuildAnalyzerRules(env, customAnalyzerNames);
-
-            candidatesNugetFullPaths.ShouldNotBeEmpty("Nuget package with custom analyzer was not generated or detected.");
-
             var analysisCandidatePath = Path.Combine(TestAssetsRootPath, analysisCandidate);
-            AddCustomDataSourceToNugetConfig(analysisCandidatePath, candidatesNugetFullPaths);
+            AddCustomDataSourceToNugetConfig(analysisCandidatePath);
 
             string projectAnalysisBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
                 $"{Path.Combine(analysisCandidatePath, $"{analysisCandidate}.csproj")} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -analyze -verbosity:d",
                 out bool successBuild);
-            successBuild.ShouldBeTrue();
+            successBuild.ShouldBeTrue(projectAnalysisBuildLog);
 
-            foreach (string expectedRegisteredRule in expectedRegisteredRules)
+            foreach (string registeredRule in expectedRegisteredRules)
             {
-                projectAnalysisBuildLog.ShouldContain($"Custom analyzer rule: {expectedRegisteredRule} has been registered successfully.");
+                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerSuccessfulAcquisition", registeredRule));
             }
-        }
-    }
-
-    private IList<string> BuildAnalyzerRules(TestEnvironment env, string[] customAnalyzerNames)
-    {
-        var candidatesNugetFullPaths = new List<string>();
-
-        foreach (var customAnalyzerName in customAnalyzerNames)
-        {
-            var candidateAnalysisProjectPath = Path.Combine(TestAssetsRootPath, customAnalyzerName, $"{customAnalyzerName}.csproj");
-            var nugetPackResults = RunnerUtilities.ExecBootstrapedMSBuild(
-                 $"{candidateAnalysisProjectPath} /m:1 -nr:False -restore /p:OutputPath={env.CreateFolder().Path} -getTargetResult:Build", out bool success, attachProcessId: false);
-
-            success.ShouldBeTrue();
 
-            string? candidatesNugetPackageFullPath = (string?)(JObject.Parse(nugetPackResults)?["TargetResults"]?["Build"]?["Items"]?[0]?["RelativeDir"] ?? string.Empty);
-
-            candidatesNugetPackageFullPath.ShouldNotBeNull();
-            candidatesNugetFullPaths.Add(candidatesNugetPackageFullPath);
+            if (expectedRejectedAnalyzers)
+            {
+                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerBaseTypeNotAssignable", "InvalidAnalyzer", "InvalidCustomAnalyzer, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
+            }
         }
-
-        return candidatesNugetFullPaths;
     }
 
-    private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath, IList<string> candidatesNugetPackageFullPaths)
+    private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
     {
         var nugetTemplatePath = Path.Combine(analysisCandidatePath, "nugetTemplate.config");
 
@@ -275,10 +256,9 @@ private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath, ILis
         if (doc.DocumentElement != null)
         {
             XmlNode? packageSourcesNode = doc.SelectSingleNode("//packageSources");
-            for (int i = 0; i < candidatesNugetPackageFullPaths.Count; i++)
-            {
-                AddPackageSource(doc, packageSourcesNode, $"Key{i}", Path.GetDirectoryName(candidatesNugetPackageFullPaths[i]) ?? string.Empty);
-            }
+            // The test packages are generated during the test project build and saved in CustomAnalyzers folder.
+            string analyzersPackagesPath = Path.Combine(Directory.GetParent(AssemblyLocation)?.Parent?.FullName ?? string.Empty, "CustomAnalyzers");
+            AddPackageSource(doc, packageSourcesNode, "Key", analyzersPackagesPath);
 
             doc.Save(Path.Combine(analysisCandidatePath, "nuget.config"));
         }
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index ada169a4b49..6a72903b8e6 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -11,9 +11,16 @@
 
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
+    <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
   </ItemGroup>
+  
+  <ItemGroup Label="TestAssests">
+    <ProjectReference Include=".\TestAssets\CustomAnalyzer\CustomAnalyzer.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomAnalyzer2\CustomAnalyzer2.csproj" />
+    <ProjectReference Include=".\TestAssets\InvalidCustomAnalyzer\InvalidCustomAnalyzer.csproj" />
+  </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="System.Collections.Immutable" />
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
index 05d1266d2ac..7734c19f311 100644
--- a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -1,12 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.UnitTests;
diff --git a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
new file mode 100644
index 00000000000..67d7cf784ef
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
@@ -0,0 +1,148 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.BuildCheckManagerProvider;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    public class TaskInvocationAnalysisDataTests : IDisposable
+    {
+        internal sealed class TestAnalyzer : BuildAnalyzer
+        {
+            #region BuildAnalyzer initialization
+
+            public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0000", "TestRule", "TestDescription", "TestMessage",
+                new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+
+            public override string FriendlyName => "MSBuild.TestAnalyzer";
+
+            public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+
+            public override void Initialize(ConfigurationContext configurationContext)
+            { }
+
+            public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+            {
+                registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);
+            }
+
+            #endregion
+
+            /// <summary>
+            /// Stores all TaskInvocationAnalysisData reported during the build.
+            /// </summary>
+            public List<TaskInvocationAnalysisData> AnalysisData = new();
+
+            private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+            {
+                AnalysisData.Add(context.Data);
+            }
+        }
+
+        private static TestAnalyzer? s_testAnalyzer;
+
+        public TaskInvocationAnalysisDataTests()
+        {
+            BuildCheckManager.s_testFactoriesPerDataSource =
+            [
+                // BuildCheckDataSource.EventArgs
+                [
+                    ([TestAnalyzer.SupportedRule.Id], true, () => (s_testAnalyzer = new TestAnalyzer())),
+                ],
+                // BuildCheckDataSource.Execution
+                [],
+            ];
+
+            s_testAnalyzer?.AnalysisData.Clear();
+        }
+
+        public void Dispose()
+        {
+            BuildCheckManager.s_testFactoriesPerDataSource = null;
+        }
+
+        private void BuildProject(string taskInvocation)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                var testProject = env.CreateTestProjectWithFiles($"<Project><Target Name=\"Build\">{taskInvocation}</Target></Project>");
+
+                using (var buildManager = new BuildManager())
+                {
+                    var request = new BuildRequestData(testProject.ProjectFile, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, [], null, BuildRequestDataFlags.None);
+                    var parameters = new BuildParameters
+                    {
+                        LogTaskInputs = true,
+                        IsBuildCheckEnabled = true,
+                        ShutdownInProcNodeOnBuildFinish = true,
+                    };
+
+                    var result = buildManager.Build(parameters, request);
+
+                    result.OverallResult.ShouldBe(BuildResultCode.Success);
+                }
+
+                foreach (var data in s_testAnalyzer!.AnalysisData)
+                {
+                    data.ProjectFilePath.ShouldBe(testProject.ProjectFile);
+                    data.TaskInvocationLocation.Line.ShouldBeGreaterThan(0);
+                    data.TaskInvocationLocation.Column.ShouldBeGreaterThan(0);
+                }
+            }
+        }
+
+        [Fact]
+        public void ReportsSimpleTaskParameters()
+        {
+            BuildProject("<Message Text='Hello'/>");
+
+            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
+            var data = s_testAnalyzer.AnalysisData[0];
+            data.TaskName.ShouldBe("Message");
+            data.Parameters.Count.ShouldBe(1);
+            data.Parameters["Text"].IsOutput.ShouldBe(false);
+            data.Parameters["Text"].Value.ShouldBe("Hello");
+        }
+
+        [Theory]
+        [InlineData("<Output TaskParameter='CombinedPaths' ItemName='OutputDirectories' />")]
+        [InlineData("<Output TaskParameter='CombinedPaths' PropertyName='OutputDirectories' />")]
+        public void ReportsComplexTaskParameters(string outputElement)
+        {
+            BuildProject($"""
+                <ItemGroup>
+                  <TestItem Include='item1;item2'/>
+                </ItemGroup>
+                <CombinePath BasePath='base' Paths='@(TestItem)'>
+                    {outputElement}
+                </CombinePath>
+            """);
+
+            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
+            var data = s_testAnalyzer.AnalysisData[0];
+            data.TaskName.ShouldBe("CombinePath");
+            data.Parameters.Count.ShouldBe(3);
+
+            data.Parameters["Paths"].IsOutput.ShouldBe(false);
+            data.Parameters["Paths"].Value.ShouldBeAssignableTo(typeof(IList));
+            IList listValue = (IList)data.Parameters["Paths"].Value!;
+            listValue.Count.ShouldBe(2);
+            listValue[0]!.ShouldBeAssignableTo(typeof(ITaskItem));
+            listValue[1]!.ShouldBeAssignableTo(typeof(ITaskItem));
+            ((ITaskItem)listValue[0]!).ItemSpec.ShouldBe("item1");
+            ((ITaskItem)listValue[1]!).ItemSpec.ShouldBe("item2");
+            data.Parameters["CombinedPaths"].IsOutput.ShouldBe(true);
+            data.Parameters["CombinedPaths"].Value.ShouldNotBeNull();
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
index 1097d29bafd..aa5beec8aa0 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <configuration>
-   <packageSources>
-
+  <packageSources>
   </packageSources>
 </configuration>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
index 9e71d7ff38f..0ffaa8d26b7 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
@@ -8,6 +8,7 @@
   <ItemGroup>
     <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
     <PackageReference Include="CustomAnalyzer2" Version="1.0.0"/>
+    <PackageReference Include="InvalidCustomAnalyzer" Version="1.0.0"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
index 1097d29bafd..1c0c23b1405 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
+++ b/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
@@ -1,6 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
 <configuration>
    <packageSources>
-
   </packageSources>
 </configuration>
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
new file mode 100644
index 00000000000..4e4cb1c0796
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
@@ -0,0 +1,17 @@
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
+  <!-- The properties need to be redefined to have a nuget package built as a part of MSBuild build. -->
+  <PropertyGroup>
+    <IsPackable>true</IsPackable>
+    <IsShipping>false</IsShipping>
+    <PackageVersion>1.0.0</PackageVersion>
+    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomAnalyzers</ArtifactsNonShippingPackagesDir>
+    <NoWarn>NU5101;NU5128;MSB3277;NU1507;NU1701;NU1702;NU5104</NoWarn>
+  </PropertyGroup>
+
+  <!-- In the real world scenario, the dependencies are added as Nuget PackageReference, modified for test purposes only. -->
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\Build\Microsoft.Build.csproj" IncludeInPackage="true" />
+  </ItemGroup>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.targets b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.targets
new file mode 100644
index 00000000000..a1ea76b439e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.targets
@@ -0,0 +1,41 @@
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+
+  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
+    <!-- Resolve the project references to get their output DLL paths -->
+    <ItemGroup>
+      <ResolvedProjectReference Include="@(ReferencePath)" Condition="%(ReferencePath.ReferenceSourceTarget) == 'ProjectReference'">
+        <OutputPath>%(ReferencePath.OriginalItemSpec)</OutputPath>
+      </ResolvedProjectReference>
+
+      <!-- Add the DLL produced by the referenced project to the _PackagesToPack list -->
+      <_PackagesToPack Include="@(ResolvedProjectReference->'%(OutputPath)')">
+          <NuGetPackageId>@(ResolvedProjectReference->'%(AssemblyName)')</NuGetPackageId>
+      </_PackagesToPack>
+    </ItemGroup>
+    
+    <!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key.
+       This produces a new list containing the DLL path and the "IncludeInPackage" metadata-->
+    <JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="NuGetPackageId" LeftMetadata="*" Right="@(ProjectReference)" RightKey="" RightMetadata="*" ItemSpecToUse="Left">
+      <Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
+    </JoinItems>
+
+    <ItemGroup>
+      <Message Importance="High" Text="Adding DLLs from the following packages: @(_PackagesToPack->'%(NuGetPackageId)')" />
+
+      <!-- Remove NETStandard DLLs -->
+      <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(NuGetPackageId) == 'NETStandard.Library'" />
+      <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(_PackagesToPack.IncludeInPackage) != 'true'" />
+    </ItemGroup>
+
+    <Message Importance="High" Text="Adding DLLs from the following packages: @(ResolvedProjectReferences->'%(OutputPath)%(AssemblyName).dll')" />
+
+    <ItemGroup>
+      <!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
+      <None Include="@(_PackagesToPack)" Pack="true" PackagePath="build" Visible="false" />
+
+      <!-- Add the DLL produced by the current project to the NuGet package -->
+      <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
+    </ItemGroup>
+  </Target>
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
index f780e9eb213..f27ab620690 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
@@ -1,29 +1,17 @@
 <Project Sdk="Microsoft.NET.Sdk">
 
+  <Import Project="..\Common\CommonTest.props" />
+
   <PropertyGroup>
     <TargetFramework>netstandard2.0</TargetFramework>
-    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
-    <IncludeBuildOutput>false</IncludeBuildOutput>
-    <!-- The output structure was modified for msbuild development needs.-->
-    <NoWarn>NU5101;NU5128;MSB3277</NoWarn>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
   </PropertyGroup>
 
   <ItemGroup>
     <None Include="CustomAnalyzer.props" Pack="true" PackagePath="build\CustomAnalyzer.props" />
+    <Content Include="README.md" />
   </ItemGroup>
 
-  <ItemGroup>
-    <!-- In the real world scenario, the DLLs are added as PackageReference, modified for test purposes only. -->
-    <Reference Include="Microsoft.Build">
-      <HintPath>$(MSBuildProjectDirectory)\..\..\Microsoft.Build.dll</HintPath>
-    </Reference>
-  </ItemGroup>
-
-  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
-    <ItemGroup>
-      <!-- Add the DLL produced by the current project to the NuGet package -->
-      <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
-    </ItemGroup>
-  </Target>
+  <Import Project="..\Common\CommonTest.targets" />
 
 </Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
index 17007b03785..a405546f1cc 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
@@ -1,28 +1,17 @@
 <Project Sdk="Microsoft.NET.Sdk">
 
+  <Import Project="..\Common\CommonTest.props" />
+
   <PropertyGroup>
     <TargetFramework>netstandard2.0</TargetFramework>
-    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
-    <!-- The output structure was modified for msbuild development needs.-->
-    <NoWarn>NU5101;NU5128;MSB3277</NoWarn>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
   </PropertyGroup>
 
   <ItemGroup>
     <None Include="CustomAnalyzer2.props" Pack="true" PackagePath="build\CustomAnalyzer2.props" />
+    <Content Include="README.md" />
   </ItemGroup>
 
-  <ItemGroup>
-    <!-- In the real world scenario, the DLLs are added as PackageReference, modified for test purposes only. -->
-    <Reference Include="Microsoft.Build">
-      <HintPath>$(MSBuildProjectDirectory)\..\..\Microsoft.Build.dll</HintPath>
-    </Reference>
-  </ItemGroup>
-
-  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
-    <ItemGroup>
-      <!-- Add the DLL produced by the current project to the NuGet package -->
-      <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="build" Visible="false" />
-    </ItemGroup>
-  </Target>
-
+  <Import Project="..\Common\CommonTest.targets" />
+  
 </Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
new file mode 100644
index 00000000000..e5f466ce414
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
@@ -0,0 +1,9 @@
+﻿using System.Collections.Generic;
+
+namespace InvalidCustomAnalyzer
+{
+    public sealed class InvalidAnalyzer
+    {
+        public string FriendlyName => "InvalidAnalyzer";
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
new file mode 100644
index 00000000000..4ef7f0674ca
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
@@ -0,0 +1,17 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <Import Project="..\Common\CommonTest.props" />
+
+  <PropertyGroup>
+    <TargetFramework>netstandard2.0</TargetFramework>
+    <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <None Include="InvalidCustomAnalyzer.props" Pack="true" PackagePath="build\InvalidCustomAnalyzer.props" />
+    <Content Include="README.md" />
+  </ItemGroup>
+
+  <Import Project="..\Common\CommonTest.targets" />
+
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
new file mode 100644
index 00000000000..52a9bab57c0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)InvalidCustomAnalyzer.dll))</MSBuildAnalyzer>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/Framework/Logging/AnsiDetector.cs b/src/Framework/Logging/AnsiDetector.cs
new file mode 100644
index 00000000000..2b0c0e8b38a
--- /dev/null
+++ b/src/Framework/Logging/AnsiDetector.cs
@@ -0,0 +1,53 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Portions of the code in this file were ported from the spectre.console by Patrik Svensson, Phil Scott, Nils Andresen
+// https://github.com/spectreconsole/spectre.console/blob/main/src/Spectre.Console/Internal/Backends/Ansi/AnsiDetector.cs
+// and from the supports-ansi project by Qingrong Ke
+// https://github.com/keqingrong/supports-ansi/blob/master/index.js
+
+using System;
+using System.Linq;
+using System.Text.RegularExpressions;
+
+namespace Microsoft.Build.Framework.Logging
+{
+    internal class AnsiDetector
+    {
+        private static readonly Regex[] terminalsRegexes =
+        {
+            new("^xterm"), // xterm, PuTTY, Mintty
+            new("^rxvt"), // RXVT
+            new("^(?!eterm-color).*eterm.*"), // Accepts eterm, but not eterm-color, which does not support moving the cursor, see #9950.
+            new("^screen"), // GNU screen, tmux
+            new("tmux"), // tmux
+            new("^vt100"), // DEC VT series
+            new("^vt102"), // DEC VT series
+            new("^vt220"), // DEC VT series
+            new("^vt320"), // DEC VT series
+            new("ansi"), // ANSI
+            new("scoansi"), // SCO ANSI
+            new("cygwin"), // Cygwin, MinGW
+            new("linux"), // Linux console
+            new("konsole"), // Konsole
+            new("bvterm"), // Bitvise SSH Client
+            new("^st-256color"), // Suckless Simple Terminal, st
+            new("alacritty"), // Alacritty
+        };
+
+        internal static bool IsAnsiSupported(string termType)
+        {
+            if (string.IsNullOrEmpty(termType))
+            {
+                return false;
+            }
+
+            if (terminalsRegexes.Any(regex => regex.IsMatch(termType)))
+            {
+                return true;
+            }
+
+            return false;
+        }
+    }
+}
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 747a065590e..3cd7934c726 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -10,7 +10,7 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-
+using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
 using Microsoft.Win32.SafeHandles;
@@ -1493,8 +1493,8 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         }
         else
         {
-            // On posix OSes we expect console always supports VT100 coloring unless it is explicitly marked as "dumb".
-            acceptAnsiColorCodes = Environment.GetEnvironmentVariable("TERM") != "dumb";
+            // On posix OSes detect whether the terminal supports VT100 from the value of the TERM environment variable.
+            acceptAnsiColorCodes = AnsiDetector.IsAnsiSupported(Environment.GetEnvironmentVariable("TERM"));
             // It wasn't redirected as tested above so we assume output is screen/console
             outputIsScreen = true;
         }
diff --git a/src/Framework/TaskParameterEventArgs.cs b/src/Framework/TaskParameterEventArgs.cs
index 7aa294f828c..8dcf97730c7 100644
--- a/src/Framework/TaskParameterEventArgs.cs
+++ b/src/Framework/TaskParameterEventArgs.cs
@@ -34,6 +34,8 @@ public class TaskParameterEventArgs : BuildMessageEventArgs
         /// </summary>
         public TaskParameterEventArgs(
             TaskParameterMessageKind kind,
+            string parameterName,
+            string propertyName,
             string itemType,
             IList items,
             bool logItemMetadata,
@@ -41,14 +43,57 @@ public TaskParameterEventArgs(
             : base(null, null, null, MessageImportance.Low, eventTimestamp)
         {
             Kind = kind;
+            ParameterName = parameterName;
+            PropertyName = propertyName;
             ItemType = itemType;
             Items = items;
             LogItemMetadata = logItemMetadata;
         }
 
+        /// <summary>
+        /// Creates an instance of this class for the given task parameter.
+        /// </summary>
+        public TaskParameterEventArgs(
+            TaskParameterMessageKind kind,
+            string itemType,
+            IList items,
+            bool logItemMetadata,
+            DateTime eventTimestamp)
+            : this(kind, parameterName: null, propertyName: null, itemType, items, logItemMetadata, eventTimestamp)
+        { }
+
+        /// <summary>
+        /// The kind of event represented by this instance.
+        /// </summary>
         public TaskParameterMessageKind Kind { get; private set; }
+
+        /// <summary>
+        /// The name of the parameter if <see cref="Kind"/> is <see cref="TaskParameterMessageKind.TaskInput"/> or <see cref="TaskParameterMessageKind.TaskOutput"/>,
+        /// null otherwise.
+        /// </summary>
+        public string ParameterName { get; private set; }
+
+        /// <summary>
+        /// The name of the property if <see cref="Kind"/> is <see cref="TaskParameterMessageKind.TaskOutput"/> and the task output
+        /// is assigned to a property, null otherwise.
+        /// </summary>
+        public string PropertyName { get; private set; }
+
+        /// <summary>
+        /// The name of the item being manipulated, e.g. "Compile" if this is an item operation. If this object represents a task input, this property should be set
+        /// to the same value as <see cref="ParameterName"/> for backward compatibility. Similarly, if this object represents a task output assigned to a property,
+        /// this should be set to the same value as <see cref="PropertyName"/> for backward compatibility.
+        /// </summary>
         public string ItemType { get; private set; }
+
+        /// <summary>
+        /// The values being manipulated (added, removed, passed to/from task).
+        /// </summary>
         public IList Items { get; private set; }
+
+        /// <summary>
+        /// True if the <see cref="Message"/> string should include metadata.
+        /// </summary>
         public bool LogItemMetadata { get; private set; }
 
         /// <summary>
@@ -85,6 +130,8 @@ internal override void CreateFromStream(BinaryReader reader, int version)
             RawTimestamp = reader.ReadTimestamp();
             BuildEventContext = reader.ReadOptionalBuildEventContext();
             Kind = (TaskParameterMessageKind)reader.Read7BitEncodedInt();
+            ParameterName = reader.ReadOptionalString();
+            PropertyName = reader.ReadOptionalString();
             ItemType = reader.ReadOptionalString();
             LineNumber = reader.Read7BitEncodedInt();
             ColumnNumber = reader.Read7BitEncodedInt();
@@ -134,6 +181,8 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteTimestamp(RawTimestamp);
             writer.WriteOptionalBuildEventContext(BuildEventContext);
             writer.Write7BitEncodedInt((int)Kind);
+            writer.WriteOptionalString(ParameterName);
+            writer.WriteOptionalString(PropertyName);
             writer.WriteOptionalString(ItemType);
             writer.Write7BitEncodedInt(LineNumber);
             writer.Write7BitEncodedInt(ColumnNumber);
diff --git a/src/Framework/TaskStartedEventArgs.cs b/src/Framework/TaskStartedEventArgs.cs
index 288a0193524..db1f450e95b 100644
--- a/src/Framework/TaskStartedEventArgs.cs
+++ b/src/Framework/TaskStartedEventArgs.cs
@@ -171,22 +171,22 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         public string ProjectFile => projectFile;
 
         /// <summary>
-        /// MSBuild file where this task was defined.
+        /// MSBuild file in which this task was invoked.
         /// </summary>
         public string TaskFile => taskFile;
 
         /// <summary>
-        /// Line number of the task invocation in the project file
+        /// Line number of the task invocation in the project file.
         /// </summary>
         public int LineNumber { get; internal set; }
 
         /// <summary>
-        /// Column number of the task invocation in the project file
+        /// Column number of the task invocation in the project file.
         /// </summary>
         public int ColumnNumber { get; internal set; }
 
         /// <summary>
-        /// The location of the assembly containing the implementation of the task
+        /// The location of the assembly containing the implementation of the task.
         /// </summary>
         public string TaskAssemblyLocation { get; private set; }
 
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index f396ca22cfe..b84cdc9dcd6 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -194,7 +194,6 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '$(DotNetBuildFromSource)' != 'true'">
     <!-- Bump these to the latest version despite transitive references to older -->
     <PackageReference Include="System.Private.Uri" PrivateAssets="all" />
-    <PackageReference Include="System.Runtime" PrivateAssets="all" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
diff --git a/src/MSBuild/TerminalLogger/Terminal.cs b/src/MSBuild/TerminalLogger/Terminal.cs
index 91565e1f797..16651d85fb9 100644
--- a/src/MSBuild/TerminalLogger/Terminal.cs
+++ b/src/MSBuild/TerminalLogger/Terminal.cs
@@ -200,6 +200,15 @@ public void WriteColorLine(TerminalColor color, string text)
     /// <inheritdoc/>
     public void Dispose()
     {
-        Console.OutputEncoding = _originalOutputEncoding;
+        try
+        {
+            Console.OutputEncoding = _originalOutputEncoding;
+        }
+        catch
+        {
+            // In some terminal emulators setting back the previous console output encoding fails.
+            // See https://github.com/dotnet/msbuild/issues/9662.
+            // We do not want to throw an exception if it happens, since it is a non-essentual failure in the logger.
+        }
     }
 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 7c2c416d00a..47ba769c277 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1344,7 +1344,7 @@ internal static bool BuildProject(
                 // This is a hack for now to make sure the perf hit only happens
                 // on diagnostic. This should be changed to pipe it through properly,
                 // perhaps as part of a fuller tracing feature.
-                bool logTaskInputs = verbosity == LoggerVerbosity.Diagnostic;
+                bool logTaskInputs = verbosity == LoggerVerbosity.Diagnostic || isBuildCheckEnabled;
 
                 if (!logTaskInputs)
                 {
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 6634af8df2f..470c4c7dd7d 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -136,6 +136,9 @@
     <Compile Include="..\Framework\NativeMethods.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
+    <Compile Include="..\Framework\Logging\AnsiDetector.cs">
+      <Link>AnsiDetector.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\NodeBuildComplete.cs">
       <Link>NodeBuildComplete.cs</Link>
     </Compile>
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 3a67481a23e..0eacfd24c73 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -1458,7 +1458,7 @@ internal static string GetDirectoryNameOfFileAbove(string startingDirectory, str
             while (lookInDirectory != null);
 
             // When we didn't find the location, then return an empty string
-            return String.Empty;
+            return string.Empty;
         }
 
         /// <summary>
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 6b8354dc0da..8264bc07be9 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -57,7 +57,8 @@ public static string ExecBootstrapedMSBuild(
             out bool successfulExit,
             bool shellExecute = false,
             ITestOutputHelper outputHelper = null,
-            bool attachProcessId = true)
+            bool attachProcessId = true,
+            int timeoutMilliseconds = 30_000)
         {
             BootstrapLocationAttribute attribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
                                                    ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
@@ -69,7 +70,7 @@ public static string ExecBootstrapedMSBuild(
 #else
             string pathToExecutable = Path.Combine(binaryFolder, "MSBuild.exe");
 #endif
-            return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper, attachProcessId);
+            return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper, attachProcessId, timeoutMilliseconds);
         }
 
         private static void AdjustForShellExecution(ref string pathToExecutable, ref string arguments)
@@ -97,7 +98,8 @@ public static string RunProcessAndGetOutput(
             out bool successfulExit,
             bool shellExecute = false,
             ITestOutputHelper outputHelper = null,
-            bool attachProcessId = true)
+            bool attachProcessId = true,
+            int timeoutMilliseconds = 30_000)
         {
             if (shellExecute)
             {
@@ -138,16 +140,17 @@ public static string RunProcessAndGetOutput(
                 p.BeginErrorReadLine();
                 p.StandardInput.Dispose();
 
+                TimeSpan timeout = TimeSpan.FromMilliseconds(timeoutMilliseconds);
                 if (Traits.Instance.DebugUnitTests)
                 {
                     p.WaitForExit();
                 }
-                else if (!p.WaitForExit(30_000))
+                else if (!p.WaitForExit(timeoutMilliseconds))
                 {
-                    // Let's not create a unit test for which we need more than 30 sec to execute.
+                    // Let's not create a unit test for which we need more than requested timeout to execute.
                     // Please consider carefully if you would like to increase the timeout.
                     p.KillTree(1000);
-                    throw new TimeoutException($"Test failed due to timeout: process {p.Id} is active for more than 30 sec.");
+                    throw new TimeoutException($"Test failed due to timeout: process {p.Id} is active for more than {timeout.TotalSeconds} sec.");
                 }
 
                 // We need the WaitForExit call without parameters because our processing of output/error streams is not synchronous.
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index 822c68ad317..11f275f9709 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -26,7 +26,7 @@ public ToolTask_Tests(ITestOutputHelper testOutput)
             _output = testOutput;
         }
 
-        private sealed class MyTool : ToolTask, IDisposable
+        private class MyTool : ToolTask, IDisposable
         {
             private string _fullToolName;
             private string _responseFileCommands = string.Empty;
@@ -737,6 +737,41 @@ public void VisualBasicLikeEscapedQuotesInCommandAreNotMadeForwardSlashes()
             engine.Errors.ShouldBe(0);
         }
 
+        private sealed class MyToolWithCustomProcess : MyTool
+        {
+            protected override Process StartToolProcess(Process proc)
+            {
+                Process customProcess = new Process();
+                customProcess.StartInfo = proc.StartInfo;
+
+                customProcess.EnableRaisingEvents = true;
+                customProcess.Exited += ReceiveExitNotification;
+
+                customProcess.ErrorDataReceived += ReceiveStandardErrorData;
+                customProcess.OutputDataReceived += ReceiveStandardOutputData;
+
+                return base.StartToolProcess(customProcess);
+            }
+        }
+
+        [Fact]
+        public void UsesCustomProcess()
+        {
+            using (MyToolWithCustomProcess t = new MyToolWithCustomProcess())
+            {
+                MockEngine3 engine = new MockEngine3();
+                t.BuildEngine = engine;
+                t.MockCommandLineCommands = NativeMethodsShared.IsWindows
+                    ? "/C echo hello_stdout & echo hello_stderr >&2"
+                    : "-c \"echo hello_stdout ; echo hello_stderr >&2\"";
+
+                t.Execute();
+
+                engine.AssertLogContains("\nhello_stdout");
+                engine.AssertLogContains("\nhello_stderr");
+            }
+        }
+
         /// <summary>
         /// Verifies that a ToolTask running under the command processor on Windows has autorun
         /// disabled or enabled depending on an escape hatch.
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 52313983a33..2443ff50c43 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -1172,7 +1172,7 @@ private void ReceiveTimeoutNotification(object unused)
         /// <remarks>This method is used as a System.EventHandler delegate.</remarks>
         /// <param name="sender"></param>
         /// <param name="e"></param>
-        private void ReceiveExitNotification(object sender, EventArgs e)
+        protected void ReceiveExitNotification(object sender, EventArgs e)
         {
             ErrorUtilities.VerifyThrow(_toolExited != null,
                 "The signalling event for tool exit must be available.");
@@ -1195,7 +1195,7 @@ private void ReceiveExitNotification(object sender, EventArgs e)
         /// <remarks>This method is used as a System.Diagnostics.DataReceivedEventHandler delegate.</remarks>
         /// <param name="sender"></param>
         /// <param name="e"></param>
-        private void ReceiveStandardErrorData(object sender, DataReceivedEventArgs e) => ReceiveStandardErrorOrOutputData(e, _standardErrorData, _standardErrorDataAvailable);
+        protected void ReceiveStandardErrorData(object sender, DataReceivedEventArgs e) => ReceiveStandardErrorOrOutputData(e, _standardErrorData, _standardErrorDataAvailable);
 
         /// <summary>
         /// Queues up the output from the stdout stream of the process executing
@@ -1206,7 +1206,7 @@ private void ReceiveExitNotification(object sender, EventArgs e)
         /// <remarks>This method is used as a System.Diagnostics.DataReceivedEventHandler delegate.</remarks>
         /// <param name="sender"></param>
         /// <param name="e"></param>
-        private void ReceiveStandardOutputData(object sender, DataReceivedEventArgs e) => ReceiveStandardErrorOrOutputData(e, _standardOutputData, _standardOutputDataAvailable);
+        protected void ReceiveStandardOutputData(object sender, DataReceivedEventArgs e) => ReceiveStandardErrorOrOutputData(e, _standardOutputData, _standardOutputDataAvailable);
 
         /// <summary>
         /// Queues up the output from either the stderr or stdout stream of the
