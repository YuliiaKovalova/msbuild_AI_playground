diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index cb827f778a0..700cef707b2 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -221,6 +221,7 @@ stages:
 - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
   - template: eng\common\templates\post-build\post-build.yml
     parameters:
+      publishingInfraVersion: 3
       # Symbol validation is not entirely reliable as of yet, so should be turned off until
       # https://github.com/dotnet/arcade/issues/2871 is resolved.
       enableSymbolValidation: false
diff --git a/Changelog.md b/Changelog.md
index b5c4a4a5807..a5c6b217f5e 100644
--- a/Changelog.md
+++ b/Changelog.md
@@ -10,6 +10,7 @@ This version of MSBuild will ship with Visual Studio 2019 version 16.10.0 and .N
 * MSBuild is faster and uses less memory.
 * Binary logs are smaller and have less performance overhead.
 * Tasks can now opt into resource management to improve parallelism in large builds.
+* It's now possible to optionally embed arbitrary files in a binary log.
 
 ### Detailed release notes
 
@@ -18,7 +19,6 @@ This version of MSBuild will ship with Visual Studio 2019 version 16.10.0 and .N
 * Projects can now specify `AdditionalTargetFrameworkInfoProperty` items to indicate that referencing projects should get those properties exposed as `AdditionalPropertiesFromProject` metadata on resolved reference items. (#5994).
 * The `Unzip` task now accepts `Include` and `Exclude` arguments to filter what is extracted from the zip file (#6018). Thanks, @IvanLieckens!
 * The `-graph:noBuild` command line argument can be used to validate that a graph is buildable without actually building it (#6016).
-* When building a solution filter, `$(SolutionFilterName)` is now defined (#6171).
 * `TaskParameterEventArgs` allow logging task parameters and values in a compact, structured way (#6155). Thanks, @KirillOsenkov!
 * ClickOnce publish now supports Ready To Run (#6244).
 * .NET 5.0 applications may now specify a toolset configuration file (#6220).
@@ -28,6 +28,8 @@ This version of MSBuild will ship with Visual Studio 2019 version 16.10.0 and .N
 * `ProjectEvaluationFinished` now has fields for properties and items (#6287). Thanks, @KirillOsenkov!
 * `WriteCodeFragment` can now write assembly attributes of specified types, and infers some common types (#6285). Thanks, @reduckted!
 * The `-detailedSummary` option now accepts a boolean argument, preventing dumping details to the console logger when building with `-bl -ds:false` (#6338). Thanks, @KirillOsenkov!
+* Binary logs now include files listed in the item `EmbedInBinlog` as well as MSBuild projects (#6339). Thanks, @KirillOsenkov!
+* The `FindInvalidProjectReferences` task is now available in .NET Core/5.0+ scenarios (#6365).
 
 #### Changed
 
@@ -44,6 +46,7 @@ This version of MSBuild will ship with Visual Studio 2019 version 16.10.0 and .N
 * `Log.HasLoggedError` now respects `MSBuildWarningsAsErrors` (#6174).
 * `TargetPath` metadata is now respected on items that copy to output directories, and takes precedence over `Link` (#6237).
 * The `Restore` operation now fails when SDKs are unresolvable or no `Restore` target exists (#6312).
+* `MSBuild.exe.config` now has explicit binding redirects for all assemblies in the MSBuild VSIX (#6334).
 
 #### Fixed
 
@@ -56,15 +59,17 @@ This version of MSBuild will ship with Visual Studio 2019 version 16.10.0 and .N
 * Improved error messages when encountering a `BadImageReferenceException` in `ResolveAssemblyReferences` (#6240, #6270). Thanks, @FiniteReality!
 * Escape special characters in `Exec`’s generated batch files, allowing builds as users with some special characters in their Windows username (#6233).
 * Permit comments and trailing commas in solution filter files (#6346).
+* Exceptions thrown from experimental cache plugins are now handled and logged better (#6345, #6368).
 
 #### Infrastructure
 
 * Update to Arcade 5.0 and .NET 5.0 (#5836).
 * The primary development branch is now named `main`.
-* Test robustness improvements (#6055). Thanks, @tmds!
+* Test robustness improvements (#6055, #6336, #6337, #6332). Thanks, @tmds and @KirillOsenkov!
 * Remove unnecessary NuGet package references (#6036). Thanks, @teo-tsirpanis!
 * Correctly mark .NET Framework 3.5 reference assembly package dependency as private (#6214).
 * Our own builds opt into text-based performance logging (#6274).
+* Update to Arcade publishing v3 (#6349).
 
 #### Documentation
 
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 1e25829f60b..b5ec4e3736b 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -27,6 +27,7 @@ The opt-out comes in the form of setting the environment variable `MSBuildDisabl
 - [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
 - [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
 - [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
+- [Fail restore operations when there is no `Restore` target or an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6312)
 ### 17.0
 
 ## Change Waves No Longer In Rotation
diff --git a/eng/Packages.props b/eng/Packages.props
index 91058315eaa..d6917bd7207 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -1,4 +1,8 @@
 <Project>
+  <!--
+    Make sure to update the binding redirects (in src\MSBuild\app.config and src\MSBuild\app.amd64.config) for any changes to
+    the list of assemblies redistributed by MSBuild (non-MSBuild assemblies in the .vsix package).
+     -->
   <ItemGroup>
     <PackageReference Update="BenchmarkDotNet" Version="0.12.1" />
     <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
diff --git a/eng/Publishing.props b/eng/Publishing.props
new file mode 100644
index 00000000000..6db69f7afa9
--- /dev/null
+++ b/eng/Publishing.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+    <PropertyGroup>
+        <PublishingVersion>3</PublishingVersion>
+    </PropertyGroup>
+</Project>
\ No newline at end of file
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 13d8260275b..0eefd4337d0 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21160.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="5.0.0-beta.21221.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>670382be6a978ba401c21c57ba44311199d2682a</Sha>
+      <Sha>e304b1672084f2274b5d838893d894fa5cf8abea</Sha>
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="5.9.1-rc.8">
       <Uri>https://github.com/nuget/nuget.client</Uri>
diff --git a/global.json b/global.json
index 5aff70ee07d..25f7aa05985 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21160.3"
+    "Microsoft.DotNet.Arcade.Sdk": "5.0.0-beta.21221.5"
   }
 }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 1cefcd56250..f8c26c263dd 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -309,6 +309,18 @@ public FindInList() { }
         public bool MatchFileNameOnly { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class FindInvalidProjectReferences : Microsoft.Build.Tasks.TaskExtension
+    {
+        public FindInvalidProjectReferences() { }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] InvalidReferences { get { throw null; } }
+        public Microsoft.Build.Framework.ITaskItem[] ProjectReferences { get { throw null; } set { } }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public string TargetPlatformIdentifier { get { throw null; } set { } }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public string TargetPlatformVersion { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public partial class FindUnderPath : Microsoft.Build.Tasks.TaskExtension
     {
         public FindUnderPath() { }
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
index e435979d2b2..a8564cf317b 100644
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
@@ -600,5 +600,7 @@ public enum VisualStudioVersion
         Version140 = 3,
         Version150 = 4,
         VersionLatest = 4,
+        Version160 = 5,
+        Version170 = 6,
     }
 }
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
index d77c4295057..9d7111dfe72 100644
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
@@ -434,5 +434,7 @@ public enum VisualStudioVersion
         Version140 = 3,
         Version150 = 4,
         VersionLatest = 4,
+        Version160 = 5,
+        Version170 = 6,
     }
 }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 53c843c112a..0c3ab22d801 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -1475,6 +1475,12 @@ internal ProjectCacheDescriptor() { }
         public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
         public string GetDetailedDescription() { throw null; }
     }
+    public sealed partial class ProjectCacheException : System.Exception
+    {
+        internal ProjectCacheException() { }
+        public string ErrorCode { get { throw null; } }
+        public bool HasBeenLoggedByProjectCache { get { throw null; } }
+    }
     public abstract partial class ProjectCachePluginBase
     {
         protected ProjectCachePluginBase() { }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index b1f8429b5cb..9dc716a4007 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -1469,6 +1469,12 @@ internal ProjectCacheDescriptor() { }
         public static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) { throw null; }
         public string GetDetailedDescription() { throw null; }
     }
+    public sealed partial class ProjectCacheException : System.Exception
+    {
+        internal ProjectCacheException() { }
+        public string ErrorCode { get { throw null; } }
+        public bool HasBeenLoggedByProjectCache { get { throw null; } }
+    }
     public abstract partial class ProjectCachePluginBase
     {
         protected ProjectCachePluginBase() { }
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 6e1556b5712..2520bc41bb6 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -19,6 +19,7 @@
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
+using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
 
@@ -328,31 +329,28 @@ public void MSBuildLastTaskResult()
         /// else could let the item get corrupt (inconsistent values for Filename and FullPath, for example)
         /// </summary>
         [Fact]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        [Trait("Category", "mono-osx-failing")]
         public void TasksCanAddRecursiveDirBuiltInMetadata()
         {
-            MockLogger logger = new MockLogger();
+            MockLogger logger = new MockLogger(this._testOutput);
 
-            string projectFileContents = ObjectModelHelpers.CleanupFileContents(@"
-<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+            string projectFileContents = ObjectModelHelpers.CleanupFileContents($@"
+<Project>
 <Target Name='t'>
- <CreateItem Include='$(programfiles)\reference assemblies\**\*.dll;'>
+ <CreateItem Include='{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}\**\*.dll'>
    <Output TaskParameter='Include' ItemName='x' />
  </CreateItem>
 <Message Text='@(x)'/>
- <Message Text='[%(x.RecursiveDir)]'/>                    
+ <Message Text='[%(x.RecursiveDir)]'/>
 </Target>
 </Project>");
 
             Project project = new Project(XmlReader.Create(new StringReader(projectFileContents)));
-            List<ILogger> loggers = new List<ILogger>();
-            loggers.Add(logger);
-            bool result = project.Build("t", loggers);
+            project.Build("t", new[] { logger }).ShouldBeTrue();
 
-            Assert.True(result);
-            logger.AssertLogDoesntContain("[]");
+            // Assuming the current directory of the test .dll has at least one subfolder
+            // such as Roslyn, the log will contain [Roslyn\] (or [Roslyn/] on Unix)
+            string slashAndBracket = Path.DirectorySeparatorChar.ToString() + "]";
+            logger.AssertLogContains(slashAndBracket);
             logger.AssertLogDoesntContain("MSB4118");
             logger.AssertLogDoesntContain("MSB3031");
         }
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index df36e0dfd2e..8ccde2767a9 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -192,7 +192,7 @@ char Chr(int projectNumber)
         }
 
         [Flags]
-        public enum ExceptionLocations
+        public enum ErrorLocations
         {
             Constructor = 1 << 0,
             BeginBuildAsync = 1 << 1,
@@ -200,6 +200,12 @@ public enum ExceptionLocations
             EndBuildAsync = 1 << 3
         }
 
+        public enum ErrorKind
+        {
+            Exception,
+            LoggedError
+        }
+
         public class InstanceMockCache : ProjectCachePluginBase
         {
             private readonly GraphCacheResponse? _testData;
@@ -791,84 +797,232 @@ public static IEnumerable<object[]> CacheExceptionLocationsTestData
         {
             get
             {
-                yield return new object[]{ExceptionLocations.Constructor};
+                // Plugin constructors cannot log errors, they can only throw exceptions.
+                yield return new object[] { ErrorLocations.Constructor, ErrorKind.Exception };
 
-                yield return new object[]{ExceptionLocations.BeginBuildAsync};
-                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync};
-                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync | ExceptionLocations.EndBuildAsync};
-                yield return new object[]{ExceptionLocations.BeginBuildAsync | ExceptionLocations.EndBuildAsync};
+                foreach (var errorKind in new[]{ErrorKind.Exception, ErrorKind.LoggedError})
+                {
+                    yield return new object[] { ErrorLocations.BeginBuildAsync, errorKind };
+                    yield return new object[] { ErrorLocations.BeginBuildAsync | ErrorLocations.GetCacheResultAsync, errorKind };
+                    yield return new object[] { ErrorLocations.BeginBuildAsync | ErrorLocations.GetCacheResultAsync | ErrorLocations.EndBuildAsync, errorKind };
+                    yield return new object[] { ErrorLocations.BeginBuildAsync | ErrorLocations.EndBuildAsync, errorKind };
 
-                yield return new object[]{ExceptionLocations.GetCacheResultAsync};
-                yield return new object[]{ExceptionLocations.GetCacheResultAsync | ExceptionLocations.EndBuildAsync};
+                    yield return new object[] { ErrorLocations.GetCacheResultAsync, errorKind };
+                    yield return new object[] { ErrorLocations.GetCacheResultAsync | ErrorLocations.EndBuildAsync, errorKind };
 
-                yield return new object[]{ExceptionLocations.EndBuildAsync};
+                    yield return new object[] { ErrorLocations.EndBuildAsync, errorKind };
+                }
             }
         }
 
         [Theory]
         [MemberData(nameof(CacheExceptionLocationsTestData))]
-        public void EngineShouldHandleExceptionsFromCachePlugin(ExceptionLocations exceptionLocations)
+        public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorLocations errorLocations, ErrorKind errorKind)
         {
             _env.DoNotLaunchDebugger();
 
+            SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
+
             var project = _env.CreateFile("1.proj", @$"
                     <Project>
                         <Target Name=`Build`>
-                            <Message Text=`Hello EngineShouldHandleExceptionsFromCachePlugin` Importance=`High` />
+                            <Message Text=`Hello World` Importance=`High` />
                         </Target>
                     </Project>".Cleanup());
 
-            SetEnvironmentForExceptionLocations(exceptionLocations);
+            Helpers.BuildManagerSession? buildSession = null;
+            MockLogger logger;
 
-            using var buildSession = new Helpers.BuildManagerSession(
-                _env,
-                new BuildParameters
+            try
+            {
+                buildSession = new Helpers.BuildManagerSession(
+                    _env,
+                    new BuildParameters
+                    {
+                        UseSynchronousLogging = true,
+                        ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
+                            SamplePluginAssemblyPath.Value,
+                            new[] {new ProjectGraphEntryPoint(project.Path)},
+                            null)
+                    });
+
+                logger = buildSession.Logger;
+                var buildResult = buildSession.BuildProjectFile(project.Path);
+
+                // Plugin construction, initialization, and query all end up throwing in BuildManager.ExecuteSubmission and thus
+                // mark the submission as failed with exception.
+                var exceptionsThatEndUpInBuildResult =
+                    ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync | ErrorLocations.GetCacheResultAsync;
+
+                if ((exceptionsThatEndUpInBuildResult & errorLocations) != 0)
                 {
-                    UseSynchronousLogging = true,
-                    ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
-                        SamplePluginAssemblyPath.Value,
-                        new[] {new ProjectGraphEntryPoint(project.Path)},
-                        null)
-                });
+                    buildResult.Exception.ShouldNotBeNull();
+                    buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
 
-            var logger = buildSession.Logger;
-            var buildResult = buildSession.BuildProjectFile(project.Path);
+                    if (errorKind == ErrorKind.Exception)
+                    {
+                        buildResult.Exception.InnerException!.ShouldNotBeNull();
+                        buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                    }
+                    else
+                    {
+                        buildResult.Exception.InnerException.ShouldBeNull();
+                    }
+                }
 
-            if (exceptionLocations == ExceptionLocations.EndBuildAsync || exceptionLocations == (ExceptionLocations.GetCacheResultAsync
-                                                                                                 | ExceptionLocations.EndBuildAsync))
+                // BuildManager.EndBuild calls plugin.EndBuild, so if only plugin.EndBuild fails it means everything else passed,
+                // so the build submission should be successful.
+                if (errorLocations == ErrorLocations.EndBuildAsync)
+                {
+                    buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+                }
+                else
+                {
+                    buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+                }
+            }
+            finally
             {
-                var e = Should.Throw<Exception>(() => buildSession.Dispose());
-                e.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+                // These exceptions prevent the creation of a plugin so there's no plugin to shutdown.
+                var exceptionsThatPreventEndBuildFromThrowing = ErrorLocations.Constructor |
+                                                                ErrorLocations.BeginBuildAsync;
+
+                if ((errorLocations & exceptionsThatPreventEndBuildFromThrowing) != 0 ||
+                    !errorLocations.HasFlag(ErrorLocations.EndBuildAsync))
+                {
+                    Should.NotThrow(() => buildSession!.Dispose());
+                }
+                else if (errorLocations.HasFlag(ErrorLocations.EndBuildAsync))
+                {
+                    var e = Should.Throw<ProjectCacheException>(() => buildSession!.Dispose());
+
+                    if (errorKind == ErrorKind.Exception)
+                    {
+                        e.InnerException!.ShouldNotBeNull();
+                        e.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+                    }
+                    else
+                    {
+                        e.InnerException.ShouldBeNull();
+                    }
+                }
+                else
+                {
+                    throw new NotImplementedException();
+                }
+            }
+
+            logger.BuildFinishedEvents.First().Succeeded.ShouldBeFalse();
+
+            // Plugin query must happen after plugin init. So if plugin init fails, then the plugin should not get queried.
+            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
+
+            if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) != 0)
+            {
+                logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: GetCacheResultAsync for");
+                logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: EndBuildAsync");
             }
             else
             {
-                buildSession.Dispose();
+                StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", expectedOccurrences: 1);
+                StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: EndBuildAsync", expectedOccurrences: 1);
             }
 
-            var exceptionsThatEndUpInBuildResult = ExceptionLocations.Constructor | ExceptionLocations.BeginBuildAsync | ExceptionLocations.GetCacheResultAsync;
+            logger.FullLog.ShouldNotContain("Cache plugin exception from");
 
-            if ((exceptionsThatEndUpInBuildResult & exceptionLocations) != 0)
+            if (errorKind == ErrorKind.LoggedError)
             {
-                buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
-                buildResult.Exception.Message.ShouldContain("Cache plugin exception from");
+                logger.FullLog.ShouldContain("Cache plugin logged error from");
             }
+        }
+
+        [Theory]
+        [MemberData(nameof(CacheExceptionLocationsTestData))]
+        public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocations errorLocations, ErrorKind errorKind)
+        {
+            _env.DoNotLaunchDebugger();
+
+            SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
+
+            var graph = Helpers.CreateProjectGraph(
+                _env,
+                new Dictionary<int, int[]>
+                {
+                    {1, new []{2}}
+                },
+                extraContentPerProjectNumber:null,
+                extraContentForAllNodes:@$"
+<ItemGroup>
+    <{ItemTypeNames.ProjectCachePlugin} Include=`{SamplePluginAssemblyPath.Value}` />
+    <{ItemTypeNames.ProjectReferenceTargets} Include=`Build` Targets=`Build` />
+</ItemGroup>
+<Target Name=`Build`>
+    <Message Text=`Hello World` Importance=`High` />
+</Target>
+"
+                );
+
+            var buildSession = new Helpers.BuildManagerSession(
+                _env,
+                new BuildParameters
+                {
+                    UseSynchronousLogging = true,
+                    MaxNodeCount = 1
+                });
 
-            if (exceptionLocations == ExceptionLocations.EndBuildAsync)
+            var logger = buildSession.Logger;
+
+            GraphBuildResult? buildResult = null;
+
+            try
             {
-                buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+                buildResult = buildSession.BuildGraph(graph);
+
+                logger.FullLog.ShouldContain("Loading the following project cache plugin:");
+
+                // Static graph build initializes and tears down the cache plugin so all cache plugin exceptions should end up in the GraphBuildResult
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+
+                buildResult.Exception.ShouldBeOfType<ProjectCacheException>();
+
+                if (errorKind == ErrorKind.Exception)
+                {
+                    buildResult.Exception.InnerException!.ShouldNotBeNull();
+                    buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from");
+                }
+
+                logger.FullLog.ShouldNotContain("Cache plugin exception from");
+
+                if (errorKind == ErrorKind.LoggedError)
+                {
+                    logger.FullLog.ShouldContain("Cache plugin logged error from");
+                }
+            }
+            finally
+            {
+                // Since all plugin exceptions during a graph build end up in the GraphBuildResult, they should not get rethrown by BM.EndBuild
+                Should.NotThrow(() => buildSession.Dispose());
             }
 
-            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ExceptionLocations.Constructor | ExceptionLocations.BeginBuildAsync;
+            logger.BuildFinishedEvents.First().Succeeded.ShouldBeFalse();
 
-            if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & exceptionLocations) != 0)
+            var exceptionsThatShouldPreventCacheQueryAndEndBuildAsync = ErrorLocations.Constructor | ErrorLocations.BeginBuildAsync;
+
+            if ((exceptionsThatShouldPreventCacheQueryAndEndBuildAsync & errorLocations) != 0)
             {
                 logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: GetCacheResultAsync for");
                 logger.FullLog.ShouldNotContain($"{AssemblyMockCache}: EndBuildAsync");
             }
             else
             {
-                logger.FullLog.ShouldContain($"{AssemblyMockCache}: GetCacheResultAsync for");
-                logger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
+                // There's two projects, so there should be two cache queries logged ... unless a cache queries throws an exception. That ends the build.
+                var expectedQueryOccurrences = errorLocations.HasFlag(ErrorLocations.GetCacheResultAsync)
+                    ? 1
+                    : 2;
+
+                StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", expectedQueryOccurrences);
+
+                StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: EndBuildAsync", expectedOccurrences: 1);
             }
         }
 
@@ -889,7 +1043,7 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
                         </Target>
                     </Project>".Cleanup());
 
-            SetEnvironmentForExceptionLocations(ExceptionLocations.EndBuildAsync);
+            SetEnvironmentForErrorLocations(ErrorLocations.EndBuildAsync, ErrorKind.Exception.ToString());
 
             using var buildSession = new Helpers.BuildManagerSession(
                 _env,
@@ -908,22 +1062,29 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
                 });
 
             buildResult!.OverallResult.ShouldBe(BuildResultCode.Failure);
-            buildResult.Exception.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+            buildResult.Exception.InnerException!.ShouldNotBeNull();
+            buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
 
             buildSession.Dispose();
 
-            Regex.Matches(logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync").Count.ShouldBe(1);
+            StringShouldContainSubstring(logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync", expectedOccurrences: 1);
+        }
+
+        private static void StringShouldContainSubstring(string aString, string substring, int expectedOccurrences)
+        {
+            aString.ShouldContain(substring);
+            Regex.Matches(aString, substring).Count.ShouldBe(expectedOccurrences);
         }
 
-        private void SetEnvironmentForExceptionLocations(ExceptionLocations exceptionLocations)
+        private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, string errorKind)
         {
-            foreach (var enumValue in Enum.GetValues(typeof(ExceptionLocations)))
+            foreach (var enumValue in Enum.GetValues(typeof(ErrorLocations)))
             {
-                var typedValue = (ExceptionLocations) enumValue;
-                if (exceptionLocations.HasFlag(typedValue))
+                var typedValue = (ErrorLocations) enumValue;
+                if (errorLocations.HasFlag(typedValue))
                 {
                     var exceptionLocation = typedValue.ToString();
-                    _env.SetEnvironmentVariable(exceptionLocation, "1");
+                    _env.SetEnvironmentVariable(exceptionLocation, errorKind);
                     _output.WriteLine($"Set exception location: {exceptionLocation}");
                 }
             }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index e795484bc95..ef032ea7791 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -754,26 +754,29 @@ public void EndBuild()
                 ErrorIfState(BuildManagerState.Idle, "NoBuildInProgress");
                 VerifyStateInternal(BuildManagerState.Building);
 
-                // If there are any submissions which never started, remove them now.
-                var submissionsToCheck = new List<BuildSubmission>(_buildSubmissions.Values);
-                foreach (BuildSubmission submission in submissionsToCheck)
-                {
-                    CheckSubmissionCompletenessAndRemove(submission);
-                }
-
-                var graphSubmissionsToCheck = new List<GraphBuildSubmission>(_graphBuildSubmissions.Values);
-                foreach (GraphBuildSubmission submission in graphSubmissionsToCheck)
-                {
-                    CheckSubmissionCompletenessAndRemove(submission);
-                }
-
                 _buildManagerState = BuildManagerState.WaitingForBuildToComplete;
             }
 
-            ILoggingService loggingService = ((IBuildComponentHost)this).LoggingService;
+            var exceptionsThrownInEndBuild = false;
 
             try
             {
+                lock (_syncLock)
+                {
+                    // If there are any submissions which never started, remove them now.
+                    var submissionsToCheck = new List<BuildSubmission>(_buildSubmissions.Values);
+                    foreach (BuildSubmission submission in submissionsToCheck)
+                    {
+                        CheckSubmissionCompletenessAndRemove(submission);
+                    }
+
+                    var graphSubmissionsToCheck = new List<GraphBuildSubmission>(_graphBuildSubmissions.Values);
+                    foreach (GraphBuildSubmission submission in graphSubmissionsToCheck)
+                    {
+                        CheckSubmissionCompletenessAndRemove(submission);
+                    }
+                }
+
                 _noActiveSubmissionsEvent.WaitOne();
                 ShutdownConnectedNodes(false /* normal termination */);
                 _noNodesActiveEvent.WaitOne();
@@ -798,17 +801,6 @@ public void EndBuild()
 
                 projectCacheShutdown?.Wait();
 
-                if (loggingService != null)
-                {
-                    // Override the build success if the user specified /warnaserror and any errors were logged outside of a build submission.
-                    if (_overallBuildSuccess && loggingService.HasBuildSubmissionLoggedErrors(BuildEventContext.InvalidSubmissionId))
-                    {
-                        _overallBuildSuccess = false;
-                    }
-
-                    loggingService.LogBuildFinished(_overallBuildSuccess);
-                }
-
 #if DEBUG
                 if (_projectStartedEvents.Count != 0)
                 {
@@ -839,14 +831,35 @@ public void EndBuild()
                     _resultsCache.ClearResults();
                 }
             }
-            catch (AggregateException ae) when (ae.InnerExceptions.Count == 1)
+            catch (Exception e)
             {
-                throw ae.InnerExceptions.First();
+                exceptionsThrownInEndBuild = true;
+
+                if (e is AggregateException ae && ae.InnerExceptions.Count == 1)
+                {
+                    e = ae.InnerExceptions.First();
+                }
+
+                throw e;
             }
             finally
             {
                 try
                 {
+                    ILoggingService loggingService = ((IBuildComponentHost)this).LoggingService;
+
+                    if (loggingService != null)
+                    {
+                        // Override the build success if the user specified /warnaserror and any errors were logged outside of a build submission.
+                        if (exceptionsThrownInEndBuild ||
+                            _overallBuildSuccess && loggingService.HasBuildSubmissionLoggedErrors(BuildEventContext.InvalidSubmissionId))
+                        {
+                            _overallBuildSuccess = false;
+                        }
+
+                        loggingService.LogBuildFinished(_overallBuildSuccess);
+                    }
+
                     ShutdownLoggingService(loggingService);
                 }
                 finally
@@ -1132,14 +1145,16 @@ void ExecuteSubmissionImpl()
                             ReportResultsToSubmission(result);
                         }
                     }
-                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
+                    // This catch should always be the first one because when this method runs in a separate thread
+                    // and throws an exception there is nobody there to observe the exception.
+                    catch (Exception ex) when (thisMethodIsAsync)
                     {
                         HandleExecuteSubmissionException(submission, ex);
-                        throw;
                     }
-                    catch (Exception ex) when (thisMethodIsAsync)
+                    catch (Exception ex) when (!ExceptionHandling.IsCriticalException(ex))
                     {
-                        OnThreadException(ex);
+                        HandleExecuteSubmissionException(submission, ex);
+                        throw;
                     }
                     void SubmitBuildRequest()
                     {
@@ -1264,11 +1279,17 @@ private void AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio
                 _buildParameters.ProjectCacheDescriptor == null)
             {
                 _projectCacheServiceInstantiatedByVSWorkaround = true;
-                ErrorUtilities.VerifyThrowInvalidOperation(
-                    ProjectCacheItems.Count == 1,
-                    "OnlyOneCachePluginMustBeSpecified",
-                    string.Join("; ", ProjectCacheItems.Values.Select(c => c.PluginPath)));
 
+                if (ProjectCacheItems.Count != 1)
+                {
+                    ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
+                        "OnlyOneCachePluginMustBeSpecified",
+                        string.Join("; ", ProjectCacheItems.Values.Select(c => c.PluginPath)));
+                }
+                
+                // Plugin needs the graph root (aka top BuildSubmission path, aka the solution path when in VS) which, under VS, is accessible
+                // only by evaluating the submission and retrieving the 'SolutionPath' property set by VS. This is also the reason why
+                // this method cannot be called from BeginBuild, because no build submissions are available there to extract the solution path from.
                 LoadSubmissionProjectIntoConfiguration(submission, config);
 
                 if (IsDesignTimeBuild(config.Project))
@@ -1282,6 +1303,7 @@ private void AutomaticallyDetectAndInstantiateProjectCacheServiceForVisualStudio
                 ErrorUtilities.VerifyThrow(
                     solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != "*Undefined*",
                     $"Expected VS to set a valid SolutionPath property but got: {solutionPath}");
+
                 ErrorUtilities.VerifyThrow(
                     FileSystems.Default.FileExists(solutionPath),
                     $"Solution file does not exist: {solutionPath}");
@@ -1741,11 +1763,15 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
                     var targetListTask = Task.Run(() => projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames));
 
-                    using var cacheService = cacheServiceTask.Result;
+                    using DisposablePluginService cacheService = cacheServiceTask.Result;
 
                     resultsPerNode = BuildGraph(projectGraph, targetListTask.Result, submission.BuildRequestData);
                 }
 
+                ErrorUtilities.VerifyThrow(
+                    submission.BuildResult?.Exception == null,
+                    "Exceptions only get set when the graph submission gets completed with an exception in OnThreadException. That should not happen during graph builds.");
+
                 // The overall submission is complete, so report it as complete
                 ReportResultsToSubmission(
                     new GraphBuildResult(
@@ -1805,7 +1831,8 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
         private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
             ProjectGraph projectGraph,
             IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode,
-            GraphBuildRequestData graphBuildRequestData)
+            GraphBuildRequestData graphBuildRequestData
+        )
         {
             var waitHandle = new AutoResetEvent(true);
             var graphBuildStateLock = new object();
@@ -1814,11 +1841,19 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
             var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);
             var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();
             var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);
+            Exception submissionException = null;
 
             while (blockedNodes.Count > 0 || buildingNodes.Count > 0)
             {
                 waitHandle.WaitOne();
 
+                // When a cache plugin is present, ExecuteSubmission(BuildSubmission) executes on a separate thread whose exceptions do not get observed.
+                // Observe them here to keep the same exception flow with the case when there's no plugins and ExecuteSubmission(BuildSubmission) does not run on a separate thread.
+                if (submissionException != null)
+                {
+                    throw submissionException;
+                }
+
                 lock (graphBuildStateLock)
                 {
                     var unblockedNodes = blockedNodes
@@ -1855,6 +1890,11 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
                         {
                             lock (graphBuildStateLock)
                             {
+                                if (submissionException == null && finishedBuildSubmission.BuildResult.Exception != null)
+                                {
+                                    submissionException = finishedBuildSubmission.BuildResult.Exception;
+                                }
+
                                 ProjectGraphNode finishedNode = buildingNodes[finishedBuildSubmission];
 
                                 finishedNodes.Add(finishedNode);
@@ -1872,14 +1912,14 @@ private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
             return resultsPerNode;
         }
 
-        private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(ProjectGraph projectGraph)
+        private DisposablePluginService SearchAndInitializeProjectCachePluginFromGraph(ProjectGraph projectGraph)
         {
             // TODO: Consider allowing parallel graph submissions, each with its own separate cache plugin. Right now the second graph submission with a cache will fail.
 
             if (_buildParameters.ProjectCacheDescriptor != null)
             {
                 // Build parameter specified project cache takes precedence.
-                return new DisposePluginService(null);
+                return new DisposablePluginService(null);
             }
 
             var nodeToCacheItems = projectGraph.ProjectNodes.ToDictionary(
@@ -1904,19 +1944,21 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj
 
             if (cacheItems.Count == 0)
             {
-                return new DisposePluginService(null);
+                return new DisposablePluginService(null);
             }
 
-            ErrorUtilities.VerifyThrowInvalidOperation(
-                cacheItems.Count == 1,
-                "OnlyOneCachePluginMustBeSpecified",
-                string.Join("; ", cacheItems.Select(ci => ci.PluginPath)));
+            if (cacheItems.Count != 1)
+            {
+                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
+                    "OnlyOneCachePluginMustBeSpecified",
+                    string.Join("; ", cacheItems.Select(ci => ci.PluginPath)));
+            }
 
             var nodesWithoutCacheItems = nodeToCacheItems.Where(kvp => kvp.Value.Length == 0).ToArray();
 
             if (nodesWithoutCacheItems.Length > 0)
             {
-                ErrorUtilities.ThrowInvalidOperation(
+                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache(
                     "NotAllNodesDefineACacheItem",
                     ItemTypeNames.ProjectCachePlugin,
                     string.Join(", ", nodesWithoutCacheItems.Select(kvp => kvp.Key.ProjectInstance.FullPath)));
@@ -1935,14 +1977,14 @@ private DisposePluginService SearchAndInitializeProjectCachePluginFromGraph(Proj
                     _graphSchedulingCancellationSource.Token);
             }
 
-            return new DisposePluginService(this);
+            return new DisposablePluginService(this);
         }
 
-        private class DisposePluginService : IDisposable
+        private class DisposablePluginService : IDisposable
         {
             private readonly BuildManager _buildManager;
 
-            public DisposePluginService(BuildManager buildManager)
+            public DisposablePluginService(BuildManager buildManager)
             {
                 _buildManager = buildManager;
             }
@@ -2605,6 +2647,11 @@ private void OnThreadException(Exception e)
             {
                 if (_threadException == null)
                 {
+                    if (e is AggregateException ae && ae.InnerExceptions.Count == 1)
+                    {
+                        e = ae.InnerExceptions.First();
+                    }
+
                     _threadException = ExceptionDispatchInfo.Capture(e);
                     var submissions = new List<BuildSubmission>(_buildSubmissions.Values);
                     foreach (BuildSubmission submission in submissions)
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 7528431810a..9dc051c711e 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -944,7 +944,7 @@ public async Task WaitForExitAsync(ILoggingService loggingService)
                     _process.Id);
                 CommunicationsUtilities.Trace("Killing node with pid = {0}", _process.Id);
 
-                _process.KillTree(timeout: 5000);
+                _process.KillTree(timeoutMilliseconds: 5000);
             }
 
 #if FEATURE_APM
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
new file mode 100644
index 00000000000..994c9da77a8
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
@@ -0,0 +1,87 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    /// <summary>
+    /// This exception is used to wrap an unhandled exception from a project cache plugin. This exception aborts the build, and it can only be
+    /// thrown by the MSBuild engine.
+    /// </summary>
+    public sealed class ProjectCacheException : Exception
+    {
+        private ProjectCacheException()
+        {
+            ErrorUtilities.ThrowInternalErrorUnreachable();
+        }
+
+        private ProjectCacheException(
+            string message,
+            Exception innerException,
+            bool hasBeenLoggedByProjectCache,
+            string errorCode
+        )
+            : base(message, innerException)
+        {
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(errorCode), "Must specify the error message code.");
+
+            HasBeenLoggedByProjectCache = hasBeenLoggedByProjectCache;
+            ErrorCode = errorCode;
+        }
+
+        /// <summary>
+        /// The project cache has already logged this as an error.
+        /// Should not get logged again.
+        /// </summary>
+        public bool HasBeenLoggedByProjectCache { get; }
+
+        /// <summary>
+        /// Gets the error code associated with this exception's message (not the inner exception).
+        /// </summary>
+        /// <value>The error code string.</value>
+        public string ErrorCode { get; }
+
+        internal static void ThrowAsUnhandledException
+        (
+            Exception innerException,
+            string messageResourceName,
+            params string[] messageArgs
+        )
+        {
+            ErrorUtilities.VerifyThrow(messageResourceName != null, "Need error message.");
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out var errorCode, out _, messageResourceName, messageArgs);
+
+            throw new ProjectCacheException(message, innerException, hasBeenLoggedByProjectCache: false, errorCode);
+        }
+
+        internal static void ThrowForErrorLoggedInsideTheProjectCache
+        (
+            string messageResourceName,
+            params string[] messageArgs
+        )
+        {
+            ErrorUtilities.VerifyThrow(messageResourceName != null, "Need error message.");
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out var errorCode, out _, messageResourceName, messageArgs);
+
+            throw new ProjectCacheException(message: message, innerException: null, hasBeenLoggedByProjectCache: true, errorCode: errorCode);
+        }
+
+        internal static void ThrowForMSBuildIssueWithTheProjectCache
+        (
+            string messageResourceName,
+            params string[] messageArgs
+        )
+        {
+            ErrorUtilities.VerifyThrow(messageResourceName != null, "Need error message.");
+
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out var errorCode, out _, messageResourceName, messageArgs);
+
+            throw new ProjectCacheException(message: message, innerException: null, hasBeenLoggedByProjectCache: false, errorCode: errorCode);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 3103b05ddf6..ad7259723ce 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.Experimental.ProjectCache
     internal class ProjectCacheService
     {
         private readonly BuildManager _buildManager;
-        private readonly PluginLoggerBase _logger;
+        private readonly Func<PluginLoggerBase> _loggerFactory;
         private readonly ProjectCacheDescriptor _projectCacheDescriptor;
         private readonly CancellationToken _cancellationToken;
         private readonly ProjectCachePluginBase _projectCachePlugin;
@@ -28,13 +28,14 @@ internal class ProjectCacheService
         private ProjectCacheService(
             ProjectCachePluginBase projectCachePlugin,
             BuildManager buildManager,
-            PluginLoggerBase logger,
+            Func<PluginLoggerBase> loggerFactory,
             ProjectCacheDescriptor projectCacheDescriptor,
-            CancellationToken cancellationToken)
+            CancellationToken cancellationToken
+        )
         {
             _projectCachePlugin = projectCachePlugin;
             _buildManager = buildManager;
-            _logger = logger;
+            _loggerFactory = loggerFactory;
             _projectCacheDescriptor = projectCacheDescriptor;
             _cancellationToken = cancellationToken;
         }
@@ -49,25 +50,33 @@ public static async Task<ProjectCacheService> FromDescriptorAsync(
                 .ConfigureAwait(false);
 
             // TODO: Detect and use the highest verbosity from all the user defined loggers. That's tricky because right now we can't discern between user set loggers and msbuild's internally added loggers.
-            var logger = new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService);
-
-            await plugin.BeginBuildAsync(
-                new CacheContext(
-                    pluginDescriptor.PluginSettings,
-                    new IFileSystemAdapter(FileSystems.Default),
-                    pluginDescriptor.ProjectGraph,
-                    pluginDescriptor.EntryPoints),
-                // TODO: Detect verbosity from logging service.
-                logger,
-                cancellationToken);
+            var loggerFactory = new Func<PluginLoggerBase>(() => new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService));
+
+            var logger = loggerFactory();
+
+            try
+            {
+                await plugin.BeginBuildAsync(
+                    new CacheContext(
+                        pluginDescriptor.PluginSettings,
+                        new IFileSystemAdapter(FileSystems.Default),
+                        pluginDescriptor.ProjectGraph,
+                        pluginDescriptor.EntryPoints),
+                    // TODO: Detect verbosity from logging service.
+                    logger,
+                    cancellationToken);
+            }
+            catch (Exception e)
+            {
+                HandlePluginException(e, nameof(ProjectCachePluginBase.BeginBuildAsync));
+            }
 
             if (logger.HasLoggedErrors)
             {
-                throw new Exception(
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheInitializationFailed"));
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
             }
 
-            return new ProjectCacheService(plugin, buildManager, logger, pluginDescriptor, cancellationToken);
+            return new ProjectCacheService(plugin, buildManager, loggerFactory, pluginDescriptor, cancellationToken);
         }
 
         private static ProjectCachePluginBase GetPluginInstance(ProjectCacheDescriptor pluginDescriptor)
@@ -83,9 +92,7 @@ private static ProjectCachePluginBase GetPluginInstance(ProjectCacheDescriptor p
 
             ErrorUtilities.ThrowInternalErrorUnreachable();
 
-#pragma warning disable CS8603 // Possible null reference return.
-            return null;
-#pragma warning restore CS8603 // Possible null reference return.
+            return null!;
         }
 
         private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
@@ -96,8 +103,10 @@ private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
             }
             catch (TargetInvocationException e) when (e.InnerException != null)
             {
-                throw e.InnerException;
+                HandlePluginException(e.InnerException, "Constructor");
             }
+
+            return null!;
         }
 
         private static Type GetTypeFromAssemblyPath(string pluginAssemblyPath)
@@ -106,7 +115,10 @@ private static Type GetTypeFromAssemblyPath(string pluginAssemblyPath)
 
             var type = GetTypes<ProjectCachePluginBase>(assembly).FirstOrDefault();
 
-            ErrorUtilities.VerifyThrow(type != null, "NoProjectCachePluginFoundInAssembly", pluginAssemblyPath);
+            if (type == null)
+            {
+                ProjectCacheException.ThrowForMSBuildIssueWithTheProjectCache("NoProjectCachePluginFoundInAssembly", pluginAssemblyPath);
+            }
 
             return type!;
 
@@ -143,16 +155,25 @@ public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest
                                    $"\n\tTargets:[{string.Join(", ", buildRequest.TargetNames)}]" +
                                    $"\n\tGlobal Properties: {{{string.Join(",", buildRequest.GlobalProperties.Select(kvp => $"{kvp.Name}={kvp.EvaluatedValue}"))}}}";
 
-            _logger.LogMessage(
+            var logger = _loggerFactory();
+
+            logger.LogMessage(
                 "\n====== Querying project cache for project " + queryDescription,
                 MessageImportance.High);
 
-            var cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, _logger, _cancellationToken);
+            CacheResult cacheResult = null!;
+            try
+            {
+                cacheResult = await _projectCachePlugin.GetCacheResultAsync(buildRequest, logger, _cancellationToken);
+            }
+            catch (Exception e)
+            {
+                HandlePluginException(e, nameof(ProjectCachePluginBase.GetCacheResultAsync));
+            }
 
-            if (_logger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
+            if (logger.HasLoggedErrors || cacheResult.ResultType == CacheResultType.None)
             {
-                throw new Exception(
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheQueryFailed", queryDescription));
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheQueryFailed", queryDescription);
             }
 
             var message = $"Plugin result: {cacheResult.ResultType}.";
@@ -172,7 +193,7 @@ public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest
                     throw new ArgumentOutOfRangeException();
             }
 
-            _logger.LogMessage(
+            logger.LogMessage(
                 message,
                 MessageImportance.High);
 
@@ -181,13 +202,34 @@ public async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest
 
         public async Task ShutDown()
         {
-            await _projectCachePlugin.EndBuildAsync(_logger, _cancellationToken);
+            var logger = _loggerFactory();
 
-            if (_logger.HasLoggedErrors)
+            try
+            {
+                await _projectCachePlugin.EndBuildAsync(logger, _cancellationToken);
+            }
+            catch (Exception e)
             {
-                throw new Exception(
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ProjectCacheShutdownFailed"));
+                HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
             }
+
+            if (logger.HasLoggedErrors)
+            {
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
+            }
+        }
+
+        private static void HandlePluginException(Exception e, string apiExceptionWasThrownFrom)
+        {
+            if (ExceptionHandling.IsCriticalException(e))
+            {
+                throw e;
+            }
+
+            ProjectCacheException.ThrowAsUnhandledException(
+                e,
+                "ProjectCacheException",
+                apiExceptionWasThrownFrom);
         }
 
         private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 8398cb68479..659066306cc 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -466,7 +466,7 @@ internal void LoadProjectIntoConfiguration(
                     projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
                 }
 
-                if (buildRequestDataFlags.HasFlag(buildRequestDataFlags & BuildRequestDataFlags.FailOnUnresolvedSdk))
+                if (buildRequestDataFlags.HasFlag(BuildRequestDataFlags.FailOnUnresolvedSdk))
                 {
                     projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
                 }
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 874962890f4..364e449dcbe 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -189,11 +189,6 @@ internal int VisualStudioVersion
         /// </summary>
         public IReadOnlyDictionary<string, ProjectInSolution> ProjectsByGuid => new ReadOnlyDictionary<string, ProjectInSolution>(_projects);
 
-        /// <summary>
-        /// This is the read accessor for the solution filter file, if present. Set through FullPath.
-        /// </summary>
-        internal string SolutionFilterFilePath { get => _solutionFilterFile; }
-
         /// <summary>
         /// This is the read/write accessor for the solution file which we will parse.  This
         /// must be set before calling any other methods on this class.
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index d291d172bde..3888a265e50 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -52,7 +52,7 @@ internal class SolutionProjectGenerator
         /// <summary>
         /// The set of properties all projects in the solution should be built with
         /// </summary>
-        private const string SolutionProperties = "BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)";
+        private const string SolutionProperties = "BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)";
 
         /// <summary>
         /// The set of properties which identify the configuration and platform to build a project with
@@ -94,7 +94,6 @@ internal class SolutionProjectGenerator
             new Tuple<string, string>("SolutionExt", null),
             new Tuple<string, string>("SolutionFileName", null),
             new Tuple<string, string>("SolutionName", null),
-            new Tuple<string, string>("SolutionFilterName", null),
             new Tuple<string, string>(SolutionPathPropertyName, null)
         };
 
@@ -500,7 +499,7 @@ bool specifyProjectToolsVersion
 
             string additionalProperties = string.Format(
                 CultureInfo.InvariantCulture,
-                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)",
+                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)",
                 EscapingUtilities.Escape(configurationName),
                 EscapingUtilities.Escape(platformName)
             );
@@ -2292,7 +2291,6 @@ private void AddGlobalProperties(ProjectRootElement traversalProject)
             globalProperties.AddProperty("SolutionExt", EscapingUtilities.Escape(Path.GetExtension(_solutionFile.FullPath)));
             globalProperties.AddProperty("SolutionFileName", EscapingUtilities.Escape(Path.GetFileName(_solutionFile.FullPath)));
             globalProperties.AddProperty("SolutionName", EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(_solutionFile.FullPath)));
-            globalProperties.AddProperty("SolutionFilterName", EscapingUtilities.Escape(Path.GetFileNameWithoutExtension(_solutionFile.SolutionFilterFilePath ?? string.Empty)));
 
             globalProperties.AddProperty(SolutionPathPropertyName, EscapingUtilities.Escape(Path.Combine(_solutionFile.SolutionFileDirectory, Path.GetFileName(_solutionFile.FullPath))));
 
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 72ae2c75ac2..6bcd2951e2d 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -164,6 +164,11 @@ public void Initialize(IEventSource eventSource)
             binaryWriter = new BinaryWriter(stream);
             eventArgsWriter = new BuildEventArgsWriter(binaryWriter);
 
+            if (projectImportsCollector != null)
+            {
+                eventArgsWriter.EmbedFile += EventArgsWriter_EmbedFile;
+            }
+
             binaryWriter.Write(FileFormatVersion);
 
             LogInitialInfo();
@@ -171,6 +176,14 @@ public void Initialize(IEventSource eventSource)
             eventSource.AnyEventRaised += EventSource_AnyEventRaised;
         }
 
+        private void EventArgsWriter_EmbedFile(string filePath)
+        {
+            if (projectImportsCollector != null)
+            {
+                projectImportsCollector.AddFile(filePath);
+            }
+        }
+
         private void LogInitialInfo()
         {
             LogMessage("BinLogFilePath=" + FilePath);
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index b3fec8d101d..20cd4232cb2 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -105,6 +105,11 @@ internal class BuildEventArgsWriter
         /// </summary>
         private readonly List<KeyValuePair<int, int>> nameValueIndexListBuffer = new List<KeyValuePair<int, int>>(1024);
 
+        /// <summary>
+        /// Raised when an item is encountered with a hint to embed a file into the binlog.
+        /// </summary>
+        public event Action<string> EmbedFile;
+
         /// <summary>
         /// Initializes a new instance of BuildEventArgsWriter with a BinaryWriter
         /// </summary>
@@ -788,6 +793,7 @@ private void WriteProjectItems(IEnumerable items)
                 {
                     WriteDeduplicatedString(itemType);
                     WriteTaskItemList(itemList);
+                    CheckForFilesToEmbed(itemType, itemList);
                 });
 
                 // signal the end
@@ -800,6 +806,7 @@ private void WriteProjectItems(IEnumerable items)
                 {
                     WriteDeduplicatedString(itemType);
                     WriteTaskItemList(itemList);
+                    CheckForFilesToEmbed(itemType, itemList);
                 });
 
                 // signal the end
@@ -827,6 +834,7 @@ private void WriteProjectItems(IEnumerable items)
                     {
                         WriteDeduplicatedString(currentItemType);
                         WriteTaskItemList(reusableProjectItemList);
+                        CheckForFilesToEmbed(currentItemType, reusableProjectItemList);
                         reusableProjectItemList.Clear();
                     }
 
@@ -839,6 +847,7 @@ private void WriteProjectItems(IEnumerable items)
                 {
                     WriteDeduplicatedString(currentItemType);
                     WriteTaskItemList(reusableProjectItemList);
+                    CheckForFilesToEmbed(currentItemType, reusableProjectItemList);
                     reusableProjectItemList.Clear();
                 }
 
@@ -847,6 +856,28 @@ private void WriteProjectItems(IEnumerable items)
             }
         }
 
+        private void CheckForFilesToEmbed(string itemType, object itemList)
+        {
+            if (EmbedFile == null ||
+                !string.Equals(itemType, ItemTypeNames.EmbedInBinlog, StringComparison.OrdinalIgnoreCase) ||
+                itemList is not IEnumerable list)
+            {
+                return;
+            }
+
+            foreach (var item in list)
+            {
+                if (item is ITaskItem taskItem && !string.IsNullOrEmpty(taskItem.ItemSpec))
+                {
+                    EmbedFile.Invoke(taskItem.ItemSpec);
+                }
+                else if (item is string itemSpec && !string.IsNullOrEmpty(itemSpec))
+                {
+                    EmbedFile.Invoke(itemSpec);
+                }
+            }
+        }
+
         private void Write(ITaskItem item, bool writeMetadata = true)
         {
             WriteDeduplicatedString(item.ItemSpec);
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 2dff53cc972..43d9b794046 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -800,5 +800,4 @@
   <ItemGroup>
     <Compile Remove="Collections\RetrievableEntryHashSet\Originals\*" />
   </ItemGroup>
-
 </Project>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index ed692c7d2c3..9bce56de852 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1864,8 +1864,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>EvaluationContext objects created with SharingPolicy.Isolated do not support being passed an MSBuildFileSystemBase file system.</value>
   </data>
   <data name="LoadingProjectCachePlugin" xml:space="preserve">
-    <value>"Loading the following project cache plugin:
-    {0}"</value>
+    <value>Loading the following project cache plugin:
+    {0}</value>
   </data>
   <data name="SolutionPathPropertyMustBeSetOnVSSubmissions" xml:space="preserve">
     <value>"MSB4264: Invalid $(SolutionPath) property: {0}"</value>
@@ -1888,6 +1888,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
+  <data name="ProjectCacheException" xml:space="preserve">
+    <value>MSB4273: The project cache threw an unhandled exception from the {0} method.</value>
+  </data>
   <data name="KillingProcessWithPid" xml:space="preserve">
     <value>Killing process with pid = {0}.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 460d8c51045..a005bbc5a4e 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">Načítá se následující modul plug-in mezipaměti projektu:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">Načítá se následující modul plug-in mezipaměti projektu:
     {0}</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: Musí se zadat jeden modul plug-in mezipaměti projektu, ale našlo se jich více: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: Nepovedlo se inicializovat mezipaměť projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 7856dd8038a..91850b56a54 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Folgendes Projektcache-Plug-In wird geladen:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Folgendes Projektcache-Plug-In wird geladen:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: Ein einzelnes Projektcache-Plug-In muss angegeben werden, es wurden jedoch mehrere gefunden: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: Fehler beim Initialisieren des Projektcache.</target>
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index a030cd7e6bd..035b1fdf1cb 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -138,10 +138,10 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="new">"Loading the following project cache plugin:
-    {0}"</target>
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="new">Loading the following project cache plugin:
+    {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -219,6 +219,11 @@
         <target state="new">MSB4265: A single project cache plugin must be specified but multiple where found: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="new">MSB4266: Failed to initialize the project cache.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 10135514f9e..8e6962329b5 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Cargando el complemento de caché de proyectos siguiente:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Cargando el complemento de caché de proyectos siguiente:
     {0} "</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: Debe especificarse un solo complemento de caché de proyectos, pero se encontraron varios: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: No se pudo inicializar la caché de proyectos.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 77795f49d65..b5ee6552148 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Chargement du plug-in de cache de projet suivant :
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Chargement du plug-in de cache de projet suivant :
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: un seul plug-in de cache de projet doit être spécifié, mais plusieurs plug-ins ont été trouvés : {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: échec de l'initialisation du cache de projet.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 2c8d2e9d4ae..dd24c5f953f 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Caricamento del plug-in seguente della cache del progetto:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Caricamento del plug-in seguente della cache del progetto:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: è necessario specificare un singolo plug-in della cache del progetto, ma ne sono trovati più di uno: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: non è stato possibile inizializzare la cache del progetto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index f91a15b4459..9bb48532bc8 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"次のプロジェクト キャッシュ プラグインを読み込んでいます。
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"次のプロジェクト キャッシュ プラグインを読み込んでいます。
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: 単一のプロジェクト キャッシュ プラグインを指定する必要がありますが、複数指定されています。{0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: プロジェクト キャッシュを初期化できませんでした。</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 3480d5aa9e1..5d7d4163bd2 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"다음 프로젝트 캐시 플러그 인을 로드하는 중:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"다음 프로젝트 캐시 플러그 인을 로드하는 중:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: 단일 프로젝트 캐시 플러그 인이 지정되어야 하지만, {0}에서 여러 개를 찾았습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: 프로젝트 캐시를 초기화하지 못했습니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index f2ae7700434..1d00d687697 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">„Ładowanie następującej wtyczki pamięci podręcznej projektu:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">„Ładowanie następującej wtyczki pamięci podręcznej projektu:
     {0}”</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: należy określić jedną wtyczkę pamięci podręcznej projektu, ale znaleziono ich wiele: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: nie można zainicjować pamięci podręcznej projektu.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index d386fdc902b..423af0d4199 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Carregando o seguinte plug-in de cache do projeto:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Carregando o seguinte plug-in de cache do projeto:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: é necessário especificar só um plug-in de cache do projeto, mas foram encontrados vários: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: falha ao inicializar o cache do projeto.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index a2a3ffc13fb..2381c6ed244 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Идет загрузка следующего подключаемого модуля кэша проектов:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Идет загрузка следующего подключаемого модуля кэша проектов:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: должен быть указан один подключаемый модуль кэша проектов, но найдено несколько: {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: не удалось инициализировать кэш проектов.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 0e7ece86344..51c4e1c7d52 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"Şu proje önbelleği eklentisi yükleniyor:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"Şu proje önbelleği eklentisi yükleniyor:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: Tek bir proje önbellek eklentisi belirtilmelidir ancak birden çok eklenti bulundu: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: Proje önbelleği başlatılamadı.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 7157572b7e0..2bf484357b9 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">“正在加载以下项目缓存插件:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">“正在加载以下项目缓存插件:
     {0}”</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: 必须指定单个项目缓存插件，但找到多个位置: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: 未能初始化项目缓存。</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index d8fb2e4baa4..f4f05481636 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -138,9 +138,9 @@
         <note />
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
-        <source>"Loading the following project cache plugin:
-    {0}"</source>
-        <target state="translated">"正在載入下列專案快取外掛程式:
+        <source>Loading the following project cache plugin:
+    {0}</source>
+        <target state="needs-review-translation">"正在載入下列專案快取外掛程式:
     {0}"</target>
         <note />
       </trans-unit>
@@ -219,6 +219,11 @@
         <target state="translated">MSB4265: 只可指定單一專案快取外掛程式，但發現多個指定項目: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheException">
+        <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
+        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
         <source>MSB4266: Failed to initialize the project cache.</source>
         <target state="translated">MSB4266: 無法將專案快取初始化。</target>
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index 1c9c9b38965..6dc05efbbac 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -519,7 +519,7 @@ bool specifyProjectToolsVersion
 
             string additionalProperties = string.Format(
                 CultureInfo.InvariantCulture,
-                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)",
+                "Configuration={0}; Platform={1}; BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)",
                 EscapingUtilities.Escape(configurationName),
                 EscapingUtilities.Escape(platformName)
             );
@@ -1608,7 +1608,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                 BuildTask msbuildTask = newTarget.AddNewTask("MSBuild");
                 msbuildTask.Condition = buildItemReference + " != ''";
                 msbuildTask.SetParameterValue("Projects", buildItemReference);
-                msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionFilterName=$(SolutionFilterName); SolutionPath=$(SolutionPath)");
+                msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)");
 
                 if (!string.IsNullOrEmpty(subTargetName))
                 {
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index e014f5652e3..1513d20e3f9 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -19,6 +19,7 @@
 using Shouldly;
 using System.IO.Compression;
 using System.Reflection;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -2127,6 +2128,31 @@ public void RestoreFailsOnUnresolvedSdk()
             logContents.ShouldContain("error MSB4236: The SDK 'UnresolvedSdk' specified could not be found.");
         }
 
+        /// <summary>
+        /// When specifying /t:restore under an old changewave, do not fail when an SDK can't be resolved.
+        /// Previous behavior was to try and continue anyway but then "restore" would succeed and build workflows continue on.
+        /// </summary>
+        [Fact]
+        public void RestorePassesOnUnresolvedSdkUnderChangewave()
+        {
+            string projectContents = ObjectModelHelpers.CleanupFileContents(
+$@"<Project>
+  <Sdk Name=""UnresolvedSdk"" />
+  <Target Name=""Restore"">
+    <Message Text=""Restore target ran"" />
+  </Target>
+</Project>");
+
+            using TestEnvironment env = Microsoft.Build.UnitTests.TestEnvironment.Create();
+
+            string logContents = ExecuteMSBuildExeExpectSuccess(projectContents,
+                envsToCreate: new Dictionary<string, string>() { ["MSBUILDDISABLEFEATURESFROMVERSION"]=ChangeWaves.Wave16_10.ToString() },
+                arguments: " /t:restore");
+
+            logContents.ShouldNotContain("MSB4236");
+        }
+
+
         /// <summary>
         /// Verifies a non-existent target doesn't fail restore as long as its not considered an entry target, in this case Restore.
         /// </summary>
@@ -2181,6 +2207,26 @@ public void RestoreFailsWhenEntryTargetIsNonExistent()
             logContents.ShouldContain("error MSB4057: The target \"Restore\" does not exist in the project.");
         }
 
+        /// <summary>
+        /// Verifies restore will not fail if the entry target doesn't exist, when changewave applied.
+        /// </summary>
+        [Fact]
+        public void RestorePassesWhenEntryTargetIsNonExistentUnderChangewave()
+        {
+            string projectContents = ObjectModelHelpers.CleanupFileContents(
+@"<Project DefaultTargets=""Build"">
+  <Target Name=""Build"">
+    <Message Text=""Build target ran&quot;"" />
+  </Target>
+</Project>");
+
+            string logContents = ExecuteMSBuildExeExpectSuccess(projectContents,
+                envsToCreate: new Dictionary<string, string>() { ["MSBUILDDISABLEFEATURESFROMVERSION"] = ChangeWaves.Wave16_10.ToString() },
+                arguments: "/t:restore");
+
+            logContents.ShouldNotContain("MSB4057");
+        }
+
         /// <summary>
         /// Verifies restore will run InitialTargets.
         /// </summary>
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 61749a966c9..4810afd35e9 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1796,7 +1796,6 @@ elementFormDefault="qualified">
     <xs:element name="SolutionExt" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="SolutionFileName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="SolutionName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
-    <xs:element name="SolutionFilterName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="SolutionPath" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="StartAction" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="StartArguments" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 3acef1dea3c..b86c58acce1 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -20,6 +20,7 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.Logging;
@@ -81,7 +82,11 @@ public enum ExitType
             /// The build stopped unexpectedly, for example,
             /// because a child died or hung.
             /// </summary>
-            Unexpected
+            Unexpected,
+            /// <summary>
+            /// A project cache failed unexpectedly.
+            /// </summary>
+            ProjectCacheFailure
         }
 
         /// <summary>
@@ -786,6 +791,24 @@ string [] commandLine
                     exitType = ExitType.InitializationError;
                 }
             }
+            catch (ProjectCacheException e)
+            {
+                Console.WriteLine($"MSBUILD : error {e.ErrorCode}: {e.Message}");
+
+#if DEBUG
+                if (!e.HasBeenLoggedByProjectCache && e.InnerException != null)
+                {
+                    Console.WriteLine("This is an unhandled exception from a project cache -- PLEASE OPEN A BUG AGAINST THE PROJECT CACHE OWNER.");
+                }
+#endif
+
+                if (e.InnerException is not null)
+                {
+                    Console.WriteLine(e.InnerException.ToString());
+                }
+
+                exitType = ExitType.ProjectCacheFailure;
+            }
             catch (BuildAbortedException e)
             {
                 Console.WriteLine(
@@ -1262,21 +1285,17 @@ string outputResultsCache
                         success = false;
 
                         // InvalidProjectFileExceptions and its aggregates have already been logged.
-                        if (exception.GetType() != typeof(InvalidProjectFileException)
+                        if (exception is not InvalidProjectFileException
                             && !(exception is AggregateException aggregateException && aggregateException.InnerExceptions.All(innerException => innerException is InvalidProjectFileException)))
                         {
-                            if
-                                (
-                                exception.GetType() == typeof(LoggerException) ||
-                                exception.GetType() == typeof(InternalLoggerException)
-                                )
+                            if (exception is LoggerException or InternalLoggerException or ProjectCacheException)
                             {
-                                // We will rethrow this so the outer exception handler can catch it, but we don't
+                                // We will rethrow these so the outer exception handler can catch them, but we don't
                                 // want to log the outer exception stack here.
                                 throw exception;
                             }
 
-                            if (exception.GetType() == typeof(BuildAbortedException))
+                            if (exception is BuildAbortedException)
                             {
                                 // this is not a bug and should not dump stack. It will already have been logged
                                 // appropriately, there is no need to take any further action with it.
@@ -1421,20 +1440,31 @@ private static (BuildResultCode result, Exception exception) ExecuteRestore(stri
             restoreGlobalProperties["MSBuildRestoreSessionId"] = Guid.NewGuid().ToString("D");
 
             // Create a new request with a Restore target only and specify:
-            //  - BuildRequestDataFlags.ClearCachesAfterBuild to ensure the projects will be reloaded from disk for subsequent builds
-            //  - BuildRequestDataFlags.SkipNonexistentNonEntryTargets to ignore missing non-entry targets since Restore does not require that all targets
-            //      exist, only top-level ones like Restore itself
-            //  - BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports to ignore imports that don't exist, are empty, or are invalid because restore might
-            //     make available an import that doesn't exist yet and the <Import /> might be missing a condition.
-            //  - BuildRequestDataFlags.FailOnUnresolvedSdk to still fail in the case when an MSBuild project SDK can't be resolved since this is fatal and should
-            //     fail the build.
+            BuildRequestDataFlags flags;
+
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
+            {
+                flags =   BuildRequestDataFlags.ClearCachesAfterBuild                // ensure the projects will be reloaded from disk for subsequent builds
+                        | BuildRequestDataFlags.SkipNonexistentNonEntryTargets       // ignore missing non-entry targets since Restore does not require that all targets
+                                                                                     // exist, only top-level ones like Restore itself
+                        | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports  // ignore imports that don't exist, are empty, or are invalid because restore might
+                                                                                     // make available an import that doesn't exist yet and the <Import /> might be missing a condition.
+                        | BuildRequestDataFlags.FailOnUnresolvedSdk;                 // still fail in the case when an MSBuild project SDK can't be resolved since this is fatal and should
+                                                                                     // fail the build.
+            }
+            else
+            {
+                // pre-16.10 flags allowed `-restore` to pass when there was no `Restore` target
+                flags = BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports;
+            }
+
             BuildRequestData restoreRequest = new BuildRequestData(
                 projectFile,
                 restoreGlobalProperties,
                 toolsVersion,
                 targetsToBuild: new[] { MSBuildConstants.RestoreTargetName },
                 hostServices: null,
-                flags: BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentNonEntryTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports | BuildRequestDataFlags.FailOnUnresolvedSdk);
+                flags);
 
             return ExecuteBuild(buildManager, restoreRequest);
         }
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 5e1dee0ffee..8c91cf21b7d 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -52,11 +52,64 @@
           <codeBase version="16.10.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
+        <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.NET.StringTools.net35" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+        </dependentAssembly>
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
+      </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.5.0" newVersion="4.0.5.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.0" newVersion="4.0.1.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.6.3.0" newVersion="4.6.3.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.2.0.0" newVersion="4.2.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+        </dependentAssembly>
 
         <!-- Redirects for components dropped by Visual Studio -->
         <dependentAssembly>
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 4dc44912a1d..ea9ce9319cf 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -41,11 +41,64 @@
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
         </dependentAssembly>
 
+        <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.NET.StringTools.net35" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+        </dependentAssembly>
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+        <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
+      </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.5.0" newVersion="4.0.5.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.0" newVersion="4.0.1.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.6.3.0" newVersion="4.6.3.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.2.0.0" newVersion="4.2.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+        </dependentAssembly>
 
         <!-- Redirects for components dropped by Visual Studio -->
         <dependentAssembly>
diff --git a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
index 8b0a83ecc8b..c89e8c9e3c6 100644
--- a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
+++ b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
@@ -14,14 +14,14 @@ public class AssemblyMockCache : ProjectCachePluginBase
     {
         public AssemblyMockCache()
         {
-            ThrowFrom("Constructor");
+            ErrorFrom("Constructor", pluginLoggerBase: null);
         }
 
         public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)
         {
             logger.LogMessage($"{nameof(AssemblyMockCache)}: BeginBuildAsync", MessageImportance.High);
 
-            ThrowFrom(nameof(BeginBuildAsync));
+            ErrorFrom(nameof(BeginBuildAsync), logger);
 
             return Task.CompletedTask;
         }
@@ -33,7 +33,7 @@ public override Task<CacheResult> GetCacheResultAsync(
         {
             logger.LogMessage($"{nameof(AssemblyMockCache)}: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
 
-            ThrowFrom(nameof(GetCacheResultAsync));
+            ErrorFrom(nameof(GetCacheResultAsync), logger);
 
             return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
         }
@@ -42,16 +42,22 @@ public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken ca
         {
             logger.LogMessage($"{nameof(AssemblyMockCache)}: EndBuildAsync", MessageImportance.High);
 
-            ThrowFrom(nameof(EndBuildAsync));
+            ErrorFrom(nameof(EndBuildAsync), logger);
 
             return Task.CompletedTask;
         }
 
-        private static void ThrowFrom(string throwFrom)
+        private static void ErrorFrom(string errorLocation, PluginLoggerBase pluginLoggerBase)
         {
-            if (Environment.GetEnvironmentVariable(throwFrom) != null)
+            var errorKind = Environment.GetEnvironmentVariable(errorLocation);
+
+            switch (errorKind)
             {
-                throw new Exception($"Cache plugin exception from {throwFrom}");
+                case "Exception":
+                    throw new Exception($"Cache plugin exception from {errorLocation}");
+                case "LoggedError":
+                    pluginLoggerBase?.LogError($"Cache plugin logged error from {errorLocation}");
+                    break;
             }
         }
     }
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index eea2401dca9..e0c4da0540e 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -141,6 +141,11 @@ internal static class ItemTypeNames
         /// Declares a project cache plugin and its configuration.
         /// </summary>
         internal const string ProjectCachePlugin = nameof(ProjectCachePlugin);
+
+        /// <summary>
+        /// Embed specified files in the binary log
+        /// </summary>
+        internal const string EmbedInBinlog = nameof(EmbedInBinlog);
     }
 
     /// <summary>
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 006e0587bf1..e567fc1f64c 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -66,9 +66,11 @@ internal static class FrameworkLocationHelper
         internal static readonly Version visualStudioVersion120 = new Version(12, 0);
         internal static readonly Version visualStudioVersion140 = new Version(14, 0);
         internal static readonly Version visualStudioVersion150 = new Version(15, 0);
+        internal static readonly Version visualStudioVersion160 = new Version(16, 0);
+        internal static readonly Version visualStudioVersion170 = new Version(17, 0);
 
         // keep this up-to-date; always point to the latest visual studio version.
-        internal static readonly Version visualStudioVersionLatest = visualStudioVersion150;
+        internal static readonly Version visualStudioVersionLatest = visualStudioVersion160;
 
         private const string dotNetFrameworkRegistryPath = "SOFTWARE\\Microsoft\\.NETFramework";
         private const string dotNetFrameworkSetupRegistryPath = "SOFTWARE\\Microsoft\\NET Framework Setup\\NDP";
@@ -286,6 +288,25 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
             }),
+
+            // VS16
+            new VisualStudioSpec(visualStudioVersion160, "NETFXSDK\\{0}", "v10.0", "InstallationFolder", new []
+            {
+                dotNetFrameworkVersion11,
+                dotNetFrameworkVersion20,
+                dotNetFrameworkVersion35,
+                dotNetFrameworkVersion40,
+                dotNetFrameworkVersion45,
+                dotNetFrameworkVersion451,
+                dotNetFrameworkVersion452,
+                dotNetFrameworkVersion46,
+                dotNetFrameworkVersion461,
+                dotNetFrameworkVersion462,
+                dotNetFrameworkVersion47,
+                dotNetFrameworkVersion471,
+                dotNetFrameworkVersion472,
+                dotNetFrameworkVersion48,
+            }),
         };
 
 #if FEATURE_WIN32_REGISTRY
@@ -320,6 +341,17 @@ private static readonly (Version, Version)[,] s_explicitFallbackRulesForPathToDo
             { (dotNetFrameworkVersion471, visualStudioVersion150), (dotNetFrameworkVersion47, visualStudioVersion150) },
             { (dotNetFrameworkVersion472, visualStudioVersion150), (dotNetFrameworkVersion471, visualStudioVersion150) },
             { (dotNetFrameworkVersion48, visualStudioVersion150), (dotNetFrameworkVersion472, visualStudioVersion150) },
+
+            // VS16
+            { (dotNetFrameworkVersion451, visualStudioVersion160), (dotNetFrameworkVersion45, visualStudioVersion160) },
+            { (dotNetFrameworkVersion452, visualStudioVersion160), (dotNetFrameworkVersion451, visualStudioVersion160) },
+            { (dotNetFrameworkVersion46, visualStudioVersion160), (dotNetFrameworkVersion451, visualStudioVersion160) },
+            { (dotNetFrameworkVersion461, visualStudioVersion160), (dotNetFrameworkVersion46, visualStudioVersion160) },
+            { (dotNetFrameworkVersion462, visualStudioVersion160), (dotNetFrameworkVersion461, visualStudioVersion160) },
+            { (dotNetFrameworkVersion47, visualStudioVersion160), (dotNetFrameworkVersion462, visualStudioVersion160) },
+            { (dotNetFrameworkVersion471, visualStudioVersion160), (dotNetFrameworkVersion47, visualStudioVersion160) },
+            { (dotNetFrameworkVersion472, visualStudioVersion160), (dotNetFrameworkVersion471, visualStudioVersion160) },
+            { (dotNetFrameworkVersion48, visualStudioVersion160), (dotNetFrameworkVersion472, visualStudioVersion160) },
        };
 #endif // FEATURE_WIN32_REGISTRY
 
diff --git a/src/Shared/ProcessExtensions.cs b/src/Shared/ProcessExtensions.cs
index 9504440d124..e09db350365 100644
--- a/src/Shared/ProcessExtensions.cs
+++ b/src/Shared/ProcessExtensions.cs
@@ -5,13 +5,12 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Shared
 {
     internal static class ProcessExtensions
     {
-        public static void KillTree(this Process process, int timeout)
+        public static void KillTree(this Process process, int timeoutMilliseconds)
         {
             if (NativeMethodsShared.IsWindows)
             {
@@ -41,7 +40,7 @@ public static void KillTree(this Process process, int timeout)
             // wait until the process finishes exiting/getting killed. 
             // We don't want to wait forever here because the task is already supposed to be dieing, we just want to give it long enough
             // to try and flush what it can and stop. If it cannot do that in a reasonable time frame then we will just ignore it.
-            process.WaitForExit(timeout);
+            process.WaitForExit(timeoutMilliseconds);
         }
 
         private static void GetAllChildIdsUnix(int parentId, ISet<int> children)
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 1c0521195bb..b782457b344 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -102,7 +102,6 @@
     <Compile Remove="CSharpTokenizer_Tests.cs" />
     <Compile Remove="DependentAssembly_Tests.cs" />
     <Compile Remove="ErrorWarningMessage_Tests.cs" />
-    <Compile Remove="FindInvalidProjectReferences_Tests.cs" />
     <Compile Remove="ResourceHandling\GenerateResourceOutOfProc_Tests.cs" />
     <Compile Remove="ResourceHandling\ResGen_Tests.cs" />
     <Compile Remove="ResourceHandling\ResGenDependencies_Tests.cs" />
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 3c304324122..6d055df7140 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -3015,7 +3015,7 @@ public static GenerateResource CreateTaskOutOfProc(ITestOutputHelper output)
         {
             GenerateResource t = CreateTask(output);
             t.ExecuteAsTool = true;
-            t.SdkToolsPath = ToolLocationHelper.GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion.VersionLatest);
+            t.SdkToolsPath = ToolLocationHelper.GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion.Version48);
 
             return t;
         }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 7a3ad571bda..bc15a0328a1 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -1065,13 +1065,20 @@ private bool ComputePathToResGen()
 
             if (String.IsNullOrEmpty(_sdkToolsPath))
             {
-                _resgenPath = ToolLocationHelper.GetPathToDotNetFrameworkSdkFile("resgen.exe", TargetDotNetFrameworkVersion.Version35);
+                // Important: the GenerateResource task is declared twice in Microsoft.Common.CurrentVersion.targets:
+                // https://github.com/dotnet/msbuild/blob/369631b4b21ef485f4d6f35e16b0c839a971b0e9/src/Tasks/Microsoft.Common.CurrentVersion.targets#L3177-L3178
+                // First for CLR >= 4.0, where SdkToolsPath is passed $(ResgenToolPath) which in turn is set to
+                // $(TargetFrameworkSDKToolsDirectory).
+                // But for CLR < 4.0 the SdkToolsPath is not passed, so we need to explicitly assume 3.5:
+                var version = TargetDotNetFrameworkVersion.Version35;
+
+                _resgenPath = ToolLocationHelper.GetPathToDotNetFrameworkSdkFile("resgen.exe", version);
 
                 if (_resgenPath == null && ExecuteAsTool)
                 {
                     Log.LogErrorWithCodeFromResources("General.PlatformSDKFileNotFound", "resgen.exe",
-                        ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion.Version35),
-                        ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version35));
+                        ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(version),
+                        ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(version));
                 }
             }
             else
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 6e05beb2f75..0223ef51572 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -385,6 +385,7 @@
     <Compile Include="FindAppConfigFile.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="FindInvalidProjectReferences.cs" />
     <Compile Include="GetFrameworkPath.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -603,7 +604,6 @@
     <Compile Include="ComReferenceWrapperInfo.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="FindInvalidProjectReferences.cs" />
     <Compile Include="GenerateBootstrapper.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 668684ed3c6..b832e571825 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -346,7 +346,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <DevEnvDir Condition="'$(DevEnvDir)'==''">*Undefined*</DevEnvDir>
     <SolutionName Condition="'$(SolutionName)'==''">*Undefined*</SolutionName>
-    <SolutionFilterName Condition="'$(SolutionFilterName)'==''">*Undefined*</SolutionFilterName>
     <!-- Example, MySolution -->
     <SolutionFileName Condition="'$(SolutionFileName)'==''">*Undefined*</SolutionFileName>
     <!-- Example, MySolution.sln -->
diff --git a/src/Utilities.UnitTests/ProcessExtensions_Tests.cs b/src/Utilities.UnitTests/ProcessExtensions_Tests.cs
index e24dca74ec4..edc892a75a9 100644
--- a/src/Utilities.UnitTests/ProcessExtensions_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessExtensions_Tests.cs
@@ -15,14 +15,19 @@ public class ProcessExtensions_Tests
         [Fact]
         public async Task KillTree()
         {
-            Process p = Process.Start("sleep", "600"); // sleep 10m.
+            var psi =
+                NativeMethodsShared.IsWindows ?
+                    new ProcessStartInfo("powershell", "-NoLogo -NoProfile -command \"Start-Sleep -Seconds 600\"") :
+                    new ProcessStartInfo("sleep", "600");
+
+            Process p = Process.Start(psi); // sleep 10m.
 
             // Verify the process is running.
             await Task.Delay(500);
             p.HasExited.ShouldBe(false);
 
             // Kill the process.
-            p.KillTree(timeout: 5000);
+            p.KillTree(timeoutMilliseconds: 5000);
             p.HasExited.ShouldBe(true);
             p.ExitCode.ShouldNotBe(0);
         }
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index d2473b7f3e5..1b6d83c2caa 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -130,30 +130,40 @@ public enum TargetDotNetFrameworkVersion
     public enum VisualStudioVersion
     {
         /// <summary>
-        /// Visual Studio 2010 and SP1
+        /// Visual Studio 2010 (Dev10) and SP1
         /// </summary>
         Version100,
 
         /// <summary>
-        /// Visual Studio Dev11
+        /// Visual Studio 2012 (Dev11)
         /// </summary>
         Version110,
 
         /// <summary>
-        /// Visual Studio Dev12
+        /// Visual Studio 2013 (Dev12)
         /// </summary>
         Version120,
 
         /// <summary>
-        /// Visual Studio Dev14
+        /// Visual Studio 2015 (Dev14)
         /// </summary>
         Version140,
 
         /// <summary>
-        /// Visual Studio Dev15
+        /// Visual Studio 2017 (Dev15)
         /// </summary>
         Version150,
 
+        /// <summary>
+        /// Visual Studio 2019 (Dev16)
+        /// </summary>
+        Version160,
+
+        /// <summary>
+        /// Visual Studio "Dev17"
+        /// </summary>
+        Version170,
+
         // keep this up-to-date; always point to the last entry.
         /// <summary>
         /// The latest version available at the time of release
@@ -2052,26 +2062,22 @@ private static Version TargetDotNetFrameworkVersionToSystemVersion(TargetDotNetF
 
         private static Version VisualStudioVersionToSystemVersion(VisualStudioVersion version)
         {
-            switch (version)
+            return version switch
             {
-                case VisualStudioVersion.Version100:
-                    return FrameworkLocationHelper.visualStudioVersion100;
-
-                case VisualStudioVersion.Version110:
-                    return FrameworkLocationHelper.visualStudioVersion110;
-
-                case VisualStudioVersion.Version120:
-                    return FrameworkLocationHelper.visualStudioVersion120;
-
-                case VisualStudioVersion.Version140:
-                    return FrameworkLocationHelper.visualStudioVersion140;
-
-                case VisualStudioVersion.Version150:
-                    return FrameworkLocationHelper.visualStudioVersion150;
+                VisualStudioVersion.Version100 => FrameworkLocationHelper.visualStudioVersion100,
+                VisualStudioVersion.Version110 => FrameworkLocationHelper.visualStudioVersion110,
+                VisualStudioVersion.Version120 => FrameworkLocationHelper.visualStudioVersion120,
+                VisualStudioVersion.Version140 => FrameworkLocationHelper.visualStudioVersion140,
+                VisualStudioVersion.Version150 => FrameworkLocationHelper.visualStudioVersion150,
+                VisualStudioVersion.Version160 => FrameworkLocationHelper.visualStudioVersion160,
+                VisualStudioVersion.Version170 => FrameworkLocationHelper.visualStudioVersion170,
+                _ => Unsupported()
+            };
 
-                default:
-                    ErrorUtilities.ThrowArgument("ToolLocationHelper.UnsupportedVisualStudioVersion", version);
-                    return null;
+            Version Unsupported()
+            {
+                ErrorUtilities.ThrowArgument("ToolLocationHelper.UnsupportedVisualStudioVersion", version);
+                return null;
             }
         }
 
@@ -3250,7 +3256,8 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
         /// </summary>
         /// <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
         /// <returns>Path string.</returns>
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName) => GetPathToDotNetFrameworkSdkFile(fileName, TargetDotNetFrameworkVersion.Latest);
+        public static string GetPathToDotNetFrameworkSdkFile(string fileName)
+            => GetPathToDotNetFrameworkSdkFile(fileName, TargetDotNetFrameworkVersion.Latest);
 
         /// <summary>
         /// Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
@@ -3261,7 +3268,8 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
         /// <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <returns>Path string.</returns>
-        public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version) => GetPathToDotNetFrameworkSdkFile(fileName, version, VisualStudioVersion.VersionLatest);
+        public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version)
+            => GetPathToDotNetFrameworkSdkFile(fileName, version, VisualStudioVersion.VersionLatest);
 
         /// <summary>
         /// Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
@@ -3276,7 +3284,7 @@ public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotN
                 version,
                 visualStudioVersion,
                 UtilitiesDotNetFrameworkArchitecture.Current,
-                true /* If the file is not found for the current architecture, it's OK to follow fallback mechanisms. */
+                canFallBackIfNecessary: true /* If the file is not found for the current architecture, it's OK to follow fallback mechanisms. */
             );
 
         /// <summary>
