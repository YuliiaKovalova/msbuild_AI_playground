diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index b6128c390d2..6524d3a81a8 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -16,25 +16,197 @@ namespace Microsoft.Build.Logging
     /// by implementing IEventSource and raising corresponding events.
     /// </summary>
     /// <remarks>The class is public so that we can call it from MSBuild.exe when replaying a log file.</remarks>
-    public sealed class BinaryLogReplayEventSource : EventArgsDispatcher, IEmbeddedContentSource
+    public sealed class BinaryLogReplayEventSource : BinaryLogReplayEventSourceBase, IEventSource, IEmbeddedContentSource
     {
-        /// Touches the <see cref="ItemGroupLoggingHelper"/> static constructor
-        /// to ensure it initializes <see cref="TaskParameterEventArgs.MessageGetter"/>
-        /// and <see cref="TaskParameterEventArgs.DictionaryFactory"/>
-        static BinaryLogReplayEventSource()
+        public BinaryLogReplayEventSource()
+            : base(true) { }
+
+        public bool AllowForwardCompatibility
         {
-            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
+            get => AllowForwardCompatibilityInternal;
+            set => AllowForwardCompatibilityInternal = value;
+        }
+
+        public event Action<string>? OnError
+        {
+            add => OnErrorInternal += value;
+            remove => OnErrorInternal -= value;
+        }
+
+        public event Action<BuildEventArgs>? BuildEventReceived
+        {
+            add => BuildEventReceivedInternal += value;
+            remove => BuildEventReceivedInternal -= value;
         }
 
         /// <summary>
-        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// This event is raised for all BuildEventArgs objects after a more type-specific event
         /// </summary>
-        /// <param name="sourceFilePath">The full file path of the binary log file</param>
-        public void Replay(string sourceFilePath)
+        public event AnyEventHandler? AnyEventRaised;
+
+        /// <summary>
+        /// Raised for BuildStatusEventArgs instances
+        /// </summary>
+        public event BuildStatusEventHandler? StatusEventRaised;
+
+        /// <summary>
+        /// Raised for CustomBuildEventArgs instances
+        /// </summary>
+        public event CustomBuildEventHandler? CustomEventRaised;
+
+        /// <summary>
+        /// Raised for BuildStartedEventArgs instances
+        /// </summary>
+        public event BuildStartedEventHandler? BuildStarted;
+
+        /// <summary>
+        /// Raised for BuildFinishedEventArgs instances
+        /// </summary>
+        public event BuildFinishedEventHandler? BuildFinished;
+
+        /// <summary>
+        /// Raised for ProjectStartedEventArgs instances
+        /// </summary>
+        public event ProjectStartedEventHandler? ProjectStarted;
+
+        /// <summary>
+        /// Raised for ProjectFinishedEventArgs instances
+        /// </summary>
+        public event ProjectFinishedEventHandler? ProjectFinished;
+
+        /// <summary>
+        /// Raised for TargetStartedEventArgs instances
+        /// </summary>
+        public event TargetStartedEventHandler? TargetStarted;
+
+        /// <summary>
+        /// Raised for TargetFinishedEventArgs instances
+        /// </summary>
+        public event TargetFinishedEventHandler? TargetFinished;
+
+        /// <summary>
+        /// Raised for TaskStartedEventArgs instances
+        /// </summary>
+        public event TaskStartedEventHandler? TaskStarted;
+
+        /// <summary>
+        /// Raised for TaskFinishedEventArgs instances
+        /// </summary>
+        public event TaskFinishedEventHandler? TaskFinished;
+
+        /// <summary>
+        /// Raised for BuildErrorEventArgs instances
+        /// </summary>
+        public event BuildErrorEventHandler? ErrorRaised;
+
+        /// <summary>
+        /// Raised for BuildWarningEventArgs instances
+        /// </summary>
+        public event BuildWarningEventHandler? WarningRaised;
+
+        /// <summary>
+        /// Raised for BuildMessageEventArgs instances
+        /// </summary>
+        public event BuildMessageEventHandler? MessageRaised;
+
+        /// <summary>
+        /// Raise one of the events that is appropriate for the type of the BuildEventArgs
+        /// </summary>
+        public void Dispatch(BuildEventArgs buildEvent)
         {
-            Replay(sourceFilePath, CancellationToken.None);
+            if (buildEvent is BuildMessageEventArgs buildMessageEventArgs)
+            {
+                MessageRaised?.Invoke(null, buildMessageEventArgs);
+            }
+            else if (buildEvent is TaskStartedEventArgs taskStartedEventArgs)
+            {
+                TaskStarted?.Invoke(null, taskStartedEventArgs);
+            }
+            else if (buildEvent is TaskFinishedEventArgs taskFinishedEventArgs)
+            {
+                TaskFinished?.Invoke(null, taskFinishedEventArgs);
+            }
+            else if (buildEvent is TargetStartedEventArgs targetStartedEventArgs)
+            {
+                TargetStarted?.Invoke(null, targetStartedEventArgs);
+            }
+            else if (buildEvent is TargetFinishedEventArgs targetFinishedEventArgs)
+            {
+                TargetFinished?.Invoke(null, targetFinishedEventArgs);
+            }
+            else if (buildEvent is ProjectStartedEventArgs projectStartedEventArgs)
+            {
+                ProjectStarted?.Invoke(null, projectStartedEventArgs);
+            }
+            else if (buildEvent is ProjectFinishedEventArgs projectFinishedEventArgs)
+            {
+                ProjectFinished?.Invoke(null, projectFinishedEventArgs);
+            }
+            else if (buildEvent is BuildStartedEventArgs buildStartedEventArgs)
+            {
+                BuildStarted?.Invoke(null, buildStartedEventArgs);
+            }
+            else if (buildEvent is BuildFinishedEventArgs buildFinishedEventArgs)
+            {
+                BuildFinished?.Invoke(null, buildFinishedEventArgs);
+            }
+            else if (buildEvent is CustomBuildEventArgs customBuildEventArgs)
+            {
+                CustomEventRaised?.Invoke(null, customBuildEventArgs);
+            }
+            else if (buildEvent is BuildStatusEventArgs buildStatusEventArgs)
+            {
+                StatusEventRaised?.Invoke(null, buildStatusEventArgs);
+            }
+            else if (buildEvent is BuildWarningEventArgs buildWarningEventArgs)
+            {
+                WarningRaised?.Invoke(null, buildWarningEventArgs);
+            }
+            else if (buildEvent is BuildErrorEventArgs buildErrorEventArgs)
+            {
+                ErrorRaised?.Invoke(null, buildErrorEventArgs);
+            }
+
+            AnyEventRaised?.Invoke(null, buildEvent);
+        }
+    }
+
+    public interface IRawLogEventsSource
+    {
+        public event Action<ArraySegment<byte>>? BuildEventReceived;
+    }
+
+    public sealed class BinaryLogReplayRawEventSource : BinaryLogReplayEventSourceBase, IRawLogEventsSource
+    {
+        public BinaryLogReplayRawEventSource()
+            : base(false) { }
+
+        public event Action<ArraySegment<byte>>? BuildEventReceived
+        {
+            add => RawBuildEventReceivedInternal += value;
+            remove => RawBuildEventReceivedInternal -= value;
+        }
+    }
+
+    public class BinaryLogReplayEventSourceBase : IEmbeddedContentSource
+    {
+        /// Touches the <see cref="ItemGroupLoggingHelper"/> static constructor
+        /// to ensure it initializes <see cref="TaskParameterEventArgs.MessageGetter"/>
+        /// and <see cref="TaskParameterEventArgs.DictionaryFactory"/>
+        static BinaryLogReplayEventSourceBase()
+        {
+            _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
+        internal BinaryLogReplayEventSourceBase(bool isStructured)
+            => _isStructuredReader = isStructured;
+
+        private bool _isStructuredReader;
+        protected bool AllowForwardCompatibilityInternal { get; set; } = true;
+        protected event Action<string>? OnErrorInternal;
+        protected event Action<BuildEventArgs>? BuildEventReceivedInternal;
+        protected event Action<ArraySegment<byte>>? RawBuildEventReceivedInternal;
+
         /// <summary>
         /// Creates a <see cref="BinaryReader"/> for the provided binary log file.
         /// Performs decompression and buffering in the optimal way.
@@ -54,9 +226,9 @@ public static BinaryReader OpenReader(string sourceFilePath)
                 // and the max throughput is reached with a 32K buffer. See details here:
                 // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
                 var bufferedStream = new BufferedStream(gzipStream, 32768);
-                return new BinaryReader(bufferedStream);
+                return new BinaryReader(bufferedStream.ToReadableSeekableStream());
             }
-            catch(Exception)
+            catch (Exception)
             {
                 stream?.Dispose();
                 throw;
@@ -69,14 +241,15 @@ public static BinaryReader OpenReader(string sourceFilePath)
         /// </summary>
         /// <param name="binaryReader"></param>
         /// <param name="closeInput">Indicates whether the passed BinaryReader should be closed on disposing.</param>
+        /// <param name="allowForwardCompatibility">Indicates whether reading of future versions of logs should be allowed.</param>
         /// <returns>BuildEventArgsReader over the given binlog file binary reader.</returns>
-        public static BuildEventArgsReader OpenBuildEventsReader(BinaryReader binaryReader, bool closeInput)
+        public static BuildEventArgsReader OpenBuildEventsReader(BinaryReader binaryReader, bool closeInput, bool allowForwardCompatibility = true)
         {
             int fileFormatVersion = binaryReader.ReadInt32();
 
             // the log file is written using a newer version of file format
             // that we don't know how to read
-            if (fileFormatVersion > BinaryLogger.FileFormatVersion)
+            if (!allowForwardCompatibility && fileFormatVersion > BinaryLogger.FileFormatVersion)
             {
                 var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnsupportedLogFileFormat", fileFormatVersion, BinaryLogger.FileFormatVersion);
                 throw new NotSupportedException(text);
@@ -95,6 +268,15 @@ public static BuildEventArgsReader OpenBuildEventsReader(BinaryReader binaryRead
         public static BuildEventArgsReader OpenBuildEventsReader(string sourceFilePath)
             => OpenBuildEventsReader(OpenReader(sourceFilePath), true);
 
+        /// <summary>
+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="sourceFilePath">The full file path of the binary log file</param>
+        public void Replay(string sourceFilePath)
+        {
+            Replay(sourceFilePath, CancellationToken.None);
+        }
+
         /// <summary>
         /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
         /// </summary>
@@ -102,7 +284,7 @@ public static BuildEventArgsReader OpenBuildEventsReader(string sourceFilePath)
         /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
         public void Replay(string sourceFilePath, CancellationToken cancellationToken)
         {
-            using var eventsReader = OpenBuildEventsReader(sourceFilePath);
+            using var eventsReader = BinaryLogReplayEventSource.OpenBuildEventsReader(sourceFilePath);
             Replay(eventsReader, cancellationToken);
         }
 
@@ -114,23 +296,44 @@ public void Replay(string sourceFilePath, CancellationToken cancellationToken)
         /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
         public void Replay(BinaryReader binaryReader, bool closeInput, CancellationToken cancellationToken)
         {
-            using var reader = OpenBuildEventsReader(binaryReader, closeInput);
+            using var reader = BinaryLogReplayEventSource.OpenBuildEventsReader(binaryReader, closeInput, AllowForwardCompatibilityInternal);
             Replay(reader, cancellationToken);
         }
 
-        /// <summary>
-        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
-        /// </summary>
-        /// <param name="reader">The build events reader - caller is responsible for disposing.</param>
-        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
         public void Replay(BuildEventArgsReader reader, CancellationToken cancellationToken)
         {
             _fileFormatVersionRead?.Invoke(reader.FileFormatVersion);
             reader.EmbeddedContentRead += _embeddedContentRead;
 
-            while (!cancellationToken.IsCancellationRequested && reader.Read() is { } instance)
+            if (_isStructuredReader)
+            {
+                ReplayStructured(reader, cancellationToken);
+            }
+            else
+            {
+                ReplayRaw(reader, cancellationToken);
+            }
+        }
+
+        private void ReplayStructured(BuildEventArgsReader reader, CancellationToken cancellationToken)
+        {
+            while (
+                !cancellationToken.IsCancellationRequested &&
+                reader.Read(AllowForwardCompatibilityInternal, AllowForwardCompatibilityInternal, OnErrorInternal ?? (_ => { }))
+                    is { } instance)
+            {
+                BuildEventReceivedInternal?.Invoke(instance);
+            }
+        }
+
+        private void ReplayRaw(BuildEventArgsReader reader, CancellationToken cancellationToken)
+        {
+            _fileFormatVersionRead?.Invoke(reader.FileFormatVersion);
+            reader.EmbeddedContentRead += _embeddedContentRead;
+
+            while (!cancellationToken.IsCancellationRequested && reader.ReadRaw() is { Count: > 0 } instance)
             {
-                Dispatch(instance);
+                RawBuildEventReceivedInternal?.Invoke(instance);
             }
         }
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 686152b6c62..1b62948bc1d 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
@@ -47,6 +48,11 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa
         /// </summary>
         private readonly StringStorage stringStorage = new StringStorage();
 
+        /// <summary>
+        /// Is the enderlying stream seekable?
+        /// </summary>
+        private readonly bool _canSeek;
+
         // reflection is needed to set these three fields because public constructors don't provide
         // a way to set these from the outside
         private static FieldInfo? buildEventArgsFieldThreadId =
@@ -62,6 +68,7 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa
         public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)
         {
             this.binaryReader = binaryReader;
+            this._canSeek = binaryReader.BaseStream.CanSeek;
             this.fileFormatVersion = fileFormatVersion;
         }
 
@@ -99,6 +106,87 @@ public void Dispose()
         /// <inheritdoc cref="IBuildFileReader.ArchiveFileEncountered"/>
         public event Action<ArchiveFileEventArgs>? ArchiveFileEncountered;
 
+        private byte[]? _pooledBuffer;
+        private BinaryWriter? _pooledBinaryWriter;
+
+        /// <summary>
+        /// Reads the next serialized log record from the <see cref="BinaryReader"/>.
+        /// </summary>
+        /// <returns>ArraySegment containing serialized BuildEventArgs record</returns>
+        public ArraySegment<byte> ReadRaw()
+        {
+            // TODO: For even better performance experiment with returning a stream
+            //   it would need to be concatenated Stream of a MemoryStream with kind and size
+            //   and SubStream over the binaryReader.BaseStream of the given size.
+            //   We'd need to validate that reader reads exactly the given size, or skip rest on their behalf.
+
+            BinaryLogRecordKind recordKind = ReadTillNextEvent();
+
+            if (recordKind == BinaryLogRecordKind.EndOfFile)
+            {
+                ReturnPooledBuffer();
+                return new ArraySegment<byte>();
+            }
+
+            int serializedEventLength = ReadInt32();
+
+            // The BinaryLogRecordKind and size needs to be added back to the buffer.
+            // We do not know the exact size needed to write those two upfront though,
+            //  so we need to call memoryStream.Position to find out.
+            (BinaryWriter binaryWriter, MemoryStream memoryStream, byte[] buffer) =
+                RentPooledBinaryWriter(serializedEventLength + 2 * sizeof(int));
+            binaryWriter.Write7BitEncodedInt((int)recordKind);
+            binaryWriter.Write7BitEncodedInt(serializedEventLength);
+
+            binaryReader.BaseStream.ReadAtLeast(buffer, (int)memoryStream.Position, serializedEventLength, throwOnEndOfStream: true);
+            // Size of the raw message and the preceding type and size info
+            return new ArraySegment<byte>(buffer, 0, serializedEventLength + (int)memoryStream.Position);
+        }
+
+        private byte[] RentPooledBuffer(int minimumBytes)
+        {
+            if (_pooledBuffer == null || _pooledBuffer.Length < minimumBytes)
+            {
+                ReturnPooledBuffer();
+                _pooledBuffer = ArrayPool<byte>.Shared.Rent(minimumBytes);
+            }
+
+            return _pooledBuffer;
+        }
+
+        private (BinaryWriter binaryWriter, MemoryStream memoryStream, byte[] buffer) RentPooledBinaryWriter(int minimumBytes)
+        {
+            if (_pooledBuffer == null || _pooledBuffer.Length < minimumBytes)
+            {
+                ReturnPooledBuffer();
+                _pooledBuffer = ArrayPool<byte>.Shared.Rent(minimumBytes);
+                _pooledBinaryWriter = null;
+            }
+
+            MemoryStream ms;
+            if (_pooledBinaryWriter == null)
+            {
+                ms = new(_pooledBuffer);
+                _pooledBinaryWriter = new BinaryWriter(ms);
+            }
+            else
+            {
+                ms = (_pooledBinaryWriter.BaseStream as MemoryStream)!;
+            }
+
+            return (_pooledBinaryWriter, ms, _pooledBuffer);
+        }
+
+        private void ReturnPooledBuffer()
+        {
+            if (_pooledBuffer != null)
+            {
+                ArrayPool<byte>.Shared.Return(_pooledBuffer);
+                _pooledBuffer = null;
+                _pooledBinaryWriter = null;
+            }
+        }
+
         /// <summary>
         /// Reads the next log record from the <see cref="BinaryReader"/>.
         /// </summary>
@@ -107,6 +195,164 @@ public void Dispose()
         /// If there are no more records, returns <see langword="null"/>.
         /// </returns>
         public BuildEventArgs? Read()
+        {
+            return Read(skipUnknownEvents: false, skipUnknownEventParts: false, _ => { });
+        }
+
+        /// <summary>
+        /// Reads the next log record from the <see cref="BinaryReader"/>.
+        /// </summary>
+        /// <param name="skipUnknownEvents">Indicates whether unknown BuildEvents should be silently skipped. Read returns null otherwise.</param>
+        /// <param name="skipUnknownEventParts">Indicates whether unread parts of BuildEvents (probably added in newer format of particular BuildEvent)should be silently skipped. Exception thrown otherwise.</param>
+        /// <param name="onError">Receives recoverable errors during reading.</param>
+        /// <returns>
+        /// The next <see cref="BuildEventArgs"/>.
+        /// If there are no more records, returns <see langword="null"/>.
+        /// </returns>
+        /// <exception cref="InvalidDataException">Thrown based on <paramref name="skipUnknownEventParts"/> and <paramref name="skipUnknownEvents"/> arguments.</exception>
+        public BuildEventArgs? Read(bool skipUnknownEvents, bool skipUnknownEventParts, Action<string> onError)
+        {
+            BuildEventArgs? result = null;
+            while (result == null)
+            {
+                BinaryLogRecordKind recordKind = ReadTillNextEvent();
+
+                if (recordKind == BinaryLogRecordKind.EndOfFile)
+                {
+                    return null;
+                }
+
+                int serializedEventLength = ReadInt32(); // record length
+
+                long preEventPosition = _canSeek ? binaryReader.BaseStream.Position : 0;
+
+                switch (recordKind)
+                {
+                    case BinaryLogRecordKind.BuildStarted:
+                        result = ReadBuildStartedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.BuildFinished:
+                        result = ReadBuildFinishedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.ProjectStarted:
+                        result = ReadProjectStartedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.ProjectFinished:
+                        result = ReadProjectFinishedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.TargetStarted:
+                        result = ReadTargetStartedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.TargetFinished:
+                        result = ReadTargetFinishedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.TaskStarted:
+                        result = ReadTaskStartedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.TaskFinished:
+                        result = ReadTaskFinishedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.Error:
+                        result = ReadBuildErrorEventArgs();
+                        break;
+                    case BinaryLogRecordKind.Warning:
+                        result = ReadBuildWarningEventArgs();
+                        break;
+                    case BinaryLogRecordKind.Message:
+                        result = ReadBuildMessageEventArgs();
+                        break;
+                    case BinaryLogRecordKind.CriticalBuildMessage:
+                        result = ReadCriticalBuildMessageEventArgs();
+                        break;
+                    case BinaryLogRecordKind.TaskCommandLine:
+                        result = ReadTaskCommandLineEventArgs();
+                        break;
+                    case BinaryLogRecordKind.TaskParameter:
+                        result = ReadTaskParameterEventArgs();
+                        break;
+                    case BinaryLogRecordKind.ProjectEvaluationStarted:
+                        result = ReadProjectEvaluationStartedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.ProjectEvaluationFinished:
+                        result = ReadProjectEvaluationFinishedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.ProjectImported:
+                        result = ReadProjectImportedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.TargetSkipped:
+                        result = ReadTargetSkippedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.EnvironmentVariableRead:
+                        result = ReadEnvironmentVariableReadEventArgs();
+                        break;
+                    case BinaryLogRecordKind.ResponseFileUsed:
+                        result = ReadResponseFileUsedEventArgs();
+                        break;
+                    case BinaryLogRecordKind.PropertyReassignment:
+                        result = ReadPropertyReassignmentEventArgs();
+                        break;
+                    case BinaryLogRecordKind.UninitializedPropertyRead:
+                        result = ReadUninitializedPropertyReadEventArgs();
+                        break;
+                    case BinaryLogRecordKind.PropertyInitialValueSet:
+                        result = ReadPropertyInitialValueSetEventArgs();
+                        break;
+                    case BinaryLogRecordKind.AssemblyLoad:
+                        result = ReadAssemblyLoadEventArgs();
+                        break;
+                    default:
+                        onError(
+                            $"BuildEvent record number {recordNumber} (serialized size: {serializedEventLength}) is of unsupported type: {recordKind}.{(skipUnknownEvents ? " Skipping it." : string.Empty)}");
+                        if (skipUnknownEvents)
+                        {
+                            SkipBytes(serializedEventLength);
+                        }
+                        else
+                        {
+                            return null;
+                        }
+                        break;
+                }
+
+                long postEventPosition = _canSeek ? binaryReader.BaseStream.Position : serializedEventLength;
+                int bytesRead = (int)(postEventPosition - preEventPosition);
+                if (bytesRead != serializedEventLength)
+                {
+                    string error =
+                        $"BuildEvent record number {recordNumber} was expected to read exactly {serializedEventLength} bytes from the stream, but read {bytesRead} instead.";
+
+                    if (skipUnknownEventParts && bytesRead < serializedEventLength)
+                    {
+                        onError(error);
+                        SkipBytes(serializedEventLength - bytesRead);
+                    }
+                    else
+                    {
+                        throw new InvalidDataException(error);
+                    }
+                }
+
+                recordNumber += 1;
+            }
+
+            return result;
+        }
+
+        private void SkipBytes(int count)
+        {
+            if (_canSeek)
+            {
+                binaryReader.BaseStream.Seek(count, SeekOrigin.Current);
+            }
+            else
+            {
+                byte[] buffer = RentPooledBuffer(count);
+                binaryReader.BaseStream.ReadAtLeast(buffer, 0, count, throwOnEndOfStream: true);
+                ReturnPooledBuffer();
+            }
+        }
+
+        private BinaryLogRecordKind ReadTillNextEvent()
         {
             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();
 
@@ -133,88 +379,7 @@ public void Dispose()
                 recordKind = (BinaryLogRecordKind)ReadInt32();
             }
 
-            BuildEventArgs? result = null;
-            switch (recordKind)
-            {
-                case BinaryLogRecordKind.EndOfFile:
-                    break;
-                case BinaryLogRecordKind.BuildStarted:
-                    result = ReadBuildStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.BuildFinished:
-                    result = ReadBuildFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectStarted:
-                    result = ReadProjectStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectFinished:
-                    result = ReadProjectFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TargetStarted:
-                    result = ReadTargetStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TargetFinished:
-                    result = ReadTargetFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TaskStarted:
-                    result = ReadTaskStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TaskFinished:
-                    result = ReadTaskFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.Error:
-                    result = ReadBuildErrorEventArgs();
-                    break;
-                case BinaryLogRecordKind.Warning:
-                    result = ReadBuildWarningEventArgs();
-                    break;
-                case BinaryLogRecordKind.Message:
-                    result = ReadBuildMessageEventArgs();
-                    break;
-                case BinaryLogRecordKind.CriticalBuildMessage:
-                    result = ReadCriticalBuildMessageEventArgs();
-                    break;
-                case BinaryLogRecordKind.TaskCommandLine:
-                    result = ReadTaskCommandLineEventArgs();
-                    break;
-                case BinaryLogRecordKind.TaskParameter:
-                    result = ReadTaskParameterEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectEvaluationStarted:
-                    result = ReadProjectEvaluationStartedEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectEvaluationFinished:
-                    result = ReadProjectEvaluationFinishedEventArgs();
-                    break;
-                case BinaryLogRecordKind.ProjectImported:
-                    result = ReadProjectImportedEventArgs();
-                    break;
-                case BinaryLogRecordKind.TargetSkipped:
-                    result = ReadTargetSkippedEventArgs();
-                    break;
-                case BinaryLogRecordKind.EnvironmentVariableRead:
-                    result = ReadEnvironmentVariableReadEventArgs();
-                    break;
-                case BinaryLogRecordKind.ResponseFileUsed:
-                    result = ReadResponseFileUsedEventArgs();
-                    break;
-                case BinaryLogRecordKind.PropertyReassignment:
-                    result = ReadPropertyReassignmentEventArgs();
-                    break;
-                case BinaryLogRecordKind.UninitializedPropertyRead:
-                    result = ReadUninitializedPropertyReadEventArgs();
-                    break;
-                case BinaryLogRecordKind.PropertyInitialValueSet:
-                    result = ReadPropertyInitialValueSetEventArgs();
-                    break;
-                case BinaryLogRecordKind.AssemblyLoad:
-                    result = ReadAssemblyLoadEventArgs();
-                    break;
-            }
-
-            recordNumber += 1;
-
-            return result;
+            return recordKind;
         }
 
         private static bool IsAuxiliaryRecord(BinaryLogRecordKind recordKind)
@@ -241,7 +406,7 @@ private void ReadEmbeddedContent(BinaryLogRecordKind recordKind)
                         new ProjectImportsCollector(Path.GetRandomFileName(), false, runOnBackground: false);
                 }
 
-                Stream embeddedStream = new SubStream(binaryReader.BaseStream, length);
+                Stream embeddedStream = binaryReader.BaseStream.Slice(length);
 
                 // We are intentionally not grace handling corrupt embedded stream
 
@@ -291,18 +456,11 @@ private void ReadEmbeddedContent(BinaryLogRecordKind recordKind)
             {
                 EmbeddedContentRead(new EmbeddedContentEventArgs(
                     recordKind.ToEmbeddedContentKind(),
-                    new SubStream(binaryReader.BaseStream, length)));
+                    binaryReader.BaseStream.Slice(length)));
             }
             else
             {
-                if (binaryReader.BaseStream.CanSeek)
-                {
-                    binaryReader.BaseStream.Seek(length, SeekOrigin.Current);
-                }
-                else
-                {
-                    binaryReader.ReadBytes(length);
-                }
+                SkipBytes(length);
             }
         }
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 99ffe22d96d..a0246b5d4fe 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -133,7 +133,10 @@ public BuildEventArgsWriter(BinaryWriter binaryWriter)
         /// </summary>
         public void Write(BuildEventArgs e)
         {
-            WriteCore(e);
+            BinaryLogRecordKind eventKind = WriteCore(e);
+
+            Write(eventKind);
+            Write((int)currentRecordStream.Length);
 
             // flush the current record and clear the MemoryStream to prepare for next use
             currentRecordStream.WriteTo(originalStream);
@@ -179,23 +182,23 @@ Base types and inheritance ("EventArgs" suffix omitted):
                     ExtendedCustomBuild
         */
 
-        private void WriteCore(BuildEventArgs e)
+        private BinaryLogRecordKind WriteCore(BuildEventArgs e)
         {
             switch (e)
             {
-                case BuildMessageEventArgs buildMessage: Write(buildMessage); break;
-                case TaskStartedEventArgs taskStarted: Write(taskStarted); break;
-                case TaskFinishedEventArgs taskFinished: Write(taskFinished); break;
-                case TargetStartedEventArgs targetStarted: Write(targetStarted); break;
-                case TargetFinishedEventArgs targetFinished: Write(targetFinished); break;
-                case BuildErrorEventArgs buildError: Write(buildError); break;
-                case BuildWarningEventArgs buildWarning: Write(buildWarning); break;
-                case ProjectStartedEventArgs projectStarted: Write(projectStarted); break;
-                case ProjectFinishedEventArgs projectFinished: Write(projectFinished); break;
-                case BuildStartedEventArgs buildStarted: Write(buildStarted); break;
-                case BuildFinishedEventArgs buildFinished: Write(buildFinished); break;
-                case ProjectEvaluationStartedEventArgs projectEvaluationStarted: Write(projectEvaluationStarted); break;
-                case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: Write(projectEvaluationFinished); break;
+                case BuildMessageEventArgs buildMessage: return Write(buildMessage);
+                case TaskStartedEventArgs taskStarted: return Write(taskStarted);
+                case TaskFinishedEventArgs taskFinished: return Write(taskFinished);
+                case TargetStartedEventArgs targetStarted: return Write(targetStarted);
+                case TargetFinishedEventArgs targetFinished: return Write(targetFinished);
+                case BuildErrorEventArgs buildError: return Write(buildError);
+                case BuildWarningEventArgs buildWarning: return Write(buildWarning);
+                case ProjectStartedEventArgs projectStarted: return Write(projectStarted);
+                case ProjectFinishedEventArgs projectFinished: return Write(projectFinished);
+                case BuildStartedEventArgs buildStarted: return Write(buildStarted);
+                case BuildFinishedEventArgs buildFinished: return Write(buildFinished);
+                case ProjectEvaluationStartedEventArgs projectEvaluationStarted: return Write(projectEvaluationStarted);
+                case ProjectEvaluationFinishedEventArgs projectEvaluationFinished: return Write(projectEvaluationFinished);
                 default:
                     // convert all unrecognized objects to message
                     // and just preserve the message
@@ -225,8 +228,7 @@ private void WriteCore(BuildEventArgs e)
                             e.Timestamp);
                     }
                     buildMessageEventArgs.BuildEventContext = e.BuildEventContext ?? BuildEventContext.Invalid;
-                    Write(buildMessageEventArgs);
-                    break;
+                    return Write(buildMessageEventArgs);
             }
         }
 
@@ -272,9 +274,8 @@ public void Dispose()
             }
         }
 
-        private void Write(BuildStartedEventArgs e)
+        private BinaryLogRecordKind Write(BuildStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.BuildStarted);
             WriteBuildEventArgsFields(e);
             if (Traits.LogAllEnvironmentVariables)
             {
@@ -284,26 +285,27 @@ private void Write(BuildStartedEventArgs e)
             {
                 Write(e.BuildEnvironment?.Where(kvp => EnvironmentUtilities.IsWellKnownEnvironmentDerivedProperty(kvp.Key)));
             }
+
+            return BinaryLogRecordKind.BuildStarted;
         }
 
-        private void Write(BuildFinishedEventArgs e)
+        private BinaryLogRecordKind Write(BuildFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.BuildFinished);
             WriteBuildEventArgsFields(e);
             Write(e.Succeeded);
+
+            return BinaryLogRecordKind.BuildFinished;
         }
 
-        private void Write(ProjectEvaluationStartedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectEvaluationStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectEvaluationStarted);
             WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
+            return BinaryLogRecordKind.ProjectEvaluationStarted;
         }
 
-        private void Write(ProjectEvaluationFinishedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectEvaluationFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectEvaluationFinished);
-
             WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
 
@@ -325,11 +327,12 @@ private void Write(ProjectEvaluationFinishedEventArgs e)
                     Write(item.Value);
                 }
             }
+
+            return BinaryLogRecordKind.ProjectEvaluationFinished;
         }
 
-        private void Write(ProjectStartedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectStarted);
             WriteBuildEventArgsFields(e, writeMessage: false);
 
             if (e.ParentProjectBuildEventContext == null)
@@ -353,62 +356,68 @@ private void Write(ProjectStartedEventArgs e)
             WriteProperties(e.Properties);
 
             WriteProjectItems(e.Items);
+
+            return BinaryLogRecordKind.ProjectStarted;
         }
 
-        private void Write(ProjectFinishedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectFinished);
             WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.ProjectFile);
             Write(e.Succeeded);
+
+            return BinaryLogRecordKind.ProjectFinished;
         }
 
-        private void Write(TargetStartedEventArgs e)
+        private BinaryLogRecordKind Write(TargetStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TargetStarted);
             WriteBuildEventArgsFields(e, writeMessage: false);
             WriteDeduplicatedString(e.TargetName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TargetFile);
             WriteDeduplicatedString(e.ParentTarget);
             Write((int)e.BuildReason);
+
+            return BinaryLogRecordKind.TargetStarted;
         }
 
-        private void Write(TargetFinishedEventArgs e)
+        private BinaryLogRecordKind Write(TargetFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TargetFinished);
             WriteBuildEventArgsFields(e, writeMessage: false);
             Write(e.Succeeded);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TargetFile);
             WriteDeduplicatedString(e.TargetName);
             WriteTaskItemList(e.TargetOutputs);
+
+            return BinaryLogRecordKind.TargetFinished;
         }
 
-        private void Write(TaskStartedEventArgs e)
+        private BinaryLogRecordKind Write(TaskStartedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TaskStarted);
             WriteBuildEventArgsFields(e, writeMessage: false, writeLineAndColumn: true);
             Write(e.LineNumber);
             Write(e.ColumnNumber);
             WriteDeduplicatedString(e.TaskName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TaskFile);
+
+            return BinaryLogRecordKind.TaskStarted;
         }
 
-        private void Write(TaskFinishedEventArgs e)
+        private BinaryLogRecordKind Write(TaskFinishedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TaskFinished);
             WriteBuildEventArgsFields(e, writeMessage: false);
             Write(e.Succeeded);
             WriteDeduplicatedString(e.TaskName);
             WriteDeduplicatedString(e.ProjectFile);
             WriteDeduplicatedString(e.TaskFile);
+
+            return BinaryLogRecordKind.TaskFinished;
         }
 
-        private void Write(BuildErrorEventArgs e)
+        private BinaryLogRecordKind Write(BuildErrorEventArgs e)
         {
-            Write(BinaryLogRecordKind.Error);
             WriteBuildEventArgsFields(e);
             WriteArguments(e.RawArguments);
             WriteDeduplicatedString(e.Subcategory);
@@ -419,11 +428,12 @@ private void Write(BuildErrorEventArgs e)
             Write(e.ColumnNumber);
             Write(e.EndLineNumber);
             Write(e.EndColumnNumber);
+
+            return BinaryLogRecordKind.Error;
         }
 
-        private void Write(BuildWarningEventArgs e)
+        private BinaryLogRecordKind Write(BuildWarningEventArgs e)
         {
-            Write(BinaryLogRecordKind.Warning);
             WriteBuildEventArgsFields(e);
             WriteArguments(e.RawArguments);
             WriteDeduplicatedString(e.Subcategory);
@@ -434,42 +444,42 @@ private void Write(BuildWarningEventArgs e)
             Write(e.ColumnNumber);
             Write(e.EndLineNumber);
             Write(e.EndColumnNumber);
+
+            return BinaryLogRecordKind.Warning;
         }
 
-        private void Write(BuildMessageEventArgs e)
+        private BinaryLogRecordKind Write(BuildMessageEventArgs e)
         {
             switch (e)
             {
-                case ResponseFileUsedEventArgs responseFileUsed: Write(responseFileUsed); break;
-                case TaskParameterEventArgs taskParameter: Write(taskParameter); break;
-                case ProjectImportedEventArgs projectImported: Write(projectImported); break;
-                case TargetSkippedEventArgs targetSkipped: Write(targetSkipped); break;
-                case PropertyReassignmentEventArgs propertyReassignment: Write(propertyReassignment); break;
-                case TaskCommandLineEventArgs taskCommandLine: Write(taskCommandLine); break;
-                case UninitializedPropertyReadEventArgs uninitializedPropertyRead: Write(uninitializedPropertyRead); break;
-                case EnvironmentVariableReadEventArgs environmentVariableRead: Write(environmentVariableRead); break;
-                case PropertyInitialValueSetEventArgs propertyInitialValueSet: Write(propertyInitialValueSet); break;
-                case CriticalBuildMessageEventArgs criticalBuildMessage: Write(criticalBuildMessage); break;
-                case AssemblyLoadBuildEventArgs assemblyLoad: Write(assemblyLoad); break;
+                case ResponseFileUsedEventArgs responseFileUsed: return Write(responseFileUsed);
+                case TaskParameterEventArgs taskParameter: return Write(taskParameter);
+                case ProjectImportedEventArgs projectImported: return Write(projectImported);
+                case TargetSkippedEventArgs targetSkipped: return Write(targetSkipped);
+                case PropertyReassignmentEventArgs propertyReassignment: return Write(propertyReassignment);
+                case TaskCommandLineEventArgs taskCommandLine: return Write(taskCommandLine);
+                case UninitializedPropertyReadEventArgs uninitializedPropertyRead: return Write(uninitializedPropertyRead);
+                case EnvironmentVariableReadEventArgs environmentVariableRead: return Write(environmentVariableRead);
+                case PropertyInitialValueSetEventArgs propertyInitialValueSet: return Write(propertyInitialValueSet);
+                case CriticalBuildMessageEventArgs criticalBuildMessage: return Write(criticalBuildMessage);
+                case AssemblyLoadBuildEventArgs assemblyLoad: return Write(assemblyLoad);
                 default: // actual BuildMessageEventArgs
-                    Write(BinaryLogRecordKind.Message);
                     WriteMessageFields(e, writeImportance: true);
-                    break;
+                    return BinaryLogRecordKind.Message;
             }
         }
 
-        private void Write(ProjectImportedEventArgs e)
+        private BinaryLogRecordKind Write(ProjectImportedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ProjectImported);
             WriteMessageFields(e);
             Write(e.ImportIgnored);
             WriteDeduplicatedString(e.ImportedProjectFile);
             WriteDeduplicatedString(e.UnexpandedProject);
+            return BinaryLogRecordKind.ProjectImported;
         }
 
-        private void Write(TargetSkippedEventArgs e)
+        private BinaryLogRecordKind Write(TargetSkippedEventArgs e)
         {
-            Write(BinaryLogRecordKind.TargetSkipped);
             WriteMessageFields(e, writeMessage: false);
             WriteDeduplicatedString(e.TargetFile);
             WriteDeduplicatedString(e.TargetName);
@@ -480,11 +490,11 @@ private void Write(TargetSkippedEventArgs e)
             Write((int)e.BuildReason);
             Write((int)e.SkipReason);
             binaryWriter.WriteOptionalBuildEventContext(e.OriginalBuildEventContext);
+            return BinaryLogRecordKind.TargetSkipped;
         }
 
-        private void Write(AssemblyLoadBuildEventArgs e)
+        private BinaryLogRecordKind Write(AssemblyLoadBuildEventArgs e)
         {
-            Write(BinaryLogRecordKind.AssemblyLoad);
             WriteMessageFields(e, writeMessage: false, writeImportance: false);
             Write((int)e.LoadingContext);
             WriteDeduplicatedString(e.LoadingInitiator);
@@ -492,63 +502,63 @@ private void Write(AssemblyLoadBuildEventArgs e)
             WriteDeduplicatedString(e.AssemblyPath);
             Write(e.MVID);
             WriteDeduplicatedString(e.AppDomainDescriptor);
+            return BinaryLogRecordKind.AssemblyLoad;
         }
 
-        private void Write(CriticalBuildMessageEventArgs e)
+        private BinaryLogRecordKind Write(CriticalBuildMessageEventArgs e)
         {
-            Write(BinaryLogRecordKind.CriticalBuildMessage);
             WriteMessageFields(e);
+            return BinaryLogRecordKind.CriticalBuildMessage;
         }
 
-        private void Write(PropertyReassignmentEventArgs e)
+        private BinaryLogRecordKind Write(PropertyReassignmentEventArgs e)
         {
-            Write(BinaryLogRecordKind.PropertyReassignment);
             WriteMessageFields(e, writeMessage: false, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
             WriteDeduplicatedString(e.PreviousValue);
             WriteDeduplicatedString(e.NewValue);
             WriteDeduplicatedString(e.Location);
+            return BinaryLogRecordKind.PropertyReassignment;
         }
 
-        private void Write(UninitializedPropertyReadEventArgs e)
+        private BinaryLogRecordKind Write(UninitializedPropertyReadEventArgs e)
         {
-            Write(BinaryLogRecordKind.UninitializedPropertyRead);
             WriteMessageFields(e, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
+            return BinaryLogRecordKind.UninitializedPropertyRead;
         }
 
-        private void Write(PropertyInitialValueSetEventArgs e)
+        private BinaryLogRecordKind Write(PropertyInitialValueSetEventArgs e)
         {
-            Write(BinaryLogRecordKind.PropertyInitialValueSet);
             WriteMessageFields(e, writeImportance: true);
             WriteDeduplicatedString(e.PropertyName);
             WriteDeduplicatedString(e.PropertyValue);
             WriteDeduplicatedString(e.PropertySource);
+            return BinaryLogRecordKind.PropertyInitialValueSet;
         }
 
-        private void Write(EnvironmentVariableReadEventArgs e)
+        private BinaryLogRecordKind Write(EnvironmentVariableReadEventArgs e)
         {
-            Write(BinaryLogRecordKind.EnvironmentVariableRead);
             WriteMessageFields(e, writeImportance: true);
             WriteDeduplicatedString(e.EnvironmentVariableName);
+            return BinaryLogRecordKind.EnvironmentVariableRead;
         }
-        private void Write(ResponseFileUsedEventArgs e)
+        private BinaryLogRecordKind Write(ResponseFileUsedEventArgs e)
         {
-            Write(BinaryLogRecordKind.ResponseFileUsed);
             WriteMessageFields(e);
             WriteDeduplicatedString(e.ResponseFilePath);
+            return BinaryLogRecordKind.ResponseFileUsed;
         }
-        private void Write(TaskCommandLineEventArgs e)
+        private BinaryLogRecordKind Write(TaskCommandLineEventArgs e)
         {
-            Write(BinaryLogRecordKind.TaskCommandLine);
             WriteMessageFields(e, writeMessage: false, writeImportance: true);
             WriteDeduplicatedString(e.CommandLine);
             WriteDeduplicatedString(e.TaskName);
+            return BinaryLogRecordKind.TaskCommandLine;
         }
 
-        private void Write(TaskParameterEventArgs e)
+        private BinaryLogRecordKind Write(TaskParameterEventArgs e)
         {
-            Write(BinaryLogRecordKind.TaskParameter);
             WriteMessageFields(e, writeMessage: false);
             Write((int)e.Kind);
             WriteDeduplicatedString(e.ItemType);
@@ -558,6 +568,7 @@ private void Write(TaskParameterEventArgs e)
             {
                 CheckForFilesToEmbed(e.ItemType, e.Items);
             }
+            return BinaryLogRecordKind.TaskParameter;
         }
 
         private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage = true, bool writeLineAndColumn = false)
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
new file mode 100644
index 00000000000..83492b0af2d
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -0,0 +1,57 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Logging
+{
+    internal static class StreamExtensions
+    {
+        public static int ReadAtLeast(this Stream stream, byte[] buffer, int offset, int minimumBytes, bool throwOnEndOfStream)
+        {
+            Debug.Assert(offset + minimumBytes <= buffer.Length);
+
+            int totalRead = 0;
+            while (totalRead < minimumBytes)
+            {
+                int read = stream.Read(buffer, offset, minimumBytes - totalRead);
+                if (read == 0)
+                {
+                    if (throwOnEndOfStream)
+                    {
+                        throw new InvalidDataException("Unexpected end of stream.");
+                    }
+
+                    return totalRead;
+                }
+
+                totalRead += read;
+                offset += read;
+            }
+
+            return totalRead;
+        }
+
+        public static Stream ToReadableSeekableStream(this Stream stream)
+        {
+            return TransparentReadStream.CreateSeekableStream(stream);
+        }
+
+        /// <summary>
+        /// Creates bounded read-only, forward-only view over an underlying stream.
+        /// </summary>
+        /// <param name="stream"></param>
+        /// <param name="length"></param>
+        /// <returns></returns>
+        public static Stream Slice(this Stream stream, long length)
+        {
+            return new SubStream(stream, length);
+        }
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
new file mode 100644
index 00000000000..5061a7c3b00
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
@@ -0,0 +1,112 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Buffers;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Runtime.InteropServices.ComTypes;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// A wrapper stream that allows position tracking and forward seeking.
+    /// </summary>
+    internal class TransparentReadStream : Stream
+    {
+        private readonly Stream _stream;
+        private long _position;
+
+        public static Stream CreateSeekableStream(Stream stream)
+        {
+            if (stream.CanSeek)
+            {
+                return stream;
+            }
+
+            if(!stream.CanRead)
+            {
+                throw new InvalidOperationException("Stream must be readable.");
+            }
+
+            return new TransparentReadStream(stream);
+        }
+
+        private TransparentReadStream(Stream stream)
+        {
+            _stream = stream;
+        }
+
+        public override bool CanRead => _stream.CanRead;
+        public override bool CanSeek => true;
+        public override bool CanWrite => false;
+        public override long Length => _stream.Length;
+        public override long Position
+        {
+            get => _position;
+            set => SkipBytes(value - _position);
+        }
+
+        public override void Flush()
+        {
+            _stream.Flush();
+        }
+
+        public override int Read(byte[] buffer, int offset, int count)
+        {
+            int cnt = _stream.Read(buffer, offset, count);
+            _position += cnt;
+            return cnt;
+        }
+
+        public override long Seek(long offset, SeekOrigin origin)
+        {
+            if(origin != SeekOrigin.Current)
+            {
+                throw new InvalidOperationException("Only seeking from SeekOrigin.Current is supported.");
+            }
+
+            SkipBytes(offset);
+
+            return _position;
+        }
+
+        public override void SetLength(long value)
+        {
+            throw new InvalidOperationException("Expanding stream is not supported.");
+        }
+
+        public override void Write(byte[] buffer, int offset, int count)
+        {
+            throw new InvalidOperationException("Writing is not supported.");
+        }
+
+        private void SkipBytes(long count)
+        {
+            if(count < 0)
+            {
+                throw new InvalidOperationException("Seeking backwards is not supported.");
+            }
+
+            if(count == 0)
+            {
+                return;
+            }
+
+            byte[] buffer = ArrayPool<byte>.Shared.Rent((int)count);
+            try
+            {
+                _position += _stream.ReadAtLeast(buffer, 0, (int)count, throwOnEndOfStream: true);
+            }
+            finally
+            {
+                ArrayPool<byte>.Shared.Return(buffer);
+            }
+        }
+
+        public override void Close() => _stream.Close();
+    }
+}
