diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index 6c23f2c1044..c2c2b91bde9 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -8,6 +8,8 @@
 using System.IO;
 using System.Reflection;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
 using Shouldly;
 using Xunit;
 
@@ -235,6 +237,35 @@ public void TestSerializeException_NestedWithStack()
             Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));
         }
 
+        [Fact]
+        public void TestSerializeBuildException_NestedWithStack()
+        {
+            Exception value = null;
+            try
+            {
+                throw new InvalidProjectFileException("sample message");
+            }
+            catch (Exception e)
+            {
+                try
+                {
+                    throw new ArgumentNullException("The argument was null", e);
+                }
+                catch (Exception exception)
+                {
+                    value = new InternalErrorException("Another message", exception);
+                }
+            }
+
+            Assert.NotNull(value);
+            TranslationHelpers.GetWriteTranslator().TranslateException(ref value);
+
+            Exception deserializedValue = null;
+            TranslationHelpers.GetReadTranslator().TranslateException(ref deserializedValue);
+
+            Assert.True(TranslationHelpers.CompareExceptions(value, deserializedValue));
+        }
+
         /// <summary>
         /// Tests serializing an object with a default constructor.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
index 657bfc4b4fb..21636513441 100644
--- a/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeFailedToLaunchException.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.BackEnd
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    internal class NodeFailedToLaunchException : Exception
+    internal class NodeFailedToLaunchException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard NodeFailedToLaunchException.
@@ -33,6 +33,10 @@ internal NodeFailedToLaunchException(Exception innerException)
             : base(innerException.Message, innerException)
         { }
 
+        public NodeFailedToLaunchException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Constructs a standard NodeFailedToLaunchException.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
index 3b1a9bb3dca..5152df6dbfb 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheException.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Experimental.ProjectCache
     /// This exception is used to wrap an unhandled exception from a project cache plugin. This exception aborts the build, and it can only be
     /// thrown by the MSBuild engine.
     /// </summary>
-    public sealed class ProjectCacheException : Exception
+    public sealed class ProjectCacheException : BuildExceptionBase
     {
         private ProjectCacheException()
         {
@@ -33,6 +34,11 @@ private ProjectCacheException(
             ErrorCode = errorCode;
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        private ProjectCacheException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// The project cache has already logged this as an error.
         /// Should not get logged again.
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
index 405d0290483..849bf195026 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulerCircularDependencyException.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors", Justification = "No point in adding the serialization constructors since BuildRequest is not serializable")]
     [SuppressMessage("Microsoft.Usage", "CA2237:MarkISerializableTypesWithSerializable", Justification = "No point in marking as ISerializable since BuildRequest is not. ")]
-    internal class SchedulerCircularDependencyException : Exception
+    internal class SchedulerCircularDependencyException : BuildExceptionBase
     {
         /// <summary>
         /// The ancestors which led to this circular dependency.
@@ -35,6 +35,11 @@ public SchedulerCircularDependencyException(BuildRequest request, IList<Schedula
             _ancestors = ancestors;
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal SchedulerCircularDependencyException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Gets an enumeration of the ancestors which led to this circular dependency.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
index bd8af074fb0..eb8a1bf87d8 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverException.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// <summary>
     /// Represents an exception that occurs when an SdkResolver throws an unhandled exception.
     /// </summary>
-    public class SdkResolverException : Exception
+    public class SdkResolverException : BuildExceptionBase
     {
         public SdkResolver Resolver { get; private set; }
 
@@ -24,5 +24,10 @@ public SdkResolverException(string resourceName, SdkResolver resolver, SdkRefere
             Resolver = resolver;
             Sdk = sdk;
         }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal SdkResolverException(string message, Exception inner)
+            : base(message, inner)
+        { }
     }
 }
diff --git a/src/Build/BackEnd/Shared/BuildAbortedException.cs b/src/Build/BackEnd/Shared/BuildAbortedException.cs
index ab5d34af0e4..54384181025 100644
--- a/src/Build/BackEnd/Shared/BuildAbortedException.cs
+++ b/src/Build/BackEnd/Shared/BuildAbortedException.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -21,7 +23,7 @@ namespace Microsoft.Build.Exceptions
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    public class BuildAbortedException : Exception
+    public class BuildAbortedException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard BuildAbortedException.
@@ -49,11 +51,41 @@ public BuildAbortedException(string message)
         /// Constructs a BuildAbortedException with an additional message attached and an inner exception.
         /// </summary>
         public BuildAbortedException(string message, Exception innerException)
-            : base(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildAbortedWithMessage", message), innerException)
+            : this(message, innerException, false)
+        { }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        private static BuildAbortedException CreateFromRemote(string message, Exception innerException)
         {
-            ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "BuildAbortedWithMessage", message);
+            return new BuildAbortedException(message, innerException, true /* calledFromDeserialization */);
+        }
 
-            ErrorCode = errorCode;
+        private BuildAbortedException(string message, Exception innerException, bool calledFromDeserialization)
+            : base(
+                calledFromDeserialization
+                    ? message
+                    : ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildAbortedWithMessage", message),
+                innerException)
+        {
+            if (!calledFromDeserialization)
+            {
+                ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out _, "BuildAbortedWithMessage", message);
+
+                ErrorCode = errorCode;
+            }
+        }
+
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(ErrorCode), ErrorCode }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            ErrorCode = state[nameof(ErrorCode)];
         }
 
         /// <summary>
@@ -70,7 +102,7 @@ protected BuildAbortedException(SerializationInfo info, StreamingContext context
         /// Gets the error code (if any) associated with the exception message.
         /// </summary>
         /// <value>Error code string, or null.</value>
-        public string ErrorCode { get; }
+        public string ErrorCode { get; private set; }
 
         /// <summary>
         /// ISerializable method which we must override since Exception implements this interface
diff --git a/src/Build/BackEnd/Shared/CircularDependencyException.cs b/src/Build/BackEnd/Shared/CircularDependencyException.cs
index 08cfb2a4783..e1b37dc6c72 100644
--- a/src/Build/BackEnd/Shared/CircularDependencyException.cs
+++ b/src/Build/BackEnd/Shared/CircularDependencyException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
 
 #nullable disable
 
@@ -16,7 +17,7 @@ namespace Microsoft.Build.Exceptions
     /// If you add fields to this class, add a custom serialization constructor and override GetObjectData().
     /// </remarks>
     [Serializable]
-    public class CircularDependencyException : Exception
+    public class CircularDependencyException : BuildExceptionBase
     {
         /// <summary>
         /// Constructs a standard BuildAbortedException.
@@ -30,6 +31,11 @@ internal CircularDependencyException(string message)
         {
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal CircularDependencyException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Constructor for deserialization.
         /// </summary>
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 06daa610cd9..89e5139ea48 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -3,12 +3,14 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Framework;
+using System.Collections.Generic;
 
 #nullable disable
 
@@ -22,7 +24,7 @@ namespace Microsoft.Build.Exceptions
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public sealed class InternalLoggerException : Exception
+    public sealed class InternalLoggerException : BuildExceptionBase
     {
         #region Unusable constructors
 
@@ -63,9 +65,7 @@ public InternalLoggerException(string message)
         /// <exception cref="InvalidOperationException"></exception>
         public InternalLoggerException(string message, Exception innerException)
             : base(message, innerException)
-        {
-            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
-        }
+        { }
 
         #endregion
 
@@ -136,6 +136,23 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("initializationException", initializationException);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+                { nameof(initializationException), initializationException.ToString() },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+            initializationException = bool.Parse(state[nameof(initializationException)]);
+        }
+
         /// <summary>
         /// Provide default values for optional members
         /// </summary>
diff --git a/src/Build/Errors/InvalidProjectFileException.cs b/src/Build/Errors/InvalidProjectFileException.cs
index 71c7d93d2cc..ff6e47dc437 100644
--- a/src/Build/Errors/InvalidProjectFileException.cs
+++ b/src/Build/Errors/InvalidProjectFileException.cs
@@ -3,6 +3,8 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
+using System.Collections.Generic;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -21,7 +23,7 @@ namespace Microsoft.Build.Exceptions
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public sealed class InvalidProjectFileException : Exception
+    public sealed class InvalidProjectFileException : BuildExceptionBase
     {
         #region Basic constructors
 
@@ -122,6 +124,35 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("hasBeenLogged", hasBeenLogged);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(file), file },
+                { nameof(lineNumber), lineNumber.ToString() },
+                { nameof(columnNumber), columnNumber.ToString() },
+                { nameof(endLineNumber), endLineNumber.ToString() },
+                { nameof(endColumnNumber), endColumnNumber.ToString() },
+                { nameof(errorSubcategory), errorSubcategory },
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+                { nameof(hasBeenLogged), hasBeenLogged.ToString() },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            file = state[nameof(file)];
+            lineNumber = int.Parse(state[nameof(lineNumber)]);
+            columnNumber = int.Parse(state[nameof(columnNumber)]);
+            endLineNumber = int.Parse(state[nameof(endLineNumber)]);
+            endColumnNumber = int.Parse(state[nameof(endColumnNumber)]);
+            errorSubcategory = state[nameof(errorSubcategory)];
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+            hasBeenLogged = bool.Parse(state[nameof(hasBeenLogged)]);
+        }
+
         #endregion
 
         #region Rich constructors
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 9f7c51e0b61..ba704d024da 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -5,6 +5,8 @@
 
 using Microsoft.Build.Shared;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
+using System.Collections.Generic;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -17,7 +19,7 @@ namespace Microsoft.Build.Exceptions
     /// Exception subclass that ToolsetReaders should throw.
     /// </summary>
     [Serializable]
-    public class InvalidToolsetDefinitionException : Exception
+    public class InvalidToolsetDefinitionException : BuildExceptionBase
     {
         /// <summary>
         /// The MSBuild error code corresponding with this exception.
@@ -103,6 +105,19 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("errorCode", errorCode);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+        }
+
         /// <summary>
         /// The MSBuild error code corresponding with this exception, or
         /// null if none was specified.
diff --git a/src/Build/Errors/RegistryException.cs b/src/Build/Errors/RegistryException.cs
index 13d4335634d..bebbbe24619 100644
--- a/src/Build/Errors/RegistryException.cs
+++ b/src/Build/Errors/RegistryException.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
 
 #nullable disable
 
@@ -12,7 +13,7 @@ namespace Microsoft.Build.Exceptions
     /// Generic exception used to wrap exceptions thrown during Registry access.
     /// </summary>
     [Serializable]
-    internal class RegistryException : Exception
+    internal class RegistryException : BuildExceptionBase
     {
         /// <summary>
         /// Basic constructor.
diff --git a/src/Build/Instance/HostObjectException.cs b/src/Build/Instance/HostObjectException.cs
index a38d07726c0..521223aabb5 100644
--- a/src/Build/Instance/HostObjectException.cs
+++ b/src/Build/Instance/HostObjectException.cs
@@ -2,13 +2,14 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using Microsoft.Build.BackEnd;
 
 #nullable disable
 
 namespace Microsoft.Build.Execution
 {
     [Serializable]
-    internal sealed class HostObjectException : Exception
+    internal sealed class HostObjectException : BuildExceptionBase
     {
         private const string ErrorMessagePrefix = "Error for HostObject:";
         private const string ErrorMessageProjectTargetTask = "In Project '{0}', Target '{1}', Task '{2}'.";
@@ -56,5 +57,17 @@ internal HostObjectException(
                 + string.Format(ErrorMessageProjectTargetTask, projectFile, targetName, taskName) + message)
         {
         }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        private static HostObjectException CreateFromRemote(string message, Exception innerException)
+        {
+            return new HostObjectException(message, innerException, true /* calledFromDeserialization */);
+        }
+
+        private HostObjectException(string message, Exception innerException, bool calledFromDeserialization)
+            : base(
+                message,
+                innerException)
+        { }
     }
 }
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index 25667c21f6c..966fb665d60 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Xml;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -16,12 +17,17 @@ namespace Microsoft.Build.Internal
     /// <summary>
     /// Exception indicating that we tried to build a type of project MSBuild did not recognize.
     /// </summary>
-    internal sealed class UnbuildableProjectTypeException : Exception
+    internal sealed class UnbuildableProjectTypeException : BuildExceptionBase
     {
         internal UnbuildableProjectTypeException(string file)
             : base(file)
         {
         }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        internal UnbuildableProjectTypeException(string message, Exception inner)
+            : base(message, inner)
+        { }
     }
 
     /// <summary>
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 7a3b0159b48..826f2f0694e 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -487,7 +487,7 @@ public void TranslateException(ref Exception value)
                     return;
                 }
 
-                value = BuildTransferredException.ReadExceptionFromTranslator(this);
+                value = BuildExceptionBase.ReadExceptionFromTranslator(this);
             }
 
 
@@ -1121,7 +1121,7 @@ public void TranslateException(ref Exception value)
                     return;
                 }
 
-                BuildTransferredException.WriteExceptionToTranslator(this, value);
+                BuildExceptionBase.WriteExceptionToTranslator(this, value);
             }
 
             /// <summary>
diff --git a/src/Framework/BuildException.cs b/src/Framework/BuildException.cs
new file mode 100644
index 00000000000..18978d8ef14
--- /dev/null
+++ b/src/Framework/BuildException.cs
@@ -0,0 +1,234 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Runtime.Serialization;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal static class BuildExceptionSerializationHelper
+    {
+        private static readonly Dictionary<string, Func<string, Exception?, BuildExceptionBase>> s_exceptionFactories = FetchExceptionsConstructors();
+
+        private static readonly Func<string, Exception?, BuildExceptionBase> s_defaultFactory =
+            (message, innerException) => new GenericBuildTransferredException(message, innerException);
+
+        private static Dictionary<string, Func<string, Exception?, BuildExceptionBase>> FetchExceptionsConstructors()
+        {
+            var exceptionFactories = new Dictionary<string, Func<string, Exception?, BuildExceptionBase>>();
+
+            foreach (Type exceptionType in AppDomain.CurrentDomain.GetAssemblies().SelectMany(s => s.GetTypes()).Where(myType => myType.IsClass && !myType.IsAbstract && myType.IsSubclassOf(typeof(BuildExceptionBase))))
+            {
+                MethodInfo? methodInfo = exceptionType.GetMethod(
+                    "CreateFromRemote",
+                    BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic,
+                    null,
+                    new[] { typeof(string), typeof(Exception) },
+                    null);
+
+                if (methodInfo != null)
+                {
+                    string key = GetExceptionSerializationKey(exceptionType);
+                    var value = (Func<string, Exception?, BuildExceptionBase>) Delegate.CreateDelegate(typeof(Func<string, Exception?, BuildExceptionBase>), methodInfo);
+
+                    exceptionFactories[key] = value;
+                    continue;
+                }
+
+                ConstructorInfo? ctorInfo = exceptionType.GetConstructor(
+                    BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance,
+                    null,
+                    new[] { typeof(string), typeof(Exception) },
+                    null);
+
+                if (ctorInfo != null)
+                {
+                    string key = GetExceptionSerializationKey(exceptionType);
+                    Func<string, Exception?, BuildExceptionBase> value = (message, innerException) =>
+                            (BuildExceptionBase)ctorInfo.Invoke(new object?[] { message, innerException });
+
+                    exceptionFactories[key] = value;
+                }
+            }
+
+            return exceptionFactories;
+        }
+
+        internal static string GetExceptionSerializationKey(Type exceptionType)
+        {
+            return exceptionType.FullName ?? exceptionType.ToString();
+        }
+
+        internal static Func<string, Exception?, BuildExceptionBase> CreateExceptionFactory(string serializationType)
+        {
+            Func<string, Exception?, BuildExceptionBase>? factory;
+            if (!s_exceptionFactories.TryGetValue(serializationType, out factory))
+            {
+                factory = s_defaultFactory;
+            }
+
+            return factory;
+        }
+    }
+
+    public abstract class BuildExceptionBase : Exception
+    {
+        private string? _remoteTypeName;
+        private string? _remoteStackTrace;
+
+        protected BuildExceptionBase()
+            : base()
+        { }
+
+        protected BuildExceptionBase(string message)
+            : base(message)
+        { }
+
+        protected BuildExceptionBase(
+            string message,
+            Exception? inner)
+            : base(message, inner)
+        { }
+
+        // This is needed as soon as we allow opt out of the non-BinaryFormatter serialization
+        protected BuildExceptionBase(SerializationInfo info, StreamingContext context)
+            : base(info, context)
+        { }
+
+        public override string? StackTrace => string.IsNullOrEmpty(_remoteStackTrace) ? base.StackTrace : _remoteStackTrace;
+
+        public override string ToString() => string.IsNullOrEmpty(_remoteTypeName) ? base.ToString() : $"{_remoteTypeName}->{base.ToString()}";
+
+        protected virtual void InitializeCustomState(IDictionary<string, string?>? customKeyedSerializedData)
+        { /* This is it. Override for exceptions with custom state */ }
+
+        protected virtual IDictionary<string, string?>? FlushCustomState()
+        {
+            /* This is it. Override for exceptions with custom state */
+            return null;
+        }
+
+        private void InitializeFromRemoteState(
+            string remoteTypeName,
+            string? remoteStackTrace,
+            string? source,
+            string? helpLink,
+            int hresult,
+            IDictionary<string, string?>? customKeyedSerializedData)
+        {
+            _remoteTypeName = remoteTypeName;
+            _remoteStackTrace = remoteStackTrace;
+            base.Source = source;
+            base.HelpLink = helpLink;
+            base.HResult = hresult;
+            if (customKeyedSerializedData != null)
+            {
+                InitializeCustomState(customKeyedSerializedData);
+            }
+        }
+
+        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)
+        {
+            BinaryWriter writer = translator.Writer;
+            writer.Write(exception.InnerException != null);
+            if (exception.InnerException != null)
+            {
+                WriteExceptionToTranslator(translator, exception.InnerException);
+            }
+
+            writer.Write(BuildExceptionSerializationHelper.GetExceptionSerializationKey(exception.GetType()));
+            writer.Write(exception.Message);
+            writer.WriteOptionalString(exception.StackTrace);
+            writer.WriteOptionalString(exception.Source);
+            writer.WriteOptionalString(exception.HelpLink);
+            // HResult is completely protected up till net4.5
+#if NET || NET45_OR_GREATER
+            writer.Write((byte)1);
+            writer.Write(exception.HResult);
+#else
+            writer.Write((byte)0);
+#endif
+
+            IDictionary<string, string?>? customKeyedSerializedData = (exception as BuildExceptionBase)?.FlushCustomState();
+            if (customKeyedSerializedData == null)
+            {
+                writer.Write((byte)0);
+            }
+            else
+            {
+                writer.Write((byte)1);
+                writer.Write(customKeyedSerializedData.Count);
+                foreach (var pair in customKeyedSerializedData)
+                {
+                    writer.Write(pair.Key);
+                    writer.WriteOptionalString(pair.Value);
+                }
+            }
+
+            Debug.Assert((exception.Data?.Count ?? 0) == 0,
+                "Exception Data is not supported in BuildTransferredException");
+        }
+
+        internal static Exception ReadExceptionFromTranslator(ITranslator translator)
+        {
+            BinaryReader reader = translator.Reader;
+            Exception? innerException = null;
+            if (reader.ReadBoolean())
+            {
+                innerException = ReadExceptionFromTranslator(translator);
+            }
+
+            string serializationType = reader.ReadString();
+            string message = reader.ReadString();
+            string? deserializedStackTrace = reader.ReadOptionalString();
+            string? source = reader.ReadOptionalString();
+            string? helpLink = reader.ReadOptionalString();
+            int hResult = reader.ReadOptionalInt32();
+
+            IDictionary<string, string?>? customKeyedSerializedData = null;
+            if (reader.ReadByte() == 1)
+            {
+                int count = reader.ReadInt32();
+                customKeyedSerializedData = new Dictionary<string, string?>(count, StringComparer.CurrentCulture);
+
+                for (int i = 0; i < count; i++)
+                {
+                    customKeyedSerializedData[reader.ReadString()] = reader.ReadOptionalString();
+                }
+            }
+
+            Exception exception = BuildExceptionSerializationHelper.CreateExceptionFactory(serializationType)(message, innerException);
+
+            if (exception is BuildExceptionBase buildException)
+            {
+                buildException.InitializeFromRemoteState(
+                    serializationType,
+                    deserializedStackTrace,
+                    source,
+                    helpLink,
+                    hResult,
+                    customKeyedSerializedData);
+            }
+
+            return exception;
+        }
+    }
+
+    /// <summary>
+    /// A catch-all type for remote exceptions that we don't know how to deserialize.
+    /// </summary>
+    internal sealed class GenericBuildTransferredException : BuildExceptionBase
+    {
+        internal GenericBuildTransferredException(
+            string message,
+            Exception? inner)
+            : base(message, inner)
+        { }
+    }
+}
diff --git a/src/Framework/BuildTransferredException.cs b/src/Framework/BuildTransferredException.cs
deleted file mode 100644
index e84e8cc6c36..00000000000
--- a/src/Framework/BuildTransferredException.cs
+++ /dev/null
@@ -1,77 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.Diagnostics;
-using System.IO;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.BackEnd
-{
-    internal sealed class BuildTransferredException : Exception
-    {
-        private readonly string _originalTypeName;
-
-        public BuildTransferredException(
-            string message,
-            Exception? inner,
-            string originalTypeName,
-            string? deserializedStackTrace)
-            : base(message, inner)
-        {
-            _originalTypeName = originalTypeName;
-            StackTrace = deserializedStackTrace;
-        }
-
-        public override string? StackTrace { get; }
-
-        public override string ToString() => $"{_originalTypeName}->{base.ToString()}";
-
-        internal static Exception ReadExceptionFromTranslator(ITranslator translator)
-        {
-            BinaryReader reader = translator.Reader;
-            Exception? innerException = null;
-            if (reader.ReadBoolean())
-            {
-                innerException = ReadExceptionFromTranslator(translator);
-            }
-
-            string message = reader.ReadString();
-            string typeName = reader.ReadString();
-            string? deserializedStackTrace = reader.ReadOptionalString();
-            BuildTransferredException exception = new(message, innerException, typeName, deserializedStackTrace)
-            {
-                Source = reader.ReadOptionalString(),
-                HelpLink = reader.ReadOptionalString(),
-                HResult = reader.ReadOptionalInt32(),
-            };
-
-            return exception;
-        }
-
-        internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception)
-        {
-            BinaryWriter writer = translator.Writer;
-            writer.Write(exception.InnerException != null);
-            if (exception.InnerException != null)
-            {
-                WriteExceptionToTranslator(translator, exception.InnerException);
-            }
-            writer.Write(exception.Message);
-            writer.Write(exception.GetType().FullName ?? exception.GetType().ToString());
-            writer.WriteOptionalString(exception.StackTrace);
-            writer.WriteOptionalString(exception.Source);
-            writer.WriteOptionalString(exception.HelpLink);
-            // HResult is completely protected up till net4.5
-#if NET || NET45_OR_GREATER
-            writer.Write((byte)1);
-            writer.Write(exception.HResult);
-#else
-            writer.Write((byte)0);
-#endif
-
-            Debug.Assert((exception.Data?.Count ?? 0) == 0,
-                "Exception Data is not supported in BuildTransferredException");
-        }
-    }
-}
diff --git a/src/Framework/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
index 86383e09bbb..200988c99a8 100644
--- a/src/Framework/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Diagnostics;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
 
 #nullable disable
 
@@ -15,7 +16,7 @@ namespace Microsoft.Build.Framework
     /// did wrong.
     /// </summary>
     [Serializable]
-    internal sealed class InternalErrorException : Exception
+    internal sealed class InternalErrorException : BuildExceptionBase
     {
         /// <summary>
         /// Default constructor.
@@ -45,9 +46,28 @@ internal InternalErrorException(
         internal InternalErrorException(
             String message,
             Exception innerException) :
-            base("MSB0001: Internal MSBuild Error: " + message + (innerException == null ? String.Empty : ("\n=============\n" + innerException.ToString() + "\n\n")), innerException)
+            this(message, innerException, false)
+        { }
+
+        // Do not remove - used by BuildExceptionSerializationHelper
+        private static InternalErrorException CreateFromRemote(string message, Exception innerException)
+        {
+            return new InternalErrorException(message, innerException, true /* calledFromDeserialization */);
+        }
+
+        private InternalErrorException(string message, Exception innerException, bool calledFromDeserialization)
+            : base(
+                calledFromDeserialization
+                    ? message
+                    : "MSB0001: Internal MSBuild Error: " + message + (innerException == null
+                        ? String.Empty
+                        : ("\n=============\n" + innerException.ToString() + "\n\n")),
+                innerException)
         {
-            ConsiderDebuggerLaunch(message, innerException);
+            if (!calledFromDeserialization)
+            {
+                ConsiderDebuggerLaunch(message, innerException);
+            }
         }
 
         #region Serialization (update when adding new class members)
diff --git a/src/Framework/LoggerException.cs b/src/Framework/LoggerException.cs
index ba423ceba87..45533829b48 100644
--- a/src/Framework/LoggerException.cs
+++ b/src/Framework/LoggerException.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions; // for SecurityPermissionAttribute
 #endif
@@ -20,7 +22,7 @@ namespace Microsoft.Build.Framework
     // promise to never change the type's fields i.e. the type is immutable; adding new fields in the next version of the type
     // without following certain special FX guidelines, can break both forward and backward compatibility
     [Serializable]
-    public class LoggerException : Exception
+    public class LoggerException : BuildExceptionBase
     {
         /// <summary>
         /// Default constructor.
@@ -104,6 +106,21 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("helpKeyword", helpKeyword);
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(errorCode), errorCode },
+                { nameof(helpKeyword), helpKeyword },
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            errorCode = state[nameof(errorCode)];
+            helpKeyword = state[nameof(helpKeyword)];
+        }
+
         #endregion
 
         #region Properties
diff --git a/src/MSBuild/CommandLineSwitchException.cs b/src/MSBuild/CommandLineSwitchException.cs
index 50cca72257a..b1f17f4cf16 100644
--- a/src/MSBuild/CommandLineSwitchException.cs
+++ b/src/MSBuild/CommandLineSwitchException.cs
@@ -3,6 +3,8 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
+using System.Collections.Generic;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
@@ -17,7 +19,7 @@ namespace Microsoft.Build.CommandLine
     /// This exception is used to flag (syntax) errors in command line switches passed to the application.
     /// </summary>
     [Serializable]
-    internal sealed class CommandLineSwitchException : Exception
+    internal sealed class CommandLineSwitchException : BuildExceptionBase
     {
         /// <summary>
         /// This constructor initializes the exception message.
@@ -56,6 +58,11 @@ private CommandLineSwitchException(
             commandLineArg = info.GetString("commandLineArg");
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        private CommandLineSwitchException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Gets the error message and the invalid switch, or only the error message if no invalid switch is set.
         /// </summary>
@@ -102,6 +109,19 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("commandLineArg", commandLineArg, typeof(string));
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(commandLineArg), commandLineArg }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            commandLineArg = state[nameof(commandLineArg)];
+        }
+
         /// <summary>
         /// Throws the exception if the specified condition is not met.
         /// </summary>
diff --git a/src/MSBuild/InitializationException.cs b/src/MSBuild/InitializationException.cs
index ff5a5e21ade..8370af2acd0 100644
--- a/src/MSBuild/InitializationException.cs
+++ b/src/MSBuild/InitializationException.cs
@@ -3,6 +3,8 @@
 
 using System;
 using System.Runtime.Serialization;
+using Microsoft.Build.BackEnd;
+using System.Collections.Generic;
 
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
@@ -22,7 +24,7 @@ namespace Microsoft.Build.CommandLine
     /// Unlike the CommandLineSwitchException, this exception is NOT thrown for syntax errors in switches.
     /// </remarks>
     [Serializable]
-    internal sealed class InitializationException : Exception
+    internal sealed class InitializationException : BuildExceptionBase
     {
         /// <summary>
         /// This constructor initializes the exception message.
@@ -61,6 +63,11 @@ private InitializationException(
             invalidSwitch = info.GetString("invalidSwitch");
         }
 
+        // Do not remove - used by BuildExceptionSerializationHelper
+        private InitializationException(string message, Exception inner)
+            : base(message, inner)
+        { }
+
         /// <summary>
         /// Gets the error message and the invalid switch, or only the error message if no invalid switch is set.
         /// </summary>
@@ -95,6 +102,20 @@ public override void GetObjectData(SerializationInfo info, StreamingContext cont
             info.AddValue("invalidSwitch", invalidSwitch, typeof(string));
         }
 
+        protected override IDictionary<string, string> FlushCustomState()
+        {
+            return new Dictionary<string, string>()
+            {
+                { nameof(invalidSwitch), invalidSwitch }
+            };
+        }
+
+        protected override void InitializeCustomState(IDictionary<string, string> state)
+        {
+            invalidSwitch = state[nameof(invalidSwitch)];
+        }
+
+
         /// <summary>
         /// Throws the exception if the specified condition is not met.
         /// </summary>
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index b6d7b028e80..12755888731 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -144,8 +144,8 @@
     <Compile Include="..\Framework\BinaryTranslator.cs">
       <Link>BinaryTranslator.cs</Link>
     </Compile>
-    <Compile Include="..\Framework\BuildTransferredException.cs">
-      <Link>BuildTransferredException.cs</Link>
+    <Compile Include="..\Framework\BuildException.cs">
+      <Link>BuildException.cs</Link>
     </Compile>
     <Compile Include="..\Shared\NodeShutdown.cs">
       <Link>NodeShutdown.cs</Link>
