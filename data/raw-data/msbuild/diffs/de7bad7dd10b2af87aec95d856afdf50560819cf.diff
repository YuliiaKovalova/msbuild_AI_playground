diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 7a819c9e65b..df3cc892777 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -56,7 +56,7 @@ internal sealed class NodeContext
         /// <summary>
         /// A mapping of all the nodes managed by this provider.
         /// </summary>
-        private Dictionary<int, NodeContext> _nodeContexts;
+        private Dictionary<int, NodeContext> _nodeContexts = new Dictionary<int, NodeContext>();
 
         /// <summary>
         /// Flag indicating we have disposed.
@@ -129,8 +129,15 @@ public int AvailableNodes
         /// <param name="host">The component host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            _componentHost = host;
-            _nodeContexts = new Dictionary<int, NodeContext>();
+            lock (_nodeContexts)
+            {
+                if (_componentHost is not null)
+                {
+                    throw new InvalidOperationException("component host was already set.");
+                }
+
+                _componentHost = host;
+            }
         }
 
         /// <summary>
@@ -242,26 +249,69 @@ private bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguratio
             }
 
             bool nodeExists;
+            NodeContext context;
             lock (_nodeContexts)
             {
                 nodeExists = _nodeContexts.ContainsKey(nodeId);
+
+                if (nodeExists)
+                {
+                    return false;
+                }
+
+                context = new();
+                _nodeContexts[nodeId] = context;
             }
 
             // If it doesn't already exist, create it.
             if (!nodeExists)
             {
-                if (!InstantiateNode(nodeId, factory))
+                if (!InitializeNode(nodeId, context, factory))
                 {
                     return false;
                 }
             }
 
-            lock (_nodeContexts)
-            {
-                _nodeContexts[nodeId]._inProcNodeEndpoint.SendData(configuration);
-            }
+            context._inProcNodeEndpoint.SendData(configuration);
 
             return true;
+
+            bool InitializeNode(int nodeId, NodeContext nodeContext, INodePacketFactory factory)
+            {
+                NodeEndpointInProc.EndpointPair endpoints = NodeEndpointInProc.CreateInProcEndpoints(NodeEndpointInProc.EndpointMode.Synchronous, _componentHost, nodeId);
+
+                nodeContext._inProcNodeEndpoint = endpoints.ManagerEndpoint;
+                nodeContext._inProcNodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(InProcNodeEndpoint_OnLinkStatusChanged);
+
+                nodeContext._packetFactory = factory;
+                nodeContext._inProcNode = new InProcNode(_componentHost, endpoints.NodeEndpoint, nodeId);
+#if FEATURE_THREAD_CULTURE
+                nodeContext._inProcNodeThread = new Thread(() => InProcNodeThreadProc(nodeId, nodeContext._inProcNode), BuildParameters.ThreadStackSize);
+#else
+                CultureInfo culture = _componentHost.BuildParameters.Culture;
+                CultureInfo uiCulture = _componentHost.BuildParameters.UICulture;
+                nodeContext._inProcNodeThread = new Thread(() =>
+                {
+                    CultureInfo.CurrentCulture = culture;
+                    CultureInfo.CurrentUICulture = uiCulture;
+                    InProcNodeThreadProc(nodeId, nodeContext._inProcNode);
+                });
+#endif
+                nodeContext._inProcNodeThread.Name = String.Format(CultureInfo.CurrentCulture, "In-proc Node ({0})", _componentHost.Name);
+                nodeContext._inProcNodeThread.IsBackground = true;
+#if FEATURE_THREAD_CULTURE
+                nodeContext._inProcNodeThread.CurrentCulture = _componentHost.BuildParameters.Culture;
+                nodeContext._inProcNodeThread.CurrentUICulture = _componentHost.BuildParameters.UICulture;
+#endif
+                nodeContext._inProcNodeThread.Start();
+
+                nodeContext._inProcNodeEndpoint.Connect(this);
+
+                int connectionTimeout = CommunicationsUtilities.NodeConnectionTimeout;
+                bool connected = nodeContext._endpointConnectedEvent.WaitOne(connectionTimeout);
+                ErrorUtilities.VerifyThrow(connected, "In-proc node failed to start up within {0}ms", connectionTimeout);
+                return true;
+            }
         }
 
         #endregion
@@ -358,54 +408,6 @@ internal static IBuildComponent CreateComponent(BuildComponentType type)
 
         #region Private Methods
 
-        /// <summary>
-        /// Creates a new in-proc node.
-        /// </summary>
-        private bool InstantiateNode(int nodeId, INodePacketFactory factory)
-        {
-            ErrorUtilities.VerifyThrow(!_nodeContexts.ContainsKey(nodeId), "In Proc node already instantiated.");
-
-            NodeEndpointInProc.EndpointPair endpoints = NodeEndpointInProc.CreateInProcEndpoints(NodeEndpointInProc.EndpointMode.Synchronous, _componentHost, nodeId);
-
-            NodeContext nodeContext = new();
-            lock (_nodeContexts)
-            {
-                _nodeContexts[nodeId] = nodeContext;
-            }
-
-            nodeContext._inProcNodeEndpoint = endpoints.ManagerEndpoint;
-            nodeContext._inProcNodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(InProcNodeEndpoint_OnLinkStatusChanged);
-
-            nodeContext._packetFactory = factory;
-            nodeContext._inProcNode = new InProcNode(_componentHost, endpoints.NodeEndpoint, nodeId);
-#if FEATURE_THREAD_CULTURE
-            nodeContext._inProcNodeThread = new Thread(() => InProcNodeThreadProc(nodeId, nodeContext._inProcNode), BuildParameters.ThreadStackSize);
-#else
-            CultureInfo culture = _componentHost.BuildParameters.Culture;
-            CultureInfo uiCulture = _componentHost.BuildParameters.UICulture;
-            nodeContext._inProcNodeThread = new Thread(() =>
-            {
-                CultureInfo.CurrentCulture = culture;
-                CultureInfo.CurrentUICulture = uiCulture;
-                InProcNodeThreadProc(nodeId, nodeContext._inProcNode);
-            });
-#endif
-            nodeContext._inProcNodeThread.Name = String.Format(CultureInfo.CurrentCulture, "In-proc Node ({0})", _componentHost.Name);
-            nodeContext._inProcNodeThread.IsBackground = true;
-#if FEATURE_THREAD_CULTURE
-            nodeContext._inProcNodeThread.CurrentCulture = _componentHost.BuildParameters.Culture;
-            nodeContext._inProcNodeThread.CurrentUICulture = _componentHost.BuildParameters.UICulture;
-#endif
-            nodeContext._inProcNodeThread.Start();
-
-            nodeContext._inProcNodeEndpoint.Connect(this);
-
-            int connectionTimeout = CommunicationsUtilities.NodeConnectionTimeout;
-            bool connected = nodeContext._endpointConnectedEvent.WaitOne(connectionTimeout);
-            ErrorUtilities.VerifyThrow(connected, "In-proc node failed to start up within {0}ms", connectionTimeout);
-            return true;
-        }
-
         /// <summary>
         /// Thread proc which runs the in-proc node.
         /// </summary>
@@ -413,7 +415,7 @@ private void InProcNodeThreadProc(int nodeId, INode inProcNode)
         {
             Exception e;
             NodeEngineShutdownReason reason = inProcNode.Run(out e);
-            InProcNodeShutdown(reason, e);
+            InProcNodeShutdown(nodeId, reason, e);
         }
 
         /// <summary>
@@ -450,9 +452,10 @@ private void InProcNodeEndpoint_OnLinkStatusChanged(INodeEndpoint endpoint, Link
         /// <summary>
         /// Callback invoked when the endpoint shuts down.
         /// </summary>
+        /// <param name="nodeId">The node that's shutting down.</param>
         /// <param name="reason">The reason the endpoint is shutting down.</param>
         /// <param name="e">Any exception which was raised that caused the endpoint to shut down.</param>
-        private void InProcNodeShutdown(NodeEngineShutdownReason reason, Exception e)
+        private void InProcNodeShutdown(int nodeId, NodeEngineShutdownReason reason, Exception e)
         {
             switch (reason)
             {
@@ -476,12 +479,15 @@ private void Dispose(bool disposing)
             {
                 if (disposing)
                 {
-                    foreach (NodeContext nodeContext in _nodeContexts.Values)
+                    lock (_nodeContexts)
                     {
-                        if (nodeContext._endpointConnectedEvent != null)
+                        foreach (NodeContext nodeContext in _nodeContexts.Values)
                         {
-                            nodeContext._endpointConnectedEvent.Dispose();
-                            nodeContext._endpointConnectedEvent = null;
+                            if (nodeContext._endpointConnectedEvent != null)
+                            {
+                                nodeContext._endpointConnectedEvent.Dispose();
+                                nodeContext._endpointConnectedEvent = null;
+                            }
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
index 7577db70433..4ff53f1d835 100644
--- a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
@@ -60,7 +60,7 @@ public bool IsInProcNode
         internal void LogFatalTaskError(Exception exception, BuildEventFileInfo file, string taskName)
         {
             CheckValidity();
-            LoggingService.LogFatalTaskError(BuildEventContext, exception, file, taskName);
+            LoggingService.LogFatalTaskError(BuildEventContext, exception, file, "MY CUSTOM ERROR MESSAGE: " + taskName);
             _hasLoggedErrors = true;
         }
     }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 31c9f55eeb0..f76e2a2853c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -209,7 +209,7 @@ public void LogFatalTaskError(BuildEventContext buildEventContext, Exception exc
         {
             ErrorUtilities.VerifyThrow(taskName != null, "Must specify the name of the task that failed.");
 
-            LogFatalError(buildEventContext, exception, file, "FatalTaskError", taskName);
+            LogFatalError(buildEventContext, exception, file, "FatalTaskError", "DIFFERENT CUSTOM ERROR MESSAGE: " + taskName);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 86f8ded7d3b..34082bb552f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -643,7 +643,6 @@ private void StartBuilderThread()
             if (IsBuilderUsingLegacyThreadingSemantics(_componentHost, _requestEntry))
             {
                 // Create a task which completes when the legacy threading task thread is finished.
-                _componentHost.LegacyThreadingData.SignalLegacyThreadStart(this);
 
                 _requestTask = Task.Factory.StartNew(
                     () =>
@@ -1115,6 +1114,7 @@ private async Task<BuildResult> BuildProject()
             _projectLoggingContext = null;
 
             MSBuildEventSource.Log.BuildProjectStart(_requestEntry.RequestConfiguration.ProjectFullPath);
+            // Console.WriteLine($"Building project: Targets => {string.Join(",", _requestEntry.RequestConfiguration.RequestedTargets ?? new string[] { "NO TARGETS" })} ** Path => {_requestEntry.RequestConfiguration.ProjectFullPath}");
 
             try
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 39ca187eaba..d2d7a672ddc 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -805,7 +805,18 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(TaskExecutionHost tas
                         using (FullTracking.Track(taskLoggingContext.TargetLoggingContext.Target.Name, _taskNode.Name, _buildRequestEntry.ProjectRootDirectory, _buildRequestEntry.RequestConfiguration.Project.PropertiesToBuildWith))
 #endif
                         {
-                            taskResult = taskExecutionHost.Execute();
+                            if (taskLoggingContext.TargetLoggingContext.Target.Name == "CreateVsixContainer")
+                            {
+                                taskResult = taskExecutionHost.Execute();
+                            }
+                            else if (taskLoggingContext.TargetLoggingContext.Target.Name == "SetVsSDKEnvironmentVariables")
+                            {
+                                taskResult = taskExecutionHost.Execute();
+                            }
+                            else
+                            {
+                                taskResult = taskExecutionHost.Execute();
+                            }
                         }
                     }
                 }
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 935c2eca520..d61824dffa1 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -10,6 +10,7 @@
 using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
+using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
@@ -544,6 +545,7 @@ public void Reset()
             _currentInProcNodeCount = 0;
             _currentOutOfProcNodeCount = 0;
 
+            Interlocked.Exchange(ref _nextGlobalRequestId, 0);
             _nextGlobalRequestId = 0;
             _customRequestSchedulingAlgorithm = null;
         }
@@ -1656,8 +1658,7 @@ private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequ
             BuildRequest newRequest = new BuildRequest(parentRequest.BuildRequest.SubmissionId, BuildRequest.ResultsTransferNodeRequestId, parentRequest.BuildRequest.ConfigurationId, [], null, parentRequest.BuildRequest.BuildEventContext, parentRequest.BuildRequest, parentRequest.BuildRequest.BuildRequestDataFlags);
 
             // Assign a new global request id - always different from any other.
-            newRequest.GlobalRequestId = _nextGlobalRequestId;
-            _nextGlobalRequestId++;
+            newRequest.GlobalRequestId = Interlocked.Increment(ref _nextGlobalRequestId);
 
             // Now add the response.  Send it to the node where the configuration's results are stored.  When those results come back
             // we will update the storage location in the configuration.  This is doing a bit of a run around the scheduler - we don't
@@ -2286,8 +2287,7 @@ private void AssignGlobalRequestId(BuildRequest request)
                 }
             }
 
-            request.GlobalRequestId = _nextGlobalRequestId;
-            _nextGlobalRequestId++;
+            request.GlobalRequestId = Interlocked.Increment(ref _nextGlobalRequestId);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index cb9ccc38eef..83f32fde62d 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -168,7 +168,6 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
                             }
 
                         case 1:
-
                             while (_receivedPackets.TryDequeue(out INodePacket packet))
                             {
                                 if (packet != null)
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index fa76ba4765c..47cee4ea849 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -1,9 +1,11 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Linq;
+using System.Threading;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
@@ -256,12 +258,14 @@ public int GlobalRequestId
             [DebuggerStepThrough]
             get
             {
+                Thread.MemoryBarrier();
                 return _globalRequestId;
             }
 
             set
             {
                 ErrorUtilities.VerifyThrow(_globalRequestId == InvalidGlobalRequestId, "Global Request ID cannot be set twice.");
+                Thread.MemoryBarrier();
                 _globalRequestId = value;
             }
         }
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 71677d96415..40c16dc66da 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -56,6 +56,8 @@ namespace Microsoft.Build.Execution
     /// </example>
     internal sealed class TaskRegistry : ITranslatable
     {
+        private static readonly object lockObject = new object();
+
         /// <summary>
         /// The fallback task registry
         /// </summary>
@@ -233,12 +235,16 @@ internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskReg
         {
             get
             {
-                if (_taskRegistrations == null)
+                lock (lockObject)
                 {
-                    _taskRegistrations = CreateRegisteredTaskDictionary();
-                }
 
-                return _taskRegistrations;
+                    if (_taskRegistrations == null)
+                    {
+                        _taskRegistrations = CreateRegisteredTaskDictionary();
+                    }
+
+                    return _taskRegistrations;
+                }
             }
         }
 
@@ -259,21 +265,24 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
             where P : class, IProperty
             where I : class, IItem
         {
-            foreach ((ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile) registration in registrations)
+            lock (lockObject)
             {
-                RegisterTasksFromUsingTaskElement(
-                    loggingContext,
-                    registration.directoryOfImportingFile,
-                    registration.projectUsingTaskXml,
-                    taskRegistry,
-                    expander,
-                    expanderOptions,
-                    fileSystem);
-            }
+                foreach ((ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile) registration in registrations)
+                {
+                    RegisterTasksFromUsingTaskElement(
+                        loggingContext,
+                        registration.directoryOfImportingFile,
+                        registration.projectUsingTaskXml,
+                        taskRegistry,
+                        expander,
+                        expanderOptions,
+                        fileSystem);
+                }
 #if DEBUG
-            taskRegistry._isInitialized = true;
-            taskRegistry._taskRegistrations ??= TaskRegistry.CreateRegisteredTaskDictionary();
+                taskRegistry._isInitialized = true;
+                taskRegistry._taskRegistrations ??= TaskRegistry.CreateRegisteredTaskDictionary();
 #endif
+            }
         }
 
         /// <summary>
@@ -428,7 +437,7 @@ private static void RegisterTasksFromUsingTaskElement
                 parameterGroupAndTaskElementRecord.ExpandUsingTask<P, I>(projectUsingTaskXml, expander, expanderOptions);
             }
 
-            Dictionary<string, string> taskFactoryParameters = null;
+            ConcurrentDictionary<string, string> taskFactoryParameters = null;
             string runtime = expander.ExpandIntoStringLeaveEscaped(projectUsingTaskXml.Runtime, expanderOptions, projectUsingTaskXml.RuntimeLocation);
             string architecture = expander.ExpandIntoStringLeaveEscaped(projectUsingTaskXml.Architecture, expanderOptions, projectUsingTaskXml.ArchitectureLocation);
             string overrideUsingTask = expander.ExpandIntoStringLeaveEscaped(projectUsingTaskXml.Override, expanderOptions, projectUsingTaskXml.OverrideLocation);
@@ -437,18 +446,18 @@ private static void RegisterTasksFromUsingTaskElement
             {
                 taskFactoryParameters = CreateTaskFactoryParametersDictionary();
 
-                taskFactoryParameters.Add(XMakeAttributes.runtime, runtime == String.Empty ? XMakeAttributes.MSBuildRuntimeValues.any : runtime);
-                taskFactoryParameters.Add(XMakeAttributes.architecture, architecture == String.Empty ? XMakeAttributes.MSBuildArchitectureValues.any : architecture);
+                taskFactoryParameters.TryAdd(XMakeAttributes.runtime, runtime == String.Empty ? XMakeAttributes.MSBuildRuntimeValues.any : runtime);
+                taskFactoryParameters.TryAdd(XMakeAttributes.architecture, architecture == String.Empty ? XMakeAttributes.MSBuildArchitectureValues.any : architecture);
             }
 
             taskRegistry.RegisterTask(taskName, AssemblyLoadInfo.Create(assemblyName, assemblyFile), taskFactory, taskFactoryParameters, parameterGroupAndTaskElementRecord, loggingContext, projectUsingTaskXml, ConversionUtilities.ValidBooleanTrue(overrideUsingTask));
         }
 
-        private static Dictionary<string, string> CreateTaskFactoryParametersDictionary(int? initialCount = null)
+        private static ConcurrentDictionary<string, string> CreateTaskFactoryParametersDictionary(int? initialCount = null)
         {
             return initialCount == null
-                ? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
-                : new Dictionary<string, string>(initialCount.Value, StringComparer.OrdinalIgnoreCase);
+                ? new ConcurrentDictionary<string, string>(StringComparer.OrdinalIgnoreCase)
+                : new ConcurrentDictionary<string, string>(Environment.ProcessorCount, initialCount.Value, StringComparer.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -520,123 +529,149 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             ElementLocation elementLocation,
             out bool retrievedFromCache)
         {
-            RegisteredTaskRecord taskRecord = null;
-            retrievedFromCache = false;
-            RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);
-
-            // Project-level override tasks are keyed by task name (unqualified).
-            // Because Foo.Bar and Baz.Bar are both valid, they are stored
-            // in a dictionary keyed as `Bar` because most tasks are called unqualified
-            if (_overriddenTasks.TryGetValue(taskName, out List<RegisteredTaskRecord> recs))
+            lock (lockObject)
             {
-                // When we determine this task was overridden, search all task records
-                // to find the most correct registration. Search with the fully qualified name (if applicable)
-                // Behavior is intended to be "first one wins"
-                foreach (RegisteredTaskRecord rec in recs)
+                RegisteredTaskRecord taskRecord = null;
+                retrievedFromCache = false;
+                RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);
+
+                // Project-level override tasks are keyed by task name (unqualified).
+                // Because Foo.Bar and Baz.Bar are both valid, they are stored
+                // in a dictionary keyed as `Bar` because most tasks are called unqualified
+                if (_overriddenTasks.TryGetValue(taskName, out List<RegisteredTaskRecord> recs))
                 {
-                    if (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, rec.TaskIdentity))
+                    // When we determine this task was overridden, search all task records
+                    // to find the most correct registration. Search with the fully qualified name (if applicable)
+                    // Behavior is intended to be "first one wins"
+                    foreach (RegisteredTaskRecord rec in recs)
                     {
-                        return rec;
+                        if (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, rec.TaskIdentity))
+                        {
+                            return rec;
+                        }
                     }
                 }
-            }
 
-            // Try the override task registry first
-            if (_toolset != null)
-            {
-                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext, RootElementCache);
-                taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
-            }
-
-            // Try the current task registry
-            if (taskRecord == null && _taskRegistrations?.Count > 0)
-            {
-                if (exactMatchRequired)
+                // Try the override task registry first
+                if (_toolset != null)
                 {
-                    if (_cachedTaskRecordsWithExactMatch.TryGetValue(taskIdentity, out taskRecord))
-                    {
-                        retrievedFromCache = true;
-                        return taskRecord;
-                    }
+                    TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext, RootElementCache);
+                    taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
                 }
-                else
+
+                // Try the current task registry
+                if (taskRecord == null && _taskRegistrations?.Count > 0)
                 {
-                    if (_cachedTaskRecordsWithFuzzyMatch.TryGetValue(taskIdentity.Name, out ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords))
+                    if (exactMatchRequired)
                     {
-                        // if we've looked up this exact one before, just grab it and return
-                        if (taskRecords.TryGetValue(taskIdentity, out taskRecord))
+                        if (_cachedTaskRecordsWithExactMatch.TryGetValue(taskIdentity, out taskRecord))
                         {
                             retrievedFromCache = true;
                             return taskRecord;
                         }
-                        else
+                    }
+                    else
+                    {
+                        if (_cachedTaskRecordsWithFuzzyMatch.TryGetValue(taskIdentity.Name, out ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords))
                         {
-                            // otherwise, check the "short list" of everything else included here to see if one of them matches
-                            foreach (RegisteredTaskRecord record in taskRecords.Values)
+                            // if we've looked up this exact one before, just grab it and return
+                            if (taskRecords.TryGetValue(taskIdentity, out taskRecord))
                             {
-                                // Just return the first one that actually matches.  There may be nulls in here as well, if we've previously attempted to
-                                // find a variation on this task record and failed.  In that case, since it wasn't an exact match (otherwise it would have
-                                // been picked up by the check above) just ignore it, the way we ignore task records that don't work with this set of
-                                // parameters.
-                                if (record != null)
+                                retrievedFromCache = true;
+                                return taskRecord;
+                            }
+                            else
+                            {
+                                // otherwise, check the "short list" of everything else included here to see if one of them matches
+                                foreach (RegisteredTaskRecord record in taskRecords.Values)
                                 {
-                                    if (record.CanTaskBeCreatedByFactory(taskName, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation))
+                                    // Just return the first one that actually matches.  There may be nulls in here as well, if we've previously attempted to
+                                    // find a variation on this task record and failed.  In that case, since it wasn't an exact match (otherwise it would have
+                                    // been picked up by the check above) just ignore it, the way we ignore task records that don't work with this set of
+                                    // parameters.
+                                    if (record != null)
                                     {
-                                        retrievedFromCache = true;
-                                        return record;
+                                        if (record.CanTaskBeCreatedByFactory(taskName, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation))
+                                        {
+                                            retrievedFromCache = true;
+                                            return record;
+                                        }
                                     }
                                 }
                             }
-                        }
 
-                        // otherwise, nothing fit, so act like we never hit the cache at all.
+                            // otherwise, nothing fit, so act like we never hit the cache at all.
+                        }
                     }
+
+                    IEnumerable<RegisteredTaskRecord> registrations = GetRelevantOrderedRegistrations(taskIdentity, exactMatchRequired);
+
+                    // look for the given task name in the registry; if not found, gather all registered task names that partially
+                    // match the given name
+                    taskRecord = GetMatchingRegistration(taskName, registrations, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation);
                 }
 
-                IEnumerable<RegisteredTaskRecord> registrations = GetRelevantOrderedRegistrations(taskIdentity, exactMatchRequired);
+                // If we didn't find the task but we have a fallback registry in the toolset state, try that one.
+                if (taskRecord == null && _toolset != null)
+                {
+                    TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext, RootElementCache);
+                    taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
+                }
 
-                // look for the given task name in the registry; if not found, gather all registered task names that partially
-                // match the given name
-                taskRecord = GetMatchingRegistration(taskName, registrations, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation);
-            }
+                // Cache the result, even if it is null.  We should never again do the work we just did, for this task name.
+                if (exactMatchRequired)
+                {
+                    _cachedTaskRecordsWithExactMatch[taskIdentity] = taskRecord;
+                }
+                else
+                {
+                    // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
+                    // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.
+                    //
+                    // To prevent us inadvertently leaking something incompatible, in this case, we need to store not just the
+                    // record that we got this time, but ALL of the records that have previously matched this key.
+                    //
+                    // Furthermore, the first level key needs to be the name of the task, not its identity -- otherwise we might
+                    // end up with multiple entries containing subsets of the same fuzzy-matchable tasks.  E.g. with the following
+                    // set of steps:
+                    // 1. Look up Foo | bar
+                    // 2. Look up Foo | * (goes into Foo | bar cache entry)
+                    // 3. Look up Foo | baz (gets its own entry because it doesn't match Foo | bar)
+                    // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up
+                    //    first, might get Foo | baz, which also matches, instead)
+                    ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords
+                        = _cachedTaskRecordsWithFuzzyMatch.GetOrAdd(taskIdentity.Name,
+                            _ => new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));
+
+                    taskRecords[taskIdentity] = taskRecord;
+                    _cachedTaskRecordsWithFuzzyMatch[taskIdentity.Name] = taskRecords;
+                }
 
-            // If we didn't find the task but we have a fallback registry in the toolset state, try that one.
-            if (taskRecord == null && _toolset != null)
-            {
-                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext, RootElementCache);
-                taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
-            }
+                return taskRecord;
 
-            // Cache the result, even if it is null.  We should never again do the work we just did, for this task name.
-            if (exactMatchRequired)
-            {
-                _cachedTaskRecordsWithExactMatch[taskIdentity] = taskRecord;
-            }
-            else
-            {
-                // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
-                // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.
-                //
-                // To prevent us inadvertently leaking something incompatible, in this case, we need to store not just the
-                // record that we got this time, but ALL of the records that have previously matched this key.
-                //
-                // Furthermore, the first level key needs to be the name of the task, not its identity -- otherwise we might
-                // end up with multiple entries containing subsets of the same fuzzy-matchable tasks.  E.g. with the following
-                // set of steps:
-                // 1. Look up Foo | bar
-                // 2. Look up Foo | * (goes into Foo | bar cache entry)
-                // 3. Look up Foo | baz (gets its own entry because it doesn't match Foo | bar)
-                // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up
-                //    first, might get Foo | baz, which also matches, instead)
-                ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords
-                    = _cachedTaskRecordsWithFuzzyMatch.GetOrAdd(taskIdentity.Name,
-                        _ => new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));
-
-                taskRecords[taskIdentity] = taskRecord;
-                _cachedTaskRecordsWithFuzzyMatch[taskIdentity.Name] = taskRecords;
-            }
+                // Searches all task declarations for the given task name.
+                // If no exact match is found, looks for partial matches.
+                // A task name that is not fully qualified may produce several partial matches.
+                IEnumerable<RegisteredTaskRecord> GetRelevantOrderedRegistrations(RegisteredTaskIdentity taskIdentity, bool exactMatchRequired)
+                {
+                    if (_taskRegistrations.TryGetValue(taskIdentity, out List<RegisteredTaskRecord> taskAssemblies))
+                    {
+                        // (records for single key should be ordered by order of registrations - as they are inserted into the list)
+                        return taskAssemblies;
+                    }
 
-            return taskRecord;
+                    if (exactMatchRequired)
+                    {
+                        return [];
+                    }
+
+                    // look through all task declarations for partial matches
+                    return _taskRegistrations
+                        .Where(tp => RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, tp.Key))
+                        .SelectMany(tp => tp.Value)
+                        .OrderBy(r => r.RegistrationOrderId);
+                }
+            }
         }
 
         /// <summary>
@@ -649,31 +684,6 @@ private static bool IsTaskFactoryClass(Type type, object unused)
                 typeof(Microsoft.Build.Framework.ITaskFactory).IsAssignableFrom(type);
         }
 
-        /// <summary>
-        /// Searches all task declarations for the given task name.
-        /// If no exact match is found, looks for partial matches.
-        /// A task name that is not fully qualified may produce several partial matches.
-        /// </summary>
-        private IEnumerable<RegisteredTaskRecord> GetRelevantOrderedRegistrations(RegisteredTaskIdentity taskIdentity, bool exactMatchRequired)
-        {
-            if (_taskRegistrations.TryGetValue(taskIdentity, out List<RegisteredTaskRecord> taskAssemblies))
-            {
-                // (records for single key should be ordered by order of registrations - as they are inserted into the list)
-                return taskAssemblies;
-            }
-
-            if (exactMatchRequired)
-            {
-                return [];
-            }
-
-            // look through all task declarations for partial matches
-            return _taskRegistrations
-                .Where(tp => RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, tp.Key))
-                .SelectMany(tp => tp.Value)
-                .OrderBy(r => r.RegistrationOrderId);
-        }
-
         /// <summary>
         /// Registers an evaluated using task tag for future
         /// consultation
@@ -682,7 +692,7 @@ private void RegisterTask(
             string taskName,
             AssemblyLoadInfo assemblyLoadInfo,
             string taskFactory,
-            Dictionary<string, string> taskFactoryParameters,
+            ConcurrentDictionary<string, string> taskFactoryParameters,
             RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord,
             LoggingContext loggingContext,
             ProjectUsingTaskElement projectUsingTaskInXml,
@@ -691,61 +701,64 @@ private void RegisterTask(
             ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
             ErrorUtilities.VerifyThrowInternalNull(assemblyLoadInfo);
 
-            // Lazily allocate the hashtable
-            if (_taskRegistrations == null)
+            lock (lockObject)
             {
-                _taskRegistrations = CreateRegisteredTaskDictionary();
-            }
-
-            // since more than one task can have the same name, we want to keep track of all assemblies that are declared to
-            // contain tasks with a given name...
-            List<RegisteredTaskRecord> registeredTaskEntries;
-            RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskFactoryParameters);
-            if (!_taskRegistrations.TryGetValue(taskIdentity, out registeredTaskEntries))
-            {
-                registeredTaskEntries = new List<RegisteredTaskRecord>();
-                _taskRegistrations[taskIdentity] = registeredTaskEntries;
-            }
+                // Lazily allocate the hashtable
+                if (_taskRegistrations == null)
+                {
+                    _taskRegistrations = CreateRegisteredTaskDictionary();
+                }
 
-            RegisteredTaskRecord newRecord = new RegisteredTaskRecord(
-                taskName,
-                assemblyLoadInfo,
-                taskFactory,
-                taskFactoryParameters,
-                inlineTaskRecord,
-                Interlocked.Increment(ref _nextRegistrationOrderId));
+                // since more than one task can have the same name, we want to keep track of all assemblies that are declared to
+                // contain tasks with a given name...
+                List<RegisteredTaskRecord> registeredTaskEntries;
+                RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskFactoryParameters);
+                if (!_taskRegistrations.TryGetValue(taskIdentity, out registeredTaskEntries))
+                {
+                    registeredTaskEntries = new List<RegisteredTaskRecord>();
+                    _taskRegistrations[taskIdentity] = registeredTaskEntries;
+                }
 
-            if (overrideTask)
-            {
-                // Key the dictionary based on Unqualified task names
-                // This is to support partial matches on tasks like Foo.Bar and Baz.Bar
-                string[] nameComponents = taskName.Split('.');
-                string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];
+                RegisteredTaskRecord newRecord = new RegisteredTaskRecord(
+                    taskName,
+                    assemblyLoadInfo,
+                    taskFactory,
+                    taskFactoryParameters,
+                    inlineTaskRecord,
+                    Interlocked.Increment(ref _nextRegistrationOrderId));
 
-                // Is the task already registered?
-                if (_overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))
+                if (overrideTask)
                 {
-                    foreach (RegisteredTaskRecord rec in recs)
+                    // Key the dictionary based on Unqualified task names
+                    // This is to support partial matches on tasks like Foo.Bar and Baz.Bar
+                    string[] nameComponents = taskName.Split('.');
+                    string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];
+
+                    // Is the task already registered?
+                    if (_overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))
                     {
-                        if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))
+                        foreach (RegisteredTaskRecord rec in recs)
                         {
-                            loggingContext.LogError(new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
-                            break;
+                            if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))
+                            {
+                                loggingContext.LogError(new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
+                                break;
+                            }
                         }
+                        recs.Add(newRecord);
+                    }
+                    else
+                    {
+                        // New record's name may be fully qualified. Use it anyway to account for partial matches.
+                        List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();
+                        unqualifiedTaskNameMatches.Add(newRecord);
+                        _overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);
+                        loggingContext.LogComment(MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
                     }
-                    recs.Add(newRecord);
-                }
-                else
-                {
-                    // New record's name may be fully qualified. Use it anyway to account for partial matches.
-                    List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();
-                    unqualifiedTaskNameMatches.Add(newRecord);
-                    _overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);
-                    loggingContext.LogComment(MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
                 }
-            }
 
-            registeredTaskEntries.Add(newRecord);
+                registeredTaskEntries.Add(newRecord);
+            }
         }
 
         private static ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)
@@ -1141,12 +1154,12 @@ internal class RegisteredTaskRecord : ITranslatable
             /// When ever a taskName is checked against the factory we cache the result so we do not have to
             /// make possibly expensive calls over and over again.
             /// </summary>
-            private Dictionary<RegisteredTaskIdentity, object> _taskNamesCreatableByFactory;
+            private ConcurrentDictionary<RegisteredTaskIdentity, object> _taskNamesCreatableByFactory;
 
             /// <summary>
             /// Set of parameters that can be used by the task factory specifically.
             /// </summary>
-            private Dictionary<string, string> _taskFactoryParameters;
+            private ConcurrentDictionary<string, string> _taskFactoryParameters;
 
             /// <summary>
             /// Encapsulates the parameters and the body of the task element for the inline task.
@@ -1161,7 +1174,7 @@ internal class RegisteredTaskRecord : ITranslatable
             /// <summary>
             /// Constructor
             /// </summary>
-            internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary<string, string> taskFactoryParameters, ParameterGroupAndTaskElementRecord inlineTask, int registrationOrderId)
+            internal RegisteredTaskRecord(string registeredName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, ConcurrentDictionary<string, string> taskFactoryParameters, ParameterGroupAndTaskElementRecord inlineTask, int registrationOrderId)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(assemblyLoadInfo, "AssemblyLoadInfo");
                 _registeredName = registeredName;
@@ -1267,7 +1280,7 @@ internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile,
                 // Keep a cache of task identities which have been checked against the factory, this is useful because we ask this question everytime we get a registered task record or a taskFactory wrapper.
                 if (_taskNamesCreatableByFactory == null)
                 {
-                    _taskNamesCreatableByFactory = new Dictionary<RegisteredTaskIdentity, object>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
+                    _taskNamesCreatableByFactory = new ConcurrentDictionary<RegisteredTaskIdentity, object>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
                 }
 
                 RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);
@@ -1821,7 +1834,7 @@ public void Translate(ITranslator translator)
 
                 if (translator.Mode == TranslationDirection.ReadFromStream && localParameters != null)
                 {
-                    _taskFactoryParameters = (Dictionary<string, string>)localParameters;
+                    _taskFactoryParameters = (ConcurrentDictionary<string, string>)localParameters;
                 }
             }
 
@@ -1836,17 +1849,20 @@ internal static RegisteredTaskRecord FactoryForDeserialization(ITranslator trans
 
         public void Translate(ITranslator translator)
         {
-            translator.Translate(ref _toolset, Toolset.FactoryForDeserialization);
-            translator.Translate(ref _nextRegistrationOrderId);
-            IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> copy = _taskRegistrations;
-            translator.TranslateDictionary(ref copy, TranslateTaskRegistrationKey, TranslateTaskRegistrationValue, count => CreateRegisteredTaskDictionary(count));
-
-            if (translator.Mode == TranslationDirection.ReadFromStream)
+            lock (lockObject)
             {
-                _taskRegistrations = (ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>)copy;
+                translator.Translate(ref _toolset, Toolset.FactoryForDeserialization);
+                translator.Translate(ref _nextRegistrationOrderId);
+                IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> copy = _taskRegistrations;
+                translator.TranslateDictionary(ref copy, TranslateTaskRegistrationKey, TranslateTaskRegistrationValue, count => CreateRegisteredTaskDictionary(count));
+
+                if (translator.Mode == TranslationDirection.ReadFromStream)
+                {
+                    _taskRegistrations = (ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>)copy;
 #if DEBUG
-                _isInitialized = _taskRegistrations != null;
+                    _isInitialized = _taskRegistrations != null;
 #endif
+                }
             }
         }
 
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 0547f5f72e4..f9b8c4f9a7e 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -59,6 +59,15 @@
     <None Remove="XamlTypes\**" />
   </ItemGroup>
 
+  <ItemGroup>
+    <None Include="..\..\..\Detours\vc\Debug\NativeDetourWrapper.dll" Link="NativeDetourWrapper.dll">
+      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
+    </None>
+    <None Include="..\..\..\Detours\vc\Debug\NativeDetourWrapper.pdb" Link="NativeDetourWrapper.pdb">
+      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
+    </None>
+  </ItemGroup>
+
   <ItemGroup>
     <ProjectReference Include="..\..\..\Detours\CLRDetourWrapper\CLRDetourWrapper.vcxproj" />
   </ItemGroup>
@@ -66,4 +75,5 @@
   <ItemGroup>
     <RCResourceFile Include="native.rc" />
   </ItemGroup>
+  
 </Project>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 033b9ebe598..939fd13b639 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -29,7 +29,8 @@ internal static class NativeMethods
 {
 #if NET472_OR_GREATER || NET5_0_OR_GREATER
     public static AsyncLocal<string> AsyncCurrentDirectory = new AsyncLocal<string>();
-    internal static DetourWrapper detourWrapper = new DetourWrapper(AsyncCurrentDirectory);
+    public static AsyncLocal<Dictionary<string, string>> AsyncEnvironmentVariables = new AsyncLocal<Dictionary<string, string>>();
+    internal static DetourWrapper detourWrapper = new DetourWrapper(AsyncCurrentDirectory, AsyncEnvironmentVariables);
 #endif
 
     #region Constants
