diff --git a/.github/ISSUE_TEMPLATE/01_bugreport.md b/.github/ISSUE_TEMPLATE/01_bugreport.md
index 3d8e508c782..58a8cb2c372 100644
--- a/.github/ISSUE_TEMPLATE/01_bugreport.md
+++ b/.github/ISSUE_TEMPLATE/01_bugreport.md
@@ -2,7 +2,7 @@
 name: üêû Bug Report
 about: Report a bug to help us improve MSBuild.
 title: ''
-labels: bug, untriaged
+labels: bug, needs-triage
 ---
 
 <!-- This is a template that helps us provide quicker feedback. Please use any relevant sections and delete anything you don't need. -->
diff --git a/.github/ISSUE_TEMPLATE/02_performanceissue.md b/.github/ISSUE_TEMPLATE/02_performanceissue.md
index e3d875c8f91..69ac8410706 100644
--- a/.github/ISSUE_TEMPLATE/02_performanceissue.md
+++ b/.github/ISSUE_TEMPLATE/02_performanceissue.md
@@ -2,7 +2,7 @@
 name: üìâ Performance Issue
 about: Report a performance issue or regression.
 title: ''
-labels: performance, untriaged
+labels: performance, needs-triage
 ---
 
 <!-- This is a template that helps us provide quicker feedback. Please use any relevant sections and delete anything you don't need. -->
diff --git a/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md b/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md
index 19dcf3094f1..a873a40f1e4 100644
--- a/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md
+++ b/.github/ISSUE_TEMPLATE/03_mybuildisbroken.md
@@ -2,7 +2,7 @@
 name: üòµ My Build is Broken
 about: Use this template for helping figure out what's wrong with your build.
 title: ''
-labels: untriaged
+labels: needs-triage
 ---
 
 <!-- NOTE: The MSBuild team receives a lot of issues and we need to prioritize them accordingly. Please understand that we may not get to your issue for some time. -->
diff --git a/.github/ISSUE_TEMPLATE/04_blankissue.md b/.github/ISSUE_TEMPLATE/04_blankissue.md
index 9be0e37587f..d3ae09b4431 100644
--- a/.github/ISSUE_TEMPLATE/04_blankissue.md
+++ b/.github/ISSUE_TEMPLATE/04_blankissue.md
@@ -2,5 +2,5 @@
 name: üìÑ Blank Issue
 about: Doesn't fit the other categories? File a blank ticket here.
 title: ''
-labels: untriaged
+labels: needs-triage
 ---
\ No newline at end of file
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index bd006c55f5d..656ef733e1f 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -42,11 +42,13 @@ stages:
   displayName: Build
 
   jobs:
-  - template: /eng/common/templates/job/onelocbuild.yml
-    parameters:
-      CreatePr: false
-      LclSource: lclFilesfromPackage
-      LclPackageId: 'LCL-JUNO-PROD-MSBUILD'
+  - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/vs16.11') }}: # should track next-release's active dev branch
+    - template: /eng/common/templates/job/onelocbuild.yml
+      parameters:
+        LclSource: lclFilesfromPackage
+        LclPackageId: 'LCL-JUNO-PROD-MSBUILD'
+        MirrorRepo: 'msbuild'
+        MirrorBranch: 'vs16.11' # should match condition above
 
   - job: Windows_NT
     pool:
diff --git a/Directory.Build.props b/Directory.Build.props
index 2cc17a1372f..117512a6a29 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -62,6 +62,10 @@
     <MachineIndependentBuild>true</MachineIndependentBuild>
   </PropertyGroup>
 
+  <PropertyGroup>
+    <AssemblyInformationCachePaths Condition="Exists('$(NetCoreRoot)sdk\$(NetCoreSdkVersion)\SdkPrecomputedAssemblyReferences.cache')">$(AssemblyInformationCachePaths);$(NetCoreRoot)sdk\$(NetCoreSdkVersion)\SDKPrecomputedAssemblyReferences.cache</AssemblyInformationCachePaths>
+  </PropertyGroup>
+
   <PropertyGroup>
     <DefaultItemExcludes>$(DefaultItemExcludes);*.log</DefaultItemExcludes>
     <DefaultItemExcludes>$(DefaultItemExcludes);*.binlog</DefaultItemExcludes>
diff --git a/README.md b/README.md
index 17bc28dd9a4..d0c18df79af 100644
--- a/README.md
+++ b/README.md
@@ -4,27 +4,29 @@ The Microsoft Build Engine is a platform for building applications. This engine,
 
 For more information on MSBuild, see the [MSBuild documentation](https://docs.microsoft.com/visualstudio/msbuild/msbuild) on docs.microsoft.com.
 
+The [changelog](documentation/Changelog.md) has detailed information about changes made in different releases.
+
 ### Build Status
 
 The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 17.0 and a corresponding version of the .NET Core SDK.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=main)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=main)
 
 We have forked for MSBuild 16.11 in the branch [`vs16.11`](https://github.com/Microsoft/msbuild/tree/vs16.11). Changes to that branch need special approval.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.11)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.11)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.11)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.11)
 
 MSBuild 16.9 builds from the branch [`vs16.9`](https://github.com/dotnet/msbuild/tree/vs16.9). Only high-priority bugfixes will be considered for servicing 16.9.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.9)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.9)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.9)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.9)
 
 MSBuild 16.7 builds from the branch [`vs16.7`](https://github.com/dotnet/msbuild/tree/vs16.7). Only high-priority bugfixes will be considered for servicing 16.7.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.7)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.7)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.7)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.7)
 
 MSBuild 16.4 builds from the branch [`vs16.4`](https://github.com/dotnet/msbuild/tree/vs16.4). Only high-priority bugfixes will be considered for servicing 16.4.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.4)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.4)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.4)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.4)
 
 MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/dotnet/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
 
diff --git a/documentation/Changelog.md b/documentation/Changelog.md
new file mode 100644
index 00000000000..4a9dbaf4710
--- /dev/null
+++ b/documentation/Changelog.md
@@ -0,0 +1,234 @@
+# MSBuild Changelog
+
+## MSBuild 16.11.0
+
+This version of MSBuild will ship with Visual Studio 2019 version 16.11.0 and .NET SDK 5.0.400.
+
+### What's new
+
+### Detailed release notes
+
+#### Added
+
+* Additional properties documented and available for completion in Visual Studio (#6500, #6530).
+* The `SignFile` task is now available in MSBuild on .NET 5.0 (#6509). Thanks, @Zastai!
+* New version properties `MSBuildFileVersion` (4-part, matches file version) and `MSBuildSemanticVersion` (matches package versions) are now available for use (#6534).
+#### Changed
+
+* When using the experimental cache API, schedule proxy builds to the in-proc node for performance (#6386).
+* Experimental cache queries are now executed in parallel (#6468).
+* The ETW events generated in `ResolveAssemblyReference` now include an approximation of the "size" of the RAR request (#6410).
+
+#### Fixed
+
+* Fixed memory leak in `ProjectRootElement.Reload` (#6457).
+* Added locking to avoid race conditions in `BuildManager` (#6412).
+* Allow `ResolveAssemblyReferences` precomputed cache files to be in read-only locations (#6393).
+* 64-bit `al.exe` is used when targeting 64-bit architectures (for real this time) (#6484).
+* Builds with `ProduceOnlyReferenceAssembly` no longer expect debug symbols to be produced (#6511). Thanks, @Zastai!
+
+#### Infrastructure
+
+* Use a packaged C# compiler to avoid changes in reference assembly generation caused by compiler changes (#6431).
+* Use more resilient test-result upload patterns (#6489).
+* Conditional compilation for .NET Core within our repo now includes new .NET 5.0+ runtimes (#6538).
+* Switched to OneLocBuild for localization PRs (#6561).
+* Moved to latest Ubuntu image for PR test legs (#6573).
+
+#### Documentation
+
+## MSBuild 16.10.2
+
+This version of MSBuild shipped with Visual Studio 2019 version 16.10.2 and will ship with .NET SDK 5.0.302.
+
+#### Fixed
+
+* Fixed a regression in the `MakeRelative` property function that dropped trailing slashes (#6513). Thanks, @dsparkplug and @pmisik!
+* Fixed a regression in glob matching where files without extensions were erroneously not matched (#6531).
+* Fixed a change in logging that caused crashes in Azure DevOps loggers (#6520).
+
+## MSBuild 16.10.1
+
+This version of MSBuild shipped with Visual Studio 2019 version 16.10.1 and .NET SDK 5.0.301.
+
+#### Fixed
+
+* Restore support for building individual project(s) within solutions by specifying `-t:Project` (#6465).
+
+## MSBuild 16.9.2
+
+This version of MSBuild shipped with Visual Studio 2019 version 16.9.7.
+
+#### Fixed
+
+* Fixed MSB0001 error when building large solutions (#6437).
+
+## MSBuild 16.10.0
+
+This version of MSBuild shipped with Visual Studio 2019 version 16.10.0 and .NET SDK 5.0.300.
+
+### What's new
+
+* MSBuild now targets .NET 5.0 and .NET Framework 4.7.2.
+* MSBuild is faster and uses less memory.
+* Binary logs are smaller and have less performance overhead.
+* Tasks can now opt into resource management to improve parallelism in large builds.
+* It's now possible to optionally embed arbitrary files in a binary log.
+
+### Detailed release notes
+
+#### Added
+
+* Projects can now specify `AdditionalTargetFrameworkInfoProperty` items to indicate that referencing projects should get those properties exposed as `AdditionalPropertiesFromProject` metadata on resolved reference items. (#5994).
+* The `Unzip` task now accepts `Include` and `Exclude` arguments to filter what is extracted from the zip file (#6018). Thanks, @IvanLieckens!
+* The `-graph:noBuild` command line argument can be used to validate that a graph is buildable without actually building it (#6016).
+* `TaskParameterEventArgs` allow logging task parameters and values in a compact, structured way (#6155). Thanks, @KirillOsenkov!
+* ClickOnce publish now supports Ready To Run (#6244).
+* .NET 5.0 applications may now specify a toolset configuration file (#6220).
+* `ResolveAssemblyReferences` can now consume information about assemblies distributed as part of the SDK (#6017).
+* Allow constructing a `ProjectInstance` from a `ProjectLink` (#6262).
+* Introduce cross-process resource management for tasks (#5859).
+* `ProjectEvaluationFinished` now has fields for properties and items (#6287). Thanks, @KirillOsenkov!
+* `WriteCodeFragment` can now write assembly attributes of specified types, and infers some common types (#6285). Thanks, @reduckted!
+* The `-detailedSummary` option now accepts a boolean argument, preventing dumping details to the console logger when building with `-bl -ds:false` (#6338). Thanks, @KirillOsenkov!
+* Binary logs now include files listed in the item `EmbedInBinlog` as well as MSBuild projects (#6339). Thanks, @KirillOsenkov!
+* The `FindInvalidProjectReferences` task is now available in .NET Core/5.0+ scenarios (#6365).
+
+#### Changed
+
+* String deduplication is now much more sophisticated, reducing memory usage (#5663).
+* Refactoring and performance improvements in `ResolveAssemblyReferences` (#5929, #6094).
+* Binary logs now store strings only once, dramatically reducing log size (#6017, #6326). Thanks, @KirillOsenkov!
+* Refactoring and code cleanup (#6120, #6159, #6158, #6282). Thanks, @Nirmal4G!
+* `Span<T>`-based methods are used on .NET Framework MSBuild as well as .NET 5.0 (#6130).
+* Improved `MSB4064` error to include information about the loaded task that didn't have the argument (#5945). Thanks, @BartoszKlonowski!
+* Performance improvements in inter-node communication (#6023). Thanks, @KirillOsenkov!
+* Performance improvements in matching items based on metadata (#6035), property expansion (#6128), glob evaluation (#6151), enumerating files (#6227).
+* When evaluated with `IgnoreInvalidImports`, _empty_ imports are also allowed (#6222).
+* `Log.HasLoggedError` now respects `MSBuildWarningsAsErrors` (#6174).
+* `TargetPath` metadata is now respected on items that copy to output directories, and takes precedence over `Link` (#6237).
+* The `Restore` operation now fails when SDKs are unresolvable (#6312).
+* `MSBuild.exe.config` now has explicit binding redirects for all assemblies in the MSBuild VSIX (#6334).
+
+#### Fixed
+
+* Inconsistencies between `XamlPreCompile` and the `CoreCompile` C## compiler invocation (#6093). Thanks, @huoyaoyuan!
+* Wait for child nodes to exit before exiting the entry-point node in VSTest scenarios (#6053). Thanks, @tmds!
+* Fix bad plugin EndBuild exception handling during graph builds (#6110).
+* Allow specifying `UseUtf8Encoding` in `ToolTask`s (#6188).
+* Failures on big-endian systems (#6204). Thanks, @uweigand!
+* 64-bit `al.exe` is used when targeting 64-bit architectures (#6207).
+* Improved error messages when encountering a `BadImageReferenceException` in `ResolveAssemblyReferences` (#6240, #6270). Thanks, @FiniteReality!
+* Escape special characters in `Exec`‚Äôs generated batch files, allowing builds as users with some special characters in their Windows username (#6233).
+* Permit comments and trailing commas in solution filter files (#6346).
+* Exceptions thrown from experimental cache plugins are now handled and logged better (#6345, #6368).
+* Source generators with configuration files can now be used in XamlPreCompile (#6438).
+* Large builds no longer crash with an exception in `LogProjectStarted` (#6437).
+
+#### Infrastructure
+
+* Update to Arcade 5.0 and .NET 5.0 (#5836).
+* The primary development branch is now named `main`.
+* Test robustness improvements (#6055, #6336, #6337, #6332). Thanks, @tmds and @KirillOsenkov!
+* Remove unnecessary NuGet package references (#6036). Thanks, @teo-tsirpanis!
+* Correctly mark .NET Framework 3.5 reference assembly package dependency as private (#6214).
+* Our own builds opt into text-based performance logging (#6274).
+* Update to Arcade publishing v3 (#6349).
+* Use OneLocBuild localization process (#6378).
+
+#### Documentation
+
+* Updates to static graph documentation (#6043).
+* Short doc on the threading model (#6042).
+* Update help text to indicate that `--` is a valid argument prefix (#6205). Thanks, @BartoszKlonowski!
+* API documentation improvements (#6246, #6284).
+* Details about interactions with the Global Assembly Cache (#6173).
+
+## MSBuild 16.9.0.2116703
+
+‚ö† This release should have been versioned `16.9.1` but was erroneously released as 16.9.0.
+
+This version of MSBuild shipped with Visual Studio 2019 version 16.9.3.
+
+#### Fixed
+
+* Restore support for building solutions with web site projects (#6238).
+
+## MSBuild 16.9.0
+
+This version of MSBuild shipped with Visual Studio 2019 version 16.9.0 and .NET SDK 5.0.200.
+
+### What's new
+
+* `MSB3277` warnings now include information about the assembly identities involved, instead of saying to rerun under higher verbosity.
+* It's now possible to opt out of culture-name detection of `EmbeddedResource`s, for instance to have a resource named `a.cs.template`.
+* Common targets now support `$(BaseOutputPath)`, with the default value `bin`.
+* Item `Update`s are no longer case-sensitive, fixing a regression in MSBuild 16.6 (#5888).
+* `ParentBuildEventContext` now includes a parent `MSBuild` task if relevant, enabling proper nesting in GUI viewers.
+* Builds that fail because a warning was elevated to an error now report overall failure in the `MSBuild.exe` exit code.
+
+### Detailed release notes
+
+#### Added
+
+* The `MSB4006` error has been enhanced to describe the cycle when possible (#5711). Thanks, @haiyuzhu!.
+* More information is logged under `MSBUILDDEBUGCOMM` (#5759).
+* The command line parser now accepts arguments with double hyphens (`--argument`) as well as single hyphens (`-argument`) and forward slashes (`/argument`) (#5786). Thanks, @BartoszKlonowski!
+* MSBuild now participates in the .NET CLI text performance log system on an opt-in basis (#5861).
+* Common targets now support `$(BaseOutputPath)`, with the default value `bin` (#5238). Thanks, @Nirmal4G!
+* `Microsoft.Build.Exceptions.CircularDependencyException` is now public (#5988). Thanks, @tflynt91!
+* `EvaluationId` is now preserved in the `ProjectStarted` event, allowing disambiguating related project start events (#5997). Thanks, @KirillOsenkov!
+* The `ResolveAssemblyReference` task can now optionally emit items describing unresolved assembly conflicts (#5990).
+* Experimental `ProjectCache` API to enable higher-order build systems (#5936).
+
+#### Changed
+
+* Warnings suppressed via `$(NoWarn)` (which formerly applied only to targets that opted in like the C## compiler) are now treated as `$(MSBuildWarningsAsMessages)` (#5671).
+* Warnings elevated via `$(WarningsAsErrors )` (which formerly applied only to targets that opted in like the C## compiler) are now treated as `$(MSBuildWarningsAsErrors)` (#5774).
+* Improved error message when using an old .NET (Core) SDK and targeting .NET 5.0 (#5826).
+* Trailing spaces in property expressions inside conditionals now emit an error instead of silently expanding to the empty string (#5672, #5868). Thanks, @mfkl!
+* `MSB3277` warnings now include information about the assembly identities involved, instead of saying to rerun under higher verbosity (#5798).
+* `MSB5009` errors now indicate the project in the solution that is causing the nesting error (#5835). Thanks, @BartoszKlonowski!
+* Avoid spawning a process to determine processor architecture (#5897). Thanks, @tmds!
+* It's now possible to opt out of culture-name detection of `EmbeddedResource`s, for instance to have a resource named `a.cs.template` (#5824).
+* `ProjectInSolution.AbsolutePath` returns a normalized full path when possible (#5949).
+* Evaluation pass-stop events now include information about the "size" (number of properties/items/imports) of the project (#5978). Thanks, @arkalyanms!
+
+#### Fixed
+
+* `AllowFailureWithoutError` now does what it said it would do (#5743).
+* The solution parser now no longer skips projects that are missing an EndProject line (#5808). Thanks, @BartoszKlonowski!
+* `ProjectReference`s to `.vcxproj` projects from multi-targeted .NET projects no longer overbuild (#5838).
+* Removed unused `InternalsVisibleTo` to obsolete test assemblies (#5914). Thanks, @SingleAccretion!
+* Respect conditions when removing all items from an existing list at evaluation time (#5927).
+* Common targets should no longer break if the environment variable `OS` is set (#5916).
+* Some internal errors will now be reported as errors instead of hanging the build (#5917).
+* Item `Update`s are no longer case-sensitive, fixing a regression in MSBuild 16.6 (#5888).
+* Use lazy string formatting in more places (#5924).
+* Redundant references to MSBuild assemblies no longer fail in 64 MSBuild inline tasks (#5975).
+* The `Exec` task will now no longer emit the expanded `Command` to the log on failure (#5962). Thanks, @tmds!
+* Tasks generated with `RoslynCodeTaskFactory` now no longer rebuild for every use, even with identical inputs (#5988). Thanks, @KirillOsenkov!
+* `ParentBuildEventContext` now includes a parent `MSBuild` task if relevant (#5966). Thanks, @KirillOsenkov!
+* Builds that fail because a warning was elevated to an error now report overall failure in the `MSBuild.exe` exit code (#6006).
+* Performance of projects with large numbers of consecutive item updates without wildcards improved (#5853).
+* Performance improvements in `ResolveAssemblyReferences` (#5973).
+* PackageReferences that are marked as development dependencies are removed from the ClickOnce manifest (#6037).
+* Stop overfiltering .NET Core assemblies from the ClickOnce manifest (#6080).
+
+#### Infrastructure
+
+* The MSBuild codebase now warns for unused `using` statements (#5761).
+* The MSBuild codebase is now indexed for [Rich Code Navigation](https://visualstudio.microsoft.com/services/rich-code-navigation/) on CI build (#5790). Thanks, @jepetty!
+* The 64-bit bootstrap directory is more usable (#5825).
+* Test robustness improvements (#5827, #5944, #5995).
+* Make non-shipping NuGet packages compliant (#5823).
+* Use [Darc](https://github.com/dotnet/arcade/blob/main/Documentation/Darc.md) to keep bootstrap dependencies up to date (#5909).
+* Replace MSBuild.Dev.sln and MSBuild.SourceBuild.sln with solution filters (#6010).
+* Minimize and update NuGet feeds (#6019, #6136).
+
+#### Documentation
+
+* Improvements to MSBuild-internal Change Wave docs (#5770, #5851).
+* High-level documentation for static graph functionality added (#5741).
+* Instructions on testing private bits (#5818, #5831).
+* XML doc comments updated to match public-ready API docs pages (#6028). Thanks, @ghogen!
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index f5363b9f43f..8cd28cc499d 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -58,6 +58,7 @@ If implementing a project with an ‚Äúouter‚Äù (determine what properties to pass
     * `TargetFrameworks` indicating what TargetFrameworks are available in the project
     * `TargetFrameworkMonikers` and `TargetPlatformMonikers` indicating what framework / platform the `TargetFrameworks` map to.  This is to support implicitly setting the target platform version (for example inferring that `net5.0-windows` means the same as `net5.0-windows7.0`) as well as treating the `TargetFramework` values [as aliases](https://github.com/NuGet/Home/issues/5154)
     * Boolean metadata for `HasSingleTargetFramework` and `IsRidAgnostic`.
+    * `Platforms` indicating what platforms are available for the project to build as, and boolean metadata `IsVcxOrNativeProj` (used for [SetPlatform Negotiation](#setplatform-negotiation))
   * The `GetReferenceNearestTargetFrameworkTask` (provided by NuGet) is responsible for selecting the best matching `TargetFramework` of the referenced project
   * This target is _optional_. If not present, the reference will be built with no additional properties.
   * **New** in MSBuild 15.5.  (`TargetFrameworkMonikers` and `TargetPlatformMonikers` metadata is new in MSBuild 16.8)
@@ -84,7 +85,6 @@ If implementing a project with an ‚Äúouter‚Äù (determine what properties to pass
   * As of 15.7, this is _optional_. If a project does not contain a `GetCopyToOutputDirectoryItems` target, projects that reference it will not copy any of its outputs to their own output folders, but the build can succeed.
 * `Clean` should delete all outputs of the project.
   * It is not called during a normal build, only during "Clean" and "Rebuild".
-
 ## Other protocol requirements
 
 As with all MSBuild logic, targets can be added to do other work with `ProjectReference`s.
@@ -119,4 +119,66 @@ These properties will then be gathered via the `GetTargetFrameworks` call.  They
 </AdditionalProjectProperties>
 ```
 
-The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.
\ No newline at end of file
+The `NearestTargetFramework` metadata will be the target framework which was selected as the best one to use for the reference (via `GetReferenceNearestTargetFrameworkTask`).  This can be used to select which set of properties were used in the target framework that was active for the reference.
+
+## SetPlatform Negotiation
+As of version 17.0, MSBuild can now dynamically figure out what platform a `ProjectReference` should build as. This includes a new target and task to determine what the `SetPlatform` metadata should be, or whether to undefine the platform so the referenced project builds with its default platform.
+
+* `_GetProjectReferenceTargetFrameworkProperties` target performs the majority of the work for assigning `SetPlatform` metadata to project references.
+  * Calls the `GetCompatiblePlatform` task, which is responsible for negotiating between the current project's platform and the platforms of the referenced project to assign a `NearestPlatform` metadata to the item.
+  * Sets or undefines `SetPlatform` based on the `NearestPlatform` assignment from `GetCompatiblePlatform`
+  * This target explicitly runs after `_GetProjectReferenceTargetFrameworkProperties` because it needs to use the `IsVcxOrNativeProj` and `Platforms` properties returned by the `GetTargetFrameworks` call.
+
+Note: If a `ProjectReference` has `SetPlatform` metadata defined already, the negotiation logic is skipped over.
+### Impact on the build
+In addition to the above task and target, `.vcxproj` and `.nativeproj` projects will receive an extra MSBuild call to the `GetTargetFrameworks` target. Previously, TargetFramework negotiation skipped over these projects because they could not multi-target in the first place. Because SetPlatform negotiation needs information given from the `GetTargetFrameworks` target, it is required that the `_GetProjectReferenceTargetFrameworkProperties` target calls the MSBuild task on the ProjectReference.
+
+This means most projects will see an evaluation with no global properties defined, unless set by the user.
+
+### How To Opt In
+First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:
+
+```xml
+<Project>
+  <PropertyGroup>
+    <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
+  </PropertyGroup>
+</Project>
+```
+
+If only set in one project, the `SetPlatform` metadata will carry forward to every consecutive project reference.
+
+Next, every referenced project is required to define a `Platforms` property, where `Platforms` is a semicolon-delimited list of platforms that project could build as. For `.vcxproj` or `.nativeproj` projects, `Platforms` is constructed from the `ProjectConfiguration` items that already exist in the project. For managed SDK projects, the default is `AnyCPU`. Managed non-SDK projects need to define this manually.
+
+Lastly, a `PlatformLookupTable` may need to be defined for more complex scenarios. A `PlatformLookupTable` is a semicolon-delimited list of mappings between platforms. `<PlatformLookupTable>Win32=x86</PlatformLookupTable>`, for example. This means that when the current project is building as `Win32`, it will attempt to build the referenced project as x86. This property is **required** when a managed AnyCPU project references an unmanaged project because `AnyCPU` does not directly map to an architecture-specific platform. You can define the table in two ways:
+
+1. A standard property within the current project, in a Directory.Build.props/targets
+2. Metadata on the `ProjectReference` item. This option takes priority over the first to allow customizations per `ProjectReference`.
+
+### References between managed and unmanaged projects
+Some cases of `ProjectReference`s require a `$(PlatformLookupTable)` to correctly determine what a referenced project should build as. References between managed and unmanaged projects also get a default lookup table that can be opted out of by setting the property `UseDefaultPlatformLookupTables` to false. See the table below for details.
+
+Note: Defining a `PlatformLookupTable` overrides the default mapping.
+| Project Reference Type | `PlatformLookupTable` Required? | Notes |
+| :--  | :-: | :-: |
+| Unmanaged -> Unmanaged | No |  |
+| Managed -> Managed | No |  |
+| Unmanaged -> Managed | Optional | Uses default mapping: `Win32=x86` |
+| Managed -> Unmanaged | **Yes** when the project is AnyCPU | Uses default mapping: `x86=Win32` |
+
+Example:
+Project A: Managed, building as `AnyCPU`, has a `ProjectReference` on Project B.
+Project B: Unmanaged, has `$(Platforms)` constructed from its `Platform` metadata from its `ProjectConfiguration` items, defined as `x64;Win32`.
+
+Because `AnyCPU` does not map to anything architecture-specific, a custom mapping must be defined. Project A can either:
+1. Define `PlatformLookupTable` in its project or a Directory.Build.props as `AnyCPU=x64` or `AnyCPU=Win32`.
+2. Define `PlatformLookupTable` as metadata on the `ProjectReference` item, which would take priority over a lookup table defined elsewhere.
+     *  When only one mapping is valid, you could also directly define `SetPlatform` metadata as `Platform=foo` (for unmanaged) or `PlatformTarget=bar` (for managed). This would skip over most negotiation logic.
+
+Example of project A defining a lookup table directly on the `ProjectReference`:
+```xml
+<ItemGroup>
+  <ProjectReference Include="B.csproj" PlatformLookupTable="AnyCPU=Win32">
+</ItemGroup>
+```
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 66b119cd485..5b152e7c1a7 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -7,6 +7,9 @@ Opt-out is a better approach for us because we'd likely get limited feedback whe
 ## How do they work?
 The opt-out comes in the form of setting the environment variable `MSBuildDisableFeaturesFromVersion` to the Change Wave (or version) that contains the feature you want **disabled**. This version happens to be the version of MSBuild that the features were developed for. See the mapping of change waves to features below.
 
+## When do they become permanent?
+A wave of features is set to "rotate out" (i.e. become standard functionality) two bands after its release. For example, wave 16.8 stayed opt-out through wave 16.10, becoming standard functionalty when wave 17.0 is introduced.
+
 ## MSBuildDisableFeaturesFromVersion Values & Outcomes
 | `MSBuildDisableFeaturesFromVersion` Value                         | Result        | Receive Warning? |
 | :-------------                                                    | :----------   | :----------: |
@@ -19,15 +22,19 @@ The opt-out comes in the form of setting the environment variable `MSBuildDisabl
 # Change Waves & Associated Features
 
 ## Current Rotation of Change Waves
-### 16.8
-- [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
-- [Truncate Target/Task skipped log messages to 1024 chars](https://github.com/dotnet/msbuild/pull/5553)
-- [Don't expand full drive globs with false condition](https://github.com/dotnet/msbuild/pull/5669)
 ### 16.10
 - [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
 - [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
 - [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
 - [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
 ### 17.0
+- [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
+- [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
+- [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
+- [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
 
 ## Change Waves No Longer In Rotation
+### 16.8
+- [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
+- [Truncate Target/Task skipped log messages to 1024 chars](https://github.com/dotnet/msbuild/pull/5553)
+- [Don't expand full drive globs with false condition](https://github.com/dotnet/msbuild/pull/5669)
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index b379b227dd6..52c0b7ec043 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -154,7 +154,7 @@
     <!-- Copy our binaries to the x64 location. -->
      <Copy SourceFiles="@(FreshlyBuiltBinariesx64)"
           DestinationFiles="@(FreshlyBuiltBinariesx64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
-    
+
     <!-- Copy our freshly-built props and targets, overwriting anything we copied from the machine -->
     <Copy SourceFiles="@(FreshlyBuiltRootProjects)"
           DestinationFiles="@(FreshlyBuiltRootProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(Filename)%(Extension)')" />
@@ -190,10 +190,22 @@
     <Copy SourceFiles="@(InstalledSdks)"
           DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)Sdks\%(RecursiveDir)%(Filename)%(Extension)')" />
 
+    <!-- The .NET SDK has a dependency on DependencyModel, but relies on having it in the final
+         MSBuild.deps.json, which differs from ours because it's generated in the SDK repo.
+
+         Copy it from "next to MSBuild" in the pre-bootstrap SDK to our little weirdo bootstrap
+         layout next to the SDK tasks, so it can get loaded by the SDK tasks that need it. -->
+    <Copy SourceFiles="$(DOTNET_INSTALL_DIR)\sdk\$(DotNetCliVersion)\Microsoft.Extensions.DependencyModel.dll"
+          DestinationFolder="$(BootstrapDestination)Sdks\Microsoft.NET.Sdk\tools\net6.0" />
+
     <Copy SourceFiles="@(InstalledExtensions)"
           DestinationFolder="$(BootstrapDestination)Current\%(RecursiveDir)" />
 
     <Copy SourceFiles="@(_NuGetRuntimeDependencies)"
           DestinationFolder="$(BootstrapDestination)" />
+
+    <!-- Disable workload resolver until we can figure out whether it can work in the bootstrap
+         https://github.com/dotnet/msbuild/issues/6566 -->
+    <Touch Files="$(BootstrapDestination)\DisableWorkloadResolver.sentinel" AlwaysCreate="true" />
   </Target>
 </Project>
diff --git a/eng/Packages.props b/eng/Packages.props
index e56a9b1e2d3..d6312348572 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -10,7 +10,7 @@
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.DotNet.GenAPI" Version="2.1.0-prerelease-02404-02" />
-    <PackageReference Update="Microsoft.Extensions.DependencyModel" Version="2.1.0" />
+    <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" />
     <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="1.16.30" />
@@ -39,16 +39,13 @@
     <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(MonoBuild)' == 'true' or $([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp2.1'))">
-    <PackageReference Update="Microsoft.Extensions.DependencyModel" Version="$(MicrosoftExtensionsDependencyModelVersion)"/>
-  </ItemGroup>
-
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
     <GlobalPackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.0" PrivateAssets="All"/>
   </ItemGroup>
 
   <ItemGroup>
     <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+    <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="$(MicrosoftCodeAnalysisBannedApiAnalyzersVersion)" />
   </ItemGroup>
 
 </Project>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 56a2267b72a..913016f5165 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,26 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21304.1">
+    <Dependency Name="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.2">
+      <Uri>https://github.com/dotnet/roslyn-analyzers</Uri>
+      <Sha />
+    </Dependency>
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21379.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>85a65ea1fca1d0867f699fed44d191358270bf6a</Sha>
+      <Sha>62a8aafffd4c68ef887680f6837abdff906a662c</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-preview.1.66">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-preview.1.107">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>e84a10e4b0e6bccce7421af020728d9bbc3e64e0</Sha>
-    </Dependency>
-    <Dependency Name="Microsoft.Extensions.DependencyModel" Version="6.0.0-preview.2.21154.6">
-      <Uri>https://github.com/dotnet/runtime</Uri>
-      <Sha />
+      <Sha>7950d9b3c0b7fb9dc1c55700dc00e86e1ebd82f2</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.0.0-1.21304.5">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.0.0-3.21373.8">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>b6a9f8c39f7a71b02b9a8b929f002777e4efd6f1</Sha>
+      <Sha>5f124755232afa7b9903d6bdfcaeb47f39c8838e</Sha>
+    </Dependency>
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21379.2">
+      <Uri>https://github.com/dotnet/arcade</Uri>
+      <Sha>62a8aafffd4c68ef887680f6837abdff906a662c</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index bb7137d8840..d9ffb13fe57 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -31,10 +31,12 @@
   <PropertyGroup>
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
-    <DotNetCliVersion>6.0.100-preview.3.21202.5</DotNetCliVersion>
+    <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21379.2</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftCodeAnalysisBannedApiAnalyzersVersion>3.3.2</MicrosoftCodeAnalysisBannedApiAnalyzersVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.0.0-1.21304.5</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.0.0-preview.1.66</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.0.0-3.21373.8</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.0.0-preview.1.107</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/build.ps1 b/eng/build.ps1
index f2a094600c1..9245a71a0f4 100644
--- a/eng/build.ps1
+++ b/eng/build.ps1
@@ -40,7 +40,7 @@ function Print-Usage() {
   Write-Host "  -verbosity <value>      Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
   Write-Host "  -binaryLog              Output binary log (short: -bl)"
   Write-Host ""
- 
+
   Write-Host "Actions:"
   Write-Host "  -restore                Restore dependencies (short: -r)"
   Write-Host "  -build                  Build solution (short: -b)"
@@ -55,14 +55,14 @@ function Print-Usage() {
   Write-Host "  -sign                   Sign build outputs"
   Write-Host "  -publish                Publish artifacts (e.g. symbols)"
   Write-Host ""
- 
+
   Write-Host "Advanced settings:"
   Write-Host "  -projects <value>       Semi-colon delimited list of sln/proj's to build. Globbing is supported (*.sln)"
   Write-Host "  -ci                     Set when running on CI server"
   Write-Host "  -prepareMachine         Prepare machine for CI run"
   Write-Host "  -msbuildEngine <value>  Msbuild engine to use to run build ('dotnet', 'vs', or unspecified)."
   Write-Host ""
- 
+
   Write-Host "Official build settings:"
   Write-Host "  -officialBuildId                            An official build id, e.g. 20190102.3"
   Write-Host "  -officialSkipApplyOptimizationData <bool>   Pass 'true' to not apply optimization data"
@@ -151,20 +151,38 @@ function Set-OptProfVariables() {
 function Check-EditedFiles() {
   # Log VSTS errors for changed lines
   git --no-pager diff HEAD --unified=0 --no-color --exit-code | ForEach-Object { "##vso[task.logissue type=error] $_" }
-  if($LASTEXITCODE -ne 0) {
+  if ($LASTEXITCODE -ne 0) {
     throw "##vso[task.logissue type=error] After building, there are changed files.  Please build locally and include these changes in your pull request."
   }
 }
 
+function Check-RequiredVersionBumps() {
+  # Log VSTS errors for missing required version bumps
+  if ($env:SYSTEM_PULLREQUEST_TARGETBRANCH) {
+    $versionLineChanged = $false
+    git --no-pager diff --unified --no-color --exit-code -w origin/$env:SYSTEM_PULLREQUEST_TARGETBRANCH HEAD src\Framework\EngineServices.cs `
+      | Select-String -Pattern "int Version =" | ForEach-Object -process { $versionLineChanged = $true }
+    if (($LASTEXITCODE -ne 0) -and (-not $versionLineChanged)) {
+      throw "##vso[task.logissue type=error] Detected changes in Framework\EngineServices.cs without a version bump.  " +
+            "If you are making API changes, please bump the version.  " +
+            "If the changes in the file are cosmetic, please add/change a comment on the Version prop to silence the error."
+    }
+  }
+}
+
 try {
   Process-Arguments
- 
+
   # Import Arcade functions
   . (Join-Path $PSScriptRoot "common\tools.ps1")
   . (Join-Path $PSScriptRoot "configure-toolset.ps1")
 
   $VSSetupDir = Join-Path $ArtifactsDir "VSSetup\$configuration"
 
+  if ($ci -and $build) {
+    Check-RequiredVersionBumps
+  }
+
   Build-Repo
 
   if ($ci -and $build) {
diff --git a/eng/common/SetupNugetSources.ps1 b/eng/common/SetupNugetSources.ps1
index a0b5fc37f43..18823840b11 100644
--- a/eng/common/SetupNugetSources.ps1
+++ b/eng/common/SetupNugetSources.ps1
@@ -158,4 +158,10 @@ if ($dotnet5Source -ne $null) {
     AddPackageSource -Sources $sources -SourceName "dotnet5-internal-transport" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet5-internal-transport/nuget/v2" -Creds $creds -Username $userName -Password $Password
 }
 
+$dotnet6Source = $sources.SelectSingleNode("add[@key='dotnet6']")
+if ($dotnet6Source -ne $null) {
+    AddPackageSource -Sources $sources -SourceName "dotnet6-internal" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet6-internal/nuget/v2" -Creds $creds -Username $userName -Password $Password
+    AddPackageSource -Sources $sources -SourceName "dotnet6-internal-transport" -SourceEndPoint "https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet6-internal-transport/nuget/v2" -Creds $creds -Username $userName -Password $Password
+}
+
 $doc.Save($filename)
diff --git a/eng/common/SetupNugetSources.sh b/eng/common/SetupNugetSources.sh
index 2734601c13c..ad3fb74fd2c 100644
--- a/eng/common/SetupNugetSources.sh
+++ b/eng/common/SetupNugetSources.sh
@@ -129,6 +129,30 @@ if [ "$?" == "0" ]; then
     PackageSources+=('dotnet5-internal-transport')
 fi
 
+# Ensure dotnet6-internal and dotnet6-internal-transport are in the packageSources if the public dotnet6 feeds are present
+grep -i "<add key=\"dotnet6\"" $ConfigFile
+if [ "$?" == "0" ]; then
+    grep -i "<add key=\"dotnet6-internal\"" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet6-internal to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet6-internal\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet6-internal/nuget/v2\" />"
+
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet6-internal')
+
+    grep -i "<add key=\"dotnet6-internal-transport\">" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet6-internal-transport to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet6-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/dotnet6-internal-transport/nuget/v2\" />"
+
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet6-internal-transport')
+fi
+
 # I want things split line by line
 PrevIFS=$IFS
 IFS=$'\n'
diff --git a/eng/common/cross/build-rootfs.sh b/eng/common/cross/build-rootfs.sh
index 591d8666a84..735a4c82838 100755
--- a/eng/common/cross/build-rootfs.sh
+++ b/eng/common/cross/build-rootfs.sh
@@ -33,7 +33,6 @@ __AlpinePackages="alpine-base"
 __AlpinePackages+=" build-base"
 __AlpinePackages+=" linux-headers"
 __AlpinePackagesEdgeCommunity=" lldb-dev"
-__AlpinePackagesEdgeMain=" llvm10-libs"
 __AlpinePackagesEdgeMain+=" python3"
 __AlpinePackagesEdgeMain+=" libedit"
 
@@ -115,6 +114,8 @@ while :; do
             __UbuntuArch=s390x
             __UbuntuRepo="http://ports.ubuntu.com/ubuntu-ports/"
             __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp5//')
             unset __LLDB_Package
             ;;
         x86)
@@ -191,6 +192,8 @@ while :; do
             __CodeName=alpine
             __UbuntuRepo=
             __AlpineVersion=3.9
+            __AlpinePackagesEdgeMain+=" llvm11-libs"
+            __AlpinePackagesEdgeMain+=" clang-libs"
             ;;
         alpine3.13)
             __CodeName=alpine
@@ -201,6 +204,7 @@ while :; do
             __AlpinePackagesEdgeCommunity=
             __AlpinePackages+=$__AlpinePackagesEdgeMain
             __AlpinePackagesEdgeMain=
+            __AlpinePackages+=" llvm10-libs"
             ;;
         freebsd11)
             __FreeBSDBase="11.3-RELEASE"
diff --git a/eng/common/dotnet-install.sh b/eng/common/dotnet-install.sh
index d6efeb44340..fdfeea66e7d 100755
--- a/eng/common/dotnet-install.sh
+++ b/eng/common/dotnet-install.sh
@@ -70,7 +70,7 @@ case $cpuname in
     ;;
 esac
 
-dotnetRoot="$repo_root/.dotnet"
+dotnetRoot="${repo_root}.dotnet"
 if [[ $architecture != "" ]] && [[ $architecture != $buildarch ]]; then
   dotnetRoot="$dotnetRoot/$architecture"
 fi
diff --git a/eng/common/generate-locproject.ps1 b/eng/common/generate-locproject.ps1
index de348a2e225..25e97ac0077 100644
--- a/eng/common/generate-locproject.ps1
+++ b/eng/common/generate-locproject.ps1
@@ -25,8 +25,15 @@ Push-Location "$SourcesDirectory" # push location for Resolve-Path -Relative to
 
 # Template files
 $jsonFiles = @()
-$jsonFiles += Get-ChildItem -Recurse -Path "$SourcesDirectory" | Where-Object { $_.FullName -Match "\.template\.config\\localize\\en\..+\.json" } # .NET templating pattern
-$jsonFiles += Get-ChildItem -Recurse -Path "$SourcesDirectory" | Where-Object { $_.FullName -Match "en\\strings\.json" } # current winforms pattern
+$jsonTemplateFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory" | Where-Object { $_.FullName -Match "\.template\.config\\localize\\.+\.en\.json" } # .NET templating pattern
+$jsonTemplateFiles | ForEach-Object {
+    $null = $_.Name -Match "(.+)\.[\w-]+\.json" # matches '[filename].[langcode].json
+    
+    $destinationFile = "$($_.Directory.FullName)\$($Matches.1).json"
+    $jsonFiles += Copy-Item "$($_.FullName)" -Destination $destinationFile -PassThru
+}
+
+$jsonWinformsTemplateFiles = Get-ChildItem -Recurse -Path "$SourcesDirectory" | Where-Object { $_.FullName -Match "en\\strings\.json" } # current winforms pattern
 
 $xlfFiles = @()
 
@@ -44,7 +51,7 @@ $langXlfFiles | ForEach-Object {
     $xlfFiles += Copy-Item "$($_.FullName)" -Destination $destinationFile -PassThru
 }
 
-$locFiles = $jsonFiles + $xlfFiles
+$locFiles = $jsonFiles + $jsonWinformsTemplateFiles + $xlfFiles
 
 $locJson = @{
     Projects = @(
diff --git a/eng/common/internal-feed-operations.ps1 b/eng/common/internal-feed-operations.ps1
index 418c09930cf..92b77347d99 100644
--- a/eng/common/internal-feed-operations.ps1
+++ b/eng/common/internal-feed-operations.ps1
@@ -45,11 +45,11 @@ function SetupCredProvider {
   # Then, we set the 'VSS_NUGET_EXTERNAL_FEED_ENDPOINTS' environment variable to restore from the stable 
   # feeds successfully
 
-  $nugetConfigPath = "$RepoRoot\NuGet.config"
+  $nugetConfigPath = Join-Path $RepoRoot "NuGet.config"
 
   if (-Not (Test-Path -Path $nugetConfigPath)) {
     Write-PipelineTelemetryError -Category 'Build' -Message 'NuGet.config file not found in repo root!'
-    ExitWithExitCode 1  
+    ExitWithExitCode 1
   }
   
   $endpoints = New-Object System.Collections.ArrayList
@@ -85,7 +85,7 @@ function SetupCredProvider {
 
 #Workaround for https://github.com/microsoft/msbuild/issues/4430
 function InstallDotNetSdkAndRestoreArcade {
-  $dotnetTempDir = "$RepoRoot\dotnet"
+  $dotnetTempDir = Join-Path $RepoRoot "dotnet"
   $dotnetSdkVersion="2.1.507" # After experimentation we know this version works when restoring the SDK (compared to 3.0.*)
   $dotnet = "$dotnetTempDir\dotnet.exe"
   $restoreProjPath = "$PSScriptRoot\restore.proj"
diff --git a/eng/common/internal-feed-operations.sh b/eng/common/internal-feed-operations.sh
index e2233e78122..9378223ba09 100755
--- a/eng/common/internal-feed-operations.sh
+++ b/eng/common/internal-feed-operations.sh
@@ -39,7 +39,7 @@ function SetupCredProvider {
   # Then, we set the 'VSS_NUGET_EXTERNAL_FEED_ENDPOINTS' environment variable to restore from the stable 
   # feeds successfully
 
-  local nugetConfigPath="$repo_root/NuGet.config"
+  local nugetConfigPath="{$repo_root}NuGet.config"
 
   if [ ! "$nugetConfigPath" ]; then
     Write-PipelineTelemetryError -category 'Build' "NuGet.config file not found in repo's root!"
diff --git a/eng/common/internal/Tools.csproj b/eng/common/internal/Tools.csproj
index f46d5efe2e3..beb9c4648ea 100644
--- a/eng/common/internal/Tools.csproj
+++ b/eng/common/internal/Tools.csproj
@@ -1,5 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (c)  Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. -->
+<!-- Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. -->
 <Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
     <TargetFramework>net472</TargetFramework>
diff --git a/eng/common/sdk-task.ps1 b/eng/common/sdk-task.ps1
index 65f1d75f3d3..b1bca63ab1d 100644
--- a/eng/common/sdk-task.ps1
+++ b/eng/common/sdk-task.ps1
@@ -34,7 +34,7 @@ function Print-Usage() {
 function Build([string]$target) {
   $logSuffix = if ($target -eq 'Execute') { '' } else { ".$target" }
   $log = Join-Path $LogDir "$task$logSuffix.binlog"
-  $outputPath = Join-Path $ToolsetDir "$task\\"
+  $outputPath = Join-Path $ToolsetDir "$task\"
 
   MSBuild $taskProject `
     /bl:$log `
@@ -64,7 +64,7 @@ try {
       $GlobalJson.tools | Add-Member -Name "vs" -Value (ConvertFrom-Json "{ `"version`": `"16.5`" }") -MemberType NoteProperty
     }
     if( -not ($GlobalJson.tools.PSObject.Properties.Name -match "xcopy-msbuild" )) {
-      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "16.8.0-preview3" -MemberType NoteProperty
+      $GlobalJson.tools | Add-Member -Name "xcopy-msbuild" -Value "16.10.0-preview2" -MemberType NoteProperty
     }
     if ($GlobalJson.tools."xcopy-msbuild".Trim() -ine "none") {
         $xcopyMSBuildToolsFolder = InitializeXCopyMSBuild $GlobalJson.tools."xcopy-msbuild" -install $true
diff --git a/eng/common/sdl/configure-sdl-tool.ps1 b/eng/common/sdl/configure-sdl-tool.ps1
new file mode 100644
index 00000000000..4999c307088
--- /dev/null
+++ b/eng/common/sdl/configure-sdl-tool.ps1
@@ -0,0 +1,109 @@
+Param(
+  [string] $GuardianCliLocation,
+  [string] $WorkingDirectory,
+  [string] $TargetDirectory,
+  [string] $GdnFolder,
+  # The list of Guardian tools to configure. For each object in the array:
+  # - If the item is a [hashtable], it must contain these entries:
+  #   - Name = The tool name as Guardian knows it.
+  #   - Scenario = (Optional) Scenario-specific name for this configuration entry. It must be unique
+  #     among all tool entries with the same Name.
+  #   - Args = (Optional) Array of Guardian tool configuration args, like '@("Target > C:\temp")'
+  # - If the item is a [string] $v, it is treated as '@{ Name="$v" }'
+  [object[]] $ToolsList,
+  [string] $GuardianLoggerLevel='Standard',
+  # Optional: Additional params to add to any tool using CredScan.
+  [string[]] $CrScanAdditionalRunConfigParams,
+  # Optional: Additional params to add to any tool using PoliCheck.
+  [string[]] $PoliCheckAdditionalRunConfigParams
+)
+
+$ErrorActionPreference = 'Stop'
+Set-StrictMode -Version 2.0
+$disableConfigureToolsetImport = $true
+$global:LASTEXITCODE = 0
+
+try {
+  # `tools.ps1` checks $ci to perform some actions. Since the SDL
+  # scripts don't necessarily execute in the same agent that run the
+  # build.ps1/sh script this variable isn't automatically set.
+  $ci = $true
+  . $PSScriptRoot\..\tools.ps1
+
+  # Normalize tools list: all in [hashtable] form with defined values for each key.
+  $ToolsList = $ToolsList |
+    ForEach-Object {
+      if ($_ -is [string]) {
+        $_ = @{ Name = $_ }
+      }
+
+      if (-not ($_['Scenario'])) { $_.Scenario = "" }
+      if (-not ($_['Args'])) { $_.Args = @() }
+      $_
+    }
+  
+  Write-Host "List of tools to configure:"
+  $ToolsList | ForEach-Object { $_ | Out-String | Write-Host }
+
+  # We store config files in the r directory of .gdn
+  $gdnConfigPath = Join-Path $GdnFolder 'r'
+  $ValidPath = Test-Path $GuardianCliLocation
+
+  if ($ValidPath -eq $False)
+  {
+    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Invalid Guardian CLI Location."
+    ExitWithExitCode 1
+  }
+
+  foreach ($tool in $ToolsList) {
+    # Put together the name and scenario to make a unique key.
+    $toolConfigName = $tool.Name
+    if ($tool.Scenario) {
+      $toolConfigName += "_" + $tool.Scenario
+    }
+
+    Write-Host "=== Configuring $toolConfigName..."
+
+    $gdnConfigFile = Join-Path $gdnConfigPath "$toolConfigName-configure.gdnconfig"
+
+    # For some tools, add default and automatic args.
+    if ($tool.Name -eq 'credscan') {
+      if ($targetDirectory) {
+        $tool.Args += "TargetDirectory < $TargetDirectory"
+      }
+      $tool.Args += "OutputType < pre"
+      $tool.Args += $CrScanAdditionalRunConfigParams
+    } elseif ($tool.Name -eq 'policheck') {
+      if ($targetDirectory) {
+        $tool.Args += "Target < $TargetDirectory"
+      }
+      $tool.Args += $PoliCheckAdditionalRunConfigParams
+    }
+
+    # Create variable pointing to the args array directly so we can use splat syntax later.
+    $toolArgs = $tool.Args
+
+    # Configure the tool. If args array is provided or the current tool has some default arguments
+    # defined, add "--args" and splat each element on the end. Arg format is "{Arg id} < {Value}",
+    # one per parameter. Doc page for "guardian configure":
+    # https://dev.azure.com/securitytools/SecurityIntegration/_wiki/wikis/Guardian/1395/configure
+    Exec-BlockVerbosely {
+      & $GuardianCliLocation configure `
+        --working-directory $WorkingDirectory `
+        --tool $tool.Name `
+        --output-path $gdnConfigFile `
+        --logger-level $GuardianLoggerLevel `
+        --noninteractive `
+        --force `
+        $(if ($toolArgs) { "--args" }) @toolArgs
+      Exit-IfNZEC "Sdl"
+    }
+
+    Write-Host "Created '$toolConfigName' configuration file: $gdnConfigFile"
+  }
+}
+catch {
+  Write-Host $_.ScriptStackTrace
+  Write-PipelineTelemetryError -Force -Category 'Sdl' -Message $_
+  ExitWithExitCode 1
+}
diff --git a/eng/common/sdl/execute-all-sdl-tools.ps1 b/eng/common/sdl/execute-all-sdl-tools.ps1
index 81b729f74a4..1157151f486 100644
--- a/eng/common/sdl/execute-all-sdl-tools.ps1
+++ b/eng/common/sdl/execute-all-sdl-tools.ps1
@@ -7,8 +7,17 @@ Param(
   [string] $SourceDirectory=$env:BUILD_SOURCESDIRECTORY,                                         # Required: the directory where source files are located
   [string] $ArtifactsDirectory = (Join-Path $env:BUILD_ARTIFACTSTAGINGDIRECTORY ('artifacts')),  # Required: the directory where build artifacts are located
   [string] $AzureDevOpsAccessToken,                                                              # Required: access token for dnceng; should be provided via KeyVault
-  [string[]] $SourceToolsList,                                                                   # Optional: list of SDL tools to run on source code
-  [string[]] $ArtifactToolsList,                                                                 # Optional: list of SDL tools to run on built artifacts
+
+  # Optional: list of SDL tools to run on source code. See 'configure-sdl-tool.ps1' for tools list
+  # format.
+  [object[]] $SourceToolsList,
+  # Optional: list of SDL tools to run on built artifacts. See 'configure-sdl-tool.ps1' for tools
+  # list format.
+  [object[]] $ArtifactToolsList,
+  # Optional: list of SDL tools to run without automatically specifying a target directory. See
+  # 'configure-sdl-tool.ps1' for tools list format.
+  [object[]] $CustomToolsList,
+
   [bool] $TsaPublish=$False,                                                                     # Optional: true will publish results to TSA; only set to true after onboarding to TSA; TSA is the automated framework used to upload test results as bugs.
   [string] $TsaBranchName=$env:BUILD_SOURCEBRANCH,                                               # Optional: required for TSA publish; defaults to $(Build.SourceBranchName); TSA is the automated framework used to upload test results as bugs.
   [string] $TsaRepositoryName=$env:BUILD_REPOSITORY_NAME,                                        # Optional: TSA repository name; will be generated automatically if not submitted; TSA is the automated framework used to upload test results as bugs.
@@ -32,7 +41,7 @@ try {
   $ErrorActionPreference = 'Stop'
   Set-StrictMode -Version 2.0
   $disableConfigureToolsetImport = $true
-  $LASTEXITCODE = 0
+  $global:LASTEXITCODE = 0
 
   # `tools.ps1` checks $ci to perform some actions. Since the SDL
   # scripts don't necessarily execute in the same agent that run the
@@ -63,13 +72,16 @@ try {
     ExitWithExitCode 1
   }
 
-  & $(Join-Path $PSScriptRoot 'init-sdl.ps1') -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -AzureDevOpsAccessToken $AzureDevOpsAccessToken -GuardianLoggerLevel $GuardianLoggerLevel
+  Exec-BlockVerbosely {
+    & $(Join-Path $PSScriptRoot 'init-sdl.ps1') -GuardianCliLocation $guardianCliLocation -Repository $RepoName -BranchName $BranchName -WorkingDirectory $workingDirectory -AzureDevOpsAccessToken $AzureDevOpsAccessToken -GuardianLoggerLevel $GuardianLoggerLevel
+  }
   $gdnFolder = Join-Path $workingDirectory '.gdn'
 
   if ($TsaOnboard) {
     if ($TsaCodebaseName -and $TsaNotificationEmail -and $TsaCodebaseAdmin -and $TsaBugAreaPath) {
-      Write-Host "$guardianCliLocation tsa-onboard --codebase-name `"$TsaCodebaseName`" --notification-alias `"$TsaNotificationEmail`" --codebase-admin `"$TsaCodebaseAdmin`" --instance-url `"$TsaInstanceUrl`" --project-name `"$TsaProjectName`" --area-path `"$TsaBugAreaPath`" --iteration-path `"$TsaIterationPath`" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel"
-      & $guardianCliLocation tsa-onboard --codebase-name "$TsaCodebaseName" --notification-alias "$TsaNotificationEmail" --codebase-admin "$TsaCodebaseAdmin" --instance-url "$TsaInstanceUrl" --project-name "$TsaProjectName" --area-path "$TsaBugAreaPath" --iteration-path "$TsaIterationPath" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel
+      Exec-BlockVerbosely {
+        & $guardianCliLocation tsa-onboard --codebase-name "$TsaCodebaseName" --notification-alias "$TsaNotificationEmail" --codebase-admin "$TsaCodebaseAdmin" --instance-url "$TsaInstanceUrl" --project-name "$TsaProjectName" --area-path "$TsaBugAreaPath" --iteration-path "$TsaIterationPath" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel
+      }
       if ($LASTEXITCODE -ne 0) {
         Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian tsa-onboard failed with exit code $LASTEXITCODE."
         ExitWithExitCode $LASTEXITCODE
@@ -80,11 +92,41 @@ try {
     }
   }
 
-  if ($ArtifactToolsList -and $ArtifactToolsList.Count -gt 0) {
-    & $(Join-Path $PSScriptRoot 'run-sdl.ps1') -GuardianCliLocation $guardianCliLocation -WorkingDirectory $workingDirectory -TargetDirectory $ArtifactsDirectory -GdnFolder $gdnFolder -ToolsList $ArtifactToolsList -AzureDevOpsAccessToken $AzureDevOpsAccessToken -UpdateBaseline $UpdateBaseline -GuardianLoggerLevel $GuardianLoggerLevel -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams
+  # Configure a list of tools with a default target directory. Populates the ".gdn/r" directory.
+  function Configure-ToolsList([object[]] $tools, [string] $targetDirectory) {
+    if ($tools -and $tools.Count -gt 0) {
+      Exec-BlockVerbosely {
+        & $(Join-Path $PSScriptRoot 'configure-sdl-tool.ps1') `
+          -GuardianCliLocation $guardianCliLocation `
+          -WorkingDirectory $workingDirectory `
+          -TargetDirectory $targetDirectory `
+          -GdnFolder $gdnFolder `
+          -ToolsList $tools `
+          -AzureDevOpsAccessToken $AzureDevOpsAccessToken `
+          -GuardianLoggerLevel $GuardianLoggerLevel `
+          -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams `
+          -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams
+        if ($BreakOnFailure) {
+          Exit-IfNZEC "Sdl"
+        }
+      }
+    }
   }
-  if ($SourceToolsList -and $SourceToolsList.Count -gt 0) {
-    & $(Join-Path $PSScriptRoot 'run-sdl.ps1') -GuardianCliLocation $guardianCliLocation -WorkingDirectory $workingDirectory -TargetDirectory $SourceDirectory -GdnFolder $gdnFolder -ToolsList $SourceToolsList -AzureDevOpsAccessToken $AzureDevOpsAccessToken -UpdateBaseline $UpdateBaseline -GuardianLoggerLevel $GuardianLoggerLevel -CrScanAdditionalRunConfigParams $CrScanAdditionalRunConfigParams -PoliCheckAdditionalRunConfigParams $PoliCheckAdditionalRunConfigParams
+
+  # Configure Artifact and Source tools with default Target directories.
+  Configure-ToolsList $ArtifactToolsList $ArtifactsDirectory
+  Configure-ToolsList $SourceToolsList $SourceDirectory
+  # Configure custom tools with no default Target directory.
+  Configure-ToolsList $CustomToolsList $null
+
+  # At this point, all tools are configured in the ".gdn" directory. Run them all in a single call.
+  # (If we used "run" multiple times, each run would overwrite data from earlier runs.)
+  Exec-BlockVerbosely {
+    & $(Join-Path $PSScriptRoot 'run-sdl.ps1') `
+      -GuardianCliLocation $guardianCliLocation `
+      -WorkingDirectory $workingDirectory `
+      -UpdateBaseline $UpdateBaseline `
+      -GdnFolder $gdnFolder
   }
 
   if ($TsaPublish) {
@@ -92,8 +134,9 @@ try {
       if (-not $TsaRepositoryName) {
         $TsaRepositoryName = "$($Repository)-$($BranchName)"
       }
-      Write-Host "$guardianCliLocation tsa-publish --all-tools --repository-name `"$TsaRepositoryName`" --branch-name `"$TsaBranchName`" --build-number `"$BuildNumber`" --codebase-name `"$TsaCodebaseName`" --notification-alias `"$TsaNotificationEmail`" --codebase-admin `"$TsaCodebaseAdmin`" --instance-url `"$TsaInstanceUrl`" --project-name `"$TsaProjectName`" --area-path `"$TsaBugAreaPath`" --iteration-path `"$TsaIterationPath`" --working-directory $workingDirectory --logger-level $GuardianLoggerLevel"
-      & $guardianCliLocation tsa-publish --all-tools --repository-name "$TsaRepositoryName" --branch-name "$TsaBranchName" --build-number "$BuildNumber" --onboard $True --codebase-name "$TsaCodebaseName" --notification-alias "$TsaNotificationEmail" --codebase-admin "$TsaCodebaseAdmin" --instance-url "$TsaInstanceUrl" --project-name "$TsaProjectName" --area-path "$TsaBugAreaPath" --iteration-path "$TsaIterationPath" --working-directory $workingDirectory  --logger-level $GuardianLoggerLevel
+      Exec-BlockVerbosely {
+        & $guardianCliLocation tsa-publish --all-tools --repository-name "$TsaRepositoryName" --branch-name "$TsaBranchName" --build-number "$BuildNumber" --onboard $True --codebase-name "$TsaCodebaseName" --notification-alias "$TsaNotificationEmail" --codebase-admin "$TsaCodebaseAdmin" --instance-url "$TsaInstanceUrl" --project-name "$TsaProjectName" --area-path "$TsaBugAreaPath" --iteration-path "$TsaIterationPath" --working-directory $workingDirectory  --logger-level $GuardianLoggerLevel
+      }
       if ($LASTEXITCODE -ne 0) {
         Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian tsa-publish failed with exit code $LASTEXITCODE."
         ExitWithExitCode $LASTEXITCODE
@@ -106,7 +149,11 @@ try {
 
   if ($BreakOnFailure) {
     Write-Host "Failing the build in case of breaking results..."
-    & $guardianCliLocation break
+    Exec-BlockVerbosely {
+      & $guardianCliLocation break --working-directory $workingDirectory --logger-level $GuardianLoggerLevel
+    }
+  } else {
+    Write-Host "Letting the build pass even if there were breaking results..."
   }
 }
 catch {
diff --git a/eng/common/sdl/extract-artifact-archives.ps1 b/eng/common/sdl/extract-artifact-archives.ps1
new file mode 100644
index 00000000000..68da4fbf257
--- /dev/null
+++ b/eng/common/sdl/extract-artifact-archives.ps1
@@ -0,0 +1,63 @@
+# This script looks for each archive file in a directory and extracts it into the target directory.
+# For example, the file "$InputPath/bin.tar.gz" extracts to "$ExtractPath/bin.tar.gz.extracted/**".
+# Uses the "tar" utility added to Windows 10 / Windows 2019 that supports tar.gz and zip.
+param(
+  # Full path to directory where archives are stored.
+  [Parameter(Mandatory=$true)][string] $InputPath,
+  # Full path to directory to extract archives into. May be the same as $InputPath.
+  [Parameter(Mandatory=$true)][string] $ExtractPath
+)
+
+$ErrorActionPreference = 'Stop'
+Set-StrictMode -Version 2.0
+
+$disableConfigureToolsetImport = $true
+
+try {
+  # `tools.ps1` checks $ci to perform some actions. Since the SDL
+  # scripts don't necessarily execute in the same agent that run the
+  # build.ps1/sh script this variable isn't automatically set.
+  $ci = $true
+  . $PSScriptRoot\..\tools.ps1
+
+  Measure-Command {
+    $jobs = @()
+
+    # Find archive files for non-Windows and Windows builds.
+    $archiveFiles = @(
+      Get-ChildItem (Join-Path $InputPath "*.tar.gz")
+      Get-ChildItem (Join-Path $InputPath "*.zip")
+    )
+
+    foreach ($targzFile in $archiveFiles) {
+      $jobs += Start-Job -ScriptBlock {
+        $file = $using:targzFile
+        $fileName = [System.IO.Path]::GetFileName($file)
+        $extractDir = Join-Path $using:ExtractPath "$fileName.extracted"
+
+        New-Item $extractDir -ItemType Directory -Force | Out-Null
+
+        Write-Host "Extracting '$file' to '$extractDir'..."
+
+        # Pipe errors to stdout to prevent PowerShell detecting them and quitting the job early.
+        # This type of quit skips the catch, so we wouldn't be able to tell which file triggered the
+        # error. Save output so it can be stored in the exception string along with context.
+        $output = tar -xf $file -C $extractDir 2>&1
+        # Handle NZEC manually rather than using Exit-IfNZEC: we are in a background job, so we
+        # don't have access to the outer scope.
+        if ($LASTEXITCODE -ne 0) {
+          throw "Error extracting '$file': non-zero exit code ($LASTEXITCODE). Output: '$output'"
+        }
+
+        Write-Host "Extracted to $extractDir"
+      }
+    }
+
+    Receive-Job $jobs -Wait
+  }
+}
+catch {
+  Write-Host $_
+  Write-PipelineTelemetryError -Force -Category 'Sdl' -Message $_
+  ExitWithExitCode 1
+}
diff --git a/eng/common/sdl/init-sdl.ps1 b/eng/common/sdl/init-sdl.ps1
index 1fe9271193c..3ac1d92b370 100644
--- a/eng/common/sdl/init-sdl.ps1
+++ b/eng/common/sdl/init-sdl.ps1
@@ -10,7 +10,7 @@ Param(
 $ErrorActionPreference = 'Stop'
 Set-StrictMode -Version 2.0
 $disableConfigureToolsetImport = $true
-$LASTEXITCODE = 0
+$global:LASTEXITCODE = 0
 
 # `tools.ps1` checks $ci to perform some actions. Since the SDL
 # scripts don't necessarily execute in the same agent that run the
diff --git a/eng/common/sdl/run-sdl.ps1 b/eng/common/sdl/run-sdl.ps1
index fe95ab35aa5..2eac8c78f10 100644
--- a/eng/common/sdl/run-sdl.ps1
+++ b/eng/common/sdl/run-sdl.ps1
@@ -1,19 +1,15 @@
 Param(
   [string] $GuardianCliLocation,
   [string] $WorkingDirectory,
-  [string] $TargetDirectory,
   [string] $GdnFolder,
-  [string[]] $ToolsList,
   [string] $UpdateBaseline,
-  [string] $GuardianLoggerLevel='Standard',
-  [string[]] $CrScanAdditionalRunConfigParams,
-  [string[]] $PoliCheckAdditionalRunConfigParams
+  [string] $GuardianLoggerLevel='Standard'
 )
 
 $ErrorActionPreference = 'Stop'
 Set-StrictMode -Version 2.0
 $disableConfigureToolsetImport = $true
-$LASTEXITCODE = 0
+$global:LASTEXITCODE = 0
 
 try {
   # `tools.ps1` checks $ci to perform some actions. Since the SDL
@@ -23,7 +19,6 @@ try {
   . $PSScriptRoot\..\tools.ps1
 
   # We store config files in the r directory of .gdn
-  Write-Host $ToolsList
   $gdnConfigPath = Join-Path $GdnFolder 'r'
   $ValidPath = Test-Path $GuardianCliLocation
 
@@ -33,37 +28,18 @@ try {
     ExitWithExitCode 1
   }
 
-  $configParam = @('--config')
-
-  foreach ($tool in $ToolsList) {
-    $gdnConfigFile = Join-Path $gdnConfigPath "$tool-configure.gdnconfig"
-    Write-Host $tool
-    # We have to manually configure tools that run on source to look at the source directory only
-    if ($tool -eq 'credscan') {
-      Write-Host "$GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args `" TargetDirectory < $TargetDirectory `" `" OutputType < pre `" $(If ($CrScanAdditionalRunConfigParams) {$CrScanAdditionalRunConfigParams})"
-      & $GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args " TargetDirectory < $TargetDirectory " "OutputType < pre" $(If ($CrScanAdditionalRunConfigParams) {$CrScanAdditionalRunConfigParams})
-      if ($LASTEXITCODE -ne 0) {
-        Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian configure for $tool failed with exit code $LASTEXITCODE."
-        ExitWithExitCode $LASTEXITCODE
-      }
-    }
-    if ($tool -eq 'policheck') {
-      Write-Host "$GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args `" Target < $TargetDirectory `" $(If ($PoliCheckAdditionalRunConfigParams) {$PoliCheckAdditionalRunConfigParams})"
-      & $GuardianCliLocation configure --working-directory $WorkingDirectory --tool $tool --output-path $gdnConfigFile --logger-level $GuardianLoggerLevel --noninteractive --force --args " Target < $TargetDirectory " $(If ($PoliCheckAdditionalRunConfigParams) {$PoliCheckAdditionalRunConfigParams})
-      if ($LASTEXITCODE -ne 0) {
-        Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian configure for $tool failed with exit code $LASTEXITCODE."
-        ExitWithExitCode $LASTEXITCODE
-      }
-    }
-
-    $configParam+=$gdnConfigFile
-  }
-
-  Write-Host "$GuardianCliLocation run --working-directory $WorkingDirectory --baseline mainbaseline --update-baseline $UpdateBaseline --logger-level $GuardianLoggerLevel $configParam"
-  & $GuardianCliLocation run --working-directory $WorkingDirectory --tool $tool --baseline mainbaseline --update-baseline $UpdateBaseline --logger-level $GuardianLoggerLevel $configParam
-  if ($LASTEXITCODE -ne 0) {
-    Write-PipelineTelemetryError -Force -Category 'Sdl' -Message "Guardian run for $ToolsList using $configParam failed with exit code $LASTEXITCODE."
-    ExitWithExitCode $LASTEXITCODE
+  $gdnConfigFiles = Get-ChildItem $gdnConfigPath -Recurse -Include '*.gdnconfig'
+  Write-Host "Discovered Guardian config files:"
+  $gdnConfigFiles | Out-String | Write-Host
+
+  Exec-BlockVerbosely {
+    & $GuardianCliLocation run `
+      --working-directory $WorkingDirectory `
+      --baseline mainbaseline `
+      --update-baseline $UpdateBaseline `
+      --logger-level $GuardianLoggerLevel `
+      --config @gdnConfigFiles
+    Exit-IfNZEC "Sdl"
   }
 }
 catch {
diff --git a/eng/common/templates/job/execute-sdl.yml b/eng/common/templates/job/execute-sdl.yml
index 4a32181fd8f..69eb67849d7 100644
--- a/eng/common/templates/job/execute-sdl.yml
+++ b/eng/common/templates/job/execute-sdl.yml
@@ -2,17 +2,41 @@ parameters:
   enable: 'false'                                             # Whether the SDL validation job should execute or not
   overrideParameters: ''                                       # Optional: to override values for parameters.
   additionalParameters: ''                                     # Optional: parameters that need user specific values eg: '-SourceToolsList @("abc","def") -ArtifactToolsList @("ghi","jkl")'
+  # Optional: if specified, restore and use this version of Guardian instead of the default.
+  overrideGuardianVersion: ''
+  # Optional: if true, publish the '.gdn' folder as a pipeline artifact. This can help with in-depth
+  # diagnosis of problems with specific tool configurations.
+  publishGuardianDirectoryToPipeline: false
+  # The script to run to execute all SDL tools. Use this if you want to use a script to define SDL
+  # parameters rather than relying on YAML. It may be better to use a local script, because you can
+  # reproduce results locally without piecing together a command based on the YAML.
+  executeAllSdlToolsScript: 'eng/common/sdl/execute-all-sdl-tools.ps1'
   # There is some sort of bug (has been reported) in Azure DevOps where if this parameter is named
   # 'continueOnError', the parameter value is not correctly picked up.
   # This can also be remedied by the caller (post-build.yml) if it does not use a nested parameter
   sdlContinueOnError: false                                    # optional: determines whether to continue the build if the step errors;
-  downloadArtifacts: true                                      # optional: determines if the artifacts should be dowloaded
+  # optional: determines if build artifacts should be downloaded.
+  downloadArtifacts: true
+  # optional: determines if this job should search the directory of downloaded artifacts for
+  # 'tar.gz' and 'zip' archive files and extract them before running SDL validation tasks.
+  extractArchiveArtifacts: false
   dependsOn: ''                                                # Optional: dependencies of the job
   artifactNames: ''                                            # Optional: patterns supplied to DownloadBuildArtifacts
                                                                # Usage:
                                                                #  artifactNames:
                                                                #    - 'BlobArtifacts'
                                                                #    - 'Artifacts_Windows_NT_Release'
+  # Optional: download a list of pipeline artifacts. 'downloadArtifacts' controls build artifacts,
+  # not pipeline artifacts, so doesn't affect the use of this parameter.
+  pipelineArtifactNames: []
+  # Optional: location and ID of the AzDO build that the build/pipeline artifacts should be
+  # downloaded from. By default, uses runtime expressions to decide based on the variables set by
+  # the 'setupMaestroVars' dependency. Overriding this parameter is necessary if SDL tasks are
+  # running without Maestro++/BAR involved, or to download artifacts from a specific existing build
+  # to iterate quickly on SDL changes.
+  AzDOProjectName: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+  AzDOPipelineId: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+  AzDOBuildId: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
 
 jobs:
 - job: Run_SDL
@@ -22,16 +46,29 @@ jobs:
   variables:
     - group: DotNet-VSTS-Bot
     - name: AzDOProjectName
-      value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOProjectName'] ]
+      value: ${{ parameters.AzDOProjectName }}
     - name: AzDOPipelineId
-      value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOPipelineId'] ]
+      value: ${{ parameters.AzDOPipelineId }}
     - name: AzDOBuildId
-      value: $[ dependencies.setupMaestroVars.outputs['setReleaseVars.AzDOBuildId'] ]
+      value: ${{ parameters.AzDOBuildId }}
+    # The Guardian version specified in 'eng/common/sdl/packages.config'. This value must be kept in
+    # sync with the packages.config file.
+    - name: DefaultGuardianVersion
+      value: 0.53.3
+    - name: GuardianVersion
+      value: ${{ coalesce(parameters.overrideGuardianVersion, '$(DefaultGuardianVersion)') }}
+    - name: GuardianPackagesConfigFile
+      value: $(Build.SourcesDirectory)\eng\common\sdl\packages.config
   pool:
-    name: Hosted VS2017
+    # To extract archives (.tar.gz, .zip), we need access to "tar", added in Windows 10/2019.
+    ${{ if eq(parameters.extractArchiveArtifacts, 'false') }}:
+      name: Hosted VS2017
+    ${{ if ne(parameters.extractArchiveArtifacts, 'false') }}:
+      vmImage: windows-2019
   steps:
   - checkout: self
     clean: true
+
   - ${{ if ne(parameters.downloadArtifacts, 'false')}}:
     - ${{ if ne(parameters.artifactNames, '') }}:
       - ${{ each artifactName in parameters.artifactNames }}:
@@ -59,16 +96,51 @@ jobs:
           itemPattern: "**"
           downloadPath: $(Build.ArtifactStagingDirectory)\artifacts
           checkDownloadedFiles: true
+
+  - ${{ each artifactName in parameters.pipelineArtifactNames }}:
+    - task: DownloadPipelineArtifact@2
+      displayName: Download Pipeline Artifacts
+      inputs:
+        buildType: specific
+        buildVersionToDownload: specific
+        project: $(AzDOProjectName)
+        pipeline: $(AzDOPipelineId)
+        buildId: $(AzDOBuildId)
+        artifactName: ${{ artifactName }}
+        downloadPath: $(Build.ArtifactStagingDirectory)\artifacts
+        checkDownloadedFiles: true
+
   - powershell: eng/common/sdl/extract-artifact-packages.ps1
       -InputPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
       -ExtractPath $(Build.ArtifactStagingDirectory)\artifacts\BlobArtifacts
     displayName: Extract Blob Artifacts
     continueOnError: ${{ parameters.sdlContinueOnError }}
+
   - powershell: eng/common/sdl/extract-artifact-packages.ps1
       -InputPath $(Build.ArtifactStagingDirectory)\artifacts\PackageArtifacts
       -ExtractPath $(Build.ArtifactStagingDirectory)\artifacts\PackageArtifacts
     displayName: Extract Package Artifacts
     continueOnError: ${{ parameters.sdlContinueOnError }}
+
+  - ${{ if ne(parameters.extractArchiveArtifacts, 'false') }}:
+    - powershell: eng/common/sdl/extract-artifact-archives.ps1
+        -InputPath $(Build.ArtifactStagingDirectory)\artifacts
+        -ExtractPath $(Build.ArtifactStagingDirectory)\artifacts
+      displayName: Extract Archive Artifacts
+      continueOnError: ${{ parameters.sdlContinueOnError }}
+  
+  - ${{ if ne(parameters.overrideGuardianVersion, '') }}:
+    - powershell: |
+        $content = Get-Content $(GuardianPackagesConfigFile)
+
+        Write-Host "packages.config content was:`n$content"
+
+        $content = $content.Replace('$(DefaultGuardianVersion)', '$(GuardianVersion)')
+        $content | Set-Content $(GuardianPackagesConfigFile)
+
+        Write-Host "packages.config content updated to:`n$content"
+      displayName: Use overridden Guardian version ${{ parameters.overrideGuardianVersion }}
+
   - task: NuGetToolInstaller@1
     displayName: 'Install NuGet.exe'
   - task: NuGetCommand@2
@@ -79,15 +151,35 @@ jobs:
       nugetConfigPath: $(Build.SourcesDirectory)\eng\common\sdl\NuGet.config
       externalFeedCredentials: GuardianConnect
       restoreDirectory: $(Build.SourcesDirectory)\.packages
+
   - ${{ if ne(parameters.overrideParameters, '') }}:
-    - powershell: eng/common/sdl/execute-all-sdl-tools.ps1 ${{ parameters.overrideParameters }}
+    - powershell: ${{ parameters.executeAllSdlToolsScript }} ${{ parameters.overrideParameters }}
       displayName: Execute SDL
       continueOnError: ${{ parameters.sdlContinueOnError }}
   - ${{ if eq(parameters.overrideParameters, '') }}:
-    - powershell: eng/common/sdl/execute-all-sdl-tools.ps1
-        -GuardianPackageName Microsoft.Guardian.Cli.0.53.3
+    - powershell: ${{ parameters.executeAllSdlToolsScript }}
+        -GuardianPackageName Microsoft.Guardian.Cli.$(GuardianVersion)
         -NugetPackageDirectory $(Build.SourcesDirectory)\.packages
         -AzureDevOpsAccessToken $(dn-bot-dotnet-build-rw-code-rw)
         ${{ parameters.additionalParameters }}
       displayName: Execute SDL
       continueOnError: ${{ parameters.sdlContinueOnError }}
+
+  - ${{ if ne(parameters.publishGuardianDirectoryToPipeline, 'false') }}:
+    # We want to publish the Guardian results and configuration for easy diagnosis. However, the
+    # '.gdn' dir is a mix of configuration, results, extracted dependencies, and Guardian default
+    # tooling files. Some of these files are large and aren't useful during an investigation, so
+    # exclude them by simply deleting them before publishing. (As of writing, there is no documented
+    # way to selectively exclude a dir from the pipeline artifact publish task.)
+    - task: DeleteFiles@1
+      displayName: Delete Guardian dependencies to avoid uploading
+      inputs:
+        SourceFolder: $(Agent.BuildDirectory)/.gdn
+        Contents: |
+          c
+          i
+      condition: succeededOrFailed()
+    - publish: $(Agent.BuildDirectory)/.gdn
+      artifact: GuardianConfiguration
+      displayName: Publish GuardianConfiguration
+      condition: succeededOrFailed()
diff --git a/eng/common/templates/job/onelocbuild.yml b/eng/common/templates/job/onelocbuild.yml
index 2acdd5256dd..e8bc77d2ebb 100644
--- a/eng/common/templates/job/onelocbuild.yml
+++ b/eng/common/templates/job/onelocbuild.yml
@@ -18,6 +18,9 @@ parameters:
   LclSource: lclFilesInRepo
   LclPackageId: ''
   RepoType: gitHub
+  GitHubOrg: dotnet
+  MirrorRepo: ''
+  MirrorBranch: main
   condition: ''
 
 jobs:
@@ -66,6 +69,11 @@ jobs:
         ${{ if eq(parameters.RepoType, 'gitHub') }}:
           repoType: ${{ parameters.RepoType }}
           gitHubPatVariable: "${{ parameters.GithubPat }}"
+        ${{ if ne(parameters.MirrorRepo, '') }}:
+          isMirrorRepoSelected: true
+          gitHubOrganization: ${{ parameters.GitHubOrg }}
+          mirrorRepo: ${{ parameters.MirrorRepo }}
+          mirrorBranch: ${{ parameters.MirrorBranch }}
       condition: ${{ parameters.condition }}
 
     - task: PublishBuildArtifacts@1
diff --git a/eng/common/templates/job/source-index-stage1.yml b/eng/common/templates/job/source-index-stage1.yml
index a649d2b5990..b58d42364b9 100644
--- a/eng/common/templates/job/source-index-stage1.yml
+++ b/eng/common/templates/job/source-index-stage1.yml
@@ -1,15 +1,19 @@
 parameters:
   runAsPublic: false
-  sourceIndexPackageVersion: 1.0.1-20210421.1
+  sourceIndexPackageVersion: 1.0.1-20210614.1
   sourceIndexPackageSource: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json
   sourceIndexBuildCommand: powershell -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "eng/common/build.ps1 -restore -build -binarylog -ci"
   preSteps: []
   binlogPath: artifacts/log/Debug/Build.binlog
   pool:
     vmImage: vs2017-win2016
+  condition: ''
+  dependsOn: ''
 
 jobs:
 - job: SourceIndexStage1
+  dependsOn: ${{ parameters.dependsOn }}
+  condition: ${{ parameters.condition }}
   variables:
   - name: SourceIndexPackageVersion
     value: ${{ parameters.sourceIndexPackageVersion }}
diff --git a/eng/common/templates/steps/source-build.yml b/eng/common/templates/steps/source-build.yml
index e20637ed6a1..705b7a1c847 100644
--- a/eng/common/templates/steps/source-build.yml
+++ b/eng/common/templates/steps/source-build.yml
@@ -29,6 +29,11 @@ steps:
       officialBuildArgs='/p:DotNetPublishUsingPipelines=true /p:OfficialBuildId=$(BUILD.BUILDNUMBER)'
     fi
 
+    internalRuntimeDownloadArgs=
+    if [ '$(dotnetclimsrc-read-sas-token-base64)' != '$''(dotnetclimsrc-read-sas-token-base64)' ]; then
+      internalRuntimeDownloadArgs='--runtimesourcefeed https://dotnetclimsrc.blob.core.windows.net/dotnet --runtimesourcefeedkey $(dotnetclimsrc-read-sas-token-base64)'
+    fi
+
     targetRidArgs=
     if [ '${{ parameters.platform.targetRID }}' != '' ]; then
       targetRidArgs='/p:TargetRid=${{ parameters.platform.targetRID }}'
@@ -43,6 +48,7 @@ steps:
       --configuration $buildConfig \
       --restore --build --pack $publishArgs -bl \
       $officialBuildArgs \
+      $internalRuntimeDownloadArgs \
       $targetRidArgs \
       /p:SourceBuildNonPortable=${{ parameters.platform.nonPortable }} \
       /p:ArcadeBuildFromSource=true
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 2d8a74f7d9e..5d526c74d51 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -42,7 +42,7 @@
 [bool]$useInstalledDotNetCli = if (Test-Path variable:useInstalledDotNetCli) { $useInstalledDotNetCli } else { $true }
 
 # Enable repos to use a particular version of the on-line dotnet-install scripts.
-#    default URL: https://dot.net/v1/dotnet-install.ps1
+#    default URL: https://dotnet.microsoft.com/download/dotnet/scripts/v1/dotnet-install.ps1
 [string]$dotnetInstallScriptVersion = if (Test-Path variable:dotnetInstallScriptVersion) { $dotnetInstallScriptVersion } else { 'v1' }
 
 # True to use global NuGet cache instead of restoring packages to repository-local directory.
@@ -106,6 +106,46 @@ function Exec-Process([string]$command, [string]$commandArgs) {
   }
 }
 
+# Take the given block, print it, print what the block probably references from the current set of
+# variables using low-effort string matching, then run the block.
+#
+# This is intended to replace the pattern of manually copy-pasting a command, wrapping it in quotes,
+# and printing it using "Write-Host". The copy-paste method is more readable in build logs, but less
+# maintainable and less reliable. It is easy to make a mistake and modify the command without
+# properly updating the "Write-Host" line, resulting in misleading build logs. The probability of
+# this mistake makes the pattern hard to trust when it shows up in build logs. Finding the bug in
+# existing source code can also be difficult, because the strings are not aligned to each other and
+# the line may be 300+ columns long.
+#
+# By removing the need to maintain two copies of the command, Exec-BlockVerbosely avoids the issues.
+#
+# In Bash (or any posix-like shell), "set -x" prints usable verbose output automatically.
+# "Set-PSDebug" appears to be similar at first glance, but unfortunately, it isn't very useful: it
+# doesn't print any info about the variables being used by the command, which is normally the
+# interesting part to diagnose.
+function Exec-BlockVerbosely([scriptblock] $block) {
+  Write-Host "--- Running script block:"
+  $blockString = $block.ToString().Trim()
+  Write-Host $blockString
+
+  Write-Host "--- List of variables that might be used:"
+  # For each variable x in the environment, check the block for a reference to x via simple "$x" or
+  # "@x" syntax. This doesn't detect other ways to reference variables ("${x}" nor "$variable:x",
+  # among others). It only catches what this function was originally written for: simple
+  # command-line commands.
+  $variableTable = Get-Variable |
+    Where-Object {
+      $blockString.Contains("`$$($_.Name)") -or $blockString.Contains("@$($_.Name)")
+    } |
+    Format-Table -AutoSize -HideTableHeaders -Wrap |
+    Out-String
+  Write-Host $variableTable.Trim()
+
+  Write-Host "--- Executing:"
+  & $block
+  Write-Host "--- Done running script block!"
+}
+
 # createSdkLocationFile parameter enables a file being generated under the toolset directory
 # which writes the sdk's location into. This is only necessary for cmd --> powershell invocations
 # as dot sourcing isn't possible.
@@ -193,38 +233,42 @@ function InitializeDotNetCli([bool]$install, [bool]$createSdkLocationFile) {
   return $global:_DotNetInstallDir = $dotnetRoot
 }
 
+function Retry($downloadBlock, $maxRetries = 5) {
+  $retries = 1
+
+  while($true) {
+    try {
+      & $downloadBlock
+      break
+    }
+    catch {
+      Write-PipelineTelemetryError -Category 'InitializeToolset' -Message $_
+    }
+
+    if (++$retries -le $maxRetries) {
+      $delayInSeconds = [math]::Pow(2, $retries) - 1 # Exponential backoff
+      Write-Host "Retrying. Waiting for $delayInSeconds seconds before next attempt ($retries of $maxRetries)."
+      Start-Sleep -Seconds $delayInSeconds
+    }
+    else {
+      Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Unable to download file in $maxRetries attempts."
+      break
+    }
+
+  }
+}
+
 function GetDotNetInstallScript([string] $dotnetRoot) {
   $installScript = Join-Path $dotnetRoot 'dotnet-install.ps1'
   if (!(Test-Path $installScript)) {
     Create-Directory $dotnetRoot
     $ProgressPreference = 'SilentlyContinue' # Don't display the console progress UI - it's a huge perf hit
+    $uri = "https://dotnet.microsoft.com/download/dotnet/scripts/$dotnetInstallScriptVersion/dotnet-install.ps1"
 
-    $maxRetries = 5
-    $retries = 1
-
-    $uri = "https://dot.net/$dotnetInstallScriptVersion/dotnet-install.ps1"
-
-    while($true) {
-      try {
-        Write-Host "GET $uri"
-        Invoke-WebRequest $uri -OutFile $installScript
-        break
-      }
-      catch {
-        Write-Host "Failed to download '$uri'"
-        Write-Error $_.Exception.Message -ErrorAction Continue
-      }
-
-      if (++$retries -le $maxRetries) {
-        $delayInSeconds = [math]::Pow(2, $retries) - 1 # Exponential backoff
-        Write-Host "Retrying. Waiting for $delayInSeconds seconds before next attempt ($retries of $maxRetries)."
-        Start-Sleep -Seconds $delayInSeconds
-      }
-      else {
-        throw "Unable to download file in $maxRetries attempts."
-      }
-
-    }
+    Retry({
+      Write-Host "GET $uri"
+      Invoke-WebRequest $uri -OutFile $installScript
+    })
   }
 
   return $installScript
@@ -308,8 +352,8 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
 
   # If the version of msbuild is going to be xcopied,
   # use this version. Version matches a package here:
-  # https://dev.azure.com/dnceng/public/_packaging?_a=package&feed=dotnet-eng&package=RoslynTools.MSBuild&protocolType=NuGet&version=16.8.0-preview3&view=overview
-  $defaultXCopyMSBuildVersion = '16.8.0-preview3'
+  # https://dev.azure.com/dnceng/public/_packaging?_a=package&feed=dotnet-eng&package=RoslynTools.MSBuild&protocolType=NuGet&version=16.10.0-preview2&view=overview
+  $defaultXCopyMSBuildVersion = '16.10.0-preview2'
 
   if (!$vsRequirements) { $vsRequirements = $GlobalJson.tools.vs }
   $vsMinVersionStr = if ($vsRequirements.version) { $vsRequirements.version } else { $vsMinVersionReqdStr }
@@ -374,7 +418,16 @@ function InitializeVisualStudioMSBuild([bool]$install, [object]$vsRequirements =
   }
 
   $msbuildVersionDir = if ([int]$vsMajorVersion -lt 16) { "$vsMajorVersion.0" } else { "Current" }
-  return $global:_MSBuildExe = Join-Path $vsInstallDir "MSBuild\$msbuildVersionDir\Bin\msbuild.exe"
+
+  $local:BinFolder = Join-Path $vsInstallDir "MSBuild\$msbuildVersionDir\Bin"
+  $local:Prefer64bit = if (Get-Member -InputObject $vsRequirements -Name 'Prefer64bit') { $vsRequirements.Prefer64bit } else { $false }
+  if ($local:Prefer64bit -and (Test-Path(Join-Path $local:BinFolder "amd64"))) {
+    $global:_MSBuildExe = Join-Path $local:BinFolder "amd64\msbuild.exe"
+  } else {
+    $global:_MSBuildExe = Join-Path $local:BinFolder "msbuild.exe"
+  }
+
+  return $global:_MSBuildExe
 }
 
 function InitializeVisualStudioEnvironmentVariables([string] $vsInstallDir, [string] $vsMajorVersion) {
@@ -403,9 +456,13 @@ function InitializeXCopyMSBuild([string]$packageVersion, [bool]$install) {
     }
 
     Create-Directory $packageDir
+
     Write-Host "Downloading $packageName $packageVersion"
     $ProgressPreference = 'SilentlyContinue' # Don't display the console progress UI - it's a huge perf hit
-    Invoke-WebRequest "https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/flat2/$packageName/$packageVersion/$packageName.$packageVersion.nupkg" -OutFile $packagePath
+    Retry({
+      Invoke-WebRequest "https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-eng/nuget/v3/flat2/$packageName/$packageVersion/$packageName.$packageVersion.nupkg" -OutFile $packagePath
+    })
+
     Unzip $packagePath $packageDir
   }
 
@@ -442,27 +499,9 @@ function LocateVisualStudio([object]$vsRequirements = $null){
   if (!(Test-Path $vsWhereExe)) {
     Create-Directory $vsWhereDir
     Write-Host 'Downloading vswhere'
-    $maxRetries = 5
-    $retries = 1
-
-    while($true) {
-      try {
-        Invoke-WebRequest "https://netcorenativeassets.blob.core.windows.net/resource-packages/external/windows/vswhere/$vswhereVersion/vswhere.exe" -OutFile $vswhereExe
-        break
-      }
-      catch{
-        Write-PipelineTelemetryError -Category 'InitializeToolset' -Message $_
-      }
-
-      if (++$retries -le $maxRetries) {
-        $delayInSeconds = [math]::Pow(2, $retries) - 1 # Exponential backoff
-        Write-Host "Retrying. Waiting for $delayInSeconds seconds before next attempt ($retries of $maxRetries)."
-        Start-Sleep -Seconds $delayInSeconds
-      }
-      else {
-        Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "Unable to download file in $maxRetries attempts."
-      }
-    }
+    Retry({
+      Invoke-WebRequest "https://netcorenativeassets.blob.core.windows.net/resource-packages/external/windows/vswhere/$vswhereVersion/vswhere.exe" -OutFile $vswhereExe
+    })
   }
 
   if (!$vsRequirements) { $vsRequirements = $GlobalJson.tools.vs }
@@ -498,7 +537,7 @@ function InitializeBuildTool() {
   if (Test-Path variable:global:_BuildTool) {
     # If the requested msbuild parameters do not match, clear the cached variables.
     if($global:_BuildTool.Contains('ExcludePrereleaseVS') -and $global:_BuildTool.ExcludePrereleaseVS -ne $excludePrereleaseVS) {
-      Remove-Item variable:global:_BuildTool 
+      Remove-Item variable:global:_BuildTool
       Remove-Item variable:global:_MSBuildExe
     } else {
       return $global:_BuildTool
@@ -555,7 +594,7 @@ function GetDefaultMSBuildEngine() {
 
 function GetNuGetPackageCachePath() {
   if ($env:NUGET_PACKAGES -eq $null) {
-    # Use local cache on CI to ensure deterministic build. 
+    # Use local cache on CI to ensure deterministic build.
     # Avoid using the http cache as workaround for https://github.com/NuGet/Home/issues/3116
     # use global cache in dev builds to avoid cost of downloading packages.
     # For directory normalization, see also: https://github.com/NuGet/Home/issues/7968
@@ -633,6 +672,17 @@ function ExitWithExitCode([int] $exitCode) {
   exit $exitCode
 }
 
+# Check if $LASTEXITCODE is a nonzero exit code (NZEC). If so, print a Azure Pipeline error for
+# diagnostics, then exit the script with the $LASTEXITCODE.
+function Exit-IfNZEC([string] $category = "General") {
+  Write-Host "Exit code $LASTEXITCODE"
+  if ($LASTEXITCODE -ne 0) {
+    $message = "Last command failed with exit code $LASTEXITCODE."
+    Write-PipelineTelemetryError -Force -Category $category -Message $message
+    ExitWithExitCode $LASTEXITCODE
+  }
+}
+
 function Stop-Processes() {
   Write-Host 'Killing running build processes...'
   foreach ($processName in $processesToStopOnExit) {
@@ -712,7 +762,10 @@ function MSBuild-Core() {
   }
 
   foreach ($arg in $args) {
-    if ($arg -ne $null -and $arg.Trim() -ne "") {
+    if ($null -ne $arg -and $arg.Trim() -ne "") {
+      if ($arg.EndsWith('\')) {
+        $arg = $arg + "\"
+      }
       $cmdArgs += " `"$arg`""
     }
   }
@@ -784,7 +837,7 @@ function Get-Darc($version) {
 
 . $PSScriptRoot\pipeline-logging-functions.ps1
 
-$RepoRoot = Resolve-Path (Join-Path $PSScriptRoot '..\..')
+$RepoRoot = Resolve-Path (Join-Path $PSScriptRoot '..\..\')
 $EngRoot = Resolve-Path (Join-Path $PSScriptRoot '..')
 $ArtifactsDir = Join-Path $RepoRoot 'artifacts'
 $ToolsetDir = Join-Path $ArtifactsDir 'toolset'
diff --git a/eng/common/tools.sh b/eng/common/tools.sh
index 5fad1846e5a..828119be411 100755
--- a/eng/common/tools.sh
+++ b/eng/common/tools.sh
@@ -54,7 +54,7 @@ warn_as_error=${warn_as_error:-true}
 use_installed_dotnet_cli=${use_installed_dotnet_cli:-true}
 
 # Enable repos to use a particular version of the on-line dotnet-install scripts.
-#    default URL: https://dot.net/v1/dotnet-install.sh
+#    default URL: https://dotnet.microsoft.com/download/dotnet/scripts/v1/dotnet-install.sh
 dotnetInstallScriptVersion=${dotnetInstallScriptVersion:-'v1'}
 
 # True to use global NuGet cache instead of restoring packages to repository-local directory.
@@ -262,7 +262,7 @@ function with_retries {
 function GetDotNetInstallScript {
   local root=$1
   local install_script="$root/dotnet-install.sh"
-  local install_script_url="https://dot.net/$dotnetInstallScriptVersion/dotnet-install.sh"
+  local install_script_url="https://dotnet.microsoft.com/download/dotnet/scripts/$dotnetInstallScriptVersion/dotnet-install.sh"
 
   if [[ ! -a "$install_script" ]]; then
     mkdir -p "$root"
@@ -485,13 +485,14 @@ _script_dir=`dirname "$_ResolvePath"`
 
 eng_root=`cd -P "$_script_dir/.." && pwd`
 repo_root=`cd -P "$_script_dir/../.." && pwd`
-artifacts_dir="$repo_root/artifacts"
+repo_root="${repo_root}/"
+artifacts_dir="${repo_root}artifacts"
 toolset_dir="$artifacts_dir/toolset"
-tools_dir="$repo_root/.tools"
+tools_dir="${repo_root}.tools"
 log_dir="$artifacts_dir/log/$configuration"
 temp_dir="$artifacts_dir/tmp/$configuration"
 
-global_json_file="$repo_root/global.json"
+global_json_file="${repo_root}global.json"
 # determine if global.json contains a "runtimes" entry
 global_json_has_runtimes=false
 if command -v jq &> /dev/null; then
@@ -504,7 +505,7 @@ fi
 
 # HOME may not be defined in some scenarios, but it is required by NuGet
 if [[ -z $HOME ]]; then
-  export HOME="$repo_root/artifacts/.home/"
+  export HOME="${repo_root}artifacts/.home/"
   mkdir -p "$HOME"
 fi
 
diff --git a/global.json b/global.json
index 2a0e889f040..3dc6a657bbb 100644
--- a/global.json
+++ b/global.json
@@ -3,7 +3,7 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "6.0.100-preview.3.21202.5",
+    "dotnet": "6.0.100-preview.6.21355.2",
     "runtimes": {
       "dotnet/x64": [
         "2.1.7"
@@ -15,6 +15,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21304.1"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21379.2"
   }
 }
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index a75f66a8753..fb2f2bd0733 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -152,6 +152,13 @@ protected CustomBuildEventArgs(string message, string helpKeyword, string sender
         protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
     }
     public delegate void CustomBuildEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e);
+    public abstract partial class EngineServices
+    {
+        public const int Version1 = 1;
+        protected EngineServices() { }
+        public virtual int Version { get { throw null; } }
+        public virtual bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
+    }
     public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public EnvironmentVariableReadEventArgs() { }
@@ -186,6 +193,10 @@ public partial interface IBuildEngine
         void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e);
         void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e);
     }
+    public partial interface IBuildEngine10 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8, Microsoft.Build.Framework.IBuildEngine9
+    {
+        Microsoft.Build.Framework.EngineServices EngineServices { get; }
+    }
     public partial interface IBuildEngine2 : Microsoft.Build.Framework.IBuildEngine
     {
         bool IsRunningMultipleNodes { get; }
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index b4eefc32fab..98e39ce8b4c 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -152,6 +152,13 @@ protected CustomBuildEventArgs(string message, string helpKeyword, string sender
         protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
     }
     public delegate void CustomBuildEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e);
+    public abstract partial class EngineServices
+    {
+        public const int Version1 = 1;
+        protected EngineServices() { }
+        public virtual int Version { get { throw null; } }
+        public virtual bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
+    }
     public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
     {
         public EnvironmentVariableReadEventArgs() { }
@@ -186,6 +193,10 @@ public partial interface IBuildEngine
         void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e);
         void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e);
     }
+    public partial interface IBuildEngine10 : Microsoft.Build.Framework.IBuildEngine, Microsoft.Build.Framework.IBuildEngine2, Microsoft.Build.Framework.IBuildEngine3, Microsoft.Build.Framework.IBuildEngine4, Microsoft.Build.Framework.IBuildEngine5, Microsoft.Build.Framework.IBuildEngine6, Microsoft.Build.Framework.IBuildEngine7, Microsoft.Build.Framework.IBuildEngine8, Microsoft.Build.Framework.IBuildEngine9
+    {
+        Microsoft.Build.Framework.EngineServices EngineServices { get; }
+    }
     public partial interface IBuildEngine2 : Microsoft.Build.Framework.IBuildEngine
     {
         bool IsRunningMultipleNodes { get; }
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index c94de3e3688..bbd015301c6 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -207,6 +207,8 @@ public Copy() { }
         public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
         public bool UseHardlinksIfPossible { get { throw null; } set { } }
         public bool UseSymboliclinksIfPossible { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public bool WroteAtLeastOneFile { get { throw null; } }
         public void Cancel() { }
         public override bool Execute() { throw null; }
     }
@@ -611,6 +613,18 @@ public GetAssemblyIdentity() { }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class GetCompatiblePlatform : Microsoft.Build.Tasks.TaskExtension
+    {
+        public GetCompatiblePlatform() { }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] AnnotatedProjects { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] AssignedProjectsWithPlatform { get { throw null; } set { } }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public string CurrentProjectPlatform { get { throw null; } set { } }
+        public string PlatformLookupTable { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public sealed partial class GetFileHash : Microsoft.Build.Tasks.TaskExtension
     {
         public GetFileHash() { }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 27ba53105be..197ce5ff14b 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -137,6 +137,8 @@ public Copy() { }
         public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
         public bool UseHardlinksIfPossible { get { throw null; } set { } }
         public bool UseSymboliclinksIfPossible { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public bool WroteAtLeastOneFile { get { throw null; } }
         public void Cancel() { }
         public override bool Execute() { throw null; }
     }
@@ -504,6 +506,18 @@ public GetAssemblyIdentity() { }
         public Microsoft.Build.Framework.ITaskItem[] AssemblyFiles { get { throw null; } set { } }
         public override bool Execute() { throw null; }
     }
+    public partial class GetCompatiblePlatform : Microsoft.Build.Tasks.TaskExtension
+    {
+        public GetCompatiblePlatform() { }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] AnnotatedProjects { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public Microsoft.Build.Framework.ITaskItem[] AssignedProjectsWithPlatform { get { throw null; } set { } }
+        [Microsoft.Build.Framework.RequiredAttribute]
+        public string CurrentProjectPlatform { get { throw null; } set { } }
+        public string PlatformLookupTable { get { throw null; } set { } }
+        public override bool Execute() { throw null; }
+    }
     public sealed partial class GetFileHash : Microsoft.Build.Tasks.TaskExtension
     {
         public GetFileHash() { }
diff --git a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
index 25d9b341e72..a9f91065f53 100644
--- a/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/net/Microsoft.Build.Utilities.Core.cs
@@ -423,6 +423,7 @@ public void LogMessageFromResources(string messageResourceName, params object[]
         public bool LogMessagesFromFile(string fileName) { throw null; }
         public bool LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
         public bool LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
+        public bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
         public void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) { }
         public void LogWarning(string message, params object[] messageArgs) { }
         public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
diff --git a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
index 3fbc85bcf6e..26fb8b5075c 100644
--- a/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
+++ b/ref/Microsoft.Build.Utilities.Core/netstandard/Microsoft.Build.Utilities.Core.cs
@@ -265,6 +265,7 @@ public void LogMessageFromResources(string messageResourceName, params object[]
         public bool LogMessagesFromFile(string fileName) { throw null; }
         public bool LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
         public bool LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) { throw null; }
+        public bool LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) { throw null; }
         public void LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) { }
         public void LogWarning(string message, params object[] messageArgs) { }
         public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) { }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index ae7b4abd563..07b58d1f82d 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -11,13 +11,18 @@ Param(
 Set-StrictMode -Version "Latest"
 $ErrorActionPreference = "Stop"
 
-function Copy-WithBackup ($origin) {
-    $directoryPart = Join-Path -Path $destination $origin.IntermediaryDirectories 
+function Copy-WithBackup ($origin, $destinationSubFolder = "") {
+    $directoryPart = [IO.Path]::Combine($destination, $destinationSubFolder, $origin.IntermediaryDirectories)
     $destinationPath = Join-Path -Path $directoryPart (Split-Path $origin.SourceFile -leaf)
 
+    $backupInto = [IO.Path]::Combine($BackupFolder, $destinationSubFolder)
+
     if (Test-Path $destinationPath -PathType Leaf) {
         # Back up previous copy of the file
-        Copy-Item $destinationPath $BackupFolder -ErrorAction Stop
+        if (!(Test-Path $backupInto)) {
+            [system.io.directory]::CreateDirectory($backupInto)
+        }
+        Copy-Item $destinationPath $backupInto -ErrorAction Stop
     }
 
     if (!(Test-Path $directoryPart)) {
@@ -60,19 +65,6 @@ $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.Utilities.Core.dll"
     FileToCopy "$bootstrapBinDirectory\Microsoft.NET.StringTools.dll"
 
-    FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Buffers.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Collections.Immutable.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Memory.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Numerics.Vectors.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Resources.Extensions.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Runtime.CompilerServices.Unsafe.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Text.Encodings.Web.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Text.Json.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Dataflow.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Extensions.dll"
-    FileToCopy "$bootstrapBinDirectory\System.ValueTuple.dll"
-
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.resources.dll" "en"
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.Tasks.Core.resources.dll" "en"
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.Utilities.Core.resources.dll" "en"
@@ -95,18 +87,16 @@ $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.VisualBasic.CrossTargeting.targets"
     FileToCopy "$bootstrapBinDirectory\Microsoft.VisualBasic.CurrentVersion.targets"
     FileToCopy "$bootstrapBinDirectory\Microsoft.VisualBasic.targets"
+
+    FileToCopy "$bootstrapBinDirectory\Microsoft.Common.tasks"
 )
 
 if ($runtime -eq "Desktop") {
     $runtimeSpecificFiles = @(
-        FileToCopy "$bootstrapBinDirectory\MSBuild.exe"
-        FileToCopy "$bootstrapBinDirectory\MSBuild.exe.config"
         FileToCopy "artifacts\bin\Microsoft.Build.Conversion\$configuration\$targetFramework\Microsoft.Build.Conversion.Core.dll"
         FileToCopy "artifacts\bin\Microsoft.Build.Engine\$configuration\$targetFramework\Microsoft.Build.Engine.dll"
 
-        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.exe"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.pdb"
-
+        FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.Data.Entity.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.ServiceModel.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.WinFx.targets"
@@ -114,6 +104,18 @@ if ($runtime -eq "Desktop") {
         FileToCopy "$bootstrapBinDirectory\Microsoft.Xaml.targets"
         FileToCopy "$bootstrapBinDirectory\Workflow.targets"
         FileToCopy "$bootstrapBinDirectory\Workflow.VisualBasic.targets"
+
+        FileToCopy "$bootstrapBinDirectory\System.Buffers.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Collections.Immutable.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Memory.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Numerics.Vectors.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Resources.Extensions.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Runtime.CompilerServices.Unsafe.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Text.Encodings.Web.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Text.Json.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Dataflow.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Extensions.dll"
+        FileToCopy "$bootstrapBinDirectory\System.ValueTuple.dll"    
     )
 } else {
     $runtimeSpecificFiles = @(
@@ -121,11 +123,40 @@ if ($runtime -eq "Desktop") {
     )
 }
 
+if ($runtime -eq "Desktop") {
+    $x86files = @(
+        FileToCopy "$bootstrapBinDirectory\MSBuild.exe"
+        FileToCopy "$bootstrapBinDirectory\MSBuild.exe.config"
+        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.exe"
+        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.pdb"
+    )
+    $amd64files = @(
+        FileToCopy "artifacts\bin\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe"
+        FileToCopy "artifacts\bin\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe.config"
+        FileToCopy "artifacts\bin\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.exe"
+        FileToCopy "artifacts\bin\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.pdb"
+    )
+}
+
 $filesToCopyToBin += $runtimeSpecificFiles
 
 foreach ($file in $filesToCopyToBin) {
     Copy-WithBackup $file
 }
 
+if ($runtime -eq "Desktop") {
+    foreach ($file in $x86files) {
+        Copy-WithBackup $file
+    }
+
+    foreach ($file in $filesToCopyToBin) {
+        Copy-WithBackup $file "amd64"
+    }
+
+    foreach ($file in $amd64files) {
+        Copy-WithBackup $file "amd64"
+    }
+}
+
 Write-Host -ForegroundColor Green "Copy succeeded"
 Write-Verbose "Run $destination\MSBuild.exe"
diff --git a/scripts/EnumerateMSBuild.ps1 b/scripts/EnumerateMSBuild.ps1
index d8ac8f262e6..115cdd8f108 100644
--- a/scripts/EnumerateMSBuild.ps1
+++ b/scripts/EnumerateMSBuild.ps1
@@ -33,7 +33,7 @@ foreach ($instance in $vsInstances)
     $instancePath = $instance.installationPath
     Write-Log "********************" -LogToConsole $False
     Write-Log "Found VS Instance: $instanceName"
-    
+
     # Look at each dll/exe in the MSBuild bin folder and get their ProductVersion
     ls -File -Recurse -Include ('*.dll', '*.exe') -Path "$instancePath\MSBuild\15.0\Bin" | % VersionInfo | Format-Table -AutoSize InternalName, ProductVersion, FileName | Out-File $logFile -Width 1000 -Append unicode
     ls -File -Recurse -Include ('*.dll', '*.exe') -Path "$instancePath\MSBuild\Current\Bin" | % VersionInfo | Format-Table -AutoSize InternalName, ProductVersion, FileName | Out-File $logFile -Width 1000 -Append unicode
@@ -68,4 +68,4 @@ Write-Log "********************" -LogToConsole $False
 $logFile = Get-ChildItem -File -Path $logFile
 
 Write-Host
-Write-Host "Output saved to $logFile"
\ No newline at end of file
+Write-Host "Output saved to $logFile"
diff --git a/src/BannedSymbols.txt b/src/BannedSymbols.txt
new file mode 100644
index 00000000000..80f588d4b83
--- /dev/null
+++ b/src/BannedSymbols.txt
@@ -0,0 +1 @@
+M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char);CompareInfo.IndexOf can unexpectedly allocate strings--use string.IndexOf
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 8d354afd72e..fb4e9d1afdc 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -395,7 +395,7 @@ public void ValidXmlInvalidSyntaxInChildElement()
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                            <XXX YYY='ZZZ'/>
-                        </ItemGroup> 
+                        </ItemGroup>
                     </Project>
                 ";
 
@@ -416,7 +416,7 @@ public void ValidXmlInvalidSyntaxOpenFromDiskTwice()
                     <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
                         <ItemGroup>
                            <XXX YYY='ZZZ'/>
-                        </ItemGroup> 
+                        </ItemGroup>
                     </Project>
                 ";
 
@@ -1392,7 +1392,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P><!-- new comment -->property value<!-- new comment --></P>
   </PropertyGroup>
-  
+
   <!-- new comment -->
   <ItemGroup>
     <i Include=`a`>
@@ -1412,7 +1412,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P><!-- new comment -->property value<!-- new comment --></P>
   </PropertyGroup>
-  
+
   <!-- new comment -->
   <ItemGroup>
     <i Include=`a`>
@@ -1428,7 +1428,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P><!-- changed comment -->property value<!-- changed comment --></P>
   </PropertyGroup>
-  
+
   <!-- changed comment -->
   <ItemGroup>
     <i Include=`a`>
@@ -1448,7 +1448,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P><!-- new comment -->property value<!-- new comment --></P>
   </PropertyGroup>
-  
+
   <!-- new comment -->
   <ItemGroup>
     <i Include=`a`>
@@ -1463,7 +1463,7 @@ public void ReloadCanSpecifyPreserveFormatting(bool initialPreserveFormatting, b
   <PropertyGroup>
     <P>property value</P>
   </PropertyGroup>
-  
+
   <ItemGroup>
     <i Include=`a`>
       <m>metadata value</m>
@@ -1562,7 +1562,7 @@ public void ReloadedStateIsResilientToChangesAndDiskRoundtrip()
 @"
 <!-- changed comment -->
 <Project xmlns=`msbuildnamespace`>
-  
+
   <!-- changed comment -->
   <ItemGroup>
 
@@ -1580,7 +1580,7 @@ public void ReloadedStateIsResilientToChangesAndDiskRoundtrip()
 @"
 <!-- changed comment -->
 <Project xmlns=`msbuildnamespace`>
-  
+
   <!-- changed comment -->
   <PropertyGroup>
     <P>v</P>
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index a7be71e809a..5323c0fd85e 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -1839,11 +1839,11 @@ public void ChooseWhenTrue()
                             <When Condition='true'>
                               <PropertyGroup>
                                 <p>v1</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i1' />
                               </ItemGroup>
-                            </When>      
+                            </When>
                         </Choose>
                     </Project>
                 ");
@@ -1866,19 +1866,19 @@ public void ChooseSecondWhenTrue()
                             <When Condition='false'>
                               <PropertyGroup>
                                 <p>v1</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i1' />
                               </ItemGroup>
-                            </When>   
+                            </When>
                             <When Condition='true'>
                               <PropertyGroup>
                                 <p>v2</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i2' />
                               </ItemGroup>
-                            </When>    
+                            </When>
                         </Choose>
                     </Project>
                 ");
@@ -1901,19 +1901,19 @@ public void ChooseOtherwise()
                             <When Condition='false'>
                               <PropertyGroup>
                                 <p>v1</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i1' />
                               </ItemGroup>
-                            </When>   
+                            </When>
                             <Otherwise>
                               <PropertyGroup>
                                 <p>v2</p>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                               <ItemGroup>
                                 <i Include='i2' />
                               </ItemGroup>
-                            </Otherwise>    
+                            </Otherwise>
                         </Choose>
                     </Project>
                 ");
@@ -1940,13 +1940,13 @@ public void ChooseTwoPasses()
                               </ItemGroup>
                               <PropertyGroup>
                                 <p>@(i);v1</p>
-                              </PropertyGroup> 
-                            </When>      
+                              </PropertyGroup>
+                            </When>
                         </Choose>
 
                       <PropertyGroup>
                         <p2>v2</p2>
-                      </PropertyGroup> 
+                      </PropertyGroup>
 
                         <Choose>
                             <When Condition='false'/>
@@ -1956,13 +1956,13 @@ public void ChooseTwoPasses()
                               </ItemGroup>
                               <PropertyGroup>
                                 <q>@(j);v1</q>
-                              </PropertyGroup> 
+                              </PropertyGroup>
                             </Otherwise>
                         </Choose>
 
                       <PropertyGroup>
                         <q2>v2</q2>
-                      </PropertyGroup> 
+                      </PropertyGroup>
                     </Project>
                 ");
 
@@ -2019,14 +2019,14 @@ public void ChooseSeesItemDefinitions()
                                   <m>%(m);m1</m>
                                 </i>
                               </ItemGroup>
-                            </When>      
+                            </When>
                         </Choose>
 
                       <ItemDefinitionGroup>
                         <i>
                           <m>m0</m>
                         </i>
-                      </ItemDefinitionGroup> 
+                      </ItemDefinitionGroup>
 
                     </Project>
                 ");
@@ -3078,7 +3078,7 @@ public void GetItemProvenanceWhenExcludeHasIndirectReferences()
                   </ItemGroup>
 
                   <PropertyGroup>
-                    <P>1;2;3;@(B)</P>  
+                    <P>1;2;3;@(B)</P>
                   </PropertyGroup>
                 </Project>
                 ";
@@ -3104,7 +3104,7 @@ public void GetItemProvenanceWhenIncludeHasIndirectReferences()
                   </ItemGroup>
 
                   <PropertyGroup>
-                    <P>1;2;3;@(B)</P>  
+                    <P>1;2;3;@(B)</P>
                   </PropertyGroup>
                 </Project>
                 ";
@@ -3130,7 +3130,7 @@ public void GetItemProvenanceWhenIncludeHasIndirectItemReferencesAndOnlyGlobsExi
                   </ItemGroup>
 
                   <PropertyGroup>
-                    <P>@(B)</P>  
+                    <P>@(B)</P>
                   </PropertyGroup>
                 </Project>
                 ";
@@ -3158,7 +3158,7 @@ public void GetItemProvenanceShouldReturnInconclusiveWhenIndirectPropertyDoesNot
                   </ItemGroup>
 
                   <PropertyGroup>
-                    <P></P>  
+                    <P></P>
                   </PropertyGroup>
                 </Project>
                 ";
@@ -3918,7 +3918,7 @@ public void ProjectImportedEventFalseCondition()
                     eventArgs.LineNumber.ShouldBe(6);
                     eventArgs.ColumnNumber.ShouldBe(3);
 
-                    logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to false condition; ( \'$(Something)\' == \'nothing\' ) was evaluated as ( \'\' == \'nothing\' )."); 
+                    logger.AssertLogContains($"Project \"{import.Project}\" was not imported by \"{pre.FullPath}\" at ({eventArgs.LineNumber},{eventArgs.ColumnNumber}), due to false condition; ( \'$(Something)\' == \'nothing\' ) was evaluated as ( \'\' == \'nothing\' ).");
                 }
             }
         }
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index e6ac8089ea8..32e5a1a9ce1 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -25,11 +25,11 @@ public class BinaryTranslator_Tests
         public void TestSerializationMode()
         {
             MemoryStream stream = new MemoryStream();
-            ITranslator translator = BinaryTranslator.GetReadTranslator(stream, null);
-            Assert.Equal(TranslationDirection.ReadFromStream, translator.Mode);
+            using ITranslator readTranslator = BinaryTranslator.GetReadTranslator(stream, null);
+            Assert.Equal(TranslationDirection.ReadFromStream, readTranslator.Mode);
 
-            translator = BinaryTranslator.GetWriteTranslator(stream);
-            Assert.Equal(TranslationDirection.WriteToStream, translator.Mode);
+            using ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(stream);
+            Assert.Equal(TranslationDirection.WriteToStream, writeTranslator.Mode);
         }
 
         /// <summary>
@@ -545,7 +545,6 @@ public void AssemblyNameWithAllFields()
                 HashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA256,
                 VersionCompatibility = AssemblyVersionCompatibility.SameMachine,
                 CodeBase = "C:\\src",
-                KeyPair = new StrongNameKeyPair(new byte[] { 4, 3, 2, 1 }),
                 ContentType = AssemblyContentType.WindowsRuntime,
                 CultureName = "zh-HK",
             };
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 41a2d98510c..b87c06c077a 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -277,10 +277,10 @@ public void VerifyEnvironmentSavedBetweenCalls()
 </UsingTask>
                         <Target Name='SetEnv'>
                             <SetEnvv/>
-                        </Target>        
+                        </Target>
                         <Target Name='Message1'>
                             <Exec Command='echo What does a cat say : " + (NativeMethodsShared.IsWindows ? "%MOO%" : "$MOO") + @"' />
-                        </Target>       
+                        </Target>
 </Project>
 ");
 
@@ -311,7 +311,7 @@ public void VerifyEnvironmentSavedBetweenCalls()
 
         /// <summary>
         /// Verify if idle nodes are shutdown when BuildManager.ShutdownAllNodes is evoked.
-        /// The final number of nodes has to be less or equal the number of nodes already in 
+        /// The final number of nodes has to be less or equal the number of nodes already in
         /// the system before this method was called.
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
@@ -344,11 +344,11 @@ public void ShutdownNodesAfterParallelBuild(int numberOfParallelProjectsToBuild,
             // Generate a theoretically unique directory to put our dummy projects in.
             string shutdownProjectDirectory = Path.Combine(Path.GetTempPath(), String.Format(CultureInfo.InvariantCulture, "VSNodeShutdown_{0}_UnitTest", Process.GetCurrentProcess().Id));
 
-            // Create the dummy projects we'll be "building" as our excuse to connect to and shut down 
-            // all the nodes. 
+            // Create the dummy projects we'll be "building" as our excuse to connect to and shut down
+            // all the nodes.
             ProjectInstance rootProject = GenerateDummyProjects(shutdownProjectDirectory, numberOfParallelProjectsToBuild, projectCollection);
 
-            // Build the projects. 
+            // Build the projects.
             var buildParameters = new BuildParameters(projectCollection)
             {
                 OnlyLogCriticalEvents = true,
@@ -362,9 +362,9 @@ public void ShutdownNodesAfterParallelBuild(int numberOfParallelProjectsToBuild,
             // Tell the build manager to not disturb process wide state
             var requestData = new BuildRequestData(rootProject, new[] { "Build" }, null);
 
-            // Use a separate BuildManager for the node shutdown build, so that we don't have 
-            // to worry about taking dependencies on whether or not the existing ones have already 
-            // disappeared. 
+            // Use a separate BuildManager for the node shutdown build, so that we don't have
+            // to worry about taking dependencies on whether or not the existing ones have already
+            // disappeared.
             var shutdownManager = new BuildManager("IdleNodeShutdown");
             shutdownManager.Build(buildParameters, requestData);
 
@@ -551,7 +551,7 @@ public void RequestedResultsAreSatisfied()
         }
 
         /// <summary>
-        /// Make sure when we are doing an in-process build that even if the environment variable MSBUILDFORWARDPROPERTIESFROMCHILD is set that we still 
+        /// Make sure when we are doing an in-process build that even if the environment variable MSBUILDFORWARDPROPERTIESFROMCHILD is set that we still
         /// get all of the initial properties.
         /// </summary>
         [Fact]
@@ -631,7 +631,7 @@ public void InProcMsBuildForwardAllPropertiesFromChild()
         }
 
         /// <summary>
-        /// Make sure when we launch a child node and set MsBuildForwardAllPropertiesFromChild that we get all of our properties. This needs to happen 
+        /// Make sure when we launch a child node and set MsBuildForwardAllPropertiesFromChild that we get all of our properties. This needs to happen
         /// even if the msbuildforwardpropertiesfromchild is set to something.
         /// </summary>
         [Fact]
@@ -703,6 +703,11 @@ public void OutOfProcNodeForwardCertainproperties()
             _env.SetEnvironmentVariable("MsBuildForwardPropertiesFromChild", "InitialProperty3;IAMNOTREAL");
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
+            // ProjectEvaluationFinished automatically and always forwards all properties, so we'd
+            // end up with all ~136 properties. Since this test is explicitly testing forwarding specific
+            // properties on ProjectStarted, turn off the new behavior.
+            _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "0");
+
             var project = CreateProject(contents, null, _projectCollection, false);
             var data = new BuildRequestData(project.FullPath, new Dictionary<string, string>(),
                 MSBuildDefaultToolsVersion, new string[] { }, null);
@@ -835,7 +840,7 @@ public void ForwardNoPropertiesLaunchChildNode()
         }
 
         /// <summary>
-        /// We want to pass the toolsets from the parent to the child nodes so that any custom toolsets 
+        /// We want to pass the toolsets from the parent to the child nodes so that any custom toolsets
         /// defined on the parent are also available on the child nodes for tasks which use the global project
         /// collection
         /// </summary>
@@ -858,7 +863,7 @@ public void VerifyCustomToolSetsPropagated()
                                <Reference Include='$(MSBuildToolsPath)\Microsoft.Build.dll'/>
 <Code Type='Method'>
  <![CDATA[
-                    
+
                                 public override bool Execute()
                                 {
                                     bool foundToolSet = false;
@@ -963,7 +968,7 @@ public void DeferredMessageShouldBeLogged()
               <Project>
                  <Target Name='Build'>
                      <Message Text='[Message]' Importance='high'/>
-                     <Warning Text='[Warn]'/>	
+                     <Warning Text='[Warn]'/>
                 </Target>
               </Project>
             ");
@@ -1019,7 +1024,7 @@ public void DeferredMessageShouldBeLogged()
         }
 
         /// <summary>
-        /// A build with a message, error and warning, verify that 
+        /// A build with a message, error and warning, verify that
         /// we only get errors, warnings, and project started and finished when OnlyLogCriticalEvents is true
         /// </summary>
         [Fact]
@@ -1029,7 +1034,7 @@ public void SimpleBuildWithFailureAndWarningOnlyLogCriticalEventsTrue()
               <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                  <Target Name='test'>
                      <Message Text='[Message]' Importance='high'/>
-                     <Warning Text='[warn]'/>	
+                     <Warning Text='[warn]'/>
                      <Error Text='[errormessage]'/>
                 </Target>
               </Project>
@@ -1053,7 +1058,7 @@ public void SimpleBuildWithFailureAndWarningOnlyLogCriticalEventsTrue()
         }
 
         /// <summary>
-        /// A build with a message, error and warning, verify that 
+        /// A build with a message, error and warning, verify that
         /// we only get errors, warnings, messages, task and target messages OnlyLogCriticalEvents is false
         /// </summary>
         [Fact]
@@ -1063,7 +1068,7 @@ public void SimpleBuildWithFailureAndWarningOnlyLogCriticalEventsFalse()
               <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                  <Target Name='test'>
                      <Message Text='[message]' Importance='high'/>
-                     <Warning Text='[warn]'/>	
+                     <Warning Text='[warn]'/>
                      <Error Text='[errormessage]'/>
                 </Target>
               </Project>
@@ -1386,9 +1391,9 @@ public void OverlappingBuildSubmissions()
         }
 
         /// <summary>
-        /// If two overlapping submissions are executed against the same project, with at least one 
-        /// target involved that skipped, make sure that the second one successfully completes 
-        /// (retrieved from the cache). 
+        /// If two overlapping submissions are executed against the same project, with at least one
+        /// target involved that skipped, make sure that the second one successfully completes
+        /// (retrieved from the cache).
         /// </summary>
         [Fact]
         public void OverlappingIdenticalBuildSubmissions()
@@ -1419,9 +1424,9 @@ public void OverlappingIdenticalBuildSubmissions()
         }
 
         /// <summary>
-        /// With two overlapping submissions, the first of which skips a target and the second 
-        /// of which should not, ensure that the second submission does not, in fact, skip 
-        /// the target.  (E.g. despite the fact that the target results are in the cache already 
+        /// With two overlapping submissions, the first of which skips a target and the second
+        /// of which should not, ensure that the second submission does not, in fact, skip
+        /// the target.  (E.g. despite the fact that the target results are in the cache already
         /// as 'skipped', ensure that we retry execution in case conditions have changed.)
         /// </summary>
         [Fact]
@@ -1516,6 +1521,7 @@ public void CancelledBuildWithUnexecutedSubmission()
         [Fact(Timeout = 20_000)]
         public void CancelledBuild()
         {
+            Console.WriteLine("Starting CancelledBuild test that is known to hang.");
             string contents = CleanupFileContents(@"
 <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
  <Target Name='test'>
@@ -1524,18 +1530,36 @@ public void CancelledBuild()
  </Target>
 </Project>
 ");
+
+            BuildParameters parameters = new ()
+            {
+                ShutdownInProcNodeOnBuildFinish = true,
+                Loggers = new ILogger[] { _logger, new MockLogger(printEventsToStdout: true) },
+                EnableNodeReuse = false
+            };
+
             BuildRequestData data = GetBuildRequestData(contents, new string[] { }, MSBuildDefaultToolsVersion);
+
+            Console.WriteLine("CancelledBuild: beginning build");
             _buildManager.BeginBuild(_parameters);
+            Console.WriteLine("CancelledBuild: build begun");
+
             BuildSubmission asyncResult = _buildManager.PendBuildRequest(data);
+            Console.WriteLine("CancelledBuild: pend build returned");
+
 
             asyncResult.ExecuteAsync(null, null);
+            Console.WriteLine("CancelledBuild: ExecuteAsync called");
             _buildManager.CancelAllSubmissions();
+            Console.WriteLine("CancelledBuild: submissions cancelled");
+
             // This test intermittently hangs. This timeout is designed to prevent that, turning a hang into a failure.
             // Todo: Investigate why this test sometimes hangs.
-            asyncResult.WaitHandle.WaitOne(TimeSpan.FromSeconds(10));
+            asyncResult.WaitHandle.WaitOne(TimeSpan.FromSeconds(10)).ShouldBeTrue();
             asyncResult.IsCompleted.ShouldBeTrue("Failing to complete by this point indicates a hang.");
             BuildResult result = asyncResult.BuildResult;
             _buildManager.EndBuild();
+            Console.WriteLine("CancelledBuild: build ended");
 
             Assert.Equal(BuildResultCode.Failure, result.OverallResult); // "Build should have failed."
             _logger.AssertLogDoesntContain("[errormessage]");
@@ -1619,7 +1643,7 @@ public void CancelledBuildInTaskHostWithDelay20()
 
         /// <summary>
         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.. task, we should
-        /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly. 
+        /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
         /// </summary>
         [Fact]
         public void CancelledBuildWithDelay40()
@@ -1650,7 +1674,7 @@ public void CancelledBuildWithDelay40()
 #if FEATURE_TASKHOST
         /// <summary>
         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.0 task, we should
-        /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly. 
+        /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
         /// </summary>
         [Fact]
         public void CancelledBuildInTaskHostWithDelay40()
@@ -2122,7 +2146,7 @@ public void Regress239661()
  </Target>
 </Project>
 ");
-            
+
             string fileName = _env.CreateFile(".proj").Path;
             File.WriteAllText(fileName, contents);
             var data = new BuildRequestData(fileName, _projectCollection.GlobalProperties, MSBuildDefaultToolsVersion, new string[0], null);
@@ -2181,9 +2205,9 @@ public void ProjectInstanceTransfersToOOPNode()
  </PropertyGroup>
 <ItemGroup>
   <Foo Include='foo'/>
-  <Foo2 Include='foo2'/>    
+  <Foo2 Include='foo2'/>
 </ItemGroup>
- <Target Name='test'>   
+ <Target Name='test'>
    <Message Text='[$(DeleteMe)]'/>
    <Message Text='[$(Unmodified)]'/>
    <Message Text='[$(VirtualProp)]'/>
@@ -2243,7 +2267,7 @@ public void ProjectInstanceLimitedTransferToOOPNode()
    <Unmodified>unmodified</Unmodified>
    <VirtualProp>original</VirtualProp>
  </PropertyGroup>
- <Target Name='test'>   
+ <Target Name='test'>
    <Message Text='[$(Unmodified)]'/>
    <Message Text='[$(VirtualProp)]'/>
  </Target>
@@ -2294,7 +2318,7 @@ public void CacheLifetime()
                 {
                     innerBuildCacheDirectory = BuildAndCheckCache(innerBuildManager, new[] { outerBuildCacheDirectory });
 
-                    // Force the cache for this build manager (and only this build manager) to be cleared.  It should leave 
+                    // Force the cache for this build manager (and only this build manager) to be cleared.  It should leave
                     // behind the results from the other one.
                     innerBuildManager.ResetCaches();
                 }
@@ -2310,9 +2334,9 @@ public void CacheLifetime()
         }
 
         /// <summary>
-        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the 
+        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the
         /// overall build result -- and thus the return value of the MSBuild task -- should reflect
-        /// that failure. 
+        /// that failure.
         /// </summary>
         [Theory]
         [InlineData(false)]
@@ -2326,9 +2350,9 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure(bool disableInP
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <MSBuild Projects=`" + projB + @"` />
- 
+
     <Warning Text=`We shouldn't reach here.` />
-  </Target>    
+  </Target>
 </Project>
 ";
 
@@ -2358,10 +2382,10 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure(bool disableInP
         }
 
         /// <summary>
-        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the 
+        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the
         /// overall build result -- and thus the return value of the MSBuild task -- should reflect
-        /// that failure.  Specifically tests where there are multiple entrypoint targets with 
-        /// AfterTargets, only one of which fails. 
+        /// that failure.  Specifically tests where there are multiple entrypoint targets with
+        /// AfterTargets, only one of which fails.
         /// </summary>
         [Theory]
         [InlineData(false)]
@@ -2375,9 +2399,9 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure_MultipleEntrypo
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <MSBuild Projects=`" + projB + @"` Targets=`Build;Build2` />
- 
+
     <Warning Text=`We shouldn't reach here.` />
-  </Target>    
+  </Target>
 </Project>
 ";
 
@@ -2424,9 +2448,9 @@ public void FailedAfterTargetInP2PShouldCauseOverallBuildFailure_MultipleEntrypo
         }
 
         /// <summary>
-        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the 
+        /// If there's a P2P that otherwise succeeds, but has an AfterTarget that errors out, the
         /// overall build result -- and thus the return value of the MSBuild task -- should reflect
-        /// that failure. This should also be true if the AfterTarget is an AfterTarget of the 
+        /// that failure. This should also be true if the AfterTarget is an AfterTarget of the
         /// entrypoint target.
         /// </summary>
         [Theory]
@@ -2441,9 +2465,9 @@ public void FailedNestedAfterTargetInP2PShouldCauseOverallBuildFailure(bool disa
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
     <MSBuild Projects=`" + projB + @"` />
- 
+
     <Warning Text=`We shouldn't reach here.` />
-  </Target>    
+  </Target>
 </Project>
 ";
 
@@ -2477,9 +2501,9 @@ public void FailedNestedAfterTargetInP2PShouldCauseOverallBuildFailure(bool disa
         }
 
         /// <summary>
-        /// If a project is called into twice, with two different entrypoint targets that 
-        /// depend on non-overlapping sets of targets, and the first fails, the second 
-        /// should not inherit that failure if all the targets it calls succeed. 
+        /// If a project is called into twice, with two different entrypoint targets that
+        /// depend on non-overlapping sets of targets, and the first fails, the second
+        /// should not inherit that failure if all the targets it calls succeed.
         /// </summary>
         [Fact]
         public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResults()
@@ -2490,7 +2514,7 @@ public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResu
             string contentsA = @"
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
   <Target Name=`Build`>
-  
+
    <Message Text=`The next MSBuild call should FAIL, but the build will continue.` />
    <MSBuild Projects=`" + projB + @"` Targets=`Build` ContinueOnError=`true` />
    <Message Text=`The next MSBuild call should SUCCEED without error.` />
@@ -2504,8 +2528,8 @@ public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResu
   <Target Name=`Build`>
     <Error Text=`Forced error in Build` />
   </Target>
-  
-  
+
+
   <Target Name=`GetTargetPath`>
     <Message Text=`Success` />
   </Target>
@@ -2525,9 +2549,9 @@ public void NonOverlappingEnusingTrypointTargetsShouldNotInfluenceEachOthersResu
         }
 
         /// <summary>
-        /// In a situation where we have two requests calling into the same project, with different entry point 
-        /// targets, one of which depends on "A;B", the other of which depends on "B", which has a dependency of 
-        /// its own on "A", that we still properly build.  
+        /// In a situation where we have two requests calling into the same project, with different entry point
+        /// targets, one of which depends on "A;B", the other of which depends on "B", which has a dependency of
+        /// its own on "A", that we still properly build.
         /// </summary>
 #if RUNTIME_TYPE_NETCORE
         [Fact(Skip = "https://github.com/Microsoft/msbuild/issues/933")]
@@ -2546,7 +2570,7 @@ public void Regress473114()
             string contentsA = @"<?xml version='1.0' encoding='utf-8'?>
 <Project ToolsVersion='4.0' DefaultTargets='Build' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
   <ItemGroup>
-    <ProjectReference Include='" + projD + @"' /> 
+    <ProjectReference Include='" + projD + @"' />
     <ProjectReference Include='" + projC + @"' />
     <ProjectReference Include='" + projB + @"' />
   </ItemGroup>
@@ -2616,19 +2640,19 @@ public void Regress473114()
         }
 
         /// <summary>
-        /// If two requests are made for the same project, and they call in with 
-        /// just the right timing such that: 
+        /// If two requests are made for the same project, and they call in with
+        /// just the right timing such that:
         /// - request 1 builds for a while, reaches a P2P, and blocks
-        /// - request 2 starts building, skips for a while, reaches the above P2P, and 
-        ///   blocks waiting for request 1's results 
+        /// - request 2 starts building, skips for a while, reaches the above P2P, and
+        ///   blocks waiting for request 1's results
         /// - request 1 resumes building, errors, and exits
         /// - request 2 resumes building
-        /// 
-        /// Then request 2 should end up exiting in the same fashion.  
-        /// 
-        /// This simple test verifies that if there are two error targets in a row, the 
-        /// second request will bail out where the first request did, as though it had 
-        /// executed the target, rather than skipping and continuing. 
+        ///
+        /// Then request 2 should end up exiting in the same fashion.
+        ///
+        /// This simple test verifies that if there are two error targets in a row, the
+        /// second request will bail out where the first request did, as though it had
+        /// executed the target, rather than skipping and continuing.
         /// </summary>
 #if MONO
         [Fact(Skip = "https://github.com/Microsoft/msbuild/issues/1240")]
@@ -2705,9 +2729,9 @@ public void VerifyMultipleRequestForSameProjectWithErrors_Simple()
         ///   blocks waiting for request 1's results
         /// - request 1 resumes building, errors, and exits
         /// - request 2 resumes building
-        /// 
+        ///
         /// Then request 2 should end up exiting in the same fashion.
-        /// 
+        ///
         /// This simple test verifies that if there are two error targets in a row, and the
         /// first has a chain of OnError targets, the OnError targets will all execute as
         /// expected in the first request, but be skipped by the second (since if it's "skipping
@@ -2825,9 +2849,9 @@ public void VerifyMultipleRequestForSameProjectWithErrors_OnErrorChain()
         ///   blocks waiting for request 1's results
         /// - request 1 resumes building, errors, and exits
         /// - request 2 resumes building
-        /// 
+        ///
         /// Then request 2 should end up exiting in the same fashion.
-        /// 
+        ///
         /// This simple test verifies that if there are two error targets in a row, AND
         /// they're marked as ContinueOnError=ErrorAndContinue, then we won't bail, but
         /// will continue executing (on the first request) or skipping (on the second)
@@ -2909,18 +2933,18 @@ public void VerifyMultipleRequestForSameProjectWithErrors_ErrorAndContinue()
         }
 
         /// <summary>
-        /// If two requests are made for the same project, and they call in with 
-        /// just the right timing such that: 
+        /// If two requests are made for the same project, and they call in with
+        /// just the right timing such that:
         /// - request 1 builds for a while, reaches a P2P, and blocks
-        /// - request 2 starts building, skips for a while, reaches the above P2P, and 
-        ///   blocks waiting for request 1's results 
+        /// - request 2 starts building, skips for a while, reaches the above P2P, and
+        ///   blocks waiting for request 1's results
         /// - request 1 resumes building, errors, and exits
         /// - request 2 resumes building
-        /// 
-        /// Then request 2 should end up exiting in the same fashion.  
-        /// 
-        /// This test verifies that if the errors are in AfterTargets, we still 
-        /// exit as though the target that those targets run after has already run. 
+        ///
+        /// Then request 2 should end up exiting in the same fashion.
+        ///
+        /// This test verifies that if the errors are in AfterTargets, we still
+        /// exit as though the target that those targets run after has already run.
         /// </summary>
 #if MONO
         [Fact(Skip = "https://github.com/Microsoft/msbuild/issues/1240")]
@@ -2990,10 +3014,10 @@ public void VerifyMultipleRequestForSameProjectWithErrors_AfterTargets()
         }
 
         /// <summary>
-        /// Related to the two tests above, if two requests are made for the same project, but 
-        /// for different entry targets, and a target fails in the first request, if the second 
-        /// request also runs that target, its skip-unsuccessful should behave in the same 
-        /// way as if the target had actually errored. 
+        /// Related to the two tests above, if two requests are made for the same project, but
+        /// for different entry targets, and a target fails in the first request, if the second
+        /// request also runs that target, its skip-unsuccessful should behave in the same
+        /// way as if the target had actually errored.
         /// </summary>
         [Fact]
         public void VerifyMultipleRequestForSameProjectWithErrors_DifferentEntrypoints()
@@ -3003,7 +3027,7 @@ public void VerifyMultipleRequestForSameProjectWithErrors_DifferentEntrypoints()
 
             string contentsA = @"
 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
-  <ItemGroup> 
+  <ItemGroup>
     <PR Include=`" + projB + @"`>
       <Targets>Build</Targets>
     </PR>
@@ -3120,7 +3144,7 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData()
         }
 
         /// <summary>
-        /// Verify that we can submit multiple simultaneous submissions with 
+        /// Verify that we can submit multiple simultaneous submissions with
         /// legacy threading mode active and successfully build, and that one of those
         /// submissions can P2P to the other.
         /// </summary>
@@ -3201,12 +3225,12 @@ public void TestSimultaneousSubmissionsWithLegacyThreadingData_P2P()
         }
 
         /// <summary>
-        /// Verify that we can submit multiple simultaneous submissions with 
+        /// Verify that we can submit multiple simultaneous submissions with
         /// legacy threading mode active and successfully build, and that one of those
         /// submissions can P2P to the other.
-        /// 
-        /// A variation of the above test, where multiple nodes are available, so the 
-        /// submissions aren't restricted to running strictly serially by the single in-proc 
+        ///
+        /// A variation of the above test, where multiple nodes are available, so the
+        /// submissions aren't restricted to running strictly serially by the single in-proc
         /// node.
         /// </summary>
 #if MONO
@@ -3309,7 +3333,7 @@ public void Regress265010()
 <ItemGroup>
   <Item Include='BaseItem'/>
 </ItemGroup>
- <Target Name='BaseTest'>   
+ <Target Name='BaseTest'>
    <Message Text='[$(Prop)]'/>
    <Message Text='[@(Item)]'/>
     <PropertyGroup>
@@ -3320,7 +3344,7 @@ public void Regress265010()
     </ItemGroup>
  </Target>
 
- <Target Name='MovedTest'>   
+ <Target Name='MovedTest'>
    <Message Text='[$(Prop)]'/>
    <Message Text='[@(Item)]'/>
  </Target>
@@ -3453,13 +3477,13 @@ private static string BuildAndCheckCache(BuildManager localBuildManager, IEnumer
         {
             string contents = CleanupFileContents(@"
 <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
- <Target Name='One' Outputs='one.txt'>   
+ <Target Name='One' Outputs='one.txt'>
  </Target>
 
- <Target Name='Two' Outputs='two.txt'>   
+ <Target Name='Two' Outputs='two.txt'>
  </Target>
 
- <Target Name='Three' Outputs='three.txt'>   
+ <Target Name='Three' Outputs='three.txt'>
  </Target>
 </Project>
 ");
@@ -3581,8 +3605,8 @@ private static ProjectInstance GenerateDummyProjects(string shutdownProjectDirec
             Directory.CreateDirectory(shutdownProjectDirectory);
 
             // Generate the project.  It will have the following format.  Setting the AdditionalProperties
-            // causes the projects to be built to be separate configs, which allows us to build the same project 
-            // a bunch of times in parallel.  
+            // causes the projects to be built to be separate configs, which allows us to build the same project
+            // a bunch of times in parallel.
             //
             // <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003'/>
             //   <ItemGroup>
@@ -3935,7 +3959,7 @@ public void OutOfProcEvaluationIdsUnique()
         /// Regression test for https://github.com/Microsoft/msbuild/issues/3047
         /// </summary>
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "out-of-proc nodes not working on mono yet")]
+        [SkipOnMono("out-of-proc nodes not working on mono yet")]
         public void MultiProcReentrantProjectWithCallTargetDoesNotFail()
         {
             var a =
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 008efd6ab92..eb37f60b029 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -26,7 +26,6 @@ public class BuildRequestConfiguration_Tests : IDisposable
         public BuildRequestConfiguration_Tests(ITestOutputHelper testOutput)
         {
             _env = TestEnvironment.Create(testOutput);
-            _env.DoNotLaunchDebugger();
         }
 
         public void Dispose()
diff --git a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
index 75e018b7cdc..9cede0f7298 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
@@ -138,7 +138,7 @@ public void TestTranslation()
 
 #if FEATURE_COM_INTEROP
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "disable com tests on mono")]
+        [SkipOnMono("disable com tests on mono")]
         public void TestTranslationRemoteHostObjects()
         {
             var stateInHostObject = 3;
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index 9a485cb0d49..4d84c33b60f 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -665,6 +665,11 @@ public void Properties()
             Assert.Equal(1, loggingService.MaxCPUCount);
             loggingService.MaxCPUCount = 5;
             Assert.Equal(5, loggingService.MaxCPUCount);
+
+            // Test MinimumRequiredMessageImportance
+            Assert.Equal(MessageImportance.Low, loggingService.MinimumRequiredMessageImportance);
+            loggingService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
+            Assert.Equal(MessageImportance.Normal, loggingService.MinimumRequiredMessageImportance);
         }
 
         #endregion
@@ -718,6 +723,8 @@ public void LoggingPacketReceived()
 
         #endregion
 
+        #region WarningsAsErrors Tests
+
         private static readonly BuildWarningEventArgs BuildWarningEventForTreatAsErrorOrMessageTests = new BuildWarningEventArgs("subcategory", "C94A41A90FFB4EF592BF98BA59BEE8AF", "file", 1, 2, 3, 4, "message", "helpKeyword", "senderName");
 
         /// <summary>
@@ -1000,6 +1007,76 @@ private MockLogger GetLoggedEventsWithWarningsAsErrorsOrMessages(
             return logger;
         }
 
+        #endregion
+
+        #region MinimumRequiredMessageImportance Tests
+
+        [Fact]
+        public void ImportanceReflectsConsoleLoggerVerbosity()
+        {
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Quiet));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High - 1);
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Minimal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High);
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Normal);
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Detailed));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Diagnostic));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+        }
+
+        [Fact]
+        public void ImportanceReflectsConfigurableForwardingLoggerVerbosity()
+        {
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Quiet));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High - 1);
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Minimal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High);
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Normal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Normal);
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Detailed));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Diagnostic));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+        }
+
+        [Fact]
+        public void ImportanceReflectsCentralForwardingLoggerVerbosity()
+        {
+            MockHost mockHost = new MockHost();
+            ILoggingService node1LoggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            ((IBuildComponent)node1LoggingService).InitializeComponent(mockHost);
+            ILoggingService node2LoggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 2);
+            ((IBuildComponent)node2LoggingService).InitializeComponent(mockHost);
+
+            // CentralForwardingLogger is always registered in in-proc nodes and it does not affect minimum importance.
+            node1LoggingService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Minimal));
+            node1LoggingService.RegisterLogger(new CentralForwardingLogger());
+            node1LoggingService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.High);
+
+            // CentralForwardingLogger in out-of-proc nodes means that we are forwarding everything and the minimum importance
+            // is Low regardless of what other loggers are registered.
+            node2LoggingService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Minimal));
+            node2LoggingService.RegisterLogger(new CentralForwardingLogger());
+            node2LoggingService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+            // Register another ConsoleLogger and verify that minimum importance hasn't changed.
+            node2LoggingService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Minimal));
+            node2LoggingService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+        }
+
+        [Fact]
+        public void ImportanceReflectsUnknownLoggerVerbosity()
+        {
+            // Minimum message importance is Low (i.e. we're logging everything) even when all registered loggers have
+            // Normal verbosity if at least of one them is not on our whitelist.
+            _initializedService.RegisterLogger(new ConsoleLogger(LoggerVerbosity.Normal));
+            _initializedService.RegisterLogger(new MockLogger() { Verbosity = LoggerVerbosity.Normal });
+            _initializedService.RegisterLogger(CreateConfigurableForwardingLogger(LoggerVerbosity.Normal));
+            _initializedService.MinimumRequiredMessageImportance.ShouldBe(MessageImportance.Low);
+        }
+        #endregion
+
         #region PrivateMethods
 
         /// <summary>
@@ -1084,6 +1161,17 @@ private LoggerDescription CreateLoggerDescription(string loggerClassName, string
                                                                              );
             return centralLoggerDescrption;
         }
+
+        /// <summary>
+        /// Creates a new <see cref="ConfigurableForwardingLogger"/> with the given verbosity.
+        /// </summary>
+        private ConfigurableForwardingLogger CreateConfigurableForwardingLogger(LoggerVerbosity verbosity)
+        {
+            return new ConfigurableForwardingLogger()
+            {
+                Verbosity = verbosity
+            };
+        }
         #endregion
 
         #region HelperClasses
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index ac9b733f8d2..2d4ed73b93d 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -223,6 +223,11 @@ public bool IncludeTaskInputs
             set { }
         }
 
+        public MessageImportance MinimumRequiredMessageImportance
+        {
+            get => MessageImportance.Low;
+        }
+
         public void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet<string> codes)
         {
             throw new NotImplementedException();
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 2520bc41bb6..486352af3f2 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -589,7 +589,7 @@ public void NullMetadataOnOutputItems_InlineTask()
         /// <summary>
         /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
-        [Fact]
+        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/6521")]
         [Trait("Category", "non-mono-tests")]
         public void NullMetadataOnLegacyOutputItems_InlineTask()
         {
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index 487afd376b8..c6f59eea74f 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -57,51 +57,14 @@ public void FindBuildEnvironmentByEnvironmentVariable()
         /// If MSBUILD_EXE_PATH is explicitly set, we should detect it as a VisualStudio instance even in older scenarios
         /// (for example when the install path is under 15.0).
         /// </summary>
-        /// <param name="is64BitMSbuild">When true, run the test pointing to amd64 msbuild.exe.</param>
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
+        [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
         [PlatformSpecific(TestPlatforms.Windows)]
-        public void FindVisualStudioEnvironmentByEnvironmentVariable(bool is64BitMSbuild)
+        public void FindVisualStudioEnvironmentByEnvironmentVariable()
         {
             using (var env = new EmptyVSEnviroment())
             {
-                var msbuildBinDirectory = is64BitMSbuild
-                    ? Path.Combine(env.BuildDirectory, "amd64")
-                    : env.BuildDirectory;
-
-                var msBuildPath = Path.Combine(msbuildBinDirectory, MSBuildExeName);
-                var msBuildConfig = Path.Combine(msbuildBinDirectory, $"{MSBuildExeName}.config");
-                var vsMSBuildDirectory = Path.Combine(env.TempFolderRoot, "MSBuild");
-
-                env.WithEnvironment("MSBUILD_EXE_PATH", msBuildPath);
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(ReturnNull, ReturnNull, ReturnNull, env.VsInstanceMock, env.EnvironmentMock, () => false);
-
-                BuildEnvironmentHelper.Instance.Mode.ShouldBe(BuildEnvironmentMode.VisualStudio);
-                BuildEnvironmentHelper.Instance.MSBuildExtensionsPath.ShouldBe(vsMSBuildDirectory);
-                BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory.ShouldBe(msbuildBinDirectory);
-                BuildEnvironmentHelper.Instance.CurrentMSBuildExePath.ShouldBe(msBuildPath);
-                BuildEnvironmentHelper.Instance.CurrentMSBuildConfigurationFile.ShouldBe(msBuildConfig);
-                // This code is not running inside the Visual Studio devenv.exe process
-                BuildEnvironmentHelper.Instance.RunningInVisualStudio.ShouldBeFalse();
-                BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory.ShouldBe(env.TempFolderRoot);
-                BuildEnvironmentHelper.Instance.RunningTests.ShouldBeFalse();
-            }
-        }
-
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
-        [PlatformSpecific(TestPlatforms.Windows)]
-        public void FindOlderVisualStudioEnvironmentByEnvironmentVariable(bool is64BitMSbuild)
-        {
-            using (var env = new EmptyVSEnviroment("15.0"))
-            {
-                var msbuildBinDirectory = is64BitMSbuild
-                    ? Path.Combine(env.BuildDirectory, "amd64")
-                    : env.BuildDirectory;
+                var msbuildBinDirectory = env.BuildDirectory;
 
                 var msBuildPath = Path.Combine(msbuildBinDirectory, MSBuildExeName);
                 var msBuildConfig = Path.Combine(msbuildBinDirectory, $"{MSBuildExeName}.config");
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 31c8209404d..023d77e74b8 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -318,9 +318,9 @@ public void ErrorMessageWithMultiplePropertiesInMessage(bool includeEvaluationPr
             output.ShouldContain("source_of_error : error : Hello from project 2 [" + project.ProjectFile + ":: Number=2 TargetFramework=netcoreapp2.1]");
         }
 
-        [Fact]
+        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/6518")]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Minimal path validation in Core allows expanding path containing quoted slashes.")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "Minimal path validation in Mono allows expanding path containing quoted slashes.")]
+        [SkipOnMono("Minimal path validation in Mono allows expanding path containing quoted slashes.")]
         public void TestItemsWithUnexpandableMetadata()
         {
             SimulatedConsole sc = new SimulatedConsole();
@@ -338,7 +338,8 @@ public void TestItemsWithUnexpandableMetadata()
  <Target Name=""X"" />
 </Project>", logger);
 
-            sc.ToString().ShouldContain("\"a\\b\\%(Filename).c\"");
+            var text = sc.ToString();
+            text.ShouldContain("\"a\\b\\%(Filename).c\"");
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index a160284d78a..232d22c62dd 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -125,8 +125,6 @@ public void PassedInFileSystemShouldBeReusedInSharedContext()
         [Fact]
         public void IsolatedContextShouldNotSupportBeingPassedAFileSystem()
         {
-            _env.DoNotLaunchDebugger();
-
             var fileSystem = new Helpers.LoggingFileSystem();
             Should.Throw<ArgumentException>(() => EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated, fileSystem));
         }
diff --git a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
index e365cb9265f..41e2d74ef72 100644
--- a/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetRegistryReader_Tests.cs
@@ -36,7 +36,7 @@ public class ToolsetRegistryReader_Tests : IDisposable
         private const string testRegistryPath = @"msbuildUnitTests";
 
         /// <summary>
-        /// Store the value of the "VisualStudioVersion" environment variable here so that 
+        /// Store the value of the "VisualStudioVersion" environment variable here so that
         /// we can unset it for the duration of the test.
         /// </summary>
         private string _oldVisualStudioVersion;
@@ -341,8 +341,8 @@ public void ReadRegistry_IgnoreSubToolsetSubKeys()
         }
 
         /// <summary>
-        /// Verifies that if a value is defined in both the base toolset and the 
-        /// selected subtoolset, the subtoolset value overrides -- even if that 
+        /// Verifies that if a value is defined in both the base toolset and the
+        /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
         [Fact]
@@ -381,8 +381,8 @@ public void ReadRegistry_SubToolsetOverridesBaseToolsetEntries()
         }
 
         /// <summary>
-        /// Verifies that if a value is defined in both the base toolset and the 
-        /// selected subtoolset, the subtoolset value overrides -- even if that 
+        /// Verifies that if a value is defined in both the base toolset and the
+        /// selected subtoolset, the subtoolset value overrides -- even if that
         /// value is empty.
         /// </summary>
         [Fact]
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index ca20d9c66cb..14b91ed0795 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -629,7 +629,7 @@ public void UsePropertyBeforeSet()
                                      <PropertyGroup>
                                          <Foo>$(baz) $(bar)</Foo>
                                          <bar>Something</bar>
-                                         <baz>Something</baz>   
+                                         <baz>Something</baz>
                                      </PropertyGroup>
 
                                   <Target Name=""Test""/>
@@ -675,7 +675,7 @@ public void UsePropertyBeforeSetDuplicates()
                                          <Foo1>$(baz) $(bar)</Foo1>
                                          <Foo>$(baz) $(bar)</Foo>
                                          <bar>Something</bar>
-                                         <baz>Something</baz>   
+                                         <baz>Something</baz>
                                      </PropertyGroup>
 
                                   <Target Name=""Test""/>
@@ -1860,12 +1860,12 @@ public void AllEvaluatedItems()
                         <Choose>
                           <When Condition='false'>
                             <ItemGroup>
-                              <i Include='i4'/>                     
+                              <i Include='i4'/>
                             </ItemGroup>
                           </When>
                           <When Condition='true'>
                             <ItemGroup>
-                              <i Include='i1'>                     
+                              <i Include='i1'>
                                 <m>m2</m>
                               </i>
                             </ItemGroup>
@@ -1876,7 +1876,7 @@ public void AllEvaluatedItems()
                           <When Condition='false'/>
                           <Otherwise>
                             <ItemGroup>
-                              <i Include='i5'/>                     
+                              <i Include='i5'/>
                             </ItemGroup>
                           </Otherwise>
                         </Choose>
@@ -2587,6 +2587,8 @@ public void MSBuildVersion()
             Project project = new Project(xml);
 
             string msbuildVersionProperty = project.GetPropertyValue("MSBuildVersion");
+            string msbuildFileVersionProperty = project.GetPropertyValue("MSBuildFileVersion");
+            string msbuildSemanticVersionProperty = project.GetPropertyValue("MSBuildSemanticVersion");
 
             Version.TryParse(msbuildVersionProperty, out Version msbuildVersionAsVersion).ShouldBeTrue();
 
@@ -2596,9 +2598,11 @@ public void MSBuildVersion()
             // Version parses missing elements into -1, and this property should be Major.Minor.Patch only
             msbuildVersionAsVersion.Revision.ShouldBe(-1);
 
+            msbuildFileVersionProperty.ShouldBe(ProjectCollection.Version.ToString());
             ProjectCollection.Version.ToString().ShouldStartWith(msbuildVersionProperty,
                 "ProjectCollection.Version should match the property MSBuildVersion, but can contain another version part");
 
+            msbuildSemanticVersionProperty.ShouldBe(ProjectCollection.DisplayVersion);
             ProjectCollection.DisplayVersion.ShouldStartWith(msbuildVersionProperty,
                 "DisplayVersion is semver2 while MSBuildVersion is Major.Minor.Build but should be a prefix match");
         }
@@ -4340,7 +4344,7 @@ public void ThrownInvalidProjectExceptionProperlyHandled()
         {
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"
                              <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns='msbuildnamespace'>
-                                
+
                                 <Import Project=""import.proj"" />
 
                             </Project>");
@@ -4392,9 +4396,9 @@ public void ThrownInvalidProjectExceptionProperlyHandled()
         /// <summary>
         /// Tests that an import, target, or task with a condition that contains an error but is short-circuited does not fail the build.  This can happen when you have a condition like:
         /// 'true' == 'false' AND '$([MSBuild]::GetDirectoryNameOfFileAbove($(NonExistentProperty), init.props))' != ''
-        /// 
+        ///
         /// The first condition is false so the second condition is not evaluated.  But in some cases we double evaluate the condition to log it.  The second evaluation will fail because it evaluates the whole string.
-        /// 
+        ///
         /// https://github.com/Microsoft/msbuild/issues/2259
         /// </summary>
         [Theory]
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 71d15858f3c..5c949dfc17b 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1547,76 +1547,6 @@ public void ExpandAllIntoStringTruncated()
             Assert.Equal(expected, expander.ExpandIntoStringAndUnescape(xmlattribute.Value, ExpanderOptions.ExpandAll | ExpanderOptions.Truncate, MockElementLocation.Instance));
         }
 
-        /// <summary>
-        /// Exercises ExpandIntoStringAndUnescape and ExpanderOptions.Truncate
-        /// </summary>
-        [Fact]
-        public void ExpandAllIntoStringNotTruncated()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_8.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-                ProjectInstance project = ProjectHelpers.CreateEmptyProjectInstance();
-                var manySpaces = "".PadLeft(2000);
-                var pg = new PropertyDictionary<ProjectPropertyInstance>();
-                pg.Set(ProjectPropertyInstance.Create("ManySpacesProperty", manySpaces));
-                var itemMetadataTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
-                {
-                    { "ManySpacesMetadata", manySpaces }
-                };
-                var itemMetadata = new StringMetadataTable(itemMetadataTable);
-                var projectItemGroups = new ItemDictionary<ProjectItemInstance>();
-                var itemGroup = new List<ProjectItemInstance>();
-                StringBuilder longFileName = new StringBuilder();
-                StringBuilder longMetadataName = new StringBuilder();
-                for (int i = 0; i < 50; i++)
-                {
-                    var item = new ProjectItemInstance(project, "ManyItems", $"ThisIsAFairlyLongFileName_{i}.bmp", project.FullPath);
-                    item.SetMetadata("Foo", $"ThisIsAFairlyLongMetadataValue_{i}");
-                    longFileName.Append($"ThisIsAFairlyLongFileName_{i}.bmp" + (i == 49 ? string.Empty : ";"));
-                    longMetadataName.Append($"ThisIsAFairlyLongMetadataValue_{i}" + (i == 49 ? string.Empty : ";"));
-                    itemGroup.Add(item);
-                }
-                var lookup = new Lookup(projectItemGroups, pg);
-                lookup.EnterScope("x");
-                lookup.PopulateWithItems("ManySpacesItem", new[]
-                {
-                    new ProjectItemInstance (project, "ManySpacesItem", "Foo", project.FullPath),
-                    new ProjectItemInstance (project, "ManySpacesItem", manySpaces, project.FullPath),
-                    new ProjectItemInstance (project, "ManySpacesItem", "Bar", project.FullPath),
-                });
-                lookup.PopulateWithItems("Exactly1024", new[]
-                {
-                    new ProjectItemInstance (project, "Exactly1024", "".PadLeft(1024), project.FullPath),
-                    new ProjectItemInstance (project, "Exactly1024", "Foo", project.FullPath),
-                });
-                lookup.PopulateWithItems("ManyItems", itemGroup);
-
-                Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(lookup, lookup, itemMetadata, FileSystems.Default);
-
-                XmlAttribute xmlattribute = (new XmlDocument()).CreateAttribute("dummy");
-                xmlattribute.Value = "'%(ManySpacesMetadata)' != '' and '$(ManySpacesProperty)' != '' and '@(ManySpacesItem)' != '' and '@(Exactly1024)' != '' and '@(ManyItems)' != '' and '@(ManyItems->'%(Foo)')' != '' and '@(ManyItems->'%(Nonexistent)')' != ''";
-
-                var expected =
-                    $"'{"",2000}' != '' and " +
-                    $"'{"",2000}' != '' and " +
-                    $"'Foo;{"",2000};Bar' != '' and " +
-                    $"'{"",1024};Foo' != '' and " +
-                    $"'{longFileName}' != '' and " +
-                    $"'{longMetadataName}' != '' and " +
-                    "';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;' != ''";
-                var actual = expander.ExpandIntoStringAndUnescape(xmlattribute.Value, ExpanderOptions.ExpandAll | ExpanderOptions.Truncate, MockElementLocation.Instance);
-                // NOTE: semicolons in the last part are *weird* because they don't actually mean anything and you get logging like
-                //     Target "Build" skipped, due to false condition; ( '@(I->'%(nonexistent)')' == '' ) was evaluated as ( ';' == '' ).
-                // but that goes back to MSBuild 4.something so I'm codifying it in this test. If you're here because you cleaned it up
-                // and want to fix the test my current opinion is that's fine.
-                actual.ShouldBe(expected);
-                ChangeWaves.ResetStateForTests();
-            }
-        }
-
         /// <summary>
         /// Exercises ExpandAllIntoString with a string that does not need expanding.
         /// In this case the expanded string should be reference identical to the passed in string.
diff --git a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
index 73ba89b0e9b..2aa10111eeb 100644
--- a/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemEvaluation_Tests.cs
@@ -110,7 +110,7 @@ public void RemoveShouldPreserveIntermediaryReferences(string content)
                 {"m1", "m1_contents"},
                 {"m2", "m2_contents"}
             };
-            
+
             var itemsForI = items.Where(i => i.ItemType == "i").ToList();
             ObjectModelHelpers.AssertItems(new[] { "a", "b", "c" }, itemsForI, expectedMetadata);
 
@@ -508,7 +508,7 @@ public void MultipleInterItemDependenciesOnSameItemOperation()
                 new Dictionary<string, string>
                 {
                     {"m", "i2"}
-                }, 
+                },
                 i1BaseMetadata,
                 i1BaseMetadata
             };
@@ -528,7 +528,7 @@ public void MultipleInterItemDependenciesOnSameItemOperation()
         public void LongIncludeChain()
         {
             const int INCLUDE_COUNT = 10000;
-            
+
             //  This was about the minimum count needed to repro a StackOverflowException
             //const int INCLUDE_COUNT = 4000;
 
@@ -605,7 +605,7 @@ public void LazyWildcardExpansionDoesNotEvaluateWildCardsIfNotReferenced()
                 }
 
                 Assert.Equal(expectedItems, project.GetConcatenatedItemsOfType("i2"));
-                
+
                 var fullPathItems = project.GetConcatenatedItemsOfType("FullPath");
                 Assert.Contains("a.cs", fullPathItems);
                 Assert.Contains("b.cs", fullPathItems);
diff --git a/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
index 92794939793..f38192ebbb3 100644
--- a/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
@@ -60,7 +60,6 @@ public void Get_GivenOpenFuncWhichAddsRootElement_ReturnsRootElement()
             ProjectRootElement rootElementToCache = ProjectRootElement.Create(projectFileToCache);
             ProjectRootElement OpenFunc(string pathArg, ProjectRootElementCacheBase cacheArg)
             {
-                cacheArg.AddEntry(rootElementToCache);
                 return rootElementToCache;
             }
 
@@ -79,7 +78,6 @@ public void Get_GivenOpenFuncWhichAddsRootElementWithDifferentCasing_ReturnsRoot
             ProjectRootElement rootElementToCache = ProjectRootElement.Create(projectFileToCache);
             ProjectRootElement OpenFunc(string pathArg, ProjectRootElementCacheBase cacheArg)
             {
-                cacheArg.AddEntry(rootElementToCache);
                 return rootElementToCache;
             }
 
@@ -112,7 +110,6 @@ public void Get_GivenOpenFuncWhichReturnsIncorrectProject_ThrowsInternalErrorExc
             ProjectRootElement rootElementToCache = ProjectRootElement.Create(projectFileToCache);
             ProjectRootElement OpenFunc(string pathArg, ProjectRootElementCacheBase cacheArg)
             {
-                cacheArg.AddEntry(rootElementToCache);
                 return rootElementToCache;
             }
 
@@ -123,21 +120,5 @@ ProjectRootElement OpenFunc(string pathArg, ProjectRootElementCacheBase cacheArg
                 cache.Get(projectFile, OpenFunc, false, null);
             });
         }
-
-        [Fact]
-        public void Get_GivenOpenFuncWhichDoesNotAddToCache_ThrowsInternalErrorException()
-        {
-            string projectFile = NativeMethodsShared.IsUnixLike ? "/foo" : "c:\\foo";
-            string openFuncPath = NativeMethodsShared.IsUnixLike ? "/foo" : "c:\\foo";
-            ProjectRootElement openFuncElement = ProjectRootElement.Create(openFuncPath);
-            ProjectRootElement OpenFunc(string pathArg, ProjectRootElementCacheBase cacheArg) => openFuncElement;
-
-            var cache = new SimpleProjectRootElementCache();
-
-            Should.Throw<InternalErrorException>(() =>
-            {
-                cache.Get(projectFile, OpenFunc, false, null);
-            });
-        }
     }
 }
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
index c4f8ab84bea..d357c472750 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
@@ -326,20 +326,39 @@ public void GlobMatchingShouldWorkWithComplexRelativeLiterals()
         [InlineData(
             @"a/b\c",
             @"d/e\f/**\a.cs",
-            @"d\e/f\g/h\i/a.cs")]
+            @"d\e/f\g/h\i/a.cs",
+            @"d\e/f\", @"g/h\i/", @"a.cs")]
         [InlineData(
             @"a/b\c",
             @"d/e\f/*b*\*.cs",
-            @"d\e/f\abc/a.cs")]
+            @"d\e/f\abc/a.cs",
+            @"d\e/f\", @"abc/", @"a.cs")]
         [InlineData(
             @"a/b/\c",
             @"d/e\/*b*/\*.cs",
-            @"d\e\\abc/\a.cs")]
-        public void GlobMatchingIgnoresSlashOrientationAndRepetitions(string globRoot, string fileSpec, string stringToMatch)
+            @"d\e\\abc/\a.cs",
+            @"d\e\\", @"abc\\", @"a.cs")]
+        public void GlobMatchingIgnoresSlashOrientationAndRepetitions(string globRoot, string fileSpec, string stringToMatch,
+            string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart)
         {
             var glob = MSBuildGlob.Parse(globRoot, fileSpec);
 
             Assert.True(glob.IsMatch(stringToMatch));
+
+            MSBuildGlob.MatchInfoResult result = glob.MatchInfo(stringToMatch);
+            Assert.True(result.IsMatch);
+
+            string NormalizeSlashes(string path)
+            {
+                string normalizedPath = path.Replace(Path.DirectorySeparatorChar == '/' ? '\\' : '/', Path.DirectorySeparatorChar);
+                return NativeMethodsShared.IsWindows ? normalizedPath.Replace("\\\\", "\\") : normalizedPath;
+            }
+
+            var rootedFixedDirectoryPart = Path.Combine(FileUtilities.NormalizePath(globRoot), fixedDirectoryPart);
+
+            Assert.Equal(FileUtilities.GetFullPathNoThrow(rootedFixedDirectoryPart), result.FixedDirectoryPartMatchGroup);
+            Assert.Equal(NormalizeSlashes(wildcardDirectoryPart), result.WildcardDirectoryPartMatchGroup);
+            Assert.Equal(NormalizeSlashes(filenamePart), result.FilenamePartMatchGroup);
         }
     }
 }
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index c1f0161e91d..bed09d043ec 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -33,8 +33,6 @@ public GraphLoadedFromSolutionTests(ITestOutputHelper output)
         [InlineData("1.sln", "2.proj")]
         public void ASolutionShouldBeTheSingleEntryPoint(params string[] files)
         {
-            _env.DoNotLaunchDebugger();
-
             for (var i = 0; i < files.Length; i++)
             {
                 files[i] = _env.CreateFile(files[i], string.Empty).Path;
@@ -52,8 +50,6 @@ public void ASolutionShouldBeTheSingleEntryPoint(params string[] files)
         [Fact]
         public void GraphConstructionFailsOnNonExistentSolution()
         {
-            _env.DoNotLaunchDebugger();
-
             var exception = Should.Throw<InvalidProjectFileException>(
                 () =>
                 {
@@ -80,8 +76,6 @@ public void StaticGraphShouldNotSupportNestedSolutions()
                 defaultTargets: null,
                 extraContent: referenceToSolution);
 
-            _env.DoNotLaunchDebugger();
-
             var exception = Should.Throw<InvalidOperationException>(
                 () =>
                 {
@@ -621,8 +615,6 @@ IEnumerable<ProjectItemInstance> GetIncomingEdgeItemsToNode(ProjectGraphNode nod
         [Fact]
         public void GraphConstructionShouldThrowOnMissingSolutionDependencies()
         {
-            _env.DoNotLaunchDebugger();
-
             var solutionContents = SolutionFileBuilder.FromGraphEdges(
                 _env,
                 new Dictionary<int, int[]> {{1, null}, {2, null}},
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 548a25b3858..28af920a861 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -106,7 +106,6 @@ public void ConstructWithSingleNodeWithProjectInstanceFactory()
         [Fact]
         public void ProjectGraphNodeConstructorNoNullArguments()
         {
-            _env.DoNotLaunchDebugger();
             Assert.Throws<InternalErrorException>(() => new ProjectGraphNode(null));
         }
 
@@ -1477,12 +1476,21 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 edges,
-                new Dictionary<string, string> {{"a", "b"}});
+                globalProperties: new Dictionary<string, string> {{"a", "b"}},
+                createProjectFile: (env, projectId, references, _, _, _) => Helpers.CreateProjectFile(
+                    env,
+                    projectId,
+                    references,
+                    projectReferenceTargets: new Dictionary<string, string[]>
+                    {
+                        {"Build", new[] {$"TargetFrom{projectId}", "Build"}}
+                    }));
 
+            var targetsPerNode = graph.GetTargetLists(new []{ "Build" });
 
             Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;
 
-            var dot = graph.ToDot(nodeIdProvider);
+            var dot = graph.ToDot(nodeIdProvider, targetsPerNode);
 
             var edgeCount = 0;
 
@@ -1490,9 +1498,12 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             {
                 var nodeId = nodeIdProvider(node);
 
+                var targets = string.Join(".*", targetsPerNode[node]);
+                targets.ShouldNotBeNullOrEmpty();
+
                 foreach (var globalProperty in node.ProjectInstance.GlobalProperties)
                 {
-                    dot.ShouldMatch($@"{nodeId}\s*\[.*{globalProperty.Key}.*{globalProperty.Value}.*\]");
+                    dot.ShouldMatch($@"{nodeId}\s*\[.*{targets}.*{globalProperty.Key}.*{globalProperty.Value}.*\]");
                 }
 
                 foreach (var reference in node.ProjectReferences)
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index 0bd541928cd..318d56ef351 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -245,7 +245,7 @@ public void TestContradictoryAffinityCausesException_Any()
         /// Test which ensures that setting an Any affinity for a project with a remote host object does not throws.
         /// </summary>
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "disable com tests on mono")]
+        [SkipOnMono("disable com tests on mono")]
         public void TestNoContradictoryRemoteHostObjectAffinity()
         {
             HostServices hostServices = new HostServices();
@@ -301,7 +301,7 @@ public void TestNonContraditcoryHostObjectAllowed_Any()
         /// Test which ensures the remote host object cannot affect a project which has the Any affinity specifically set.
         /// </summary>
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "disable com tests on mono")]
+        [SkipOnMono("disable com tests on mono")]
         public void TestRegisterRemoteHostObjectNoAffect_Any2()
         {
             HostServices hostServices = new HostServices();
@@ -341,7 +341,7 @@ public void TestNonContraditcoryHostObjectAllowed_InProc()
         /// Test which ensures the affinity for a project can be changed once the in process host object is registered
         /// </summary>
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "disable com tests on mono")]
+        [SkipOnMono("disable com tests on mono")]
         public void TestAffinityChangeAfterRegisterInprocessHostObject()
         {
             HostServices hostServices = new HostServices();
@@ -452,7 +452,7 @@ public void UnloadedProjectDiscardsHostServices()
         /// Tests that register overrides existing reigsted remote host object.
         /// </summary>
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "disable com tests on mono")]
+        [SkipOnMono("disable com tests on mono")]
         public void TestRegisterOverrideExistingRegisted()
         {
             var hostServices = new HostServices();
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 004c7e50289..fce4c51b159 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -233,6 +233,30 @@ public enum ErrorKind
             LoggedError
         }
 
+        public class ConfigurableMockCache : ProjectCachePluginBase
+        {
+            public Func<BuildRequestData, PluginLoggerBase, CancellationToken, Task<CacheResult>>? GetCacheResultImplementation { get; set; }
+            public override Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken)
+            {
+                return Task.CompletedTask;
+            }
+
+            public override Task<CacheResult> GetCacheResultAsync(
+                BuildRequestData buildRequest,
+                PluginLoggerBase logger,
+                CancellationToken cancellationToken)
+            {
+                return GetCacheResultImplementation != null
+                    ? GetCacheResultImplementation(buildRequest, logger, cancellationToken)
+                    : Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
+            }
+
+            public override Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken)
+            {
+                return Task.CompletedTask;
+            }
+        }
+
         public class InstanceMockCache : ProjectCachePluginBase
         {
             private readonly GraphCacheResponse? _testData;
@@ -272,6 +296,8 @@ public override async Task<CacheResult> GetCacheResultAsync(
 
                 logger.LogMessage($"MockCache: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
 
+                buildRequest.ProjectInstance.ShouldNotBeNull("The cache plugin expects evaluated projects.");
+
                 if (_projectQuerySleepTime is not null)
                 {
                     await Task.Delay(_projectQuerySleepTime.Value);
@@ -430,10 +456,14 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
             var graph = testData.CreateGraph(_env);
             var mockCache = new InstanceMockCache(testData);
 
-            buildParameters.ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
-                mockCache,
-                null,
-                graph);
+            // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
+            buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                    mockCache,
+                    null,
+                    graph)
+            };
 
             using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
 
@@ -460,7 +490,12 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
                 null,
                 graph);
 
-            buildParameters.ProjectCacheDescriptor = projectCacheDescriptor;
+            // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
+            buildParameters = new BuildParameters(buildParameters, resetEnvironment: true)
+            {
+                ProjectCacheDescriptor = projectCacheDescriptor
+            };
+
 
             using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
             var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
@@ -497,6 +532,9 @@ public void ProjectCacheByVsWorkaroundWorks(GraphCacheResponse testData, BuildPa
                         runningInVisualStudio: true,
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
+                // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
+                buildParameters = new BuildParameters(buildParameters, resetEnvironment: true);
+
                 BuildManager.ProjectCacheItems.ShouldBeEmpty();
 
                 var graph = testData.CreateGraph(_env);
@@ -519,6 +557,7 @@ public void ProjectCacheByVsWorkaroundWorks(GraphCacheResponse testData, BuildPa
                 }
 
                 buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
+                buildSession.Logger.FullLog.ShouldContain("Running project cache with Visual Studio workaround");
 
                 AssertCacheBuild(graph, testData, null, buildSession.Logger, nodesToBuildResults);
             }
@@ -584,6 +623,9 @@ public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
 
                 buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
 
+                // Design time builds should not initialize the plugin.
+                buildSession.Logger.FullLog.ShouldNotContain("Running project cache with Visual Studio workaround");
+
                 // Cache doesn't get initialized and queried.
                 buildSession.Logger.FullLog.ShouldNotContain("BeginBuildAsync");
                 buildSession.Logger.FullLog.ShouldNotContain("GetCacheResultAsync for");
@@ -905,8 +947,6 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
         [Fact]
         public void GraphBuildErrorsIfMultiplePluginsAreFound()
         {
-            _env.DoNotLaunchDebugger();
-
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 new Dictionary<int, int[]>
@@ -931,8 +971,6 @@ public void GraphBuildErrorsIfMultiplePluginsAreFound()
         [Fact]
         public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
         {
-            _env.DoNotLaunchDebugger();
-
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 dependencyEdges: new Dictionary<int, int[]>
@@ -985,8 +1023,6 @@ public static IEnumerable<object[]> CacheExceptionLocationsTestData
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorLocations errorLocations, ErrorKind errorKind)
         {
-            _env.DoNotLaunchDebugger();
-
             SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
 
             var project = _env.CreateFile("1.proj", @$"
@@ -1106,8 +1142,6 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocations errorLocations, ErrorKind errorKind)
         {
-            _env.DoNotLaunchDebugger();
-
             SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
 
             var graph = Helpers.CreateProjectGraph(
@@ -1195,8 +1229,6 @@ public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocati
         [Fact]
         public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
         {
-            _env.DoNotLaunchDebugger();
-
             var project = _env.CreateFile(
                 "1.proj",
                 @$"
@@ -1316,6 +1348,83 @@ Task<BuildResult> BuildProjectFileAsync(int projectNumber)
             }
         }
 
+        [Theory]
+        [InlineData(false, false)]
+        // TODO: Reenable when this gets into the main branch.
+        //[InlineData(true, true)]
+        public void ParallelStressTestForVsWorkaround(bool useSynchronousLogging, bool disableInprocNode)
+        {
+            var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
+
+            try
+            {
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(
+                    new BuildEnvironment(
+                        currentBuildEnvironment.Mode,
+                        currentBuildEnvironment.CurrentMSBuildExePath,
+                        currentBuildEnvironment.RunningTests,
+                        runningInVisualStudio: true,
+                        visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
+
+                BuildManager.ProjectCacheItems.ShouldBeEmpty();
+
+                var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount() * 2).ToArray();
+
+                var testData = new GraphCacheResponse(
+                    new Dictionary<int, int[]>
+                    {
+                        {1, referenceNumbers}
+                    },
+                    referenceNumbers.ToDictionary(k => k, k => GraphCacheResponse.SuccessfulProxyTargetResult())
+                );
+
+                var graph = testData.CreateGraph(_env);
+
+                // Even though the assembly cache is discovered, we'll be overriding it with a descriptor based cache.
+                BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
+
+                using var buildSession = new Helpers.BuildManagerSession(_env, new BuildParameters
+                {
+                    MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
+                    UseSynchronousLogging = useSynchronousLogging,
+                    DisableInProcNode = disableInprocNode
+                });
+
+                var buildResultTasks = new List<Task<BuildResult>>();
+
+                foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
+                {
+                    var buildResultTask = buildSession.BuildProjectFileAsync(
+                        node.ProjectInstance.FullPath,
+                        globalProperties:
+                        new Dictionary<string, string> { { "SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath } });
+
+                    buildResultTasks.Add(buildResultTask);
+                }
+
+                foreach (var buildResultTask in buildResultTasks)
+                {
+                    buildResultTask.Result.OverallResult.ShouldBe(BuildResultCode.Success);
+                }
+
+                buildSession.BuildProjectFile(
+                        graph.GraphRoots.First().ProjectInstance.FullPath,
+                        globalProperties:
+                        new Dictionary<string, string> {{"SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath}})
+                    .OverallResult.ShouldBe(BuildResultCode.Success);
+
+                StringShouldContainSubstring(buildSession.Logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
+
+                buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
+                buildSession.Logger.FullLog.ShouldContain("Running project cache with Visual Studio workaround");
+            }
+            finally
+            {
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly(currentBuildEnvironment);
+                BuildManager.ProjectCacheItems.Clear();
+            }
+        }
+
         [Theory]
         [InlineData(false, false)]
         [InlineData(true, true)]
@@ -1351,6 +1460,97 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
             cache.QueryStartStops.Count.ShouldBe(graph.ProjectNodes.Count * 2);
         }
 
+        [Fact]
+        // Schedules different requests for the same BuildRequestConfiguration in parallel.
+        // The first batch of the requests are cache misses, the second batch are cache hits via proxy builds.
+        // The first batch is delayed so it starts intermingling with the second batch.
+        // This test ensures that scheduling proxy builds on the inproc node works nicely within the Scheduler
+        // if the BuildRequestConfigurations for those proxy builds have built before (or are still building) on
+        // the out of proc node.
+        // More details: https://github.com/dotnet/msbuild/pull/6635 
+        public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
+        {
+            var cacheNotApplicableTarget = "NATarget";
+            var cacheHitTarget = "CacheHitTarget";
+            var proxyTarget = "ProxyTarget";
+
+            var project =
+@$"
+<Project>
+    <Target Name='{cacheNotApplicableTarget}'>
+        <Exec Command=`{Helpers.GetSleepCommand(TimeSpan.FromMilliseconds(200))}` />
+        <Message Text='{cacheNotApplicableTarget} in $(MSBuildThisFile)' />
+    </Target>
+
+    <Target Name='{cacheHitTarget}'>
+        <Message Text='{cacheHitTarget} in $(MSBuildThisFile)' />
+    </Target>
+
+    <Target Name='{proxyTarget}'>
+        <Message Text='{proxyTarget} in $(MSBuildThisFile)' />
+    </Target>
+</Project>
+".Cleanup();
+
+            var projectPaths = Enumerable.Range(0, NativeMethodsShared.GetLogicalCoreCount())
+                .Select(i => _env.CreateFile($"project{i}.proj", project).Path)
+                .ToArray();
+
+            var cacheHitCount = 0;
+            var nonCacheHitCount = 0;
+
+            var buildParameters = new BuildParameters
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
+                    new ConfigurableMockCache
+                    {
+                        GetCacheResultImplementation = (request, _, _) =>
+                        {
+                            var projectFile = request.ProjectFullPath;
+
+                            if (request.TargetNames.Contains(cacheNotApplicableTarget))
+                            {
+                                Interlocked.Increment(ref nonCacheHitCount);
+                                return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
+                            }
+                            else
+                            {
+                                Interlocked.Increment(ref cacheHitCount);
+                                return Task.FromResult(
+                                    CacheResult.IndicateCacheHit(
+                                        new ProxyTargets(new Dictionary<string, string> {{proxyTarget, cacheHitTarget}})));
+                            }
+                        }
+                    },
+                    projectPaths.Select(p => new ProjectGraphEntryPoint(p)).ToArray(),
+                    projectGraph: null),
+                MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount()
+            };
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+
+            var buildRequests = new List<(string, string)>();
+            buildRequests.AddRange(projectPaths.Select(r => (r, cacheNotApplicableTarget)));
+            buildRequests.AddRange(projectPaths.Select(r => (r, cacheHitTarget)));
+
+            var buildTasks = new List<Task<BuildResult>>();
+            foreach (var (projectPath, target) in buildRequests)
+            {
+                buildTasks.Add(buildSession.BuildProjectFileAsync(projectPath, new[] {target}));
+            }
+
+            foreach (var buildResult in buildTasks.Select(buildTask => buildTask.Result))
+            {
+                buildResult.Exception.ShouldBeNull();
+                buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+            }
+
+            buildSession.Logger.ProjectStartedEvents.Count.ShouldBe(2 * projectPaths.Length);
+
+            cacheHitCount.ShouldBe(projectPaths.Length);
+            nonCacheHitCount.ShouldBe(projectPaths.Length);
+        }
+
         private static void StringShouldContainSubstring(string aString, string substring, int expectedOccurrences)
         {
             aString.ShouldContain(substring);
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index c624af051ac..61adb110cf1 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -30,7 +30,9 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Utilities;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
@@ -486,7 +488,7 @@ public void BeginBuild(BuildParameters parameters)
             ILoggingService InitializeLoggingService()
             {
                 ILoggingService loggingService = CreateLoggingService(
-                    _buildParameters.Loggers,
+                    AppendDebuggingLoggers(_buildParameters.Loggers),
                     _buildParameters.ForwardingLoggers,
                     _buildParameters.WarningsAsErrors,
                     _buildParameters.WarningsAsMessages);
@@ -518,6 +520,22 @@ ILoggingService InitializeLoggingService()
                 return loggingService;
             }
 
+            // VS builds discard many msbuild events so attach a binlogger to capture them all.
+            IEnumerable<ILogger> AppendDebuggingLoggers(IEnumerable<ILogger> loggers)
+            {
+                if (DebugUtils.ShouldDebugCurrentProcess is false ||
+                    Traits.Instance.DebugEngine is false)
+                {
+                    return loggers;
+                }
+
+                var binlogPath = DebugUtils.FindNextAvailableDebugFilePath($"{DebugUtils.ProcessInfoString}_BuildManager_{_hostName}.binlog");
+
+                var logger = new BinaryLogger { Parameters = binlogPath };
+
+                return (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[] { logger });
+            }
+
             void InitializeCaches()
             {
                 Debug.Assert(Monitor.IsEntered(_syncLock));
@@ -561,17 +579,14 @@ void InitializeCaches()
             }
         }
 
-        private void AttachDebugger()
+        private static void AttachDebugger()
         {
             if (Debugger.IsAttached)
             {
                 return;
             }
 
-            var processNameToBreakInto = Environment.GetEnvironmentVariable("MSBuildDebugBuildManagerOnStartProcessName");
-            var thisProcessMatchesName = string.IsNullOrWhiteSpace(processNameToBreakInto) || Process.GetCurrentProcess().ProcessName.Contains(processNameToBreakInto);
-
-            if (!thisProcessMatchesName)
+            if (!DebugUtils.ShouldDebugCurrentProcess)
             {
                 return;
             }
@@ -1757,11 +1772,17 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                 if (submission.BuildRequestData.GraphBuildOptions.Build)
                 {
                     var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
-                    var targetListTask = Task.Run(() => projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames));
+                    var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
+
+                    DumpGraph(projectGraph, targetListTask);
 
                     using DisposablePluginService cacheService = cacheServiceTask.Result;
 
-                    resultsPerNode = BuildGraph(projectGraph, targetListTask.Result, submission.BuildRequestData);
+                    resultsPerNode = BuildGraph(projectGraph, targetListTask, submission.BuildRequestData);
+                }
+                else
+                {
+                    DumpGraph(projectGraph);
                 }
 
                 ErrorUtilities.VerifyThrow(
@@ -1825,6 +1846,18 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     _overallBuildSuccess = false;
                 }
             }
+
+            static void DumpGraph(ProjectGraph graph, IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetList = null)
+            {
+                if (Traits.Instance.DebugEngine is false)
+                {
+                    return;
+                }
+
+                var logPath = DebugUtils.FindNextAvailableDebugFilePath($"{DebugUtils.ProcessInfoString}_ProjectGraph.dot");
+
+                File.WriteAllText(logPath, graph.ToDot(targetList));
+            }
         }
 
         private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
@@ -3080,7 +3113,7 @@ private void CancelAndMarkAsFailure()
         /// <summary>
         /// The logger registered to the logging service when no other one is.
         /// </summary>
-        private class NullLogger : ILogger
+        internal class NullLogger : ILogger
         {
             #region ILogger Members
 
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 1259648e255..93d21956172 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -253,7 +253,7 @@ private BuildParameters(ITranslator translator)
         /// <summary>
         /// Copy constructor
         /// </summary>
-        private BuildParameters(BuildParameters other)
+        internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
         {
             ErrorUtilities.VerifyThrowInternalNull(other, nameof(other));
 
@@ -261,7 +261,11 @@ private BuildParameters(BuildParameters other)
             _culture = other._culture;
             _defaultToolsVersion = other._defaultToolsVersion;
             _enableNodeReuse = other._enableNodeReuse;
-            _buildProcessEnvironment = other._buildProcessEnvironment != null ? new Dictionary<string, string>(other._buildProcessEnvironment) : null;
+            _buildProcessEnvironment = resetEnvironment
+                ? CommunicationsUtilities.GetEnvironmentVariables()
+                : other._buildProcessEnvironment != null
+                    ? new Dictionary<string, string>(other._buildProcessEnvironment)
+                    : null;
             _environmentProperties = other._environmentProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._environmentProperties) : null;
             _forwardingLoggers = other._forwardingLoggers != null ? new List<ForwardingLoggerRecord>(other._forwardingLoggers) : null;
             _globalProperties = other._globalProperties != null ? new PropertyDictionary<ProjectPropertyInstance>(other._globalProperties) : null;
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index 4ac2ae28805..8bce00b3a26 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -79,7 +79,7 @@ public static (IConfigCache ConfigCache, IResultsCache ResultsCache, Exception e
 
                 using (var fileStream = File.OpenRead(inputCacheFile))
                 {
-                    var translator = BinaryTranslator.GetReadTranslator(fileStream, null);
+                    using var translator = BinaryTranslator.GetReadTranslator(fileStream, null);
 
                     translator.Translate(ref configCache);
                     translator.Translate(ref resultsCache);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 1038643d11f..2dbcd31ea0e 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -12,6 +12,8 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
+using Microsoft.Build.Utilities;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 namespace Microsoft.Build.BackEnd
@@ -115,8 +117,10 @@ internal class BuildRequestEngine : IBuildRequestEngine, IBuildComponent
         /// </summary>
         internal BuildRequestEngine()
         {
-            _debugDumpState = Environment.GetEnvironmentVariable("MSBUILDDEBUGSCHEDULER") == "1";
-            _debugDumpPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            _debugDumpState = Traits.Instance.DebugScheduler;
+            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
+                ? DebugUtils.DebugPath
+                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
             _debugForceCaching = Environment.GetEnvironmentVariable("MSBUILDDEBUGFORCECACHING") == "1";
 
             if (String.IsNullOrEmpty(_debugDumpPath))
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 86d4e070d33..096fb99283f 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -207,6 +207,15 @@ bool IncludeTaskInputs
             set;
         }
 
+        /// <summary>
+        /// Returns the minimum logging importance that must be logged because there is a possibility that
+        /// at least one registered logger consumes it.
+        /// </summary>
+        MessageImportance MinimumRequiredMessageImportance
+        {
+            get;
+        }
+
         #endregion
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index eb11739f920..163a6d4fc62 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -222,6 +222,12 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// </summary>
         private IDictionary<int, ISet<string>> _warningsAsMessagesByProject;
 
+        /// <summary>
+        /// The minimum message importance that must be logged because there is a possibility that a logger consumes it.
+        /// Null means that the optimization is disabled or no relevant logger has been registered.
+        /// </summary>
+        private MessageImportance? _minimumRequiredMessageImportance;
+
         #region LoggingThread Data
 
         /// <summary>
@@ -702,6 +708,19 @@ public ICollection<string> RegisteredSinkNames
             }
         }
 
+        /// <summary>
+        /// Returns the minimum logging importance that must be logged because there is a possibility that
+        /// at least one registered logger consumes it.
+        /// </summary>
+        public MessageImportance MinimumRequiredMessageImportance
+        {
+            get
+            {
+                // If we haven't set the field return the default of "all messages must be logged".
+                return _minimumRequiredMessageImportance ?? MessageImportance.Low;
+            }
+        }
+
         #endregion
 
         #region Members
@@ -1120,7 +1139,7 @@ public void LogBuildEvent(BuildEventArgs buildEvent)
         #endregion
 
         /// <summary>
-        /// This method will becalled from multiple threads in asynchronous mode.
+        /// This method will be called from multiple threads in asynchronous mode.
         ///
         /// Determine where to send the buildevent either to the filters or to a specific sink.
         /// When in Asynchronous mode the event should to into the logging queue (as long as we are initialized).
@@ -1553,10 +1572,57 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)
                 InternalLoggerException.Throw(e, null, "FatalErrorWhileInitializingLogger", true, logger.GetType().Name);
             }
 
+            // Update the minimum guaranteed message importance based on the newly added logger.
+            UpdateMinimumMessageImportance(logger);
+
             // Keep track of the loggers so they can be unregistered later on
             _loggers.Add(logger);
         }
 
+        /// <summary>
+        /// Updates <see cref="_minimumRequiredMessageImportance"/> based on the given <paramref name="logger"/>.
+        /// </summary>
+        /// <param name="logger">The newly registered logger.</param>
+        /// <remarks>
+        /// This method contains knowledge about several logger classes used by MSBuild. The goal is to optimize common scenarios,
+        /// such as building on the command line with normal or minimum verbosity. If the user registers an external custom logger,
+        /// we will fall back to "minimum importance" == Low because we don't know how the logger processes messages, therefore we
+        /// must feed it everything.
+        /// </remarks>
+        private void UpdateMinimumMessageImportance(ILogger logger)
+        {
+            var innerLogger = (logger is Evaluation.ProjectCollection.ReusableLogger reusableLogger) ? reusableLogger.OriginalLogger : logger;
+
+            MessageImportance? minimumImportance = innerLogger switch
+            {
+                Build.Logging.ConsoleLogger consoleLogger => consoleLogger.GetMinimumMessageImportance(),
+                Build.Logging.ConfigurableForwardingLogger forwardingLogger => forwardingLogger.GetMinimumMessageImportance(),
+
+                // Central forwarding loggers are used in worker nodes if logging verbosity could not be optimized, i.e. in cases
+                // where we must log everything. They can be ignored in inproc nodes.
+                CentralForwardingLogger => (_nodeId > 1 ? MessageImportance.Low : null),
+
+                // The null logger has no effect on minimum verbosity.
+                Execution.BuildManager.NullLogger => null,
+
+                // If the logger is not on our whitelist, there are no importance guarantees. Fall back to "any importance".
+                _ => MessageImportance.Low
+            };
+
+            if (minimumImportance != null)
+            {
+                if (_minimumRequiredMessageImportance == null)
+                {
+                    _minimumRequiredMessageImportance = minimumImportance;
+                }
+                else
+                {
+                    int newMinImportance = Math.Max((int)_minimumRequiredMessageImportance, (int)minimumImportance);
+                    _minimumRequiredMessageImportance = (MessageImportance)newMinImportance;
+                }
+            }
+        }
+
         /// <summary>
         /// When an exception is raised in the logging thread, we do not want the application to terminate right away.
         /// Whidbey and orcas msbuild have the logger exceptions occurring on the engine thread so that the host can
@@ -1609,8 +1675,7 @@ private void TryRaiseProjectFinishedEvent(BuildEventArgs args)
         /// </summary>
         private string GetAndVerifyProjectFileFromContext(BuildEventContext context)
         {
-            string projectFile;
-            _projectFileMap.TryGetValue(context.ProjectContextId, out projectFile);
+            _projectFileMap.TryGetValue(context.ProjectContextId, out string projectFile);
 
             // PERF: Not using VerifyThrow to avoid boxing an int in the non-error case.
             if (projectFile == null)
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 846c0b3a643..4c5e5934c83 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -135,7 +135,12 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 properties,
                 items,
                 evaluationId);
-            LoggingService.LogComment(this.BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", toolsVersion);
+
+            // No need to log a redundant message in the common case
+            if (toolsVersion != "Current")
+            {
+                LoggingService.LogComment(this.BuildEventContext, MessageImportance.Low, "ToolsVersionInEffectForBuild", toolsVersion);
+            }
 
             this.IsValid = true;
         }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 4d6ad7af480..bf7b0033794 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -4,6 +4,7 @@
 #nullable enable
 using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Linq;
 using System.Reflection;
 using System.Threading;
@@ -27,6 +28,15 @@ internal record NullableBool(bool Value)
         public static implicit operator bool(NullableBool? d) => d is not null && d.Value;
     }
 
+    internal enum ProjectCacheServiceState
+    {
+        NotInitialized,
+        BeginBuildStarted,
+        BeginBuildFinished,
+        ShutdownStarted,
+        ShutdownFinished
+    }
+
     internal class ProjectCacheService
     {
         private readonly BuildManager _buildManager;
@@ -34,6 +44,7 @@ internal class ProjectCacheService
         private readonly ProjectCacheDescriptor _projectCacheDescriptor;
         private readonly CancellationToken _cancellationToken;
         private readonly ProjectCachePluginBase _projectCachePlugin;
+        private ProjectCacheServiceState _serviceState = ProjectCacheServiceState.NotInitialized;
 
         /// <summary>
         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
@@ -46,6 +57,7 @@ private sealed class DefaultMSBuildFileSystem : MSBuildFileSystemBase { }
         // Volatile because it is read by the BuildManager thread and written by one project cache service thread pool thread.
         // TODO: remove after we change VS to set the cache descriptor via build parameters.
         public volatile NullableBool? DesignTimeBuildsDetected;
+        private TaskCompletionSource<bool>? LateInitializationForVSWorkaroundCompleted;
 
         private ProjectCacheService(
             ProjectCachePluginBase projectCachePlugin,
@@ -75,39 +87,51 @@ public static async Task<ProjectCacheService> FromDescriptorAsync(
             // their verbosity levels.
             var loggerFactory = new Func<PluginLoggerBase>(() => new LoggingServiceToPluginLoggerAdapter(LoggerVerbosity.Normal, loggingService));
 
-            // TODO: remove after we change VS to set the cache descriptor via build parameters.
-            if (pluginDescriptor.VsWorkaround)
+            var service = new ProjectCacheService(plugin, buildManager, loggerFactory, pluginDescriptor, cancellationToken);
+
+            // TODO: remove the if after we change VS to set the cache descriptor via build parameters and always call BeginBuildAsync in FromDescriptorAsync.
+            // When running under VS we can't initialize the plugin until we evaluate a project (any project) and extract
+            // further information (set by VS) from it required by the plugin.
+            if (!pluginDescriptor.VsWorkaround)
             {
-                // When running under VS we can't initialize the plugin until we evaluate a project (any project) and extract
-                // further information (set by VS) from it required by the plugin.
-                return new ProjectCacheService(plugin, buildManager, loggerFactory, pluginDescriptor, cancellationToken);
+                await service.BeginBuildAsync();
             }
 
-            await InitializePlugin(pluginDescriptor, cancellationToken, loggerFactory, plugin);
-
-            return new ProjectCacheService(plugin, buildManager, loggerFactory, pluginDescriptor, cancellationToken);
+            return service;
         }
 
-        private static async Task InitializePlugin(
-            ProjectCacheDescriptor pluginDescriptor,
-            CancellationToken cancellationToken,
-            Func<PluginLoggerBase> loggerFactory,
-            ProjectCachePluginBase plugin
-        )
+        // TODO: remove vsWorkaroundOverrideDescriptor after we change VS to set the cache descriptor via build parameters.
+        private async Task BeginBuildAsync(ProjectCacheDescriptor? vsWorkaroundOverrideDescriptor = null)
         {
-            var logger = loggerFactory();
+            var logger = _loggerFactory();
 
             try
             {
-                await plugin.BeginBuildAsync(
+                SetState(ProjectCacheServiceState.BeginBuildStarted);
+
+                logger.LogMessage("Initializing project cache plugin", MessageImportance.Low);
+                var timer = Stopwatch.StartNew();
+
+                if (_projectCacheDescriptor.VsWorkaround)
+                {
+                    logger.LogMessage("Running project cache with Visual Studio workaround");
+                }
+
+                var projectDescriptor = vsWorkaroundOverrideDescriptor ?? _projectCacheDescriptor;
+                await _projectCachePlugin.BeginBuildAsync(
                     new CacheContext(
-                        pluginDescriptor.PluginSettings,
+                        projectDescriptor.PluginSettings,
                         new DefaultMSBuildFileSystem(),
-                        pluginDescriptor.ProjectGraph,
-                        pluginDescriptor.EntryPoints),
+                        projectDescriptor.ProjectGraph,
+                        projectDescriptor.EntryPoints),
                     // TODO: Detect verbosity from logging service.
                     logger,
-                    cancellationToken);
+                    _cancellationToken);
+
+                timer.Stop();
+                logger.LogMessage($"Finished initializing project cache plugin in {timer.Elapsed.TotalMilliseconds} ms", MessageImportance.Low);
+
+                SetState(ProjectCacheServiceState.BeginBuildFinished);
             }
             catch (Exception e)
             {
@@ -215,13 +239,20 @@ async Task<CacheResult> ProcessCacheRequest(CacheRequest request)
 
                 EvaluateProjectIfNecessary(request);
 
+                // Detect design time builds.
                 if (_projectCacheDescriptor.VsWorkaround)
                 {
-                    Interlocked.CompareExchange(
+                    var isDesignTimeBuild = IsDesignTimeBuild(request.Configuration.Project);
+
+                    var previousValue = Interlocked.CompareExchange(
                         ref DesignTimeBuildsDetected,
-                        new NullableBool(IsDesignTimeBuild(request.Configuration.Project)),
+                        new NullableBool(isDesignTimeBuild),
                         null);
 
+                    ErrorUtilities.VerifyThrowInternalError(
+                        previousValue is null || previousValue == false || isDesignTimeBuild,
+                        "Either all builds in a build session or design time builds, or none");
+
                     // No point progressing with expensive plugin initialization or cache query if design time build detected.
                     if (DesignTimeBuildsDetected)
                     {
@@ -230,13 +261,35 @@ async Task<CacheResult> ProcessCacheRequest(CacheRequest request)
                     }
                 }
 
+                // TODO: remove after we change VS to set the cache descriptor via build parameters.
+                // VS workaround needs to wait until the first project is evaluated to extract enough information to initialize the plugin.
+                // No cache request can progress until late initialization is complete.
                 if (_projectCacheDescriptor.VsWorkaround)
                 {
-                    // TODO: remove after we change VS to set the cache descriptor via build parameters.
-                    await LateInitializePluginForVsWorkaround(request);
+                    if (Interlocked.CompareExchange(
+                            ref LateInitializationForVSWorkaroundCompleted,
+                            new TaskCompletionSource<bool>(),
+                            null) is null)
+                    {
+                        await LateInitializePluginForVsWorkaround(request);
+                        LateInitializationForVSWorkaroundCompleted.SetResult(true);
+                    }
+                    else
+                    {
+                        // Can't be null. If the thread got here it means another thread initialized the completion source.
+                        await LateInitializationForVSWorkaroundCompleted!.Task;
+                    }
                 }
 
-                return await GetCacheResultAsync(cacheRequest.Submission.BuildRequestData);
+                ErrorUtilities.VerifyThrowInternalError(
+                    LateInitializationForVSWorkaroundCompleted is null ||
+                    _projectCacheDescriptor.VsWorkaround && LateInitializationForVSWorkaroundCompleted.Task.IsCompleted,
+                    "Completion source should be null when this is not the VS workaround");
+
+                return await GetCacheResultAsync(
+                    new BuildRequestData(
+                        request.Configuration.Project,
+                        request.Submission.BuildRequestData.TargetNames.ToArray()));
             }
 
             static bool IsDesignTimeBuild(ProjectInstance project)
@@ -284,7 +337,7 @@ async Task LateInitializePluginForVsWorkaround(CacheRequest request)
                     FileSystems.Default.FileExists(solutionPath),
                     $"Solution file does not exist: {solutionPath}");
 
-                await InitializePlugin(
+                await BeginBuildAsync(
                     ProjectCacheDescriptor.FromAssemblyPath(
                         _projectCacheDescriptor.PluginAssemblyPath!,
                         new[]
@@ -294,10 +347,7 @@ await InitializePlugin(
                                 configuration.Project.GlobalProperties)
                         },
                         projectGraph: null,
-                        _projectCacheDescriptor.PluginSettings),
-                    _cancellationToken,
-                    _loggerFactory,
-                    _projectCachePlugin);
+                        _projectCacheDescriptor.PluginSettings));
             }
 
             static bool MSBuildStringIsTrue(string msbuildString) =>
@@ -306,6 +356,19 @@ static bool MSBuildStringIsTrue(string msbuildString) =>
 
         private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest)
         {
+            lock (this)
+            {
+                CheckNotInState(ProjectCacheServiceState.NotInitialized);
+                CheckNotInState(ProjectCacheServiceState.BeginBuildStarted);
+
+                if (_serviceState is ProjectCacheServiceState.ShutdownStarted or ProjectCacheServiceState.ShutdownFinished)
+                {
+                    return CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable);
+                }
+            }
+			
+            ErrorUtilities.VerifyThrowInternalNull(buildRequest.ProjectInstance, nameof(buildRequest.ProjectInstance));
+
             var queryDescription = $"{buildRequest.ProjectFullPath}" +
                                    $"\n\tTargets:[{string.Join(", ", buildRequest.TargetNames)}]" +
                                    $"\n\tGlobal Properties: {{{string.Join(",", buildRequest.GlobalProperties.Select(kvp => $"{kvp.Name}={kvp.EvaluatedValue}"))}}}";
@@ -361,16 +424,28 @@ public async Task ShutDown()
 
             try
             {
+                SetState(ProjectCacheServiceState.ShutdownStarted);
+
+                logger.LogMessage("Shutting down project cache plugin", MessageImportance.Low);
+                var timer = Stopwatch.StartNew();
+
                 await _projectCachePlugin.EndBuildAsync(logger, _cancellationToken);
+
+                timer.Stop();
+                logger.LogMessage($"Finished shutting down project cache plugin in {timer.Elapsed.TotalMilliseconds} ms", MessageImportance.Low);
+
+                if (logger.HasLoggedErrors)
+                {
+                    ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
+                }
             }
-            catch (Exception e)
+            catch (Exception e) when (e is not ProjectCacheException)
             {
                 HandlePluginException(e, nameof(ProjectCachePluginBase.EndBuildAsync));
             }
-
-            if (logger.HasLoggedErrors)
+            finally
             {
-                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheShutdownFailed");
+                SetState(ProjectCacheServiceState.ShutdownFinished);
             }
         }
 
@@ -387,6 +462,52 @@ private static void HandlePluginException(Exception e, string apiExceptionWasThr
                 apiExceptionWasThrownFrom);
         }
 
+        private void SetState(ProjectCacheServiceState newState)
+        {
+            lock (this)
+            {
+                switch (newState)
+                {
+                    case ProjectCacheServiceState.NotInitialized:
+                        ErrorUtilities.ThrowInternalError($"Cannot transition to {ProjectCacheServiceState.NotInitialized}");
+                        break;
+                    case ProjectCacheServiceState.BeginBuildStarted:
+                        CheckInState(ProjectCacheServiceState.NotInitialized);
+                        break;
+                    case ProjectCacheServiceState.BeginBuildFinished:
+                        CheckInState(ProjectCacheServiceState.BeginBuildStarted);
+                        break;
+                    case ProjectCacheServiceState.ShutdownStarted:
+                        CheckNotInState(ProjectCacheServiceState.ShutdownStarted);
+                        CheckNotInState(ProjectCacheServiceState.ShutdownFinished);
+                        break;
+                    case ProjectCacheServiceState.ShutdownFinished:
+                        CheckInState(ProjectCacheServiceState.ShutdownStarted);
+                        break;
+                    default:
+                        throw new ArgumentOutOfRangeException(nameof(newState), newState, null);
+                }
+
+                _serviceState = newState;
+            }
+        }
+
+        private void CheckInState(ProjectCacheServiceState expectedState)
+        {
+            lock (this)
+            {
+                ErrorUtilities.VerifyThrowInternalError(_serviceState == expectedState, $"Expected state {expectedState}, actual state {_serviceState}");
+            }
+        }
+
+        private void CheckNotInState(ProjectCacheServiceState unexpectedState)
+        {
+            lock (this)
+            {
+                ErrorUtilities.VerifyThrowInternalError(_serviceState != unexpectedState, $"Unexpected state {_serviceState}");
+            }
+        }
+
         private class LoggingServiceToPluginLoggerAdapter : PluginLoggerBase
         {
             private readonly ILoggingService _loggingService;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 1314a3c173a..d3a925b34a8 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -8,6 +8,7 @@
 using System.Threading.Tasks;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -464,8 +465,10 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         Lookup lookupForExecution;
 
                         // UNDONE: (Refactor) Refactor TargetUpToDateChecker to take a logging context, not a logging service.
+                        MSBuildEventSource.Log.TargetUpToDateStart();
                         TargetUpToDateChecker dependencyAnalyzer = new TargetUpToDateChecker(requestEntry.RequestConfiguration.Project, _target, targetLoggingContext.LoggingService, targetLoggingContext.BuildEventContext);
                         DependencyAnalysisResult dependencyResult = dependencyAnalyzer.PerformDependencyAnalysis(bucket, out changedTargetInputs, out upToDateTargetInputs);
+                        MSBuildEventSource.Log.TargetUpToDateStop((int)dependencyResult);
 
                         switch (dependencyResult)
                         {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index be1bb7b8250..1601b3e29c6 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -34,7 +34,7 @@ internal class TaskHost :
 #if FEATURE_APPDOMAIN
         MarshalByRefObject,
 #endif
-        IBuildEngine9
+        IBuildEngine10
     {
         /// <summary>
         /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set.
@@ -130,6 +130,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
             _disableInprocNode = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
                 ? s_disableInprocNodeByEnvironmentVariable || host.BuildParameters.DisableInProcNode
                 : s_disableInprocNodeByEnvironmentVariable;
+            EngineServices = new EngineServicesImpl(this);
         }
 
         /// <summary>
@@ -874,6 +875,39 @@ internal void ReleaseAllCores()
 
         #endregion
 
+        #region IBuildEngine10 Members
+
+        [Serializable]
+        private sealed class EngineServicesImpl : EngineServices
+        {
+            private TaskHost _taskHost;
+
+            internal EngineServicesImpl(TaskHost taskHost)
+            {
+                _taskHost = taskHost;
+            }
+
+            /// <inheritdoc/>
+            public override bool LogsMessagesOfImportance(MessageImportance importance)
+            {
+#if FEATURE_APPDOMAIN
+                if (RemotingServices.IsTransparentProxy(_taskHost))
+                {
+                    // If the check would be a cross-domain call, chances are that it wouldn't be worth it.
+                    // Simply disable the optimization in such a case.
+                    return true;
+                }
+#endif
+                MessageImportance minimumImportance = _taskHost._taskLoggingContext?.LoggingService.MinimumRequiredMessageImportance ?? MessageImportance.Low;
+                return importance <= minimumImportance;
+
+            }
+        }
+
+        public EngineServices EngineServices{ get; }
+
+        #endregion
+
         /// <summary>
         /// Called by the internal MSBuild task.
         /// Does not take the lock because it is called by another request builder thread.
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 92a86164801..b40d2f1fb4c 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Utilities;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
@@ -176,8 +177,11 @@ internal class Scheduler : IScheduler
         /// </summary>
         public Scheduler()
         {
-            _debugDumpState = Environment.GetEnvironmentVariable("MSBUILDDEBUGSCHEDULER") == "1";
-            _debugDumpPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            // Be careful moving these to Traits, changing the timing of reading environment variables has a breaking potential.
+            _debugDumpState = Traits.Instance.DebugScheduler;
+            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
+                ? DebugUtils.DebugPath
+                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
             _schedulingUnlimitedVariable = Environment.GetEnvironmentVariable("MSBUILDSCHEDULINGUNLIMITED");
             _nodeLimitOffset = 0;
 
@@ -1382,7 +1386,7 @@ private void AssignUnscheduledRequestToNode(SchedulableRequest request, int node
 
             void WarnWhenProxyBuildsGetScheduledOnOutOfProcNode()
             {
-                if (request.IsProxyBuildRequest() && nodeId != InProcNodeId)
+                if (request.IsProxyBuildRequest() && nodeId != InProcNodeId && _schedulingData.CanScheduleRequestToNode(request, InProcNodeId))
                 {
                     ErrorUtilities.VerifyThrow(
                         _componentHost.BuildParameters.DisableInProcNode || ForceAffinityOutOfProc,
@@ -2104,7 +2108,11 @@ private NodeAffinity GetNodeAffinityForRequest(BuildRequest request)
                 return NodeAffinity.InProc;
             }
 
-            if (request.IsProxyBuildRequest())
+            ErrorUtilities.VerifyThrow(request.ConfigurationId != BuildRequestConfiguration.InvalidConfigurationId, "Requests should have a valid configuration id at this point");
+            // If this configuration has been previously built on an out of proc node, scheduling it on the inproc node can cause either an affinity mismatch error when
+            // there are other pending requests for the same configuration or "unscheduled requests remain in the presence of free out of proc nodes" errors if there's no pending requests.
+            // So only assign proxy builds to the inproc node if their config hasn't been previously assigned to an out of proc node.
+            if (_schedulingData.CanScheduleConfigurationToNode(request.ConfigurationId, InProcNodeId) && request.IsProxyBuildRequest())
             {
                 return NodeAffinity.InProc;
             }
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index 0edc83f296e..9aeb9009c80 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -647,7 +647,12 @@ public int GetAssignedNodeForRequestConfiguration(int configurationId)
         /// </summary>
         public bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId)
         {
-            int requiredNodeId = GetAssignedNodeForRequestConfiguration(request.BuildRequest.ConfigurationId);
+            return CanScheduleConfigurationToNode(request.BuildRequest.ConfigurationId, nodeId);
+        }
+
+        public bool CanScheduleConfigurationToNode(int configurationId, int nodeId)
+        {
+            int requiredNodeId = GetAssignedNodeForRequestConfiguration(configurationId);
             return requiredNodeId == Scheduler.InvalidNodeId || requiredNodeId == nodeId;
         }
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index c719a51d2df..b8546bbe1b6 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -316,7 +317,7 @@ private int GetConfigWithComparison(IEnumerable<int> realConfigsToSchedule, Comp
         private void AnalyzeData()
         {
             DoRecursiveAnalysis();
-            if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDEBUGSCHEDULER")))
+            if (Traits.Instance.DebugScheduler)
             {
                 DetermineExpensiveConfigs();
                 DetermineConfigsByNumberOfOccurrences();
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 80e36648f23..9e500181510 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -118,11 +118,6 @@ public class OutOfProcNode : INode, IBuildComponentHost, INodePacketFactory, INo
         /// </summary>
         private Exception _shutdownException;
 
-        /// <summary>
-        /// Flag indicating if we should debug communications or not.
-        /// </summary>
-        private readonly bool _debugCommunications;
-
         /// <summary>
         /// Data for the use of LegacyThreading semantics.
         /// </summary>
@@ -140,8 +135,6 @@ public OutOfProcNode()
         {
             s_isOutOfProcNode = true;
 
-            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
-
             _receivedPackets = new ConcurrentQueue<INodePacket>();
             _packetReceivedEvent = new AutoResetEvent(false);
             _shutdownEvent = new ManualResetEvent(false);
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index fa45800a6e9..2cc6ab1f7b4 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -671,19 +671,12 @@ public void CacheIfPossible()
                 {
                     if (IsCacheable)
                     {
-                        ITranslator translator = GetConfigurationTranslator(TranslationDirection.WriteToStream);
-
-                        try
-                        {
-                            _project.Cache(translator);
-                            _baseLookup = null;
-
-                            IsCached = true;
-                        }
-                        finally
-                        {
-                            translator.Writer.BaseStream.Dispose();
-                        }
+                        using ITranslator translator = GetConfigurationTranslator(TranslationDirection.WriteToStream);
+
+                        _project.Cache(translator);
+                        _baseLookup = null;
+
+                        IsCached = true;
                     }
                 }
             }
@@ -706,17 +699,11 @@ public void RetrieveFromCache()
                     return;
                 }
 
-                ITranslator translator = GetConfigurationTranslator(TranslationDirection.ReadFromStream);
-                try
-                {
-                    _project.RetrieveFromCache(translator);
+                using ITranslator translator = GetConfigurationTranslator(TranslationDirection.ReadFromStream);
 
-                    IsCached = false;
-                }
-                finally
-                {
-                    translator.Reader.BaseStream.Dispose();
-                }
+                _project.RetrieveFromCache(translator);
+
+                IsCached = false;
             }
         }
 
diff --git a/src/Build/BackEnd/Shared/TargetResult.cs b/src/Build/BackEnd/Shared/TargetResult.cs
index 4969cdb7664..d94d59beda8 100644
--- a/src/Build/BackEnd/Shared/TargetResult.cs
+++ b/src/Build/BackEnd/Shared/TargetResult.cs
@@ -243,22 +243,15 @@ internal void CacheItems(int configId, string targetName)
                     return;
                 }
 
-                ITranslator translator = GetResultsCacheTranslator(configId, targetName, TranslationDirection.WriteToStream);
+                using ITranslator translator = GetResultsCacheTranslator(configId, targetName, TranslationDirection.WriteToStream);
 
                 // If the translator is null, it means these results were cached once before.  Since target results are immutable once they
                 // have been created, there is no point in writing them again.
                 if (translator != null)
                 {
-                    try
-                    {
-                        TranslateItems(translator);
-                        _items = null;
-                        _cacheInfo = new CacheInfo(configId, targetName);
-                    }
-                    finally
-                    {
-                        translator.Writer.BaseStream.Dispose();
-                    }
+                    TranslateItems(translator);
+                    _items = null;
+                    _cacheInfo = new CacheInfo(configId, targetName);
                 }
             }
         }
@@ -284,17 +277,10 @@ private void RetrieveItemsFromCache()
             {
                 if (_items == null)
                 {
-                    ITranslator translator = GetResultsCacheTranslator(_cacheInfo.ConfigId, _cacheInfo.TargetName, TranslationDirection.ReadFromStream);
-
-                    try
-                    {
-                        TranslateItems(translator);
-                        _cacheInfo = new CacheInfo();
-                    }
-                    finally
-                    {
-                        translator.Reader.BaseStream.Dispose();
-                    }
+                    using ITranslator translator = GetResultsCacheTranslator(_cacheInfo.ConfigId, _cacheInfo.TargetName, TranslationDirection.ReadFromStream);
+
+                    TranslateItems(translator);
+                    _cacheInfo = new CacheInfo();
                 }
             }
         }
@@ -339,7 +325,7 @@ private void TranslateItems(ITranslator translator)
                 ErrorUtilities.VerifyThrow(buffer != null, "Unexpected null items buffer during translation.");
 
                 using MemoryStream itemsStream = new MemoryStream(buffer, 0, buffer.Length, writable: false, publiclyVisible: true);
-                var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, null);
+                using var itemTranslator = BinaryTranslator.GetReadTranslator(itemsStream, null);
                 _items = new TaskItem[itemsCount];
                 for (int i = 0; i < _items.Length; i++)
                 {
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index cd19bb38ebc..389f1f3cf6e 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -207,8 +207,12 @@ private ProjectRootElement(ProjectRootElementCacheBase projectRootElementCache,
         /// Assumes path is already normalized.
         /// May throw InvalidProjectFileException.
         /// </summary>
-        private ProjectRootElement(string path, ProjectRootElementCacheBase projectRootElementCache,
-            bool preserveFormatting)
+        private ProjectRootElement
+            (
+                string path,
+                ProjectRootElementCacheBase projectRootElementCache,
+                bool preserveFormatting
+            )
         {
             ErrorUtilities.VerifyThrowArgumentLength(path, nameof(path));
             ErrorUtilities.VerifyThrowInternalRooted(path);
@@ -222,8 +226,6 @@ private ProjectRootElement(string path, ProjectRootElementCacheBase projectRootE
             XmlDocumentWithLocation document = LoadDocument(path, preserveFormatting, projectRootElementCache.LoadProjectsReadOnly);
 
             ProjectParser.Parse(document, this);
-
-            projectRootElementCache.AddEntry(this);
         }
 
         /// <summary>
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index f158ca5a2bb..0a6df394738 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -43,7 +43,7 @@ namespace Microsoft.Build.Evaluation
     /// Edits to this project always update the backing XML.
     /// </summary>
     // UNDONE: (Multiple configurations.) Protect against problems when attempting to edit, after edits were made to the same ProjectRootElement either directly or through other projects evaluated from that ProjectRootElement.
-    [DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")]
+    [DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={implementation._data.GlobalPropertiesDictionary.Count} #Properties={implementation._data.Properties.Count} #ItemTypes={implementation._data.ItemTypes.Count} #ItemDefinitions={implementation._data.ItemDefinitions.Count} #Items={implementation._data.Items.Count} #Targets={implementation._data.Targets.Count}")]
     public class Project : ILinkableObject
     {
         /// <summary>
@@ -461,7 +461,7 @@ private Project(string projectFile, IDictionary<string, string> globalProperties
             {
                 // If possible, clear out the XML we just loaded into the XML cache:
                 // if we had loaded the XML from disk into the cache within this constructor,
-                // and then are are bailing out because there is a typo in the XML such that 
+                // and then are are bailing out because there is a typo in the XML such that
                 // evaluation failed, we don't want to leave the bad XML in the cache;
                 // the user wouldn't be able to fix the XML file and try again.
                 if (!ExceptionHandling.IsCriticalException(ex))
@@ -2503,7 +2503,7 @@ private List<GlobResult> GetAllGlobs(List<ProjectItemElement> projectItemElement
                 // 5. <I Include="C"/>
                 // 6. <I Remove="..."/> // this remove applies to the includes at 1, 3, 5
                 // So A's applicable removes are composed of:
-                // 
+                //
                 // The applicable removes for the element at position 1 (xml element A) are composed of:
                 // - all the removes seen by the next include statement of I's type (xml element B, position 3, which appears after A in file order). In this example that's Removes at positions 4 and 6.
                 // - new removes between A and B. In this example that's Remove 2.
@@ -2634,7 +2634,7 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>.
             /// </summary>
-            /// /// <param name="item"> 
+            /// /// <param name="item">
             /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
             /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
             /// The element that produced this <paramref name="item"/> is included in the results.
@@ -3163,7 +3163,7 @@ public override void RemoveItems(IEnumerable<ProjectItem> items)
                 ErrorUtilities.VerifyThrowArgumentNull(items, nameof(items));
 
                 // Copying to a list makes it possible to remove
-                // all items of a particular type with 
+                // all items of a particular type with
                 //   RemoveItems(p.GetItems("mytype"))
                 // without modifying the collection during enumeration.
                 var itemsList = new List<ProjectItem>(items);
@@ -3586,7 +3586,7 @@ private void ReevaluateIfNecessary(
                 EvaluationContext evaluationContext = null)
             {
                 // We will skip the evaluation if the flag is set. This will give us better performance on scenarios
-                // that we know we don't have to reevaluate. One example is project conversion bulk addfiles and set attributes. 
+                // that we know we don't have to reevaluate. One example is project conversion bulk addfiles and set attributes.
                 if (!SkipEvaluation && !ProjectCollection.SkipEvaluation && IsDirty)
                 {
                     try
@@ -3684,9 +3684,9 @@ internal void Initialize(IDictionary<string, string> globalProperties, string to
                     {
                         if (String.Equals(pair.Key, Constants.SubToolsetVersionPropertyName, StringComparison.OrdinalIgnoreCase) && subToolsetVersion != null)
                         {
-                            // if we have a sub-toolset version explicitly provided by the ProjectInstance constructor, AND a sub-toolset version provided as a global property, 
-                            // make sure that the one passed in with the constructor wins.  If there isn't a matching global property, the sub-toolset version will be set at 
-                            // a later point. 
+                            // if we have a sub-toolset version explicitly provided by the ProjectInstance constructor, AND a sub-toolset version provided as a global property,
+                            // make sure that the one passed in with the constructor wins.  If there isn't a matching global property, the sub-toolset version will be set at
+                            // a later point.
                             globalPropertiesCollection.Set(ProjectPropertyInstance.Create(pair.Key, subToolsetVersion));
                         }
                         else
@@ -4185,7 +4185,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSyste
 
                 _globalPropertiesToTreatAsLocal?.Clear();
 
-                // Include the main project in the list of imports, as this list is 
+                // Include the main project in the list of imports, as this list is
                 // used to figure out if any of them have changed.
                 RecordImport(null, Project.Xml, Project.Xml.Version, null);
 
@@ -4225,7 +4225,7 @@ out var usingDifferentToolsVersionFromProjectFile
                     SubToolsetVersion = Toolset.GenerateSubToolsetVersion(GlobalPropertiesDictionary);
                 }
 
-                // Create a task registry which will fall back on the toolset task registry if necessary.          
+                // Create a task registry which will fall back on the toolset task registry if necessary.
                 TaskRegistry = new TaskRegistry(Toolset, Project.ProjectCollection.ProjectRootElementCache);
             }
 
@@ -4235,7 +4235,7 @@ out var usingDifferentToolsVersionFromProjectFile
             /// </summary>
             public void FinishEvaluation()
             {
-                // We assume there will be no further changes to the targets collection 
+                // We assume there will be no further changes to the targets collection
                 // This also makes sure that we are thread safe
                 Targets.MakeReadOnly();
 
@@ -4254,7 +4254,7 @@ public void FinishEvaluation()
                     }
                     else
                     {
-                        // Else we'll guess that this latest one is a potential match for the next, 
+                        // Else we'll guess that this latest one is a potential match for the next,
                         // if it actually has any elements (eg., it's not a .user or .filters file)
                         if (Targets.Count > 0)
                         {
@@ -4489,7 +4489,7 @@ internal bool RemoveItem(ProjectItem item)
 
                 // This remove will not succeed if the item include was changed.
                 // If many items are modified and then removed, this will leak them
-                // until the next reevaluation.                
+                // until the next reevaluation.
                 ItemsByEvaluatedIncludeCache.Remove(item.EvaluatedInclude, item);
 
                 ItemsIgnoringCondition.Remove(item);
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 07519d583ba..8629bd94317 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1801,6 +1801,11 @@ internal class ReusableLogger : INodeLogger, IEventSource4
             /// </summary>
             private readonly ILogger _originalLogger;
 
+            /// <summary>
+            /// Returns the logger we are wrapping.
+            /// </summary>
+            internal ILogger OriginalLogger => _originalLogger;
+
             /// <summary>
             /// The design-time event source
             /// </summary>
diff --git a/src/Build/Definition/ProjectImportPathMatch.cs b/src/Build/Definition/ProjectImportPathMatch.cs
index f31d63fb957..1c670eb06a4 100644
--- a/src/Build/Definition/ProjectImportPathMatch.cs
+++ b/src/Build/Definition/ProjectImportPathMatch.cs
@@ -62,4 +62,4 @@ internal static ProjectImportPathMatch FactoryForDeserialization(ITranslator tra
             return new ProjectImportPathMatch(translator);
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index a4e4d21565b..77d32963bf6 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -485,7 +485,7 @@ public string DefaultSubToolsetVersion
                         return Constants.Dev10SubToolsetValue;
                     }
 
-                    // 2) Otherwise, just pick the highest available. 
+                    // 2) Otherwise, just pick the highest available.
                     SortedDictionary<Version, string> subToolsetsWithVersion = new SortedDictionary<Version, string>();
                     List<string> additionalSubToolsetNames = new List<string>();
 
@@ -499,7 +499,7 @@ public string DefaultSubToolsetVersion
                         }
                         else
                         {
-                            // if it doesn't parse to an actual version number, shrug and just add it to the end. 
+                            // if it doesn't parse to an actual version number, shrug and just add it to the end.
                             additionalSubToolsetNames.Add(subToolsetName);
                         }
                     }
@@ -538,11 +538,11 @@ internal static bool Dev10IsInstalled
                 {
                     try
                     {
-                        // Figure out whether Dev10 is currently installed using the following heuristic: 
-                        // - Check whether the overall key (installed if any version of Dev10 is installed) is there. 
-                        //   - If it's not, no version of Dev10 exists or has ever existed on this machine, so return 'false'. 
-                        //   - If it is, we know that some version of Dev10 has been installed at some point, but we don't know 
-                        //     for sure whether it's still there or not.  Check the inndividual keys for {Pro, Premium, Ultimate, 
+                        // Figure out whether Dev10 is currently installed using the following heuristic:
+                        // - Check whether the overall key (installed if any version of Dev10 is installed) is there.
+                        //   - If it's not, no version of Dev10 exists or has ever existed on this machine, so return 'false'.
+                        //   - If it is, we know that some version of Dev10 has been installed at some point, but we don't know
+                        //     for sure whether it's still there or not.  Check the inndividual keys for {Pro, Premium, Ultimate,
                         //     C# Express, VB Express, C++ Express, VWD Express, LightSwitch} 2010
                         //     - If even one of them exists, return 'true'.
                         //     - Otherwise, return 'false.
@@ -804,7 +804,7 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
                 }
             }
 
-            // Next, try the toolset environment properties 
+            // Next, try the toolset environment properties
             if (_environmentProperties != null)
             {
                 ProjectPropertyInstance visualStudioVersionProperty = _environmentProperties[Constants.SubToolsetVersionPropertyName];
@@ -823,8 +823,8 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
                 subToolsetVersion = SubToolsets.Keys.FirstOrDefault(version => visualStudioVersionFromSolutionAsVersion.Equals(VersionUtilities.ConvertToVersion(version)));
             }
 
-            // Solution version also didn't work out, so fall back to default. 
-            // If subToolsetVersion is null, there simply wasn't a matching solution version. 
+            // Solution version also didn't work out, so fall back to default.
+            // If subToolsetVersion is null, there simply wasn't a matching solution version.
             return subToolsetVersion ?? (DefaultSubToolsetVersion);
         }
 
@@ -920,12 +920,12 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));
 
-                    // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the 
-                    // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.  
+                    // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the
+                    // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.
                     int count = _environmentProperties.Count + reservedProperties.Count + Properties.Values.Count + _globalProperties.Count + 1;
 
-                    // GenerateSubToolsetVersion checks the environment and global properties, so it's safe to go ahead and gather the 
-                    // subtoolset properties here without fearing that we'll have somehow come up with the wrong subtoolset version. 
+                    // GenerateSubToolsetVersion checks the environment and global properties, so it's safe to go ahead and gather the
+                    // subtoolset properties here without fearing that we'll have somehow come up with the wrong subtoolset version.
                     string subToolsetVersion = this.GenerateSubToolsetVersion();
                     SubToolset subToolset;
                     ICollection<ProjectPropertyInstance> subToolsetProperties = null;
@@ -941,10 +941,10 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
 
                     _propertyBag = new PropertyDictionary<ProjectPropertyInstance>(count);
 
-                    // Should be imported in the same order as in the evaluator:  
+                    // Should be imported in the same order as in the evaluator:
                     // - Environment
                     // - Toolset
-                    // - Subtoolset (if any) 
+                    // - Subtoolset (if any)
                     // - Global
                     _propertyBag.ImportProperties(_environmentProperties);
 
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index e2081dc5ad7..d49b10b1cf2 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -323,7 +323,7 @@ private static string GetValue(RegistryKeyWrapper wrapper, string valueName)
                 object result = wrapper.GetValue(valueName);
 
                 // RegistryKey.GetValue returns null if the value is not present
-                // and String.Empty if the value is present and no data is defined. 
+                // and String.Empty if the value is present and no data is defined.
                 // We preserve this distinction, because a string property in the registry with
                 // no value really has an empty string for a value (which is a valid property value)
                 // rather than null for a value (which is an invalid property value)
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index d47f970c517..d8c160e44dd 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -627,7 +627,7 @@ private void Evaluate()
                 }
 
                 _data.InitialTargets = initialTargets;
-                MSBuildEventSource.Log.EvaluatePass1Stop(projectFile, _projectRootElement.Properties.Count, _projectRootElement.Imports.Count);
+                MSBuildEventSource.Log.EvaluatePass1Stop(projectFile);
                 // Pass2: evaluate item definitions
                 // Don't box via IEnumerator and foreach; cache count so not to evaluate via interface each iteration
                 MSBuildEventSource.Log.EvaluatePass2Start(projectFile);
@@ -641,7 +641,7 @@ private void Evaluate()
                         }
                     }
                 }
-                MSBuildEventSource.Log.EvaluatePass2Stop(projectFile, _itemDefinitionGroupElements.Count);
+                MSBuildEventSource.Log.EvaluatePass2Stop(projectFile);
                 LazyItemEvaluator<P, I, M, D> lazyEvaluator = null;
                 using (_evaluationProfiler.TrackPass(EvaluationPass.Items))
                 {
@@ -684,7 +684,7 @@ private void Evaluate()
                     lazyEvaluator = null;
                 }
 
-                MSBuildEventSource.Log.EvaluatePass3Stop(projectFile, _itemGroupElements.Count);
+                MSBuildEventSource.Log.EvaluatePass3Stop(projectFile);
 
                 // Pass4: evaluate using-tasks
                 MSBuildEventSource.Log.EvaluatePass4Start(projectFile);
@@ -696,7 +696,7 @@ private void Evaluate()
                     }
                 }
 
-                // If there was no DefaultTargets attribute found in the depth first pass, 
+                // If there was no DefaultTargets attribute found in the depth first pass,
                 // use the name of the first target. If there isn't any target, don't error until build time.
 
                 if (_data.DefaultTargets == null)
@@ -714,7 +714,7 @@ private void Evaluate()
                 Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget = new Dictionary<string, List<TargetSpecification>>(StringComparer.OrdinalIgnoreCase);
                 LinkedList<ProjectTargetElement> activeTargetsByEvaluationOrder = new LinkedList<ProjectTargetElement>();
                 Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets = new Dictionary<string, LinkedListNode<ProjectTargetElement>>(StringComparer.OrdinalIgnoreCase);
-                MSBuildEventSource.Log.EvaluatePass4Stop(projectFile, _usingTaskElements.Count);
+                MSBuildEventSource.Log.EvaluatePass4Stop(projectFile);
 
                 using (_evaluationProfiler.TrackPass(EvaluationPass.Targets))
                 {
@@ -748,7 +748,7 @@ private void Evaluate()
 
                     if (Traits.Instance.EscapeHatches.DebugEvaluation)
                     {
-                        // This is so important for VS performance it's worth always tracing; accidentally having 
+                        // This is so important for VS performance it's worth always tracing; accidentally having
                         // inconsistent sets of global properties will cause reevaluations, which are wasteful and incorrect
                         if (_projectRootElement.Count > 0) // VB/C# will new up empty projects; they aren't worth recording
                         {
@@ -773,7 +773,7 @@ private void Evaluate()
                     }
 
                     _data.FinishEvaluation();
-                    MSBuildEventSource.Log.EvaluatePass5Stop(projectFile, targetElementsCount);
+                    MSBuildEventSource.Log.EvaluatePass5Stop(projectFile);
                 }
             }
 
@@ -1002,7 +1002,7 @@ private void EvaluateUsingTaskElement(string directoryOfImportingFile, ProjectUs
         /// </summary>
         private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<ProjectTargetElement> activeTargetsByEvaluationOrder, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets)
         {
-            // If we already have read a target instance for this element, use that. 
+            // If we already have read a target instance for this element, use that.
             ProjectTargetInstance targetInstance = targetElement.TargetInstance ?? ReadNewTargetElement(targetElement, _projectSupportsReturnsAttribute[(ProjectRootElement)targetElement.Parent], _evaluationProfiler);
 
             string targetName = targetElement.Name;
@@ -1091,6 +1091,8 @@ private void ValidateChangeWaveState()
             }
         }
 
+        private static readonly string CachedFileVersion = ProjectCollection.Version.ToString();
+
         /// <summary>
         /// Set the built-in properties, most of which are read-only
         /// </summary>
@@ -1106,6 +1108,8 @@ private void AddBuiltInProperties()
             SetBuiltInProperty(ReservedPropertyNames.programFiles32, FrameworkLocationHelper.programFiles32);
             SetBuiltInProperty(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion);
             SetBuiltInProperty(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild);
+            SetBuiltInProperty(ReservedPropertyNames.fileVersion, CachedFileVersion);
+            SetBuiltInProperty(ReservedPropertyNames.semanticVersion, ProjectCollection.DisplayVersion);
 
             ValidateChangeWaveState();
 
@@ -1192,9 +1196,9 @@ private void AddToolsetProperties()
             }
             else
             {
-                // Make the subtoolset version itself available as a property -- but only if it's not already set. 
+                // Make the subtoolset version itself available as a property -- but only if it's not already set.
                 // Because some people may be depending on this value even if there isn't a matching sub-toolset,
-                // set the property even if there is no matching sub-toolset.  
+                // set the property even if there is no matching sub-toolset.
                 if (!_data.Properties.Contains(Constants.SubToolsetVersionPropertyName))
                 {
                     _data.SetProperty(Constants.SubToolsetVersionPropertyName, _data.SubToolsetVersion, false /* NOT global property */, false /* may NOT be a reserved name */);
@@ -1249,8 +1253,8 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
             using (_evaluationProfiler.TrackElement(propertyElement))
             {
                 // Global properties cannot be overridden.  We silently ignore them if we try.  Legacy behavior.
-                // That is, unless this global property has been explicitly labeled as one that we want to treat as overridable for the duration 
-                // of this project (or import). 
+                // That is, unless this global property has been explicitly labeled as one that we want to treat as overridable for the duration
+                // of this project (or import).
                 if (
                         ((IDictionary<string, ProjectPropertyInstance>)_data.GlobalPropertiesDictionary).ContainsKey(propertyElement.Name) &&
                         !_data.GlobalPropertiesToTreatAsLocal.Contains(propertyElement.Name)
@@ -1926,8 +1930,6 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
                     }
                 }
 
-                _projectRootElementCache.AddEntry(project);
-
                 return project;
             }
 
@@ -2278,8 +2280,8 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                         }
                     }
 
-                    // Because these expressions will never be expanded again, we 
-                    // can store the unescaped value. The only purpose of escaping is to 
+                    // Because these expressions will never be expanded again, we
+                    // can store the unescaped value. The only purpose of escaping is to
                     // avoid undesired splitting or expansion.
                     _importsSeen.Add(importFileUnescaped, importElement);
                 }
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 80ddea0b0c2..2153f368007 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -610,7 +610,7 @@ private static bool IsValidPropertyName(string propertyName)
         /// </summary>
         private static bool IsTruncationEnabled(ExpanderOptions options)
         {
-            return (options & ExpanderOptions.Truncate) != 0 && !Traits.Instance.EscapeHatches.DoNotTruncateConditions && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8);
+            return (options & ExpanderOptions.Truncate) != 0 && !Traits.Instance.EscapeHatches.DoNotTruncateConditions;
         }
 
         /// <summary>
@@ -1759,7 +1759,7 @@ internal static ExpressionShredder.ItemExpressionCapture ExpandSingleItemVectorE
                 }
 
                 List<ExpressionShredder.ItemExpressionCapture> matches;
-                if (s_invariantCompareInfo.IndexOf(expression, '@') == -1)
+                if (expression.IndexOf('@') == -1)
                 {
                     return null;
                 }
@@ -2539,7 +2539,7 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
                             {
                                 // It may be that the itemspec has unescaped ';'s in it so we need to split here to handle
                                 // that case.
-                                if (s_invariantCompareInfo.IndexOf(metadataValue, ';') >= 0)
+                                if (metadataValue.IndexOf(';') >= 0)
                                 {
                                     var splits = ExpressionShredder.SplitSemiColonSeparatedList(metadataValue);
 
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index aa5f8b40442..ffa04158d9d 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -65,7 +65,7 @@ internal static SemiColonTokenizer SplitSemiColonSeparatedList(string expression
         /// where metadata key is like "itemname.metadataname" or "metadataname".
         /// PERF: Tables are null if there are no entries, because this is quite a common case.
         /// </summary>
-        internal static ItemsAndMetadataPair GetReferencedItemNamesAndMetadata(List<string> expressions)
+        internal static ItemsAndMetadataPair GetReferencedItemNamesAndMetadata(IEnumerable<string> expressions)
         {
             ItemsAndMetadataPair pair = new ItemsAndMetadataPair(null, null);
 
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 7a1cb4db89b..e666b97f94e 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -462,7 +462,7 @@ public GlobFragment(string textFragment, string projectDirectory)
     /// on multiple metadata. If one item specifies NotTargetFramework to be net46 and TargetFramework to
     /// be netcoreapp3.1, we wouldn't want to match that to an item with TargetFramework 46 and
     /// NotTargetFramework netcoreapp3.1.
-    /// 
+    ///
     /// Implementing this as a list of sets where each metadatum key has its own set also would not work
     /// because different items could match on different metadata, and we want to check to see if any
     /// single item matches on all the metadata. As an example, consider this scenario:
@@ -474,10 +474,10 @@ public GlobFragment(string textFragment, string projectDirectory)
     /// should match none of them because Forgind doesn't match all three metadata of any of the items.
     /// With a list of sets, Forgind would match Baby on BadAt, Child on GoodAt, and Adolescent on OkAt,
     /// and Forgind would be erroneously removed.
-    /// 
+    ///
     /// With a Trie as below, Items specify paths in the tree, so going to any child node eliminates all
     /// items that don't share that metadatum. This ensures the match is proper.
-    /// 
+    ///
     /// Todo: Tries naturally can have different shapes depending on in what order the metadata are considered.
     /// Specifically, if all the items share a single metadata value for the one metadatum and have different
     /// values for a second metadatum, it will have only one node more than the number of items if the first
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 233156392bd..a351b02dbbe 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -21,7 +21,9 @@ class IncludeOperation : LazyItemOperation
             
             readonly string _rootDirectory;
 
-            readonly ImmutableList<string> _excludes;
+            // TODO: Convert this to ImmutableSegmentedList<T> once available.
+            // https://github.com/dotnet/msbuild/issues/6601
+            readonly List<string> _excludes;
 
             readonly ImmutableList<ProjectMetadataElement> _metadata;
 
@@ -31,7 +33,7 @@ public IncludeOperation(IncludeOperationBuilder builder, LazyItemEvaluator<P, I,
                 _elementOrder = builder.ElementOrder;
                 _rootDirectory = builder.RootDirectory;
 
-                _excludes = builder.Excludes.ToImmutable();
+                _excludes = builder.Excludes;
                 _metadata = builder.Metadata.ToImmutable();
             }
 
@@ -92,7 +94,7 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                     {
                         // If this item is behind a false condition and represents a full drive/filesystem scan, expanding it is
                         // almost certainly undesired. It should be skipped to avoid evaluation taking an excessive amount of time.
-                        bool skipGlob = !_conditionResult && globFragment.IsFullFileSystemScan && !Traits.Instance.EscapeHatches.AlwaysEvaluateDangerousGlobs && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8);
+                        bool skipGlob = !_conditionResult && globFragment.IsFullFileSystemScan && !Traits.Instance.EscapeHatches.AlwaysEvaluateDangerousGlobs;
                         if (!skipGlob)
                         {
                             string glob = globFragment.TextFragment;
@@ -167,7 +169,9 @@ class IncludeOperationBuilder : OperationBuilderWithMetadata
             public int ElementOrder { get; set; }
             public string RootDirectory { get; set; }
 
-            public ImmutableList<string>.Builder Excludes { get; } = ImmutableList.CreateBuilder<string>();
+            // TODO: Convert this to ImmutableSegmentedList<T>.Builder once available.
+            // https://github.com/dotnet/msbuild/issues/6601
+            public List<string> Excludes { get; } = new();
 
             public IncludeOperationBuilder(ProjectItemElement itemElement, bool conditionResult) : base(itemElement, conditionResult)
             {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index b072a36f854..fc77d17b488 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -230,7 +230,6 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                         // End of legal area for metadata expressions.
                         _expander.Metadata = null;
                     }
-
                     // End of pseudo batching
                     ////////////////////////////////////////////////////
                     // Start of old code
@@ -283,17 +282,18 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                 }
             }
 
-            protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElement> metadata, out ItemsAndMetadataPair itemsAndMetadataFound)
+            private static IEnumerable<string> GetMetadataValuesAndConditions(ImmutableList<ProjectMetadataElement> metadata)
             {
-                List<string> values = new List<string>(metadata.Count * 2);
-
                 foreach (var metadataElement in metadata)
                 {
-                    values.Add(metadataElement.Value);
-                    values.Add(metadataElement.Condition);
+                    yield return metadataElement.Value;
+                    yield return metadataElement.Condition;
                 }
+            }
 
-                itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(values);
+            protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElement> metadata, out ItemsAndMetadataPair itemsAndMetadataFound)
+            {
+                itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetMetadataValuesAndConditions(metadata));
 
                 bool needToExpandMetadataForEachItem = false;
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index e5f2a72f61a..b6188e08c4e 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -612,38 +612,36 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
             }
         }
 
+        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander)
+        {
+            // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
+            // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
+            // See: https://github.com/Microsoft/msbuild/issues/3460
+            const ExpanderOptions expanderOptions = ExpanderOptions.ExpandProperties | ExpanderOptions.LeavePropertiesUnexpandedOnError;
+
+            // Expand properties here, because a property may have a value which is an item reference (ie "@(Bar)"), and
+            // if so we need to add the right item reference.
+            foreach (var metadatumElement in metadata)
+            {
+                yield return expander.ExpandIntoStringLeaveEscaped(
+                    metadatumElement.Value,
+                    expanderOptions,
+                    metadatumElement.Location);
+
+                yield return expander.ExpandIntoStringLeaveEscaped(
+                    metadatumElement.Condition,
+                    expanderOptions,
+                    metadatumElement.ConditionLocation);
+            }
+        }
+
         private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBuilderWithMetadata operationBuilder)
         {
             if (itemElement.HasMetadata)
             {
                 operationBuilder.Metadata.AddRange(itemElement.Metadata);
 
-                var values = new List<string>(itemElement.Metadata.Count * 2);
-
-                // Expand properties here, because a property may have a value which is an item reference (ie "@(Bar)"), and
-                // if so we need to add the right item reference.
-                foreach (var metadatumElement in itemElement.Metadata)
-                {
-                    // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
-                    // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
-                    // See: https://github.com/Microsoft/msbuild/issues/3460
-                    const ExpanderOptions expanderOptions = ExpanderOptions.ExpandProperties | ExpanderOptions.LeavePropertiesUnexpandedOnError;
-
-                    var valueWithPropertiesExpanded = _expander.ExpandIntoStringLeaveEscaped(
-                        metadatumElement.Value,
-                        expanderOptions,
-                        metadatumElement.Location);
-
-                    var conditionWithPropertiesExpanded = _expander.ExpandIntoStringLeaveEscaped(
-                        metadatumElement.Condition,
-                        expanderOptions,
-                        metadatumElement.ConditionLocation);
-
-                    values.Add(valueWithPropertiesExpanded);
-                    values.Add(conditionWithPropertiesExpanded);
-                }
-
-                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(values);
+                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander));
                 if (itemsAndMetadataFound.Items != null)
                 {
                     foreach (var itemType in itemsAndMetadataFound.Items)
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index b75de665c00..df98809f549 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -75,6 +75,14 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// </summary>
         private static bool s_debugLogCacheActivity;
 
+        /// <summary>
+        /// Whether the cache should check file content for cache entry invalidation.
+        /// </summary>
+        /// <remarks>
+        /// Value shall be true only in case of testing. Outside QA tests it shall be false.
+        /// </remarks>
+        private static bool s_—ÅheckFileContent;
+
         /// <summary>
         /// The map of weakly-held ProjectRootElement's
         /// </summary>
@@ -116,6 +124,7 @@ static ProjectRootElementCache()
             }
 
             s_debugLogCacheActivity = Environment.GetEnvironmentVariable("MSBUILDDEBUGXMLCACHE") == "1";
+            s_—ÅheckFileContent = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDCACHECHECKFILECONTENT"));
         }
 
         /// <summary>
@@ -131,15 +140,66 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
             LoadProjectsReadOnly = loadProjectsReadOnly;
         }
 
+
+        /// <summary>
+        /// Returns true if given cache entry exists and is outdated.
+        /// </summary>
+        private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement)
+        {
+            if (projectRootElement != null && _autoReloadFromDisk)
+            {
+                FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);
+
+                // If the file doesn't exist on disk, go ahead and use the cached version.
+                // It's an in-memory project that hasn't been saved yet.
+                if (fileInfo != null)
+                {
+                    if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)
+                    {
+                        // File was changed on disk by external means. Cached version is no longer valid.
+                        // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file
+                        // externally and load a new project over it to see the new content. So we dump it from the cache
+                        // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,
+                        // but clients ought not get themselves into such a state - and unless they save them to disk,
+                        // it may not be a problem.
+                        return true;
+                    }
+                    else if (s_—ÅheckFileContent)
+                    {
+                        // QA tests run too fast for the timestamp check to work. This environment variable is for their
+                        // use: it checks the file content as well as the timestamp. That's better than completely disabling
+                        // the cache as we get test coverage of the rest of the cache code.
+                        XmlDocument document = new XmlDocument();
+                        document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;
+
+                        using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))
+                        {
+                            document.Load(xtr.Reader);
+                        }
+
+                        string diskContent = document.OuterXml;
+                        string cacheContent = projectRootElement.XmlDocument.OuterXml;
+
+                        if (diskContent != cacheContent)
+                        {
+                            return true;
+                        }
+                    }
+                }
+            }
+
+            return false;
+        }
+
         /// <summary>
         /// Returns an existing ProjectRootElement for the specified file path, if any.
         /// If none exists, calls the provided delegate to load one, and adds that to the cache.
         /// The reason that it calls back to do this is so that the cache is locked between determining
         /// that the entry does not exist and adding the entry.
-        /// 
+        ///
         /// If <see cref="_autoReloadFromDisk"/> was set to true, and the file on disk has changed since it was cached,
         /// it will be reloaded before being returned.
-        /// 
+        ///
         /// Thread safe.
         /// </summary>
         /// <remarks>
@@ -148,7 +208,7 @@ internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadO
         /// If item is found, boosts it to the top of the strong cache.
         /// </remarks>
         /// <param name="projectFile">The project file which contains the ProjectRootElement.  Must be a full path.</param>
-        /// <param name="openProjectRootElement">The delegate to use to load if necessary. May be null.</param>
+        /// <param name="openProjectRootElement">The delegate to use to load if necessary. May be null. Must not update the cache.</param>
         /// <param name="isExplicitlyLoaded"><code>true</code> if the project is explicitly loaded, otherwise <code>false</code>.</param>
         /// <param name="preserveFormatting"><code>true</code> to the project was loaded with the formated preserved, otherwise <code>false</code>.</param>
         /// <returns>The ProjectRootElement instance if one exists.  Null otherwise.</returns>
@@ -158,91 +218,82 @@ internal override ProjectRootElement Get(string projectFile, OpenProjectRootElem
             // Should already have been canonicalized
             ErrorUtilities.VerifyThrowInternalRooted(projectFile);
 
+            ProjectRootElement projectRootElement;
             lock (_locker)
             {
-                ProjectRootElement projectRootElement;
                 _weakCache.TryGetValue(projectFile, out projectRootElement);
 
-                if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)
+                if (projectRootElement != null)
                 {
-                    //  Cached project doesn't match preserveFormatting setting, so reload it
-                    projectRootElement.Reload(true, preserveFormatting);
-                }
-
-                if (projectRootElement != null && _autoReloadFromDisk)
-                {
-                    FileInfo fileInfo = FileUtilities.GetFileInfoNoThrow(projectFile);
+                    BoostEntryInStrongCache(projectRootElement);
 
-                    // If the file doesn't exist on disk, go ahead and use the cached version.
-                    // It's an in-memory project that hasn't been saved yet.
-                    if (fileInfo != null)
+                    // An implicit load will never reset the explicit flag.
+                    if (isExplicitlyLoaded)
                     {
-                        bool forgetEntry = false;
-
-                        if (fileInfo.LastWriteTime != projectRootElement.LastWriteTimeWhenRead)
-                        {
-                            // File was changed on disk by external means. Cached version is no longer reliable. 
-                            // We could throw here or ignore the problem, but it is a common and reasonable pattern to change a file 
-                            // externally and load a new project over it to see the new content. So we dump it from the cache
-                            // to force a load from disk. There might then exist more than one ProjectRootElement with the same path,
-                            // but clients ought not get themselves into such a state - and unless they save them to disk,
-                            // it may not be a problem.  
-                            forgetEntry = true;
-                        }
-                        else if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDCACHECHECKFILECONTENT")))
-                        {
-                            // QA tests run too fast for the timestamp check to work. This environment variable is for their
-                            // use: it checks the file content as well as the timestamp. That's better than completely disabling
-                            // the cache as we get test coverage of the rest of the cache code.
-                            XmlDocument document = new XmlDocument();
-                            document.PreserveWhitespace = projectRootElement.XmlDocument.PreserveWhitespace;
-
-                            using (var xtr = XmlReaderExtension.Create(projectRootElement.FullPath, projectRootElement.ProjectRootElementCache.LoadProjectsReadOnly))
-                            {
-                                document.Load(xtr.Reader);
-                            }
-
-                            string diskContent = document.OuterXml;
-                            string cacheContent = projectRootElement.XmlDocument.OuterXml;
-
-                            if (diskContent != cacheContent)
-                            {
-                                forgetEntry = true;
-                            }
-                        }
-
-                        if (forgetEntry)
-                        {
-                            ForgetEntry(projectRootElement);
-
-                            DebugTraceCache("Out of date dropped from XML cache: ", projectFile);
-                            projectRootElement = null;
-                        }
+                        projectRootElement.MarkAsExplicitlyLoaded();
                     }
                 }
+                else
+                {
+                    DebugTraceCache("Not found in cache: ", projectFile);
+                }
 
-                if (projectRootElement == null && openProjectRootElement != null)
+                if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)
                 {
-                    projectRootElement = openProjectRootElement(projectFile, this);
+                    //  Cached project doesn't match preserveFormatting setting, so reload it
+                    projectRootElement.Reload(true, preserveFormatting);
+                }
+            }
 
-                    ErrorUtilities.VerifyThrowInternalNull(projectRootElement, "projectRootElement");
-                    ErrorUtilities.VerifyThrow(projectRootElement.FullPath == projectFile, "Got project back with incorrect path");
-                    ErrorUtilities.VerifyThrow(_weakCache.Contains(projectFile), "Open should have renamed into cache and boosted");
+            bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);
+            if (projectRootElementIsInvalid)
+            {
+                DebugTraceCache("Not satisfied from cache: ", projectFile);
+                ForgetEntryIfExists(projectRootElement);
+            }
+
+            if (openProjectRootElement == null)
+            {
+                if (projectRootElement == null || projectRootElementIsInvalid)
+                {
+                    return null;
                 }
-                else if (projectRootElement != null)
+                else
                 {
                     DebugTraceCache("Satisfied from XML cache: ", projectFile);
-                    BoostEntryInStrongCache(projectRootElement);
+                    return projectRootElement;
                 }
+            }
+
+            // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.
+            if (projectRootElement == null || projectRootElementIsInvalid)
+            {
+                // We do not lock loading with common _locker of the cache, to avoid lock contention.
+                // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplication, as
+                // it is not likely that two threads would use Get function for the same project simulteniously and it is not a big deal if in some cases we load the same project twice.
+
+                projectRootElement = openProjectRootElement(projectFile, this);
+                ErrorUtilities.VerifyThrowInternalNull(projectRootElement, "projectRootElement");
+                ErrorUtilities.VerifyThrow(projectRootElement.FullPath == projectFile, "Got project back with incorrect path");
 
                 // An implicit load will never reset the explicit flag.
-                if (projectRootElement != null && isExplicitlyLoaded)
+                if (isExplicitlyLoaded)
                 {
                     projectRootElement.MarkAsExplicitlyLoaded();
                 }
 
-                return projectRootElement;
+                // Update cache element.
+                // It is unlikely, but it might be that while without the lock, the projectRootElement in cache was updated by another thread.
+                // And here its entry will be replaced with the loaded projectRootElement. This is fine:
+                // if loaded projectRootElement is out of date (so, it changed since the time we loaded it), it will be updated the next time some thread calls Get function.
+                AddEntry(projectRootElement);
             }
+            else
+            {
+                DebugTraceCache("Satisfied from XML cache: ", projectFile);
+            }
+
+            return projectRootElement;
         }
 
         /// <summary>
@@ -508,6 +559,22 @@ private void ForgetEntry(ProjectRootElement projectRootElement)
                 _strongCache.Remove(strongCacheEntry);
                 RaiseProjectRootElementRemovedFromStrongCache(strongCacheEntry.Value);
             }
+
+            DebugTraceCache("Out of date dropped from XML cache: ", projectRootElement.FullPath);
+        }
+
+        /// <summary>
+        /// Completely remove an entry from this cache if it exists.
+        /// </summary>
+        private void ForgetEntryIfExists(ProjectRootElement projectRootElement)
+        {
+            lock (_locker)
+            {
+                if (_weakCache.TryGetValue(projectRootElement.FullPath, out var cached) && cached == projectRootElement)
+                {
+                    ForgetEntry(projectRootElement);
+                }
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/SimpleProjectRootElementCache.cs b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
index 6890d8bd75b..7e7700d1467 100644
--- a/src/Build/Evaluation/SimpleProjectRootElementCache.cs
+++ b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
@@ -63,8 +63,11 @@ private ProjectRootElement GetFromOrAddToCache(string projectFile, OpenProjectRo
                 ErrorUtilities.VerifyThrowInternalNull(rootElement, "projectRootElement");
                 ErrorUtilities.VerifyThrow(rootElement.FullPath.Equals(key, StringComparison.OrdinalIgnoreCase),
                     "Got project back with incorrect path");
+
+                AddEntry(rootElement);
+
                 ErrorUtilities.VerifyThrow(_cache.TryGetValue(key, out _),
-                    "Open should have renamed into cache and boosted");
+                    "Project should have been added into cache and boosted");
 
                 return rootElement;
             });
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 0420aa9edd3..9460958a40f 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -7,6 +7,7 @@
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 
 namespace Microsoft.Build.Globbing
@@ -126,10 +127,13 @@ public MatchInfoResult MatchInfo(string stringToMatch)
                 normalizedInput,
                 _state.Value.Regex,
                 out bool isMatch,
-                out string fixedDirectoryPart,
                 out string wildcardDirectoryPart,
                 out string filenamePart);
 
+            // We don't capture the fixed directory part in the regex but we can infer it from the other two.
+            int fixedDirectoryPartLength = normalizedInput.Length - wildcardDirectoryPart.Length - filenamePart.Length;
+            string fixedDirectoryPart = normalizedInput.Substring(0, fixedDirectoryPartLength);
+
             return new MatchInfoResult(isMatch, fixedDirectoryPart, wildcardDirectoryPart, filenamePart);
         }
 
@@ -202,8 +206,20 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
 
                     if (regex == null)
                     {
+                        RegexOptions regexOptions = FileMatcher.DefaultRegexOptions;
                         // compile the regex since it's expected to be used multiple times
-                        Regex newRegex = new Regex(matchFileExpression, FileMatcher.DefaultRegexOptions | RegexOptions.Compiled);
+                        // For the kind of regexes used here, compilation on .NET Framework tends to be expensive and not worth the small
+                        // run-time boost so it's enabled only on .NET Core by default.
+#if RUNTIME_TYPE_NETCORE
+                        bool compileRegex = true;
+#else
+                        bool compileRegex = !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);
+#endif
+                        if (compileRegex)
+                        {
+                            regexOptions |= RegexOptions.Compiled;
+                        }
+                        Regex newRegex = new Regex(matchFileExpression, regexOptions);
                         lock (s_regexCache)
                         {
                             if (!s_regexCache.TryGetValue(matchFileExpression, out regex))
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index b445f72d83d..40cf6aee0ed 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -10,19 +10,20 @@
 using System.Linq;
 using System.Text;
 using System.Threading;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Graph
 {
     /// <summary>
     ///     Represents a graph of evaluated projects.
     /// </summary>
-    [DebuggerDisplay(@"#roots={GraphRoots.Count}, #nodes={ProjectNodes.Count}, #entryPoints={EntryPointNodes.Count}")]
+    [DebuggerDisplay(@"{DebuggerDisplayString()}")]
     public sealed class ProjectGraph
     {
         /// <summary>
@@ -475,13 +476,16 @@ GraphConstructionMetrics EndMeasurement()
             }
         }
 
-        internal string ToDot()
+        internal string ToDot(IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode = null)
         {
             var nodeCount = 0;
-            return ToDot(node => nodeCount++.ToString());
+            return ToDot(node => nodeCount++.ToString(), targetsPerNode);
         }
 
-        internal string ToDot(Func<ProjectGraphNode, string> nodeIdProvider)
+        internal string ToDot(
+            Func<ProjectGraphNode, string> nodeIdProvider,
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode = null
+        )
         {
             ErrorUtilities.VerifyThrowArgumentNull(nodeIdProvider, nameof(nodeIdProvider));
 
@@ -489,31 +493,56 @@ internal string ToDot(Func<ProjectGraphNode, string> nodeIdProvider)
 
             var sb = new StringBuilder();
 
-            sb.Append("digraph g\n{\n\tnode [shape=box]\n");
+            sb.AppendLine($"/* {DebuggerDisplayString()} */");
+
+            sb.AppendLine("digraph g")
+                .AppendLine("{")
+                .AppendLine("\tnode [shape=box]");
 
             foreach (var node in ProjectNodes)
             {
-                var nodeId = nodeIds.GetOrAdd(node, (n, idProvider) => idProvider(n), nodeIdProvider);
+                var nodeId = GetNodeId(node);
 
                 var nodeName = Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);
+
                 var globalPropertiesString = string.Join(
                     "<br/>",
                     node.ProjectInstance.GlobalProperties.OrderBy(kvp => kvp.Key)
                         .Select(kvp => $"{kvp.Key}={kvp.Value}"));
 
-                sb.Append('\t').Append(nodeId).Append(" [label=<").Append(nodeName).Append("<br/>").Append(globalPropertiesString).AppendLine(">]");
+                var targetListString = GetTargetListString(node);
+
+                sb.AppendLine($"\t{nodeId} [label=<{nodeName}<br/>({targetListString})<br/>{globalPropertiesString}>]");
 
                 foreach (var reference in node.ProjectReferences)
                 {
-                    var referenceId = nodeIds.GetOrAdd(reference, (n, idProvider) => idProvider(n), nodeIdProvider);
+                    var referenceId = GetNodeId(reference);
 
-                    sb.Append('\t').Append(nodeId).Append(" -> ").AppendLine(referenceId);
+                    sb.AppendLine($"\t{nodeId} -> {referenceId}");
                 }
             }
 
             sb.Append("}");
 
             return sb.ToString();
+
+            string GetNodeId(ProjectGraphNode node)
+            {
+                return nodeIds.GetOrAdd(node, (n, idProvider) => idProvider(n), nodeIdProvider);
+            }
+
+            string GetTargetListString(ProjectGraphNode node)
+            {
+                var targetListString = targetsPerNode is null
+                    ? string.Empty
+                    : string.Join(", ", targetsPerNode[node]);
+                return targetListString;
+            }
+        }
+
+        private string DebuggerDisplayString()
+        {
+            return $"#roots={GraphRoots.Count}, #nodes={ProjectNodes.Count}, #entryPoints={EntryPointNodes.Count}";
         }
 
         private static IReadOnlyCollection<ProjectGraphNode> TopologicalSort(
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 70d0477ad3a..167a67e396e 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -2,19 +2,21 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
+using System.IO;
+using System.Linq;
 using System.Text;
+
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using System.Collections;
-using System.Globalization;
-using System.IO;
 
 using ColorSetter = Microsoft.Build.Logging.ColorSetter;
 using ColorResetter = Microsoft.Build.Logging.ColorResetter;
 using WriteHandler = Microsoft.Build.Logging.WriteHandler;
-using Microsoft.Build.Exceptions;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -329,6 +331,33 @@ internal void IsRunningWithCharacterFileType()
         /// </summary>
         internal bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity) => Verbosity >= checkVerbosity;
 
+        /// <summary>
+        /// Returns the minimum logger verbosity required to log a message with the given importance.
+        /// </summary>
+        /// <param name="importance">The message importance.</param>
+        /// <param name="lightenText">True if the message should be rendered using lighter colored text.</param>
+        /// <returns>The logger verbosity required to log a message of the given <paramref name="importance"/>.</returns>
+        internal static LoggerVerbosity ImportanceToMinimumVerbosity(MessageImportance importance, out bool lightenText)
+        {
+            switch (importance)
+            {
+                case MessageImportance.High:
+                    lightenText = false;
+                    return LoggerVerbosity.Minimal;
+                case MessageImportance.Normal:
+                    lightenText = true;
+                    return LoggerVerbosity.Normal;
+                case MessageImportance.Low:
+                    lightenText = true;
+                    return LoggerVerbosity.Detailed;
+
+                default:
+                    ErrorUtilities.VerifyThrow(false, "Impossible");
+                    lightenText = false;
+                    return LoggerVerbosity.Detailed;
+            }
+        }
+
         /// <summary>
         /// Sets foreground color to color specified
         /// </summary>
@@ -642,42 +671,56 @@ internal SortedList ExtractItemList(IEnumerable items)
         /// </summary>
         internal virtual void OutputItems(string itemType, ArrayList itemTypeList)
         {
-            // Write each item, one per line
-            bool haveWrittenItemType = false;
-            setColor(ConsoleColor.DarkGray);
-            foreach (ITaskItem item in itemTypeList)
+            WriteItemType(itemType);
+
+            foreach (var item in itemTypeList)
             {
-                if (!haveWrittenItemType)
+                string itemSpec = item switch
                 {
-                    setColor(ConsoleColor.Gray);
-                    WriteLinePretty(itemType);
-                    haveWrittenItemType = true;
-                    setColor(ConsoleColor.DarkGray);
-                }
-                WriteLinePretty("    "  /* indent slightly*/ + item.ItemSpec);
+                    ITaskItem taskItem => taskItem.ItemSpec,
+                    IItem iitem => iitem.EvaluatedInclude,
+                    { } misc => Convert.ToString(misc),
+                    null => "null"
+                };
 
-                IDictionary metadata = item.CloneCustomMetadata();
+                WriteItemSpec(itemSpec);
 
-                foreach (DictionaryEntry metadatum in metadata)
+                var metadata = item switch
                 {
-                    string valueOrError;
-                    try
-                    {
-                        valueOrError = item.GetMetadata(metadatum.Key as string);
-                    }
-                    catch (InvalidProjectFileException e)
+                    IMetadataContainer metadataContainer => metadataContainer.EnumerateMetadata(),
+                    IItem<ProjectMetadata> iitem => iitem.Metadata?.Select(m => new KeyValuePair<string, string>(m.Name, m.EvaluatedValue)),
+                    _ => null
+                };
+
+                if (metadata != null)
+                {
+                    foreach (var metadatum in metadata)
                     {
-                        valueOrError = e.Message;
+                        WriteMetadata(metadatum.Key, metadatum.Value);
                     }
-
-                    // A metadatum's "value" is its escaped value, since that's how we represent them internally.
-                    // So unescape before returning to the world at large.
-                    WriteLinePretty("        " + metadatum.Key + " = " + valueOrError);
                 }
             }
+
             resetColor();
         }
 
+        protected virtual void WriteItemType(string itemType)
+        {
+            setColor(ConsoleColor.Gray);
+            WriteLinePretty(itemType);
+            setColor(ConsoleColor.DarkGray);
+        }
+
+        protected virtual void WriteItemSpec(string itemSpec)
+        {
+            WriteLinePretty("    " + itemSpec);
+        }
+
+        protected virtual void WriteMetadata(string name, string value)
+        {
+            WriteLinePretty("        " + name + " = " + value);
+        }
+
         /// <summary>
         /// Returns a performance counter for a given scope (either task name or target name)
         /// from the given table.
@@ -959,6 +1002,12 @@ public virtual void Initialize(IEventSource eventSource)
                 eventSource.MessageRaised += MessageHandler;
                 eventSource.CustomEventRaised += CustomEventHandler;
                 eventSource.StatusEventRaised += StatusEventHandler;
+
+                bool logPropertiesAndItemsAfterEvaluation = Utilities.Traits.Instance.EscapeHatches.LogPropertiesAndItemsAfterEvaluation ?? true;
+                if (logPropertiesAndItemsAfterEvaluation && eventSource is IEventSource4 eventSource4)
+                {
+                    eventSource4.IncludeEvaluationPropertiesAndItems();
+                }
             }
         }
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 1d285b47c6b..9645b39d991 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -304,6 +304,13 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
                 condition = ReadOptionalString();
                 evaluatedCondition = ReadOptionalString();
                 originallySucceeded = ReadBoolean();
+
+                // Attempt to infer skip reason from the data we have
+                skipReason = condition != null ?
+                    TargetSkipReason.ConditionWasFalse // condition expression only stored when false
+                    : originallySucceeded ?
+                        TargetSkipReason.PreviouslyBuiltSuccessfully
+                        : TargetSkipReason.PreviouslyBuiltUnsuccessfully;
             }
 
             var buildReason = (TargetBuiltReason)ReadInt32();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index f0de05860eb..9b2e2930b92 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -447,8 +447,6 @@ private void Write(ProjectImportedEventArgs e)
 
         private void Write(TargetSkippedEventArgs e)
         {
-            ErrorUtilities.VerifyThrow(e.SkipReason != TargetSkipReason.None, "TargetSkippedEventArgs.SkipReason needs to be set");
-
             Write(BinaryLogRecordKind.TargetSkipped);
             WriteMessageFields(e, writeMessage: false);
             WriteDeduplicatedString(e.TargetFile);
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 3af25e3ce19..c6358a9badb 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -164,8 +164,6 @@ private void InitializeBaseConsoleLogger()
                 _parameters = null;
             }
 
-            
-
             _consoleLogger.SkipProjectStartedText = _skipProjectStartedText;
         }
 
@@ -477,6 +475,31 @@ public void CustomEventHandler(object sender, CustomBuildEventArgs e)
             _consoleLogger.CustomEventHandler(sender, e);
         }
 
+        /// <summary>
+        /// Returns the minimum importance of messages logged by this logger.
+        /// </summary>
+        /// <returns>
+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)
+        /// if this logger does not log messages of any importance.
+        /// </returns>
+        internal MessageImportance GetMinimumMessageImportance()
+        {
+            if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Low, out _))
+            {
+                return MessageImportance.Low;
+            }
+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.Normal, out _))
+            {
+                return MessageImportance.Normal;
+            }
+            else if (Verbosity >= BaseConsoleLogger.ImportanceToMinimumVerbosity(MessageImportance.High, out _))
+            {
+                return MessageImportance.High;
+            }
+            // The logger does not log messages of any importance.
+            return MessageImportance.High - 1;
+        }
+
         #endregion
     }
 }
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index d530bd07264..83c2499aefa 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -75,7 +75,7 @@ public int NodeId
         /// </summary>
         private void InitializeForwardingTable()
         {
-            _forwardingTable = new Dictionary<string, int>(15, StringComparer.OrdinalIgnoreCase);
+            _forwardingTable = new Dictionary<string, int>(17, StringComparer.OrdinalIgnoreCase);
             _forwardingTable[BuildStartedEventDescription] = 0;
             _forwardingTable[BuildFinishedEventDescription] = 0;
             _forwardingTable[ProjectStartedEventDescription] = 0;
@@ -258,6 +258,31 @@ private void SetForwardingBasedOnVerbosity()
             }
         }
 
+        /// <summary>
+        /// Returns the minimum importance of messages logged by this logger.
+        /// </summary>
+        /// <returns>
+        /// The minimum message importance corresponding to this logger's verbosity or (MessageImportance.High - 1)
+        /// if this logger does not log messages of any importance.
+        /// </returns>
+        internal MessageImportance GetMinimumMessageImportance()
+        {
+            if (_forwardingTable[LowMessageEventDescription] == 1)
+            {
+                return MessageImportance.Low;
+            }
+            if (_forwardingTable[NormalMessageEventDescription] == 1)
+            {
+                return MessageImportance.Normal;
+            }
+            if (_forwardingTable[HighMessageEventDescription] == 1)
+            {
+                return MessageImportance.High;
+            }
+            // The logger does not log messages of any importance.
+            return MessageImportance.High - 1;
+        }
+
         /// <summary>
         /// Reset the states of per-build member variables.
         /// Used when a build is finished, but the logger might be needed for the next build.
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index edcbe439efe..26ed295bc8b 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -540,20 +540,38 @@ public override void ProjectStartedHandler(object sender, ProjectStartedEventArg
                 }
             }
 
-            ReadProjectConfigurationDescription(e.BuildEventContext, e.Items);
+            var projectKey = (e.BuildEventContext.NodeId, e.BuildEventContext.ProjectContextId);
+
+            // If the value is available at all, it will be either in the items
+            // from ProjectStarted (old behavior), or the items from ProjectEvaluationFinished (new behavior).
+            // First try the old behavior, and fallback to the new behavior.
+            var result = ReadProjectConfigurationDescription(e.Items);
+            if (result != null)
+            {
+                // Found the items directly on ProjectStarted
+                propertyOutputMap[projectKey] = result;
+            }
+            else
+            {
+                // Try to see if we saw the items on the corresponding ProjectEvaluationFinished
+                var evaluationKey = GetEvaluationKey(e.BuildEventContext);
+
+                // if the value was set from ProjectEvaluationFinished, copy it into the entry
+                // for this project
+                if (propertyOutputMap.TryGetValue(evaluationKey, out string value))
+                {
+                    propertyOutputMap[projectKey] = value;
+                }
+            }
         }
 
-        private void ReadProjectConfigurationDescription(BuildEventContext buildEventContext, IEnumerable items)
+        private string ReadProjectConfigurationDescription(IEnumerable items)
         {
-            if (buildEventContext == null || items == null)
+            if (items == null)
             {
-                return;
+                return null;
             }
 
-            // node and project context ids for the propertyOutputMap key.
-            int nodeID = buildEventContext.NodeId;
-            int projectContextId = buildEventContext.ProjectContextId;
-
             ReuseableStringBuilder projectConfigurationDescription = null;
 
             Internal.Utilities.EnumerateItems(items, item =>
@@ -578,14 +596,27 @@ private void ReadProjectConfigurationDescription(BuildEventContext buildEventCon
                 }
             });
 
-            // Add the finished dictionary to propertyOutputMap.
             if (projectConfigurationDescription != null)
             {
-                propertyOutputMap.Add((nodeID, projectContextId), projectConfigurationDescription.ToString());
+                var result = projectConfigurationDescription.ToString();
                 (projectConfigurationDescription as IDisposable)?.Dispose();
+                return result;
             }
+
+            return null;
         }
 
+        /// <summary>
+        /// In case the items are stored on ProjectEvaluationFinishedEventArgs
+        /// (new behavior), we first store the value per evaluation, and then
+        /// in ProjectStarted, find the value from the project's evaluation
+        /// and use that.
+        /// </summary>
+        private (int, int) GetEvaluationKey(BuildEventContext buildEventContext)
+            // note that we use a negative number for evaluations so that we don't conflict
+            // with project context ids.
+            => (buildEventContext.NodeId, -buildEventContext.EvaluationId);
+
         /// <summary>
         /// Handler for project finished events
         /// </summary>
@@ -751,44 +782,23 @@ internal void WriteItems(BuildEventArgs e, IEnumerable items)
             ShownBuildEventContext(e.BuildEventContext);
         }
 
-        internal override void OutputItems(string itemType, ArrayList itemTypeList)
+        protected override void WriteItemType(string itemType)
         {
-            // Write each item, one per line
-            bool haveWrittenItemType = false;
-            foreach (ITaskItem item in itemTypeList)
-            {
-                if (!haveWrittenItemType)
-                {
-                    setColor(ConsoleColor.DarkGray);
-                    WriteMessageAligned(itemType, false);
-                    haveWrittenItemType = true;
-                }
-                setColor(ConsoleColor.Gray);
-
-                // Indent the text by two tab lengths
-                StringBuilder result = new StringBuilder((2 * tabWidth) + item.ItemSpec.Length);
-                result.Append(' ', 2 * tabWidth).Append(item.ItemSpec);
-                WriteMessageAligned(result.ToString(), false);
-
-                IDictionary metadata = item.CloneCustomMetadata();
+            setColor(ConsoleColor.DarkGray);
+            WriteMessageAligned(itemType, prefixAlreadyWritten: false);
+            setColor(ConsoleColor.Gray);
+        }
 
-                foreach (DictionaryEntry metadatum in metadata)
-                {
-                    string valueOrError;
-                    try
-                    {
-                        valueOrError = item.GetMetadata(metadatum.Key as string);
-                    }
-                    catch (InvalidProjectFileException e)
-                    {
-                        valueOrError = e.Message;
-                    }
+        protected override void WriteItemSpec(string itemSpec)
+        {
+            WriteMessageAligned(new string(' ', 2 * tabWidth) + itemSpec, prefixAlreadyWritten: false);
+        }
 
-                    WriteMessageAligned($"{new string(' ', 4 * tabWidth)}{metadatum.Key} = {valueOrError}", false);
-                }
-            }
-            resetColor();
+        protected override void WriteMetadata(string name, string value)
+        {
+            WriteMessageAligned($"{new string(' ', 4 * tabWidth)}{name} = {value}", prefixAlreadyWritten: false);
         }
+
         /// <summary>
         /// Handler for target started events
         /// </summary>
@@ -962,16 +972,16 @@ public override void TaskFinishedHandler(object sender, TaskFinishedEventArgs e)
         /// <summary>
         /// Finds the LogOutProperty string to be printed in messages.
         /// </summary>
-        /// <param name="e"> Build event to extract context information from.</param>
+        /// <param name="e">Build event to extract context information from.</param>
         internal string FindLogOutputProperties(BuildEventArgs e)
         {
             string projectConfigurationDescription = String.Empty;
             if (e.BuildEventContext != null)
             {
-                int nodeId = e.BuildEventContext.NodeId;
-                int projectContextId = e.BuildEventContext.ProjectContextId;
-                propertyOutputMap.TryGetValue((nodeId, projectContextId), out projectConfigurationDescription);
+                var key = (e.BuildEventContext.NodeId, e.BuildEventContext.ProjectContextId);
+                propertyOutputMap.TryGetValue(key, out projectConfigurationDescription);
             }
+
             return projectConfigurationDescription;
         }
 
@@ -1090,23 +1100,8 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
             }
             else
             {
-                switch (e.Importance)
-                {
-                    case MessageImportance.High:
-                        print = IsVerbosityAtLeast(LoggerVerbosity.Minimal);
-                        break;
-                    case MessageImportance.Normal:
-                        print = IsVerbosityAtLeast(LoggerVerbosity.Normal);
-                        lightenText = true;
-                        break;
-                    case MessageImportance.Low:
-                        print = IsVerbosityAtLeast(LoggerVerbosity.Detailed);
-                        lightenText = true;
-                        break;
-                    default:
-                        ErrorUtilities.VerifyThrow(false, "Impossible");
-                        break;
-                }
+                LoggerVerbosity minimumVerbosity = ImportanceToMinimumVerbosity(e.Importance, out lightenText);
+                print = IsVerbosityAtLeast(minimumVerbosity);
             }
 
             if (print)
@@ -1168,7 +1163,12 @@ public override void StatusEventHandler(object sender, BuildStatusEventArgs e)
                     }
                 }
 
-                ReadProjectConfigurationDescription(projectEvaluationFinished.BuildEventContext, projectEvaluationFinished.Items);
+                var value = ReadProjectConfigurationDescription(projectEvaluationFinished.Items);
+                if (value != null)
+                {
+                    var evaluationKey = GetEvaluationKey(e.BuildEventContext);
+                    propertyOutputMap[evaluationKey] = value;
+                }
             }
         }
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index c47c5ed976d..9deedd88b0e 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -497,28 +497,8 @@ public override void WarningHandler(object sender, BuildWarningEventArgs e)
         /// </summary>
         public override void MessageHandler(object sender, BuildMessageEventArgs e)
         {
-            bool print = false;
-            bool lightenText = false;
-            switch (e.Importance)
-            {
-                case MessageImportance.High:
-                    print = IsVerbosityAtLeast(LoggerVerbosity.Minimal);
-                    break;
-
-                case MessageImportance.Normal:
-                    print = IsVerbosityAtLeast(LoggerVerbosity.Normal);
-                    lightenText = true;
-                    break;
-
-                case MessageImportance.Low:
-                    print = IsVerbosityAtLeast(LoggerVerbosity.Detailed);
-                    lightenText = true;
-                    break;
-
-                default:
-                    ErrorUtilities.VerifyThrow(false, "Impossible");
-                    break;
-            }
+            LoggerVerbosity minimumVerbosity = ImportanceToMinimumVerbosity(e.Importance, out bool lightenText);
+            bool print = IsVerbosityAtLeast(minimumVerbosity);
 
             if (print)
             {
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index 8d03cf5a8a2..a327906f7ef 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -51,6 +51,8 @@ internal static class ReservedPropertyNames
         internal const string programFiles32 = "MSBuildProgramFiles32";
         internal const string localAppData = "LocalAppData";
         internal const string assemblyVersion = "MSBuildAssemblyVersion";
+        internal const string fileVersion = "MSBuildFileVersion";
+        internal const string semanticVersion = "MSBuildSemanticVersion";
         internal const string version = "MSBuildVersion";
         internal const string osName = "OS";
         internal const string frameworkToolsRoot = "MSBuildFrameworkToolsRoot";
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index fd441c3a8d6..fd04936e305 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="cs" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: Zak√°z√°n√≠ uzlu inproc zp≈Øsob√≠ sn√≠≈æen√≠ v√Ωkonu p≈ôi pou≈æ√≠v√°n√≠ modul≈Ø plug-in mezipamƒõti projektu, kter√© vys√≠laj√≠ ≈æ√°dosti o sestaven√≠ proxy serveru.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index e55f606d0d3..d3c84a65998 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="de" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: Das Deaktivieren des In-Process-Knotens f√ºhrt zu Leistungseinbu√üen bei der Verwendung von Projektcache-Plug-Ins, die Proxybuildanforderungen ausgeben.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 1b26dadc718..f580cb75fab 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: Al deshabilitar el nodo InProc, se degrada el rendimiento cuando use los complementos de cach√© de proyectos que emiten solicitudes de compilaci√≥n de proxy.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index cdcca79f380..7949e02cabc 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
     <body>
@@ -221,7 +221,7 @@
       </trans-unit>
       <trans-unit id="ProjectCacheException">
         <source>MSB4273: The project cache threw an unhandled exception from the {0} method.</source>
-        <target state="new">MSB4273: The project cache threw an unhandled exception from the {0} method.</target>
+        <target state="translated">MSB4273: le cache de projet a lev√© une exception non g√©r√©e √† partir de la m√©thode {0}.</target>
         <note />
       </trans-unit>
       <trans-unit id="ProjectCacheInitializationFailed">
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: la d√©sactivation du n≈ìud inproc entra√Æne une d√©t√©rioration des performances lors de l‚Äôutilisation de plug-ins de cache de projet qui √©mettent des requ√™tes de build proxy.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index bcd50a9ef47..52645cf5e12 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="it" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: la disabilitazione del nodo InProc porta a una riduzione del livello delle prestazioni quando si usano plug-in della cache del progetto che emettono richieste di compilazione proxy.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index e1a88799392..56ac6773c8a 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ja" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: „Éó„É≠„Ç≠„Ç∑„Éª„Éì„É´„ÉâË¶ÅÊ±Ç„ÇíÂá∫„Åô„Éó„É≠„Ç∏„Çß„ÇØ„Éà „Ç≠„É£„ÉÉ„Ç∑„É• „Éó„É©„Ç∞„Ç§„É≥„Çí‰ΩøÁî®„Åô„ÇãÂ†¥Âêà„ÄÅInProc „Éé„Éº„Éâ„ÇíÁÑ°Âäπ„Å´„Åô„Çã„Å®„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Åå‰Ωé‰∏ã„Åó„Åæ„Åô„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 75af46eda13..e682e068149 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: ÌîÑÎ°ùÏãú ÎπåÎìú ÏöîÏ≤≠ÏùÑ ÎÇ¥Î≥¥ÎÇ¥Îäî ÌîÑÎ°úÏ†ùÌä∏ Ï∫êÏãú ÌîåÎü¨Í∑∏ Ïù∏ÏùÑ ÏÇ¨Ïö©Ìï† Îïå inproc ÎÖ∏ÎìúÎ•º ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÎèÑÎ°ù ÏÑ§Ï†ïÌïòÎ©¥ ÏÑ±Îä•Ïù¥ Ï†ÄÌïòÎê©ÎãàÎã§.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 6ea85ee644b..bf49e4af42e 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pl" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: wy≈ÇƒÖczenie wƒôz≈Ça InProc prowadzi do obni≈ºenia wydajno≈õci, gdy u≈ºywane sƒÖ wtyczki pamiƒôci podrƒôcznej projektu, kt√≥re emitujƒÖ ≈ºƒÖdania kompilowania serwera proxy.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 68cf6eb5dd8..05415ba0bfa 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pt-BR" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: desativar o n√≥ inproc leva √† degrada√ß√£o do desempenho ao usar plug-ins de cache de projeto que emitem solicita√ß√µes de constru√ß√£o de proxy.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 51547011c53..096b82fd9b8 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏–ø—Ä–æ—Ü–µ—Å—Å–Ω–æ–≥–æ —É–∑–ª–∞ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –∑–∞–º–µ–¥–ª–µ–Ω–∏—é –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–ª–∞–≥–∏–Ω–æ–≤ –∫—ç—à–∞ –ø—Ä–æ–µ–∫—Ç–∞, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–∑–¥–∞—é—Ç –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ —Å–±–æ—Ä–∫—É –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä–∞.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 1cc28ff9a8e..07e20b02e39 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="tr" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: InProc d√ºƒü√ºm√ºn√ºn devre dƒ±≈üƒ± bƒ±rakƒ±lmasƒ±, ara sunucu olu≈üturma istekleri g√∂nderen proje √∂nbelleƒüi eklentileri kullanƒ±lƒ±rken performans d√º≈ü√º≈ü√ºne yol a√ßar.</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 4059cf492db..5f687d7838f 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: ‰ΩøÁî®ÂèëÂá∫‰ª£ÁêÜÊûÑÂª∫ËØ∑Ê±ÇÁöÑÈ°πÁõÆÁºìÂ≠òÊèí‰ª∂Êó∂ÔºåÁ¶ÅÁî® inproc ËäÇÁÇπ‰ºöÂØºËá¥ÊÄßËÉΩ‰∏ãÈôç„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 898c29d736e..ef4f8832a45 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
@@ -259,7 +259,7 @@
       </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
-        <target state="new">MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</target>
+        <target state="translated">MSB4274: ÂÅúÁî® inproc ÁØÄÈªûÊúÉÂú®‰ΩøÁî®ÂèØÁôºÂá∫ proxy ÁµÑÂª∫Ë¶ÅÊ±ÇÁöÑÂ∞àÊ°àÂø´ÂèñÂ§ñÊéõÁ®ãÂºèÊôÇÔºåÂ∞éËá¥ÊïàËÉΩÈôç‰Ωé„ÄÇ</target>
         <note />
       </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 02b46c31efa..da8165d3369 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -168,7 +168,7 @@ private string[] GetFileList
 
                 if (returnEscaped)
                 {
-                    // We must now go back and make sure all special characters are escaped because we always 
+                    // We must now go back and make sure all special characters are escaped because we always
                     // store data in the engine in escaped form so it doesn't interfere with our parsing.
                     // Note that this means that characters that were not escaped in the original filespec
                     // may now be escaped, but that's not easy to avoid.
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index 424e7dea8a9..4bf4944e94c 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -1,11 +1,8 @@
 Ôªøusing System;
-using System.Diagnostics;
 using System.IO;
-using System.Reflection;
 using System.Text;
 using System.Xml;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Internal
 {
@@ -29,16 +26,6 @@ internal static XmlReaderExtension Create(string filePath, bool loadAsReadOnly)
         private readonly Stream _stream;
         private readonly StreamReader _streamReader;
 
-        /// <summary>
-        /// Caches a <see cref="PropertyInfo"/> representing the "Normalization" internal property on the <see cref="XmlReader"/>-derived
-        /// type returned from <see cref="XmlReader.Create(TextReader, XmlReaderSettings, string)"/>. The cache is process/AppDomain-wide
-        /// and lock-free, so we use volatile access for thread safety, i.e. to ensure that when the field is updated the PropertyInfo
-        /// it's pointing to is seen as fully initialized by all CPUs.
-        /// </summary>
-        private static volatile PropertyInfo _normalizationPropertyInfo;
-
-        private static bool _disableReadOnlyLoad;
-
         private XmlReaderExtension(string file, bool loadAsReadOnly)
         {
             try
@@ -84,61 +71,15 @@ public void Dispose()
             _stream?.Dispose();
         }
 
-        /// <summary>
-        /// Returns <see cref="PropertyInfo"/> of the "Normalization" internal property on the given <see cref="XmlReader"/>-derived type.
-        /// </summary>
-        private static PropertyInfo GetNormalizationPropertyInfo(Type xmlReaderType)
-        {
-            PropertyInfo propertyInfo = _normalizationPropertyInfo;
-            if (propertyInfo == null)
-            {
-                BindingFlags bindingFlags = BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance;
-                propertyInfo = xmlReaderType.GetProperty("Normalization", bindingFlags);
-                _normalizationPropertyInfo = propertyInfo;
-            }
-
-            return propertyInfo;
-        }
-
         private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, out Encoding encoding)
         {
             string uri = new UriBuilder(Uri.UriSchemeFile, string.Empty) { Path = file }.ToString();
 
-            XmlReader reader = null;
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10) && loadAsReadOnly && !_disableReadOnlyLoad)
-            {
-                // Create an XML reader with IgnoreComments and IgnoreWhitespace set if we know that we won't be asked
-                // to write the DOM back to a file. This is a performance optimization.
-                XmlReaderSettings settings = new XmlReaderSettings
-                {
-                    DtdProcessing = DtdProcessing.Ignore,
-                    IgnoreComments = true,
-                    IgnoreWhitespace = true,
-                };
-                reader = XmlReader.Create(input, settings, uri);
-
-                // Try to set Normalization to false. We do this to remain compatible with earlier versions of MSBuild
-                // where we constructed the reader with 'new XmlTextReader()' which has normalization enabled by default.
-                PropertyInfo normalizationPropertyInfo = GetNormalizationPropertyInfo(reader.GetType());
-                if (normalizationPropertyInfo != null)
-                {
-                    normalizationPropertyInfo.SetValue(reader, false);
-                }
-                else
-                {
-                    // Fall back to using XmlTextReader if the prop could not be bound.
-                    Debug.Fail("Could not set Normalization to false on the result of XmlReader.Create");
-                    _disableReadOnlyLoad = true;
-
-                    reader.Dispose();
-                    reader = null;
-                }
-            }
-
-            if (reader == null)
-            {
-                reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };
-            }
+            
+            // Ignore loadAsReadOnly for now; using XmlReader.Create results in whitespace changes
+            // of attribute text, specifically newline removal.
+            // https://github.com/Microsoft/msbuild/issues/4210
+            XmlReader reader = new XmlTextReader(uri, input) { DtdProcessing = DtdProcessing.Ignore };
 
             reader.Read();
             encoding = input.CurrentEncoding;
diff --git a/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hans.xlf b/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hans.xlf
index 4134008b926..e49ab19ee4d 100644
--- a/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx" build-num="-1522637684">
     <header>
diff --git a/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hant.xlf b/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hant.xlf
index c5ae79dc07c..e99a3a187a1 100644
--- a/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Deprecated/Conversion/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx" build-num="-1522637684">
     <header>
diff --git a/src/Deprecated/Engine.UnitTests/Project_Tests.cs b/src/Deprecated/Engine.UnitTests/Project_Tests.cs
index 38f2844b922..1144ce87b6f 100644
--- a/src/Deprecated/Engine.UnitTests/Project_Tests.cs
+++ b/src/Deprecated/Engine.UnitTests/Project_Tests.cs
@@ -26,8 +26,8 @@ public class AddItem
     {
         /// <summary>
         /// This loads an existing project, and uses the MSBuild object model to
-        /// add a new item (Type="Compile" Include="c.cs") to the project.  Then 
-        /// it compares the final project XML to make sure the item was added in 
+        /// add a new item (Type="Compile" Include="c.cs") to the project.  Then
+        /// it compares the final project XML to make sure the item was added in
         /// the correct place.
         /// </summary>
         /// <param name="originalProjectContents"></param>
@@ -49,7 +49,7 @@ string newItemInclude
             // The project shouldn't be marked dirty yet.
             Assertion.Assert("Project shouldn't be dirty", !project.IsDirtyNeedToReevaluate);
 
-            // Add a new item (Type="Compile", Include="c.cs") to the project using 
+            // Add a new item (Type="Compile", Include="c.cs") to the project using
             // the object model.
             BuildItem newItem = project.AddNewItem(newItemType, newItemInclude);
 
@@ -143,7 +143,7 @@ public void AddNewItemToNewItemGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -151,7 +151,7 @@ public void AddNewItemToNewItemGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -170,7 +170,7 @@ public void AddNewItemToNewItemGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -179,7 +179,7 @@ public void AddNewItemToNewItemGroup()
         }
 
         /// <summary>
-        /// This loads an existing project that did not contain any items previously. 
+        /// This loads an existing project that did not contain any items previously.
         /// It then uses the MSBuild object model to
         /// add a new item to the project.  Then it compares the final project
         /// XML to make sure the item was added in the correct place.
@@ -267,9 +267,9 @@ public void AddNewItemAndQueryForNonExistentMetadata()
         }
 
         /// <summary>
-        /// Add a new item of the same name and include path of an item that already 
+        /// Add a new item of the same name and include path of an item that already
         /// exists in the project.  Current behavior is that we add the duplicated item,
-        /// although there's no great reason for this.  If we wanted, we could have 
+        /// although there's no great reason for this.  If we wanted, we could have
         /// made it so that adding a dup results in a no-op to the project file.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -701,7 +701,7 @@ public void AddNewItemThatMatchesWildcardWithMetadata()
 
         /// <summary>
         /// There's a wildcard in the project already, but it's part of a semicolon-separated
-        /// list of items.  Now the user tries to add an item that matches that wildcard.  
+        /// list of items.  Now the user tries to add an item that matches that wildcard.
         /// In this case, we don't touch the project at all.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -741,7 +741,7 @@ public void AddNewItemThatMatchesWildcardInSemicolonList()
 
         /// <summary>
         /// There's a wildcard in the project already, but it's part of a semicolon-separated
-        /// list of items, and it uses a property reference.  Now the user tries to add a new 
+        /// list of items, and it uses a property reference.  Now the user tries to add a new
         /// item that matches that wildcard.  In this case, we don't touch the project at all.
         /// We're so smart.
         /// </summary>
@@ -803,7 +803,7 @@ public void AddNewItemGroup()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -818,7 +818,7 @@ public void AddNewItemGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -826,7 +826,7 @@ public void AddNewItemGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -843,7 +843,7 @@ public void AddNewItemGroup()
                     <ItemGroup />
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -865,17 +865,17 @@ public class RemoveItem
         /// <summary>
         /// This loads an existing project, and uses the MSBuild object model to
         /// remove an item of a particular item spec (e.g., "b.cs").  It then
-        /// compares the final project XML to make sure the item was added in 
+        /// compares the final project XML to make sure the item was added in
         /// the correct place.
         /// </summary>
         /// <param name="originalProjectContents"></param>
         /// <param name="newExpectedProjectContents"></param>
         /// <param name="itemSpecToRemove"></param>
         /// <owner>RGoel</owner>
-        private void RemoveItemHelper 
+        private void RemoveItemHelper
             (
-            string originalProjectContents, 
-            string newExpectedProjectContents, 
+            string originalProjectContents,
+            string newExpectedProjectContents,
             string itemSpecToRemove
             )
         {
@@ -889,7 +889,7 @@ string itemSpecToRemove
 
             // The VS IDE does a few re-evaluations with different sets of global properties
             // (i.e., Configuration=Debug, Configuration=Release, etc.).  This is to simulate
-            // that.  If there's a bug in the Project object, then re-evaluation can 
+            // that.  If there's a bug in the Project object, then re-evaluation can
             // potentially mess up the number of items hanging around.
             project.MarkProjectAsDirty ();
             BuildItemGroup evaluatedItems2 = project.EvaluatedItemsIgnoringCondition;
@@ -936,9 +936,9 @@ public void RemoveItemBySpec()
                     <ItemGroup>
                         <Reference Include=`System` />
                     </ItemGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -957,12 +957,12 @@ public void RemoveItemBySpec()
                     <ItemGroup>
                         <Reference Include=`System` />
                     </ItemGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
-            
+
             this.RemoveItemHelper (projectOriginalContents, projectNewExpectedContents, "b.cs");
         }
 
@@ -978,7 +978,7 @@ public void RemoveItemBySpecFromMultiItemSpec()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -993,9 +993,9 @@ public void RemoveItemBySpecFromMultiItemSpec()
                     <ItemGroup>
                         <Reference Include=`System` />
                     </ItemGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1003,7 +1003,7 @@ public void RemoveItemBySpecFromMultiItemSpec()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -1019,12 +1019,12 @@ public void RemoveItemBySpecFromMultiItemSpec()
                     <ItemGroup>
                         <Reference Include=`System` />
                     </ItemGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
-            
+
             this.RemoveItemHelper (projectOriginalContents, projectNewExpectedContents, "b.cs");
         }
 
@@ -1042,7 +1042,7 @@ public void RemoveItemBySpecFromMultiItemSpecWithMetadata()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1052,7 +1052,7 @@ public void RemoveItemBySpecFromMultiItemSpecWithMetadata()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1060,7 +1060,7 @@ public void RemoveItemBySpecFromMultiItemSpecWithMetadata()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1073,10 +1073,10 @@ public void RemoveItemBySpecFromMultiItemSpecWithMetadata()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
-            
+
             this.RemoveItemHelper (projectOriginalContents, projectNewExpectedContents, "b.cs");
         }
 
@@ -1101,7 +1101,7 @@ public void RemoveItemBySpecWhenMultiItemSpecExists()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1119,10 +1119,10 @@ public void RemoveItemBySpecWhenMultiItemSpecExists()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
-            
+
             this.RemoveItemHelper (projectOriginalContents, projectNewExpectedContents, "d.cs");
         }
 
@@ -1153,7 +1153,7 @@ public void RemoveSpecificItem()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1174,7 +1174,7 @@ public void RemoveSpecificItem()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1226,7 +1226,7 @@ public void RemoveItemsByName()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1246,7 +1246,7 @@ public void RemoveItemsByName()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1287,7 +1287,7 @@ public void RemoveItemGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1303,7 +1303,7 @@ public void RemoveItemGroup()
                     </PropertyGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1667,8 +1667,8 @@ public class ModifyItem
     {
         /// <summary>
         /// This loads an existing project, and uses the MSBuild object model to
-        /// modify the "Include" attribute of an item of a particular item spec (e.g., 
-        /// "b.cs").  It then compares the final project XML to make sure the item was 
+        /// modify the "Include" attribute of an item of a particular item spec (e.g.,
+        /// "b.cs").  It then compares the final project XML to make sure the item was
         /// modified correctly.
         /// </summary>
         /// <param name="originalProjectContents"></param>
@@ -1676,10 +1676,10 @@ public class ModifyItem
         /// <param name="oldItemSpec"></param>
         /// <param name="newIncludePath"></param>
         /// <owner>RGoel</owner>
-        internal static void ModifyItemIncludeHelper 
+        internal static void ModifyItemIncludeHelper
             (
-            string originalProjectContents, 
-            string newExpectedProjectContents, 
+            string originalProjectContents,
+            string newExpectedProjectContents,
             string oldItemSpec,
             string newIncludePath
             )
@@ -1694,7 +1694,7 @@ string newIncludePath
 
             // The VS IDE does a few re-evaluations with different sets of global properties
             // (i.e., Configuration=Debug, Configuration=Release, etc.).  This is to simulate
-            // that.  If there's a bug in the Project object, then re-evaluation can 
+            // that.  If there's a bug in the Project object, then re-evaluation can
             // potentially mess up the number of items hanging around.
             project.MarkProjectAsDirty ();
             BuildItemGroup evaluatedItems2 = project.EvaluatedItemsIgnoringCondition;
@@ -1729,7 +1729,7 @@ public void ModifyItemIncludeWithEmbeddedProperty()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -1749,7 +1749,7 @@ public void ModifyItemIncludeWithEmbeddedProperty()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1757,7 +1757,7 @@ public void ModifyItemIncludeWithEmbeddedProperty()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -1777,7 +1777,7 @@ public void ModifyItemIncludeWithEmbeddedProperty()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1796,7 +1796,7 @@ public void ModifyItemIncludeWithinMultiItemSpec()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1809,7 +1809,7 @@ public void ModifyItemIncludeWithinMultiItemSpec()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1817,7 +1817,7 @@ public void ModifyItemIncludeWithinMultiItemSpec()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1836,7 +1836,7 @@ public void ModifyItemIncludeWithinMultiItemSpec()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -1888,17 +1888,17 @@ public void ModifyItemIncludeWithinNonMatchingWildcard()
         {
             // Populate the project directory with three physical files on disk -- a.weirdo, b.weirdo, c.weirdo.
             CreateThreeWeirdoFilesHelper();
-            
+
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -1906,7 +1906,7 @@ public void ModifyItemIncludeWithinNonMatchingWildcard()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
@@ -1914,7 +1914,7 @@ public void ModifyItemIncludeWithinNonMatchingWildcard()
                         <MyWildcard Include=`banana.cs` />
                         <MyWildcard Include=`c.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -1940,13 +1940,13 @@ public void ModifyItemIncludeWithinMatchingWildcard()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -1954,13 +1954,13 @@ public void ModifyItemIncludeWithinMatchingWildcard()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -1988,13 +1988,13 @@ public void ModifyRawItemIncludeWithinMatchingWildcard()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`*.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -2002,13 +2002,13 @@ public void ModifyRawItemIncludeWithinMatchingWildcard()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <ItemGroup>
                         <MyWildcard Include=`banana.weirdo` />
                     </ItemGroup>
-                
+
                 </Project>
                 ";
 
@@ -2073,8 +2073,8 @@ string itemSpec
 
         /// <summary>
         /// This loads an existing project, and uses the MSBuild object model to
-        /// modify the Name of an item of a particular item spec (e.g., 
-        /// "b.cs").  It then compares the final project XML to make sure the item was 
+        /// modify the Name of an item of a particular item spec (e.g.,
+        /// "b.cs").  It then compares the final project XML to make sure the item was
         /// modified correctly.
         /// </summary>
         /// <param name="originalProjectContents"></param>
@@ -2100,7 +2100,7 @@ string newItemType
 
             // The VS IDE does a few re-evaluations with different sets of global properties
             // (i.e., Configuration=Debug, Configuration=Release, etc.).  This is to simulate
-            // that.  If there's a bug in the Project object, then re-evaluation can 
+            // that.  If there's a bug in the Project object, then re-evaluation can
             // potentially mess up the number of items hanging around.
             project.MarkProjectAsDirty();
             BuildItemGroup evaluatedItems2 = project.EvaluatedItemsIgnoringCondition;
@@ -2270,7 +2270,7 @@ public void ModifyItemMetadata()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2285,7 +2285,7 @@ public void ModifyItemMetadata()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2293,7 +2293,7 @@ public void ModifyItemMetadata()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2311,7 +2311,7 @@ public void ModifyItemMetadata()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2338,7 +2338,7 @@ public void ModifyItemMetadata()
     public class AddProperty
     {
         /// <summary>
-        /// Tests that the object model correctly adds a new property to the correct 
+        /// Tests that the object model correctly adds a new property to the correct
         /// existing PropertyGroup.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -2348,23 +2348,23 @@ public void SetPropertyOnNewPropertyInExistingPropertyGroup()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup Condition=` '$(A)' == 'B' `>
                         <OutputPath>c:\blah</OutputPath>
                     </PropertyGroup>
-                
+
                     <PropertyGroup>
                         <WarningLevel>1</WarningLevel>
                     </PropertyGroup>
-                
+
                     <PropertyGroup>
                         <Optimize>true</Optimize>
                     </PropertyGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2372,24 +2372,24 @@ public void SetPropertyOnNewPropertyInExistingPropertyGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup Condition=` '$(A)' == 'B' `>
                         <OutputPath>c:\blah</OutputPath>
                     </PropertyGroup>
-                
+
                     <PropertyGroup>
                         <WarningLevel>1</WarningLevel>
                         <MyNewProperty>woohoo</MyNewProperty>
                     </PropertyGroup>
-                
+
                     <PropertyGroup>
                         <Optimize>true</Optimize>
                     </PropertyGroup>
-                
+
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2398,7 +2398,7 @@ public void SetPropertyOnNewPropertyInExistingPropertyGroup()
             // The project shouldn't be marked dirty yet.
             Assertion.Assert("Project shouldn't be dirty", !project.IsDirtyNeedToReevaluate);
 
-            // Set the given new property in the project file using 
+            // Set the given new property in the project file using
             // the object model.
             project.SetProperty("MyNewProperty", "woohoo", "");
 
@@ -2419,7 +2419,7 @@ public void AddNewPropertyThroughPropertyGroup()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2434,7 +2434,7 @@ public void AddNewPropertyThroughPropertyGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2442,7 +2442,7 @@ public void AddNewPropertyThroughPropertyGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2458,7 +2458,7 @@ public void AddNewPropertyThroughPropertyGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2484,7 +2484,7 @@ public void AddNewPropertyGroup()
             // ************************************
             //               BEFORE
             // ************************************
-            string projectOriginalContents = @" 
+            string projectOriginalContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2499,7 +2499,7 @@ public void AddNewPropertyGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2507,7 +2507,7 @@ public void AddNewPropertyGroup()
             // ************************************
             //               AFTER
             // ************************************
-            string projectNewExpectedContents = @" 
+            string projectNewExpectedContents = @"
                 <Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
 
                     <PropertyGroup>
@@ -2524,7 +2524,7 @@ public void AddNewPropertyGroup()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2640,7 +2640,7 @@ public void RemovePropertyByName()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2663,7 +2663,7 @@ public void RemovePropertyByName()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -2914,7 +2914,7 @@ public void RemoveAllPropertyGroupsByConditionWithChoose()
                             <PropertyGroup Condition=`'$(x)'=='y'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
-  
+
                             <PropertyGroup Condition=`'$(x)'=='z'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
@@ -2923,7 +2923,7 @@ public void RemoveAllPropertyGroupsByConditionWithChoose()
                             <PropertyGroup Condition=`'$(x)'=='y'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
-  
+
                             <PropertyGroup Condition=`'$(x)'=='z'`>
                                   <ReferencePath>c:\foobar</ReferencePath>
                             </PropertyGroup>
@@ -3112,7 +3112,7 @@ public void SetPropertyOnExistingProperty()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -3135,7 +3135,7 @@ public void SetPropertyOnExistingProperty()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -3446,7 +3446,7 @@ public void VerifyMsbuildProgramFiles32ReservedProperty()
                                 <PropertyGroup>
                                     <abcdef>$(MsBuildProgramFiles32)</abcdef>
                                 </PropertyGroup>
-                                
+
                                 <Target Name='t'>
                                     <Message Text='[$(abcdef)]' />
                                 </Target>
@@ -3513,7 +3513,7 @@ public void ModifyPropertyInImportedProjectFileAfterRename()
             Assertion.AssertEquals(@"c:\boobah", importedProj.EvaluatedProperties["ReferencePath"].FinalValueEscaped);
 
             importedProj.Save(Path.Combine(ObjectModelHelpers.TempProjectDir, "newimported.proj"));
-                
+
             // Now we add a new imported property to the main file, into an existing imported
             // property group.
             mainProj.SetImportedProperty("ReferencePath", @"c:\hoohah", null, importedProj);
@@ -3785,7 +3785,7 @@ public void RegistryProperties()
 
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                   <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                   <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <P>$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"@Foo)</P>
                         <Q Condition=""'$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"@Foo)' == 'FooValue'"">QValue</Q>
@@ -3812,7 +3812,7 @@ public void RegistryPropertiesWithEscapedCharactersInValue()
 
             Project p = ObjectModelHelpers.CreateInMemoryProject(@"
 
-                   <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`> 
+                   <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <P>$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"@Foo)</P>
                         <Q Condition=""'$(Registry:HKEY_CURRENT_USER\" + testRegistryPath + @"@Bar)' == '%24(Foo)'"">QValue</Q>
@@ -3834,7 +3834,7 @@ public class QueryProjectState
     {
         /// <summary>
         /// This tests the Project.EvaluatedItemsIgnoringCondition property.  This
-        /// property should return the list of evaluated items in the project, 
+        /// property should return the list of evaluated items in the project,
         /// pretending that all "Condition"s evaluated to true.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -3856,7 +3856,7 @@ public void GetEvaluatedItemsIgnoringCondition()
                     </ItemGroup>
 
                     <Target Name=`Build` />
-                
+
                 </Project>
                 ";
 
@@ -4098,7 +4098,7 @@ public void ReplaceImport()
     public class Evaluation
     {
         /// <summary>
-        /// Relative paths in 'exists' on conditions should be evalauted relative to the 
+        /// Relative paths in 'exists' on conditions should be evalauted relative to the
         /// project directory.
         /// </summary>
         [Test]
@@ -4142,7 +4142,7 @@ public void ImportConditionsEvaluatedUsingProjectsDirectory()
         }
 
         /// <summary>
-        /// Relative paths in 'exists' on conditions should be evalauted relative to the 
+        /// Relative paths in 'exists' on conditions should be evalauted relative to the
         /// project directory.
         /// </summary>
         [Test]
@@ -4181,7 +4181,7 @@ public void PropertyConditionsEvaluatedUsingProjectsDirectory()
         }
 
         /// <summary>
-        /// Relative paths in 'exists' on conditions should be evalauted relative to the 
+        /// Relative paths in 'exists' on conditions should be evalauted relative to the
         /// project directory.
         /// </summary>
         [Test]
@@ -4387,7 +4387,7 @@ public void InvalidMetadataName()
                         <a Include=`x`>
                             <meta.data>foo</meta.data>
                         </a>
-                    </ItemGroup>        
+                    </ItemGroup>
                     <Target Name=`t` />
                 </Project>
                 ";
@@ -4432,7 +4432,7 @@ public void IllegalCharactersInUsingTaskAssemblyFile()
 
             Project project = ObjectModelHelpers.CreateInMemoryProject(original);
         }
-        
+
         /// <summary>
         /// Unknown attribute on UsingTask should throw
         /// </summary>
@@ -4449,7 +4449,7 @@ public void UnknownAttributeInUsingTask()
 
             // Should throw
             Project project = ObjectModelHelpers.CreateInMemoryProject(original);
-        }                  
+        }
 
         /// <summary>
         /// RequiredRuntime attribute on UsingTask should be ignored
@@ -4467,10 +4467,10 @@ public void RequiredRuntimeAttributeInUsingTask()
 
             // Should not throw
             Project project = ObjectModelHelpers.CreateInMemoryProject(original);
-        }        
+        }
 
         /// <summary>
-        /// Tests that putting invalid characters in the <Import> path results in a 
+        /// Tests that putting invalid characters in the <Import> path results in a
         /// InvalidProjectFileException.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -4589,7 +4589,7 @@ public void SetNewGlobalProperty()
         }
 
         /// <summary>
-        /// This tests that the project is NOT marked as dirty when we set a 
+        /// This tests that the project is NOT marked as dirty when we set a
         /// global property to the exact same value it had before.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -4649,7 +4649,7 @@ public void MSBuildExtensionsPathDefault()
             {
                 expectedValue = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
             }
-     
+
             Assertion.AssertEquals(expectedValue + @"\MSBuild",
                 (string)myProject.EvaluatedProperties[specialPropertyName]);
 
@@ -4664,7 +4664,7 @@ public void MSBuildExtensionsPathDefault()
         public void MSBuildExtensionsPathDefault_Legacy()
         {
             string specialPropertyName = "MSBuildExtensionsPath";
-            
+
             // Save the old copy of the MSBuildExtensionsPath, so we can restore it when the unit test is done.
             string backupMSBuildExtensionsPath = Environment.GetEnvironmentVariable(specialPropertyName);
             string backupMagicSwitch = Environment.GetEnvironmentVariable("MSBUILDLEGACYEXTENSIONSPATH");
@@ -4753,7 +4753,7 @@ public void MSBuildExtensionsPathWithGlobalOverride()
         }
 
         /// <summary>
-        /// The default value for $(MSBuildExtensionsPath32) should point to "c:\program files (x86)\msbuild" on a 64 bit machine. 
+        /// The default value for $(MSBuildExtensionsPath32) should point to "c:\program files (x86)\msbuild" on a 64 bit machine.
         /// We can't test that directly since tests generally don't run on 64 bit boxes. However we can set the "ProgramFiles(x86)"
         /// environment variable and make sure that that's the value used.
         /// </summary>
@@ -5006,7 +5006,7 @@ public void MSBuildStartupDirectory()
     public class LoadAndSave
     {
         /// <summary>
-        /// Just load an MSBuild project by passing in a TextReader, and get back the contents to 
+        /// Just load an MSBuild project by passing in a TextReader, and get back the contents to
         /// make sure the project was read in correctly.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -5206,7 +5206,7 @@ public void RemoveMissingImportAndLoadNormally()
             // Save the modified project
             StringWriter writer = new StringWriter();
             project.Save(writer);
-            
+
             // Load the modified project into a new project object
             xmldoc = new XmlDocument();
             xmldoc.LoadXml(writer.ToString());
@@ -5258,7 +5258,7 @@ public void FailingTargetsDoNotHaveOutputs()
         }
 
         /// <summary>
-        /// Checks to make sure that passing in the DoNotResetPreviouslyBuiltTargets flag 
+        /// Checks to make sure that passing in the DoNotResetPreviouslyBuiltTargets flag
         /// works as expected.
         /// </summary>
         /// <owner>JomoF</owner>
@@ -5287,7 +5287,7 @@ public void CheckDoNotResetPreviouslyBuiltTargets()
             // At this point, the property $(FileExists) should be 'true'
             Assertion.AssertEquals("true", p.GetEvaluatedProperty("FileExists"));
 
-            // Delete the file 
+            // Delete the file
             File.Delete(tempFile);
 
             // Build again. The result should still be 'true' because the target won't be reevaluated.
@@ -5353,7 +5353,7 @@ public void RunInitialTargetsInMainProject()
 
             // Build the target.
             p.Build(null, null);
-        
+
             Assertion.Assert("Build target should have been run.", myLogger.FullLog.Contains("BuildTargetExecuted"));
             Assertion.Assert("CheckForErrors target should have been run.", myLogger.FullLog.Contains("CheckForErrorsTargetExecuted"));
         }
@@ -5457,14 +5457,14 @@ public void RunInitialTargetsInMainAndImportedProjects()
 
                     ", importedProject1, importedProject2));
 
-                Assertion.AssertEquals("Check all InitialTargets", "CheckForBadUser; CheckForBadProperties; CheckForBadConfigurations", 
+                Assertion.AssertEquals("Check all InitialTargets", "CheckForBadUser; CheckForBadProperties; CheckForBadConfigurations",
                     p.InitialTargets);
 
                 // Build the default target.
                 p.Build(null, null);
 
                 DumpBuildItemGroup(p.GetEvaluatedItemsByName("TargetOrder"));
-            
+
                 // The following method will ensure that the targets were executed in the correct order.
                 EngineHelpers.AssertItemsMatch(@"
                     CheckForBadUser_Executed
@@ -5479,14 +5479,14 @@ public void RunInitialTargetsInMainAndImportedProjects()
                 // Change the InitialTargets on the main project to be "NewChecks", but do it via an environment variable.
                 p.InitialTargets = "$(MyNewChecks)";
 
-                Assertion.AssertEquals("Check all InitialTargets", "NewChecks; CheckForBadProperties; CheckForBadConfigurations", 
+                Assertion.AssertEquals("Check all InitialTargets", "NewChecks; CheckForBadProperties; CheckForBadConfigurations",
                     p.InitialTargets);
 
                 // Build the default target.
                 p.Build(null, null);
 
                 DumpBuildItemGroup(p.GetEvaluatedItemsByName("TargetOrder"));
-            
+
                 // The following method will ensure that the targets were executed in the correct order.
                 EngineHelpers.AssertItemsMatch(@"
                     NewChecks_Executed
@@ -5555,7 +5555,7 @@ public void ModifyInitialTargetsInMainProject()
 
             // Build the default target.
             p.Build(null, null);
-        
+
             Assertion.Assert("Build target should have been run.", myLogger.FullLog.Contains("BuildTargetExecuted"));
             Assertion.Assert("CheckForErrors target should have been run.", myLogger.FullLog.Contains("CheckForErrorsTargetExecuted"));
         }
@@ -5680,7 +5680,7 @@ public void SetGetProjectExtensions()
         }
 
         /// <summary>
-        /// There is a certain error that the MSBuild engine fires when you try to do a build on 
+        /// There is a certain error that the MSBuild engine fires when you try to do a build on
         /// a project that has had its targets disabled because of security.  However, the project
         /// system doesn't want to show this error to the user because it's not actionable for
         /// the user.  So it looks for code MSB4112 to throw away this error.  Here we're just
@@ -5693,10 +5693,10 @@ public void VerifySecurityErrorHasCodeMSB4112()
         {
             ResourceManager resourceManager = new ResourceManager("Microsoft.Build.Engine.Resources.Strings", typeof(Project).Assembly);
             string securityMessage = resourceManager.GetString("SecurityProjectBuildDisabled", CultureInfo.CurrentUICulture);
-            
-            Assertion.Assert( 
+
+            Assertion.Assert(
                 "Security message about disabled targets need to have code MSB4112, because code in the VS Core project system depends on this.  See DesignTimeBuildFeedback.cpp.",
-                securityMessage.Contains("MSB4112") 
+                securityMessage.Contains("MSB4112")
             );
         }
 
@@ -5790,12 +5790,12 @@ public void RegressVsWhidbey579075()
                     </Target>
                 </Project>
                 ", logger);
-            
+
             // Set a property and force project evaluation
             project.SetProperty("Configuration", "Release");
             BuildPropertyGroup evaluatedProperties = project.EvaluatedProperties;
 
-            // Set a different value of the property and build without forced reevaluation, 
+            // Set a different value of the property and build without forced reevaluation,
             // check if the new value is passed to the logger
             project.SetProperty("Configuration", "Debug");
             project.Build();
@@ -5815,7 +5815,7 @@ public void VersionBasedMSBuildBinPathDefault()
                     <Target Name=`Build`/>
                 </Project>", null);
 
-            Assertion.AssertEquals("Nonexistent ToolsVersion should evaluate to the default version", 
+            Assertion.AssertEquals("Nonexistent ToolsVersion should evaluate to the default version",
                 Constants.defaultToolsVersion, project.ToolsVersion);
 
             Assertion.AssertEquals("Nonexistent ToolsVersion should mean ToolsVersionAttribute is the default version",
@@ -5823,7 +5823,7 @@ public void VersionBasedMSBuildBinPathDefault()
 
             Assertion.AssertEquals("BinPath is the MSBuildBinPath for the default version",
                 "www.msbuild.org", project.EvaluatedProperties[ReservedPropertyNames.binPath].FinalValue);
-            
+
             Assertion.AssertEquals("BinPath is the MSBuildToolsPath for the default version",
                 "www.msbuild.org", project.EvaluatedProperties[ReservedPropertyNames.toolsPath].FinalValue);
         }
@@ -5839,7 +5839,7 @@ public void VersionBasedMSBuildBinPathExplicit()
                     <Target Name=`Build`/>
                 </Project>", null);
 
-            Assertion.AssertEquals("ToolsVersion should have been picked up from the project attribute", 
+            Assertion.AssertEquals("ToolsVersion should have been picked up from the project attribute",
                 "myValidToolsVersion", project.ToolsVersion);
 
             Assertion.AssertEquals("ToolsVersionAttribute should have been picked up from the project attribute",
@@ -6010,7 +6010,7 @@ public void MSBuildToolsVersionProperty()
 
             Project project = ObjectModelHelpers.CreateInMemoryProject(e, ObjectModelHelpers.CleanupFileContents(@"
                 <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
-                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>    
+                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>
                     <Target Name=`Build`>
                         <Message Text=`##$(MSBuildToolsVersion)##`/>
                     </Target>
@@ -6031,7 +6031,7 @@ public void MSBuildToolsVersionProperty2()
 
             Project project = ObjectModelHelpers.CreateInMemoryProject(e, ObjectModelHelpers.CleanupFileContents(@"
                 <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
-                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>    
+                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>
                     <Target Name=`Build`>
                         <Message Text=`##$(MSBuildToolsVersion)##`/>
                     </Target>
@@ -6054,7 +6054,7 @@ public void SetEffectiveToolsVersionAttribute()
 
             Project project = ObjectModelHelpers.CreateInMemoryProject(e, ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion=`myValidToolsVersion` DefaultTargets=`Build` xmlns=`msbuildnamespace`>
-                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>    
+                    <UsingTask TaskName='Message' AssemblyName='Microsoft.Build.Tasks.Core, Version=msbuildassemblyversion, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'/>
                     <PropertyGroup>
                        <TheToolsVersion>$(MSBuildToolsVersion)</TheToolsVersion>
                     </PropertyGroup>
@@ -6130,4 +6130,3 @@ public void PropertiesFromToolsetAppliedToProjectWhenToolsVersionOverridden()
         }
     }
 }
-
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index 5a5ff319324..da393b51c0c 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -435,7 +435,7 @@ internal void ReportUnhandledError(Exception originalException)
                 }
                 catch (Exception ex)
                 {
-                    // If an error occurred while trying to send the original exception to the parent 
+                    // If an error occurred while trying to send the original exception to the parent
                     // rethrow the original exception
                     string message = ResourceUtilities.FormatResourceString("FatalErrorOnChildNode", nodeId, ex.Message);
 
@@ -630,7 +630,7 @@ private void NodeLocalEngineLoop()
         private ManualResetEvent exitNodeEvent;
         // The engine being used to process build requests
         private Engine localEngine;
-        // The queue of build requests arriving from the parent. The queue is needed to buffer the requests while the local engine is 
+        // The queue of build requests arriving from the parent. The queue is needed to buffer the requests while the local engine is
         // being created and initialized
         private Queue<BuildRequest> buildRequests;
         // This flag is true if the thread that will be running the Engine.BuildLoop has been launched
diff --git a/src/Deprecated/Engine/Introspector/Introspector.cs b/src/Deprecated/Engine/Introspector/Introspector.cs
index a4c0f0cfc87..203896320f5 100644
--- a/src/Deprecated/Engine/Introspector/Introspector.cs
+++ b/src/Deprecated/Engine/Introspector/Introspector.cs
@@ -26,7 +26,7 @@ internal Introspector(Engine parentEngine, ProjectManager projectManager, NodeMa
         /// <summary>
         /// This method is called when the parent engine doesn't see activity for a preset time period to
         /// determine if the whole system is making forward progress. In order to that, status is collected
-        /// from every node in the system. If no node is making forward progress then the graph of all the 
+        /// from every node in the system. If no node is making forward progress then the graph of all the
         /// inprogress targets is analyzed for cycles. If a cycle is found the appropriate node is instructed
         /// to break it. If no cause for deadlock can be determined the system is shutdown.
         /// </summary>
@@ -90,7 +90,7 @@ internal int DetectDeadlock( int queueCounts, long lastLoopActivity, int current
                 }
                 else if (nodeStatus[i].HasExited)
                 {
-                    // A node has exited prematurely. The only option is to shutdown 
+                    // A node has exited prematurely. The only option is to shutdown
                     LogOrDumpError("ChildExitedPrematurely", i + 1);
 
                     SystemShutdown();
@@ -142,7 +142,7 @@ internal int DetectDeadlock( int queueCounts, long lastLoopActivity, int current
                                                   cycleDetector.CycleEdgeParent);
                 // Use the amount of time it took us to receive the NodeStatus and buffer it a little because node status is sent via a faster code path
                 ignoreTimeout = DateTime.Now.Ticks + requestDurationTime + (cycleBreakTimeout * TimeSpan.TicksPerMillisecond);
-                return currentTimeout; 
+                return currentTimeout;
             }
 
             // The system doesn't appear to be making progress. Switch to a largest sampling interval.
@@ -208,7 +208,7 @@ private void LogOrDumpError(string resourceName, params object[] args)
         }
 
         /// <summary>
-        /// Adds a set of nodeStatus's to the cycle graph 
+        /// Adds a set of nodeStatus's to the cycle graph
         /// </summary>
         private void AddTargetStatesToCycleDetector(NodeStatus[] nodeStatus, TargetCycleDetector cycleDetector)
         {
@@ -229,7 +229,7 @@ private void GatherNodeInformationForShutdown(NodeStatus[] nodeStatus, NodeStatu
             {
                 TimeSpan timeSinceLastNodeTaskActivity = new TimeSpan(nodeStatus[i].TimeSinceLastTaskActivity);
                 TimeSpan timeSinceLastNodeLoopActivity = new TimeSpan(nodeStatus[i].TimeSinceLastLoopActivity);
- 
+
                 Console.WriteLine("Status: " + i + " Task Activity " + timeSinceLastNodeTaskActivity.TotalMilliseconds +
                                   " Loop Activity " + timeSinceLastNodeLoopActivity.TotalMilliseconds + " Queue depth " +
                                   nodeStatus[i].QueueDepth);
@@ -262,11 +262,11 @@ internal void SystemShutdown()
 
 
         /// <summary>
-        /// This function is called to break the link between two targets that creates a cycle. The link could be 
+        /// This function is called to break the link between two targets that creates a cycle. The link could be
         /// due to depends/onerror relationship between parent and child. In that case both parent and child are
-        /// on the same node and within the same project. Or the link could be formed by an IBuildEngine callback 
-        /// (made such by tasks such as MSBuild or CallTarget) in which case there maybe multiple requests forming 
-        /// same link between parent and child. Also in that case parent and child maybe on different nodes and/or in 
+        /// on the same node and within the same project. Or the link could be formed by an IBuildEngine callback
+        /// (made such by tasks such as MSBuild or CallTarget) in which case there maybe multiple requests forming
+        /// same link between parent and child. Also in that case parent and child maybe on different nodes and/or in
         /// different projects. In either case the break is forced by finding the correct builds states and causing
         /// them to fail.
         /// </summary>
@@ -291,7 +291,7 @@ internal void BreakCycle(TargetInProgessState child, TargetInProgessState parent
             {
                 parentStates[i].CurrentBuildContextState = ProjectBuildState.BuildContextState.CycleDetected;
                 TaskExecutionContext taskExecutionContext =
-                    new TaskExecutionContext(parentProject, childTarget, null, parentStates[i], EngineCallback.invalidEngineHandle, 
+                    new TaskExecutionContext(parentProject, childTarget, null, parentStates[i], EngineCallback.invalidEngineHandle,
                                              EngineCallback.inProcNode, null);
 
                 parentEngine.PostTaskOutputUpdates(taskExecutionContext);
@@ -305,7 +305,7 @@ internal void BreakCycle(TargetInProgessState child, TargetInProgessState parent
         /// </summary>
         internal List<ProjectBuildState> FindConnectingContexts
         (
-            TargetInProgessState child, 
+            TargetInProgessState child,
             TargetInProgessState parent,
             Target childTarget,
             List<ProjectBuildState> waitingStates,
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
index 07cc648695e..eb73adeb434 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
@@ -59,7 +59,7 @@ string startupDirectory
             }
 
             /* If we dont get a path passed in as a parameter, we can only assume that our path
-             is in the current appdomain basedirectory, this is the base directory 
+             is in the current appdomain basedirectory, this is the base directory
               that the assembly resolver uses to probe for assemblies
            */
             if (string.IsNullOrEmpty(this.locationOfMSBuildExe))
@@ -90,7 +90,7 @@ string startupDirectory
                 lastUsedNodeNumber = nodeData[i].NodeNumber + 1;
             }
 
-            // Set up the callback 
+            // Set up the callback
             this.engineCallback = parentEngineCallback;
             this.parentGlobalProperties = parentGlobalPropertyGroup;
             this.toolsetSearchLocations = toolSetSearchLocations;
@@ -228,7 +228,7 @@ public void PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest)
             if (nodeData[nodeIndex].NodeState != NodeState.Launched)
             {
                 // Note that we have to check the node status again inside the mutex. This
-                // ensures that that after flipping the status to launched inside the mutex 
+                // ensures that that after flipping the status to launched inside the mutex
                 // there will be no more writes to the queue of targets waiting to be sent
                 lock (nodeStateLock)
                 {
@@ -319,7 +319,7 @@ public void ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
                 }
             }
 
-            // Reset the shutdown response received properties incase the nodes are going 
+            // Reset the shutdown response received properties incase the nodes are going
             // to be used for another build on the same engine.
             foreach (LocalNodeInfo nodeInfo in nodeData)
             {
@@ -459,7 +459,7 @@ private void TerminateChildNode(int processId)
             }
             catch (System.ComponentModel.Win32Exception)
             {
-                // The exception indicates that the child process is no longer running or 
+                // The exception indicates that the child process is no longer running or
                 // the parent cannot access the child process information due to insufficent security permissions
             }
         }
@@ -697,7 +697,7 @@ private void InitializeNode(int nodeIndex)
                         nodeInUseEvent.Close();
 
                         // If the node is still active and has not replied to the initialization message it must
-                        // be in bad state - try to get that node to exit 
+                        // be in bad state - try to get that node to exit
                         if (!nodeConnected && checkIfNodeActive(nodeData[nodeIndex].NodeNumber))
                         {
                             EventWaitHandle nodeShutdownEvent = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeErrorShutdownEventName(nodeData[nodeIndex].NodeNumber));
@@ -738,7 +738,7 @@ private static  bool checkIfNodeActive(int nodeNumber)
             }
             catch (WaitHandleCannotBeOpenedException)
             {
-                // Assume that the node is not running 
+                // Assume that the node is not running
             }
             finally
             {
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hans.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hans.xlf
index 031b8bc6e53..95cc52355de 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx" build-num="-1944534404">
     <header>
diff --git a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
index 52c6f2222ec..9d065a332ba 100644
--- a/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Deprecated/Engine/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx" build-num="-1944534404">
     <header>
diff --git a/src/Deprecated/Engine/Shared/ErrorUtilities.cs b/src/Deprecated/Engine/Shared/ErrorUtilities.cs
index 213310ce25e..1af0f4ceb05 100644
--- a/src/Deprecated/Engine/Shared/ErrorUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ErrorUtilities.cs
@@ -32,7 +32,7 @@ internal static void LaunchMsBuildDebuggerOnFatalError()
         /// Puts up an assertion dialog in debug builds, and throws an exception in
         /// both debug and release builds. Since this is not a no-op in release builds,
         /// it should not be called repeatedly in performance-critical scenarios.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -48,7 +48,7 @@ private static void ThrowInternalError
             params object[] args
         )
         {
-            // We ignore showAssert:  we don't want to show the assert dialog no matter what. 
+            // We ignore showAssert:  we don't want to show the assert dialog no matter what.
             throw new InternalErrorException(ResourceUtilities.FormatString(unformattedMessage, args));
         }
 
@@ -243,7 +243,7 @@ object arg3
 
         /// <summary>
         /// Throws an InvalidOperationException.
-        /// 
+        ///
         /// PERF WARNING: calling a method that takes a variable number of arguments
         /// is expensive, because memory is allocated for the array of arguments -- do
         /// not call this method repeatedly in performance-critical scenarios
@@ -597,7 +597,7 @@ internal static void VerifyThrowArgumentNull(object parameter, string parameterN
         {
             if (parameter == null)
             {
-                // Most ArgumentNullException overloads append its own rather clunky multi-line message. 
+                // Most ArgumentNullException overloads append its own rather clunky multi-line message.
                 // So use the one overload that doesn't.
                 throw new ArgumentNullException(
                     ResourceUtilities.FormatResourceString(resourceName, parameterName),
diff --git a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
index fd30818c312..bf0b4845cec 100644
--- a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
+++ b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.BuildEngine.Shared
     internal static class FrameworkLocationHelper
     {
         #region Private and internal members
-        
+
         /// <summary>
         /// By default when a root path is not specified we would like to use the program files directory \ reference assemblies\framework as the root location
         /// to generate the reference assembly paths from.
@@ -48,9 +48,9 @@ internal static class FrameworkLocationHelper
         internal const string fullDotNetFrameworkSdkRegistryKeyV35 = "HKEY_LOCAL_MACHINE\\" + dotNetFrameworkSdkRegistryPathV35;
         private const string dotNetFrameworkRegistryKeyV35 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV35;
         internal const string dotNetFrameworkSdkInstallKeyValueV35 = "InstallationFolder";
-       
+
         internal const string dotNetFrameworkVersionFolderPrefixV35 = "v3.5"; // v3.5 is for Orcas.
-        
+
         private const string dotNetFrameworkAssemblyFoldersRegistryKeyV35 = dotNetFrameworkAssemblyFoldersRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV35;
         private const string secondaryDotNetFrameworkSdkRegistryPathV35 = "SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows";
         internal const string secondaryDotNetFrameworkSdkInstallKeyValueV35 = "CurrentInstallFolder";
@@ -66,8 +66,7 @@ internal static class FrameworkLocationHelper
         internal const string secondaryDotNetFrameworkSdkInstallKeyValueV40 = "CurrentInstallFolder";
         private const string dotNetFrameworkRegistryKeyV40 = dotNetFrameworkSetupRegistryPath + "\\v4\\Full";
         private static readonly GetDirectories getDirectories = new GetDirectories(Directory.GetDirectories);
-        
-        
+
         private static string pathToDotNetFrameworkV11;
         internal static string PathToDotNetFrameworkV11
         {
@@ -249,13 +248,13 @@ internal static string PathToDotNetFrameworkSdkV35
                         dotNetFrameworkSdkInstallKeyValueV35);
 
                     // Because there is no longer a strong 1:1 mapping between FX versions and SDK
-                    // versions, if we're unable to locate the desired SDK version, we will try to 
+                    // versions, if we're unable to locate the desired SDK version, we will try to
                     // use whichever SDK version is installed by looking at the key pointing to the
                     // "latest" version.
                     //
-                    // This isn't ideal, but it will allow our tasks to function on any of several 
+                    // This isn't ideal, but it will allow our tasks to function on any of several
                     // related SDKs even if they don't have exactly the same versions.
-                    
+
                     if (String.IsNullOrEmpty(FrameworkLocationHelper.pathToDotNetFrameworkSdkV35))
                     {
                         FrameworkLocationHelper.pathToDotNetFrameworkSdkV35 = FindRegistryValueUnderKey(
@@ -281,11 +280,11 @@ internal static string PathToDotNetFrameworkSdkV40
                         dotNetFrameworkSdkInstallKeyValueV40);
 
                     // Because there is no longer a strong 1:1 mapping between FX versions and SDK
-                    // versions, if we're unable to locate the desired SDK version, we will try to 
+                    // versions, if we're unable to locate the desired SDK version, we will try to
                     // use whichever SDK version is installed by looking at the key pointing to the
                     // "latest" version. For example, instead of 6.0A, we might fall back to 6.0B.
                     //
-                    // This isn't ideal, but it will allow our tasks to function on any of several 
+                    // This isn't ideal, but it will allow our tasks to function on any of several
                     // related SDKs even if they don't have exactly the same versions.
 
                     if (String.IsNullOrEmpty(FrameworkLocationHelper.pathToDotNetFrameworkSdkV40))
@@ -506,7 +505,7 @@ GetDirectories getDirectories
             // The intention here is to choose the alphabetical maximum.
             string max = directories[0];
 
-            // the max.EndsWith condition: pre beta 2 versions of v3.5 have build number like v3.5.20111.  
+            // the max.EndsWith condition: pre beta 2 versions of v3.5 have build number like v3.5.20111.
             // This was removed in beta2
             // We should favor \v3.5 over \v3.5.xxxxx
             // versions previous to 2.0 have .xxxx version numbers.  3.0 and 3.5 do not.
@@ -530,7 +529,7 @@ GetDirectories getDirectories
         }
 
         #endregion
- 
+
         /// <summary>
         /// Determine the 32 bit program files directory, this is used for finding where the reference assemblies live.
         /// </summary>
@@ -549,7 +548,7 @@ internal static string GenerateProgramFiles32()
         }
 
         /// <summary>
-        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then 
+        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then
         /// using that path to generate the path to the reference assemblies location.
         /// </summary>
         internal static string GenerateProgramFilesReferenceAssemblyRoot()
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 6301a6116e5..913c97b1281 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -110,7 +110,7 @@
     <DefineConstants Condition="$([MSBuild]::IsOSPlatform('windows'))">$(DefineConstants);TEST_ISWINDOWS</DefineConstants>
   </PropertyGroup>
 
-  <PropertyGroup Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp1.0')) or $(TargetFramework.StartsWith('netstandard')))">
+  <PropertyGroup Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETCoreApp' or $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETStandard')">
     <NetCoreBuild>true</NetCoreBuild>
     <DefineConstants>$(DefineConstants);RUNTIME_TYPE_NETCORE</DefineConstants>
   </PropertyGroup>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 8e0072633ea..fa1e0d4275b 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -55,6 +55,8 @@
     <PackageReference Include="xunit.core" />
     <PackageReference Include="xunit.assert" />
 
+    <PackageReference Include="Microsoft.DotNet.XUnitExtensions" />
+
     <!-- Don't localize unit test projects -->
     <PackageReference Remove="XliffTasks" />
 
@@ -67,6 +69,9 @@
          PrivateAssets to keep this reference (auto-added when targeting netcoreapp*)
          from making it into our NuGet packages. -->
     <PackageReference Update="Microsoft.NETCore.App" PrivateAssets="All" />
+
+    <!-- Configure analyzer to forbid certain API calls -->
+    <AdditionalFiles Include="$(MSBuildThisFileDirectory)BannedSymbols.txt" />
   </ItemGroup>
 
   <!-- GenAPI settings -->
@@ -78,9 +83,9 @@
   <PropertyGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true' and $([MSBuild]::IsOSPlatform('windows'))">
     <GenAPIAssemblyName>$(AssemblyName)</GenAPIAssemblyName>
     <GenAPIAssemblyName Condition="'$(GenAPIAssemblyName)' == ''">$(MSBuildProjectName)</GenAPIAssemblyName>
-    <GenAPIShortFrameworkIdentifier Condition=" '$(TargetFrameworkIdentifier)' == '.NETFramework' ">net</GenAPIShortFrameworkIdentifier>
-    <GenAPIShortFrameworkIdentifier Condition="$(TargetFramework.StartsWith('netstandard'))">netstandard</GenAPIShortFrameworkIdentifier>
-    <GenAPIShortFrameworkIdentifier Condition="$([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp1.0'))">netstandard</GenAPIShortFrameworkIdentifier>
+    <GenAPIShortFrameworkIdentifier Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">net</GenAPIShortFrameworkIdentifier>
+    <GenAPIShortFrameworkIdentifier Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETStandard'">netstandard</GenAPIShortFrameworkIdentifier>
+    <GenAPIShortFrameworkIdentifier Condition="$([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETCoreApp'">netstandard</GenAPIShortFrameworkIdentifier>
     <GenAPITargetPath>$(RepoRoot)ref\$(GenAPIAssemblyName)\$(GenAPIShortFrameworkIdentifier)\$(GenAPIAssemblyName).cs</GenAPITargetPath>
   </PropertyGroup>
 
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 7761c468d44..d97becfa1d0 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -22,10 +22,9 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves-Dev.md
     internal class ChangeWaves
     {
-        internal static readonly Version Wave16_8 = new Version(16, 8);
         internal static readonly Version Wave16_10 = new Version(16, 10);
         internal static readonly Version Wave17_0 = new Version(17, 0);
-        internal static readonly Version[] AllWaves = { Wave16_8, Wave16_10, Wave17_0 };
+        internal static readonly Version[] AllWaves = { Wave16_10, Wave17_0 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
new file mode 100644
index 00000000000..b2b5fa9b281
--- /dev/null
+++ b/src/Framework/EngineServices.cs
@@ -0,0 +1,41 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Exposes build engine functionality that was made available in newer versions of MSBuild.
+    /// </summary>
+    /// <remarks>
+    /// Make all members virtual but not abstract, ensuring that implementations can override them and external implementations
+    /// won't break when the class is extended with new members. This base implementation should be throwing <see cref="NotImplementedException"/>.
+    /// </remarks>
+    [Serializable]
+    public abstract class EngineServices
+    {
+        /// <summary>
+        /// Initial version with LogsMessagesOfImportance() as the only exposed member.
+        /// </summary>
+        public const int Version1 = 1;
+
+        /// <summary>
+        /// An explicit version of this class. Must be incremented whenever new members are added. Derived classes should override
+        /// the property to return the version actually being implemented.
+        /// </summary>
+        public virtual int Version => Version1;
+
+        /// <summary>
+        /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
+        /// </summary>
+        /// <param name="importance">The importance to check.</param>
+        /// <returns>True if messages of the given importance should be logged, false if it's guaranteed that such messages would be ignored.</returns>
+        /// <remarks>
+        /// Example: If we know that no logger is interested in <see cref="MessageImportance.Low"/>, this method returns <see langword="true"/>
+        /// for <see cref="MessageImportance.Normal"/> and <see cref="MessageImportance.High"/>, and returns <see langword="false"/>
+        /// for <see cref="MessageImportance.Low"/>.
+        /// </remarks>
+        public virtual bool LogsMessagesOfImportance(MessageImportance importance) => throw new NotImplementedException();
+    }
+}
diff --git a/src/Framework/Event args classes.cd b/src/Framework/Event args classes.cd
deleted file mode 100644
index 705d0aa3b6f..00000000000
--- a/src/Framework/Event args classes.cd	
+++ /dev/null
@@ -1,102 +0,0 @@
-Ôªø<?xml version="1.0" encoding="utf-8"?>
-<ClassDiagram MajorVersion="1" MinorVersion="1">
-  <Font Name="Tahoma" Size="8.25" />
-  <Class Name="Microsoft.Build.Framework.BuildErrorEventArgs" Collapsed="true">
-    <Position X="6" Y="1.75" Width="1.75" />
-    <TypeIdentifier>
-      <FileName>BuildErrorEventArgs.cs</FileName>
-      <HashCode>AAAAAAAAgAAAAAAAAAAoAAAArAAEAAgAFAAAABAABAA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.BuildEventArgs" Collapsed="true">
-    <Position X="4.75" Y="0.5" Width="1.5" />
-    <TypeIdentifier>
-      <FileName>BuildEventArgs.cs</FileName>
-      <HashCode>AAAAAAAAAAAgAAAAAAAGAAAABgAAAAAAACAAICAgACA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.BuildFinishedEventArgs" Collapsed="true">
-    <Position X="1" Y="4" Width="2" />
-    <TypeIdentifier>
-      <FileName>BuildFinishedEventArgs.cs</FileName>
-      <HashCode>AAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.BuildMessageEventArgs" Collapsed="true">
-    <Position X="10.25" Y="1.75" Width="2" />
-    <TypeIdentifier>
-      <FileName>BuildMessageEventArgs.cs</FileName>
-      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAAAAA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.BuildStartedEventArgs" Collapsed="true">
-    <Position X="1" Y="3.25" Width="1.75" />
-    <TypeIdentifier>
-      <FileName>BuildStartedEventArgs.cs</FileName>
-      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.BuildStatusEventArgs" Collapsed="true">
-    <Position X="2.5" Y="2" Width="1.75" />
-    <TypeIdentifier>
-      <FileName>BuildStatusEventArgs.cs</FileName>
-      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.BuildWarningEventArgs" Collapsed="true">
-    <Position X="8" Y="1.75" Width="2" />
-    <TypeIdentifier>
-      <FileName>BuildWarningEventArgs.cs</FileName>
-      <HashCode>AAAAAAAAgAAAAAAAAAAoAAAArAAEAAgAFAAAABAABAA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.CustomBuildEventArgs" Collapsed="true">
-    <Position X="6.25" Y="2.75" Width="1.75" />
-    <TypeIdentifier>
-      <FileName>CustomBuildEventArgs.cs</FileName>
-      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.ProjectFinishedEventArgs" Collapsed="true">
-    <Position X="1" Y="5.5" Width="2" />
-    <TypeIdentifier>
-      <FileName>ProjectFinishedEventArgs.cs</FileName>
-      <HashCode>AAAAgAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAIA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.ProjectStartedEventArgs" Collapsed="true">
-    <Position X="1" Y="4.75" Width="2" />
-    <TypeIdentifier>
-      <FileName>ProjectStartedEventArgs.cs</FileName>
-      <HashCode>AAAAABAAABAAAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.TargetFinishedEventArgs" Collapsed="true">
-    <Position X="3.75" Y="4" Width="2" />
-    <TypeIdentifier>
-      <FileName>TargetFinishedEventArgs.cs</FileName>
-      <HashCode>AAAAoAAAADAAAAAQAAAAAAAAAAAAAAAgAAAAIAAAAIA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.TargetStartedEventArgs" Collapsed="true">
-    <Position X="3.75" Y="3.25" Width="2" />
-    <TypeIdentifier>
-      <FileName>TargetStartedEventArgs.cs</FileName>
-      <HashCode>AAAAIAAAADAAAAAQAAAAAAAAAAAAAAAgAAAAIAAAAAA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.TaskFinishedEventArgs" Collapsed="true">
-    <Position X="3.75" Y="5.5" Width="1.75" />
-    <TypeIdentifier>
-      <FileName>TaskFinishedEventArgs.cs</FileName>
-      <HashCode>AAAAggAAABIEAAAQBAAAAAAAAAAAAAAAAAAAAAAAAIA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-  <Class Name="Microsoft.Build.Framework.TaskStartedEventArgs" Collapsed="true">
-    <Position X="3.75" Y="4.75" Width="1.75" />
-    <TypeIdentifier>
-      <FileName>TaskStartedEventArgs.cs</FileName>
-      <HashCode>AAAAAgAAABIEAAAQBAAAAAAAAAAAAAAAAAAAAAAAAAA=</HashCode>
-    </TypeIdentifier>
-  </Class>
-</ClassDiagram>
\ No newline at end of file
diff --git a/src/Framework/IBuildEngine10.cs b/src/Framework/IBuildEngine10.cs
new file mode 100644
index 00000000000..7a7805d9791
--- /dev/null
+++ b/src/Framework/IBuildEngine10.cs
@@ -0,0 +1,17 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// This interface extends <see cref="IBuildEngine9" /> to provide a reference to the <see cref="EngineServices" /> class.
+    /// Future engine API should be added to the class as opposed to introducing yet another version of the IBuildEngine interface.
+    /// </summary>
+    public interface IBuildEngine10 : IBuildEngine9
+    {
+        /// <summary>
+        /// Returns the new build engine interface.
+        /// </summary>
+        EngineServices EngineServices { get; }
+    }
+}
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 91cc35ad3a4..13bf34480b7 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -103,106 +103,100 @@ public void EvaluateConditionStop(string condition, bool result)
         /// <summary>
         /// Call this method to notify listeners of how the project data was evaluated.
         /// </summary>
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(11, Keywords = Keywords.All)]
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
+        [Event(11, Keywords = Keywords.All | Keywords.PerformanceLog)]
         public void EvaluateStart(string projectFile)
         {
             WriteEvent(11, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        [Event(12, Keywords = Keywords.All)]
-        public void EvaluatePass0Start(string projectFile)
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
+        [Event(12, Keywords = Keywords.All | Keywords.PerformanceLog)]
+        public void EvaluateStop(string projectFile)
         {
             WriteEvent(12, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(13, Keywords = Keywords.All)]
-        public void EvaluatePass0Stop(string projectFile)
+        public void EvaluatePass0Start(string projectFile)
         {
             WriteEvent(13, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(14, Keywords = Keywords.All)]
-        public void EvaluatePass1Start(string projectFile)
+        public void EvaluatePass0Stop(string projectFile)
         {
             WriteEvent(14, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        /// <param name="numberOfProperties">Number of Properties getting evaluated.</param>
-        /// <param name="numberOfImports">Number of Imports getting evaluated.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(15, Keywords = Keywords.All)]
-        public void EvaluatePass1Stop(string projectFile, int numberOfProperties, int numberOfImports)
+        public void EvaluatePass1Start(string projectFile)
         {
-            WriteEvent(15, projectFile, numberOfProperties, numberOfImports);
+            WriteEvent(15, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(16, Keywords = Keywords.All)]
-        public void EvaluatePass2Start(string projectFile)
+        public void EvaluatePass1Stop(string projectFile)
         {
             WriteEvent(16, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        /// <param name="numberOfItemDefinitionGroupElements">Number of ItemDefinitionGroupElements getting evaluated.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(17, Keywords = Keywords.All)]
-        public void EvaluatePass2Stop(string projectFile, int numberOfItemDefinitionGroupElements)
+        public void EvaluatePass2Start(string projectFile)
         {
-            WriteEvent(17, projectFile, numberOfItemDefinitionGroupElements);
+            WriteEvent(17, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(18, Keywords = Keywords.All)]
-        public void EvaluatePass3Start(string projectFile)
+        public void EvaluatePass2Stop(string projectFile)
         {
             WriteEvent(18, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        /// <param name="numberOfItemGroupElements">Number of project items evaluated.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(19, Keywords = Keywords.All)]
-        public void EvaluatePass3Stop(string projectFile, int numberOfItemGroupElements)
+        public void EvaluatePass3Start(string projectFile)
         {
-            WriteEvent(19, projectFile, numberOfItemGroupElements);
+            WriteEvent(19, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(20, Keywords = Keywords.All)]
-        public void EvaluatePass4Start(string projectFile)
+        public void EvaluatePass3Stop(string projectFile)
         {
             WriteEvent(20, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        /// <param name="numberOfUsingTaskElements">Number of using tasks elements evaluated.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(21, Keywords = Keywords.All)]
-        public void EvaluatePass4Stop(string projectFile, int numberOfUsingTaskElements)
+        public void EvaluatePass4Start(string projectFile)
         {
-            WriteEvent(21, projectFile, numberOfUsingTaskElements);
+            WriteEvent(21, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(22, Keywords = Keywords.All)]
-        public void EvaluatePass5Start(string projectFile)
+        public void EvaluatePass4Stop(string projectFile)
         {
             WriteEvent(22, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
-        /// <param name="targetElementsCount">Number of targets read.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(23, Keywords = Keywords.All)]
-        public void EvaluatePass5Stop(string projectFile, int targetElementsCount)
+        public void EvaluatePass5Start(string projectFile)
         {
-            WriteEvent(23, projectFile, targetElementsCount);
+            WriteEvent(23, projectFile);
         }
 
-        /// <param name="projectFile">Relevant information about where in the run of the progam it is.</param>
+        /// <param name="projectFile">Filename of the project being evaluated.</param>
         [Event(24, Keywords = Keywords.All)]
-        public void EvaluateStop(string projectFile)
+        public void EvaluatePass5Stop(string projectFile)
         {
             WriteEvent(24, projectFile);
         }
@@ -284,15 +278,15 @@ public void RarLogResultsStop()
         /// <summary>
         /// Call this method to notify listeners of profiling for the function that parses an XML document into a ProjectRootElement.
         /// </summary>
-        /// <param name="projectFileName">Relevant information about where in the run of the progam it is.</param>
-        [Event(33, Keywords = Keywords.All | Keywords.PerformanceLog)]
+        /// <param name="projectFileName">Filename of the project being evaluated.</param>
+        [Event(33, Keywords = Keywords.All)]
         public void ParseStart(string projectFileName)
         {
             WriteEvent(33, projectFileName);
         }
 
-        /// <param name="projectFileName">Relevant information about where in the run of the progam it is.</param>
-        [Event(34, Keywords = Keywords.All | Keywords.PerformanceLog)]
+        /// <param name="projectFileName">Filename of the project being evaluated.</param>
+        [Event(34, Keywords = Keywords.All)]
         public void ParseStop(string projectFileName)
         {
             WriteEvent(34, projectFileName);
@@ -424,6 +418,18 @@ public void PacketReadSize(int size)
             WriteEvent(55, size);
         }
 
+        [Event(56, Keywords = Keywords.All)]
+        public void TargetUpToDateStart()
+        {
+            WriteEvent(56);
+        }
+
+        [Event(57, Keywords = Keywords.All)]
+        public void TargetUpToDateStop(int result)
+        {
+            WriteEvent(57, result);
+        }
+        
         [Event(58, Keywords = Keywords.All)]
         public void CopyUpToDateStart(string path)
         {
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index af47eedfc65..8220910cf74 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -11,7 +11,7 @@
 
   <ItemGroup>
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
-    
+
     <!-- Direct project references needed here to avoid NuGet version conflict errors -->
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
@@ -39,11 +39,6 @@
     <Content Include="$(RepoRoot).dotnet\sdk\$(DotNetCliVersion)\RuntimeIdentifierGraph.json" CopyToOutputDirectory="PreserveNewest" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(MonoBuild)' != 'true'">
-    <!-- Include DependencyModel libraries. -->
-    <PackageReference Include="Microsoft.Extensions.DependencyModel" />
-  </ItemGroup>
-
   <!-- Use deps file from this project with additional dependencies listed instead of the one generated in the MSBuild project -->
   <Target Name="UpdateMSBuildDepsFile" AfterTargets="Build" Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::IsTargetFrameworkCompatible('$(TargetFramework)', 'netcoreapp2.1')) or '$(TargetFramework)' == 'netstandard2.0')">
     <Copy SourceFiles="$(OutputPath)$(AssemblyName).deps.json" DestinationFiles="$(OutputPath)MSBuild.deps.json" />
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 8c918a9fda0..c9dbd905e72 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -19,10 +19,11 @@
 using Shouldly;
 using System.IO.Compression;
 using System.Reflection;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
-    public class XMakeAppTests
+    public class XMakeAppTests : IDisposable
     {
 #if USE_MSBUILD_DLL_EXTN
         private const string MSBuildExeName = "MSBuild.dll";
@@ -31,10 +32,12 @@ public class XMakeAppTests
 #endif
 
         private readonly ITestOutputHelper _output;
+        private readonly TestEnvironment _env;
 
         public XMakeAppTests(ITestOutputHelper output)
         {
             _output = output;
+            _env = UnitTests.TestEnvironment.Create(_output);
         }
 
         private const string AutoResponseFileName = "MSBuild.rsp";
@@ -45,7 +48,7 @@ public void GatherCommandLineSwitchesTwoProperties()
             CommandLineSwitches switches = new CommandLineSwitches();
 
             var arguments = new List<string>();
-            arguments.AddRange(new string[] { "/p:a=b", "/p:c=d" });
+            arguments.AddRange(new[] { "/p:a=b", "/p:c=d" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
 
@@ -60,7 +63,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithArgument()
             CommandLineSwitches switches = new CommandLineSwitches();
 
             var arguments = new List<string>();
-            arguments.AddRange(new string[] { "/m:2" });
+            arguments.AddRange(new[] { "/m:2" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
 
@@ -77,7 +80,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgument()
             CommandLineSwitches switches = new CommandLineSwitches();
 
             var arguments = new List<string>();
-            arguments.AddRange(new string[] { "/m:3", "/m" });
+            arguments.AddRange(new[] { "/m:3", "/m" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
 
@@ -97,7 +100,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgumentButWithColon()
             CommandLineSwitches switches = new CommandLineSwitches();
 
             var arguments = new List<string>();
-            arguments.AddRange(new string[] { "/m:" });
+            arguments.AddRange(new[] { "/m:" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
 
@@ -137,11 +140,8 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgumentButWithColon()
         [Fact]
         public void SplitUnquotedTest()
         {
-            List<string> sa;
-            int emptySplits;
-
             // nothing quoted
-            sa = QuotingUtilities.SplitUnquoted("abcdxyz");
+            var sa = QuotingUtilities.SplitUnquoted("abcdxyz");
             sa.Count.ShouldBe(1);
             sa[0].ShouldBe("abcdxyz");
 
@@ -165,7 +165,7 @@ public void SplitUnquotedTest()
             sa[2].ShouldBe("dxyz");
 
             // nothing quoted
-            sa = QuotingUtilities.SplitUnquoted("abc,c;dxyz", 2, false, false, out emptySplits, ';', ',');
+            sa = QuotingUtilities.SplitUnquoted("abc,c;dxyz", 2, false, false, out var emptySplits, ';', ',');
             emptySplits.ShouldBe(0);
             sa.Count.ShouldBe(2);
             sa[0].ShouldBe("abc");
@@ -183,8 +183,8 @@ public void SplitUnquotedTest()
             emptySplits.ShouldBe(0);
             sa.Count.ShouldBe(4);
             sa[0].ShouldBe("abc");
-            sa[1].ShouldBe(String.Empty);
-            sa[2].ShouldBe(String.Empty);
+            sa[1].ShouldBe(string.Empty);
+            sa[2].ShouldBe(string.Empty);
             sa[3].ShouldBe("dxyz");
 
             // "c d" is quoted
@@ -330,10 +330,8 @@ public void SplitUnquotedTest()
         [Fact]
         public void UnquoteTest()
         {
-            int doubleQuotesRemoved;
-
             // "cde" is quoted
-            QuotingUtilities.Unquote("abc\"cde\"xyz", out doubleQuotesRemoved).ShouldBe("abccdexyz");
+            QuotingUtilities.Unquote("abc\"cde\"xyz", out var doubleQuotesRemoved).ShouldBe("abccdexyz");
             doubleQuotesRemoved.ShouldBe(2);
 
             // "xyz" is quoted (the terminal double-quote is assumed)
@@ -393,8 +391,7 @@ public void UnquoteTest()
         public void ExtractSwitchParametersTest()
         {
             string commandLineArg = "\"/p:foo=\"bar";
-            int doubleQuotesRemovedFromArg;
-            string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out var doubleQuotesRemovedFromArg);
             MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":\"foo=\"bar");
             doubleQuotesRemovedFromArg.ShouldBe(2);
 
@@ -513,15 +510,15 @@ public void InvalidVerbosity()
         [Fact]
         public void ValidMaxCPUCountSwitch()
         {
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "1" }).ShouldBe(1);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "2" }).ShouldBe(2);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "3" }).ShouldBe(3);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "4" }).ShouldBe(4);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "8" }).ShouldBe(8);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "63" }).ShouldBe(63);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "1" }).ShouldBe(1);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "2" }).ShouldBe(2);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "3" }).ShouldBe(3);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "4" }).ShouldBe(4);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "8" }).ShouldBe(8);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "63" }).ShouldBe(63);
 
             // Should pick last value
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "8", "4" }).ShouldBe(4);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "8", "4" }).ShouldBe(4);
         }
 
         [Fact]
@@ -529,7 +526,7 @@ public void InvalidMaxCPUCountSwitch1()
         {
             Should.Throw<CommandLineSwitchException>(() =>
             {
-                MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "-1" });
+                MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "-1" });
             }
            );
         }
@@ -539,7 +536,7 @@ public void InvalidMaxCPUCountSwitch2()
         {
             Should.Throw<CommandLineSwitchException>(() =>
             {
-                MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "0" });
+                MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "0" });
             }
            );
         }
@@ -550,7 +547,7 @@ public void InvalidMaxCPUCountSwitch3()
             Should.Throw<CommandLineSwitchException>(() =>
             {
                 // Too big
-                MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "foo" });
+                MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "foo" });
             }
            );
         }
@@ -560,7 +557,7 @@ public void InvalidMaxCPUCountSwitch4()
         {
             Should.Throw<CommandLineSwitchException>(() =>
             {
-                MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "1025" });
+                MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "1025" });
             }
            );
         }
@@ -586,7 +583,7 @@ public void SetConsoleUICulture()
             MSBuildApp.SetConsoleUI();
 
             // Make sure this doesn't throw an exception.
-            string bar = String.Format(CultureInfo.CurrentUICulture, "{0}", 1);
+            string bar = string.Format(CultureInfo.CurrentUICulture, "{0}", 1);
 
             // Restore the current UI culture back to the way it was at the beginning of this unit test.
             thisThread.CurrentUICulture = originalUICulture;
@@ -647,20 +644,19 @@ public void ConfigurationInvalid()
 
                 var msbuildParameters = "\"" + pathToProjectFile + "\"";
 
-                bool successfulExit;
-                output = RunnerUtilities.ExecMSBuild(newPathToMSBuildExe, msbuildParameters, out successfulExit);
+                output = RunnerUtilities.ExecMSBuild(newPathToMSBuildExe, msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeFalse();
             }
             catch (Exception ex)
             {
-                Console.WriteLine(ex.ToString());
+                _output.WriteLine(ex.ToString());
                 throw;
             }
             finally
             {
                 if (output != null)
                 {
-                    Console.WriteLine(output);
+                    _output.WriteLine(output);
                 }
 
                 try
@@ -800,7 +796,7 @@ public void MSBuildEngineLogger()
             }
         }
 
-        private string _pathToArbitraryBogusFile = NativeMethodsShared.IsWindows // OK on 64 bit as well
+        private readonly string _pathToArbitraryBogusFile = NativeMethodsShared.IsWindows // OK on 64 bit as well
                                                         ? Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "notepad.exe")
                                                         : "/bin/cat";
 
@@ -813,8 +809,7 @@ public void GetCommandLine()
             var msbuildParameters = "\"" + _pathToArbitraryBogusFile + "\"" + (NativeMethodsShared.IsWindows ? " /v:diag" : " -v:diag");
             File.Exists(_pathToArbitraryBogusFile).ShouldBeTrue();
 
-            bool successfulExit;
-            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
             successfulExit.ShouldBeFalse();
 
             output.ShouldContain(RunnerUtilities.PathToCurrentlyRunningMsBuildExe + (NativeMethodsShared.IsWindows ? " /v:diag " : " -v:diag ") + _pathToArbitraryBogusFile, Case.Insensitive);
@@ -829,7 +824,6 @@ public void GetCommandLineQuotedExe()
             var msbuildParameters = "\"" + _pathToArbitraryBogusFile + "\"" + (NativeMethodsShared.IsWindows ? " /v:diag" : " -v:diag");
             File.Exists(_pathToArbitraryBogusFile).ShouldBeTrue();
 
-            bool successfulExit;
             string pathToMSBuildExe = RunnerUtilities.PathToCurrentlyRunningMsBuildExe;
             // This @pathToMSBuildExe is used directly with Process, so don't quote it on
             // Unix
@@ -838,7 +832,7 @@ public void GetCommandLineQuotedExe()
                 pathToMSBuildExe = "\"" + pathToMSBuildExe + "\"";
             }
 
-            string output = RunnerUtilities.ExecMSBuild(pathToMSBuildExe, msbuildParameters, out successfulExit);
+            string output = RunnerUtilities.ExecMSBuild(pathToMSBuildExe, msbuildParameters, out var successfulExit);
             successfulExit.ShouldBeFalse();
 
             output.ShouldContain(RunnerUtilities.PathToCurrentlyRunningMsBuildExe + (NativeMethodsShared.IsWindows ? " /v:diag " : " -v:diag ") + _pathToArbitraryBogusFile, Case.Insensitive);
@@ -850,7 +844,7 @@ public void GetCommandLineQuotedExe()
         [Fact]
         public void GetCommandLineQuotedExeOnPath()
         {
-            string output = null;
+            string output;
             string current = Directory.GetCurrentDirectory();
 
             try
@@ -859,8 +853,7 @@ public void GetCommandLineQuotedExeOnPath()
 
                 var msbuildParameters = "\"" + _pathToArbitraryBogusFile + "\"" + (NativeMethodsShared.IsWindows ? " /v:diag" : " -v:diag");
 
-                bool successfulExit;
-                output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeFalse();
             }
             finally
@@ -878,38 +871,23 @@ public void GetCommandLineQuotedExeOnPath()
         [Fact]
         public void ResponseFileInProjectDirectoryFoundImplicitly()
         {
-            string directory = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
+            string directory = _env.DefaultTestDirectory.Path;
             string projectPath = Path.Combine(directory, "my.proj");
             string rspPath = Path.Combine(directory, AutoResponseFileName);
 
-            string currentDirectory = Directory.GetCurrentDirectory();
-
-            try
-            {
-                Directory.CreateDirectory(directory);
-
-                string content = ObjectModelHelpers.CleanupFileContents("<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'><Target Name='t'><Warning Text='[A=$(A)]'/></Target></Project>");
-                File.WriteAllText(projectPath, content);
+            string content = ObjectModelHelpers.CleanupFileContents("<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'><Target Name='t'><Warning Text='[A=$(A)]'/></Target></Project>");
+            File.WriteAllText(projectPath, content);
 
-                string rspContent = "/p:A=1";
-                File.WriteAllText(rspPath, rspContent);
+            string rspContent = "/p:A=1";
+            File.WriteAllText(rspPath, rspContent);
 
-                // Find the project in the current directory
-                Directory.SetCurrentDirectory(directory);
+            // Find the project in the current directory
+            _env.SetCurrentDirectory(directory);
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(String.Empty, out successfulExit);
-                successfulExit.ShouldBeTrue();
+            string output = RunnerUtilities.ExecMSBuild(string.Empty, out var successfulExit);
+            successfulExit.ShouldBeTrue();
 
-                output.ShouldContain("[A=1]");
-            }
-            finally
-            {
-                Directory.SetCurrentDirectory(currentDirectory);
-                File.Delete(projectPath);
-                File.Delete(rspPath);
-                FileUtilities.DeleteWithoutTrailingBackslash(directory);
-            }
+            output.ShouldContain("[A=1]");
         }
 
         /// <summary>
@@ -935,8 +913,7 @@ public void ResponseFileInProjectDirectoryExplicit()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=1]");
@@ -971,8 +948,7 @@ public void ResponseFileInProjectDirectoryRandomName()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=]");
@@ -1008,8 +984,7 @@ public void ResponseFileInProjectDirectoryCommandLineWins()
 
                 var msbuildParameters = "\"" + projectPath + "\"" + " /p:A=2";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=2]");
@@ -1054,8 +1029,7 @@ public void ResponseFileInProjectDirectoryWinsOverMainMSBuildRsp()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(exePath, msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(exePath, msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=1]");
@@ -1090,8 +1064,7 @@ public void ProjectDirectoryIsMSBuildExeDirectory()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(exePath, msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(exePath, msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=1]");
@@ -1124,8 +1097,7 @@ public void ResponseFileInProjectDirectoryItselfWithNoAutoResponseSwitch()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeFalse();
 
                 output.ShouldContain("MSB1027"); // msbuild.rsp cannot have /noautoresponse in it
@@ -1160,8 +1132,7 @@ public void ResponseFileInProjectDirectoryButCommandLineNoAutoResponseSwitch()
 
                 var msbuildParameters = "\"" + projectPath + "\" /noautoresponse";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=]");
@@ -1193,8 +1164,7 @@ public void ResponseFileInProjectDirectoryNullCase()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=]");
@@ -1213,22 +1183,19 @@ public void ResponseFileInProjectDirectoryNullCase()
         [Fact]
         public void ResponseFileSupportsThisFileDirectory()
         {
-            using (var env = UnitTests.TestEnvironment.Create())
-            {
-                var content = ObjectModelHelpers.CleanupFileContents(
-                    "<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'><Target Name='t'><Warning Text='[A=$(A)]'/></Target></Project>");
+            var content = ObjectModelHelpers.CleanupFileContents(
+                "<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'><Target Name='t'><Warning Text='[A=$(A)]'/></Target></Project>");
 
-                var directory = env.CreateFolder();
-                directory.CreateFile("Directory.Build.rsp", "/p:A=%MSBuildThisFileDirectory%");
-                var projectPath = directory.CreateFile("my.proj", content).Path;
+            var directory = _env.CreateFolder();
+            directory.CreateFile("Directory.Build.rsp", "/p:A=%MSBuildThisFileDirectory%");
+            var projectPath = directory.CreateFile("my.proj", content).Path;
 
-                var msbuildParameters = "\"" + projectPath + "\"";
+            var msbuildParameters = "\"" + projectPath + "\"";
 
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
-                successfulExit.ShouldBeTrue();
+            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+            successfulExit.ShouldBeTrue();
 
-                output.ShouldContain($"[A={directory.Path}{Path.DirectorySeparatorChar}]");
-            }
+            output.ShouldContain($"[A={directory.Path}{Path.DirectorySeparatorChar}]");
         }
 
         /// <summary>
@@ -1254,7 +1221,7 @@ public void NormalPriorityBuild()
 
         private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params string[] arguments)
         {
-            string[] aggregateArguments = arguments.Union(new string[] { " /nr:false /v:diag "}).ToArray();
+            string[] aggregateArguments = arguments.Union(new[] { " /nr:false /v:diag "}).ToArray();
 
             string contents = ObjectModelHelpers.CleanupFileContents(@"
 <Project DefaultTargets=""Build"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
@@ -1275,7 +1242,7 @@ private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params s
 
             string logContents = ExecuteMSBuildExeExpectSuccess(contents, envsToCreate: environmentVars, arguments: aggregateArguments);
 
-            string expected = string.Format(@"Task priority is '{0}'", expectedPrority);
+            string expected = $@"Task priority is '{expectedPrority}'";
             logContents.ShouldContain(expected, () => logContents);
         }
 
@@ -1283,11 +1250,11 @@ private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params s
         /// Test the default file to build in cases involving at least one solution filter file.
         /// </summary>
         [Theory]
-        [InlineData(new string[] { "my.proj", "my.sln", "my.slnf" }, "my.sln")]
-        [InlineData(new string[] { "abc.proj", "bcd.csproj", "slnf.slnf", "other.slnf" }, "abc.proj")]
-        [InlineData(new string[] { "abc.sln", "slnf.slnf", "abc.slnf" }, "abc.sln")]
-        [InlineData(new string[] { "abc.csproj", "abc.slnf", "not.slnf" }, "abc.csproj")]
-        [InlineData(new string[] { "abc.slnf" }, "abc.slnf")]
+        [InlineData(new[] { "my.proj", "my.sln", "my.slnf" }, "my.sln")]
+        [InlineData(new[] { "abc.proj", "bcd.csproj", "slnf.slnf", "other.slnf" }, "abc.proj")]
+        [InlineData(new[] { "abc.sln", "slnf.slnf", "abc.slnf" }, "abc.sln")]
+        [InlineData(new[] { "abc.csproj", "abc.slnf", "not.slnf" }, "abc.csproj")]
+        [InlineData(new[] { "abc.slnf" }, "abc.slnf")]
         public void TestDefaultBuildWithSolutionFilter(string[] projects, string answer)
         {
             string[] extensionsToIgnore = Array.Empty<string>();
@@ -1304,10 +1271,10 @@ public void TestDefaultBuildWithSolutionFilter(string[] projects, string answer)
         [Fact]
         public void TestProcessProjectSwitchOneProjNotFoundExtension()
         {
-            string[] projects = new string[] { "my.proj" };
-            string[] extensionsToIgnore = new string[] { ".phantomextension" };
+            string[] projects = { "my.proj" };
+            string[] extensionsToIgnore = { ".phantomextension" };
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
         }
 
         /// <summary>
@@ -1316,10 +1283,10 @@ public void TestProcessProjectSwitchOneProjNotFoundExtension()
         [Fact]
         public void TestTwoIdenticalExtensionsToIgnore()
         {
-            string[] projects = new string[] { "my.proj" };
-            string[] extensionsToIgnore = new string[] { ".phantomextension", ".phantomextension" };
+            string[] projects = { "my.proj" };
+            string[] extensionsToIgnore = { ".phantomextension", ".phantomextension" };
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
         }
 
         /// <summary>
@@ -1328,13 +1295,13 @@ public void TestTwoIdenticalExtensionsToIgnore()
         [Fact]
         public void TestProcessProjectSwitchNullandEmptyProjectsToIgnore()
         {
-            string[] projects = new string[] { "my.proj" };
+            string[] projects = { "my.proj" };
             string[] extensionsToIgnore = null;
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
 
             extensionsToIgnore = new string[] { };
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
         }
 
         /// <summary>
@@ -1345,10 +1312,10 @@ public void TestProcessProjectSwitchNullInList()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { ".phantomextension", null };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { ".phantomextension", null };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
             }
            );
         }
@@ -1361,10 +1328,10 @@ public void TestProcessProjectSwitchEmptyInList()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { ".phantomextension", string.Empty };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { ".phantomextension", string.Empty };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
             }
            );
         }
@@ -1376,10 +1343,10 @@ public void TestProcessProjectSwitchExtensionWithoutDot()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { "phantomextension" };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { "phantomextension" };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase);
             }
            );
         }
@@ -1391,10 +1358,10 @@ public void TestProcessProjectSwitchMalformed()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { ".C:\\boocatmoo.a" };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { ".C:\\boocatmoo.a" };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
             }
            );
         }
@@ -1406,65 +1373,65 @@ public void TestProcessProjectSwitchWildcards()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { ".proj*", ".nativeproj?" };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { ".proj*", ".nativeproj?" };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
         [Fact]
         public void TestProcessProjectSwitch()
         {
-            string[] projects = new string[] { "test.nativeproj", "test.vcproj" };
-            string[] extensionsToIgnore = new string[] { ".phantomextension", ".vcproj" };
+            string[] projects = { "test.nativeproj", "test.vcproj" };
+            string[] extensionsToIgnore = { ".phantomextension", ".vcproj" };
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.nativeproj", StringCompareShould.IgnoreCase); // "Expected test.nativeproj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.nativeproj", StringCompareShould.IgnoreCase); // "Expected test.nativeproj to be only project found"
 
-            projects = new string[] { "test.nativeproj", "test.vcproj", "test.proj" };
-            extensionsToIgnore = new string[] { ".phantomextension", ".vcproj" };
+            projects = new[] { "test.nativeproj", "test.vcproj", "test.proj" };
+            extensionsToIgnore = new[] { ".phantomextension", ".vcproj" };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
 
-            projects = new string[] { "test.nativeproj", "test.vcproj" };
-            extensionsToIgnore = new string[] { ".vcproj" };
+            projects = new[] { "test.nativeproj", "test.vcproj" };
+            extensionsToIgnore = new[] { ".vcproj" };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.nativeproj", StringCompareShould.IgnoreCase); // "Expected test.nativeproj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.nativeproj", StringCompareShould.IgnoreCase); // "Expected test.nativeproj to be only project found"
 
-            projects = new string[] { "test.proj", "test.sln" };
-            extensionsToIgnore = new string[] { ".vcproj" };
+            projects = new[] { "test.proj", "test.sln" };
+            extensionsToIgnore = new[] { ".vcproj" };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-            projects = new string[] { "test.proj", "test.sln", "test.proj~", "test.sln~" };
+            projects = new[] { "test.proj", "test.sln", "test.proj~", "test.sln~" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-            projects = new string[] { "test.proj" };
+            projects = new[] { "test.proj" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
 
-            projects = new string[] { "test.proj", "test.proj~" };
+            projects = new[] { "test.proj", "test.proj~" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
 
-            projects = new string[] { "test.sln" };
+            projects = new[] { "test.sln" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-            projects = new string[] { "test.sln", "test.sln~" };
+            projects = new[] { "test.sln", "test.sln~" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-            projects = new string[] { "test.sln~", "test.sln" };
+            projects = new[] { "test.sln~", "test.sln" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
         }
 
         /// <summary>
@@ -1473,10 +1440,10 @@ public void TestProcessProjectSwitch()
         [Fact]
         public void TestProcessProjectSwitchReplicateBuildingDFLKG()
         {
-            string[] projects = new string[] { "test.proj", "test.sln", "Foo.vcproj" };
+            string[] projects = { "test.proj", "test.sln", "Foo.vcproj" };
             string[] extensionsToIgnore = { ".sln", ".vcproj" };
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj"); // "Expected test.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj"); // "Expected test.proj to be only project found"
         }
 
         /// <summary>
@@ -1487,12 +1454,10 @@ public void TestProcessProjectSwitchRemovedAllprojects()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects;
-                string[] extensionsToIgnore = null;
-                projects = new string[] { "test.nativeproj", "test.vcproj" };
-                extensionsToIgnore = new string[] { ".nativeproj", ".vcproj" };
+                var projects = new[] { "test.nativeproj", "test.vcproj" };
+                var extensionsToIgnore = new[] { ".nativeproj", ".vcproj" };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1504,10 +1469,10 @@ public void TestProcessProjectSwitchSlnProjDifferentNames()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.proj", "Different.sln" };
+                string[] projects = { "test.proj", "Different.sln" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1519,10 +1484,10 @@ public void TestProcessProjectSwitchTwoProj()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.proj", "Different.proj" };
+                string[] projects = { "test.proj", "Different.proj" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1534,10 +1499,10 @@ public void TestProcessProjectSwitchTwoNative()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.nativeproj", "Different.nativeproj" };
+                string[] projects = { "test.nativeproj", "Different.nativeproj" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1549,10 +1514,10 @@ public void TestProcessProjectSwitchTwoSolutions()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.sln", "Different.sln" };
+                string[] projects = { "test.sln", "Different.sln" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1564,10 +1529,10 @@ public void TestProcessProjectSwitchMoreThenTwoProj()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.nativeproj", "Different.csproj", "Another.proj" };
+                string[] projects = { "test.nativeproj", "Different.csproj", "Another.proj" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1579,10 +1544,10 @@ public void TestProcessProjectSwitchNoProjectOrSolution()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { };
+                string[] projects = { };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1591,7 +1556,7 @@ public void TestProcessProjectSwitchNoProjectOrSolution()
         /// </summary>
         internal class IgnoreProjectExtensionsHelper
         {
-            private List<string> _directoryFileNameList;
+            private readonly List<string> _directoryFileNameList;
 
             /// <summary>
             /// Takes in a list of file names to simulate as being in a directory
@@ -1618,14 +1583,14 @@ internal string[] GetFiles(string path, string searchPattern)
                 List<string> fileNamesToReturn = new List<string>();
                 foreach (string file in _directoryFileNameList)
                 {
-                    if (String.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
                     {
                         if (FileUtilities.IsSolutionFilename(file))
                         {
                             fileNamesToReturn.Add(file);
                         }
                     }
-                    else if (String.Equals(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase))
                     {
                         if (Path.GetExtension(file).Contains("proj"))
                         {
@@ -1759,7 +1724,7 @@ public void TestProcessFileLoggerSwitch3()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[1] { "Parameter" };
+            fileLoggerParameters = new[] { "Parameter" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1774,7 +1739,7 @@ public void TestProcessFileLoggerSwitch3()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "Parameter1", "Parameter" };
+            fileLoggerParameters = new[] { "Parameter1", "Parameter" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1814,7 +1779,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[1] { "verbosity=Normal;" };
+            fileLoggerParameters = new[] { "verbosity=Normal;" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1831,7 +1796,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "verbosity=Normal", "" };
+            fileLoggerParameters = new[] { "verbosity=Normal", "" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1848,7 +1813,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "", "Parameter1" };
+            fileLoggerParameters = new[] { "", "Parameter1" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1865,7 +1830,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "Parameter1", "verbosity=Normal;logfile=" + (NativeMethodsShared.IsWindows ? "c:\\temp\\cat.log" : "/tmp/cat.log") };
+            fileLoggerParameters = new[] { "Parameter1", "verbosity=Normal;logfile=" + (NativeMethodsShared.IsWindows ? "c:\\temp\\cat.log" : "/tmp/cat.log") };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1880,7 +1845,7 @@ public void TestProcessFileLoggerSwitch4()
 
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "Parameter1", "verbosity=Normal;logfile=" + Path.Combine("..", "cat.log") + ";Parameter1" };
+            fileLoggerParameters = new[] { "Parameter1", "verbosity=Normal;logfile=" + Path.Combine("..", "cat.log") + ";Parameter1" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1895,7 +1860,7 @@ public void TestProcessFileLoggerSwitch4()
 
             loggers = new List<ILogger>();
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
-            fileLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
+            fileLoggerParameters = new[] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1937,8 +1902,8 @@ public void ProcessConsoleLoggerSwitches()
         {
             var loggers = new List<ILogger>();
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
-            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>(); 
-            string[] consoleLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
+            List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
+            string[] consoleLoggerParameters = { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
 
             MSBuildApp.ProcessConsoleLoggerSwitch
                        (
@@ -1991,7 +1956,7 @@ public void RestoreFirstReevaluatesImportGraph()
   <PropertyGroup>
     <RestoreFirstProps>{Guid.NewGuid():N}.props</RestoreFirstProps>
   </PropertyGroup>
-  
+
   <Import Project=""$(RestoreFirstProps)"" Condition=""Exists($(RestoreFirstProps))""/>
 
   <Target Name=""Build"">
@@ -2003,10 +1968,10 @@ public void RestoreFirstReevaluatesImportGraph()
     <ItemGroup>
       <Lines Include=""&lt;Project ToolsVersion=&quot;Current&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;&lt;PropertyGroup&gt;&lt;PropertyA&gt;{guid}&lt;/PropertyA&gt;&lt;/PropertyGroup&gt;&lt;/Project&gt;"" />
     </ItemGroup>
-    
+
     <WriteLinesToFile File=""$(RestoreFirstProps)"" Lines=""@(Lines)"" Overwrite=""true"" />
   </Target>
-  
+
 </Project>");
 
             string logContents = ExecuteMSBuildExeExpectSuccess(projectContents, arguments: "/restore");
@@ -2026,7 +1991,7 @@ public void RestoreFirstClearsProjectRootElementCache()
   <PropertyGroup>
     <RestoreFirstProps>{restoreFirstProps}</RestoreFirstProps>
   </PropertyGroup>
-  
+
   <Import Project=""$(RestoreFirstProps)"" Condition=""Exists($(RestoreFirstProps))""/>
 
   <Target Name=""Build"">
@@ -2039,10 +2004,10 @@ public void RestoreFirstClearsProjectRootElementCache()
     <ItemGroup>
       <Lines Include=""&lt;Project ToolsVersion=&quot;Current&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;&lt;PropertyGroup&gt;&lt;PropertyA&gt;{guid2}&lt;/PropertyA&gt;&lt;/PropertyGroup&gt;&lt;/Project&gt;"" />
     </ItemGroup>
-    
+
     <WriteLinesToFile File=""$(RestoreFirstProps)"" Lines=""@(Lines)"" Overwrite=""true"" />
   </Target>
-  
+
 </Project>");
 
             IDictionary<string, string> preExistingProps = new Dictionary<string, string>
@@ -2073,7 +2038,7 @@ public void RestoreIgnoresMissingImports()
   <PropertyGroup>
     <RestoreFirstProps>{restoreFirstProps}</RestoreFirstProps>
   </PropertyGroup>
-  
+
   <Import Project=""$(RestoreFirstProps)"" />
 
   <Target Name=""Build"">
@@ -2086,10 +2051,10 @@ public void RestoreIgnoresMissingImports()
     <ItemGroup>
       <Lines Include=""&lt;Project ToolsVersion=&quot;Current&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt;&lt;PropertyGroup&gt;&lt;PropertyA&gt;{guid2}&lt;/PropertyA&gt;&lt;/PropertyGroup&gt;&lt;/Project&gt;"" />
     </ItemGroup>
-    
+
     <WriteLinesToFile File=""$(RestoreFirstProps)"" Lines=""@(Lines)"" Overwrite=""true"" />
   </Target>
-  
+
 </Project>");
 
             IDictionary<string, string> preExistingProps = new Dictionary<string, string>
@@ -2186,18 +2151,15 @@ public void MissingOptionalLoggersAreIgnored(string logger)
                 "<Project>" +
                 "<Target Name=\"t\"><Message Text=\"Hello\"/></Target>" +
                 "</Project>";
-            using (var env = UnitTests.TestEnvironment.Create())
-            {
-                var tempDir = env.CreateFolder();
-                var projectFile = tempDir.CreateFile("missingloggertest.proj", projectString);
+            var tempDir = _env.CreateFolder();
+            var projectFile = tempDir.CreateFile("missingloggertest.proj", projectString);
 
-                var parametersLoggerOptional = $"{logger} -verbosity:diagnostic \"{projectFile.Path}\"";
+            var parametersLoggerOptional = $"{logger} -verbosity:diagnostic \"{projectFile.Path}\"";
 
-                var output = RunnerUtilities.ExecMSBuild(parametersLoggerOptional, out bool successfulExit, _output);
-                successfulExit.ShouldBe(true);
-                output.ShouldContain("Hello", output);
-                output.ShouldContain("The specified logger could not be created and will not be used.", output);
-            }
+            var output = RunnerUtilities.ExecMSBuild(parametersLoggerOptional, out bool successfulExit, _output);
+            successfulExit.ShouldBe(true);
+            output.ShouldContain("Hello", output);
+            output.ShouldContain("The specified logger could not be created and will not be used.", output);
         }
 
         [Theory]
@@ -2211,7 +2173,7 @@ public void InteractiveSetsBuiltInProperty(string arguments)
   <Target Name=""Build"">
     <Message Text=""MSBuildInteractive = [$(MSBuildInteractive)]"" />
   </Target>
-  
+
 </Project>");
 
             string logContents = ExecuteMSBuildExeExpectSuccess(projectContents, arguments: arguments);
@@ -2225,54 +2187,47 @@ public void InteractiveSetsBuiltInProperty(string arguments)
         [Fact]
         public void BinaryLogContainsImportedFiles()
         {
-            using (TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create())
-            {
-                var testProject = testEnvironment.CreateFile("Importer.proj", ObjectModelHelpers.CleanupFileContents(@"
-                <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                    <Import Project=""TestProject.proj"" />
+            var testProject = _env.CreateFile("Importer.proj", ObjectModelHelpers.CleanupFileContents(@"
+            <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+                <Import Project=""TestProject.proj"" />
 
-                    <Target Name=""Build"">
-                    </Target>
-  
-                </Project>"));
+                <Target Name=""Build"">
+                </Target>
 
-                testEnvironment.CreateFile("TestProject.proj", @"
-                <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                  <Target Name=""Build"">
-                    <Message Text=""Hello from TestProject!"" />
-                  </Target>
-                </Project>
-                ");
+            </Project>"));
 
-                string binLogLocation = testEnvironment.DefaultTestDirectory.Path;
+            _env.CreateFile("TestProject.proj", @"
+            <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+              <Target Name=""Build"">
+                <Message Text=""Hello from TestProject!"" />
+              </Target>
+            </Project>
+            ");
 
-                string output = RunnerUtilities.ExecMSBuild($"\"{testProject.Path}\" \"/bl:{binLogLocation}/output.binlog\"", out var success, _output);
+            string binLogLocation = _env.DefaultTestDirectory.Path;
 
-                success.ShouldBeTrue(output);
+            string output = RunnerUtilities.ExecMSBuild($"\"{testProject.Path}\" \"/bl:{binLogLocation}/output.binlog\"", out var success, _output);
 
-                RunnerUtilities.ExecMSBuild($"\"{binLogLocation}/output.binlog\" \"/bl:{binLogLocation}/replay.binlog;ProjectImports=ZipFile\"", out success, _output);
+            success.ShouldBeTrue(output);
 
-                using (ZipArchive archive = ZipFile.OpenRead($"{binLogLocation}/replay.ProjectImports.zip"))
-                {
-                     archive.Entries.ShouldContain(e => e.FullName.EndsWith(".proj", StringComparison.OrdinalIgnoreCase), 2);
-                }
-            }
+            RunnerUtilities.ExecMSBuild($"\"{binLogLocation}/output.binlog\" \"/bl:{binLogLocation}/replay.binlog;ProjectImports=ZipFile\"", out success, _output);
+
+            using ZipArchive archive = ZipFile.OpenRead($"{binLogLocation}/replay.ProjectImports.zip");
+            archive.Entries.ShouldContain(e => e.FullName.EndsWith(".proj", StringComparison.OrdinalIgnoreCase), 2);
         }
 
         [Fact]
         public void EndToEndWarnAsErrors()
         {
-            using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
-
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
 
   <Target Name=""IssueWarning"">
     <Warning Text=""Warning!"" />
   </Target>
-  
+
 </Project>");
 
-            TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents);
+            TransientTestProjectWithFiles testProject = _env.CreateTestProjectWithFiles(projectContents);
 
             RunnerUtilities.ExecMSBuild($"\"{testProject.ProjectFile}\" -warnaserror", out bool success, _output);
 
@@ -2284,46 +2239,103 @@ public void EndToEndWarnAsErrors()
         [Fact]
         public void BuildSlnOutOfProc()
         {
-            using (TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create())
-            {
-                string solutionFileContents =
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
+            string solutionFileContents =
+@"Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio Version 16
 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'TestProject', 'TestProject.proj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
 EndProject
 Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Mixed Platforms = Debug|Mixed Platforms
-        Release|Any CPU = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.ActiveCfg = CSConfig1|Any CPU
-        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.Build.0 = CSConfig1|Any CPU
-    EndGlobalSection
+GlobalSection(SolutionConfigurationPlatforms) = preSolution
+    Debug|Mixed Platforms = Debug|Mixed Platforms
+    Release|Any CPU = Release|Any CPU
+EndGlobalSection
+GlobalSection(ProjectConfigurationPlatforms) = postSolution
+    {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.ActiveCfg = CSConfig1|Any CPU
+    {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.Build.0 = CSConfig1|Any CPU
+EndGlobalSection
 EndGlobal
-                    ".Replace("'", "\"");
+                ".Replace("'", "\"");
+
+            var testSolution = _env.CreateFile("TestSolution.sln", ObjectModelHelpers.CleanupFileContents(solutionFileContents));
 
-                var testSolution = testEnvironment.CreateFile("TestSolution.sln", ObjectModelHelpers.CleanupFileContents(solutionFileContents));
+            string testMessage = "Hello from TestProject!";
+            _env.CreateFile("TestProject.proj", @$"
+            <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+              <Target Name=""Build"">
+                <Message Text=""{testMessage}"" />
+              </Target>
+            </Project>
+            ");
 
-                string testMessage = "Hello from TestProject!";
-                testEnvironment.CreateFile("TestProject.proj", @$"
-                <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                  <Target Name=""Build"">
-                    <Message Text=""{testMessage}"" />
-                  </Target>
-                </Project>
-                ");
+            _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
-                testEnvironment.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+            string output = RunnerUtilities.ExecMSBuild($"\"{testSolution.Path}\" /p:Configuration=Debug", out var success, _output);
 
-                string output = RunnerUtilities.ExecMSBuild($"\"{testSolution.Path}\" /p:Configuration=Debug", out var success, _output);
+            success.ShouldBeTrue(output);
+            output.ShouldContain(testMessage);
+        }
 
-                success.ShouldBeTrue(output);
-                output.ShouldContain(testMessage);
+        /// <summary>
+        /// Helper task used by <see cref="EndToEndMinimumMessageImportance"/> to verify <see cref="TaskLoggingHelper.LogsMessagesOfImportance"/>.
+        /// </summary>
+        public class MessageImportanceCheckingTask : Task
+        {
+            public int ExpectedMinimumMessageImportance { get; set; }
+
+            public override bool Execute()
+            {
+                bool shouldLogHigh = Log.LogsMessagesOfImportance(MessageImportance.High);
+                bool shouldLogNormal = Log.LogsMessagesOfImportance(MessageImportance.Normal);
+                bool shouldLogLow = Log.LogsMessagesOfImportance(MessageImportance.Low);
+                return (MessageImportance)ExpectedMinimumMessageImportance switch
+                {
+                    MessageImportance.High - 1 => !shouldLogHigh && !shouldLogNormal && !shouldLogLow,
+                    MessageImportance.High => shouldLogHigh && !shouldLogNormal && !shouldLogLow,
+                    MessageImportance.Normal => shouldLogHigh && shouldLogNormal && !shouldLogLow,
+                    MessageImportance.Low => shouldLogHigh && shouldLogNormal && shouldLogLow,
+                    _ => false
+                };
             }
         }
 
+        [Theory]
+        [InlineData("/v:diagnostic", MessageImportance.Low)]
+        [InlineData("/v:detailed", MessageImportance.Low)]
+        [InlineData("/v:normal", MessageImportance.Normal)]
+        [InlineData("/v:minimal", MessageImportance.High)]
+        [InlineData("/v:quiet", MessageImportance.High - 1)]
+        [InlineData("/v:diagnostic /bl", MessageImportance.Low)]
+        [InlineData("/v:detailed /bl", MessageImportance.Low)]
+        [InlineData("/v:normal /bl", MessageImportance.Low)] // v:normal but with binary logger so everything must be logged
+        [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
+        [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
+        public void EndToEndMinimumMessageImportance(string arguments, MessageImportance expectedMinimumMessageImportance)
+        {
+            using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
+
+            string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
+
+  <UsingTask TaskName=""" + typeof(MessageImportanceCheckingTask).FullName + @""" AssemblyFile=""" + Assembly.GetExecutingAssembly().Location + @"""/>
+
+  <Target Name=""CheckMessageImportance"">
+    <MessageImportanceCheckingTask ExpectedMinimumMessageImportance=""" + (int)expectedMinimumMessageImportance + @""" />
+  </Target>
+
+</Project>");
+
+            TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents);
+
+            // Build in-proc.
+            RunnerUtilities.ExecMSBuild($"{arguments} \"{testProject.ProjectFile}\"", out bool success, _output);
+            success.ShouldBeTrue();
+
+            // Build out-of-proc to exercise both logging code paths.
+            testEnvironment.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+            testEnvironment.SetEnvironmentVariable("MSBUILDDISABLENODEREUSE", "1");
+            RunnerUtilities.ExecMSBuild($"{arguments} \"{testProject.ProjectFile}\"", out success, _output);
+            success.ShouldBeTrue();
+        }
+
 #if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>.
@@ -2417,32 +2429,32 @@ private string ExecuteMSBuildExeExpectFailure(string projectContents, IDictionar
 
         private (bool result, string output) ExecuteMSBuildExe(string projectContents, IDictionary<string, string> filesToCreate = null, IDictionary<string, string> envsToCreate = null, params string[] arguments)
         {
-            using (TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create())
-            {
-                TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents, new string[0]);
+            TransientTestProjectWithFiles testProject = _env.CreateTestProjectWithFiles(projectContents, new string[0]);
 
-                if (filesToCreate != null)
+            if (filesToCreate != null)
+            {
+                foreach (var item in filesToCreate)
                 {
-                    foreach (var item in filesToCreate)
-                    {
-                        File.WriteAllText(Path.Combine(testProject.TestRoot, item.Key), item.Value);
-                    }
+                    File.WriteAllText(Path.Combine(testProject.TestRoot, item.Key), item.Value);
                 }
+            }
 
-                if (envsToCreate != null)
+            if (envsToCreate != null)
+            {
+                foreach (var env in envsToCreate)
                 {
-                    foreach (var env in envsToCreate)
-                    {
-                        testEnvironment.SetEnvironmentVariable(env.Key, env.Value);
-                    }
+                    _env.SetEnvironmentVariable(env.Key, env.Value);
                 }
+            }
 
-                bool success;
+            string output = RunnerUtilities.ExecMSBuild($"\"{testProject.ProjectFile}\" {string.Join(" ", arguments)}", out var success, _output);
 
-                string output = RunnerUtilities.ExecMSBuild($"\"{testProject.ProjectFile}\" {String.Join(" ", arguments)}", out success, _output);
+            return (success, output);
+        }
 
-                return (success, output);
-            }
+        public void Dispose()
+        {
+            _env.Dispose();
         }
     }
 }
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 1dc2dbcd012..6f5c50b7343 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1680,11 +1680,21 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="OutputType" _locComment="" -->Type of output to generate (WinExe, Exe, or Library)</xs:documentation>
         </xs:annotation>
     </xs:element>
+    <xs:element name="PackageOutputPath" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="PackageOutputPath" -->Path to the output folder for the package generated when calling Pack.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
     <xs:element name="PackageTargetFallback" substitutionGroup="msb:Property">
       <xs:annotation>
         <xs:documentation><!-- _locID_text="PackageTargetFallback" _locComment="" -->Allows packages using alternative monikers to be referenced in this project, which include older (e.g. dnxcore50, dotnet5.x) and Portable Class Library names.</xs:documentation>
       </xs:annotation>
     </xs:element>
+    <xs:element name="PackAsTool" type="msb:boolean" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="PackAsTool" _locComment="" -->Indicate whether the NuGet package should be configured as a .NET tool suitable for use with "dotnet tool install".</xs:documentation>
+      </xs:annotation>
+    </xs:element>
     <xs:element name="AssetTargetFallback" type="msb:StringPropertyType" substitutionGroup="msb:Property">
       <xs:annotation>
         <xs:documentation><!-- _locID_text="AssetTargetFallback" _locComment="" -->Can be set to one or more target framework monikers. When determining package compatibility, if the package does not have compatible assets for the project's real target framework, compatibility will be rechecked using each target framework from the AssetTargetFramework project of the referencing project.</xs:documentation>
@@ -1829,6 +1839,11 @@ elementFormDefault="qualified">
     <xs:element name="TargetPlatformVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TargetPlatformMinVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TargetZone" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="ToolCommandName" type="msb:StringPropertyType" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="ToolCommandName" -->Specifies the command that will invoke the tool after it's installed.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
     <xs:element name="TreatWarningsAsErrors" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="TrustUrlParameters" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 34adcd7cb25..9ee7405d822 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -33,7 +33,7 @@ internal class OutOfProcTaskHostNode :
 #if CLR2COMPATIBILITY
         IBuildEngine3
 #else
-        IBuildEngine9
+        IBuildEngine10
 #endif
     {
         /// <summary>
@@ -172,7 +172,7 @@ public OutOfProcTaskHostNode()
             // We don't know what the current build thinks this variable should be until RunTask(), but as a fallback in case there are
             // communications before we get the configuration set up, just go with what was already in the environment from when this node
             // was initially launched.
-            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
+            _debugCommunications = Traits.Instance.DebugNodeCommunication;
 
             _receivedPackets = new Queue<INodePacket>();
 
@@ -492,6 +492,22 @@ public void ReleaseCores(int coresToRelease)
         }
 
         #endregion
+
+        #region IBuildEngine10 Members
+
+        [Serializable]
+        private sealed class EngineServicesImpl : EngineServices
+        {
+            /// <summary>
+            /// No logging verbosity optimization in OOP nodes.
+            /// </summary>
+            public override bool LogsMessagesOfImportance(MessageImportance importance) => true;
+        }
+
+        public EngineServices EngineServices { get; } = new EngineServicesImpl();
+
+        #endregion
+
 #endif
 
         #region INodePacketFactory Members
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index d1ce644a52e..5769d82fa59 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="cs" original="../Strings.resx">
     <body>
@@ -494,10 +494,10 @@ Copyright (C) Microsoft Corporation. V≈°echna pr√°va vyhrazena.
                         ErrorsOnly ‚Äì zobraz√≠ jenom chyby.
                         WarningsOnly ‚Äì zobraz√≠ jenom upozornƒõn√≠.
                         NoItemAndPropertyList ‚Äì nezobraz√≠ na zaƒç√°tku sestaven√≠ ka≈æd√©ho
-                            projektu seznamy polo≈æek a vlastnost√≠.    
-                        ShowCommandLine ‚Äì zobraz√≠ zpr√°vy TaskCommandLineEvent.  
+                            projektu seznamy polo≈æek a vlastnost√≠.
+                        ShowCommandLine ‚Äì zobraz√≠ zpr√°vy TaskCommandLineEvent.
                         ShowTimestamp ‚Äì p≈ôed ka≈ædou zpr√°vou zobraz√≠
-                            ƒçasov√© raz√≠tko.                                           
+                            ƒçasov√© raz√≠tko.
                         ShowEventId ‚Äì zobraz√≠ ID ud√°losti pro spu≈°tƒõn√© a dokonƒçen√©
                             ud√°losti a zpr√°vy.
                         ForceNoAlign ‚Äì nenastavuje text podle velikosti vyrovn√°vac√≠
@@ -634,7 +634,7 @@ Copyright (C) Microsoft Corporation. V≈°echna pr√°va vyhrazena.
                      Setting this also turns on isolated builds (-isolate).
                      (short form: -orc)
    </source>
-        <target state="translated">  -outputResultsCache:&lt;souborMezipamƒõti&gt;...
+        <target state="translated">  -outputResultsCache:[souborMezipamƒõti]...
                      V√Ωstupn√≠ soubor mezipamƒõti, do nƒõho≈æ bude MSBuild
                      zapisovat obsah sv√Ωch mezipamƒõt√≠ v√Ωsledk≈Ø sestaven√≠.
                      Nastaven√≠m t√©to mo≈ænosti zapnete tak√© izolovan√© buildy (-isolate).
@@ -794,7 +794,7 @@ Copyright (C) Microsoft Corporation. V≈°echna pr√°va vyhrazena.
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger                                                       
+        <target state="translated">  -distributedFileLogger
                      Ulo≈æ√≠ v√Ωstup sestaven√≠ do v√≠ce soubor≈Ø protokolu, po jednom
                      pro ka≈æd√Ω uzel n√°stroje MSBuild. Tyto soubory jsou na poƒç√°tku
                      um√≠stƒõny v aktu√°ln√≠m adres√°≈ôi. Standardnƒõ maj√≠ tyto soubory
@@ -1566,48 +1566,48 @@ Copyright (C) Microsoft Corporation. V≈°echna pr√°va vyhrazena.
                        -binaryLogger
     </source>
         <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializuje v≈°echny ud√°losti sestaven√≠ do komprimovan√©ho
-                     bin√°rn√≠ho souboru. Tento soubor se standardnƒõ nach√°z√≠
-                     v aktu√°ln√≠m adres√°≈ôi a m√° n√°zev msbuild.binlog. Bin√°rn√≠
-                     protokol je podrobn√Ω popis procesu sestaven√≠, kter√Ω se
+                     Serializuje v≈°echny ud√°losti sestaven√≠ do komprimovan√©ho bin√°rn√≠ho souboru.
+                     Tento soubor se standardnƒõ nach√°z√≠ v aktu√°ln√≠m adres√°≈ôi a m√° n√°zev msbuild.binlog.
+                     Bin√°rn√≠ protokol je podrobn√Ω popis procesu sestaven√≠, kter√Ω se
                      d√° pozdƒõji pou≈æ√≠t k rekonstrukci textov√Ωch protokol≈Ø
                      a kter√Ω m≈Ø≈æou pou≈æ√≠vat jin√© n√°stroje pro anal√Ωzu.
                      Bin√°rn√≠ protokol m√° obvykle 10‚Äì20kr√°t men≈°√≠ velikost ne≈æ
-                     nejpodrobnƒõj≈°√≠ textov√Ω protokol na √∫rovni diagnostiky,
-                     ale obsahuje v√≠ce informac√≠.
+                     nejpodrobnƒõj≈°√≠ textov√Ω protokol na √∫rovni diagnostiky, ale obsahuje v√≠ce informac√≠.
                      (Kr√°tk√Ω tvar: -bl)
 
                      Bin√°rn√≠ protokolovac√≠ n√°stroj standardnƒõ shroma≈æƒèuje
                      zdrojov√Ω text projektov√Ωch soubor≈Ø vƒçetnƒõ v≈°ech
                      importovan√Ωch projekt≈Ø a c√≠lov√Ωch soubor≈Ø zji≈°tƒõn√Ωch
-                     p≈ôi sestavov√°n√≠. Toto chov√°n√≠ ≈ô√≠d√≠ voliteln√Ω parametr
-                     ProjectImports:
-                      ProjectImports=None     - Neshroma≈æƒèovat importovan√©
-                                                projekty
+                     p≈ôi sestavov√°n√≠. Toto chov√°n√≠ ≈ô√≠d√≠ voliteln√Ω parametr ProjectImports:
+
+                     ProjectImports=None     - Neshroma≈æƒèovat importovan√©
+                                                 projekty.
                       ProjectImports=Embed    - Vlo≈æit importovan√© projekty
-                                                do souboru protokolu
+                     do souboru protokolu.
                       ProjectImports=ZipFile  - Ulo≈æit projektov√© soubory
                                                 do output.projectimports.zip,
                                                 kde output je stejn√Ω n√°zev
-                                                jako n√°zev souboru bin√°rn√≠ho
-                                                protokolu
+                                                jako n√°zev souboru bin√°rn√≠ho protokolu.
+
                      V√Ωchoz√≠ nastaven√≠ pro ProjectImports je Embed.
                      Pozn√°mka: Protokolovac√≠ n√°stroj neshroma≈æƒèuje zdrojov√©
                      soubory nepat≈ô√≠c√≠ pod MSBuild, jako .cs, .cpp atd.
+
                      Soubor .binlog se d√° znovu p≈ôehr√°t‚Äú tak, ≈æe se p≈ôed√°
                      souboru msbuild.exe jako argument m√≠sto projektu/≈ôe≈°en√≠.
                      Jin√© protokolovac√≠ n√°stroje obdr≈æ√≠ informace obsa≈æen√©
                      v souboru protokolu, jako by ≈°lo o p≈Øvodn√≠ sestaven√≠.
-                     V√≠ce o bin√°rn√≠m protokolu a jeho pou≈æit√≠ si m≈Ø≈æete
-                     p≈ôeƒç√≠st na str√°nce:
+                     V√≠ce o bin√°rn√≠m protokolu a jeho pou≈æit√≠ si m≈Ø≈æete p≈ôeƒç√≠st na str√°nce:
                      https://aka.ms/msbuild/binlog
+
                      P≈ô√≠klady:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
                        -bl:output.binlog;ProjectImports=ZipFile
-                       -bl:..\\..\\custom.binlog
-                       -binaryLogger    </target>
+                       -bl:..\..\custom.binlog
+                       -binaryLogger
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 8284308c137..9ccad6d1801 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="de" original="../Strings.resx">
     <body>
@@ -505,7 +505,7 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
                             bei der Mehrprozessorprotokollierung im Modus mit nur einem Prozessor.
                         EnableMPLogging: Aktiviert das Format der
                             Mehrprozessorprotokollierung auch bei der Ausf√ºhrung
-                            im Modus mit nur einem Prozessor. Dieses Protokollierungsformat ist standardm√§√üig aktiviert.  
+                            im Modus mit nur einem Prozessor. Dieses Protokollierungsformat ist standardm√§√üig aktiviert. 
                         ForceConsoleColor: Verwendet selbst dann
                             ANSI-Konsolenfarben, wenn
                             die Konsole dies nicht unterst√ºtzt.
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 4b0ad7be159..e36eec845fb 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
     <body>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 6c40786a49a..ecd04ae29ab 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
     <body>
@@ -844,13 +844,12 @@ Copyright (C) Microsoft Corporation. Tous droits r√©serv√©s.
          Param√®tres suppl√©mentaires pour les journaliseurs de fichiers.
          La pr√©sence de ce commutateur implique l'utilisation du
          commutateur -fileLogger[n] correspondant.
-         S'il est sp√©cifi√©, "n" doit √™tre un chiffre entre¬†1 et¬†9.
+         S'il est sp√©cifi√©, "n" doit √™tre un chiffre entre 1 et 9.
          -fileLoggerParameters est √©galement utilis√© par tous les
-         journaliseurs vers des fichiers. Consultez la description
-         de -distributedFileLogger.
-         (Forme abr√©g√©e¬†: -flp[n])
+         journaliseurs vers des fichiers. Consultez la description de -distributedFileLogger.
+         (Forme abr√©g√©e : -flp[n])
          Les m√™mes param√®tres que ceux list√©s pour le journaliseur de la
-         console sont disponibles. Param√®tres suppl√©mentaires disponibles¬†:
+         console sont disponibles. Param√®tres suppl√©mentaires disponibles :
             LogFile--Chemin du fichier journal dans lequel
                 le journal de g√©n√©ration est √©crit.
             Append--D√©termine si le journal de g√©n√©ration est ajout√©
@@ -862,7 +861,7 @@ Copyright (C) Microsoft Corporation. Tous droits r√©serv√©s.
             Encoding--Sp√©cifie l'encodage du fichier,
                 par exemple, UTF-8, Unicode ou ASCII
          Le niveau de d√©tail par d√©faut est Detailed.
-         Exemples¬†:
+         Exemples :
            -fileLoggerParameters:LogFile=MyLog.log;Append;
                    Verbosity=diagnostic;Encoding=UTF-8
 
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 6ebbdf7964f..c37e60c4dc4 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="it" original="../Strings.resx">
     <body>
@@ -315,7 +315,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
         <target state="translated">  @&lt;file&gt;            Inserisce le impostazioni della riga di comando da un file di testo. Per specificare
                      pi√π file di risposta, specificare ciascun file
                      separatamente.
-                     
+
                      Qualsiasi file di risposta denominato "msbuild.rsp" viene usato
                      automaticamente dai percorsi seguenti: 
                      (1) la directory di msbuild.exe
@@ -815,6 +815,7 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
                      file viene assegnato il nome "MSBuild&lt;idnodo&gt;.log". Il
                      percorso dei file e altri parametri di fileLogger possono
                      essere specificati aggiungendo l'opzione
+
                      "-fileLoggerParameters".
                      Se il nome di un file di log viene impostato con l'opzione
                      fileLoggerParameters, il logger distribuito user√† il nome
@@ -1685,7 +1686,8 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
                      file is '.md', the result is generated in markdown
                      format. Otherwise, a tab separated file is produced.
     </source>
-        <target state="translated">  -profileEvaluation:&lt;file&gt;                     Esegue la profilatura della valutazione di MSBuild e scrive
+        <target state="translated">  -profileEvaluation:&lt;file&gt;
+Esegue la profilatura della valutazione di MSBuild e scrive
                      il risultato nel file specificato. Se l'estensione del file
                      specificato √® '.md', il risultato viene generato in formato
                      Markdown. In caso contrario, viene prodotto un file
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 089b3db5c9e..58adc2124db 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ja" original="../Strings.resx">
     <body>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 2d320eb0ef0..4e641e8d1e0 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
     <body>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index c14e0ffa53d..548f0673c44 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pl" original="../Strings.resx">
     <body>
@@ -412,7 +412,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrze≈ºone.
                         [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;
                         [;&lt;parametry rejestratora&gt;]
                      Sk≈Çadnia elementu &lt;klasa rejestratora&gt;:
-                        &lt;czƒô≈õciowa lub pe≈Çna przestrze≈Ñ nazw&gt;.]
+                        [&lt;czƒô≈õciowa lub pe≈Çna przestrze≈Ñ nazw&gt;.]
                         &lt;nazwa klasy rejestratora&gt;
                      Sk≈Çadnia elementu &lt;zestaw rejestratora&gt;:
                         {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
@@ -807,6 +807,7 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrze≈ºone.
                      Domy≈õlnie pliki majƒÖ nazwƒô
                      ‚ÄûMSBuild&lt;identyfikator wƒôz≈Ça&gt;.log‚Äù. Lokalizacjƒô plik√≥w
                      i inne parametry rejestratora plik√≥w mo≈ºna okre≈õliƒá
+
                      przez dodanie prze≈ÇƒÖcznika ‚Äû-fileLoggerParameters‚Äù.
 
                      Je≈õli nazwa pliku zostanie ustawiona za pomocƒÖ prze≈ÇƒÖcznika
@@ -1641,7 +1642,7 @@ dziennik√≥w                     tekstowych i wykorzystaƒá w innych narzƒôdziach
                      przywr√≥cenia pakiet√≥w przed ich skompilowaniem. Podanie parametru 
                      -restore jest r√≥wnoznaczne z podaniem parametru -restore:True.
                      Za pomocƒÖ tego parametru mo≈ºna przes≈Çoniƒá warto≈õƒá pochodzƒÖcƒÖ
-                     z pliku odpowiedzi.                     
+                     z pliku odpowiedzi.
                      (Kr√≥tka forma: -r)
     </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 751fc9b422d..e41b484c1a6 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pt-BR" original="../Strings.resx">
     <body>
@@ -1623,9 +1623,12 @@ isoladamente.
     </source>
         <target state="translated">  -restore[:True|False]
                      Executa um destino chamado Restore antes de compilar
-                     outros destinos e garante o build desses                                                     ¬†                    destinos usando uma l√≥gica de build restaurada.                                                             Isso √© √∫til quando sua √°rvore de
-projeto precisar ¬†¬†                                               ¬†                    que pacotes sejam restaurados antes de serem compilados.¬† ¬†  ¬†      ¬†     ¬†       Especificar -restore √© o mesmo que
-                     especificar                            -restore:True. Use o par√¢metro para
+                     outros destinos e garante o build desses
+                     destinos usando uma l√≥gica de build restaurada.
+                     Isso √© √∫til quando sua √°rvore de  projeto precisar
+                     que pacotes sejam restaurados antes de serem compilados.
+                     Especificar -restore √© o mesmo que
+                     -restore:True. Use o par√¢metro para
                      substituir um valor originado de um arquivo de resposta.
                      (Forma abreviada: -r)
     </target>
@@ -1707,4 +1710,4 @@ projeto precisar ¬†¬†                                               ¬†
       </trans-unit>
     </body>
   </file>
-</xliff>
+</xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 75212bac50f..4ef8b52a05a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
     <body>
@@ -366,7 +366,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                        -property:WarningLevel=2;OutDir=bin\Debug\
 </source>
         <target state="translated">  -property:&lt;n&gt;=&lt;v&gt;  –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∏–ª–∏ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ —Å–≤–æ–π—Å—Ç–≤–∞ —É—Ä–æ–≤–Ω—è –ø—Ä–æ–µ–∫—Ç–∞. &lt;n&gt; —è–≤–ª—è–µ—Ç—Å—è
-                     –∏–º–µ–Ω–µ–º —Å–≤–æ–π—Å—Ç–≤–∞, –∞ &lt;v&gt;¬†‚Äî  –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ 
+                     –∏–º–µ–Ω–µ–º —Å–≤–æ–π—Å—Ç–≤–∞, –∞ &lt;v&gt; ‚Äî  –µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ
                      —Ç–æ—á–∫—É —Å –∑–∞–ø—è—Ç–æ–π –∏–ª–∏ –∑–∞–ø—è—Ç—É—é, —á—Ç–æ–±—ã —Ä–∞–∑–¥–µ–ª–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–≤–æ–π—Å—Ç–≤, –∏–ª–∏
                      —É–∫–∞–∂–∏—Ç–µ –∫–∞–∂–¥–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ –æ—Ç–¥–µ–ª—å–Ω–æ. (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -p)
                      –ü—Ä–∏–º–µ—Ä:
@@ -572,12 +572,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                      MSBuild will use up to the number of processors on the
                      computer. (Short form: -m[:n])
       </source>
-        <target state="translated">  -maxCpuCount[:n]   –£–∫–∞–∑—ã–≤–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
-                     –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ —Å–±–æ—Ä–∫–∏. –ï—Å–ª–∏ –∫–ª—é—á
-                     –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1.
-                     –ï—Å–ª–∏ –∫–ª—é—á –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –±–µ–∑ –∑–Ω–∞—á–µ–Ω–∏—è, MSBuild
-                     –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–æ–≤,
-                     –∫–æ—Ç–æ—Ä–æ–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–µ. (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -m[:n])
+        <target state="translated">  -maxCpuCount[:n]   –£–∫–∞–∑—ã–≤–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö
+                     –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ —Å–±–æ—Ä–∫–∏.  –ï—Å–ª–∏ –∫–ª—é—á –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ
+                     –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1.  –ï—Å–ª–∏ –∫–ª—é—á –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –±–µ–∑ –∑–Ω–∞—á–µ–Ω–∏—è,
+                     MSBuild –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–æ–≤, –∫–æ—Ç–æ—Ä–æ–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞
+                     –∫–æ–º–ø—å—é—Ç–µ—Ä–µ. (–ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞: -m[:n])
       </target>
         <note>
           LOCALIZATION: "maxCpuCount" should not be localized.
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index f8ed2f2d849..8bed4f53eff 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="tr" original="../Strings.resx">
     <body>
@@ -506,7 +506,7 @@ Telif Hakkƒ± (C) Microsoft Corporation. T√ºm haklarƒ± saklƒ±dƒ±r.
                             devre dƒ±≈üƒ± bƒ±rak.
                         EnableMPLogging--√áok i≈ülemci olmayan modda √ßalƒ±≈üƒ±rken 
                             bile √ßok i≈ülemcili g√ºnl√ºk stilini etkinle≈ütir. Bu 
-                            g√ºnl√ºk stili varsayƒ±lan olarak a√ßƒ±ktƒ±r.  
+                            g√ºnl√ºk stili varsayƒ±lan olarak a√ßƒ±ktƒ±r.
                         ForceConsoleColor--Konsol desteklemese bile ANSI
                             konsol renklerini kullan
                                                 Verbosity--Bu g√ºnl√ºk√ß√º i√ßin /verbosity ayarƒ±nƒ±
@@ -789,7 +789,7 @@ Telif Hakkƒ± (C) Microsoft Corporation. T√ºm haklarƒ± saklƒ±dƒ±r.
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger                                                       
+        <target state="translated">  -distributedFileLogger
                      Derleme √ßƒ±kƒ±≈üƒ±nƒ±, her MSBuild d√ºƒü√ºm√º i√ßin bir g√ºnl√ºk
                      dosyasƒ± olmak √ºzere birden √ßok g√ºnl√ºk dosyasƒ±na kaydeder. Bu
                      dosyalarƒ±n ilk konumu ge√ßerli dizindir. Dosyalarƒ±n 
@@ -1631,7 +1631,7 @@ Telif Hakkƒ± (C) Microsoft Corporation. T√ºm haklarƒ± saklƒ±dƒ±r.
                      Bu, proje aƒüacƒ±nƒ±zƒ±n paketlerin olu≈üturulabilmesi i√ßin
                      √∂nce geri y√ºklenmesini gerektirdiƒüi durumlarda yararlƒ±dƒ±r.
                      -restore deƒüerinin belirtilmesi, -restore:True deƒüerinin
-                     belirtilmesiyle aynƒ±dƒ±r.  Yanƒ±t dosyasƒ±ndan gelen bir deƒüeri
+                     belirtilmesiyle aynƒ±dƒ±r. Yanƒ±t dosyasƒ±ndan gelen bir deƒüeri
                      ge√ßersiz kƒ±lmak i√ßin parametreyi kullanƒ±n.
                      (Kƒ±sa bi√ßim: -r)
     </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index bf57d51080e..011389fa1a6 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
@@ -800,7 +800,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
            ÂºÄÂÖ≥ËÆæÁΩÆÁöÑÔºåÂàÜÂ∏ÉÂºèËÆ∞ÂΩïÂô®Â∞Ü‰ΩøÁî® fileName ‰Ωú‰∏∫
            Ê®°ÊùøÂπ∂Â∞ÜËäÇÁÇπ ID ÈôÑÂä†Âà∞Ê≠§ fileName 
            ‰ª•‰æø‰∏∫ÊØè‰∏™ËäÇÁÇπÂàõÂª∫‰∏Ä‰∏™Êó•ÂøóÊñá‰ª∂„ÄÇ
-  </target>
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "MSBuild", "MSBuild.exe" and "MSBuild.rsp"
@@ -868,7 +868,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
             -flp1:warningsonly;logfile=msbuild.wrn 
             -flp2:errorsonly;logfile=msbuild.err
-  </target>
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "MSBuild", "MSBuild.exe" and "MSBuild.rsp"
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 066da1aa35f..a3b1e39cf03 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 09a0f38eaf3..3a62d532f86 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -3133,7 +3133,9 @@ private static void ProcessFileLoggers(string[][] groupedFileLoggerParameters, L
                 LoggerVerbosity defaultFileLoggerVerbosity = LoggerVerbosity.Detailed;
                 fileLogger.Verbosity = defaultFileLoggerVerbosity;
 
-                if (cpuCount == 1)
+                // Check to see if there is a possibility we will be logging from an out-of-proc node.
+                // If so (we're multi-proc or the in-proc node is disabled), we register a distributed logger.
+                if (cpuCount == 1 && Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") != "1")
                 {
                     // We've decided to use the MP logger even in single proc mode.
                     // Switch it on here, rather than in the logger, so that other hosts that use
@@ -3197,7 +3199,9 @@ List<ILogger> loggers
                     consoleParameters = AggregateParameters(consoleParameters, consoleLoggerParameters);
                 }
 
-                if (cpuCount == 1)
+                // Check to see if there is a possibility we will be logging from an out-of-proc node.
+                // If so (we're multi-proc or the in-proc node is disabled), we register a distributed logger.
+                if (cpuCount == 1 && Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") != "1")
                 {
                     // We've decided to use the MP logger even in single proc mode.
                     // Switch it on here, rather than in the logger, so that other hosts that use
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 3ef1cfa3ffc..1946bc0bbb9 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -10,7 +10,11 @@
       <DisableFXClosureWalk enabled="true" />
       <DeferFXClosureWalk enabled="true" />
       <generatePublisherEvidence enabled="false" />
-      <AppContextSwitchOverrides value="Switch.System.Security.Cryptography.UseLegacyFipsThrow=false" />
+      <ThreadPool_UnfairSemaphoreSpinLimit enabled="0" />
+      <!-- Manually expanded list of quirks applied to a .NET 4.7.2 application, to work around CLR bug that doesn't apply them correctly
+           https://referencesource.microsoft.com/#mscorlib/system/AppContext/AppContextDefaultValues.Defaults.cs,37
+           Framework bug: https://dev.azure.com/devdiv/DevDiv/_workitems/edit/1148752 -->
+      <AppContextSwitchOverrides value="Switch.System.Globalization.NoAsyncCurrentCulture=false;Switch.System.Threading.ThrowExceptionIfDisposedCancellationTokenSource=false;Switch.System.Security.ClaimsIdentity.SetActorAsReferenceWhenCopyingClaimsIdentity=false;Switch.System.Security.Cryptography.DoNotAddrOfCspParentWindowHandle=false;Switch.System.Diagnostics.IgnorePortablePDBsInStackTraces=false;Switch.System.IO.UseLegacyPathHandling=false;Switch.System.IO.BlockLongPaths=false;Switch.System.Security.Cryptography.UseLegacyFipsThrow=false;" />
       <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.Framework" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
@@ -110,11 +114,11 @@
         <!-- Redirects for components dropped by Visual Studio -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Activities.Build" culture="neutral" publicKeyToken="31bf3856ad364e35" />
-          <bindingRedirect oldVersion="4.0.0.0" newVersion="16.0.0.0" />
+          <bindingRedirect oldVersion="4.0.0.0" newVersion="17.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="XamlBuildTask" culture="neutral" publicKeyToken="31bf3856ad364e35" />
-          <bindingRedirect oldVersion="4.0.0.0-16.0.0.0" newVersion="16.0.0.0" />
+          <bindingRedirect oldVersion="4.0.0.0-17.0.0.0" newVersion="17.0.0.0" />
         </dependentAssembly>
 
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
@@ -156,7 +160,7 @@
         <property name="RoslynTargetsPath" value="$([MSBuild]::GetToolsDirectory32())\Roslyn" />
 
         <!-- VC Specific Paths -->
-        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v160\'))" />
+        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v170\'))" />
         <property name="VCTargetsPath14" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath14)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V140\'))" />
         <property name="VCTargetsPath12" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath12)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V120\'))" />
         <property name="VCTargetsPath11" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath11)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V110\'))" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 3eee42f2426..4f9a252f295 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -10,6 +10,7 @@
       <DisableFXClosureWalk enabled="true" />
       <DeferFXClosureWalk enabled="true" />
       <generatePublisherEvidence enabled="false" />
+      <ThreadPool_UnfairSemaphoreSpinLimit enabled="0" />
       <AppContextSwitchOverrides value="Switch.System.Security.Cryptography.UseLegacyFipsThrow=false" />
       <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
         <dependentAssembly>
@@ -103,13 +104,13 @@
         <!-- Redirects for components dropped by Visual Studio -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Activities.Build" culture="neutral" publicKeyToken="31bf3856ad364e35" />
-          <bindingRedirect oldVersion="4.0.0.0" newVersion="16.0.0.0" />
-          <codeBase version="16.0.0.0" href=".\amd64\Microsoft.Activities.Build.dll" />
+          <bindingRedirect oldVersion="4.0.0.0" newVersion="17.0.0.0" />
+          <codeBase version="17.0.0.0" href=".\amd64\Microsoft.Activities.Build.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="XamlBuildTask" culture="neutral" publicKeyToken="31bf3856ad364e35" />
-          <bindingRedirect oldVersion="4.0.0.0-16.0.0.0" newVersion="16.0.0.0" />
-          <codeBase version="16.0.0.0" href=".\amd64\XamlBuildTask.dll" />
+          <bindingRedirect oldVersion="4.0.0.0-17.0.0.0" newVersion="17.0.0.0" />
+          <codeBase version="17.0.0.0" href=".\amd64\XamlBuildTask.dll" />
         </dependentAssembly>
 
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
@@ -151,7 +152,7 @@
         <property name="RoslynTargetsPath" value="$([MSBuild]::GetToolsDirectory32())\Roslyn" />
 
         <!-- VC Specific Paths -->
-        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v160\'))" />
+        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v170\'))" />
         <property name="VCTargetsPath14" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath14)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V140\'))" />
         <property name="VCTargetsPath12" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath12)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V120\'))" />
         <property name="VCTargetsPath11" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath11)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V110\'))" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 93a462aed27..eac0cd9b1b1 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -36,20 +36,20 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)MSBuild.exe.config
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe vs.file.ngenArchitecture=x86
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
-  file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)Microsoft.NET.StringTools.dll vs.file.ngenArchitecture=all
   file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
diff --git a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
index 3b26b82d942..7f049a6c699 100644
--- a/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
+++ b/src/Samples/ProjectCachePlugin/AssemblyMockCache.cs
@@ -2,11 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Diagnostics;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
+using Shouldly;
 
 namespace MockCacheFromAssembly
 {
@@ -33,6 +35,8 @@ public override Task<CacheResult> GetCacheResultAsync(
         {
             logger.LogMessage($"{nameof(AssemblyMockCache)}: GetCacheResultAsync for {buildRequest.ProjectFullPath}", MessageImportance.High);
 
+            buildRequest.ProjectInstance.ShouldNotBeNull("The cache plugin expects evaluated projects.");
+
             ErrorFrom(nameof(GetCacheResultAsync), logger);
 
             return Task.FromResult(CacheResult.IndicateNonCacheHit(CacheResultType.CacheNotApplicable));
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
index 4f7a5e8d6ad..f96f6412f45 100644
--- a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -12,4 +12,7 @@
     <ProjectReference Include="..\..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\..\Framework\Microsoft.Build.Framework.csproj" />
   </ItemGroup>
+  <ItemGroup>
+    <PackageReference Include="Shouldly" Version="3.0.0" />
+  </ItemGroup>
 </Project>
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 8c62a178e05..99db41274e3 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -148,7 +148,6 @@ private AssemblyNameExtension(SerializationInfo info, StreamingContext context)
                 var hashAlgorithm = (System.Configuration.Assemblies.AssemblyHashAlgorithm) info.GetInt32("hashAlg");
                 var versionCompatibility = (AssemblyVersionCompatibility) info.GetInt32("verCompat");
                 var codeBase = info.GetString("codebase");
-                var keyPair = (StrongNameKeyPair) info.GetValue("keypair", typeof(StrongNameKeyPair));
 
                 asAssemblyName = new AssemblyName
                 {
@@ -160,7 +159,6 @@ private AssemblyNameExtension(SerializationInfo info, StreamingContext context)
                     HashAlgorithm = hashAlgorithm,
                     VersionCompatibility = versionCompatibility,
                     CodeBase = codeBase,
-                    KeyPair = keyPair
                 };
 
                 asAssemblyName.SetPublicKey(publicKey);
@@ -635,7 +633,7 @@ private static int CompareBaseNamesStringWise(string asString1, string asString2
         /// </summary>
         internal AssemblyNameExtension Clone()
         {
-            AssemblyNameExtension newExtension = new AssemblyNameExtension();
+            AssemblyNameExtension newExtension = new();
 
             if (asAssemblyName != null)
             {
@@ -1001,7 +999,6 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)
                 info.AddValue("hashAlg", asAssemblyName.HashAlgorithm);
                 info.AddValue("verCompat", asAssemblyName.VersionCompatibility);
                 info.AddValue("codebase", asAssemblyName.CodeBase);
-                info.AddValue("keypair", asAssemblyName.KeyPair);
             }
 
             info.AddValue("asStr", asString);
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 74f46865a14..56a1b1f3803 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -64,6 +64,14 @@ public BinaryReadTranslator(Stream packetStream, SharedReadBuffer buffer)
                 _reader = InterningBinaryReader.Create(packetStream, buffer);
             }
 
+            /// <summary>
+            /// Delegates the Dispose call the to the underlying BinaryReader.
+            /// </summary>
+            public void Dispose()
+            {
+                _reader.Close();
+            }
+
             /// <summary>
             /// Gets the reader, if any.
             /// </summary>
@@ -716,6 +724,14 @@ public BinaryWriteTranslator(Stream packetStream)
                 _writer = new BinaryWriter(packetStream);
             }
 
+            /// <summary>
+            /// Delegates the Dispose call the to the underlying BinaryWriter.
+            /// </summary>
+            public void Dispose()
+            {
+                _writer.Close();
+            }
+
             /// <summary>
             /// Gets the reader, if any.
             /// </summary>
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 5631f5c9358..6f739d163b8 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -125,7 +125,7 @@ private static BuildEnvironment TryFromEnvironmentVariable()
 
             return msBuildExePath == null
                 ? null
-                : TryFromMSBuildAssemblyUnderVisualStudio(msBuildExePath, msBuildExePath, true) ?? TryFromStandaloneMSBuildExe(msBuildExePath);
+                : TryFromMSBuildExeUnderVisualStudio(msBuildExePath, allowLegacyToolsVersion: true) ?? TryFromStandaloneMSBuildExe(msBuildExePath);
         }
 
         private static BuildEnvironment TryFromVisualStudioProcess()
@@ -183,7 +183,7 @@ private static BuildEnvironment TryFromMSBuildAssembly()
             var msBuildDll = Path.Combine(FileUtilities.GetFolderAbove(buildAssembly), "MSBuild.dll");
 
             // First check if we're in a VS installation
-            var environment = TryFromMSBuildAssemblyUnderVisualStudio(buildAssembly, msBuildExe);
+            var environment = TryFromMSBuildExeUnderVisualStudio(msBuildExe);
             if (environment != null)
             {
                 return environment;
@@ -208,25 +208,22 @@ private static BuildEnvironment TryFromMSBuildAssembly()
             return null;
         }
 
-        private static BuildEnvironment TryFromMSBuildAssemblyUnderVisualStudio(string msbuildAssembly, string msbuildExe, bool allowLegacyToolsVersion = false)
+        private static BuildEnvironment TryFromMSBuildExeUnderVisualStudio(string msbuildExe, bool allowLegacyToolsVersion = false)
         {
             string msBuildPathPattern = allowLegacyToolsVersion
                 ? $@".*\\MSBuild\\({CurrentToolsVersion}|\d+\.0)\\Bin\\.*"
                 : $@".*\\MSBuild\\{CurrentToolsVersion}\\Bin\\.*";
 
             if (NativeMethodsShared.IsWindows &&
-                Regex.IsMatch(msbuildAssembly, msBuildPathPattern, RegexOptions.IgnoreCase))
+                Regex.IsMatch(msbuildExe, msBuildPathPattern, RegexOptions.IgnoreCase))
             {
-                // In a Visual Studio path we must have MSBuild.exe
-                if (FileSystems.Default.FileExists(msbuildExe))
-                {
-                    return new BuildEnvironment(
+                string visualStudioRoot = GetVsRootFromMSBuildAssembly(msbuildExe);
+                return new BuildEnvironment(
                         BuildEnvironmentMode.VisualStudio,
                         msbuildExe,
                         runningTests: s_runningTests(),
                         runningInVisualStudio: false,
-                        visualStudioPath: GetVsRootFromMSBuildAssembly(msbuildExe));
-                }
+                        visualStudioPath: visualStudioRoot);
             }
 
             return null;
@@ -320,7 +317,8 @@ private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePat
         private static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)
         {
             return FileUtilities.GetFolderAbove(msBuildAssembly,
-                Regex.IsMatch(msBuildAssembly, $@"\\Bin\\Amd64\\MSBuild\.exe", RegexOptions.IgnoreCase)
+                Path.GetDirectoryName(msBuildAssembly)
+                  .EndsWith(@"\amd64", StringComparison.OrdinalIgnoreCase)
                     ? 5
                     : 4);
         }
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index f8337625465..9f643cc6ea6 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -13,7 +13,11 @@
 
 using Microsoft.Build.Shared;
 using System.Reflection;
+using Microsoft.Build.Utilities;
 
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Shared.Debugging;
+#endif
 #if !FEATURE_APM
 using System.Threading.Tasks;
 #endif
@@ -131,7 +135,7 @@ static internal class CommunicationsUtilities
         /// <summary>
         /// Whether to trace communications
         /// </summary>
-        private static bool s_trace = String.Equals(Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM"), "1", StringComparison.Ordinal);
+        private static bool s_trace = Traits.Instance.DebugNodeCommunication;
 
         /// <summary>
         /// Place to dump trace
@@ -175,6 +179,13 @@ static internal int NodeConnectionTimeout
         /// </summary>
         internal static Dictionary<string, string> GetEnvironmentVariables()
         {
+#if !CLR2COMPATIBILITY
+            // The DebugUtils static constructor can set the MSBUILDDEBUGPATH environment variable to propagate the debug path to out of proc nodes.
+            // Need to ensure that constructor is called before this method returns in order to capture its env var write.
+            // Otherwise the env var is not captured and thus gets deleted when RequiestBuilder resets the environment based on the cached results of this method.
+            ErrorUtilities.VerifyThrowInternalNull(DebugUtils.DebugPath, nameof(DebugUtils.DebugPath));
+#endif
+
             Dictionary<string, string> table = new Dictionary<string, string>(200, StringComparer.OrdinalIgnoreCase); // Razzle has 150 environment variables
 
             if (NativeMethodsShared.IsWindows)
@@ -552,7 +563,14 @@ internal static void Trace(int nodeId, string format, params object[] args)
             {
                 if (s_debugDumpPath == null)
                 {
-                    s_debugDumpPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                    s_debugDumpPath =
+#if CLR2COMPATIBILITY
+                        Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+#else
+                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
+                            ? DebugUtils.DebugPath
+                            : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+#endif
 
                     if (String.IsNullOrEmpty(s_debugDumpPath))
                     {
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 14cd04a244d..19b6d03f5d0 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -153,26 +153,23 @@ private Assembly TryResolveAssemblyFromPaths(AssemblyLoadContext context, Assemb
             {
                 foreach (var searchPath in searchPaths)
                 {
-                    foreach (var extension in MSBuildLoadContext.Extensions)
+                    var candidatePath = Path.Combine(searchPath,
+                        cultureSubfolder,
+                        $"{assemblyName.Name}.dll");
+
+                    if (IsAssemblyAlreadyLoaded(candidatePath) ||
+                        !FileSystems.Default.FileExists(candidatePath))
                     {
-                        var candidatePath = Path.Combine(searchPath,
-                            cultureSubfolder,
-                            $"{assemblyName.Name}.{extension}");
-
-                        if (IsAssemblyAlreadyLoaded(candidatePath) ||
-                            !FileSystems.Default.FileExists(candidatePath))
-                        {
-                            continue;
-                        }
-
-                        AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
-                        if (candidateAssemblyName.Version != assemblyName.Version)
-                        {
-                            continue;
-                        }
-
-                        return LoadAndCache(context, candidatePath);
+                        continue;
                     }
+
+                    AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
+                    if (candidateAssemblyName.Version != assemblyName.Version)
+                    {
+                        continue;
+                    }
+
+                    return LoadAndCache(context, candidatePath);
                 }
             }
 
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
new file mode 100644
index 00000000000..03736d2ad73
--- /dev/null
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -0,0 +1,99 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Utilities;
+using System;
+using System.Diagnostics;
+using System.IO;
+using System.Text.RegularExpressions;
+
+namespace Microsoft.Build.Shared.Debugging
+{
+    internal static class DebugUtils
+    {
+        private enum NodeMode
+        {
+            CentralNode,
+            OutOfProcNode,
+            OutOfProcTaskHostNode
+        }
+
+        static DebugUtils()
+        {
+            string environmentDebugPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            var debugDirectory = environmentDebugPath ?? Path.Combine(Directory.GetCurrentDirectory(), "MSBuild_Logs");
+
+            if (Traits.Instance.DebugEngine)
+            {
+                FileUtilities.EnsureDirectoryExists(debugDirectory);
+
+                // Out of proc nodes do not know the startup directory so set the environment variable for them.
+                if (string.IsNullOrWhiteSpace(environmentDebugPath))
+                {
+                    Environment.SetEnvironmentVariable("MSBUILDDEBUGPATH", debugDirectory);
+                }
+            }
+
+            DebugPath = debugDirectory;
+        }
+
+        private static readonly Lazy<NodeMode> ProcessNodeMode = new(
+        () =>
+        {
+            return ScanNodeMode(Environment.CommandLine);
+
+            NodeMode ScanNodeMode(string input)
+            {
+                var match = Regex.Match(input, @"/nodemode:(?<nodemode>[12\s])(\s|$)", RegexOptions.IgnoreCase);
+
+                if (!match.Success)
+                {
+                    return NodeMode.CentralNode;
+                }
+                var nodeMode = match.Groups["nodemode"].Value;
+
+                Trace.Assert(!string.IsNullOrEmpty(nodeMode));
+
+                return nodeMode switch
+                {
+                    "1" => NodeMode.OutOfProcNode,
+                    "2" => NodeMode.OutOfProcTaskHostNode,
+                    _ => throw new NotImplementedException(),
+                };
+            }
+        });
+
+        private static bool CurrentProcessMatchesDebugName()
+        {
+            var processNameToBreakInto = Environment.GetEnvironmentVariable("MSBuildDebugProcessName");
+            var thisProcessMatchesName = string.IsNullOrWhiteSpace(processNameToBreakInto) ||
+                                         Process.GetCurrentProcess().ProcessName.Contains(processNameToBreakInto);
+
+            return thisProcessMatchesName;
+        }
+
+        public static readonly string ProcessInfoString =
+            $"{ProcessNodeMode.Value}_{Process.GetCurrentProcess().ProcessName}_PID={Process.GetCurrentProcess().Id}_x{(Environment.Is64BitProcess ? "64" : "86")}";
+
+        public static readonly bool ShouldDebugCurrentProcess = CurrentProcessMatchesDebugName();
+
+        public static string DebugPath { get; }
+
+        public static string FindNextAvailableDebugFilePath(string fileName)
+        {
+            var extension = Path.GetExtension(fileName);
+            var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(fileName);
+
+            var fullPath = Path.Combine(DebugPath, fileName);
+
+            var counter = 0;
+            while (File.Exists(fullPath))
+            {
+                fileName = $"{fileNameWithoutExtension}_{counter++}{extension}";
+                fullPath = Path.Combine(DebugPath, fileName);
+            }
+
+            return fullPath;
+        }
+    }
+}
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index bfcdbfd57c4..28fe6c8587a 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -20,13 +20,6 @@ namespace Microsoft.Build.Shared.Debugging
     /// </summary>
     internal class PrintLineDebugger : IDisposable
     {
-        internal enum NodeMode
-        {
-            CentralNode,
-            OutOfProcNode,
-            OutOfProcTaskHostNode
-        }
-
         private static readonly Lazy<PropertyInfo> CommonWriterProperty = new Lazy<PropertyInfo>(
             () =>
             {
@@ -45,41 +38,10 @@ internal enum NodeMode
         public static Lazy<PrintLineDebugger> DefaultWithProcessInfo =
             new Lazy<PrintLineDebugger>(() => Create(null, null, true));
 
-        private static readonly Lazy<NodeMode> ProcessNodeMode = new Lazy<NodeMode>(
-            () =>
-            {
-                return ScanNodeMode(Environment.CommandLine);
-
-                NodeMode ScanNodeMode(string input)
-                {
-                    var match = Regex.Match(input, @"/nodemode:(?<nodemode>[12\s])(\s|$)", RegexOptions.IgnoreCase);
-
-                    if (!match.Success)
-                    {
-                        return NodeMode.CentralNode;
-                    }
-                    var nodeMode = match.Groups["nodemode"].Value;
-
-                    Trace.Assert(!string.IsNullOrEmpty(nodeMode));
-
-                    return nodeMode switch
-                    {
-                        "1" => NodeMode.OutOfProcNode,
-                        "2" => NodeMode.OutOfProcTaskHostNode,
-                        _ => throw new NotImplementedException(),
-                    };
-                }
-            });
-
         private readonly string _id;
 
         private readonly CommonWriterType _writerSetByThisInstance;
 
-        public static string ProcessInfo
-            =>
-                $"{ProcessNodeMode.Value}_PID={Process.GetCurrentProcess() .Id}({Process.GetCurrentProcess() .ProcessName})x{(Environment.Is64BitProcess ? "64" : "86")}"
-            ;
-
         public PrintLineDebugger(string id, CommonWriterType writer)
         {
             _id = id ?? string.Empty;
@@ -147,7 +109,7 @@ public static PrintLineDebugger Create(
         {
             return new PrintLineDebugger(
                 prependProcessInfo
-                    ? $"{ProcessInfo}_{id}"
+                    ? $"{DebugUtils.ProcessInfoString}_{id}"
                     : id,
                 writer);
         }
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 2731c90b61a..9bb3502596b 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -47,6 +47,14 @@ public static void DebugTraceMessage(string category, string formatstring, param
 #if !BUILDINGAPPXTASKS
         #region VerifyThrow -- for internal errors
 
+        internal static void VerifyThrowInternalError(bool condition, string message, params object[] args)
+        {
+            if (s_throwExceptions && !condition)
+            {
+                throw new InternalErrorException(ResourceUtilities.FormatString(message, args));
+            }
+        }
+
         /// <summary>
         /// Throws InternalErrorException. 
         /// This is only for situations that would mean that there is a bug in MSBuild itself.
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index ae0dac9bfe3..8ba3e225520 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -19,6 +19,10 @@ namespace Microsoft.Build.AppxPackage.Shared
 using Microsoft.Build.Shared.FileSystem;
 using System.Xml.Schema;
 using System.Runtime.Serialization;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Shared.Debugging;
+#endif
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Shared
 #endif
@@ -41,7 +45,16 @@ static ExceptionHandling()
         /// <returns></returns>
         private static string GetDebugDumpPath()
         {
-            string debugPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            string debugPath =
+// Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
+#if CLR2COMPATIBILITY || MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+                        Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+#else
+                ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
+                    ? DebugUtils.DebugPath
+                    : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+#endif
+
             return !string.IsNullOrEmpty(debugPath)
                     ? debugPath
                     : Path.GetTempPath();
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index ebc622953da..9af0619bab7 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -54,7 +54,7 @@ internal class FileMatcher
 
         private static class FileSpecRegexParts
         {
-            internal const string FixedDirGroupStart = "^(?<FIXEDDIR>";
+            internal const string BeginningOfLine = "^";
             internal const string WildcardGroupStart = "(?<WILDCARDDIR>";
             internal const string FilenameGroupStart = "(?<FILENAME>";
             internal const string GroupEnd = ")";
@@ -71,10 +71,10 @@ private static class FileSpecRegexParts
         }
 
         /*
-         * MAX_PATH + FileSpecRegexParts.BeginningOfLine.Length + FileSpecRegexParts.FixedDirWildcardDirSeparator.Length
-            + FileSpecRegexParts.WildcardDirFilenameSeparator.Length + FileSpecRegexParts.EndOfLine.Length;
+         * FileSpecRegexParts.BeginningOfLine.Length + FileSpecRegexParts.WildcardGroupStart.Length + FileSpecRegexParts.GroupEnd.Length
+            + FileSpecRegexParts.FilenameGroupStart.Length + FileSpecRegexParts.GroupEnd.Length + FileSpecRegexParts.EndOfLine.Length;
          */
-        private const int FileSpecRegexMinLength = 44;
+        private const int FileSpecRegexMinLength = 31;
 
         /// <summary>
         /// The Default FileMatcher does not cache directory enumeration.
@@ -501,7 +501,7 @@ GetFileSystemEntries getFileSystemEntries
                 else
                 {
                     // Relative
-                    pathRoot = String.Empty;
+                    pathRoot = string.Empty;
                     startingElement = 0;
                 }
             }
@@ -516,7 +516,7 @@ GetFileSystemEntries getFileSystemEntries
                 // If there is a zero-length part, then that means there was an extra slash.
                 if (parts[i].Length == 0)
                 {
-                    longParts[i - startingElement] = String.Empty;
+                    longParts[i - startingElement] = string.Empty;
                 }
                 else
                 {
@@ -556,7 +556,7 @@ GetFileSystemEntries getFileSystemEntries
                 }
             }
 
-            return pathRoot + String.Join(s_directorySeparator, longParts);
+            return pathRoot + string.Join(s_directorySeparator, longParts);
         }
 
         /// <summary>
@@ -630,8 +630,8 @@ out string filenamePart
                  * 
                  *     **
                  */
-                fixedDirectoryPart = String.Empty;
-                wildcardDirectoryPart = String.Empty;
+                fixedDirectoryPart = string.Empty;
+                wildcardDirectoryPart = string.Empty;
                 filenamePart = filespec;
                 return;
             }
@@ -661,7 +661,7 @@ out string filenamePart
 
                 // We know the fixed director part now.
                 fixedDirectoryPart = filespec.Substring(0, indexOfLastDirectorySeparator + 1);
-                wildcardDirectoryPart = String.Empty;
+                wildcardDirectoryPart = string.Empty;
                 filenamePart = filespec.Substring(indexOfLastDirectorySeparator + 1);
                 return;
             }
@@ -682,7 +682,7 @@ out string filenamePart
                  * 
                  *      dir?\**
                  */
-                fixedDirectoryPart = String.Empty;
+                fixedDirectoryPart = string.Empty;
                 wildcardDirectoryPart = filespec.Substring(0, indexOfLastDirectorySeparator + 1);
                 filenamePart = filespec.Substring(indexOfLastDirectorySeparator + 1);
                 return;
@@ -1207,10 +1207,10 @@ string filenamePart
         {
 #if DEBUG
             ErrorUtilities.VerifyThrow(
-                FileSpecRegexMinLength == FileSpecRegexParts.FixedDirGroupStart.Length
+                FileSpecRegexMinLength == FileSpecRegexParts.BeginningOfLine.Length
                 + FileSpecRegexParts.WildcardGroupStart.Length
                 + FileSpecRegexParts.FilenameGroupStart.Length
-                + (FileSpecRegexParts.GroupEnd.Length * 3)
+                + (FileSpecRegexParts.GroupEnd.Length * 2)
                 + FileSpecRegexParts.EndOfLine.Length,
                 "Checked-in length of known regex components differs from computed length. Update checked-in constant."
             );
@@ -1278,7 +1278,7 @@ private static bool HasMisplacedRecursiveOperator(string str)
         /// </summary>
         private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBuilder regex, string fixedDir)
         {
-            regex.Append(FileSpecRegexParts.FixedDirGroupStart);
+            regex.Append(FileSpecRegexParts.BeginningOfLine);
 
             bool isUncPath = NativeMethodsShared.IsWindows && fixedDir.Length > 1
                              && fixedDir[0] == '\\' && fixedDir[1] == '\\';
@@ -1292,8 +1292,6 @@ private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBui
             {
                 AppendRegularExpressionFromChar(regex, fixedDir[i]);
             }
-
-            regex.Append(FileSpecRegexParts.GroupEnd);
         }
 
         /// <summary>
@@ -1569,9 +1567,9 @@ internal void GetFileSpecInfo(
             FixupParts fixupParts = null)
         {
             needsRecursion = false;
-            fixedDirectoryPart = String.Empty;
-            wildcardDirectoryPart = String.Empty;
-            filenamePart = String.Empty;
+            fixedDirectoryPart = string.Empty;
+            wildcardDirectoryPart = string.Empty;
+            filenamePart = string.Empty;
 
             if (!RawFileSpecIsValid(filespec))
             {
@@ -1663,9 +1661,7 @@ internal Result()
             internal bool isLegalFileSpec; // initially false
             internal bool isMatch; // initially false
             internal bool isFileSpecRecursive; // initially false
-            internal string fixedDirectoryPart = String.Empty;
-            internal string wildcardDirectoryPart = String.Empty;
-            internal string filenamePart = String.Empty;
+            internal string wildcardDirectoryPart = string.Empty;
         }
 
         /// <summary>
@@ -1857,9 +1853,8 @@ out matchResult.isLegalFileSpec
                     fileToMatch,
                     regexFileMatch,
                     out matchResult.isMatch,
-                    out matchResult.fixedDirectoryPart,
                     out matchResult.wildcardDirectoryPart,
-                    out matchResult.filenamePart);
+                    out _);
             }
 
             return matchResult;
@@ -1869,20 +1864,17 @@ internal static void GetRegexMatchInfo(
             string fileToMatch,
             Regex fileSpecRegex,
             out bool isMatch,
-            out string fixedDirectoryPart,
             out string wildcardDirectoryPart,
             out string filenamePart)
         {
             Match match = fileSpecRegex.Match(fileToMatch);
 
             isMatch = match.Success;
-            fixedDirectoryPart = string.Empty;
-            wildcardDirectoryPart = String.Empty;
+            wildcardDirectoryPart = string.Empty;
             filenamePart = string.Empty;
 
             if (isMatch)
             {
-                fixedDirectoryPart = match.Groups["FIXEDDIR"].Value;
                 wildcardDirectoryPart = match.Groups["WILDCARDDIR"].Value;
                 filenamePart = match.Groups["FILENAME"].Value;
             }
@@ -2093,7 +2085,7 @@ out bool isLegalFileSpec
                         return SearchAction.ReturnEmptyList;
                     }
 
-                    stripProjectDirectory = !String.Equals(fixedDirectoryPart, oldFixedDirectoryPart, StringComparison.OrdinalIgnoreCase);
+                    stripProjectDirectory = !string.Equals(fixedDirectoryPart, oldFixedDirectoryPart, StringComparison.OrdinalIgnoreCase);
                 }
                 else
                 {
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 527c30d8105..afdbc7fefec 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -499,8 +499,8 @@ private static string FallbackDotNetFrameworkSdkInstallPath
 
                         if (EnvironmentUtilities.Is64BitProcess && s_fallbackDotNetFrameworkSdkInstallPath == null)
                         {
-                            // Since we're 64-bit, what we just checked was the 64-bit fallback key -- so now let's 
-                            // check the 32-bit one too, just in case. 
+                            // Since we're 64-bit, what we just checked was the 64-bit fallback key -- so now let's
+                            // check the 32-bit one too, just in case.
                             s_fallbackDotNetFrameworkSdkInstallPath =
                                 FindRegistryValueUnderKey(
                                     fallbackDotNetFrameworkSdkRegistryInstallPath,
@@ -770,7 +770,7 @@ DotNetFrameworkArchitecture architecture
                 return directoryExists(frameworkPath) ? frameworkPath : null;
             }
 
-            // If the COMPLUS variables are set, they override everything -- that's the directory we want.  
+            // If the COMPLUS variables are set, they override everything -- that's the directory we want.
             string complusInstallRoot = Environment.GetEnvironmentVariable("COMPLUS_INSTALLROOT");
             string complusVersion = Environment.GetEnvironmentVariable("COMPLUS_VERSION");
 
@@ -780,7 +780,7 @@ DotNetFrameworkArchitecture architecture
             }
 
             // If the current runtime starts with correct prefix, then this is the runtime we want to use.
-            // However, only if we're requesting current architecture -- otherwise, the base path may be different, so we'll need to look it up. 
+            // However, only if we're requesting current architecture -- otherwise, the base path may be different, so we'll need to look it up.
             string leaf = Path.GetFileName(currentRuntimePath);
             if (leaf.StartsWith(prefix, StringComparison.Ordinal) && architecture == DotNetFrameworkArchitecture.Current)
             {
@@ -796,19 +796,19 @@ DotNetFrameworkArchitecture architecture
 
             if (indexOfFramework64 != -1 && architecture == DotNetFrameworkArchitecture.Bitness32)
             {
-                // need to get rid of just the 64, but want to look up 'Framework64' rather than '64' to avoid the case where 
-                // the path is something like 'C:\MyPath\64\Framework64'.  9 = length of 'Framework', to make the index match 
-                // the location of the '64'. 
+                // need to get rid of just the 64, but want to look up 'Framework64' rather than '64' to avoid the case where
+                // the path is something like 'C:\MyPath\64\Framework64'.  9 = length of 'Framework', to make the index match
+                // the location of the '64'.
                 int indexOf64 = indexOfFramework64 + 9;
                 string tempLocation = baseLocation;
                 baseLocation = tempLocation.Substring(0, indexOf64) + tempLocation.Substring(indexOf64 + 2, tempLocation.Length - indexOf64 - 2);
             }
             else if (indexOfFramework64 == -1 && architecture == DotNetFrameworkArchitecture.Bitness64)
             {
-                // need to add 64 -- since this is a heuristic, we assume that we just need to append.  
+                // need to add 64 -- since this is a heuristic, we assume that we just need to append.
                 baseLocation += "64";
             }
-            // we don't need to do anything if it's DotNetFrameworkArchitecture.Current.  
+            // we don't need to do anything if it's DotNetFrameworkArchitecture.Current.
 
             string[] directories;
 
@@ -818,7 +818,7 @@ DotNetFrameworkArchitecture architecture
             }
             else
             {
-                // If we can't even find the base path, might as well give up now. 
+                // If we can't even find the base path, might as well give up now.
                 return null;
             }
 
@@ -832,7 +832,7 @@ DotNetFrameworkArchitecture architecture
             // The intention here is to choose the alphabetical maximum.
             string max = directories[0];
 
-            // the max.EndsWith condition: pre beta 2 versions of v3.5 have build number like v3.5.20111.  
+            // the max.EndsWith condition: pre beta 2 versions of v3.5 have build number like v3.5.20111.
             // This was removed in beta2
             // We should favor \v3.5 over \v3.5.xxxxx
             // versions previous to 2.0 have .xxxx version numbers.  3.0 and 3.5 do not.
@@ -893,15 +893,15 @@ internal static string GenerateProgramFiles64()
             string programFilesX64;
             if (string.Equals(programFiles, programFiles32))
             {
-                // either we're in a 32-bit window, or we're on a 32-bit machine.  
+                // either we're in a 32-bit window, or we're on a 32-bit machine.
                 // if we're on a 32-bit machine, ProgramW6432 won't exist
-                // if we're on a 64-bit machine, ProgramW6432 will point to the correct Program Files. 
+                // if we're on a 64-bit machine, ProgramW6432 will point to the correct Program Files.
                 programFilesX64 = Environment.GetEnvironmentVariable("ProgramW6432");
             }
             else
             {
-                // 64-bit window on a 64-bit machine; %ProgramFiles% points to the 64-bit 
-                // Program Files already. 
+                // 64-bit window on a 64-bit machine; %ProgramFiles% points to the 64-bit
+                // Program Files already.
                 programFilesX64 = programFiles;
             }
 
@@ -1160,8 +1160,8 @@ private static void RedirectVersionsIfNecessary(ref Version dotNetFrameworkVersi
 
             if (dotNetFrameworkVersion == dotNetFrameworkVersion35 && visualStudioVersion > visualStudioVersion110)
             {
-                // Fall back to Dev11 location -- 3.5 tools MSI was reshipped unchanged, so there 
-                // essentially are no 12-specific 3.5 tools. 
+                // Fall back to Dev11 location -- 3.5 tools MSI was reshipped unchanged, so there
+                // essentially are no 12-specific 3.5 tools.
                 visualStudioVersion = visualStudioVersion110;
                 return;
             }
@@ -1367,8 +1367,8 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                 }
 
 #if FEATURE_WIN32_REGISTRY
-                // Otherwise, check to see if we're even installed.  If not, return null -- no point in setting the static 
-                // variables to null when that's what they are already.  
+                // Otherwise, check to see if we're even installed.  If not, return null -- no point in setting the static
+                // variables to null when that's what they are already.
                 if (NativeMethodsShared.IsWindows && !CheckForFrameworkInstallation(
                     this._dotNetFrameworkRegistryKey,
                     this._dotNetFrameworkSetupRegistryInstalledName
@@ -1441,7 +1441,7 @@ public virtual string GetPathToDotNetFrameworkSdkTools(VisualStudioSpec visualSt
 
                     // For the Dev10 SDK, we check the registry that corresponds to the current process' bitness, rather than
                     // always the 32-bit one the way we do for Dev11 and onward, since that's what we did in Dev10 as well.
-                    // As of Dev11, the SDK reg keys are installed in the 32-bit registry. 
+                    // As of Dev11, the SDK reg keys are installed in the 32-bit registry.
                     RegistryView registryView = visualStudioSpec.Version == visualStudioVersion100 ? RegistryView.Default : RegistryView.Registry32;
 
                     generatedPathToDotNetFrameworkSdkTools = FindRegistryValueUnderKey(
@@ -1556,7 +1556,7 @@ public virtual string GetPathToWindowsSdk()
 
                     string registryPath = string.Join(@"\", MicrosoftSDKsRegistryKey, "Windows", visualStudioSpec.WindowsSdkRegistryKey);
 
-                    // As of Dev11, the SDK reg keys are installed in the 32-bit registry. 
+                    // As of Dev11, the SDK reg keys are installed in the 32-bit registry.
                     this._pathToWindowsSdk = FindRegistryValueUnderKey(
                         registryPath,
                         visualStudioSpec.WindowsSdkRegistryInstallationFolderName,
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 97ea429de96..c3360d19224 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -62,7 +62,7 @@ internal enum TranslationDirection
     ///    that by ensuring a single Translate method on a given object can handle both reads and
     ///    writes without referencing any field more than once.
     /// </remarks>
-    internal interface ITranslator
+    internal interface ITranslator : IDisposable
     {
         /// <summary>
         /// Returns the current serialization mode.
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 40589a0becb..389450a2242 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -5,6 +5,11 @@
 using System.Text;
 using System.IO;
 using System.Diagnostics;
+using System.Threading;
+
+#if !CLR2COMPATIBILITY
+using System.Buffers;
+#endif
 
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 
@@ -26,11 +31,23 @@ internal class InterningBinaryReader : BinaryReader
         private const int MaxCharsBuffer = 20000;
 #endif
 
+        /// <summary>
+        /// A cache of recently used buffers. This is a pool of size 1 to avoid allocating moderately sized
+        /// <see cref="Buffer"/> objects repeatedly. Used in scenarios that don't have a good context to attach
+        /// a shared buffer to.
+        /// </summary>
+        private static Buffer s_bufferPool;
+
         /// <summary>
         /// Shared buffer saves allocating these arrays many times.
         /// </summary>
         private Buffer _buffer;
 
+        /// <summary>
+        /// True if <see cref="_buffer"/> is owned by this instance, false if it was passed by the caller.
+        /// </summary>
+        private bool _isPrivateBuffer;
+
         /// <summary>
         /// The decoder used to translate from UTF8 (or whatever).
         /// </summary>
@@ -39,7 +56,7 @@ internal class InterningBinaryReader : BinaryReader
         /// <summary>
         /// Comment about constructing.
         /// </summary>
-        private InterningBinaryReader(Stream input, Buffer buffer)
+        private InterningBinaryReader(Stream input, Buffer buffer, bool isPrivateBuffer)
             : base(input, Encoding.UTF8)
         {
             if (input == null)
@@ -48,6 +65,7 @@ private InterningBinaryReader(Stream input, Buffer buffer)
             }
 
             _buffer = buffer;
+            _isPrivateBuffer = isPrivateBuffer;
             _decoder = Encoding.UTF8.GetDecoder();
         }
 
@@ -57,6 +75,7 @@ private InterningBinaryReader(Stream input, Buffer buffer)
         /// </summary>
         override public String ReadString()
         {
+            char[] resultBuffer = null;
             try
             {
                 MemoryStream memoryStream = this.BaseStream as MemoryStream;
@@ -80,7 +99,6 @@ override public String ReadString()
                 }
 
                 char[] charBuffer = _buffer.CharBuffer;
-                char[] resultBuffer = null;
                 do
                 {
                     readLength = ((stringLength - currPos) > MaxCharsBuffer) ? MaxCharsBuffer : (stringLength - currPos);
@@ -132,31 +150,82 @@ override public String ReadString()
                         charsRead = _decoder.GetChars(rawBuffer, rawPosition, n, charBuffer, 0);
                         return Strings.WeakIntern(charBuffer.AsSpan(0, charsRead));
                     }
-
+#if !CLR2COMPATIBILITY
+                    resultBuffer ??= ArrayPool<char>.Shared.Rent(stringLength); // Actual string length in chars may be smaller.
+#else
+                    // Since NET35 is only used in rare TaskHost processes, we decided to leave it as-is.
                     resultBuffer ??= new char[stringLength]; // Actual string length in chars may be smaller.
+#endif
                     charsRead += _decoder.GetChars(rawBuffer, rawPosition, n, resultBuffer, charsRead);
 
                     currPos += n;
                 }
                 while (currPos < stringLength);
 
-                return Strings.WeakIntern(resultBuffer.AsSpan(0, charsRead));
+                var retval = Strings.WeakIntern(resultBuffer.AsSpan(0, charsRead));
+
+                return retval;
             }
             catch (Exception e)
             {
                 Debug.Assert(false, e.ToString());
                 throw;
             }
+#if !CLR2COMPATIBILITY
+            finally
+            {
+                // resultBuffer shall always be either Rented or null
+                if (resultBuffer != null)
+                {
+                    ArrayPool<char>.Shared.Return(resultBuffer);
+                }
+            }
+#endif
         }
 
         /// <summary>
         /// A shared buffer to avoid extra allocations in InterningBinaryReader.
         /// </summary>
+        /// <remarks>
+        /// The caller is responsible for managing the lifetime of the returned buffer and for passing it to <see cref="Create"/>.
+        /// </remarks>
         internal static SharedReadBuffer CreateSharedBuffer()
         {
             return new Buffer();
         }
 
+        /// <summary>
+        /// Gets a buffer from the pool or creates a new one.
+        /// </summary>
+        /// <returns>The <see cref="Buffer"/>. Should be returned to the pool after we're done with it.</returns>
+        private static Buffer GetPooledBuffer()
+        {
+            Buffer buffer = Interlocked.Exchange(ref s_bufferPool, null);
+            if (buffer != null)
+            {
+                return buffer;
+            }
+            return new Buffer();
+        }
+
+#region IDisposable pattern
+
+        /// <summary>
+        /// Returns our buffer to the pool if we were not passed one by the caller.
+        /// </summary>
+        protected override void Dispose(bool disposing)
+        {
+            if (_isPrivateBuffer)
+            {
+                // If we created this buffer then try to return it to the pool. If s_bufferPool is non-null we leave it alone,
+                // the idea being that it's more likely to have lived longer than our buffer.
+                Interlocked.CompareExchange(ref s_bufferPool, _buffer, null);
+            }
+            base.Dispose(disposing);
+        }
+
+#endregion
+
         /// <summary>
         /// Create a BinaryReader. It will either be an interning reader or standard binary reader
         /// depending on whether the interning reader is possible given the buffer and stream.
@@ -164,13 +233,11 @@ internal static SharedReadBuffer CreateSharedBuffer()
         internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer)
         {
             Buffer buffer = (Buffer)sharedBuffer;
-
-            if (buffer == null)
+            if (buffer != null)
             {
-                buffer = new Buffer();
+                return new InterningBinaryReader(stream, buffer, false);
             }
-
-            return new InterningBinaryReader(stream, buffer);
+            return new InterningBinaryReader(stream, GetPooledBuffer(), true);
         }
 
         /// <summary>
@@ -178,13 +245,14 @@ internal static BinaryReader Create(Stream stream, SharedReadBuffer sharedBuffer
         /// </summary>
         private class Buffer : SharedReadBuffer
         {
+            private char[] _charBuffer;
+            private byte[] _byteBuffer;
+
             /// <summary>
             /// Yes, we are constructing.
             /// </summary>
             internal Buffer()
             {
-                this.CharBuffer = new char[MaxCharsBuffer];
-                this.ByteBuffer = new byte[Encoding.UTF8.GetMaxByteCount(MaxCharsBuffer)];
             }
 
             /// <summary>
@@ -192,8 +260,11 @@ internal Buffer()
             /// </summary>
             internal char[] CharBuffer
             {
-                get;
-                private set;
+                get
+                {
+                    _charBuffer ??= new char[MaxCharsBuffer];
+                    return _charBuffer;
+                }
             }
 
             /// <summary>
@@ -201,8 +272,11 @@ internal char[] CharBuffer
             /// </summary>
             internal byte[] ByteBuffer
             {
-                get;
-                private set;
+                get
+                {
+                    _byteBuffer ??= new byte[Encoding.UTF8.GetMaxByteCount(MaxCharsBuffer)];
+                    return _byteBuffer;
+                }
             }
         }
     }
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index f080c2e05a9..1de3e06bced 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -29,9 +29,6 @@ internal class MSBuildLoadContext : AssemblyLoadContext
                 "Microsoft.Build.Utilities.Core",
             }.ToImmutableHashSet();
 
-        internal static readonly string[] Extensions = new[] { "ni.dll", "ni.exe", "dll", "exe" };
-
-
         public MSBuildLoadContext(string assemblyPath)
             : base($"MSBuild plugin {assemblyPath}")
         {
@@ -56,11 +53,9 @@ public MSBuildLoadContext(string assemblyPath)
                 // bare search directory if that fails.
                 : new[] { assemblyName.CultureName, string.Empty })
             {
-                foreach (var extension in Extensions)
-                {
                     var candidatePath = Path.Combine(_directory,
                         cultureSubfolder,
-                        $"{assemblyName.Name}.{extension}");
+                        $"{assemblyName.Name}.dll");
 
                     if (!FileSystems.Default.FileExists(candidatePath))
                     {
@@ -74,7 +69,6 @@ public MSBuildLoadContext(string assemblyPath)
                     }
 
                     return LoadFromAssemblyPath(candidatePath);
-                }
             }
 
             // If the Assembly is provided via a file path, the following rules are used to load the assembly:
@@ -83,7 +77,7 @@ public MSBuildLoadContext(string assemblyPath)
             //   into the default ALC (so it's shared with other uses).
 
             var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
-                assemblyName.Name!);
+                $"{assemblyName.Name}.dll");
 
             if (FileSystems.Default.FileExists(assemblyNameInExecutableDirectory))
             {
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 42e8a3ead07..09314174d36 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -514,9 +514,6 @@ public static int GetLogicalCoreCount()
             //     https://github.com/dotnet/runtime/issues/29686
             // so always double-check it.
             if (IsWindows
-#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-                && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_8)
-#endif
 #if NETFRAMEWORK
                 // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
                 // So if we get a high core count on full framework, double-check it.
@@ -635,6 +632,9 @@ internal static bool IsMaxPathLegacyWindows()
             }
         }
 
+        // CA1416 warns about code that can only run on Windows, but we verified we're running on Windows before this.
+        // This is the most reasonable way to resolve this part because other ways would require ifdef'ing on NET472.
+#pragma warning disable CA1416
         private static bool IsLongPathsEnabledRegistry()
         {
             using (RegistryKey fileSystemKey = Registry.LocalMachine.OpenSubKey(WINDOWS_FILE_SYSTEM_REGISTRY_KEY))
@@ -643,6 +643,7 @@ private static bool IsLongPathsEnabledRegistry()
                 return fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == 1;
             }
         }
+#pragma warning restore CA1416
 
         /// <summary>
         /// Cached value for IsUnixLike (this method is called frequently during evaluation).
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 99f43c83280..3d468e23e95 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -43,11 +43,6 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// </summary>
         private const int PipeBufferSize = 131072;
 
-        /// <summary>
-        /// Flag indicating if we should debug communications or not.
-        /// </summary>
-        private bool _debugCommunications = false;
-
         /// <summary>
         /// The current communication status of the node.
         /// </summary>
@@ -193,8 +188,6 @@ internal void InternalConstruct(string pipeName)
         {
             ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
 
-            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
-
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
             _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 95694a52226..28e73b49c1a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -122,7 +122,7 @@
       </trans-unit>
       <trans-unit id="TaskNotMarshalByRef">
         <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="translated">MSB4077: Die Aufgabe "{0}" wurde mit dem LoadInSeparateAppDomain-Attribut markiert, ist jedoch nicht von MarshalByRefObject abgeleitet. Vergewissern Sie sich, dass die Aufgabe von MarshalByRefObject oder AppDomainIsolatedTask abgeleitet wird.</target>
+        <target state="translated">MSB4077: Die Aufgabe "{0}" wurde mit dem LoadInSeparateAppDomain-Attribut markiert, ist jedoch nicht von MarshalByRefObject abgeleitet. Stellen Sie sicher, dass die Aufgabe von MarshalByRefObject oder AppDomainIsolatedTask abgeleitet wird.</target>
         <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
       </trans-unit>
       <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 4c2fef8096e..332d51f7961 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -122,7 +122,7 @@
       </trans-unit>
       <trans-unit id="TaskNotMarshalByRef">
         <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="translated">MSB4077: La tarea "{0}" se marc√≥ con el atributo LoadInSeparateAppDomain, pero no deriva de MarshalByRefObject. Aseg√∫rese de que la tarea deriva de MarshalByRefObject o de AppDomainIsolatedTask.</target>
+        <target state="translated">MSB4077: La tarea "{0}" se marc√≥ con el atributo LoadInSeparateAppDomain, pero esta no deriva de MarshalByRefObject. Aseg√∫rese de que la tarea deriva de MarshalByRefObject o de AppDomainIsolatedTask.</target>
         <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
       </trans-unit>
       <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 62416e6a96a..98d0ecd2344 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -122,7 +122,7 @@
       </trans-unit>
       <trans-unit id="TaskNotMarshalByRef">
         <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="translated">MSB4077: La t√¢che "{0}" a √©t√© marqu√©e avec l'attribut LoadInSeparateAppDomain, mais elle ne d√©rive pas de MarshalByRefObject. V√©rifiez que la t√¢che d√©rive de MarshalByRefObject ou de AppDomainIsolatedTask.</target>
+        <target state="translated">MSB4077: la t√¢che "{0}" a √©t√© marqu√©e avec l'attribut LoadInSeparateAppDomain, mais ne d√©rive pas de MarshalByRefObject. V√©rifiez que la t√¢che d√©rive de MarshalByRefObject ou de AppDomainIsolatedTask.</target>
         <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
       </trans-unit>
       <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index dc190421451..7cd5d631a66 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -122,7 +122,7 @@
       </trans-unit>
       <trans-unit id="TaskNotMarshalByRef">
         <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="translated">MSB4077: "{0}" ÏûëÏóÖÏù¥ LoadInSeparateAppDomain ÌäπÏÑ±ÏúºÎ°ú ÌëúÏãúÎêòÏóàÏßÄÎßå MarshalByRefObjectÏóêÏÑú ÌååÏÉùÎêòÏßÄ ÏïäÏäµÎãàÎã§. Ìï¥Îãπ ÏûëÏóÖÏù¥ MarshalByRefObject ÎòêÎäî AppDomainIsolatedTaskÏóêÏÑú ÌååÏÉùÎêòÎäîÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî.</target>
+        <target state="translated">MSB4077: "{0}" ÏûëÏóÖÏù¥ LoadInSeparateAppDomain ÌäπÏÑ±ÏúºÎ°ú ÌëúÏãúÎêòÏóàÏßÄÎßå MarshalByRefObjectÏóêÏÑú ÌååÏÉùÎêòÏßÄ ÏïäÏäµÎãàÎã§. Ìï¥Îãπ ÏûëÏóÖÏù¥ MarshalByRefObject ÎòêÎäî AppDomainIsolatedTaskÏóêÏÑú ÌååÏÉùÎêòÎäîÏßÄ ÌôïÏù∏ÌïòÏã≠ÏãúÏò§.</target>
         <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
       </trans-unit>
       <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index acf02be88fd..6fd1b77903b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -52,7 +52,7 @@
       </trans-unit>
       <trans-unit id="InvalidVerbosity">
         <source>MSB4103: "{0}" is not a valid logger verbosity level.</source>
-        <target state="translated">MSB4103: "{0}" n√£o √© um n√≠vel v√°lido de detalhamento de agente.</target>
+        <target state="translated">MSB4103: "{0}" n√£o √© um n√≠vel de detalhamento de agente de log v√°lido.</target>
         <note>{StrBegin="MSB4103: "}</note>
       </trans-unit>
       <trans-unit id="MissingProject">
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 73f58bb94c7..d6831788b90 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -122,7 +122,7 @@
       </trans-unit>
       <trans-unit id="TaskNotMarshalByRef">
         <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="translated">MSB4077: "{0}" g√∂revi LoadInSeparateAppDomain √∂zniteliƒüiyle i≈üaretlenmi≈ü, ancak MarshalByRefObject √∂ƒüesinden t√ºretilmiyor. G√∂revin MarshalByRefObject veya AppDomainIsolatedTask √∂ƒüesinden t√ºretilip t√ºretilmediƒüini denetleyin.</target>
+        <target state="translated">MSB4077: "{0}" g√∂revi LoadInSeparateAppDomain √∂zniteliƒüiyle i≈üaretlenmi≈ü, ancak MarshalByRefObject √∂ƒüesinden t√ºretilmiyor. G√∂revin MarshalByRefObject veya AppDomainIsolatedTask √∂ƒüesinden t√ºretildiƒüini denetleyin.</target>
         <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
       </trans-unit>
       <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 248af5346b3..b5468e75bcb 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.shared.resx">
     <body>
@@ -122,7 +122,7 @@
       </trans-unit>
       <trans-unit id="TaskNotMarshalByRef">
         <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="translated">MSB4077: ‚Äú{0}‚Äù‰ªªÂä°Â∑≤Ê†áËÆ∞‰∏∫ LoadInSeparateAppDomain ÁâπÊÄßÔºå‰ΩÜÂπ∂ÈùûÊ¥æÁîüËá™ MarshalByRefObject„ÄÇËØ∑Ê£ÄÊü•ËØ•‰ªªÂä°ÊòØÊ¥æÁîüËá™ MarshalByRefObject ËøòÊòØ AppDomainIsolatedTask„ÄÇ</target>
+        <target state="translated">MSB4077: ‚Äú{0}‚Äù‰ªªÂä°Â∑≤Ê†áËÆ∞‰∏∫ LoadInSeparateAppDomain ÁâπÊÄßÔºå‰ΩÜÊú™Ê¥æÁîüËá™ MarshalByRefObject„ÄÇËØ∑Ê£ÄÊü•ËØ•‰ªªÂä°ÊòØÊ¥æÁîüËá™ MarshalByRefObject ËøòÊòØ AppDomainIsolatedTask„ÄÇ</target>
         <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
       </trans-unit>
       <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index dccd588bfc1..893e286184a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.shared.resx">
     <body>
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 9d9fdc1c1b4..66a202fd6b8 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -156,9 +156,9 @@ protected IBuildEngine BuildEngine
         /// </summary>
         public bool HasLoggedErrors { get; private set; }
 
-#endregion
+        #endregion
 
-#region Utility methods
+        #region Utility methods
 
         /// <summary>
         /// Extracts the message code (if any) prefixed to the given message string. Message code prefixes must match the
@@ -235,9 +235,20 @@ public virtual string GetResourceMessage(string resourceName)
             string resourceString = FormatResourceString(resourceName, null);
             return resourceString;
         }
-#endregion
+        #endregion
+
+        #region Message logging methods
 
-#region Message logging methods
+        /// <summary>
+        /// Returns true if a message of given importance should be logged because it is possible that a logger consuming it exists.
+        /// </summary>
+        /// <param name="importance">The importance to check.</param>
+        /// <returns>True if messages of the given importance should be logged, false if it's guaranteed that such messages would be ignored.</returns>
+        public bool LogsMessagesOfImportance(MessageImportance importance)
+        {
+            return BuildEngine is not IBuildEngine10 buildEngine10
+                || buildEngine10.EngineServices.LogsMessagesOfImportance(importance);
+        }
 
         /// <summary>
         /// Logs a message using the specified string.
@@ -279,6 +290,10 @@ public void LogMessage(MessageImportance importance, string message, params obje
                 ResourceUtilities.FormatString(message, messageArgs);
             }
 #endif
+            if (!LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
 
             BuildMessageEventArgs e = new BuildMessageEventArgs
                 (
@@ -343,6 +358,11 @@ params object[] messageArgs
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
             ErrorUtilities.VerifyThrowArgumentNull(message, nameof(message));
 
+            if (!LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
+
             // If BuildEngine is null, task attempted to log before it was set on it,
             // presumably in its constructor. This is not allowed, and all
             // we can do is throw.
@@ -470,6 +490,11 @@ public void LogMessageFromResources(MessageImportance importance, string message
             // global state.
             ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, nameof(messageResourceName));
 
+            if (!LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
+
             LogMessage(importance, GetResourceMessage(messageResourceName), messageArgs);
 #if DEBUG
             // Assert that the message does not contain an error code.  Only errors and warnings
@@ -552,6 +577,11 @@ public void LogCommandLine(MessageImportance importance, string commandLine)
             // No lock needed, as BuildEngine methods from v4.5 onwards are thread safe.
             ErrorUtilities.VerifyThrowArgumentNull(commandLine, nameof(commandLine));
 
+            if (!LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
+
             var e = new TaskCommandLineEventArgs(commandLine, TaskName, importance);
 
             // If BuildEngine is null, the task attempted to log before it was set on it,
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index feb3acb6a5c..ff7d9685aa7 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -19,7 +19,7 @@ internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Conf
         {
             ToolsetConfigurationSection configurationSection = null;
 
-            // This will be null if the application config file does not have the following section 
+            // This will be null if the application config file does not have the following section
             // definition for the msbuildToolsets section as the first child element.
             //   <configSections>
             //     <section name=""msbuildToolsets"" type=""Microsoft.Build.Evaluation.ToolsetConfigurationSection, Microsoft.Build"" />
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 09cca604107..39fe9f7abb0 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -27,11 +27,14 @@ public static Traits Instance
         public Traits()
         {
             EscapeHatches = new EscapeHatches();
+
+            DebugScheduler = DebugEngine || !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDEBUGSCHEDULER"));
+            DebugNodeCommunication = DebugEngine || !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM"));
         }
 
         public EscapeHatches EscapeHatches { get; }
 
-        internal readonly string MSBuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION"); 
+        internal readonly string MSBuildDisableFeaturesFromVersion = Environment.GetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION");
 
         /// <summary>
         /// Do not expand wildcards that match a certain pattern
@@ -86,6 +89,10 @@ public Traits()
         /// </summary>
         public readonly int LogPropertyTracking = ParseIntFromEnvironmentVariableOrDefault("MsBuildLogPropertyTracking", 0); // Default to logging nothing via the property tracker.
 
+        public readonly bool DebugEngine = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildDebugEngine"));
+        public readonly bool DebugScheduler;
+        public readonly bool DebugNodeCommunication;
+
         private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVariable, int defaultValue)
         {
             return int.TryParse(Environment.GetEnvironmentVariable(environmentVariable), out int result)
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index b39f82091be..d8cf2eeed4c 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -74,7 +74,7 @@ public void GetFilesComplexGlobbingMatching(GetFilesComplexGlobbingMatchingInfo
             foreach (string fullPath in GetFilesComplexGlobbingMatchingInfo.FilesToCreate.Select(i => Path.Combine(testFolder.Path, i.ToPlatformSlash())))
             {
                 Directory.CreateDirectory(Path.GetDirectoryName(fullPath));
-                
+
                 File.WriteAllBytes(fullPath, new byte[1]);
             }
 
@@ -293,7 +293,7 @@ public static IEnumerable<object[]> GetTestData()
                         ExpectNoMatches = NativeMethodsShared.IsLinux,
                     }
                 };
-                
+
 #if !MONO // https://github.com/mono/mono/issues/8441
                 yield return new object[]
                 {
@@ -1653,7 +1653,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             "",
             "",
             "",
-            "^(?<FIXEDDIR>)(?<WILDCARDDIR>)(?<FILENAME>)$",
+            "^(?<WILDCARDDIR>)(?<FILENAME>)$",
             false,
             true
         )]
@@ -1723,7 +1723,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             "",
             @"*fo?ba?\",
             "*fo?ba?",
-            @"^(?<FIXEDDIR>)(?<WILDCARDDIR>[^/\\]*fo.ba.[/\\]+)(?<FILENAME>[^/\\]*fo.ba.)$",
+            @"^(?<WILDCARDDIR>[^/\\]*fo.ba.[/\\]+)(?<FILENAME>[^/\\]*fo.ba.)$",
             true,
             true
         )]
@@ -1733,7 +1733,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             "",
             "",
             "?oo*.",
-            @"^(?<FIXEDDIR>)(?<WILDCARDDIR>)(?<FILENAME>[^\.].oo[^\.]*)$",
+            @"^(?<WILDCARDDIR>)(?<FILENAME>[^\.].oo[^\.]*)$",
             false,
             true
         )]
@@ -1743,7 +1743,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             "",
             "",
             "*.*foo*.*",
-            @"^(?<FIXEDDIR>)(?<WILDCARDDIR>)(?<FILENAME>[^/\\]*foo[^/\\]*)$",
+            @"^(?<WILDCARDDIR>)(?<FILENAME>[^/\\]*foo[^/\\]*)$",
             false,
             true
         )]
@@ -1753,7 +1753,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             @"\foo///bar\\\",
             @"?foo///bar\\\",
             "foo",
-            @"^(?<FIXEDDIR>[/\\]+foo[/\\]+bar[/\\]+)(?<WILDCARDDIR>.foo[/\\]+bar[/\\]+)(?<FILENAME>foo)$",
+            @"^[/\\]+foo[/\\]+bar[/\\]+(?<WILDCARDDIR>.foo[/\\]+bar[/\\]+)(?<FILENAME>foo)$",
             true,
             true
         )]
@@ -1763,7 +1763,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             @"\./.\foo/.\./bar\./.\",
             @"?foo/.\./bar\./.\",
             "foo",
-            @"^(?<FIXEDDIR>[/\\]+foo[/\\]+bar[/\\]+)(?<WILDCARDDIR>.foo[/\\]+bar[/\\]+)(?<FILENAME>foo)$",
+            @"^[/\\]+foo[/\\]+bar[/\\]+(?<WILDCARDDIR>.foo[/\\]+bar[/\\]+)(?<FILENAME>foo)$",
             true,
             true
         )]
@@ -1773,7 +1773,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             @"foo\",
             @"**/**\bar/**\**/foo\**/**\",
             "bar",
-            @"^(?<FIXEDDIR>foo[/\\]+)(?<WILDCARDDIR>((.*/)|(.*\\)|())bar((/)|(\\)|(/.*/)|(/.*\\)|(\\.*\\)|(\\.*/))foo((/)|(\\)|(/.*/)|(/.*\\)|(\\.*\\)|(\\.*/)))(?<FILENAME>bar)$",
+            @"^foo[/\\]+(?<WILDCARDDIR>((.*/)|(.*\\)|())bar((/)|(\\)|(/.*/)|(/.*\\)|(\\.*\\)|(\\.*/))foo((/)|(\\)|(/.*/)|(/.*\\)|(\\.*\\)|(\\.*/)))(?<FILENAME>bar)$",
             true,
             true
         )]
@@ -1783,7 +1783,7 @@ public void ExcludeComplexPattern(string include, string[] exclude, string[] mat
             @"foo\\\.///",
             @"**\\\.///**\\\.///bar\\\.///**\\\.///**\\\.///foo\\\.///**\\\.///**\\\.///",
             "bar",
-            @"^(?<FIXEDDIR>foo[/\\]+)(?<WILDCARDDIR>((.*/)|(.*\\)|())bar((/)|(\\)|(/.*/)|(/.*\\)|(\\.*\\)|(\\.*/))foo((/)|(\\)|(/.*/)|(/.*\\)|(\\.*\\)|(\\.*/)))(?<FILENAME>bar)$",
+            @"^foo[/\\]+(?<WILDCARDDIR>((.*/)|(.*\\)|())bar((/)|(\\)|(/.*/)|(/.*\\)|(\\.*\\)|(\\.*/))foo((/)|(\\)|(/.*/)|(/.*\\)|(\\.*\\)|(\\.*/)))(?<FILENAME>bar)$",
             true,
             true
         )]
@@ -1821,7 +1821,7 @@ bool expectedIsLegalFileSpec
             @"$()+.[^{\",
             @"?$()+.[^{\",
             "$()+.[^{",
-            @"^(?<FIXEDDIR>\$\(\)\+\.\[\^\{[/\\]+)(?<WILDCARDDIR>.\$\(\)\+\.\[\^\{[/\\]+)(?<FILENAME>\$\(\)\+\.\[\^\{)$",
+            @"^\$\(\)\+\.\[\^\{[/\\]+(?<WILDCARDDIR>.\$\(\)\+\.\[\^\{[/\\]+)(?<FILENAME>\$\(\)\+\.\[\^\{)$",
             true,
             true
         )]
@@ -1831,7 +1831,7 @@ bool expectedIsLegalFileSpec
             @"\\\.\foo/",
             "",
             "bar",
-            @"^(?<FIXEDDIR>\\\\foo[/\\]+)(?<WILDCARDDIR>)(?<FILENAME>bar)$",
+            @"^\\\\foo[/\\]+(?<WILDCARDDIR>)(?<FILENAME>bar)$",
             false,
             true
         )]
@@ -1864,7 +1864,7 @@ bool expectedIsLegalFileSpec
             @"$()+.[^{|/",
             @"?$()+.[^{|/",
             "$()+.[^{|",
-            @"^(?<FIXEDDIR>\$\(\)\+\.\[\^\{\|[/\\]+)(?<WILDCARDDIR>.\$\(\)\+\.\[\^\{\|[/\\]+)(?<FILENAME>\$\(\)\+\.\[\^\{\|)$",
+            @"^\$\(\)\+\.\[\^\{\|[/\\]+(?<WILDCARDDIR>.\$\(\)\+\.\[\^\{\|[/\\]+)(?<FILENAME>\$\(\)\+\.\[\^\{\|)$",
             true,
             true
         )]
@@ -1874,7 +1874,7 @@ bool expectedIsLegalFileSpec
             @"///./foo/",
             "",
             "bar",
-            @"^(?<FIXEDDIR>[/\\]+foo[/\\]+)(?<WILDCARDDIR>)(?<FILENAME>bar)$",
+            @"^[/\\]+foo[/\\]+(?<WILDCARDDIR>)(?<FILENAME>bar)$",
             false,
             true
         )]
@@ -2112,8 +2112,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                             int nextSlash = normalizedCandidate.IndexOfAny(FileMatcher.directorySeparatorCharacters, path.Length + 1);
                             if (nextSlash != -1)
                             {
-                                
-                                //UNC paths start with a \\ fragment. Match against \\ when path is empty (i.e., inside the current working directory)
+                                // UNC paths start with a \\ fragment. Match against \\ when path is empty (i.e., inside the current working directory)
                                 string match = normalizedCandidate.StartsWith(@"\\") && string.IsNullOrEmpty(path)
                                     ? @"\\"
                                     : normalizedCandidate.Substring(0, nextSlash);
@@ -2129,7 +2128,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                                     directories.Add(FileMatcher.Normalize(match));
                                 }
                                 else if    // Match patterns like ?emp
-                                    (
+                                (
                                     pattern.Substring(0, 1) == "?"
                                     && pattern.Length == baseMatch.Length
                                 )
@@ -2666,8 +2665,3 @@ public bool FileOrDirectoryExists(string path)
         }
     }
 }
-
-
-
-
-
diff --git a/src/Shared/UnitTests/TestAssemblyInfo.cs b/src/Shared/UnitTests/TestAssemblyInfo.cs
index e1e7ef66d5a..627aa0d465e 100644
--- a/src/Shared/UnitTests/TestAssemblyInfo.cs
+++ b/src/Shared/UnitTests/TestAssemblyInfo.cs
@@ -35,6 +35,8 @@ public MSBuildTestAssemblyFixture()
 
         _testEnvironment = TestEnvironment.Create();
 
+        _testEnvironment.DoNotLaunchDebugger();
+
         //  Reset the VisualStudioVersion environment variable.  This will be set if tests are run from a VS command prompt.  However,
         //  if the environment variable is set, it will interfere with tests which set the SubToolsetVersion
         //  (VerifySubToolsetVersionSetByConstructorOverridable), as the environment variable would take precedence.
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 373805aa30f..e932aba587b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -2493,6 +2493,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             };
         }
 
+#pragma warning disable CA1416
         /// <summary>
         /// Registry access delegate. Given a hive and a view, return the registry base key.
         /// </summary>
@@ -2901,6 +2902,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
             Assert.True(false, $"New GetRegistrySubKeyDefaultValue parameters encountered, need to add unittesting support for subKey={subKey}");
             return null;
         }
+#pragma warning restore CA1416
 
         /// <summary>
         /// Delegate for System.IO.File.GetLastWriteTime
diff --git a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
new file mode 100644
index 00000000000..91bbc2269b3
--- /dev/null
+++ b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
@@ -0,0 +1,203 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    sealed public class GetCompatiblePlatform_Tests
+    {
+        private readonly ITestOutputHelper _output;
+
+        public GetCompatiblePlatform_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
+        [Fact]
+        public void ResolvesViaPlatformLookupTable()
+        {
+            // PlatformLookupTable always takes priority. It is typically user-defined.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;x86;AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "win32",
+                PlatformLookupTable = "win32=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x64");
+        }
+
+        [Fact]
+        public void ResolvesViaProjectReferencesPlatformLookupTable()
+        {
+            // A ProjectReference's PlatformLookupTable takes priority over the current project's table.
+            // This allows overrides on a per-ProjectItem basis.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;x86;AnyCPU");
+
+            // ProjectReference will be assigned x86 because its table takes priority
+            projectReference.SetMetadata("PlatformLookupTable", "win32=x86");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "win32",
+                PlatformLookupTable = "win32=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x86");
+        }
+
+        [Fact]
+        public void ResolvesViaAnyCPUDefault()
+        {
+            // No valid mapping via the lookup table, should default to AnyCPU when the current project
+            // and ProjectReference platforms don't match.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "AnyCPU=x64", 
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("AnyCPU");
+        }
+
+        [Fact]
+        public void ResolvesViaSamePlatform()
+        {
+            // No valid mapping via the lookup table. If the ProjectReference's platform
+            // matches the current project's platform, it takes priority over AnyCPU default.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x86;x64;AnyCPU");
+            projectReference.SetMetadata("PlatformLookupTable", "x86=AnyCPU"); // matching platform takes priority over lookup tables
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "x86=AnyCPU",
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x86");
+        }
+
+        [Fact]
+        public void FailsToResolve()
+        {
+            // No valid mapping via the lookup table, ProjectReference can't default to AnyCPU,
+            // it also can't match with current project, log a warning.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "AnyCPU=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+            // When the task logs a warning, it does not set NearestPlatform
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            ((MockEngine)task.BuildEngine).AssertLogContains("MSB3981");
+        }
+
+        [Fact]
+        public void WarnsWhenProjectReferenceHasNoPlatformOptions()
+        {
+            // Task should log a warning when a ProjectReference has no options to build as.
+            // It will continue and have no NearestPlatform metadata.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", string.Empty);
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "AnyCPU=x64",
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+            // When the task logs a warning, it does not set NearestPlatform
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            ((MockEngine)task.BuildEngine).AssertLogContains("MSB3982");
+        }
+
+        /// <summary>
+        /// Invalid format on PlatformLookupTable results in an exception being thrown.
+        /// </summary>
+        [Fact]
+        public void WarnsOnInvalidFormatLookupTable()
+        {
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "AnyCPU",
+                PlatformLookupTable = "AnyCPU=;A=B", // invalid format
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+            // When the platformlookuptable is in an invalid format, it is discarded.
+            // There shouldn't have been a translation found from AnyCPU to anything.
+            // Meaning the projectreference would not have NearestPlatform set.
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            ((MockEngine)task.BuildEngine).AssertLogContains("MSB3983");
+        }
+
+        /// <summary>
+        /// Invalid format on PlatformLookupTable from the projectreference results in an exception being thrown.
+        /// </summary>
+        [Fact]
+        public void WarnsOnInvalidFormatProjectReferenceLookupTable()
+        {
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;x86");
+            projectReference.SetMetadata("PlatformLookupTable", "x86=;b=d");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "AnyCPU",
+                PlatformLookupTable = "AnyCPU=x86;A=B", // invalid format
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            // A ProjectReference PlatformLookupTable should take priority, but is thrown away when
+            // it has an invalid format. The current project's PLT should be the next priority.
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("x86");
+            ((MockEngine)task.BuildEngine).AssertLogContains("MSB3983");
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 558b16bf131..99e3d7066b0 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -2716,7 +2716,7 @@ public References(ITestOutputHelper output)
 
         [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Linked resources not supported on Core: https://github.com/microsoft/msbuild/issues/4094")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "https://github.com/Microsoft/msbuild/issues/677")]
+        [SkipOnMono("https://github.com/Microsoft/msbuild/issues/677")]
         public void DontLockP2PReferenceWhenResolvingSystemTypes()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
@@ -2894,7 +2894,7 @@ public class Class1
         /// </summary>
         [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "Linked resources not supported on Core: https://github.com/microsoft/msbuild/issues/4094")]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Mono, "https://github.com/Microsoft/msbuild/issues/677")]
+        [SkipOnMono("https://github.com/Microsoft/msbuild/issues/677")]
         public void ReferencedAssemblySpecifiedUsingRelativePath()
         {
             // This WriteLine is a hack.  On a slow machine, the Tasks unittest fails because remoting
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index e5b3b361455..c6b179e69ad 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -513,6 +513,13 @@ internal string FullPath
             }
         }
 
+        internal void NormalizeFullPath()
+        {
+            _fullPath = FileUtilities.NormalizePath(_fullPath);
+            _fullPathWithoutExtension = null;
+            _directoryName = null;
+        }
+
         /// <summary>
         /// The directory that this assembly lives in.
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 5967f4c1cdf..196a70b8747 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -407,6 +407,12 @@ internal void AddReference(AssemblyNameExtension assemblyName, Reference referen
                 }
             }
 
+            if (reference.FullPath.Length > 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+            {
+                // Saves effort and makes deduplication possible downstream
+                reference.NormalizeFullPath();
+            }
+
             References[assemblyName] = reference;
         }
 
@@ -1337,7 +1343,11 @@ out userRequestedSpecificFile
             // If the path was resolved, then specify the full path on the reference.
             if (resolvedPath != null)
             {
-                if (!Path.IsPathRooted(resolvedPath))
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+                {
+                    resolvedPath = FileUtilities.NormalizePath(resolvedPath);
+                }
+                else if (!Path.IsPathRooted(resolvedPath))
                 {
                     resolvedPath = Path.GetFullPath(resolvedPath);
                 }
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index ace96711c25..7ed21691a98 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1247,7 +1247,8 @@ quiet at the engine level.
             }
 
 #if FEATURE_WIN32_REGISTRY
-            if (dependencyTable.Resolvers != null)
+            MessageImportance messageImportance = MessageImportance.Low;
+            if (dependencyTable.Resolvers != null && Log.LogsMessagesOfImportance(messageImportance))
             {
                 foreach (Resolver r in dependencyTable.Resolvers)
                 {
@@ -1255,7 +1256,6 @@ quiet at the engine level.
                     {
                         AssemblyFoldersEx assemblyFoldersEx = ((AssemblyFoldersExResolver)r).AssemblyFoldersExLocations;
 
-                        MessageImportance messageImportance = MessageImportance.Low;
                         if (assemblyFoldersEx != null && _showAssemblyFoldersExLocations.TryGetValue(r.SearchPath, out messageImportance))
                         {
                             Log.LogMessageFromResources(messageImportance, "ResolveAssemblyReference.AssemblyFoldersExSearchLocations", r.SearchPath);
@@ -1347,6 +1347,10 @@ private void LogReference(Reference reference, string fusionName)
         {
             // Set an importance level to be used for secondary messages.
             MessageImportance importance = ChooseReferenceLoggingImportance(reference);
+            if (!Log.LogsMessagesOfImportance(importance))
+            {
+                return;
+            }
 
             // Log the fusion name and whether this is a primary or a dependency.
             LogPrimaryOrDependency(reference, fusionName, importance);
@@ -1413,7 +1417,8 @@ private MessageImportance ChooseReferenceLoggingImportance(Reference reference)
         /// </summary>
         private void LogInputs()
         {
-            if (Traits.Instance.EscapeHatches.LogTaskInputs || Silent)
+            MessageImportance importance = MessageImportance.Low;
+            if (Traits.Instance.EscapeHatches.LogTaskInputs || Silent || !Log.LogsMessagesOfImportance(importance))
             {
                 // the inputs will be logged automatically anyway, avoid duplication in the logs
                 return;
@@ -1421,7 +1426,6 @@ private void LogInputs()
 
             string indent = Strings.FourSpaces;
             string property = Strings.LogTaskPropertyFormat;
-            MessageImportance importance = MessageImportance.Low;
 
             Log.LogMessage(importance, property, "TargetFrameworkMoniker");
             Log.LogMessage(importance, indent + _targetedFrameworkMoniker);
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 94af66f7e4a..869718fea00 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -140,6 +140,9 @@ public Copy()
         [Output]
         public ITaskItem[] CopiedFiles { get; private set; }
 
+        [Output]
+        public bool WroteAtLeastOneFile { get; private set; }
+
         /// <summary>
         /// Whether to overwrite files in the destination
         /// that have the read-only attribute set.
@@ -299,6 +302,9 @@ FileState destinationFileState  // The destination file
 
                 File.Copy(sourceFileState.Name, destinationFileState.Name, true);
             }
+            
+            // Files were successfully copied or linked. Those are equivalent here.
+            WroteAtLeastOneFile = true;
 
             destinationFileState.Reset();
 
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index bc15a0328a1..26967ca64e7 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -3151,10 +3151,13 @@ internal void ReadAssemblyResources(String name, String outFileOrDir)
                 // We can't easily filter those.  We can simply skip them.
                 return;
             }
-            catch (Exception e)
+            catch (ArgumentException e) when (e.InnerException is BadImageFormatException)
+            {
+                // BadImageFormatExceptions can be wrapped in ArgumentExceptions, so catch those, too. See https://referencesource.microsoft.com/#mscorlib/system/reflection/module.cs,857
+                return;
+            }
+            catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                if (ExceptionHandling.IsCriticalException(e))
-                    throw;
                 _logger.LogErrorWithCodeFromResources("GenerateResource.CannotLoadAssemblyLoadFromFailed", name, e);
             }
 
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
new file mode 100644
index 00000000000..c86c88199d7
--- /dev/null
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -0,0 +1,154 @@
+Ôªø// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable enable
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Tasks
+{
+    /// <summary>
+    /// Performs SetPlatform negotiation for all project references when opted
+    /// in via the EnableDynamicPlatformResolution property.
+    /// 
+    /// See ProjectReference-Protocol.md for details.
+    /// </summary>
+    public class GetCompatiblePlatform : TaskExtension
+    {
+        /// <summary>
+        /// All ProjectReference items.
+        /// </summary>
+        [Required]
+        public ITaskItem[] AnnotatedProjects { get; set; }
+
+        /// <summary>
+        /// The platform the current project is building as. 
+        /// </summary>
+        [Required]
+        public string CurrentProjectPlatform { get; set; }
+
+        /// <summary>
+        /// Optional parameter that defines mappings from current project platforms
+        /// to what the ProjectReference should build as.
+        /// Win32=x86, for example.
+        /// </summary>
+        public string PlatformLookupTable { get; set; }
+
+        /// <summary>
+        /// The resulting items with NearestPlatform metadata set.
+        /// </summary>
+        [Output]
+        public ITaskItem[]? AssignedProjectsWithPlatform { get; set; }
+
+        public GetCompatiblePlatform()
+        {
+            AnnotatedProjects = new ITaskItem[0];
+            CurrentProjectPlatform = string.Empty;
+            PlatformLookupTable = string.Empty;
+        }
+
+        public override bool Execute()
+        {
+            Dictionary<string, string>? currentProjectLookupTable = ExtractLookupTable(PlatformLookupTable);
+
+            AssignedProjectsWithPlatform = new ITaskItem[AnnotatedProjects.Length];
+            for (int i = 0; i < AnnotatedProjects.Length; i++)
+            {
+                AssignedProjectsWithPlatform[i] = new TaskItem(AnnotatedProjects[i]);
+
+                string projectReferencePlatformMetadata = AssignedProjectsWithPlatform[i].GetMetadata("Platforms");
+
+                if (string.IsNullOrEmpty(projectReferencePlatformMetadata))
+                {
+                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoPlatformsListed", AssignedProjectsWithPlatform[i].ItemSpec);
+                    continue;
+                }
+
+                string projectReferenceLookupTableMetadata = AssignedProjectsWithPlatform[i].GetMetadata("PlatformLookupTable");
+                // Pull platformlookuptable metadata from the referenced project. This allows custom
+                // mappings on a per-ProjectReference basis.
+                Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata);
+
+                HashSet<string> projectReferencePlatforms = new HashSet<string>();
+                foreach (string s in projectReferencePlatformMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+                {
+                    projectReferencePlatforms.Add(s);
+                }
+
+                string buildProjectReferenceAs = string.Empty;
+
+                // Prefer matching platforms
+                if (projectReferencePlatforms.Contains(CurrentProjectPlatform))
+                {
+                    buildProjectReferenceAs = CurrentProjectPlatform;
+                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.SamePlatform");
+                }
+                // Prioritize PlatformLookupTable **metadata** attached to the ProjectReference item
+                // before the current project's table. We do this to allow per-ProjectReference fine tuning.
+                else if (projectReferenceLookupTable != null &&
+                        projectReferenceLookupTable.ContainsKey(CurrentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(projectReferenceLookupTable[CurrentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = projectReferenceLookupTable[CurrentProjectPlatform];
+                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
+                }
+                // Current project's translation table follows
+                else if (currentProjectLookupTable != null &&
+                        currentProjectLookupTable.ContainsKey(CurrentProjectPlatform) &&
+                        projectReferencePlatforms.Contains(currentProjectLookupTable[CurrentProjectPlatform]))
+                {
+                    buildProjectReferenceAs = currentProjectLookupTable[CurrentProjectPlatform];
+                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", CurrentProjectPlatform, buildProjectReferenceAs, PlatformLookupTable);
+                }
+                // AnyCPU if possible
+                else if (projectReferencePlatforms.Contains("AnyCPU"))
+                {
+                    buildProjectReferenceAs = "AnyCPU";
+                    Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.AnyCPUDefault");
+                }
+                else
+                {
+                    // Keep NearestPlatform empty, log a warning. Common.CurrentVersion.targets will undefine 
+                    // Platform/PlatformTarget when this is the case.
+                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", AssignedProjectsWithPlatform[i].ItemSpec);
+                }
+
+                AssignedProjectsWithPlatform[i].SetMetadata("NearestPlatform", buildProjectReferenceAs);
+                Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.DisplayChosenPlatform", AssignedProjectsWithPlatform[i].ItemSpec, buildProjectReferenceAs);
+            }
+
+            return !Log.HasLoggedErrors;
+        }
+
+        private Dictionary<string, string>? ExtractLookupTable(string stringTable)
+        {
+            if (string.IsNullOrEmpty(stringTable))
+            {
+                return null;
+            }
+
+            Dictionary<string, string> table = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+
+            foreach (string s in stringTable.Trim().Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
+            {
+                string[] keyVal = s.Trim().Split(MSBuildConstants.EqualsChar);
+
+                // Invalid table, don't use it.
+                if (keyVal.Length != 2 || string.IsNullOrEmpty(keyVal[0]) || string.IsNullOrEmpty(keyVal[1]))
+                {
+                    Log.LogWarningWithCodeFromResources("GetCompatiblePlatform.InvalidLookupTableFormat", stringTable);
+                    return null;
+                }
+
+                table[keyVal[0]] = keyVal[1];
+            }
+
+            Log.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.LookupTableParsed", stringTable);
+
+            return table;
+        }
+    }
+}
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 4468c610426..dfc8d0050ac 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -928,7 +928,7 @@ internal SDKInfo LoadAssemblyListFromCacheFile(string sdkIdentity, string sdkRoo
                     if (!string.IsNullOrEmpty(cacheFile))
                     {
                         using FileStream fs = new FileStream(cacheFile, FileMode.Open);
-                        var translator = BinaryTranslator.GetReadTranslator(fs, buffer: null);
+                        using var translator = BinaryTranslator.GetReadTranslator(fs, buffer: null);
                         SDKInfo sdkInfo = new SDKInfo();
                         sdkInfo.Translate(translator);
                         return sdkInfo;
diff --git a/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hans.xlf b/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hans.xlf
index 3c85e336dcc..f962020b89a 100644
--- a/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hans.xlf
+++ b/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hans.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.ManifestUtilities.resx">
     <body>
diff --git a/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hant.xlf b/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hant.xlf
index a0726f458b3..37d5db669fa 100644
--- a/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hant.xlf
+++ b/src/Tasks/ManifestUtil/Resources/xlf/Strings.ManifestUtilities.zh-Hant.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.ManifestUtilities.resx">
     <body>
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index f060dad8a13..e5418ee4bad 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -342,6 +342,7 @@
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="ResourceHandling\*.cs" />
+    <Compile Include="GetCompatiblePlatform.cs" />
     <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
diff --git a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
index 0246dd8beda..d7bd7923aa7 100644
--- a/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.CSharp.CurrentVersion.targets
@@ -234,70 +234,71 @@ Copyright (C) Microsoft Corporation. All rights reserved.
        </PropertyGroup>
 
        <!-- Condition is to filter out the _CoreCompileResourceInputs so that it doesn't pass in culture resources to the compiler -->
-        <Csc  Condition=" '%(_CoreCompileResourceInputs.WithCulture)' != 'true' "
-              AdditionalLibPaths="$(AdditionalLibPaths)"
-              AddModules="@(AddModules)"
-              AdditionalFiles="@(AdditionalFiles)"
-              AllowUnsafeBlocks="$(AllowUnsafeBlocks)"
-              AnalyzerConfigFiles="@(EditorConfigFiles)"
-              Analyzers="@(Analyzer)"
-              ApplicationConfiguration="$(AppConfigForCompiler)"
-              BaseAddress="$(BaseAddress)"
-              CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)"
-              CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)"
-              CodePage="$(CodePage)"
-              DebugType="$(DebugType)"
-              DefineConstants="$(DefineConstants)"
-              DelaySign="$(DelaySign)"
-              DisabledWarnings="$(NoWarn)"
-              DocumentationFile="@(DocFileItem)"
-              EmitDebugInformation="$(DebugSymbols)"
-              EnvironmentVariables="$(CscEnvironment)"
-              ErrorEndLocation="$(ErrorEndLocation)"
-              ErrorLog="$(ErrorLog)"
-              ErrorReport="$(ErrorReport)"
-              FileAlignment="$(FileAlignment)"
-              GenerateFullPaths="$(GenerateFullPaths)"
-              HighEntropyVA="$(HighEntropyVA)"
-              KeyContainer="$(KeyContainerName)"
-              KeyFile="$(KeyOriginatorFile)"
-              LangVersion="$(LangVersion)"
-              LinkResources="@(LinkResource)"
-              MainEntryPoint="$(StartupObject)"
-              ModuleAssemblyName="$(ModuleAssemblyName)"
-              NoConfig="true"
-              NoLogo="$(NoLogo)"
-              NoStandardLib="$(NoCompilerStandardLib)"
-              NoWin32Manifest="$(NoWin32Manifest)"
-              Nullable="$(Nullable)"
-              Optimize="$(Optimize)"
-              OutputAssembly="@(XamlIntermediateAssembly)"
-              PdbFile="$(PdbFile)"
-              Platform="$(PlatformTarget)"
-              Prefer32Bit="$(Prefer32Bit)"
-              PreferredUILang="$(PreferredUILang)"
-              References="@(ReferencePath)"
-              ReportAnalyzer="$(ReportAnalyzer)"
-              Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)"
-              ResponseFiles="$(CompilerResponseFile)"
-              SkipAnalyzers="$(_SkipAnalyzers)"
-              Sources="@(Compile)"
-              SubsystemVersion="$(SubsystemVersion)"
-              TargetType="$(OutputType)"
-              ToolExe="$(CscToolExe)"
-              ToolPath="$(CscToolPath)"
-              TreatWarningsAsErrors="$(TreatWarningsAsErrors)"
-              UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)"
-              UseSharedCompilation="$(UseSharedCompilation)"
-              Utf8Output="$(Utf8Output)"
-              VsSessionGuid="$(VsSessionGuid)"
-              WarningLevel="$(WarningLevel)"
-              WarningsAsErrors="$(WarningsAsErrors)"
-              WarningsNotAsErrors="$(WarningsNotAsErrors)"
-              Win32Icon="$(ApplicationIcon)"
-              Win32Manifest="$(Win32Manifest)"
-              Win32Resource="$(Win32Resource)"
-              />
+       <!-- Don't run analyzers for Csc task on XamlPrecompile pass, we only want to run them on core compile. -->
+       <Csc Condition=" '%(_CoreCompileResourceInputs.WithCulture)' != 'true' "
+            AdditionalLibPaths="$(AdditionalLibPaths)"
+            AddModules="@(AddModules)"
+            AdditionalFiles="@(AdditionalFiles)"
+            AllowUnsafeBlocks="$(AllowUnsafeBlocks)"
+            AnalyzerConfigFiles="@(EditorConfigFiles)"
+            Analyzers="@(Analyzer)"
+            ApplicationConfiguration="$(AppConfigForCompiler)"
+            BaseAddress="$(BaseAddress)"
+            CheckForOverflowUnderflow="$(CheckForOverflowUnderflow)"
+            CodeAnalysisRuleSet="$(ResolvedCodeAnalysisRuleSet)"
+            CodePage="$(CodePage)"
+            DebugType="$(DebugType)"
+            DefineConstants="$(DefineConstants)"
+            DelaySign="$(DelaySign)"
+            DisabledWarnings="$(NoWarn)"
+            DocumentationFile="@(DocFileItem)"
+            EmitDebugInformation="$(DebugSymbols)"
+            EnvironmentVariables="$(CscEnvironment)"
+            ErrorEndLocation="$(ErrorEndLocation)"
+            ErrorLog="$(ErrorLog)"
+            ErrorReport="$(ErrorReport)"
+            FileAlignment="$(FileAlignment)"
+            GenerateFullPaths="$(GenerateFullPaths)"
+            HighEntropyVA="$(HighEntropyVA)"
+            KeyContainer="$(KeyContainerName)"
+            KeyFile="$(KeyOriginatorFile)"
+            LangVersion="$(LangVersion)"
+            LinkResources="@(LinkResource)"
+            MainEntryPoint="$(StartupObject)"
+            ModuleAssemblyName="$(ModuleAssemblyName)"
+            NoConfig="true"
+            NoLogo="$(NoLogo)"
+            NoStandardLib="$(NoCompilerStandardLib)"
+            NoWin32Manifest="$(NoWin32Manifest)"
+            Nullable="$(Nullable)"
+            Optimize="$(Optimize)"
+            OutputAssembly="@(XamlIntermediateAssembly)"
+            PdbFile="$(PdbFile)"
+            Platform="$(PlatformTarget)"
+            Prefer32Bit="$(Prefer32Bit)"
+            PreferredUILang="$(PreferredUILang)"
+            References="@(ReferencePath)"
+            ReportAnalyzer="$(ReportAnalyzer)"
+            Resources="@(_CoreCompileResourceInputs);@(CompiledLicenseFile)"
+            ResponseFiles="$(CompilerResponseFile)"
+            SkipAnalyzers="true"
+            Sources="@(Compile)"
+            SubsystemVersion="$(SubsystemVersion)"
+            TargetType="$(OutputType)"
+            ToolExe="$(CscToolExe)"
+            ToolPath="$(CscToolPath)"
+            TreatWarningsAsErrors="$(TreatWarningsAsErrors)"
+            UseHostCompilerIfAvailable="$(UseHostCompilerIfAvailable)"
+            UseSharedCompilation="$(UseSharedCompilation)"
+            Utf8Output="$(Utf8Output)"
+            VsSessionGuid="$(VsSessionGuid)"
+            WarningLevel="$(WarningLevel)"
+            WarningsAsErrors="$(WarningsAsErrors)"
+            WarningsNotAsErrors="$(WarningsNotAsErrors)"
+            Win32Icon="$(ApplicationIcon)"
+            Win32Manifest="$(Win32Manifest)"
+            Win32Resource="$(Win32Resource)"
+            />
 
 <!-- Only Applicable to the regular CoreCompile:
               <ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index f59b407d959..c7d553aecd3 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -46,6 +46,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <!-- Extract necessary information for SetPlatform negotiation -->
+        <!-- This target does not run for cpp projects. -->
+        <IsVcxOrNativeProj>false</IsVcxOrNativeProj>
+        <Platforms>$(Platforms)</Platforms>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
 
@@ -165,7 +169,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   -->
   <PropertyGroup>
     <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
-    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
+    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
     <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'==''">$(MSBuildToolsPath)\NuGet.targets</NuGetRestoreTargets>
   </PropertyGroup>
 
@@ -216,8 +220,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <Import Project="$(DirectoryBuildTargetsPath)" Condition="'$(ImportDirectoryBuildTargets)' == 'true' and exists('$(DirectoryBuildTargetsPath)')"/>
 
-  <!-- TODO: https://github.com/Microsoft/msbuild/issues/1062: Remove this temporary hook when possible. -->
-  <Import Project="$(CoreCrossTargetingTargetsPath)"
-          Condition="'$(CoreCrossTargetingTargetsPath)' != '' and Exists('$(CoreCrossTargetingTargetsPath)')" />
-
 </Project>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index c87052240f9..8cb9228276d 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -179,6 +179,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_DebugSymbolsProduced Condition="'$(DebugType)'=='full'">true</_DebugSymbolsProduced>
     <_DebugSymbolsProduced Condition="'$(DebugType)'=='portable'">true</_DebugSymbolsProduced>
     <_DebugSymbolsProduced Condition="'$(DebugType)'=='embedded'">false</_DebugSymbolsProduced>
+    <_DebugSymbolsProduced Condition="'$(ProduceOnlyReferenceAssembly)'=='true'">false</_DebugSymbolsProduced>
 
     <!-- Whether or not a .xml file is produced. -->
     <_DocumentationFileProduced>true</_DocumentationFileProduced>
@@ -572,7 +573,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <AssemblyFoldersSuffix Condition=" '$(AssemblyFoldersSuffix)' == '' ">AssemblyFoldersEx</AssemblyFoldersSuffix>
     <FrameworkRegistryBase Condition=" '$(FrameworkRegistryBase)' == '' ">Software\Microsoft\$(TargetFrameworkIdentifier)</FrameworkRegistryBase>
     <TargetPlatformRegistryBase Condition="'$(TargetPlatformRegistryBase)' == ''">Software\Microsoft\Microsoft SDKs\$(TargetPlatformIdentifier)</TargetPlatformRegistryBase>
-    <AssemblyFoldersConfigFile Condition="'$(AssemblyFoldersConfigFile)' == ''">$(MSBuildToolsPath32)\AssemblyFolders.config</AssemblyFoldersConfigFile>
+    <AssemblyFoldersConfigFile Condition="'$(AssemblyFoldersConfigFile)' == ''">$([MSBuild]::GetToolsDirectory32())\AssemblyFolders.config</AssemblyFoldersConfigFile>
     <AssemblyFoldersConfigFileSearchPath Condition="Exists('$(AssemblyFoldersConfigFile)')">{AssemblyFoldersFromConfig:$(AssemblyFoldersConfigFile),$(TargetFrameworkVersion)};</AssemblyFoldersConfigFileSearchPath>
     <!--
         The SearchPaths property is set to find assemblies in the following order:
@@ -641,7 +642,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   </PropertyGroup>
 
   <!-- Users familiar with how some other repos work try to use NoWarn with MSBuild in place of MSBuildWarningsAsMessages. -->
-  <PropertyGroup Condition="$([MSBuild]::AreFeaturesEnabled('16.8'))">
+  <PropertyGroup>
     <MSBuildWarningsAsMessages Condition="'$(MSBuildWarningsAsMessages)'==''">$(NoWarn)</MSBuildWarningsAsMessages>
     <MSBuildWarningsAsErrors Condition="'$(MSBuildWarningsAsErrors)'==''">$(WarningsAsErrors)</MSBuildWarningsAsErrors>
   </PropertyGroup>
@@ -1602,6 +1603,93 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <!--
+    ====================================================================================
+                                        _GetProjectReferencePlatformProperties
+
+    If a project is opted in via $(EnableDynamicPlatformResolution), this target calls the 
+    GetCompatiblePlatform task on all ProjectReference items to determine the most compatible 
+    platform for each project. It then sets SetPlatform metadata on each ProjectReference.
+    This prevents overbuilding a project when 'AnyCPU' is available.
+
+    ======================================================================================
+  -->
+
+  <!-- Managed projects need to have PlatformTarget set for SetPlatform negotiation. Default to $(Platform), which is AnyCPU by default. -->
+  <PropertyGroup>
+    <PlatformTarget Condition="'$(EnableDynamicPlatformResolution)' == 'true' and '$(PlatformTarget)' == ''
+                                and '$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj'">$(Platform)</PlatformTarget>
+
+    <UseDefaultPlatformLookupTables Condition="'$(UseDefaultPlatformLookupTables)' == ''">true</UseDefaultPlatformLookupTables>
+  </PropertyGroup>
+
+  <!-- This target skips VS builds because they already supply Platform and
+       Configuration information. -->
+  <Target Name="_GetProjectReferencePlatformProperties"
+          Condition="'$(EnableDynamicPlatformResolution)' == 'true'
+                     and '$(BuildingInsideVisualStudio)' != 'true'
+                     and '@(_MSBuildProjectReferenceExistent)' != ''">
+
+    <!-- Allow preset SetPlatform to override this operation -->
+    <ItemGroup>
+      <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SetPlatform)' != ''">
+        <SkipGetPlatformProperties>true</SkipGetPlatformProperties>
+      </_MSBuildProjectReferenceExistent>
+    </ItemGroup>
+
+    <ItemGroup>
+      <_ProjectReferencePlatformPossibilities Include="@(_MSBuildProjectReferenceExistent)" 
+                                              Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'"/>
+    </ItemGroup>
+
+    <!-- Managed Platform "source of truth" is $(PlatformTarget). For cpp it's $(Platform) -->
+    <PropertyGroup>
+      <CurrentPlatform>$(PlatformTarget)</CurrentPlatform>
+      <CurrentPlatform Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">$(Platform)</CurrentPlatform>
+    </PropertyGroup>
+
+    <!-- Assign default PlatformLookupTables when doing Managed <-> Unmanaged hops -->
+    <ItemGroup>
+      <!-- If we're looking at a c++ project from a managed project, map managed platforms to native platforms. -->
+      <_ProjectReferencePlatformPossibilities Condition="'$(MSBuildProjectExtension)' != '.vcxproj' and '$(MSBuildProjectExtension)' != '.nativeproj' and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' == 'true'">
+        <!-- Taken from https://docs.microsoft.com/visualstudio/msbuild/assignprojectconfiguration-task -->
+        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">x86=Win32</PlatformLookupTable>
+      </_ProjectReferencePlatformPossibilities>
+
+      <!-- If we're looking at a managed project from a cpp project, map native to managed platforms. -->
+      <_ProjectReferencePlatformPossibilities Condition="('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj') and '%(_ProjectReferencePlatformPossibilities.IsVcxOrNativeProj)' != 'true'">
+        <PlatformLookupTable Condition="'$(UseDefaultPlatformLookupTables)' == 'true' and '$(PlatformLookupTable)' == ''">Win32=x86</PlatformLookupTable>
+      </_ProjectReferencePlatformPossibilities>
+    </ItemGroup>
+
+    <GetCompatiblePlatform AnnotatedProjects="@(_ProjectReferencePlatformPossibilities)"
+                           CurrentProjectPlatform="$(CurrentPlatform)"
+                           PlatformLookupTable="$(PlatformLookupTable)"
+                           Condition="'@(_ProjectReferencePlatformPossibilities)' != ''">
+      <Output ItemName="_ProjectsWithPlatformAssignment" TaskParameter="AssignedProjectsWithPlatform" />
+    </GetCompatiblePlatform>
+
+    <!-- If GetCompatiblePlatform didn't run, @(ProjectsWithPlatformAssignment) will be empty.
+         Don't do anything in this case. Ex: A project references many projects
+         that can't multiplatform.  -->
+    <ItemGroup Condition="'@(_ProjectsWithPlatformAssignment)' != ''">
+      <ProjectsWithNearestPlatform Include="@(_ProjectsWithPlatformAssignment)"/>
+      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' != ''">
+        <SetPlatform>PlatformTarget=%(ProjectsWithNearestPlatform.NearestPlatform)</SetPlatform>
+        <SetPlatform Condition="'%(ProjectsWithNearestPlatform.IsVcxOrNativeProj)' == 'true'">Platform=%(ProjectsWithNearestPlatform.NearestPlatform)</SetPlatform>
+      </ProjectsWithNearestPlatform>
+
+      <ProjectsWithNearestPlatform Condition="'@(ProjectsWithNearestPlatform)' == '%(Identity)' and '%(ProjectsWithNearestPlatform.NearestPlatform)' == ''">
+        <UndefineProperties Condition="'%(ProjectsWithNearestPlatform.IsVcxOrNativeProj)' == 'true'">%(ProjectsWithNearestPlatform.UndefineProperties);Platform</UndefineProperties>
+        <UndefineProperties Condition="'%(ProjectsWithNearestPlatform.IsVcxOrNativeProj)' != 'true'">%(ProjectsWithNearestPlatform.UndefineProperties);PlatformTarget</UndefineProperties>
+      </ProjectsWithNearestPlatform>
+
+      <_MSBuildProjectReferenceExistent Remove="@(_MSBuildProjectReferenceExistent)" Condition="'%(_MSBuildProjectReferenceExistent.SkipGetPlatformProperties)' != 'true'"/>
+      <_MSBuildProjectReferenceExistent Include="@(ProjectsWithNearestPlatform)"/>
+    </ItemGroup>
+
+  </Target>
+
   <!--
     ====================================================================================
                                         _GetProjectReferenceTargetFrameworkProperties
@@ -1657,7 +1745,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
    -->
    <ItemGroup>
       <_MSBuildProjectReferenceExistent Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' == '' and ('%(Extension)' == '.vcxproj' or '%(Extension)' == '.nativeproj')">
-        <SkipGetTargetFrameworkProperties>true</SkipGetTargetFrameworkProperties>
+        <!-- When we're dynamically figuring out platform, we need the MSBuild call that retrieves TF data. -->
+        <SkipGetTargetFrameworkProperties Condition="'$(EnableDynamicPlatformResolution)' != 'true'">true</SkipGetTargetFrameworkProperties>
         <UndefineProperties>%(_MSBuildProjectReferenceExistent.UndefineProperties);TargetFramework</UndefineProperties>
       </_MSBuildProjectReferenceExistent>
    </ItemGroup>
@@ -1719,8 +1808,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                                             CurrentProjectTargetPlatform="$(TargetPlatformMoniker)"
                                             CurrentProjectName="$(MSBuildProjectName)"
                                             FallbackTargetFrameworks="$(AssetTargetFallback)"
-                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
-                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true'">
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
       <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
     </GetReferenceNearestTargetFrameworkTask>
 
@@ -1728,8 +1817,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                                             CurrentProjectTargetFramework="$(ReferringTargetFrameworkForProjectReferences)"
                                             CurrentProjectName="$(MSBuildProjectName)"
                                             FallbackTargetFrameworks="$(AssetTargetFallback)"
-                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities->Count())' != '0' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
-                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true'">
+                                            Condition="'@(_ProjectReferenceTargetFrameworkPossibilities)' != '' and '$(ReferringTargetFrameworkForProjectReferences)' != ''
+                                                        And '$(GetReferenceNearestTargetFrameworkTaskSupportsTargetPlatformParameter)' != 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' != 'true'">
       <Output ItemName="AnnotatedProjects" TaskParameter="AssignedProjects" />
     </GetReferenceNearestTargetFrameworkTask>
 
@@ -1738,9 +1827,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          If the task was skipped or the current TargetFramework is empty, AnnotatedProjects will be empty.
          In this case, copy _ProjectReferenceTargetFrameworkPossibilities as is. See:
             https://github.com/dotnet/sdk/issues/416
+
+        Furthermore, if we're referencing a .vcxproj or .nativeproj, those items won't be populated into `AnnotatedProjects`
+        by `GetReferenceNearestTargetFrameworkTask`, so let them flow when `EnableDynamicPlatformResolution` is set. 
       -->
       <AnnotatedProjects Include="@(_ProjectReferenceTargetFrameworkPossibilities)"
-                         Condition="'$(ReferringTargetFrameworkForProjectReferences)' == ''" />
+                         Condition="'$(ReferringTargetFrameworkForProjectReferences)' == '' or
+                                    ('$(EnableDynamicPlatformResolution)' == 'true' and '%(_ProjectReferenceTargetFrameworkPossibilities.IsVcxOrNativeProj)' == 'true')" />
+
       <!-- If the NearestTargetFramework property was set and the project multi-targets, SetTargetFramework must be set. -->
       <AnnotatedProjects Condition="'@(AnnotatedProjects)' == '%(Identity)' and '%(AnnotatedProjects.NearestTargetFramework)' != '' and '%(AnnotatedProjects.HasSingleTargetFramework)' != 'true'">
         <SetTargetFramework>TargetFramework=%(AnnotatedProjects.NearestTargetFramework)</SetTargetFramework>
@@ -1792,6 +1886,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <!-- indicate to caller that project is RID agnostic so that a global property RuntimeIdentifier value can be removed -->
         <IsRidAgnostic>false</IsRidAgnostic>
         <IsRidAgnostic Condition=" '$(RuntimeIdentifier)' == '' and '$(RuntimeIdentifiers)' == '' ">true</IsRidAgnostic>
+        <!-- Extract necessary information for SetPlatform negotiation -->
+        <IsVcxOrNativeProj Condition="'$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj'">true</IsVcxOrNativeProj>
+        <Platforms>$(Platforms)</Platforms>
+        <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
+             Build the `Platforms` property from that. -->
+        <Platforms Condition="'@(ProjectConfiguration)' != '' and ('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj')">@(ProjectConfiguration->'%(Platform)'->Distinct())</Platforms>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
 
@@ -1859,7 +1959,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <PrepareProjectReferencesDependsOn>
       AssignProjectConfiguration;
       _SplitProjectReferencesByFileExistence;
-      _GetProjectReferenceTargetFrameworkProperties
+      _GetProjectReferenceTargetFrameworkProperties;
+      _GetProjectReferencePlatformProperties
     </PrepareProjectReferencesDependsOn>
   </PropertyGroup>
 
@@ -4232,6 +4333,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
       <_ClickOnceFiles Include="$(PublishedSingleFilePath)"/>
       <_ClickOnceFiles Include="@(_FilesExcludedFromBundle)"/>
+
+      <!-- Include file association icons from Content as loose files -->
+      <_FileAssociationIcons Include="%(FileAssociation.DefaultIcon)"/>
+      <_ClickOnceFiles Include="@(ContentWithTargetPath)" Condition="'%(Identity)'=='@(_FileAssociationIcons)'"/>
     </ItemGroup>
 
     <!-- For single file publish in .net core app, sign the SF EXE if signing is enabled -->
@@ -4689,6 +4794,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
       <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable"/>
       <Output TaskParameter="CopiedFiles" ItemName="ReferencesCopiedInThisBuild"/>
+      <Output TaskParameter="WroteAtLeastOneFile" PropertyName="WroteAtLeastOneFile"/>
 
     </Copy>
 
@@ -4698,7 +4804,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          input to projects that reference this one. -->
     <Touch Files="@(CopyUpToDateMarker)"
            AlwaysCreate="true"
-           Condition="'@(ReferencesCopiedInThisBuild)' != ''">
+           Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'">
         <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
     </Touch>
 
@@ -4720,13 +4826,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
                                         GetCopyToOutputDirectoryItems
 
     Get all project items that may need to be transferred to the output directory.
-    This includes baggage items from transitively referenced projects. It would appear
-    that this target computes full transitive closure of content items for all referenced
-    projects; however that is not the case. It only collects the content items from its
-    immediate children and not children of children. The reason this happens is that
-    the ProjectReferenceWithConfiguration list that is consumed by _SplitProjectReferencesByFileExistence
-    is only populated in the current project and is empty in the children. The empty list
-    causes _MSBuildProjectReferenceExistent to be empty and terminates the recursion.
+    This includes baggage items from transitively referenced projects.
+
+    As of 17.0, content items are copied transitively by default.
+    Set `MSBuildCopyContentTransitively` to false to opt out.
+    See https://github.com/dotnet/msbuild/pull/6622 for more info.
     ============================================================
     -->
   <PropertyGroup>
@@ -4735,9 +4839,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       GetCopyToOutputDirectoryItems depends on an unspecified dependency _SplitProjectReferencesByFileExistence -> AssignProjectConfiguration (https://github.com/microsoft/msbuild/issues/4677).
       When the unspecified dependency does not happen by accident, content copying is only 1 level deep instead of transitive.
       This target enforces the dependency.
-
-      TODO: make transitive content copying the default when the breaking change is acceptable.
     -->
+
+    <MSBuildCopyContentTransitively Condition=" '$(MSBuildCopyContentTransitively)' == '' and $([MSBuild]::AreFeaturesEnabled('17.0'))">true</MSBuildCopyContentTransitively>
+
     <_TargetsThatPrepareProjectReferences Condition=" '$(MSBuildCopyContentTransitively)' == 'true' ">
       AssignProjectConfiguration;
       _SplitProjectReferencesByFileExistence
@@ -6524,7 +6629,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <!-- Import NuGet.targets (required for GetReferenceNearestTargetFrameworkTask and used for Restore functionality) -->
   <PropertyGroup>
     <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
-    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
+    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
     <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'==''">$(MSBuildToolsPath)\NuGet.targets</NuGetRestoreTargets>
   </PropertyGroup>
 
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index 32f5f05ab9f..b08b6558352 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -171,7 +171,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
   <PropertyGroup>
     <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
-    <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
+    <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$([MSBuild]::GetToolsDirectory32())\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
     <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
   </PropertyGroup>
 
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index 6cef8ef8661..f6b98da83af 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -127,6 +127,7 @@
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateTrustInfo"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GetCompatiblePlatform"                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetFileHash"                           AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkPath"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetFrameworkSdkPath"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index ee59ffb9b5e..48877a31c2f 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -52,6 +52,8 @@ public sealed class ResolveManifestFiles : TaskExtension
         // if signing manifests is on and not all app files are included, then the project can't be published.
         private bool _canPublish;
         private Dictionary<string, ITaskItem> _runtimePackAssets;
+        // map of satellite assemblies that are included in References
+        private SatelliteRefAssemblyMap _satelliteAssembliesPassedAsReferences = new SatelliteRefAssemblyMap();
         #endregion
 
         #region Properties
@@ -380,6 +382,28 @@ private void GetOutputAssemblies(List<PublishInfo> publishInfos, List<ITaskItem>
                 {
                     if (!IsFiltered(item))
                     {
+                        // ClickOnce for .NET 4.X should not publish duplicate satellite assemblies.
+                        // This will cause ClickOnce install to fail. This can happen if some package
+                        // decides to publish the en-us resource assemblies for other locales also.
+                        if (!LauncherBasedDeployment && _satelliteAssembliesPassedAsReferences.ContainsItem(item))
+                        {
+                            continue;
+                        }
+
+                        // Apply the culture publishing rules to include or exclude satellite assemblies
+                        AssemblyIdentity identity = AssemblyIdentity.FromManagedAssembly(item.ItemSpec);
+                        if (identity != null && !String.Equals(identity.Culture, "neutral", StringComparison.Ordinal))
+                        {
+                            CultureInfo satelliteCulture = GetItemCulture(item);
+                            if (PublishFlags.IsSatelliteIncludedByDefault(satelliteCulture, _targetCulture, _includeAllSatellites))
+                            {
+                                _satelliteAssembliesPassedAsReferences.Add(item);
+                            }
+                            else
+                            {
+                                continue;
+                            }
+                        }
                         item.SetMetadata("AssemblyType", "Managed");
                         assemblyMap.Add(item);
                     }
@@ -574,6 +598,10 @@ private void GetOutputSatellites(List<PublishInfo> publishInfos, List<ITaskItem>
                 foreach (ITaskItem item in _satelliteAssemblies)
                 {
                     item.SetMetadata("AssemblyType", "Satellite");
+                    if (_satelliteAssembliesPassedAsReferences.ContainsItem(item))
+                    {
+                        continue;
+                    }
                     satelliteMap.Add(item, true);
                 }
             }
@@ -855,6 +883,54 @@ IEnumerator IEnumerable.GetEnumerator()
         }
         #endregion
 
+        #region SatelliteRefAssemblyMap
+        private class SatelliteRefAssemblyMap : IEnumerable
+        {
+            private readonly Dictionary<string, MapEntry> _dictionary = new Dictionary<string, MapEntry>(StringComparer.InvariantCultureIgnoreCase);
+
+            public MapEntry this[string fusionName]
+            {
+                get
+                {
+                    _dictionary.TryGetValue(fusionName, out MapEntry entry);
+                    return entry;
+                }
+            }
+
+            public bool ContainsItem(ITaskItem item)
+            {
+                AssemblyIdentity identity = AssemblyIdentity.FromManagedAssembly(item.ItemSpec);
+                if (identity != null)
+                {
+                    return _dictionary.ContainsKey(identity.ToString());
+                }
+                return false;
+            }
+
+            public void Add(ITaskItem item)
+            {
+                var entry = new MapEntry(item, true);
+                AssemblyIdentity identity = AssemblyIdentity.FromManagedAssembly(item.ItemSpec);
+                if (identity != null && !String.Equals(identity.Culture, "neutral", StringComparison.Ordinal))
+                {
+                    // Use satellite assembly strong name signature as key
+                    string key = identity.ToString();
+                    Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same key '{0}' detected", key));
+                    if (!_dictionary.ContainsKey(key))
+                    {
+                        _dictionary.Add(key, entry);
+                    }
+                }
+            }
+
+            IEnumerator IEnumerable.GetEnumerator()
+            {
+                return _dictionary.Values.GetEnumerator();
+            }
+        }
+        #endregion
+
+
         #region FileMap
         private class FileMap : IEnumerable
         {
@@ -1036,7 +1112,7 @@ public static PublishFlags GetSatelliteFlags(PublishState state, CultureInfo sat
 
             public bool IsPublished { get; }
 
-            private static bool IsSatelliteIncludedByDefault(CultureInfo satelliteCulture, CultureInfo targetCulture, bool includeAllSatellites)
+            public static bool IsSatelliteIncludedByDefault(CultureInfo satelliteCulture, CultureInfo targetCulture, bool includeAllSatellites)
             {
                 // If target culture not specified then satellite is not included by default...
                 if (targetCulture == null)
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 48b0bfb05a3..45b52e509f0 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -2893,6 +2893,37 @@
     <value>MSB3965: No output path specified in build settings.</value>
     <comment>{StrBegin="MSB3965: "}</comment>
   </data>
+
+  <!--
+        MSB3981 - MSB3990   Task: GetCompatiblePlatform
+  -->
+  <data name="GetCompatiblePlatform.NoCompatiblePlatformFound">
+    <value>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</value>
+    <comment>{StrBegin="MSB3981: "}</comment>
+  </data>
+  <data name="GetCompatiblePlatform.NoPlatformsListed">
+    <value>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</value>
+    <comment>{StrBegin="MSB3982: "}</comment>
+  </data>
+  <data name="GetCompatiblePlatform.InvalidLookupTableFormat">
+    <value>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</value>
+    <comment>{StrBegin="MSB3983: "}</comment>
+  </data>
+  <data name="GetCompatiblePlatform.LookupTableParsed">
+    <value>Parsed lookup table:'{0}'.</value>
+  </data>
+    <data name="GetCompatiblePlatform.FoundMappingInTable">
+    <value>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</value>
+  </data>
+  <data name="GetCompatiblePlatform.DisplayChosenPlatform">
+    <value>Project '{0}' will build with platform: '{1}'.</value>
+  </data>
+  <data name="GetCompatiblePlatform.SamePlatform">
+    <value>ProjectReference and current project have the same platform.</value>
+  </data>
+  <data name="GetCompatiblePlatform.AnyCPUDefault">
+    <value>Choosing AnyCPU by default.</value>
+  </data>
   <!--
         The tasks message bucket is: MSB3001 - MSB3999
 
@@ -2978,6 +3009,7 @@
             MSB3951 - MSB3960   Task: VerifyFileHash
             MSB3961 - MSB3970   Task: GenerateLauncher
             MSB3971 - MSB3980   Task: GetReferenceAssemblyPaths overflow
+            MSB3981 - MSB3990   Task: GetCompatiblePlatform
 
             MSB4000 - MSB4200   Portable targets & tasks (vsproject\flavors\portable\msbuild)
             MSB9000 - MSB9900   MSBuild targets files (C++)
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 47e2693228e..4dffc40b6a4 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="cs" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Nelze z√≠skat n√°zev sestaven√≠ pro {0}. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Oƒçek√°van√° verze sady Microsoft Windows SDK nebyla nalezena. P≈ôi hled√°n√≠ bylo pou≈æito um√≠stƒõn√≠ urƒçen√© hodnotou {0} kl√≠ƒçe registru {1}. Pokud dan√Ω proces sestaven√≠ sadu SDK nepot≈ôebuje, lze tuto chybu ignorovat. V opaƒçn√©m p≈ô√≠padƒõ m≈Ø≈æete pot√≠≈æe odstranit proveden√≠m jedn√© z n√°sleduj√≠c√≠ch akc√≠: 1) instalac√≠ sady Microsoft Windows SDK,  2) Instalac√≠ sady Visual Studio 2010. 3) Ruƒçn√≠m nastaven√≠m uveden√©ho kl√≠ƒçe registru na spr√°vn√© um√≠stƒõn√≠.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 2764a459b17..b2967c6f62b 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="de" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Der Assemblyname f√ºr "{0}" kann nicht abgerufen werden. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Die erwartete Version des Microsoft Windows SDK wurde nicht gefunden. Es wurde nach einem im Wert "{0}" des Registrierungsschl√ºssels "{1}" angegebenen Speicherort gesucht. Wenn das SDK f√ºr den Buildprozess nicht erforderlich ist, kann diese Meldung ignoriert werden. Andernfalls k√∂nnen Sie das Problem mit einem der folgenden Verfahren beheben:  1) Installieren Sie das Microsoft Windows SDK.  2) Installieren Sie Visual Studio 2010.  3) Legen Sie den obigen Registrierungsschl√ºssel manuell auf den korrekten Speicherort fest.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index 14b9fb2399b..751a0a265bf 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -1371,6 +1371,46 @@
         <target state="new">MSB3441: Cannot get assembly name for "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="new">Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index abce121ff65..f192095b546 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: No se puede obtener el nombre del ensamblado para "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">No se encuentra la versi√≥n esperada de Microsoft Windows SDK. Se busc√≥ una ubicaci√≥n especificada en el valor "{0}" de la clave del Registro "{1}". Si el proceso de compilaci√≥n no necesita el SDK, se puede omitir. De lo contrario, puede solucionar el problema realizando alguna de las siguientes acciones:  1) Instale Microsoft Windows SDK.  2) Instale Visual Studio 2010.  3) Establezca manualmente la clave del Registro indicada en la ubicaci√≥n correcta.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 5796f3152fc..227e4e0ada5 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Impossible d'obtenir le nom d'assembly de "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Impossible de trouver la version attendue du SDK Microsoft Windows. Recherche d'un emplacement indiqu√© dans la valeur "{0}" de la cl√© de Registre "{1}". Si votre processus de g√©n√©ration n'a pas besoin du SDK, cette erreur peut √™tre ignor√©e. Sinon, essayez de r√©soudre le probl√®me de l'une des mani√®res suivantes¬†: 1) Installez le SDK Microsoft Windows.  2) Installez Visual Studio¬†2010. 3) Indiquez l'emplacement appropri√© dans la cl√© de Registre ci-dessus.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 50aa55dd16b..c9de2ea77a7 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="it" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: non √® possibile ottenere il nome dell'assembly per "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Non √® stato possibile trovare la versione prevista di Microsoft Windows SDK. √à stato cercato il percorso specificato nel valore "{0}" della chiave del Registro di sistema "{1}". Se il processo di compilazione non richiede l'SDK, √® possibile ignorare il problema. In caso contrario, per risolvere il problema eseguire una di queste operazioni: 1) Installare Microsoft Windows SDK.  2) Installare Visual Studio 2010. 3) Impostare manualmente la chiave del Registro di sistema specificata in precedenza sul percorso corretto.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index bf0e88d55ed..505b8abd5d6 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ja" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: "{0}" „ÅÆ„Ç¢„Çª„É≥„Éñ„É™Âêç„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„ÄÇ{1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">ÂøÖË¶Å„Å™„Éê„Éº„Ç∏„Éß„É≥„ÅÆ Microsoft Windows SDK „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„É¨„Ç∏„Çπ„Éà„É™ „Ç≠„Éº "{1}" „ÅÆÂÄ§ "{0}" „ÅßÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥ÊâÄ„ÇíÊé¢„Åó„Åæ„Åó„Åü„ÄÇ„Åì„ÅÆ„Ç®„É©„Éº„ÅØ„ÄÅ„Éì„É´„ÉâÂá¶ÁêÜ„Åß SDK „Åå‰∏çË¶Å„Å™Â†¥Âêà„ÅØÁÑ°Ë¶ñ„Åß„Åç„Åæ„Åô„ÄÇSDK „ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØ„ÄÅÊ¨°„ÅÆ„ÅÑ„Åö„Çå„Åã„ÇíË°å„ÅÜ„Åì„Å®„Å´„Çà„Å£„Å¶ÂïèÈ°å„ÇíËß£Ê±∫„Åß„Åç„Åæ„Åô„ÄÇ1) Microsoft Windows SDK „Çí„Ç§„É≥„Çπ„Éà„Éº„É´„Åô„Çã„ÄÇ2) Visual Studio 2010 „Çí„Ç§„É≥„Çπ„Éà„Éº„É´„Åô„Çã„ÄÇ3) ‰∏äË®ò„ÅÆ„É¨„Ç∏„Çπ„Éà„É™ „Ç≠„Éº„ÇíÊ≠£„Åó„ÅÑÂ†¥ÊâÄ„Å´ÊâãÂãï„ÅßË®≠ÂÆö„Åô„Çã„ÄÇ</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 0ffa4a11df8..8f3abe83e5e 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: "{0}"Ïùò Ïñ¥ÏÖàÎ∏îÎ¶¨ Ïù¥Î¶ÑÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">ÏõêÌïòÎäî Microsoft Windows SDK Î≤ÑÏ†ÑÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. "{1}" Î†àÏßÄÏä§Ìä∏Î¶¨ ÌÇ§Ïùò "{0}" Í∞íÏóê ÏßÄÏ†ïÎêú ÏúÑÏπòÎ•º Í≤ÄÏÉâÌñàÏäµÎãàÎã§. ÎπåÎìú ÌîÑÎ°úÏÑ∏Ïä§ÏóêÏÑú SDKÍ∞Ä ÌïÑÏöîÌïòÏßÄ ÏïäÏúºÎ©¥ Ïù¥ Î©îÏãúÏßÄÎ•º Î¨¥ÏãúÌï¥ÎèÑ Îê©ÎãàÎã§. Í∑∏Î†áÏßÄ ÏïäÏúºÎ©¥ Îã§Ïùå Ï§ë ÌïòÎÇòÎ•º ÏàòÌñâÌïòÏó¨ Î¨∏Ï†úÎ•º Ìï¥Í≤∞Ìï† Ïàò ÏûàÏäµÎãàÎã§. 1) Microsoft Windows SDKÎ•º ÏÑ§ÏπòÌï©ÎãàÎã§.  2) Visual Studio 2010ÏùÑ ÏÑ§ÏπòÌï©ÎãàÎã§. 3) ÏúÑÏùò Î†àÏßÄÏä§Ìä∏Î¶¨ ÌÇ§Î•º Ïò¨Î∞îÎ•∏ ÏúÑÏπòÎ°ú ÏßÅÏ†ë ÏÑ§Ï†ïÌï©ÎãàÎã§.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 0b07372babf..75fc8e7f976 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pl" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Nie mo≈ºna pobraƒá nazwy zestawu dla ‚Äû{0}‚Äù. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Nie mo≈ºna zlokalizowaƒá oczekiwanej wersji zestawu Microsoft Windows SDK. Poszukiwano lokalizacji okre≈õlonej w warto≈õci ‚Äû{0}‚Äù klucza rejestru ‚Äû{1}‚Äù. Je≈ºeli proces kompilacji nie wymaga zestawu SDK, mo≈ºna zignorowaƒá ten element. W przeciwnym przypadku problem mo≈ºna rozwiƒÖzaƒá, wykonujƒÖc jednƒÖ z nastƒôpujƒÖcych czynno≈õci: 1) zainstalowanie zestawu Microsoft Windows SDK,  2) zainstalowanie programu Visual Studio 2010, 3) rƒôczne ustawienie poprawnej lokalizacji w powy≈ºszym kluczu rejestru.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index bff033eca29..1ed2d4d14ee 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pt-BR" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: N√£o foi poss√≠vel obter o nome de assembly para "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">N√£o foi poss√≠vel localizar a vers√£o esperada do SDK do Microsoft Windows. Ela foi procurada em uma localiza√ß√£o especificada no valor "{0}" da chave do Registro "{1}". Se o seu processo de build n√£o precisar do SDK, isso poder√° ser ignorado. Caso contr√°rio, voc√™ poder√° resolver o problema executando um destes procedimentos: 1) Instalar o SDK do Microsoft Windows.  2) Instalar o Visual Studio 2010. 3) Definir manualmente a chave do Registro acima para a localiza√ß√£o correta.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 0319146c12b..b2fe1cecf3d 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–º—è —Å–±–æ—Ä–∫–∏ –¥–ª—è "{0}". {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–∞—Ä—É–∂–∏—Ç—å —Ç—Ä–µ–±—É–µ–º—É—é –≤–µ—Ä—Å–∏—é Microsoft Windows SDK. –ü–æ–∏—Å–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω –≤ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–∏, –∑–∞–¥–∞–Ω–Ω–æ–º –∑–Ω–∞—á–µ–Ω–∏–µ–º "{0}" —Ä–∞–∑–¥–µ–ª–∞ —Ä–µ–µ—Å—Ç—Ä–∞ "{1}". –ï—Å–ª–∏ –¥–∞–Ω–Ω–æ–º—É –ø—Ä–æ—Ü–µ—Å—Å—É —Å–±–æ—Ä–∫–∏ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–∞–∫–µ—Ç SDK, –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –º–æ–∂–Ω–æ –Ω–µ –æ–±—Ä–∞—â–∞—Ç—å –≤–Ω–∏–º–∞–Ω–∏—è. –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –Ω–µ–ø–æ–ª–∞–¥–∫—É, –≤–æ–∑–º–æ–∂–Ω–æ, —É–¥–∞—Å—Ç—Å—è —É—Å—Ç—Ä–∞–Ω–∏—Ç—å, –≤—ã–ø–æ–ª–Ω–∏–≤ –æ–¥–Ω–æ –∏–∑ —Å–ª–µ–¥—É—é—â–∏—Ö –¥–µ–π—Å—Ç–≤–∏–π: (1) —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ Microsoft Windows SDK;  (2) —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ Visual Studio 2010; (3) –≤—Ä—É—á–Ω—É—é –∑–∞–¥–∞–π—Ç–µ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –≤—ã—à–µ —Ä–∞–∑–¥–µ–ª–µ —Ä–µ–µ—Å—Ç—Ä–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index d0d3f932959..8322c625cfd 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="tr" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: "{0}" i√ßin derleme adƒ± alƒ±namƒ±yor. {1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Beklenen Microsoft Windows SDK s√ºr√ºm√º bulunamadƒ±. "{1}" kayƒ±t defteri anahtarƒ±nƒ±n "{0}" deƒüerinde belirtilen konum arandƒ±. Derleme i≈üleminiz SDK‚Äôya ihtiya√ß duymuyorsa bu yoksayƒ±labilir. Aksi halde, ≈üu i≈ülemlerden birini yaparak sorunu √ß√∂zebilirsiniz: 1) Microsoft Windows SDK‚Äôyƒ± y√ºkleyin.  2) Visual Studio 2010‚Äôu y√ºkleyin. 3) Yukarƒ±daki kayƒ±t defteri anahtarƒ±nƒ± el ile doƒüru konuma ayarlayƒ±n.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 74e83975e40..93d8a13443c 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: Êó†Ê≥ïËé∑Âèñ‚Äú{0}‚ÄùÁöÑÁ®ãÂ∫èÈõÜÂêçÁß∞„ÄÇ{1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Êú™ËÉΩÊâæÂà∞ Microsoft Windows SDK ÁöÑÈ¢ÑÊúüÁâàÊú¨„ÄÇÂ∑≤Êü•ÊâæËøáÊ≥®ÂÜåË°®È°π‚Äú{1}‚ÄùÁöÑ‚Äú{0}‚ÄùÂÄº‰∏≠ÊåáÂÆöÁöÑ‰ΩçÁΩÆ„ÄÇÂ¶ÇÊûúÁîüÊàêËøáÁ®ã‰∏çÈúÄË¶ÅËØ• SDKÔºåÂàôÂèØ‰ª•ÂøΩÁï•Ê≠§ÈóÆÈ¢ò„ÄÇÂê¶ÂàôÔºåÈÄöËøáÊâßË°å‰∏ãÂàóÊìç‰Ωú‰πã‰∏ÄÂèØ‰ª•Ëß£ÂÜ≥Ê≠§ÈóÆÈ¢ò: 1) ÂÆâË£Ö Microsoft Windows SDK„ÄÇ2) ÂÆâË£Ö Visual Studio 2010„ÄÇ 3) ÊâãÂä®ÂêëÊ≠£Á°ÆÁöÑ‰ΩçÁΩÆËÆæÁΩÆ‰∏äÈù¢ÁöÑÊ≥®ÂÜåË°®È°π„ÄÇ</target>
@@ -2647,7 +2687,7 @@
       </trans-unit>
       <trans-unit id="Xaml.MissingTaskBody">
         <source>MSB3692: Unable to create Xaml task.  The &lt;UsingTask&gt; does not contain a &lt;Task&gt; definition.</source>
-        <target state="translated">MSB3692:  Êó†Ê≥ïÂàõÂª∫ Xaml ‰ªªÂä°„ÄÇ  &lt;UsingTask&gt; Êú™ÂåÖÂê´ &lt;Task&gt; ÂÆö‰πâ„ÄÇ</target>
+        <target state="translated">MSB3692: Êó†Ê≥ïÂàõÂª∫ Xaml ‰ªªÂä°„ÄÇ  &lt;UsingTask&gt; Êú™ÂåÖÂê´ &lt;Task&gt; ÂÆö‰πâ„ÄÇ</target>
         <note>{StrBegin="MSB3692: "}</note>
       </trans-unit>
       <trans-unit id="Xaml.ArgumentOutOfRange">
@@ -3242,7 +3282,7 @@
       </trans-unit>
       <trans-unit id="ErrorAndWarning.EmptyMessage">
         <source>(No message specified)</source>
-        <target state="translated">ÔºàÊú™ÊåáÂÆö‰ªª‰ΩïÊ∂àÊÅØÔºâ</target>
+        <target state="translated">(Êú™ÊåáÂÆö‰ªª‰ΩïÊ∂àÊÅØ)</target>
         <note />
       </trans-unit>
       <trans-unit id="TaskFactoryNotSupportedFailure">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 337211ec03f..e206b7cccfc 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
@@ -1326,6 +1326,46 @@
         <target state="translated">MSB3441: ÁÑ°Ê≥ïÂèñÂæó "{0}" ÁöÑÁµÑ‰ª∂ÂêçÁ®±„ÄÇ{1}</target>
         <note>{StrBegin="MSB3441: "}</note>
       </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.AnyCPUDefault">
+        <source>Choosing AnyCPU by default.</source>
+        <target state="new">Choosing AnyCPU by default.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.DisplayChosenPlatform">
+        <source>Project '{0}' will build with platform: '{1}'.</source>
+        <target state="new">Project '{0}' will build with platform: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.FoundMappingInTable">
+        <source>Found mapping '{0}'='{1}' in given lookup table: '{2}'.</source>
+        <target state="new">Found mapping '{0}'='{1}' in given lookup table: '{2}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.InvalidLookupTableFormat">
+        <source>MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</source>
+        <target state="new">MSB3983: The PlatformLookupTable '{0}' is in an invalid format and won't be used. The format should be 'A=B;C=D'.</target>
+        <note>{StrBegin="MSB3983: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.LookupTableParsed">
+        <source>Parsed lookup table:'{0}'.</source>
+        <target state="new">Parsed lookup table:'{0}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoCompatiblePlatformFound">
+        <source>MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</source>
+        <target state="new">MSB3981: Could not determine what '{0}' should be built as. The project will be built without the Platform property set.</target>
+        <note>{StrBegin="MSB3981: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.NoPlatformsListed">
+        <source>MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</source>
+        <target state="new">MSB3982: EnableDynamicPlatformResolution is true but referenced project '{0}' has no 'Platforms' metadata set. It will be built without a specified platform.</target>
+        <note>{StrBegin="MSB3982: "}</note>
+      </trans-unit>
+      <trans-unit id="GetCompatiblePlatform.SamePlatform">
+        <source>ProjectReference and current project have the same platform.</source>
+        <target state="new">ProjectReference and current project have the same platform.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="GetFrameworkSdkPath.CouldNotFindSDK">
         <source>Could not locate the expected version of the Microsoft Windows SDK. Looked for a location specified in the "{0}" value of the registry key "{1}". If your build process does not need the SDK then this can be ignored. Otherwise you can solve the problem by doing one of the following:  1) Install the Microsoft Windows SDK.  2) Install Visual Studio 2010.  3) Manually set the above registry key to the correct location.</source>
         <target state="translated">Êâæ‰∏çÂà∞È†êÊúüÁöÑ Microsoft Windows SDK ÁâàÊú¨„ÄÇÂ∑≤Âú®ÁôªÈåÑÊ©üÁ¢º "{1}" ÁöÑ "{0}" ÂÄº‰∏≠ÊåáÂÆöÁöÑ‰ΩçÁΩÆÂ∞ãÊâæ„ÄÇÂ¶ÇÊûúÊÇ®ÁöÑÂª∫ÁΩÆÁ®ãÂ∫è‰∏çÈúÄË¶ÅÈÄôÂÄã SDKÔºåÊÇ®ÂèØ‰ª•ÂøΩÁï•Ê≠§Ë®äÊÅØ„ÄÇÂê¶ÂâáÔºåÊÇ®ÂèØ‰ª•Âü∑Ë°å‰∏ãÂàóÂÖ∂‰∏≠‰∏ÄÂÄãÂãï‰Ωú‰ª•Ëß£Ê±∫Ê≠§ÂïèÈ°å:  1) ÂÆâË£ù Microsoft Windows SDK„ÄÇ2) ÂÆâË£ù Visual Studio 2010„ÄÇ  3) ÊâãÂãïÂ∞á‰∏äÊñπÁôªÈåÑÊ©üÁ¢ºË®≠ÁÇ∫Ê≠£Á¢∫‰ΩçÁΩÆ„ÄÇ</target>
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 191d2dfe090..20f98be86e0 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -76,9 +76,18 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                 {
                     using (FileStream s = File.OpenRead(stateFile))
                     {
-                        var translator = BinaryTranslator.GetReadTranslator(s, buffer: null);
+                        using var translator = BinaryTranslator.GetReadTranslator(s, buffer: null);
+
                         byte version = 0;
                         translator.Translate(ref version);
+                        // If the version is wrong, log a message not a warning. This could be a valid cache with the wrong version preventing correct deserialization.
+                        // For the latter case, internals may be unexpectedly null.
+                        if (version != CurrentSerializationVersion)
+                        {
+                            log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
+                            return null;
+                        }
+
                         var constructors = requiredReturnType.GetConstructors();
                         foreach (var constructor in constructors)
                         {
@@ -88,18 +97,8 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                                 retVal = constructor.Invoke(new object[] { translator }) as StateFileBase;
                             }
                         }
-
-                        // If retVal is still null or the version is wrong, log a message not a warning. This could be a valid cache with the wrong version preventing correct deserialization.
-                        // For the latter case, internals may be unexpectedly null.
-                        if (retVal == null || version != CurrentSerializationVersion)
-                        {
-                            // When upgrading to Visual Studio 2008 and running the build for the first time the resource cache files are replaced which causes a cast error due
-                            // to a new version number on the tasks class. "Unable to cast object of type 'Microsoft.Build.Tasks.SystemState' to type 'Microsoft.Build.Tasks.StateFileBase".
-                            // If there is an invalid cast, a message rather than a warning should be emitted.
-                            log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
-                            return null;
-                        }
-                        else if (!requiredReturnType.IsInstanceOfType(retVal))
+                        
+                        if (retVal == null || !requiredReturnType.IsInstanceOfType(retVal))
                         {
                             log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile,
                                 log.FormatResourceString("General.IncompatibleStateFileType"));
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
index fce9024bbde..b9816891b01 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index 7466d06bfc8..3feb3149cf9 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+Ôªø<?xml version="1.0" encoding="utf-8"?>
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
diff --git a/src/Xunit.NetCore.Extensions/Attributes/ActiveIssueAttribute.cs b/src/Xunit.NetCore.Extensions/Attributes/ActiveIssueAttribute.cs
deleted file mode 100644
index d4060615d87..00000000000
--- a/src/Xunit.NetCore.Extensions/Attributes/ActiveIssueAttribute.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-using Xunit.Sdk;
-
-namespace Xunit
-{
-    /// <summary>
-    /// Apply this attribute to your test method to specify an active issue.
-    /// </summary>
-    [TraitDiscoverer("Xunit.NetCore.Extensions.ActiveIssueDiscoverer", "Xunit.NetCore.Extensions")]
-    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = true)]
-    public class ActiveIssueAttribute : Attribute, ITraitAttribute
-    {
-        public ActiveIssueAttribute(int issueNumber, TestPlatforms platforms) { }
-        public ActiveIssueAttribute(string issue, TestPlatforms platforms) { }
-        public ActiveIssueAttribute(int issueNumber, TargetFrameworkMonikers framework) { }
-        public ActiveIssueAttribute(string issue, TargetFrameworkMonikers framework) { }
-        public ActiveIssueAttribute(int issueNumber, TestPlatforms platforms = TestPlatforms.Any, TargetFrameworkMonikers framework = (TargetFrameworkMonikers)0) { }
-        public ActiveIssueAttribute(string issue, TestPlatforms platforms = TestPlatforms.Any, TargetFrameworkMonikers framework = (TargetFrameworkMonikers)0) { }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Attributes/ConditionalFactAttribute.cs b/src/Xunit.NetCore.Extensions/Attributes/ConditionalFactAttribute.cs
deleted file mode 100644
index f0951064b1b..00000000000
--- a/src/Xunit.NetCore.Extensions/Attributes/ConditionalFactAttribute.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-using Xunit.Sdk;
-
-namespace Xunit
-{
-    [XunitTestCaseDiscoverer("Xunit.NetCore.Extensions.ConditionalFactDiscoverer", "Xunit.NetCore.Extensions")]
-    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
-    public sealed class ConditionalFactAttribute : FactAttribute
-    {
-        public Type     CalleeType { get; private set; }
-        public string[] ConditionMemberNames { get; private set; }
-
-        public ConditionalFactAttribute(Type calleeType, params string[] conditionMemberNames)
-        {
-            CalleeType = calleeType;
-            ConditionMemberNames = conditionMemberNames;
-        }
-
-        public ConditionalFactAttribute(params string[] conditionMemberNames)
-        {
-            ConditionMemberNames = conditionMemberNames;
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Attributes/ConditionalTheoryAttribute.cs b/src/Xunit.NetCore.Extensions/Attributes/ConditionalTheoryAttribute.cs
deleted file mode 100644
index 761f1ff4f1b..00000000000
--- a/src/Xunit.NetCore.Extensions/Attributes/ConditionalTheoryAttribute.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-using Xunit.Sdk;
-
-namespace Xunit
-{
-    [XunitTestCaseDiscoverer("Xunit.NetCore.Extensions.ConditionalTheoryDiscoverer", "Xunit.NetCore.Extensions")]
-    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
-    public sealed class ConditionalTheoryAttribute : TheoryAttribute
-    {
-        public Type     CalleeType { get; private set; }
-        public string[] ConditionMemberNames { get; private set; }
-
-        public ConditionalTheoryAttribute(Type calleeType, params string[] conditionMemberNames)
-        {
-            CalleeType = calleeType;
-            ConditionMemberNames = conditionMemberNames;
-        }
-
-        public ConditionalTheoryAttribute(params string[] conditionMemberNames)
-        {
-            ConditionMemberNames = conditionMemberNames;
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Attributes/OuterLoopAttribute.cs b/src/Xunit.NetCore.Extensions/Attributes/OuterLoopAttribute.cs
deleted file mode 100644
index d09a52f4787..00000000000
--- a/src/Xunit.NetCore.Extensions/Attributes/OuterLoopAttribute.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-using Xunit.Sdk;
-
-namespace Xunit
-{
-    /// <summary>
-    /// Apply this attribute to your test method to specify a outer-loop category.
-    /// </summary>
-    [TraitDiscoverer("Xunit.NetCore.Extensions.OuterLoopTestsDiscoverer", "Xunit.NetCore.Extensions")]
-    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = true)]
-    public class OuterLoopAttribute : Attribute, ITraitAttribute
-    {
-        public OuterLoopAttribute() { }
-        public OuterLoopAttribute(string reason) { }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Attributes/PlatformSpecificAttribute.cs b/src/Xunit.NetCore.Extensions/Attributes/PlatformSpecificAttribute.cs
deleted file mode 100644
index 50532884811..00000000000
--- a/src/Xunit.NetCore.Extensions/Attributes/PlatformSpecificAttribute.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-using Xunit.Sdk;
-
-namespace Xunit
-{
-    /// <summary>
-    /// Apply this attribute to your test method to specify this is a platform specific test.
-    /// </summary>
-    [TraitDiscoverer("Xunit.NetCore.Extensions.PlatformSpecificDiscoverer", "Xunit.NetCore.Extensions")]
-    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = false)]
-    public class PlatformSpecificAttribute : Attribute, ITraitAttribute
-    {
-        public PlatformSpecificAttribute(TestPlatforms platforms) { }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Attributes/SkipOnTargetFrameworkAttribute.cs b/src/Xunit.NetCore.Extensions/Attributes/SkipOnTargetFrameworkAttribute.cs
deleted file mode 100644
index c44881202aa..00000000000
--- a/src/Xunit.NetCore.Extensions/Attributes/SkipOnTargetFrameworkAttribute.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-using Xunit.Sdk;
-
-namespace Xunit
-{
-    /// <summary>
-    /// Apply this attribute to your test method to specify this is a platform specific test.
-    /// </summary>
-    [TraitDiscoverer("Xunit.NetCore.Extensions.SkipOnTargetFrameworkDiscoverer", "Xunit.NetCore.Extensions")]
-    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = true)]
-    public class SkipOnTargetFrameworkAttribute : Attribute, ITraitAttribute
-    {
-        public SkipOnTargetFrameworkAttribute(TargetFrameworkMonikers platform, string reason = null) { }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/ActiveIssueDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/ActiveIssueDiscoverer.cs
deleted file mode 100644
index 0839e333bf3..00000000000
--- a/src/Xunit.NetCore.Extensions/Discoverers/ActiveIssueDiscoverer.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq;
-using System.Runtime.InteropServices;
-using Xunit.Abstractions;
-using Xunit.Sdk;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This class discovers all of the tests and test classes that have
-    /// applied the ActiveIssue attribute
-    /// </summary>
-    public class ActiveIssueDiscoverer : ITraitDiscoverer
-    {
-        /// <summary>
-        /// Gets the trait values from the Category attribute.
-        /// </summary>
-        /// <param name="traitAttribute">The trait attribute containing the trait values.</param>
-        /// <returns>The trait values.</returns>
-        public IEnumerable<KeyValuePair<string, string>> GetTraits(IAttributeInfo traitAttribute)
-        {
-            IEnumerable<object> ctorArgs = traitAttribute.GetConstructorArguments();
-            Debug.Assert(ctorArgs.Count() >= 2);
-
-            string issue = ctorArgs.First().ToString();
-            TestPlatforms platforms = TestPlatforms.Any;
-            TargetFrameworkMonikers frameworks = (TargetFrameworkMonikers)0;
-            
-            foreach (object arg in ctorArgs.Skip(1)) // First argument is the issue number.
-            {
-                if (arg is TestPlatforms)
-                {
-                    platforms = (TestPlatforms)arg;
-                }
-                else if (arg is TargetFrameworkMonikers)
-                {
-                    frameworks = (TargetFrameworkMonikers)arg;
-                }
-            }
-        
-            if ((platforms.HasFlag(TestPlatforms.FreeBSD) && RuntimeInformation.IsOSPlatform(OSPlatform.Create("FREEBSD"))) ||
-                (platforms.HasFlag(TestPlatforms.Linux) && RuntimeInformation.IsOSPlatform(OSPlatform.Linux)) ||
-                (platforms.HasFlag(TestPlatforms.NetBSD) && RuntimeInformation.IsOSPlatform(OSPlatform.Create("NETBSD"))) ||
-                (platforms.HasFlag(TestPlatforms.OSX) && RuntimeInformation.IsOSPlatform(OSPlatform.OSX)) ||
-                (platforms.HasFlag(TestPlatforms.Windows) && RuntimeInformation.IsOSPlatform(OSPlatform.Windows)))
-            {
-                if (frameworks.HasFlag(TargetFrameworkMonikers.NetFramework))
-                    yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetfxTest);
-                if (frameworks.HasFlag(TargetFrameworkMonikers.Mono))
-                    yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonMonoTest);
-                if (frameworks.HasFlag(TargetFrameworkMonikers.Netcoreapp))
-                    yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetcoreappTest);
-                if (frameworks.HasFlag(TargetFrameworkMonikers.UapNotUapAot))
-                    yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonUapTest);
-                if (frameworks.HasFlag(TargetFrameworkMonikers.UapAot))
-                    yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonUapAotTest);
-                if (frameworks.HasFlag(TargetFrameworkMonikers.NetcoreCoreRT))
-                    yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetcoreCoreRTTest);
-                if (frameworks == (TargetFrameworkMonikers)0)
-                    yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.Failing);
-
-                yield return new KeyValuePair<string, string>(XunitConstants.ActiveIssue, issue);
-            }
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalFactDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalFactDiscoverer.cs
deleted file mode 100644
index 3ef2fc34e4b..00000000000
--- a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalFactDiscoverer.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System.Collections.Generic;
-using System.Linq;
-using Xunit.Abstractions;
-using Xunit.Sdk;
-
-namespace Xunit.NetCore.Extensions
-{
-    public class ConditionalFactDiscoverer : FactDiscoverer
-    {
-        private readonly IMessageSink _diagnosticMessageSink;
-
-        public ConditionalFactDiscoverer(IMessageSink diagnosticMessageSink) : base(diagnosticMessageSink)
-        {
-            _diagnosticMessageSink = diagnosticMessageSink;
-        }
-
-        public override IEnumerable<IXunitTestCase> Discover(
-            ITestFrameworkDiscoveryOptions discoveryOptions, ITestMethod testMethod, IAttributeInfo factAttribute)
-        {
-            IEnumerable<IXunitTestCase> testCases = base.Discover(discoveryOptions, testMethod, factAttribute);
-            return ConditionalTestDiscoverer.Discover(discoveryOptions, _diagnosticMessageSink, testMethod, testCases, factAttribute.GetConstructorArguments().ToArray());
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
deleted file mode 100644
index 1fc7269cd91..00000000000
--- a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
+++ /dev/null
@@ -1,165 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Reflection;
-using Xunit.Abstractions;
-using Xunit.Sdk;
-
-namespace Xunit.NetCore.Extensions
-{
-    // Internal helper class for code common to conditional test discovery through
-    // [ConditionalFact] and [ConditionalTheory]
-    internal class ConditionalTestDiscoverer
-    {
-        // This helper method evaluates the given condition member names for a given set of test cases.
-        // If any condition member evaluates to 'false', the test cases are marked to be skipped.
-        // The skip reason is the collection of all the condition members that evalated to 'false'.
-        internal static IEnumerable<IXunitTestCase> Discover(
-                                                        ITestFrameworkDiscoveryOptions discoveryOptions,
-                                                        IMessageSink diagnosticMessageSink,
-                                                        ITestMethod testMethod,
-                                                        IEnumerable<IXunitTestCase> testCases,
-                                                        object[] conditionArguments)
-        {
-            // A null or empty list of conditionMemberNames is treated as "no conditions".
-            // and the test cases will not be skipped.
-            // Example: [ConditionalFact()]
-            if (conditionArguments == null || conditionArguments.Length == 0)
-            {
-                return testCases;
-            }
-
-            string [] conditionMemberNames;
-
-            Type calleeType = conditionArguments[0] as Type;
-            if (calleeType != null)
-            {
-                if (conditionArguments.Length < 2)
-                {
-                    // [ConditionalFact(typeof(x))] no provided methods.
-                    return testCases;
-                }
-
-                // [ConditionalFact(typeof(x), "MethodName")]
-                conditionMemberNames = conditionArguments[1] as string[];
-            }
-            else
-            {
-                // [ConditionalFact("MethodName")]
-                conditionMemberNames = conditionArguments[0] as string[];
-            }
-
-            // [ConditionalFact((string[]) null)]
-            int conditionCount = conditionMemberNames == null ? 0 : conditionMemberNames.Count();
-            if (conditionCount == 0)
-            {
-                return testCases;
-            }
-
-            MethodInfo testMethodInfo = testMethod.Method.ToRuntimeMethod();
-            Type testMethodDeclaringType = testMethodInfo.DeclaringType;
-            List<string> falseConditions = new List<string>(conditionCount);
-
-            foreach (string entry in conditionMemberNames)
-            {
-                string conditionMemberName = entry;
-
-                // Null condition member names are silently tolerated
-                if (string.IsNullOrWhiteSpace(conditionMemberName))
-                {
-                    continue;
-                }
-
-                Type declaringType;
-
-                if (calleeType != null)
-                {
-                    declaringType = calleeType;
-                }
-                else
-                {
-                    declaringType = testMethodDeclaringType;
-
-                    string[] symbols = conditionMemberName.Split('.');
-                    if (symbols.Length == 2)
-                    {
-                        conditionMemberName = symbols[1];
-                        ITypeInfo type = testMethod.TestClass.Class.Assembly.GetTypes(false).Where(t => t.Name.Contains(symbols[0])).FirstOrDefault();
-                        if (type != null)
-                        {
-                            declaringType = type.ToRuntimeType();
-                        }
-                    }
-                }
-
-                MethodInfo conditionMethodInfo;
-                if ((conditionMethodInfo = LookupConditionalMethod(declaringType, conditionMemberName)) == null)
-                {
-                    return new[] 
-                    {
-                        new ExecutionErrorTestCase(
-                            diagnosticMessageSink,
-                            discoveryOptions.MethodDisplayOrDefault(),
-                            TestMethodDisplayOptions.None,
-                            testMethod,
-                            GetFailedLookupString(conditionMemberName, declaringType))
-                    };
-                }
-
-                // In the case of multiple conditions, collect the results of all
-                // of them to produce a summary skip reason.
-                try
-                {
-                    if (!(bool)conditionMethodInfo.Invoke(null, null))
-                    {
-                        falseConditions.Add(conditionMemberName);
-                    }
-                }
-                catch (Exception exc)
-                {
-                    falseConditions.Add($"{conditionMemberName} ({exc.GetType().Name})");
-                }
-            }
-
-            // Compose a summary of all conditions that returned false.
-            if (falseConditions.Count > 0)
-            {
-                string skippedReason = string.Format("Condition(s) not met: \"{0}\"", string.Join("\", \"", falseConditions));
-                return testCases.Select(tc => new SkippedTestCase(tc, skippedReason));
-            }
-
-            // No conditions returned false (including the absence of any conditions).
-            return testCases;
-        }
-
-        internal static string GetFailedLookupString(string name, Type type)
-        {
-            return
-                $"An appropriate member '{name}' could not be found. " +
-                $"The conditional method needs to be a static method or property on the type {type} or any ancestor, " +
-                "of any visibility, accepting zero arguments, and having a return type of Boolean.";
-        }
-        
-        internal static MethodInfo LookupConditionalMethod(Type t, string name)
-        {
-            if (t == null || name == null)
-                return null;
-
-            TypeInfo ti = t.GetTypeInfo();
-
-            MethodInfo mi = ti.GetDeclaredMethod(name);
-            if (mi?.IsStatic == true && mi.GetParameters().Length == 0 && mi.ReturnType == typeof(bool))
-                return mi;
-
-            PropertyInfo pi = ti.GetDeclaredProperty(name);
-            if (pi?.PropertyType == typeof(bool) && pi.GetMethod?.IsStatic == true && pi.GetMethod.GetParameters().Length == 0)
-                return pi.GetMethod;
-
-            return LookupConditionalMethod(ti.BaseType, name);
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTheoryDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTheoryDiscoverer.cs
deleted file mode 100644
index b4b6e5b1ff7..00000000000
--- a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTheoryDiscoverer.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System.Collections.Generic;
-using System.Linq;
-using Xunit.Abstractions;
-using Xunit.Sdk;
-
-namespace Xunit.NetCore.Extensions
-{
-    public class ConditionalTheoryDiscoverer : TheoryDiscoverer
-    {
-        private readonly IMessageSink _diagnosticMessageSink;
-
-        public ConditionalTheoryDiscoverer(IMessageSink diagnosticMessageSink) : base(diagnosticMessageSink)
-        {
-            _diagnosticMessageSink = diagnosticMessageSink;
-        }
-
-        public override IEnumerable<IXunitTestCase> Discover(
-            ITestFrameworkDiscoveryOptions discoveryOptions, ITestMethod testMethod, IAttributeInfo theoryAttribute)
-        {
-            IEnumerable<IXunitTestCase> testCases = base.Discover(discoveryOptions, testMethod, theoryAttribute);
-            return ConditionalTestDiscoverer.Discover(discoveryOptions, _diagnosticMessageSink, testMethod, testCases, theoryAttribute.GetConstructorArguments().ToArray());
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/OuterLoopTestsDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/OuterLoopTestsDiscoverer.cs
deleted file mode 100644
index db67037d84f..00000000000
--- a/src/Xunit.NetCore.Extensions/Discoverers/OuterLoopTestsDiscoverer.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System.Collections.Generic;
-using Xunit.Abstractions;
-using Xunit.Sdk;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This class discovers all of the tests and test classes that have
-    /// applied the OuterLoop attribute
-    /// </summary>
-    public class OuterLoopTestsDiscoverer : ITraitDiscoverer
-    {
-        /// <summary>
-        /// Gets the trait values from the Category attribute.
-        /// </summary>
-        /// <param name="traitAttribute">The trait attribute containing the trait values.</param>
-        /// <returns>The trait values.</returns>
-        public IEnumerable<KeyValuePair<string, string>> GetTraits(IAttributeInfo traitAttribute)
-        {
-            yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.OuterLoop);
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/PlatformSpecificDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/PlatformSpecificDiscoverer.cs
deleted file mode 100644
index ce3b9e4b99f..00000000000
--- a/src/Xunit.NetCore.Extensions/Discoverers/PlatformSpecificDiscoverer.cs
+++ /dev/null
@@ -1,38 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System.Linq;
-using System.Collections.Generic;
-using Xunit.Abstractions;
-using Xunit.Sdk;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This class discovers all of the tests and test classes that have
-    /// applied the PlatformSpecific attribute
-    /// </summary>
-    public class PlatformSpecificDiscoverer : ITraitDiscoverer
-    {
-        /// <summary>
-        /// Gets the trait values from the Category attribute.
-        /// </summary>
-        /// <param name="traitAttribute">The trait attribute containing the trait values.</param>
-        /// <returns>The trait values.</returns>
-        public IEnumerable<KeyValuePair<string, string>> GetTraits(IAttributeInfo traitAttribute)
-        {
-            TestPlatforms platforms = (TestPlatforms)traitAttribute.GetConstructorArguments().First();
-            if (!platforms.HasFlag(TestPlatforms.Windows))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonWindowsTest);
-            if (!platforms.HasFlag(TestPlatforms.Linux))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonLinuxTest);
-            if (!platforms.HasFlag(TestPlatforms.OSX))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonOSXTest);
-            if (!platforms.HasFlag(TestPlatforms.FreeBSD))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonFreeBSDTest);
-            if (!platforms.HasFlag(TestPlatforms.NetBSD))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetBSDTest);
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/SkipOnTargetFrameworkDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/SkipOnTargetFrameworkDiscoverer.cs
deleted file mode 100644
index 19f73d13a2a..00000000000
--- a/src/Xunit.NetCore.Extensions/Discoverers/SkipOnTargetFrameworkDiscoverer.cs
+++ /dev/null
@@ -1,62 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System.Linq;
-using System.Collections.Generic;
-using Xunit.Abstractions;
-using Xunit.Sdk;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>
-    /// This class discovers all of the tests and test classes that have
-    /// applied the TestOnTargetFrameworkDiscoverer attribute
-    /// </summary>
-    public class SkipOnTargetFrameworkDiscoverer : ITraitDiscoverer
-    {
-        /// <summary>
-        /// Gets the trait values from the Category attribute.
-        /// </summary>
-        /// <param name="traitAttribute">The trait attribute containing the trait values.</param>
-        /// <returns>The trait values.</returns>
-        public IEnumerable<KeyValuePair<string, string>> GetTraits(IAttributeInfo traitAttribute)
-        {
-            TargetFrameworkMonikers platform = (TargetFrameworkMonikers)traitAttribute.GetConstructorArguments().First();
-            if (platform.HasFlag(TargetFrameworkMonikers.Net45))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNet45Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.Net451))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNet451Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.Net452))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNet452Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.Net46))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNet46Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.Net461))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNet461Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.Net462))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNet462Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.Net463))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNet463Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.Netcore50))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetcore50Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.Netcore50aot))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetcore50aotTest);
-            if (platform.HasFlag(TargetFrameworkMonikers.Netcoreapp1_0))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetcoreapp1_0Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.Netcoreapp1_1))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetcoreapp1_1Test);
-            if (platform.HasFlag(TargetFrameworkMonikers.NetFramework))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetfxTest);
-            if (platform.HasFlag(TargetFrameworkMonikers.Mono))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonMonoTest);
-            if (platform.HasFlag(TargetFrameworkMonikers.Netcoreapp))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetcoreappTest);
-            if (platform.HasFlag(TargetFrameworkMonikers.UapNotUapAot))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonUapTest);
-            if (platform.HasFlag(TargetFrameworkMonikers.UapAot))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonUapAotTest);
-            if (platform.HasFlag(TargetFrameworkMonikers.NetcoreCoreRT))
-                yield return new KeyValuePair<string, string>(XunitConstants.Category, XunitConstants.NonNetcoreCoreRTTest);
-        }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/README.md b/src/Xunit.NetCore.Extensions/README.md
deleted file mode 100644
index 537725d4f33..00000000000
--- a/src/Xunit.NetCore.Extensions/README.md
+++ /dev/null
@@ -1 +0,0 @@
-# Xunit.NetCore.Extensions
\ No newline at end of file
diff --git a/src/Xunit.NetCore.Extensions/SkippedTestCase.cs b/src/Xunit.NetCore.Extensions/SkippedTestCase.cs
deleted file mode 100644
index 518f4ffa77a..00000000000
--- a/src/Xunit.NetCore.Extensions/SkippedTestCase.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-using System.Collections.Generic;
-using System.Threading;
-using System.Threading.Tasks;
-using Xunit.Abstractions;
-using Xunit.Sdk;
-
-namespace Xunit.NetCore.Extensions
-{
-    /// <summary>Wraps another test case that should be skipped.</summary>
-    internal sealed class SkippedTestCase : LongLivedMarshalByRefObject, IXunitTestCase
-    {
-        private readonly IXunitTestCase _testCase;
-        private readonly string _skippedReason;
-
-        public SkippedTestCase()
-        {
-
-        }
-
-        internal SkippedTestCase(IXunitTestCase testCase, string skippedReason)
-        {
-            _testCase = testCase;
-            _skippedReason = skippedReason;
-        }
-
-        public string DisplayName { get { return _testCase.DisplayName; } }
-
-        public IMethodInfo Method { get { return _testCase.Method; } }
-
-        public string SkipReason { get { return _skippedReason; } }
-
-        public ISourceInformation SourceInformation { get { return _testCase.SourceInformation; } set { _testCase.SourceInformation = value; } }
-
-        public ITestMethod TestMethod { get { return _testCase.TestMethod; } }
-
-        public object[] TestMethodArguments { get { return _testCase.TestMethodArguments; } }
-
-        public Dictionary<string, List<string>> Traits { get { return _testCase.Traits; } }
-
-        public string UniqueID { get { return _testCase.UniqueID; } }
-
-        public int Timeout { get { return _testCase.Timeout; } }
-
-        public Exception InitializationException
-        {
-            get { return _testCase.InitializationException; }
-        }
-
-        public void Deserialize(IXunitSerializationInfo info) { _testCase.Deserialize(info); }
-
-        public Task<RunSummary> RunAsync(
-            IMessageSink diagnosticMessageSink, IMessageBus messageBus, object[] constructorArguments,
-            ExceptionAggregator aggregator, CancellationTokenSource cancellationTokenSource)
-        {
-            return new XunitTestCaseRunner(this, DisplayName, _skippedReason, constructorArguments, TestMethodArguments, messageBus, aggregator, cancellationTokenSource).RunAsync();
-        }
-
-        public void Serialize(IXunitSerializationInfo info) { _testCase.Serialize(info); }
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/TargetFrameworkMonikers.cs b/src/Xunit.NetCore.Extensions/TargetFrameworkMonikers.cs
deleted file mode 100644
index 3091730edc7..00000000000
--- a/src/Xunit.NetCore.Extensions/TargetFrameworkMonikers.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-Ôªø// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-
-namespace Xunit
-{
-    [Flags]
-    public enum TargetFrameworkMonikers
-    {
-        Net45 = 0x1,
-        Net451 = 0x2,
-        Net452 = 0x4,
-        Net46 = 0x8,
-        Net461 = 0x10,
-        Net462 = 0x20,
-        Net463 = 0x40,
-        Netcore50 = 0x80,
-        Netcore50aot = 0x100,
-        Netcoreapp1_0 = 0x200,
-        Netcoreapp1_1 = 0x400,
-        NetFramework = 0x800,
-        Netcoreapp = 0x1000,
-        UapNotUapAot = 0x2000,
-        UapAot = 0x4000,
-        Uap = UapAot | UapNotUapAot,
-        NetcoreCoreRT = 0x8000,
-        Mono = 0x10000
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/TestPlatforms.cs b/src/Xunit.NetCore.Extensions/TestPlatforms.cs
deleted file mode 100644
index fe905803bec..00000000000
--- a/src/Xunit.NetCore.Extensions/TestPlatforms.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-using System;
-
-namespace Xunit
-{
-    [Flags]
-    public enum TestPlatforms
-    {
-        Windows = 1,
-        Linux = 2,
-        OSX = 4,
-        FreeBSD = 8,
-        NetBSD = 16,
-        AnyUnix = FreeBSD | Linux | NetBSD | OSX,
-        Any = ~0
-    }
-}
diff --git a/src/Xunit.NetCore.Extensions/XunitConstants.cs b/src/Xunit.NetCore.Extensions/XunitConstants.cs
deleted file mode 100644
index 02d08d297f1..00000000000
--- a/src/Xunit.NetCore.Extensions/XunitConstants.cs
+++ /dev/null
@@ -1,43 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-// See the LICENSE file in the project root for more information.
-
-namespace Xunit.NetCore.Extensions
-{
-    public struct XunitConstants
-    {
-        internal const string NonFreeBSDTest = "nonfreebsdtests";
-        internal const string NonLinuxTest = "nonlinuxtests";
-        internal const string NonNetBSDTest = "nonnetbsdtests";
-        internal const string NonOSXTest = "nonosxtests";
-        internal const string NonWindowsTest = "nonwindowstests";
-
-        internal const string NonNet45Test = "nonnet45tests";
-        internal const string NonNet451Test = "nonnet451tests";
-        internal static string NonNet452Test = "nonnet452tests";
-        internal static string NonNet46Test = "nonnet46tests";
-        internal static string NonNet461Test = "nonnet461tests";
-        internal static string NonNet462Test = "nonnet462tests";
-        internal static string NonNet463Test = "nonnet463tests";
-        internal static string NonNetcore50Test = "nonnetcore50tests";
-        internal static string NonNetcore50aotTest = "nonnetcore50aottests";
-        internal static string NonNetcoreapp1_0Test = "nonnetcoreapp1.0tests";
-        internal static string NonNetcoreapp1_1Test = "nonnetcoreapp1.1tests";
-
-        //Non version framework constants
-        internal static string NonNetfxTest = "nonnetfxtests";
-        internal static string NonMonoTest = "nonmonotests";
-        internal static string NonUapTest = "nonuaptests";
-        internal static string NonUapAotTest = "nonuapaottests";
-        internal static string NonNetcoreappTest = "nonnetcoreapptests";
-        internal static string NonNetcoreCoreRTTest = "nonnetcorecorerttests";
-
-        internal const string Failing = "failing";
-        internal const string ActiveIssue = "activeissue";
-        internal const string OuterLoop = "outerloop";
-
-        public const string Category = "category";
-        public const string IgnoreForCI = "ignoreforci";
-        public const string RequiresElevation = "requireselevation";
-    }
-}
