diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index fc93e2a1ae1..62e411ac638 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -4,8 +4,11 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
@@ -84,7 +87,7 @@ public void StaticGraphShouldNotSupportNestedSolutions()
                     new ProjectGraph(root.Path);
                 });
 
-            exception.Message.ShouldContain("MSB4264:");
+            exception.Message.ShouldContain("MSB4263:");
         }
 
         public static IEnumerable<object[]> Graphs
@@ -256,6 +259,398 @@ public void SolutionParserIgnoresProjectConfigurationsThatDoNotFullyMatchAnySolu
             graph.ProjectNodes.ShouldBeEmpty();
         }
 
+        public static IEnumerable<object[]> SolutionOnlyDependenciesData
+        {
+            get
+            {
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]> //graph nodes and ProjectReference edges
+                    {
+                        {1, null},
+                        {2, null}
+                    },
+                    new[] {(1, 2)}, // solution only edges
+                    false, // is there a cycle
+                    false // solution edges overlap with graph edges
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null},
+                        {2, null}
+                    },
+                    new[] {(1, 2), (2, 1)},
+                    true,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null},
+                        {2, null},
+                        {3, null},
+                        {4, null},
+                        {5, null}
+                    },
+                    new[] {(1, 2), (1, 3), (2, 4), (3,4), (4, 5)},
+                    false,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null},
+                        {2, null},
+                        {3, null},
+                        {4, null},
+                        {5, null}
+                    },
+                    new[] {(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 3)},
+                    false,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, null},
+                        {2, null},
+                        {3, null},
+                        {4, null},
+                        {5, null}
+                    },
+                    new[] {(1, 3), (2, 3), (3, 4), (3, 5), (5, 4), (2, 1)},
+                    false,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{2}},
+                    },
+                    new[] {(1, 2)},
+                    false,
+                    true
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{2}},
+                    },
+                    new[] {(1, 2), (1, 2)},
+                    false,
+                    true
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{2}},
+                    },
+                    new[] {(2, 1)},
+                    true,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{2, 3}},
+                        {2, new []{4}},
+                        {3, new []{4}},
+                        {4, new []{5}},
+                        {5, null}
+                    },
+                    new[] {(3, 2)},
+                    false,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{2, 3}},
+                        {2, new []{4}},
+                        {3, new []{4}},
+                        {4, new []{5}},
+                        {5, null}
+                    },
+                    new[] {(1, 2), (1, 3), (3, 2), (1, 5)},
+                    false,
+                    true
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{2, 3}},
+                        {2, new []{4}},
+                        {3, new []{4}},
+                        {4, new []{5}},
+                        {5, null}
+                    },
+                    new[] {(3, 2), (5, 3)},
+                    true,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new []{2, 3}},
+                        {2, new []{4}},
+                        {3, new []{4}},
+                        {4, new []{5}},
+                        {5, null}
+                    },
+                    new[] {(5, 3)},
+                    true,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}},
+                        {2, new[] {3}},
+                        {3, new[] {4}},
+                    },
+                    new[] {(1,3), (2, 4)},
+                    false,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}},
+                        {2, new[] {3}},
+                        {3, new[] {4}},
+                    },
+                    new[] {(1,3), (2, 4), (1, 2), (2, 3), (3, 4)},
+                    false,
+                    true
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}},
+                        {3, null},
+                        {4, null}
+                    },
+                    new[] {(3, 2), (2, 4)},
+                    false,
+                    false
+                };
+
+                yield return new object[]
+                {
+                    new Dictionary<int, int[]>
+                    {
+                        {1, new[] {2}},
+                        {3, null},
+                        {4, null}
+                    },
+                    new[] {(3, 2), (2, 4), (4, 1)},
+                    true,
+                    false
+                };
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(SolutionOnlyDependenciesData))]
+        public void SolutionsCanInjectEdgesIntoTheProjectGraph(Dictionary<int, int[]> edges, (int, int)[] solutionDependencies, bool hasCycle, bool solutionEdgesOverlapGraphEdges)
+        {
+            // Use the same global properties as the solution would use so all ConfigurationMetadata objects would match on global properties.
+            var graph = CreateProjectGraph(
+                _env,
+                edges,
+                new Dictionary<string, string>()
+                {
+                    {"Configuration", "Debug"},
+                    {"Platform", "AnyCPU"}
+                });
+
+            // Use ConfigutationMetadata because it is IEquatable, whereas ProjectGraphNode is node.
+            var graphEdges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
+
+            var solutionContents =
+                SolutionFileBuilder.FromGraph(
+                    graph,
+                    solutionDependencies: solutionDependencies.Select(dependency => (dependency.Item1.ToString(), dependency.Item2.ToString())).ToArray())
+                    .BuildSolution();
+            var solutionFile = _env.CreateFile("solution.sln", solutionContents).Path;
+
+            Exception exception = null;
+
+            ProjectGraph graphFromSolution = null;
+
+            try
+            {
+                graphFromSolution = new ProjectGraph(solutionFile);
+            }
+            catch (Exception e)
+            {
+                exception = e;
+            }
+
+            if (hasCycle)
+            {
+                exception.ShouldNotBeNull();
+                exception.Message.ShouldContain("MSB4251");
+
+                return;
+            }
+
+            exception.ShouldBeNull();
+
+            var graphFromSolutionEdges = graphFromSolution.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
+
+            // Original edges get preserved.
+            foreach (var graphEdge in graphEdges)
+            {
+                graphFromSolutionEdges.Keys.ShouldContain(graphEdge.Key);
+            }
+
+            // Solution edges get added. Assert each solution dependency is found within the graph edges
+            var solutionOnlyEdges = graphFromSolutionEdges.Keys.Except(graphEdges.Keys).ToList();
+
+            foreach (var solutionDependency in solutionDependencies)
+            {
+                if (!solutionEdgesOverlapGraphEdges)
+                {
+                    solutionOnlyEdges.ShouldContain(edge => EdgeCompliesWithSolutionDependency(edge, solutionDependency));
+                }
+
+                graphFromSolutionEdges.Keys.ShouldContain(edge => EdgeCompliesWithSolutionDependency(edge, solutionDependency));
+
+                solutionOnlyEdges.RemoveAll(edge => EdgeCompliesWithSolutionDependency(edge, solutionDependency));
+            }
+
+            // no extra edges get added
+            solutionOnlyEdges.ShouldBeEmpty();
+        }
+
+        [Fact]
+        public void SolutionEdgesShouldNotOverwriteProjectReferenceEdges()
+        {
+            var solutionContents = SolutionFileBuilder.FromGraphEdges(
+                _env,
+                new Dictionary<int, int[]>()
+                {
+                    {1, new[] {2}}
+                }).BuildSolution();
+
+            var graph = new ProjectGraph(_env.CreateFile("solution.sln", solutionContents).Path);
+
+            var edges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
+
+            edges.Count.ShouldBe(1);
+
+            edges.First().Value.ItemType.ShouldBe(ItemTypeNames.ProjectReference);
+        }
+
+        [Fact]
+        public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()
+        {
+            var solutionContents = new SolutionFileBuilder
+            {
+                Projects = new Dictionary<string, string>
+                {
+                    {"1", GraphTestingUtilities.CreateProjectFile(_env, 1, new[] {2}).Path},
+                    {"2", GraphTestingUtilities.CreateProjectFile(_env, 2, extraContent: MultitargetingSpecification).Path},
+                    {"3", GraphTestingUtilities.CreateProjectFile(_env, 3, new[] {4}, extraContent: MultitargetingSpecification).Path},
+                    {"4", GraphTestingUtilities.CreateProjectFile(_env, 4).Path}
+                },
+                SolutionDependencies = new[] {("1", "2"), ("3", "4")}
+            }.BuildSolution();
+
+            var graph = new ProjectGraph(_env.CreateFile("solution.sln", solutionContents).Path);
+
+            var edges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
+            edges.Count.ShouldBe(8);
+
+            var node1 = GetFirstNodeWithProjectNumber(graph, 1);
+            node1.ProjectReferences.Count.ShouldBe(3);
+            node1.ProjectReferences.Count(r => GetProjectNumber(r) == 2).ShouldBe(3);
+            GetOutgoingEdgeItemsFromNode(node1, edges).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));
+
+            var outerBuild3 = GetOuterBuild(graph, 3);
+            outerBuild3.ProjectReferences.Count.ShouldBe(3);
+            outerBuild3.ProjectReferences.Count(r => GetProjectNumber(r) == 3).ShouldBe(2);
+            outerBuild3.ProjectReferences.Count(r => GetProjectNumber(r) == 4).ShouldBe(1);
+
+            GetInnerBuilds(graph, 3).SelectMany(n => n.ProjectReferences).Count(r => GetProjectNumber(r) == 4).ShouldBe(2);
+            GetInnerBuilds(graph, 3).SelectMany(n => GetIncomingEdgeItemsToNode(n, edges)).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));
+            GetInnerBuilds(graph, 3).SelectMany(n => GetOutgoingEdgeItemsFromNode(n, edges)).ShouldAllBe(edgeItem => !IsSolutionItemReference(edgeItem));
+
+            IEnumerable<ProjectItemInstance> GetOutgoingEdgeItemsFromNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> edgeInfos)
+            {
+                return edgeInfos.Where(e => e.Key.Item1.Equals(node.ToConfigurationMetadata())).Select(e => e.Value);
+            }
+
+            IEnumerable<ProjectItemInstance> GetIncomingEdgeItemsToNode(ProjectGraphNode node, IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> edgeInfos)
+            {
+                return edgeInfos.Where(e => e.Key.Item2.Equals(node.ToConfigurationMetadata())).Select(e => e.Value);
+            }
+        }
+
+        [Fact]
+        public void GraphConstructionShouldThrowOnMissingSolutionDependencies()
+        {
+            _env.DoNotLaunchDebugger();
+
+            var solutionContents = SolutionFileBuilder.FromGraphEdges(
+                _env,
+                new Dictionary<int, int[]> {{1, null}, {2, null}},
+                new[] {("1", new[] {Guid.NewGuid().ToString("B")})}).BuildSolution();
+
+            var solutionFile = _env.CreateFile(
+                "solution.sln",
+                solutionContents)
+                .Path;
+
+            var exception = Should.Throw<InvalidProjectFileException>(
+                () =>
+                {
+                    new ProjectGraph(solutionFile);
+                });
+
+            exception.Message.ShouldContain("but a project with this GUID was not found in the .SLN file");
+        }
+
+        private static bool IsSolutionItemReference(ProjectItemInstance edgeItem)
+        {
+            return edgeItem.ItemType == GraphBuilder.SolutionItemReference;
+        }
+
+        private static bool EdgeCompliesWithSolutionDependency((ConfigurationMetadata, ConfigurationMetadata) edge, (int, int) solutionDependency)
+        {
+            return GetProjectNumber(edge.Item1) == solutionDependency.Item1 && GetProjectNumber(edge.Item2) == solutionDependency.Item2;
+        }
+
         private void AssertSolutionBasedGraph(
             Dictionary<int, int[]> edges,
             SolutionConfigurationInSolution currentSolutionConfiguration,
@@ -263,15 +658,9 @@ private void AssertSolutionBasedGraph(
             Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>> projectConfigurations = null)
         {
             var graph = CreateProjectGraph(_env, edges);
+            var graphEdges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
 
-            var solutionFileBuilder = new SolutionFileBuilder
-            {
-                Projects = graph.ProjectNodes.ToDictionary(
-                    n => GetProjectNumber(n)
-                        .ToString(),
-                    n => n.ProjectInstance.FullPath),
-                ProjectConfigurations = projectConfigurations
-            };
+            var solutionFileBuilder = SolutionFileBuilder.FromGraph(graph, projectConfigurations);
 
             var solutionContents = solutionFileBuilder.BuildSolution();
 
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index fcc6df14ddc..42cddef429a 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -3,10 +3,13 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
 using System.Text;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.Utilities;
 using Shouldly;
@@ -15,6 +18,114 @@ namespace Microsoft.Build.Experimental.Graph.UnitTests
 {
     internal static class GraphTestingUtilities
     {
+        public static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> {{PropertyNames.IsGraphBuild, "true"}}.ToImmutableDictionary();
+
+        public static readonly string InnerBuildPropertyName = "InnerBuild";
+
+        public static readonly string MultitargetingSpecification = $@"<PropertyGroup>
+                                                                        <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>
+                                                                        <InnerBuildPropertyValues>InnerBuildProperties</InnerBuildPropertyValues>
+                                                                        <InnerBuildProperties>a;b</InnerBuildProperties>
+                                                                     </PropertyGroup>";
+
+        public static void AssertOuterBuildAsNonRoot(
+            ProjectGraphNode outerBuild,
+            ProjectGraph graph,
+            Dictionary<string, string> additionalGlobalProperties = null,
+            int expectedInnerBuildCount = 2)
+        {
+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+
+            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
+
+            outerBuild.ProjectReferences.ShouldBeEmpty();
+            outerBuild.ReferencingProjects.ShouldNotBeEmpty();
+
+            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)
+            {
+                var innerBuilds =
+                    outerBuildReferencer.ProjectReferences.Where(
+                        p =>
+                            IsInnerBuild(p) 
+                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();
+
+                innerBuilds.Length.ShouldBe(expectedInnerBuildCount);
+
+                foreach (var innerBuild in innerBuilds)
+                {
+                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
+
+                    innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);
+                    innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);
+
+                    graph.TestOnly_Edges.TestOnly_HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
+
+                    var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
+                    var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
+
+                    edgeToOuterBuild.ShouldBe(edgeToInnerBuild);
+                }
+            }
+        }
+
+        public static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)
+        {
+            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+
+            IsNotMultitargeting(node).ShouldBeTrue();
+            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+            node.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
+        }
+
+        public static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)
+        {
+            additionalGlobalProperties.ShouldNotBeNull();
+
+            IsOuterBuild(outerBuild).ShouldBeTrue();
+            IsInnerBuild(outerBuild).ShouldBeFalse();
+
+            outerBuild.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
+            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
+        }
+
+        public static void AssertInnerBuildEvaluation(
+            ProjectGraphNode innerBuild,
+            bool InnerBuildPropertyIsSetViaGlobalProperty,
+            Dictionary<string, string> additionalGlobalProperties)
+        {
+            additionalGlobalProperties.ShouldNotBeNull();
+
+            IsOuterBuild(innerBuild).ShouldBeFalse();
+            IsInnerBuild(innerBuild).ShouldBeTrue();
+
+            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildPropertyName);
+
+            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();
+
+            if (InnerBuildPropertyIsSetViaGlobalProperty)
+            {
+                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(
+                    EmptyGlobalProperties
+                        .Add(InnerBuildPropertyName, innerBuildPropertyValue)
+                        .AddRange(additionalGlobalProperties));
+            }
+        }
+
+        internal static bool IsOuterBuild(ProjectGraphNode project)
+        {
+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;
+        }
+
+        internal static bool IsInnerBuild(ProjectGraphNode project)
+        {
+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;
+        }
+
+        internal static bool IsNotMultitargeting(ProjectGraphNode project)
+        {
+            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;
+        }
+
         internal static ProjectGraphNode GetFirstNodeWithProjectNumber(ProjectGraph graph, int projectNum)
         {
             return GetNodesWithProjectNumber(graph, projectNum).First();
@@ -25,18 +136,55 @@ internal static IEnumerable<ProjectGraphNode> GetNodesWithProjectNumber(ProjectG
             return graph.ProjectNodes.Where(node => node.ProjectInstance.FullPath.EndsWith(projectNum + ".proj"));
         }
 
+        internal static ProjectGraphNode GetOuterBuild(ProjectGraph graph, int projectNumber)
+        {
+            return GetNodesWithProjectNumber(graph, projectNumber).FirstOrDefault(IsOuterBuild);
+        }
+
+        internal static IReadOnlyCollection<ProjectGraphNode> GetInnerBuilds(ProjectGraph graph, int projectNumber)
+        {
+            var outerBuild = GetOuterBuild(graph, projectNumber);
+
+            if (outerBuild == null)
+            {
+                return ImmutableArray<ProjectGraphNode>.Empty;
+            }
+            else
+            {
+                var innerBuilds = GetNodesWithProjectNumber(graph, projectNumber)
+                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath.Equals(outerBuild.ProjectInstance.FullPath))
+                    .ToArray();
+
+                innerBuilds.ShouldNotBeEmpty();
+
+                return innerBuilds;
+            }
+        }
+
         internal static string GetProjectFileName(ProjectGraphNode node)
         {
             node.ShouldNotBeNull();
             return Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);
         }
 
+        internal static string GetProjectFileName(ConfigurationMetadata config)
+        {
+            config.ShouldNotBeNull();
+            return Path.GetFileNameWithoutExtension(config.ProjectFullPath);
+        }
+
         internal static int GetProjectNumber(ProjectGraphNode node)
         {
             node.ShouldNotBeNull();
             return int.Parse(GetProjectFileName(node));
         }
 
+        internal static int GetProjectNumber(ConfigurationMetadata config)
+        {
+            config.ShouldNotBeNull();
+            return int.Parse(GetProjectFileName(config));
+        }
+
         internal static string GetProjectPath(ProjectGraphNode node)
         {
             node.ShouldNotBeNull();
@@ -64,104 +212,189 @@ internal static TransientTestFile CreateProjectFile(
     }
 
     internal class SolutionFileBuilder
+    {
+        public static readonly IReadOnlyCollection<SolutionConfigurationInSolution> SolutionConfigurationPlatformsDefaults = new[]
+        {
+            new SolutionConfigurationInSolution("Debug", "AnyCPU"),
+            new SolutionConfigurationInSolution("Release", "AnyCPU")
+        };
+
+        /// <summary>
+        /// projectName -> projectPath
+        /// </summary>
+        public IReadOnlyDictionary<string, string> Projects { get; set; }
+
+        public IReadOnlyCollection<SolutionConfigurationInSolution> SolutionConfigurationPlatforms { get; set; } = SolutionConfigurationPlatformsDefaults;
+
+        public Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>> ProjectConfigurations { get; set; }
+
+        public (string, string)[] SolutionDependencies { get; set; }
+        public (string, string[])[] SolutionDependenciesProjectNameToGuids { get; set; }
+
+        private readonly struct ProjectInfo
         {
-            public static readonly IReadOnlyCollection<SolutionConfigurationInSolution> SolutionConfigurationPlatformsDefaults = new[]
+            private readonly List<ProjectInfo> _dependencies;
+            private readonly List<string> _dependencyGuids;
+            public string Name { get; }
+            public string Path { get; }
+            public string ProjectTypeGuid { get; }
+            public string Guid { get; }
+
+            public IReadOnlyCollection<ProjectInfo> Dependencies => _dependencies;
+
+            public IReadOnlyCollection<string> DependencyGuids => _dependencyGuids;
+
+            public ProjectInfo(string name, string path, string projectTypeGuid, string guid)
             {
-                new SolutionConfigurationInSolution("Debug", "AnyCPU"),
-                new SolutionConfigurationInSolution("Release", "AnyCPU")
-            };
+                Name = name;
+                Path = path;
+                ProjectTypeGuid = projectTypeGuid;
+                Guid = guid;
+                _dependencies = new List<ProjectInfo>();
+                _dependencyGuids = new List<string>();
+            }
 
-            /// <summary>
-            /// projectName -> projectPath
-            /// </summary>
-            public IReadOnlyDictionary<string, string> Projects { get; set; }
+            public void AddDependency(ProjectInfo dependency)
+            {
+                _dependencies.Add(dependency);
+            }
 
-            public IReadOnlyCollection<SolutionConfigurationInSolution> SolutionConfigurationPlatforms { get; set; } = SolutionConfigurationPlatformsDefaults;
-            public Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>> ProjectConfigurations { get; set; }
+            internal void AddGuidDependencies(string[] dependencyGuids)
+            {
+                _dependencyGuids.AddRange(dependencyGuids);
+            }
+        }
 
-            readonly struct ProjectInSolution
+        public static SolutionFileBuilder FromGraphEdges(
+            TestEnvironment env,
+            Dictionary<int, int[]> edges,
+            (string, string[])[] solutionDependenciesProjectNameToGuids = null)
+        {
+            return FromGraph(Helpers.CreateProjectGraph(env, edges), solutionDependenciesProjectNameToGuids: solutionDependenciesProjectNameToGuids);
+        }
+
+        public static SolutionFileBuilder FromGraph(
+            ProjectGraph graph,
+            Dictionary<string, Dictionary<SolutionConfigurationInSolution, ProjectConfigurationInSolution>> projectConfigurations = null,
+            (string, string)[] solutionDependencies = null,
+            (string, string[])[] solutionDependenciesProjectNameToGuids = null)
+        {
+            return new SolutionFileBuilder
             {
-                public string Name { get; }
-                public string Path { get; }
-                public string ProjectTypeGuid { get; }
-                public string Guid { get; }
+                Projects = graph.ProjectNodes.ToDictionary(
+                    n => GraphTestingUtilities.GetProjectNumber(n).ToString(),
+                    n => n.ProjectInstance.FullPath),
+                ProjectConfigurations = projectConfigurations,
+                SolutionDependencies = solutionDependencies,
+                SolutionDependenciesProjectNameToGuids = solutionDependenciesProjectNameToGuids
+            };
+        }
 
-                public ProjectInSolution(string name, string path, string projectTypeGuid, string guid)
+        public string BuildSolution()
+        {
+            var projectInfos = Projects.ToDictionary(
+                kvp => kvp.Key,
+                kvp => new ProjectInfo(
+                    kvp.Key,
+                    kvp.Value,
+                    "{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}",
+                    Guid.NewGuid()
+                        .ToString("B")));
+
+            if (SolutionDependencies != null && SolutionDependencies.Length > 0)
+            {
+                foreach (var (parent, dependency) in SolutionDependencies)
                 {
-                    Name = name;
-                    Path = path;
-                    ProjectTypeGuid = projectTypeGuid;
-                    Guid = guid;
+                    projectInfos.ShouldContainKey(parent);
+                    projectInfos.ShouldContainKey(dependency);
+
+                    projectInfos[parent].AddDependency(projectInfos[dependency]); 
                 }
             }
 
-            public string BuildSolution()
+            if (SolutionDependenciesProjectNameToGuids!= null && SolutionDependenciesProjectNameToGuids.Length > 0)
             {
-                var projectInfo = Projects.ToDictionary(
-                    kvp => kvp.Key,
-                    kvp => new ProjectInSolution(
-                        kvp.Key,
-                        kvp.Value,
-                        "{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}",
-                        Guid.NewGuid()
-                            .ToString("B")));
-
-                ProjectConfigurations = ProjectConfigurations ?? projectInfo.ToDictionary(
-                        p => p.Key,
-                        p => SolutionConfigurationPlatforms.ToDictionary(
-                                sc => sc,
-                                sc => new ProjectConfigurationInSolution(
-                                    configurationName: sc.ConfigurationName,
-                                    platformName: sc.PlatformName,
-                                    includeInBuild: true)
-                            )
-                    );
-
-                var sb = new StringBuilder();
+                foreach (var (parent, dependencyGuids) in SolutionDependenciesProjectNameToGuids)
+                {
+                    projectInfos.ShouldContainKey(parent);
+                    projectInfos[parent].AddGuidDependencies(dependencyGuids);
+                }
+            }
 
-                sb.AppendLine($@"
+            ProjectConfigurations = ProjectConfigurations ?? projectInfos.ToDictionary(
+                p => p.Key,
+                p => SolutionConfigurationPlatforms.ToDictionary(
+                    sc => sc,
+                    sc => new ProjectConfigurationInSolution(
+                        sc.ConfigurationName,
+                        sc.PlatformName,
+                        true)
+                    )
+                );
+
+            var sb = new StringBuilder();
+
+            sb.AppendLine($@"
 Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio Version {VisualStudioVersion.VersionLatest}
 VisualStudioVersion = {VisualStudioVersion.VersionLatest}.0.0.0
 MinimumVisualStudioVersion = 10.0.40219.1");
 
-                foreach (var project in projectInfo.Values)
+            foreach (var project in projectInfos.Values)
+            {
+                sb.AppendLine($@"
+Project(""{project.ProjectTypeGuid}"") = ""{project.Name}"", ""{project.Path}"", ""{project.Guid}""");
+
+                if (project.Dependencies.Count > 0 || project.DependencyGuids.Count > 0)
                 {
-                    sb.AppendLine($@"
-Project(""{project.ProjectTypeGuid}"") = ""{project.Name}"", ""{project.Path}"", ""{project.Guid}""
-EndProject
-");
-                }
+                    sb.AppendLine($"\tProjectSection(ProjectDependencies) = postProject");
 
-                sb.AppendLine("Global");
+                    foreach (var dependency in project.Dependencies)
+                    {
+                        sb.AppendLine($"\t\t{dependency.Guid} = {dependency.Guid}");
+                    }
 
-                sb.AppendLine("\tGlobalSection(SolutionConfigurationPlatforms) = preSolution");
+                    foreach (var dependencyGuid in project.DependencyGuids)
+                    {
+                        sb.AppendLine($"\t\t{dependencyGuid} = {dependencyGuid}");
+                    }
 
-                foreach (var solutionConfigurationPlatform in SolutionConfigurationPlatforms)
-                {
-                    sb.AppendLine($"\t\t{solutionConfigurationPlatform.FullName} = {solutionConfigurationPlatform.FullName}");
+                    sb.AppendLine($"\tEndProjectSection");
                 }
 
-                sb.AppendLine("\tEndGlobalSection");
+                sb.AppendLine($@"
+EndProject");
+            }
+
+            sb.AppendLine("Global");
+
+            sb.AppendLine("\tGlobalSection(SolutionConfigurationPlatforms) = preSolution");
+
+            foreach (var solutionConfigurationPlatform in SolutionConfigurationPlatforms)
+            {
+                sb.AppendLine($"\t\t{solutionConfigurationPlatform.FullName} = {solutionConfigurationPlatform.FullName}");
+            }
 
-                sb.AppendLine("\tGlobalSection(ProjectConfigurationPlatforms) = postSolution");
+            sb.AppendLine("\tEndGlobalSection");
 
-                foreach (var project in projectInfo)
+            sb.AppendLine("\tGlobalSection(ProjectConfigurationPlatforms) = postSolution");
+
+            foreach (var project in projectInfos)
+            {
+                foreach (var configurationMapping in ProjectConfigurations[project.Key])
                 {
-                    foreach (var configurationMapping in ProjectConfigurations[project.Key])
-                    {
-                        var solutionConfiguration = configurationMapping.Key;
-                        var projectConfiguration = configurationMapping.Value;
-                        sb.AppendLine($"\t\t{project.Value.Guid}.{solutionConfiguration.FullName}.ActiveCfg = {projectConfiguration.FullName}");
-                        sb.AppendLine($"\t\t{project.Value.Guid}.{solutionConfiguration.FullName}.Build.0 = {projectConfiguration.FullName}");
-                    }
+                    var solutionConfiguration = configurationMapping.Key;
+                    var projectConfiguration = configurationMapping.Value;
+                    sb.AppendLine($"\t\t{project.Value.Guid}.{solutionConfiguration.FullName}.ActiveCfg = {projectConfiguration.FullName}");
+                    sb.AppendLine($"\t\t{project.Value.Guid}.{solutionConfiguration.FullName}.Build.0 = {projectConfiguration.FullName}");
                 }
+            }
 
-                sb.AppendLine("\tEndGlobalSection");
+            sb.AppendLine("\tEndGlobalSection");
 
-                sb.AppendLine("EndGlobal");
+            sb.AppendLine("EndGlobal");
 
-                return sb.ToString();
-            }
+            return sb.ToString();
         }
+    }
 }
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index a889274d80c..8b0e5e9ad12 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -24,15 +24,6 @@ public class ProjectGraphTests : IDisposable
     {
         private TestEnvironment _env;
 
-        private static readonly ImmutableDictionary<string, string> EmptyGlobalProperties = new Dictionary<string, string> {{PropertyNames.IsGraphBuild, "true"}}.ToImmutableDictionary();
-
-        private static readonly string InnerBuildPropertyName = "InnerBuild";
-
-        private static readonly string MultitargetingSpecification = $@"<PropertyGroup>
-                                                                        <InnerBuildProperty>{InnerBuildPropertyName}</InnerBuildProperty>
-                                                                        <InnerBuildPropertyValues>InnerBuildProperties</InnerBuildPropertyValues>
-                                                                        <InnerBuildProperties>a;b</InnerBuildProperties>
-                                                                     </PropertyGroup>";
         private static readonly string ProjectReferenceTargetsWithMultitargeting = @"<ItemGroup>
                                                                                         <!-- Item order is important to ensure outer build targets are put in front of inner build ones -->
                                                                                         <ProjectReferenceTargets Include='A' Targets='AHelperInner;A' />
@@ -1426,89 +1417,6 @@ private static void AssertOuterBuildAsRoot(
             }
         }
 
-        private static void AssertOuterBuildAsNonRoot(
-            ProjectGraphNode outerBuild,
-            ProjectGraph graph,
-            Dictionary<string, string> additionalGlobalProperties = null,
-            int expectedInnerBuildCount = 2)
-        {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
-
-            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
-
-            outerBuild.ProjectReferences.ShouldBeEmpty();
-            outerBuild.ReferencingProjects.ShouldNotBeEmpty();
-
-            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)
-            {
-                var innerBuilds =
-                    outerBuildReferencer.ProjectReferences.Where(
-                        p =>
-                            IsInnerBuild(p) 
-                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();
-
-                innerBuilds.Length.ShouldBe(expectedInnerBuildCount);
-
-                foreach (var innerBuild in innerBuilds)
-                {
-                    AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
-
-                    innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);
-                    innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);
-
-                    graph.TestOnly_Edges.TestOnly_HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
-
-                    var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
-                    var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
-
-                    edgeToOuterBuild.ShouldBe(edgeToInnerBuild);
-                }
-            }
-        }
-
-        private static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)
-        {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
-
-            IsNotMultitargeting(node).ShouldBeTrue();
-            node.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
-            node.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
-        }
-
-        private static void AssertOuterBuildEvaluation(ProjectGraphNode outerBuild, Dictionary<string, string> additionalGlobalProperties)
-        {
-            additionalGlobalProperties.ShouldNotBeNull();
-
-            IsOuterBuild(outerBuild).ShouldBeTrue();
-            IsInnerBuild(outerBuild).ShouldBeFalse();
-
-            outerBuild.ProjectInstance.GetProperty(InnerBuildPropertyName).ShouldBeNull();
-            outerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
-        }
-
-        private static void AssertInnerBuildEvaluation(
-            ProjectGraphNode innerBuild,
-            bool InnerBuildPropertyIsSetViaGlobalProperty,
-            Dictionary<string, string> additionalGlobalProperties)
-        {
-            additionalGlobalProperties.ShouldNotBeNull();
-
-            IsOuterBuild(innerBuild).ShouldBeFalse();
-            IsInnerBuild(innerBuild).ShouldBeTrue();
-
-            var innerBuildPropertyValue = innerBuild.ProjectInstance.GetPropertyValue(InnerBuildPropertyName);
-
-            innerBuildPropertyValue.ShouldNotBeNullOrEmpty();
-
-            if (InnerBuildPropertyIsSetViaGlobalProperty)
-            {
-                innerBuild.ProjectInstance.GlobalProperties.ShouldBeEquivalentTo(
-                    EmptyGlobalProperties
-                        .Add(InnerBuildPropertyName, innerBuildPropertyValue)
-                        .AddRange(additionalGlobalProperties));
-            }
-        }
-
         [Fact]
         public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
         {
@@ -1985,46 +1893,6 @@ public void UserValuesForIsGraphBuildGlobalPropertyShouldBePreserved()
             }
         }
 
-        internal static bool IsOuterBuild(ProjectGraphNode project)
-        {
-            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.OuterBuild;
-        }
-
-        internal static bool IsInnerBuild(ProjectGraphNode project)
-        {
-            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.InnerBuild;
-        }
-
-        internal static bool IsNotMultitargeting(ProjectGraphNode project)
-        {
-            return ProjectInterpretation.GetProjectType(project.ProjectInstance) == ProjectInterpretation.ProjectType.NonMultitargeting;
-        }
-
-        internal static ProjectGraphNode GetOuterBuild(ProjectGraph graph, int projectNumber)
-        {
-            return GetNodesWithProjectNumber(graph, projectNumber).FirstOrDefault(IsOuterBuild);
-        }
-
-        internal static IReadOnlyCollection<ProjectGraphNode> GetInnerBuilds(ProjectGraph graph, int projectNumber)
-        {
-            var outerBuild = GetOuterBuild(graph, projectNumber);
-
-            if (outerBuild == null)
-            {
-                return ImmutableArray<ProjectGraphNode>.Empty;
-            }
-            else
-            {
-                var innerBuilds = GetNodesWithProjectNumber(graph, projectNumber)
-                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath.Equals(outerBuild.ProjectInstance.FullPath))
-                    .ToArray();
-
-                innerBuilds.ShouldNotBeEmpty();
-
-                return innerBuilds;
-            }
-        }
-
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
index 2b127aba893..e67a10c96cb 100644
--- a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
+++ b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
@@ -3,7 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-
+using System.Diagnostics;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -14,6 +14,7 @@ namespace Microsoft.Build.BackEnd
     /// <summary>
     /// A struct representing the uniquely-identifying portion of a BuildRequestConfiguration.  Used for lookups.
     /// </summary>
+    [DebuggerDisplay(@"{DebugString()}")]
     internal class ConfigurationMetadata : IEquatable<ConfigurationMetadata>, ITranslatable
     {
         /// <summary>
@@ -166,5 +167,13 @@ private bool InternalEquals(ConfigurationMetadata other)
                    ToolsVersion.Equals(other.ToolsVersion, StringComparison.OrdinalIgnoreCase) &&
                    GlobalProperties.Equals(other.GlobalProperties);
         }
+
+        private string DebugString()
+        {
+            var truncatedProjectFile = FileUtilities.TruncatePathToTrailingSegments(ProjectFullPath, 2);
+
+            return
+                $"{truncatedProjectFile}, #GlobalProps={GlobalProperties.Count}";
+        }
     }
 }
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 21879264456..9ce0934583e 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -95,6 +95,7 @@ public sealed class ProjectInSolution
         #region Member data
         private string _relativePath;         // Relative from .SLN file.  For example, "WindowsApplication1\WindowsApplication1.csproj"
         private readonly List<string> _dependencies;     // A list of strings representing the Guids of the dependent projects.
+        private IReadOnlyList<string> _dependenciesAsReadonly;
         private string _uniqueProjectName;    // For example, "MySlnFolder\MySubSlnFolder\WindowsApplication1"
 
         /// <summary>
@@ -103,6 +104,7 @@ public sealed class ProjectInSolution
         /// V: project configuration 
         /// </summary>
         private readonly Dictionary<string, ProjectConfigurationInSolution> _projectConfigurations;
+        private IReadOnlyDictionary<string, ProjectConfigurationInSolution> _projectConfigurationsReadOnly;
 
         #endregion
 
@@ -176,14 +178,16 @@ internal set
         /// List of guids, in "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" form, mapping to projects 
         /// that this project has a build order dependency on, as defined in the solution file. 
         /// </summary>
-        public IReadOnlyList<string> Dependencies => _dependencies.AsReadOnly();
+        public IReadOnlyList<string> Dependencies => _dependenciesAsReadonly ?? (_dependenciesAsReadonly = _dependencies.AsReadOnly());
 
         /// <summary>
         /// Configurations for this project, keyed off the configuration's full name, e.g. "Debug|x86"
         /// They contain only the project configurations from the solution file that fully matched (configuration and platform) against the solution configurations.
         /// </summary>
-        public IReadOnlyDictionary<string, ProjectConfigurationInSolution> ProjectConfigurations =>
-            new ReadOnlyDictionary<string, ProjectConfigurationInSolution>(_projectConfigurations);
+        public IReadOnlyDictionary<string, ProjectConfigurationInSolution> ProjectConfigurations
+            =>
+                _projectConfigurationsReadOnly
+                ?? (_projectConfigurationsReadOnly = new ReadOnlyDictionary<string, ProjectConfigurationInSolution>(_projectConfigurations));
 
         /// <summary>
         /// Extension of the project file, if any
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 95e2b759926..99f7b8d5769 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -666,8 +666,8 @@ private void ParseProject(string firstLine)
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
                             new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseProjectDepGuidError", proj.ProjectName);
 
-                        string parentGuid = match.Groups["PROPERTYNAME"].Value.Trim();
-                        proj.AddDependency(parentGuid);
+                        string referenceGuid = match.Groups["PROPERTYNAME"].Value.Trim();
+                        proj.AddDependency(referenceGuid);
 
                         line = ReadLine();
                     }
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 05a4487a9ab..3baa004921e 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -20,6 +20,8 @@ namespace Microsoft.Build.Experimental.Graph
 {
     internal class GraphBuilder
     {
+        internal static readonly string SolutionItemReference = "_SolutionReference";
+        
         /// <summary>
         /// The thread calling BuildGraph() will act as an implicit worker
         /// </summary>
@@ -42,6 +44,7 @@ internal class GraphBuilder
         private readonly ProjectInterpretation _projectInterpretation;
 
         private readonly ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory;
+        private IReadOnlyDictionary<string, IReadOnlyCollection<string>> _solutionDependencies;
 
         public GraphBuilder(
             IEnumerable<ProjectGraphEntryPoint> entryPoints,
@@ -51,7 +54,11 @@ public GraphBuilder(
             int degreeOfParallelism,
             CancellationToken cancellationToken)
         {
-            _entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(ExpandSolutionIfNecessary(entryPoints.ToImmutableArray()));
+            var (actualEntryPoints, solutionDependencies) = ExpandSolutionIfPresent(entryPoints.ToImmutableArray());
+
+            _solutionDependencies = solutionDependencies;
+
+            _entryPointConfigurationMetadata = AddGraphBuildPropertyToEntryPoints(actualEntryPoints);
             
             IEqualityComparer<ConfigurationMetadata> configComparer = EqualityComparer<ConfigurationMetadata>.Default;
 
@@ -73,9 +80,7 @@ public void BuildGraph()
             }
             var allParsedProjects = FindGraphNodes();
             
-            Edges = new GraphEdges();
-            AddParsedEdges(allParsedProjects, Edges);
-            _projectInterpretation.PostProcess(allParsedProjects, this);
+            AddEdges(allParsedProjects);
 
             EntryPointNodes = _entryPointConfigurationMetadata.Select(e => allParsedProjects[e].GraphNode).ToList();
 
@@ -102,7 +107,18 @@ private static IReadOnlyCollection<ProjectGraphNode> GetGraphRoots(IReadOnlyColl
             return graphRoots;
         }
 
-        private void AddParsedEdges(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects, GraphEdges edges)
+        private void AddEdges(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects)
+        {
+            Edges = new GraphEdges();
+            AddEdgesFromProjectFileReferences(allParsedProjects, Edges);
+            _projectInterpretation.PostProcess(allParsedProjects, this);
+            if (_solutionDependencies != null && _solutionDependencies.Count != 0)
+            {
+                AddEdgesFromSolution(allParsedProjects, _solutionDependencies, Edges);
+            }
+        }
+
+        private static void AddEdgesFromProjectFileReferences(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects, GraphEdges edges)
         {
             foreach (var parsedProject in allParsedProjects)
             {
@@ -120,11 +136,61 @@ private void AddParsedEdges(Dictionary<ConfigurationMetadata, ParsedProject> all
             }
         }
 
-        private IReadOnlyCollection<ProjectGraphEntryPoint> ExpandSolutionIfNecessary(IReadOnlyCollection<ProjectGraphEntryPoint> entryPoints)
+        private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetadata, ParsedProject> allParsedProjects, IReadOnlyDictionary<string, IReadOnlyCollection<string>> solutionDependencies, GraphEdges edges)
+        {
+            var projectsByPath = new Dictionary<string, List<ProjectGraphNode>>();
+
+            foreach (var project in allParsedProjects)
+            {
+                var projectPath = project.Value.GraphNode.ProjectInstance.FullPath;
+
+                if (projectsByPath.ContainsKey(projectPath))
+                {
+                    projectsByPath[projectPath].Add(project.Value.GraphNode);
+                }
+                else
+                {
+                    projectsByPath[projectPath] = new List<ProjectGraphNode> {project.Value.GraphNode};
+                }
+            }
+
+            foreach (var solutionDependency in solutionDependencies)
+            {
+                var referencingProjectPath = solutionDependency.Key;
+
+                ErrorUtilities.VerifyThrow(projectsByPath.ContainsKey(referencingProjectPath), "nodes should include solution projects");
+
+                var referencedNodes = solutionDependency.Value.SelectMany(
+                    referencedProjectPath =>
+                    {
+                        ErrorUtilities.VerifyThrow(projectsByPath.ContainsKey(referencedProjectPath), "nodes should include solution projects");
+
+                        return projectsByPath[referencedProjectPath];
+                    }).ToArray();
+
+                var referencingNodes = projectsByPath[referencingProjectPath];
+
+                foreach (var referencingNode in referencingNodes)
+                {
+                    foreach (var referencedNode in referencedNodes)
+                    {
+                        var stubItem = new ProjectItemInstance(
+                            referencingNode.ProjectInstance,
+                            SolutionItemReference,
+                            referencedNode.ProjectInstance.FullPath,
+                            referencingNode.ProjectInstance.FullPath);
+
+                        referencingNode.AddProjectReference(referencedNode, stubItem, edges);
+                    }
+                }
+            }
+        }
+
+        private (IReadOnlyCollection<ProjectGraphEntryPoint> NewEntryPoints, IReadOnlyDictionary<string, IReadOnlyCollection<string>> SolutionDependencies) ExpandSolutionIfPresent(IReadOnlyCollection<ProjectGraphEntryPoint> entryPoints)
         {
             if (entryPoints.Count == 0 || !entryPoints.Any(e => FileUtilities.IsSolutionFilename(e.ProjectFile)))
             {
-                return entryPoints;
+                return (entryPoints, null);
             }
 
             if (entryPoints.Count != 1)
@@ -174,7 +240,7 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> ExpandSolutionIfNecessary(IR
                 {
                     newEntryPoints.Add(
                         new ProjectGraphEntryPoint(
-                            project.AbsolutePath,
+                            FileUtilities.NormalizePath(project.AbsolutePath),
                             solutionGlobalProperties
                                 .SetItem("Configuration", projectConfiguration.ConfigurationName)
                                 .SetItem("Platform", projectConfiguration.PlatformName)
@@ -184,25 +250,11 @@ private IReadOnlyCollection<ProjectGraphEntryPoint> ExpandSolutionIfNecessary(IR
 
             newEntryPoints.TrimExcess();
 
-            return newEntryPoints;
+            return (newEntryPoints, GetSolutionDependencies(solution));
 
             IReadOnlyCollection<ProjectInSolution> GetBuildableProjects(SolutionFile solutionFile)
             {
-                var buildableProjects = solutionFile.ProjectsInOrder.Where(p => p.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat).ToImmutableArray();
-
-                var projectsWithSolutionDependencies = buildableProjects.Where(p => p.Dependencies.Count != 0);
-
-                if (projectsWithSolutionDependencies.Any())
-                {
-                    throw new ArgumentException(
-                        ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
-                            "StaticGraphDoesNotHandleSolutionOnlyDependencies",
-                            solutionFile.FullPath,
-                            string.Join(";", projectsWithSolutionDependencies))
-                        );
-                }
-
-                return buildableProjects;
+                return solutionFile.ProjectsInOrder.Where(p => p.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat).ToImmutableArray();
             }
 
             SolutionConfigurationInSolution SelectSolutionConfiguration(SolutionFile solutionFile, ImmutableDictionary<string, string> globalProperties)
@@ -234,6 +286,44 @@ ProjectConfigurationInSolution SelectProjectConfiguration(
                 var partiallyMarchedConfig = projectConfigs.FirstOrDefault(pc => pc.Value.ConfigurationName.Equals(solutionConfig.ConfigurationName, StringComparison.OrdinalIgnoreCase)).Value;
                 return partiallyMarchedConfig ?? projectConfigs.First().Value;
             }
+
+            IReadOnlyDictionary<string, IReadOnlyCollection<string>> GetSolutionDependencies(SolutionFile solutionFile)
+            {
+                var solutionDependencies = new Dictionary<string, IReadOnlyCollection<string>>();
+
+                foreach (var projectWithDependencies in solutionFile.ProjectsInOrder.Where(p => p.Dependencies.Count != 0))
+                {
+                    solutionDependencies[FileUtilities.NormalizePath(projectWithDependencies.AbsolutePath)] = projectWithDependencies.Dependencies.Select(
+                        dependencyGuid =>
+                        {
+
+                            // code snippet cloned from SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration
+
+                            if (!solutionFile.ProjectsByGuid.TryGetValue(dependencyGuid, out var dependencyProject))
+                            {
+                                // If it's not itself part of the solution, that's an invalid solution
+                                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
+                                    dependencyProject != null,
+                                    "SubCategoryForSolutionParsingErrors",
+                                    new BuildEventFileInfo(solutionFile.FullPath),
+                                    "SolutionParseProjectDepNotFoundError",
+                                    projectWithDependencies.ProjectGuid,
+                                    dependencyGuid);
+                            }
+
+                            // Add it to the list of dependencies, but only if it should build in this solution configuration 
+                            // (If a project is not selected for build in the solution configuration, it won't build even if it's depended on by something that IS selected for build)
+                            // .. and only if it's known to be MSBuild format, as projects can't use the information otherwise 
+                            return dependencyProject?.ProjectType == SolutionProjectType.KnownToBeMSBuildFormat
+                                ? FileUtilities.NormalizePath(dependencyProject.AbsolutePath)
+                                : null;
+                        })
+                        .Where(p => p != null)
+                        .ToArray();
+                }
+
+                return solutionDependencies;
+            }
         }
 
         private static List<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable<ProjectGraphEntryPoint> entryPoints)
@@ -264,8 +354,8 @@ void AddGraphBuildGlobalVariable(PropertyDictionary<ProjectPropertyInstance> glo
         }
 
         /// <remarks>
-        ///     Traverse the found nodes and add edges.
         ///     Maintain the state of each node (InProcess and Processed) to detect cycles.
+        ///     Assumes edges have been added between nodes.
         ///     Returns false if cycles were detected.
         /// </remarks>
         private void DetectCycles(
@@ -494,6 +584,14 @@ public void RemoveEdge((ProjectGraphNode node, ProjectGraphNode reference) key)
                 ReferenceItems.TryRemove(key, out _);
             }
 
+            internal IReadOnlyDictionary<(ConfigurationMetadata, ConfigurationMetadata), ProjectItemInstance> TestOnly_AsConfigurationMetadata()
+            {
+                return ReferenceItems.ToImmutableDictionary(
+                    kvp => (kvp.Key.Item1.ToConfigurationMetadata(), kvp.Key.Item2.ToConfigurationMetadata()),
+                    kvp => kvp.Value
+                    );
+            }
+
             internal bool TestOnly_HasEdge((ProjectGraphNode node, ProjectGraphNode reference) key) => ReferenceItems.ContainsKey(key);
         }
 
diff --git a/src/Build/Graph/ProjectGraphNode.cs b/src/Build/Graph/ProjectGraphNode.cs
index 97435223d35..02e3cd11647 100644
--- a/src/Build/Graph/ProjectGraphNode.cs
+++ b/src/Build/Graph/ProjectGraphNode.cs
@@ -3,6 +3,7 @@
 
 using System.Collections.Generic;
 using System.Diagnostics;
+using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
@@ -10,6 +11,7 @@ namespace Microsoft.Build.Experimental.Graph
 {
     /// <summary>
     /// Represents the node for a particular project in a project graph.
+    /// A node is defined by (ProjectPath, ToolsVersion, GlobalProperties).
     /// </summary>
     [DebuggerDisplay(@"{DebugString()}")]
     public sealed class ProjectGraphNode
@@ -68,5 +70,10 @@ internal void RemoveReferences(GraphBuilder.GraphEdges edges)
 
             _projectReferences.Clear();
         }
+
+        internal ConfigurationMetadata ToConfigurationMetadata()
+        {
+            return new ConfigurationMetadata(ProjectInstance.FullPath, ProjectInstance.GlobalPropertiesDictionary);
+        }
     }
 }
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 7714e679e42..9f17f6349d9 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -25,6 +25,7 @@ internal sealed class ProjectInterpretation
         private const string SetTargetFrameworkMetadataName = "SetTargetFramework";
         private const string GlobalPropertiesToRemoveMetadataName = "GlobalPropertiesToRemove";
         private const string ProjectReferenceTargetIsOuterBuildMetadataName = "OuterBuild";
+        internal const string InnerBuildReferenceItemName = "_ProjectSelfReference";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -61,7 +62,7 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
             switch (GetProjectType(requesterInstance))
             {
                 case ProjectType.OuterBuild:
-                    projectReferenceItems = GetInnerBuildReferences(requesterInstance);
+                    projectReferenceItems = ConstructInnerBuildReferences(requesterInstance);
                     break;
                 case ProjectType.InnerBuild:
                     globalPropertiesModifiers = ModifierForNonMultitargetingNodes.Add((parts, reference) => parts.AddPropertyToUndefine(GetInnerBuildPropertyName(requesterInstance)));
@@ -162,7 +163,7 @@ public void PostProcess(Dictionary<ConfigurationMetadata, ParsedProject> allNode
             }
         }
 
-        private static IEnumerable<ProjectItemInstance> GetInnerBuildReferences(ProjectInstance outerBuild)
+        private static IEnumerable<ProjectItemInstance> ConstructInnerBuildReferences(ProjectInstance outerBuild)
         {
             var globalPropertyName = GetInnerBuildPropertyName(outerBuild);
             var globalPropertyValues = GetInnerBuildPropertyValues(outerBuild);
@@ -174,7 +175,7 @@ private static IEnumerable<ProjectItemInstance> GetInnerBuildReferences(ProjectI
             {
                 yield return new ProjectItemInstance(
                     outerBuild,
-                    "_ProjectSelfReference",
+                    InnerBuildReferenceItemName,
                     outerBuild.FullPath,
                     new[] {new KeyValuePair<string, string>(ItemMetadataNames.PropertiesMetadataName, $"{globalPropertyName}={globalPropertyValue}")},
                     outerBuild.FullPath);
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 66c683a38fa..839e1cbae28 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1784,15 +1784,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </comment>
   </data>
-  <data name="StaticGraphDoesNotHandleSolutionOnlyDependencies" UESanitized="false" Visibility="Public">
-    <value>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </value>
-    <comment>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
-    </comment>
-  </data>
   <data name="StaticGraphDoesNotSupportSlnReferences" UESanitized="false" Visibility="Public">
-    <value>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+    <value>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </value>
     <comment>
       LOCALIZATION: {0} and {1} are file paths
@@ -1804,7 +1797,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
         MSB4128 is being used in FileLogger.cs (can't be added here yet as strings are currently frozen)
         MSB4129 is used by Shared\XmlUtilities.cs (can't be added here yet as strings are currently frozen)
 
-        Next message code should be MSB4265.
+        Next message code should be MSB4264.
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 850d1ad5f6c..1de22f232d4 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index d0bc9f00bad..fa525396f4e 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index a62951862c4..0025e938679 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index b129220ba0d..d1b5c55e75a 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 70d71e7e760..982b76ce130 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 46cdc685aa2..06584a0b160 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index b3a1935e3bb..2c5a359a750 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index c016c050f86..c09ff6bbe04 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index e57fd5c6c67..ef85eda9fff 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 260702f0e9b..63ed414fe46 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -119,21 +119,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 24976dbde39..97181c642ca 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index af2103f7961..1019189bb8f 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 5b3a1412515..84bcb8b8edf 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 9d27f0d9aa8..ca23486f4e3 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -120,21 +120,12 @@
         <target state="new">MSB4261: Static graph only accepts a solution as the only entry point. Multiple entry points detected: {0}</target>
         <note>
       LOCALIZATION: {0} is a semicolon delimited list of files
-    </note>
-      </trans-unit>
-      <trans-unit id="StaticGraphDoesNotHandleSolutionOnlyDependencies">
-        <source>MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </source>
-        <target state="new">MSB4263: Static graph does not support solutions containing solution only dependencies. Solution file "{0}" contains the following projects with solution only dependencies: {1}
-    </target>
-        <note>
-      LOCALIZATION: {0} is a file and {1} is a semicolon delimited list of files
     </note>
       </trans-unit>
       <trans-unit id="StaticGraphDoesNotSupportSlnReferences">
-        <source>MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <source>MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </source>
-        <target state="new">MSB4264: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
+        <target state="new">MSB4263: Project "{0}" has a reference to solution file "{1}". Referencing solutions is not supported in static graph.
     </target>
         <note>
       LOCALIZATION: {0} and {1} are file paths
