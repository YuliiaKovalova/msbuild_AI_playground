diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index b7fcc724450..4515291b047 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -136,6 +136,77 @@ public void SimpleBuild()
             Assert.Equal("InitialProperty3", propertyValue);
         }
 
+        [Fact]
+        public void SimpleP2PBuildInProc()
+        {
+            var newParameters = _parameters.Clone();
+
+            newParameters.DisableInProcNode = false;
+            newParameters.MaxNodeCount = 1;
+
+            SimpleP2PBuild(newParameters);
+        }
+
+        [Fact]
+        public void SimpleP2PBuildOutOfProc()
+        {
+            var newParameters = _parameters.Clone();
+
+            newParameters.DisableInProcNode = true;
+            newParameters.MaxNodeCount = 3;
+
+            SimpleP2PBuild(newParameters);
+        }
+
+        private void SimpleP2PBuild(BuildParameters buildParameters)
+        {
+            var graph = Helpers.CreateProjectGraph(
+                _env,
+                new Dictionary<int, int[]>
+                {
+                    {1, new[] {2, 3}}
+                },
+                createProjectFile:
+                    (env, projectNumber, references, targets, defaultTargets, content) =>
+                    {
+                        return Helpers.CreateProjectFile(
+                            env,
+                            projectNumber,
+                            references,
+                            targets,
+                            "ActualBuild",
+                            @"<Target Name='ActualBuild'>
+                                            <MSBuild Projects='@(ProjectReference)'/>
+                                         </Target>");
+                    });
+
+            var result = _buildManager.Build(
+                buildParameters,
+                new BuildRequestData(
+                    graph.GraphRoots.FirstOrDefault()
+                        .ProjectInstance.FullPath,
+                    new Dictionary<string, string>(),
+                    MSBuildConstants.CurrentToolsVersion,
+                    new string[0],
+                    null));
+
+            result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            _logger.AllBuildEvents.OfType<ProjectStartedEventArgs>()
+                .Count()
+                .ShouldBe(3);
+            _logger.AllBuildEvents.OfType<ProjectEvaluationFinishedEventArgs>()
+                .Count()
+                .ShouldBe(3);
+
+            _logger.AllBuildEvents.OfType<ProjectEvaluationStartedEventArgs>()
+                .Count()
+                .ShouldBe(3);
+            _logger.AllBuildEvents.OfType<ProjectEvaluationFinishedEventArgs>()
+                .Count()
+                .ShouldBe(3);
+        }
+
         /// <summary>
         /// A simple successful graph build.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 5d7dfcb1861..c9e4fdd7302 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -16,12 +16,29 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
+using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
-    public class BuildRequestConfiguration_Tests
+    public class BuildRequestConfiguration_Tests : IDisposable
     {
+        private TestEnvironment _env;
+
+        public BuildRequestConfiguration_Tests(ITestOutputHelper testOutput)
+        {
+            _env = TestEnvironment.Create(testOutput);
+            _env.DoNotLaunchDebugger();
+        }
+
+        public void Dispose()
+        {
+            _env.Dispose();
+        }
+
         [Fact]
         public void TestConstructorNullFile()
         {
@@ -427,5 +444,92 @@ public void TestCache2()
                 FileUtilities.ClearCacheDirectoryPath();
             }
         }
+
+        [Fact]
+        public void SkipIsolationChecksRejectsMissingEvaluation()
+        {
+            var configWithoutEvaluation = new BuildRequestConfiguration();
+
+            var exception = Assert.Throws<InternalErrorException>(
+                () =>
+                {
+                    configWithoutEvaluation.ShouldSkipIsolationConstraintsForReference(Path.GetFullPath("foo"));
+                });
+        }
+
+        [Fact]
+        public void SkipIsolationChecksRejectsRelativeReferencePaths()
+        {
+            var exception = Assert.Throws<InternalErrorException>(
+                () =>
+                {
+                    TestSkipIsolationConstraints("*", "build.proj", false);
+                });
+
+            exception.Message.ShouldContain("Method does not treat path normalization cases");
+        }
+
+        [Fact]
+        public void SkipIsolationConstraintsDoesNotSkipWhenItemDoesNotExist()
+        {
+            TestSkipIsolationConstraints(@"c:\*.csproj", @"c:\foo.csproj", false, "<Project></Project>");
+        }
+
+        [Theory]
+        [InlineData("", @"c:\foo", false)]
+        [InlineData("*", @"c:\foo.proj", false)] // relative glob is normalized to project directory
+        [InlineData("*", @"$(MSBuildProjectDirectory)\foo.proj", true)] // relative glob is normalized to project directory
+        [InlineData(@"c:\*.csproj", @"c:\foo.proj", false)]
+        [InlineData(@"c:\*.csproj", @"c:\foo.csproj", true)]
+        [InlineData(@"c:\*.props;c:\*.csproj", @"c:\foo.csproj", true)]
+        [InlineData(@"c:\project\*script*\**\*.proj", @"c:\foo.csproj", false)]
+        [InlineData(@"c:\project\*script*\**\*.proj", @"c:\project\scripts\a\b\build.proj", true)]
+        [InlineData(@"c:\project\script\Project*.proj", @"c:\project\script\Project.proj", true)]
+        [InlineData(@"c:\project\script\Project*.proj", @"c:\project\script\Project1.proj", true)]
+        [InlineData(@"c:\project\script\Project*.proj", @"c:\project\script\build.proj", false)]
+        public void SkipIsolationCheckShouldFilterReferencesViaMSBuildGlobs(string glob, string referencePath, bool expectedOutput)
+        {
+            TestSkipIsolationConstraints(glob, referencePath, expectedOutput);
+        }
+
+        private void TestSkipIsolationConstraints(string glob, string referencePath, bool expectedOutput, string projectContents = null)
+        {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                glob = glob.Replace(@"c:\", "/").ToSlash();
+                referencePath = referencePath.Replace(@"c:\", "/").ToSlash();
+            }
+
+            glob = $"$([MSBuild]::Escape('{glob}'))";
+
+            projectContents = projectContents ?? $@"
+<Project>
+    <ItemGroup>
+        <{ItemTypeNames.GraphIsolationExemptReference} Include=`{glob};ShouldNotMatchAnything`/>
+    </ItemGroup>
+</Project>
+".Cleanup();
+
+            var projectCollection = _env.CreateProjectCollection().Collection;
+            var project = Project.FromXmlReader(
+                XmlReader.Create(new StringReader(projectContents)),
+                new ProjectOptions
+                {
+                    ProjectCollection = projectCollection
+                });
+
+            project.FullPath = _env.CreateFolder().Path;
+
+            var projectInstance = project.CreateProjectInstance();
+
+            var configuration = new BuildRequestConfiguration(new BuildRequestData(projectInstance, new string[] {}), MSBuildConstants.CurrentToolsVersion);
+
+            if (referencePath.Contains("$"))
+            {
+                referencePath = project.ExpandPropertyValueBestEffortLeaveEscaped(referencePath, ElementLocation.EmptyLocation);
+            }
+
+            configuration.ShouldSkipIsolationConstraintsForReference(referencePath).ShouldBe(expectedOutput);
+        }
     }
 }
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 06ccc1ec26a..47577ab4e66 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -20,6 +20,10 @@ public class IsolateProjectsTests
         private readonly string _project = @"
                 <Project DefaultTargets='BuildSelf'>
 
+                    <ItemGroup>
+                        <GraphIsolationExemptReference Condition=`'{4}'!=''` Include=`$([MSBuild]::Escape('{4}'))`/>
+                    </ItemGroup>
+
                     <ItemGroup>
                         <ProjectReference Include='{0}'/>
                     </ItemGroup>
@@ -54,17 +58,67 @@ public class IsolateProjectsTests
 
                     <Target Name='SelfTarget'>
                     </Target>
+
+                    <UsingTask TaskName='CustomMSBuild' TaskFactory='RoslynCodeTaskFactory' AssemblyFile='$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll'>
+                        <ParameterGroup>
+                          <Projects ParameterType='Microsoft.Build.Framework.ITaskItem[]' Required='true' />
+                          <Targets ParameterType='Microsoft.Build.Framework.ITaskItem[]' Required='true' />
+                        </ParameterGroup>
+                        <Task>
+                          <Code Type='Fragment' Language='cs'>
+                    <![CDATA[
+
+var projects = new string[Projects.Length];
+var globalProperties = new IDictionary[Projects.Length];
+var toolsVersions = new string[Projects.Length];
+
+for (var i = 0; i < Projects.Length; i++)
+{{
+  projects[i] = Projects[i].ItemSpec;
+  globalProperties[i] = new Dictionary<string, string>();
+  toolsVersions[i] = ""Current"";
+}}
+
+var targets = new string[Targets.Length];
+for (var i = 0; i < Targets.Length; i++)
+{{
+  targets[i] = Targets[i].ItemSpec;
+}}
+
+BuildEngine5.BuildProjectFilesInParallel(
+  projects,
+  targets,
+  globalProperties,
+  null,
+  toolsVersions,
+  false,
+  false
+  );
+]]>
+                          </Code>
+                        </Task>
+                    </UsingTask>
+
+                    <Target Name='BuildDeclaredReferenceViaTask'>
+                        <CustomMSBuild Projects='{1}' Targets='DeclaredReferenceTarget'/>
+                    </Target>
+
+                    <Target Name='BuildUndeclaredReferenceViaTask'>
+                        <CustomMSBuild Projects='{2}' Targets='UndeclaredReferenceTarget'/>
+                    </Target>
                 </Project>";
 
         private readonly string _declaredReference = @"
                 <Project>
                     <Target Name='DeclaredReferenceTarget'>
+                        <Message Text='Message from reference' Importance='High' />
                     </Target>
                 </Project>";
 
         private readonly string _undeclaredReference = @"
                 <Project>
                     <Target Name='UndeclaredReferenceTarget'>
+                        <Message Text='Message from reference' Importance='High' />
                     </Target>
                 </Project>";
 
@@ -78,7 +132,7 @@ public IsolateProjectsTests(ITestOutputHelper testOutput)
         [Theory]
         [InlineData(BuildResultCode.Success, new string[] { })]
         [InlineData(BuildResultCode.Success, new[] {"BuildSelf"})]
-        public void CacheAndTaskEnforcementShouldAcceptSelfReferences(BuildResultCode expectedBuildResult, string[] targets)
+        public void CacheAndUndeclaredReferenceEnforcementShouldAcceptSelfReferences(BuildResultCode expectedBuildResult, string[] targets)
         {
             AssertBuild(targets,
                 (result, logger) =>
@@ -90,7 +144,7 @@ public void CacheAndTaskEnforcementShouldAcceptSelfReferences(BuildResultCode ex
         }
 
         [Fact]
-        public void CacheAndTaskEnforcementShouldAcceptCallTarget()
+        public void CacheAndUndeclaredReferenceEnforcementShouldAcceptCallTarget()
         {
             AssertBuild(new []{"CallTarget"},
                 (result, logger) =>
@@ -130,9 +184,58 @@ private void CacheEnforcementShouldFailWhenReferenceWasNotPreviouslyBuilt2(bool
         }
 
         [Fact]
-        public void CacheEnforcementShouldAcceptPreviouslyBuiltReferences()
+        public void IsolationRelatedMessagesShouldNotBePresentInNonIsolatedBuilds()
         {
-            AssertBuild(new []{"BuildDeclaredReference"},
+            AssertBuild(
+                new[] { "BuildDeclaredReference", "BuildUndeclaredReference" },
+                (result, logger) =>
+                {
+                    result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+                    logger.ErrorCount.ShouldBe(0);
+                    logger.Errors.ShouldBeEmpty();
+
+                    // the references got built because isolation is turned off
+                    logger.AssertMessageCount("Message from reference", 2);
+                    logger.AllBuildEvents.OfType<ProjectStartedEventArgs>().Count().ShouldBe(3);
+
+                    logger.AssertLogDoesntContain("MSB4260");
+                },
+                excludeReferencesFromConstraints: true,
+                isolateProjects: false);
+        }
+
+        [Theory]
+        [InlineData("BuildDeclaredReference")]
+        [InlineData("BuildDeclaredReferenceViaTask")]
+        [InlineData("BuildUndeclaredReference")]
+        [InlineData("BuildUndeclaredReferenceViaTask")]
+        public void EnforcementsCanBeSkipped(string targetName)
+        {
+            AssertBuild(
+                new[] { targetName },
+                (result, logger) =>
+                {
+                    result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+                    logger.ErrorCount.ShouldBe(0);
+                    logger.Errors.ShouldBeEmpty();
+
+                    // the reference got built because the constraints were skipped
+                    logger.AssertMessageCount("Message from reference", 1);
+                    logger.AllBuildEvents.OfType<ProjectStartedEventArgs>().Count().ShouldBe(2);
+
+                    logger.AssertMessageCount("MSB4260", 1);
+                },
+                excludeReferencesFromConstraints: true);
+        }
+
+        [Theory]
+        [InlineData("BuildDeclaredReference")]
+        [InlineData("BuildDeclaredReferenceViaTask")]
+        public void CacheEnforcementShouldAcceptPreviouslyBuiltReferences(string targetName)
+        {
+            AssertBuild(new []{ targetName },
                 (result, logger) =>
                 {
                     result.OverallResult.ShouldBe(BuildResultCode.Success);
@@ -143,11 +246,13 @@ public void CacheEnforcementShouldAcceptPreviouslyBuiltReferences()
         }
 
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void TaskEnforcementShouldFailOnUndeclaredReference(bool addContinueOnError)
+        [InlineData(false, "BuildUndeclaredReference")]
+//        [InlineData(false, "BuildUndeclaredReferenceViaTask")] https://github.com/microsoft/msbuild/issues/4385
+        [InlineData(true, "BuildUndeclaredReference")]
+//        [InlineData(true, "BuildUndeclaredReferenceViaTask")] https://github.com/microsoft/msbuild/issues/4385
+        public void UndeclaredReferenceEnforcementShouldFailOnUndeclaredReference(bool addContinueOnError, string targetName)
         {
-            AssertBuild(new[] { "BuildUndeclaredReference" },
+            AssertBuild(new[] { targetName },
                 (result, logger) =>
                 {
                     result.OverallResult.ShouldBe(BuildResultCode.Failure);
@@ -159,10 +264,12 @@ public void TaskEnforcementShouldFailOnUndeclaredReference(bool addContinueOnErr
                 addContinueOnError: addContinueOnError);
         }
 
-        [Fact]
-        public void TaskEnforcementShouldFailOnPreviouslyBuiltButUndeclaredReferences()
+        [Theory]
+        [InlineData("BuildUndeclaredReference")]
+//        [InlineData("BuildUndeclaredReferenceViaTask")] https://github.com/microsoft/msbuild/issues/4385
+        public void UndeclaredReferenceEnforcementShouldFailOnPreviouslyBuiltButUndeclaredReferences(string targetName)
         {
-            AssertBuild(new[] { "BuildUndeclaredReference" },
+            AssertBuild(new[] { targetName },
                 (result, logger) =>
                 {
                     result.OverallResult.ShouldBe(BuildResultCode.Failure);
@@ -174,7 +281,7 @@ public void TaskEnforcementShouldFailOnPreviouslyBuiltButUndeclaredReferences()
                 buildUndeclaredReference: true);
         }
 
-        public static IEnumerable<object[]> TaskEnforcementShouldNormalizeFilePathsTestData
+        public static IEnumerable<object[]> UndeclaredReferenceEnforcementShouldNormalizeFilePathsTestData
         {
             get
             {
@@ -194,27 +301,33 @@ public static IEnumerable<object[]> TaskEnforcementShouldNormalizeFilePathsTestD
 
                 Func<string, string> ToDuplicateSlashes = path => path.Replace("/", "//").Replace(@"\", @"\\");
 
+                var targetNames = new []{"BuildDeclaredReference", /*"BuildDeclaredReferenceViaTask"*/};
+
                 var functions = new[] {Preserve, FullToRelative, ToForwardSlash, ToBackSlash, ToDuplicateSlashes};
 
                 foreach (var projectReferenceModifier in functions)
                 {
                     foreach (var msbuildProjectModifier in functions)
                     {
-                        yield return new object[]
+                        foreach (var targetName in targetNames)
                         {
-                            projectReferenceModifier,
-                            msbuildProjectModifier
-                        };
+                            yield return new object[]
+                            {
+                                projectReferenceModifier,
+                                msbuildProjectModifier,
+                                targetName
+                            };
+                        }
                     }
                 }
             }
         }
 
         [Theory]
-        [MemberData(nameof(TaskEnforcementShouldNormalizeFilePathsTestData))]
-        public void TaskEnforcementShouldNormalizeFilePaths(Func<string, string> projectReferenceModifier, Func<string, string> msbuildProjectModifier)
+        [MemberData(nameof(UndeclaredReferenceEnforcementShouldNormalizeFilePathsTestData))]
+        public void UndeclaredReferenceEnforcementShouldNormalizeFilePaths(Func<string, string> projectReferenceModifier, Func<string, string> msbuildProjectModifier, string targetName)
         {
-            AssertBuild(new []{"BuildDeclaredReference"},
+            AssertBuild(new []{targetName},
                 (result, logger) =>
                 {
                     result.OverallResult.ShouldBe(BuildResultCode.Success);
@@ -224,8 +337,8 @@ public void TaskEnforcementShouldNormalizeFilePaths(Func<string, string> project
                 buildDeclaredReference: true,
                 buildUndeclaredReference: false,
                 addContinueOnError: false,
-                projectReferenceModifier,
-                msbuildProjectModifier);
+                projectReferenceModifier: projectReferenceModifier,
+                msbuildOnDeclaredReferenceModifier: msbuildProjectModifier);
         }
 
         private void AssertBuild(
@@ -234,6 +347,8 @@ private void AssertBuild(
             bool buildDeclaredReference = false,
             bool buildUndeclaredReference = false,
             bool addContinueOnError = false,
+            bool excludeReferencesFromConstraints = false,
+            bool isolateProjects = true,
             Func<string, string> projectReferenceModifier = null,
             Func<string, string> msbuildOnDeclaredReferenceModifier = null)
         {
@@ -243,23 +358,28 @@ private void AssertBuild(
                 if (NativeMethodsShared.IsOSX)
                 {
                     // OSX links /var into /private, which makes Path.GetTempPath() to return "/var..." but Directory.GetCurrentDirectory to return "/private/var..."
-                    // this discrepancy fails the msbuild task enforcements due to failed path equality checks
+                    // this discrepancy fails the msbuild undeclared reference enforcements due to failed path equality checks
                     env.SetTempPath(Path.Combine(Directory.GetCurrentDirectory(), Guid.NewGuid().ToString("N")), deleteTempDirectory:true);
                 }
 
-                var projectFile = env.CreateFile().Path;
+                var rootProjectFile = env.CreateFile().Path;
                 var declaredReferenceFile = env.CreateFile().Path;
                 var undeclaredReferenceFile = env.CreateFile().Path;
 
-                File.WriteAllText(
-                    projectFile,
-                    string.Format(
-                        _project,
-                        projectReferenceModifier?.Invoke(declaredReferenceFile) ?? declaredReferenceFile,
-                        msbuildOnDeclaredReferenceModifier?.Invoke(declaredReferenceFile) ?? declaredReferenceFile,
-                        undeclaredReferenceFile,
-                        addContinueOnError ? "ContinueOnError='WarnAndContinue'" : string.Empty));
-
+                var projectContents = string.Format(
+                    _project.Cleanup(),
+                    projectReferenceModifier?.Invoke(declaredReferenceFile) ?? declaredReferenceFile,
+                    msbuildOnDeclaredReferenceModifier?.Invoke(declaredReferenceFile) ?? declaredReferenceFile,
+                    undeclaredReferenceFile,
+                    addContinueOnError
+                        ? "ContinueOnError='WarnAndContinue'"
+                        : string.Empty,
+                    excludeReferencesFromConstraints
+                        ? $"{declaredReferenceFile};{undeclaredReferenceFile}"
+                        : string.Empty)
+                    .Cleanup();
+
+                File.WriteAllText(rootProjectFile, projectContents);
                 File.WriteAllText(declaredReferenceFile, _declaredReference);
                 File.WriteAllText(undeclaredReferenceFile, _undeclaredReference);
 
@@ -270,14 +390,14 @@ private void AssertBuild(
 
                 var buildParameters = new BuildParameters
                 {
-                    IsolateProjects = true,
+                    IsolateProjects = isolateProjects,
                     Loggers = new ILogger[] {logger},
                     EnableNodeReuse = false,
                     DisableInProcNode = disableInProcNode
                 };
 
                 var rootRequest = new BuildRequestData(
-                    projectFile,
+                    rootProjectFile,
                     new Dictionary<string, string>(),
                     MSBuildConstants.CurrentToolsVersion,
                     targets,
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index f75bc33e614..edd89d352a4 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -1125,30 +1125,56 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                         // waiting for results.  It is important that we tell the issuing request to wait for a result
                         // prior to issuing any necessary configuration request so that we don't get into a state where
                         // we receive the configuration response before we enter the wait state.
-                        newRequest = new BuildRequest(issuingEntry.Request.SubmissionId, GetNextBuildRequestId(),
-                            request.Config.ConfigurationId, request.Targets, issuingEntry.Request.HostServices,
-                            issuingEntry.Request.BuildEventContext, issuingEntry.Request,
-                            buildRequestDataFlags);
+                        newRequest = new BuildRequest(
+                            submissionId: issuingEntry.Request.SubmissionId,
+                            nodeRequestId: GetNextBuildRequestId(),
+                            configurationId: request.Config.ConfigurationId,
+                            escapedTargets: request.Targets,
+                            hostServices: issuingEntry.Request.HostServices,
+                            parentBuildEventContext: issuingEntry.Request.BuildEventContext,
+                            parentRequest: issuingEntry.Request,
+                            buildRequestDataFlags: buildRequestDataFlags,
+                            requestedProjectState: null,
+                            skipStaticGraphIsolationConstraints: request.SkipStaticGraphIsolationConstraints);
 
                         issuingEntry.WaitForResult(newRequest);
 
                         if (matchingConfig == null)
                         {
                             // Issue the config resolution request
-                            TraceEngine("Request {0}({1}) (nr {2}) is waiting on configuration {3} (IBR)", issuingEntry.Request.GlobalRequestId, issuingEntry.Request.ConfigurationId, issuingEntry.Request.NodeRequestId, request.Config.ConfigurationId);
+                            TraceEngine(
+                                "Request {0}({1}) (nr {2}) is waiting on configuration {3} (IBR)",
+                                issuingEntry.Request.GlobalRequestId,
+                                issuingEntry.Request.ConfigurationId,
+                                issuingEntry.Request.NodeRequestId,
+                                request.Config.ConfigurationId);
                             issuingEntry.WaitForConfiguration(request.Config);
                         }
                     }
                     else
                     {
                         // We have a configuration, see if we already have results locally.
-                        newRequest = new BuildRequest(issuingEntry.Request.SubmissionId, GetNextBuildRequestId(),
-                            matchingConfig.ConfigurationId, request.Targets, issuingEntry.Request.HostServices,
-                            issuingEntry.Request.BuildEventContext, issuingEntry.Request,
-                            buildRequestDataFlags);
+                        newRequest = new BuildRequest(
+                            submissionId: issuingEntry.Request.SubmissionId,
+                            nodeRequestId: GetNextBuildRequestId(),
+                            configurationId: matchingConfig.ConfigurationId,
+                            escapedTargets: request.Targets,
+                            hostServices: issuingEntry.Request.HostServices,
+                            parentBuildEventContext: issuingEntry.Request.BuildEventContext,
+                            parentRequest: issuingEntry.Request,
+                            buildRequestDataFlags: buildRequestDataFlags,
+                            requestedProjectState: null,
+                            skipStaticGraphIsolationConstraints: request.SkipStaticGraphIsolationConstraints);
 
                         IResultsCache resultsCache = (IResultsCache)_componentHost.GetComponent(BuildComponentType.ResultsCache);
-                        ResultsCacheResponse response = resultsCache.SatisfyRequest(newRequest, matchingConfig.ProjectInitialTargets, matchingConfig.ProjectDefaultTargets, matchingConfig.GetAfterTargetsForDefaultTargets(newRequest), skippedResultsAreOK: false);
+
+                        var response = resultsCache.SatisfyRequest(
+                            newRequest,
+                            matchingConfig.ProjectInitialTargets,
+                            matchingConfig.ProjectDefaultTargets,
+                            matchingConfig.GetAfterTargetsForDefaultTargets(newRequest),
+                            skippedResultsAreOK: false);
+
                         if (response.Type == ResultsCacheResponseType.Satisfied)
                         {
                             // We have a result, give it back to this request.
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
index 74e9e996396..dfc0b880b02 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
@@ -25,7 +25,13 @@ internal class FullyQualifiedBuildRequest
         /// <param name="targets">The set of targets to build.</param>
         /// <param name="resultsNeeded">Whether or not to wait for the results of this request.</param>
         /// <param name="flags">Flags specified for the build request.</param>
-        public FullyQualifiedBuildRequest(BuildRequestConfiguration config, string[] targets, bool resultsNeeded, BuildRequestDataFlags flags = BuildRequestDataFlags.None)
+        public FullyQualifiedBuildRequest(
+            BuildRequestConfiguration config,
+            string[] targets,
+            bool resultsNeeded,
+            bool skipStaticGraphIsolationConstraints = false,
+            BuildRequestDataFlags flags = BuildRequestDataFlags.None
+            )
         {
             ErrorUtilities.VerifyThrowArgumentNull(config, nameof(config));
             ErrorUtilities.VerifyThrowArgumentNull(targets, nameof(targets));
@@ -33,6 +39,7 @@ public FullyQualifiedBuildRequest(BuildRequestConfiguration config, string[] tar
             Config = config;
             Targets = targets;
             ResultsNeeded = resultsNeeded;
+            SkipStaticGraphIsolationConstraints = skipStaticGraphIsolationConstraints;
             BuildRequestDataFlags = flags;
         }
 
@@ -56,6 +63,8 @@ public FullyQualifiedBuildRequest(BuildRequestConfiguration config, string[] tar
         /// </summary>
         public BuildRequestDataFlags BuildRequestDataFlags { get; set; }
 
+        public bool SkipStaticGraphIsolationConstraints { get; }
+
         /// <summary>
         /// Implementation of the equality operator.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 1b18f076613..31e2bec7ae4 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -355,8 +355,14 @@ public async Task<BuildResult[]> BuildProjects(string[] projectFiles, PropertyDi
 
                 BuildRequestConfiguration config = new BuildRequestConfiguration(data, _componentHost.BuildParameters.DefaultToolsVersion);
 
-                requests[i] = new FullyQualifiedBuildRequest(config, targets, waitForResults,
-                    flags: skipNonexistentTargets ? BuildRequestDataFlags.SkipNonexistentTargets : BuildRequestDataFlags.None);
+                requests[i] = new FullyQualifiedBuildRequest(
+                    config: config,
+                    targets: targets,
+                    resultsNeeded: waitForResults,
+                    skipStaticGraphIsolationConstraints: _componentHost.BuildParameters.IsolateProjects && _requestEntry.RequestConfiguration.ShouldSkipIsolationConstraintsForReference(config.ProjectFullPath),
+                    flags: skipNonexistentTargets
+                        ? BuildRequestDataFlags.SkipNonexistentTargets
+                        : BuildRequestDataFlags.None);
             }
 
             // Send the requests off
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 378a29dbe4f..594333e16bf 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -990,7 +990,7 @@ private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
                 return null;
             }
 
-            var projectReferenceItems = _taskExecutionHost.ProjectInstance.GetItems(ItemTypeNames.ProjectReference);
+            var projectReferenceItems = _buildRequestEntry.RequestConfiguration.Project.GetItems(ItemTypeNames.ProjectReference);
 
             var declaredProjects = new HashSet<string>(projectReferenceItems.Count);
 
@@ -1008,7 +1008,9 @@ private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
             {
                 var normalizedMSBuildProject = FileUtilities.NormalizePath(msbuildProject.ItemSpec);
 
-                if (!declaredProjects.Contains(normalizedMSBuildProject))
+                if (
+                    !(declaredProjects.Contains(normalizedMSBuildProject)
+                      || _buildRequestEntry.RequestConfiguration.ShouldSkipIsolationConstraintsForReference(normalizedMSBuildProject)))
                 {
                     if (undeclaredProjects == null)
                     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 96eefa82ade..58a4b26a555 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -285,7 +285,7 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
 
             // If the caller supplies an array to put the target outputs in, it must have the same length as the array of project file names they provided, too.
             // "MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items."
-            ErrorUtilities.VerifyThrowArgument((targetOutputsPerProject == null) || (projectFileNames.Length == targetOutputsPerProject.Length), "General.TwoVectorsMustHaveSameLength", projectFileNames.Length, targetOutputsPerProject.Length, "projectFileNames", "targetOutputsPerProject");
+            ErrorUtilities.VerifyThrowArgument((targetOutputsPerProject == null) || (projectFileNames.Length == targetOutputsPerProject.Length), "General.TwoVectorsMustHaveSameLength", projectFileNames.Length, targetOutputsPerProject?.Length ?? 0, "projectFileNames", "targetOutputsPerProject");
 
             BuildEngineResult result = BuildProjectFilesInParallel(projectFileNames, targetNames, globalProperties, new List<String>[projectFileNames.Length], toolsVersion, includeTargetOutputs);
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index ea32b4244d3..38ddec64bbb 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1582,8 +1582,10 @@ private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest,
                         abortRequestBatch = true;
                     }
                 }
-                else if (CheckIfCacheMissesAreAllowed(nodeForResults, request, responses))
+                else if (CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(nodeForResults, request, responses, out var emitNonErrorLogs))
                 {
+                    emitNonErrorLogs(_componentHost.LoggingService);
+
                     // Ensure there is no affinity mismatch between this request and a previous request of the same configuration.
                     NodeAffinity requestAffinity = GetNodeAffinityForRequest(request);
                     NodeAffinity existingRequestAffinity = NodeAffinity.Any;
@@ -1730,7 +1732,7 @@ private void ResolveRequestFromCacheAndResumeIfPossible(SchedulableRequest reque
             }
             else
             {
-                CheckIfCacheMissesAreAllowed(nodeForResults, request.BuildRequest, responses);
+                CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(nodeForResults, request.BuildRequest, responses, out _);
             }
         }
 
@@ -1786,72 +1788,95 @@ private ScheduleResponse TrySatisfyRequestFromCache(int nodeForResults, BuildReq
             return null;
         }
 
-        private bool CheckIfCacheMissesAreAllowed(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses)
+        /// <returns>True if caches misses are allowed, false otherwise</returns>
+        private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeForResults, BuildRequest request, List<ScheduleResponse> responses, out Action<ILoggingService> emitNonErrorLogs)
         {
+            emitNonErrorLogs = _ => { };
+
             var isIsolatedBuild = _componentHost.BuildParameters.IsolateProjects;
+            var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);
 
             // do not check root requests as nothing depends on them
-            if (!request.IsRootRequest && isIsolatedBuild)
+            if (!isIsolatedBuild || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints)
             {
-                var configCache = (IConfigCache) _componentHost.GetComponent(BuildComponentType.ConfigCache);
-                var requestConfig = configCache[request.ConfigurationId];
-
-                // Need the parent request. But the parent / child relationship is sometimes formed after the cache is queried, so get creative
-                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);
-                if (parentRequest == null)
+                if (isIsolatedBuild && request.SkipStaticGraphIsolationConstraints)
                 {
-                    // the parent might still be in executing requests because the scheduler might not have had a chance to mark it as blocked yet
-                    parentRequest = _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);
+                    // retrieving the configs is not quite free, so avoid computing them eagerly
+                    var configs = GetConfigurations();
+
+                    emitNonErrorLogs = ls => ls.LogComment(
+                            NewBuildEventContext(),
+                            MessageImportance.Normal,
+                            "SkippedConstraintsOnRequest",
+                            configs.parentConfig.ProjectFullPath,
+                            configs.requestConfig.ProjectFullPath);
                 }
 
-                ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));
-                ErrorUtilities.VerifyThrow(
-                    configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),
-                    "All non root requests should have a parent with a loaded configuration");
+                return true;
+            }
 
-                var parentConfig = configCache[parentRequest.BuildRequest.ConfigurationId];
+            var (requestConfig, parentConfig) = GetConfigurations();
 
-                // allow self references (project calling the msbuild task on itself, potentially with different global properties)
-                if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))
-                {
-                    return true;
-                }
+            // allow self references (project calling the msbuild task on itself, potentially with different global properties)
+            if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))
+            {
+                return true;
+            }
 
-                var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
-                    "CacheMissesNotAllowedInIsolatedGraphBuilds",
-                    parentConfig.ProjectFullPath,
-                    requestConfig.ProjectFullPath,
-                    request.Targets.Count == 0
-                        ? "default"
-                        : string.Join(";", request.Targets));
+            var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                "CacheMissesNotAllowedInIsolatedGraphBuilds",
+                parentConfig.ProjectFullPath,
+                requestConfig.ProjectFullPath,
+                request.Targets.Count == 0
+                    ? "default"
+                    : string.Join(";", request.Targets));
 
-                // Issue a failed build result to have the msbuild task marked as failed and thus stop the build
-                BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));
-                result.SetOverallResult(false);
+            // Issue a failed build result to have the msbuild task marked as failed and thus stop the build
+            BuildResult result = new BuildResult(request, new InvalidOperationException(errorMessage));
+            result.SetOverallResult(false);
 
-                var response = GetResponseForResult(nodeForResults, request, result);
-                responses.Add(response);
+            var response = GetResponseForResult(nodeForResults, request, result);
+            responses.Add(response);
 
-                // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors
-                // todo Search if there's a way to have the error automagically logged in response to the failed build result
-                _componentHost.LoggingService.LogErrorFromText(
-                    new BuildEventContext(
-                        request.SubmissionId,
-                        1,
-                        BuildEventContext.InvalidProjectInstanceId,
-                        BuildEventContext.InvalidProjectContextId,
-                        BuildEventContext.InvalidTargetId,
-                        BuildEventContext.InvalidTaskId),
-                    null,
-                    null,
-                    null,
-                    new BuildEventFileInfo(requestConfig.ProjectFullPath),
-                    errorMessage);
+            // Log an error to have something displayed to the user and to avoid having a failed build with 0 errors
+            // todo Search if there's a way to have the error automagically logged in response to the failed build result
+            _componentHost.LoggingService.LogErrorFromText(
+                NewBuildEventContext(),
+                null,
+                null,
+                null,
+                new BuildEventFileInfo(requestConfig.ProjectFullPath),
+                errorMessage);
 
-                return false;
+            return false;
+
+            BuildEventContext NewBuildEventContext()
+            {
+                return new BuildEventContext(
+                    request.SubmissionId,
+                    1,
+                    BuildEventContext.InvalidProjectInstanceId,
+                    BuildEventContext.InvalidProjectContextId,
+                    BuildEventContext.InvalidTargetId,
+                    BuildEventContext.InvalidTaskId);
             }
 
-            return true;
+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) GetConfigurations()
+            {
+                var buildRequestConfiguration = configCache[request.ConfigurationId];
+
+                // Need the parent request. It might be blocked or executing; check both.
+                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)
+                                    ?? _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);
+
+                ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));
+                ErrorUtilities.VerifyThrow(
+                    configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),
+                    "All non root requests should have a parent with a loaded configuration");
+
+                var parentConfiguration = configCache[parentRequest.BuildRequest.ConfigurationId];
+                return (buildRequestConfiguration, parentConfiguration);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index da2142a0d38..0b76c0090a2 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -80,10 +80,7 @@ internal class BuildRequest : INodePacket
         /// </summary>
         private RequestedProjectState _requestedProjectState;
 
-        /// <summary>
-        /// If set, skip targets that are not defined in the projects to be built.
-        /// </summary>
-        private bool _skipNonexistentTargets;
+        private bool _skipStaticGraphIsolationConstraints;
 
         /// <summary>
         /// Constructor for serialization.
@@ -102,6 +99,7 @@ public BuildRequest()
         /// <param name="hostServices">Host services if any. May be null.</param>
         /// <param name="parentBuildEventContext">The build event context of the parent project.</param>
         /// <param name="parentRequest">The parent build request, if any.</param>
+        /// <param name="skipStaticGraphIsolationConstraints"></param>
         /// <param name="buildRequestDataFlags">Additional flags for the request.</param>
         /// <param name="requestedProjectState">Filter for desired build results.</param>
         public BuildRequest(
@@ -113,7 +111,8 @@ public BuildRequest(
             BuildEventContext parentBuildEventContext,
             BuildRequest parentRequest,
             BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
-            RequestedProjectState requestedProjectState = null)
+            RequestedProjectState requestedProjectState = null,
+            bool skipStaticGraphIsolationConstraints = false)
         {
             ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
             ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, "parentBuildEventContext");
@@ -137,6 +136,8 @@ public BuildRequest(
             _nodeRequestId = nodeRequestId;
             _buildRequestDataFlags = buildRequestDataFlags;
             _requestedProjectState = requestedProjectState;
+
+            _skipStaticGraphIsolationConstraints = skipStaticGraphIsolationConstraints;
         }
 
         /// <summary>
@@ -309,13 +310,9 @@ internal bool IsRootRequest
         }
 
         /// <summary>
-        /// If set, skip targets that are not defined in the projects to be built.
+        /// Whether static graph isolation constraints should be skipped for this request
         /// </summary>
-        internal bool SkipNonexistentTargets
-        {
-            get => _skipNonexistentTargets;
-            set => _skipNonexistentTargets = value;
-        }
+        internal bool SkipStaticGraphIsolationConstraints => _skipStaticGraphIsolationConstraints;
 
         /// <summary>
         /// Sets the configuration id to a resolved id.
@@ -344,7 +341,7 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _parentBuildEventContext);
             translator.Translate(ref _buildEventContext);
             translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
-            translator.Translate(ref _skipNonexistentTargets);
+            translator.Translate(ref _skipStaticGraphIsolationConstraints);
             translator.Translate(ref _requestedProjectState);
             translator.Translate(ref _hostServices);
 
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index a720c981851..b7219edaddc 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -9,7 +9,11 @@
 using Microsoft.Build.Collections;
 using System.Diagnostics;
 using System.IO;
+using System.Linq;
+using System.Threading;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Globbing;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.BackEnd
@@ -710,6 +714,47 @@ public List<string> GetAfterTargetsForDefaultTargets(BuildRequest request)
             return null;
         }
 
+        private Func<string, bool> shouldSkipStaticGraphIsolationOnReference;
+
+        public bool ShouldSkipIsolationConstraintsForReference(string referenceFullPath)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(Project, nameof(Project));
+            ErrorUtilities.VerifyThrowInternalLength(referenceFullPath, nameof(referenceFullPath));
+            ErrorUtilities.VerifyThrow(Path.IsPathRooted(referenceFullPath), "Method does not treat path normalization cases");
+
+            if (shouldSkipStaticGraphIsolationOnReference == null)
+            {
+                shouldSkipStaticGraphIsolationOnReference = GetReferenceFilter();
+            }
+
+            return shouldSkipStaticGraphIsolationOnReference(referenceFullPath);
+
+            Func<string, bool> GetReferenceFilter()
+            {
+                lock (_syncLock)
+                {
+                    if (shouldSkipStaticGraphIsolationOnReference != null)
+                    {
+                        return shouldSkipStaticGraphIsolationOnReference;
+                    }
+
+                    var items = Project.GetItems(ItemTypeNames.GraphIsolationExemptReference);
+
+                    if (items.Count == 0 || items.All(i => string.IsNullOrWhiteSpace(i.EvaluatedInclude)))
+                    {
+                        return _ => false;
+                    }
+
+                    var fragments = items.SelectMany(i => ExpressionShredder.SplitSemiColonSeparatedList(i.EvaluatedInclude));
+                    var glob = new CompositeGlob(
+                        fragments
+                            .Select(s => MSBuildGlob.Parse(Project.Directory, s)));
+
+                    return s => glob.IsMatch(s);
+                }
+            }
+        }
+
         /// <summary>
         /// This override is used to provide a hash code for storage in dictionaries and the like.
         /// </summary>
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index a8fe06b7345..1918b6f394c 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -223,7 +223,7 @@ private static string NormalizeTheFixedDirectoryPartAgainstTheGlobRoot(string fi
 
         /// <summary>
         ///     See <see cref="Parse(string,string)" />.
-        ///     The glob root will be the current working directory.
+        ///     The glob root, if the glob is not fully qualified, will be the current working directory.
         /// </summary>
         /// <param name="fileSpec"></param>
         /// <returns></returns>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index f255737e458..c59c6abd2bc 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1733,7 +1733,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     </comment>
   </data>
   <data name="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds" UESanitized="false" Visibility="Public">
-    <value>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</value>
+    <value>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</value>
     <comment>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
@@ -1763,13 +1763,19 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is a file path
     </comment>
   </data>
+  <data name="SkippedConstraintsOnRequest" UESanitized="false" Visibility="Public">
+    <value>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</value>
+    <comment>
+      LOCALIZATION: {0} and {1} are file paths
+    </comment>
+  </data>
   <!--
         The engine message bucket is: MSB4001 - MSB4999
 
         MSB4128 is being used in FileLogger.cs (can't be added here yet as strings are currently frozen)
         MSB4129 is used by Shared\XmlUtilities.cs (can't be added here yet as strings are currently frozen)
 
-        Next message code should be MSB4259.
+        Next message code should be MSB4260.
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 512afe58ab4..d5c8b82fc31 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: loha MSBuild sestavuje projekty {0}, kter nejsou zadan v poloce ProjectReference. V izolovanch sestavench to pravdpodobn znamen, e tyto odkazy nejsou v {1} explicitn zadan jako poloka ProjectReference.</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: loha MSBuild sestavuje projekty {0}, kter nejsou zadan v poloce ProjectReference. V izolovanch sestavench to pravdpodobn znamen, e tyto odkazy nejsou v {1} explicitn zadan jako poloka ProjectReference.</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 993fc20c7b5..b5848b0a0e6 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: Mit der MSBuild-Aufgabe werden die Projekte "{0}" erstellt, die nicht im ProjectReference-Element angegeben wurden. In isolierten Builds bedeutet dies wahrscheinlich, dass der Verweis nicht explizit als ProjectReference-Element in "{1}" angegeben wurde.</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: Mit der MSBuild-Aufgabe werden die Projekte "{0}" erstellt, die nicht im ProjectReference-Element angegeben wurden. In isolierten Builds bedeutet dies wahrscheinlich, dass der Verweis nicht explizit als ProjectReference-Element in "{1}" angegeben wurde.</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index 09a76e95dd1..39d40db568b 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="new">MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="new">MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 1cf4503a951..2f0d5a3cf55 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: La tarea MSBuild est compilando proyectos {0} que no se especifican en el elemento ProjectReference. En compilaciones aisladas, esto significa probablemente que las referencias no se especifican explcitamente como un elemento ProjectReference en "{1}"</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: La tarea MSBuild est compilando proyectos {0} que no se especifican en el elemento ProjectReference. En compilaciones aisladas, esto significa probablemente que las referencias no se especifican explcitamente como un elemento ProjectReference en "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index d056f4936da..437fa11a1d9 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: La tche MSBuild gnre un ou des projets {0} qui ne sont pas spcifis dans l'lment ProjectReference. Dans les builds isoles, cela signifie probablement que les rfrences ne sont pas explicitement spcifies en tant qu'lment ProjectReference dans "{1}"</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: La tche MSBuild gnre un ou des projets {0} qui ne sont pas spcifis dans l'lment ProjectReference. Dans les builds isoles, cela signifie probablement que les rfrences ne sont pas explicitement spcifies en tant qu'lment ProjectReference dans "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 7118e914a64..cd5e77491d5 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: il task MSBuild compila progetti {0} che non sono specificati nell'elemento ProjectReference. Nelle compilazioni isolate questa condizione indica probabilmente che i riferimenti non sono specificati in modo esplicito come elemento ProjectReference in "{1}"</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: il task MSBuild compila progetti {0} che non sono specificati nell'elemento ProjectReference. Nelle compilazioni isolate questa condizione indica probabilmente che i riferimenti non sono specificati in modo esplicito come elemento ProjectReference in "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 6aebf001288..cecbee2cf0a 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: ProjectReference  {0}  MSBuild  "{1}"  ProjectReference </target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: ProjectReference  {0}  MSBuild  "{1}"  ProjectReference </target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 4247c39fb18..abe7d660676 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: MSBuild  ProjectReference    {0}   .     "{1}" ProjectReference       .</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: MSBuild  ProjectReference    {0}   .     "{1}" ProjectReference       .</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 5c4655d601c..2609f630544 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: Zadanie programu MSBuild kompiluje projekty {0}, ktre nie s okrelone w elemencie ProjectReference. W przypadku kompilacji izolowanych prawdopodobnie oznacza to, e odwoania nie zostay jawnie okrelone jako element ProjectReference w pliku {1}</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: Zadanie programu MSBuild kompiluje projekty {0}, ktre nie s okrelone w elemencie ProjectReference. W przypadku kompilacji izolowanych prawdopodobnie oznacza to, e odwoania nie zostay jawnie okrelone jako element ProjectReference w pliku {1}</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 75801c54f9e..ecd89e42500 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -105,11 +105,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: A tarefa MSBuild est compilando projetos {0} que no esto especificados no item ProjectReference. Em builds isolados, isso provavelmente significa que as referncias no so especificadas de forma explcita como um item de ProjectReference em "{1}"</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: A tarefa MSBuild est compilando projetos {0} que no esto especificados no item ProjectReference. Em builds isolados, isso provavelmente significa que as referncias no so especificadas de forma explcita como um item de ProjectReference em "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index ddcfcf4ba80..c44dcfd29ff 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254:  MSBuild  () {0},      ProjectReference.      ,        ProjectReference  "{1}"</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254:  MSBuild  () {0},      ProjectReference.      ,        ProjectReference  "{1}"</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index f4dbe99b7aa..4bd7f4f0353 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: MSBuild grevi, ProjectReference esinde belirtilmeyen {0} projesini derliyor. Yaltlm derlemelerde bu genellikle bavurularn "{1}" iinde aka ProjectReference esi olarak belirtilmedii anlamna gelir</target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: MSBuild grevi, ProjectReference esinde belirtilmeyen {0} projesini derliyor. Yaltlm derlemelerde bu genellikle bavurularn "{1}" iinde aka ProjectReference esi olarak belirtilmedii anlamna gelir</target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 0f8259f095f..7dc77fc5abd 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: MSBuild  ProjectReference  {0} {1} ProjectReference </target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: MSBuild  ProjectReference  {0} {1} ProjectReference </target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index a912a88a85c..2d6626e9be2 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -106,11 +106,18 @@
         <note>
       {StrBegin="MSB4250: "}
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
+    </note>
+      </trans-unit>
+      <trans-unit id="SkippedConstraintsOnRequest">
+        <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
+        <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
+        <note>
+      LOCALIZATION: {0} and {1} are file paths
     </note>
       </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4254: The MSBuild task is building project(s) {0} which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
-        <target state="translated">MSB4254: MSBuild  {0}  ProjectReference  "{1}"  ProjectReference </target>
+        <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
+        <target state="needs-review-translation">MSB4254: MSBuild  {0}  ProjectReference  "{1}"  ProjectReference </target>
         <note>
       {StrBegin="MSB4254:"}
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 312814279f9..afc7e4c70a2 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -78,8 +78,8 @@ internal static class MSBuildConstants
         /// Current version of this MSBuild Engine assembly in the form, e.g, "12.0"
         /// </summary>
         internal const string CurrentProductVersion = "16.0";
-		
-		/// <summary>
+        
+        /// <summary>
         /// Symbol used in ProjectReferenceTarget items to represent default targets
         /// </summary>
         internal const string DefaultTargetsMarker = ".default";
@@ -89,8 +89,8 @@ internal static class MSBuildConstants
         /// with fallback to default targets if the ProjectReference item has no targets specified.
         /// </summary>
         internal const string ProjectReferenceTargetsOrDefaultTargetsMarker = ".projectReferenceTargetsOrDefaultTargets";
-		
-		// One-time allocations to avoid implicit allocations for Split(), Trim().
+        
+        // One-time allocations to avoid implicit allocations for Split(), Trim().
         internal static readonly char[] SemicolonChar = { ';' };
         internal static readonly char[] SpaceChar = { ' ' };
         internal static readonly char[] SingleQuoteChar = { '\'' };
@@ -133,6 +133,8 @@ internal static class ItemTypeNames
         /// Statically specifies what targets a project calls on its references
         /// </summary>
         internal const string ProjectReferenceTargets = nameof(ProjectReferenceTargets);
+
+        internal const string GraphIsolationExemptReference = nameof(GraphIsolationExemptReference);
     }
 
     /// <summary>
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 2fc743937a9..07af5356dc7 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -8,6 +8,7 @@
 using System.Reflection;
 using System.Resources;
 using System.Text;
+using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
 using Shouldly;
 using Xunit;
@@ -472,5 +473,11 @@ internal void AssertLogDoesntContain(string contains)
         /// Assert that no warnings were logged
         /// </summary>
         internal void AssertNoWarnings() => Assert.Equal(0, WarningCount);
+
+        internal void AssertMessageCount(string message, int expectedCount)
+        {
+            var matches = Regex.Matches(FullLog, message);
+            matches.Count.ShouldBe(expectedCount);
+        }
     }
 }
diff --git a/src/Tasks/Microsoft.Managed.targets b/src/Tasks/Microsoft.Managed.targets
index 5e81b324d25..e71e2a89775 100644
--- a/src/Tasks/Microsoft.Managed.targets
+++ b/src/Tasks/Microsoft.Managed.targets
@@ -35,6 +35,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <DisableTransitiveProjectReferences Condition="'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''">true</DisableTransitiveProjectReferences>
    </PropertyGroup>
 
+   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
+      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.
+           Detect WPF, and exclude the generated project from static graph isolation constraint checking.
+           Escape the item to avoid eager evaluation of the wildcards.
+      -->
+      <GraphIsolationExemptReference
+         Condition="'$(UseWPF)' == 'true' or '@(Page)' != '' or '@(ApplicationDefinition)' != '' or '@(XamlPage)' != '' or '@(XamlAppDef)' != ''"
+         Include="$([MSBuild]::Escape('$(MSBuildProjectDirectory)\$(MSBuildProjectName)*_wpftmp$(MSBuildProjectExtension)'))" />
+   </ItemGroup>
+
   <!--
     Properties for extension of ProjectReferenceTargets.
     Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
