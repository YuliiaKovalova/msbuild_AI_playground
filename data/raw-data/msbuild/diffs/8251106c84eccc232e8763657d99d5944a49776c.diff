diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index d59f83ba636..45651faea11 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -1116,6 +1116,13 @@ public enum NodeEngineShutdownReason
         ConnectionFailed = 2,
         Error = 3,
     }
+    public partial class OutOfProcEntryNode
+    {
+        public OutOfProcEntryNode(System.Func<string, System.ValueTuple<int, string>> buildFunction) { }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) { throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, out System.Exception shutdownException) { throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { throw null; }
+    }
     public partial class OutOfProcNode
     {
         public OutOfProcNode() { }
@@ -1574,8 +1581,8 @@ protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) {
         public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
-        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
-        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
+        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
         protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
         public override string ToString() { throw null; }
         public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index ab3acb3d087..a37bc73db3d 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -1110,6 +1110,13 @@ public enum NodeEngineShutdownReason
         ConnectionFailed = 2,
         Error = 3,
     }
+    public partial class OutOfProcEntryNode
+    {
+        public OutOfProcEntryNode(System.Func<string, System.ValueTuple<int, string>> buildFunction) { }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) { throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(bool enableReuse, out System.Exception shutdownException) { throw null; }
+        public Microsoft.Build.Execution.NodeEngineShutdownReason Run(out System.Exception shutdownException) { throw null; }
+    }
     public partial class OutOfProcNode
     {
         public OutOfProcNode() { }
@@ -1568,8 +1575,8 @@ protected GraphBuildOptions(Microsoft.Build.Graph.GraphBuildOptions original) {
         public virtual bool Equals(Microsoft.Build.Graph.GraphBuildOptions other) { throw null; }
         public override bool Equals(object obj) { throw null; }
         public override int GetHashCode() { throw null; }
-        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
-        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions r1, Microsoft.Build.Graph.GraphBuildOptions r2) { throw null; }
+        public static bool operator ==(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
+        public static bool operator !=(Microsoft.Build.Graph.GraphBuildOptions left, Microsoft.Build.Graph.GraphBuildOptions right) { throw null; }
         protected virtual bool PrintMembers(System.Text.StringBuilder builder) { throw null; }
         public override string ToString() { throw null; }
         public virtual Microsoft.Build.Graph.GraphBuildOptions <Clone>$() { throw null; }
diff --git a/src/Build/BackEnd/Components/Communications/EntryNodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/EntryNodeEndpointOutOfProc.cs
new file mode 100644
index 00000000000..ffa9f6f52c8
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/EntryNodeEndpointOutOfProc.cs
@@ -0,0 +1,45 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// This is an implementation of INodeEndpoint for the out-of-proc nodes.  It acts only as a client.
+    /// </summary>
+    internal class EntryNodeEndpointOutOfProc : NodeEndpointOutOfProcBase
+    {
+        #region Private Data
+
+        private readonly IHandshake _handshake;
+
+        #endregion
+
+        #region Constructors and Factories
+
+        /// <summary>
+        /// Instantiates an endpoint to act as a client
+        /// </summary>
+        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
+        /// <param name="handshake"></param>
+        internal EntryNodeEndpointOutOfProc(
+            string pipeName,
+            IHandshake handshake)
+        {
+            _handshake = handshake;
+
+            InternalConstruct(pipeName);
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Returns the host handshake for this node endpoint
+        /// </summary>
+        protected override IHandshake GetHandshake()
+        {
+            return _handshake;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/EntryNodeHandshake.cs b/src/Build/BackEnd/Components/Communications/EntryNodeHandshake.cs
new file mode 100644
index 00000000000..b23984cf1e1
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/EntryNodeHandshake.cs
@@ -0,0 +1,94 @@
+﻿using System;
+using System.Diagnostics;
+using System.Globalization;
+using System.IO;
+using System.Security.Cryptography;
+using System.Text;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal class EntryNodeHandshake : IHandshake
+    {
+        /// <summary>
+        /// The version of the handshake. This should be updated each time the handshake is altered.
+        /// </summary>
+        readonly int _version = 0x101;
+
+        readonly int _options;
+        readonly int _salt;
+        readonly int _fileVersionMajor;
+        readonly int _fileVersionMinor;
+        readonly int _fileVersionBuild;
+        readonly int _fileVersionRevision;
+
+        internal EntryNodeHandshake(HandshakeOptions nodeType, string msBuildLocation)
+        {
+            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
+            // This indicates in the first byte that we are a modern build.
+            _options = (int)nodeType;
+            string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
+            var msBuildFile = new FileInfo(msBuildLocation);
+            var msBuildDirectory = msBuildFile.DirectoryName;
+            _salt = ComputeHandshakeHash(handshakeSalt + msBuildDirectory);
+            Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(msBuildLocation).FileVersion ?? string.Empty);
+            _fileVersionMajor = fileVersion.Major;
+            _fileVersionMinor = fileVersion.Minor;
+            _fileVersionBuild = fileVersion.Build;
+            _fileVersionRevision = fileVersion.Revision;
+        }
+
+        internal const int EndOfHandshakeSignal = -0x2a2a2a2a;
+
+        /// <summary>
+        /// Compute stable hash as integer
+        /// </summary>
+        private static int ComputeHandshakeHash(string fromString)
+        {
+            using var sha = SHA256.Create();
+            var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(fromString));
+
+            return BitConverter.ToInt32(bytes, 0);
+        }
+
+        internal static int AvoidEndOfHandshakeSignal(int x)
+        {
+            return x == EndOfHandshakeSignal ? ~x : x;
+        }
+
+        public int[] RetrieveHandshakeComponents()
+        {
+            return new int[]
+            {
+                AvoidEndOfHandshakeSignal(_version),
+                AvoidEndOfHandshakeSignal(_options),
+                AvoidEndOfHandshakeSignal(_salt),
+                AvoidEndOfHandshakeSignal(_fileVersionMajor),
+                AvoidEndOfHandshakeSignal(_fileVersionMinor),
+                AvoidEndOfHandshakeSignal(_fileVersionBuild),
+                AvoidEndOfHandshakeSignal(_fileVersionRevision),
+            };
+        }
+
+        public string GetKey()
+        {
+            return $"{_version} {_options} {_salt} {_fileVersionMajor} {_fileVersionMinor} {_fileVersionBuild} {_fileVersionRevision}"
+                .ToString(CultureInfo.InvariantCulture);
+        }
+
+        public byte? ExpectedVersionInFirstByte => null;
+
+        /// <summary>
+        /// Computes Handshake stable hash string representing whole state of handshake.
+        /// </summary>
+        public string ComputeHash()
+        {
+            var input = GetKey();
+            using var sha = SHA256.Create();
+            var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input));
+            return Convert.ToBase64String(bytes)
+                .Replace("/", "_")
+                .Replace("=", string.Empty);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 132cb665bb1..60159b5267a 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -52,7 +52,7 @@ internal NodeEndpointOutOfProc(
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override Handshake GetHandshake()
+        protected override IHandshake GetHandshake()
         {
             return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess, nodeReuse: _enableReuse, lowPriority: _lowPriority));
         }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 11ea72ba505..df67423ef55 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -63,7 +63,7 @@ public int AvailableNodes
         /// </summary>
         /// <param name="enableNodeReuse">Is reuse of build nodes allowed?</param>
         /// <param name="enableLowPriority">Is the build running at low priority?</param>
-        internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPriority)
+        internal static IHandshake GetHandshake(bool enableNodeReuse, bool enableLowPriority)
         {
             CommunicationsUtilities.Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", enableNodeReuse={2}, enableLowPriority={3}", Traits.MSBuildNodeHandshakeSalt, BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, enableNodeReuse, enableLowPriority);
             return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
@@ -91,7 +91,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
             // Make it here.
             CommunicationsUtilities.Trace("Starting to acquire a new or existing node to establish node ID {0}...", nodeId);
 
-            Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            IHandshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
             NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);
 
             if (context != null)
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 9dc051c711e..cf7fcd205ac 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -9,7 +9,6 @@
 using System.IO;
 using System.IO.Pipes;
 using System.Diagnostics;
-using System.Threading;
 using System.Threading.Tasks;
 using System.Runtime.InteropServices;
 #if FEATURE_PIPE_SECURITY
@@ -180,7 +179,7 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
         /// Finds or creates a child process which can act as a node.
         /// </summary>
         /// <returns>The pipe stream representing the node.</returns>
-        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, Handshake hostHandshake, NodeContextTerminateDelegate terminateNode)
+        protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, int nodeId, INodePacketFactory factory, IHandshake hostHandshake, NodeContextTerminateDelegate terminateNode)
         {
 #if DEBUG
             if (Execution.BuildManager.WaitForDebugger)
@@ -324,9 +323,9 @@ protected NodeContext GetNode(string msbuildLocation, string commandLineArgs, in
         /// Generate a string from task host context and the remote process to be used as key to lookup processes we have already
         /// attempted to connect to or are already connected to
         /// </summary>
-        private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessId)
+        private string GetProcessesToIgnoreKey(IHandshake hostHandshake, int nodeProcessId)
         {
-            return hostHandshake.ToString() + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
+            return hostHandshake.GetKey() + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
         }
 
 #if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
@@ -353,7 +352,7 @@ private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStrea
         /// <summary>
         /// Attempts to connect to the specified process.
         /// </summary>
-        private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
+        private Stream TryConnectToProcess(int nodeProcessId, int timeout, IHandshake handshake)
         {
             // Try and connect to the process.
             string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + nodeProcessId);
diff --git a/src/Build/BackEnd/Node/EntryNodeCommand.cs b/src/Build/BackEnd/Node/EntryNodeCommand.cs
new file mode 100644
index 00000000000..58af3f04508
--- /dev/null
+++ b/src/Build/BackEnd/Node/EntryNodeCommand.cs
@@ -0,0 +1,217 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal class EntryNodeConsoleWrite : INodePacket
+    {
+        public string Text { get; }
+        public ConsoleColor Foreground { get; }
+        public ConsoleColor Background { get; }
+
+        /// <summary>
+        /// 1 = stdout, 2 = stderr
+        /// </summary>
+        public byte OutputType { get; }
+
+        public EntryNodeConsoleWrite(string text, ConsoleColor foreground, ConsoleColor background, byte outputType)
+        {
+            Text = text;
+            Foreground = foreground;
+            Background = background;
+            OutputType = outputType;
+        }
+
+        #region INodePacket Members
+
+        /// <summary>
+        /// Packet type.
+        /// This has to be in sync with Microsoft.Build.BackEnd.NodePacketType.EntryNodeInfo
+        /// </summary>
+        public NodePacketType Type => NodePacketType.EntryNodeConsole;
+
+        #endregion
+
+        public void Translate(ITranslator translator)
+        {
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                var bw = translator.Writer;
+
+                bw.Write(Text);
+                bw.Write((int)Foreground);
+                bw.Write((int)Background);
+                bw.Write(OutputType);
+            }
+            else
+            {
+                throw new InvalidOperationException("Read from stream not supported");
+            }
+        }
+    }
+
+    internal class EntryNodeResponse : INodePacket
+    {
+        public EntryNodeResponse(int exitCode, string exitType)
+        {
+            ExitCode = exitCode;
+            ExitType = exitType;
+        }
+
+        #region INodePacket Members
+
+        /// <summary>
+        /// Packet type.
+        /// This has to be in sync with Microsoft.Build.BackEnd.NodePacketType.EntryNodeCommand
+        /// </summary>
+        public NodePacketType Type => NodePacketType.EntryNodeResponse;
+
+        #endregion
+
+        public int ExitCode { get; }
+
+        public string ExitType { get; }
+
+        public void Translate(ITranslator translator)
+        {
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                var bw = translator.Writer;
+
+                bw.Write(ExitCode);
+                bw.Write(ExitType);
+            }
+            else
+            {
+                throw new InvalidOperationException("Read from stream not supported");
+            }
+        }
+    }
+
+    /// <summary>
+    /// EntryNodeCommand contains all of the information necessary for a entry node to run a command line.
+    /// </summary>
+    internal class EntryNodeCommand : INodePacket
+    {
+        /// <summary>
+        /// The startup directory
+        /// </summary>
+        private string _commandLine;
+
+        /// <summary>
+        /// The startup directory
+        /// </summary>
+        private string _startupDirectory;
+
+        /// <summary>
+        /// The process environment.
+        /// </summary>
+        private Dictionary<string, string> _buildProcessEnvironment;
+
+        /// <summary>
+        /// The culture
+        /// </summary>
+        private CultureInfo _culture;
+
+        /// <summary>
+        /// The UI culture.
+        /// </summary>
+        private CultureInfo _uiCulture;
+
+        public EntryNodeCommand(string commandLine, string startupDirectory, Dictionary<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture)
+        {
+            _commandLine = commandLine;
+            _startupDirectory = startupDirectory;
+            _buildProcessEnvironment = buildProcessEnvironment;
+            _culture = culture;
+            _uiCulture = uiCulture;
+        }
+
+        /// <summary>
+        /// Private constructor for deserialization
+        /// </summary>
+        private EntryNodeCommand()
+        {
+        }
+
+#region INodePacket Members
+
+        /// <summary>
+        /// Retrieves the packet type.
+        /// </summary>
+        public NodePacketType Type => NodePacketType.EntryNodeCommand;
+
+#endregion
+
+        /// <summary>
+        /// The startup directory
+        /// </summary>
+        public string CommandLine => _commandLine;
+
+        /// <summary>
+        /// The startup directory
+        /// </summary>
+        public string StartupDirectory => _startupDirectory;
+
+        /// <summary>
+        /// The process environment.
+        /// </summary>
+        public Dictionary<string, string> BuildProcessEnvironment => _buildProcessEnvironment;
+
+        /// <summary>
+        /// The culture
+        /// </summary>
+        public CultureInfo Culture => _culture;
+
+        /// <summary>
+        /// The UI culture.
+        /// </summary>
+        public CultureInfo UICulture => _uiCulture;
+
+#region INodePacketTranslatable Members
+
+        /// <summary>
+        /// Translates the packet to/from binary form.
+        /// </summary>
+        /// <param name="translator">The translator to use.</param>
+        public void Translate(ITranslator translator)
+        {
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                var br = translator.Reader;
+
+                _commandLine = br.ReadString();
+                _startupDirectory = br.ReadString();
+                int count = br.ReadInt32();
+                _buildProcessEnvironment = new Dictionary<string, string>(count, StringComparer.OrdinalIgnoreCase);
+                for (int i = 0; i < count; ++i)
+                {
+                    var key = br.ReadString();
+                    var value = br.ReadString();
+                    _buildProcessEnvironment.Add(key, value);
+                }
+                _culture = new CultureInfo(br.ReadString());
+                _uiCulture = new CultureInfo(br.ReadString());
+            }
+            else
+            {
+                throw new InvalidOperationException("Writing into stream not supported");
+            }
+        }
+
+        /// <summary>
+        /// Factory for deserialization.
+        /// </summary>
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            EntryNodeCommand command = new ();
+            command.Translate(translator);
+            return command;
+        }
+#endregion
+    }
+}
diff --git a/src/Build/BackEnd/Node/OutOfProcEntryNode.cs b/src/Build/BackEnd/Node/OutOfProcEntryNode.cs
new file mode 100644
index 00000000000..a96ffc31e46
--- /dev/null
+++ b/src/Build/BackEnd/Node/OutOfProcEntryNode.cs
@@ -0,0 +1,443 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Concurrent;
+using System.IO;
+using System.Linq;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// This class represents an implementation of INode for out-of-proc entry nodes aka MSBuild server 
+    /// </summary>
+    public class OutOfProcEntryNode : INode, INodePacketFactory, INodePacketHandler
+    {
+        private readonly Func<string, (int exitCode, string exitType)> _buildFunction;
+
+        /// <summary>
+        /// The endpoint used to talk to the host.
+        /// </summary>
+        private INodeEndpoint _nodeEndpoint;
+
+        /// <summary>
+        /// The packet factory.
+        /// </summary>
+        private readonly NodePacketFactory _packetFactory;
+
+        /// <summary>
+        /// The queue of packets we have received but which have not yet been processed.
+        /// </summary>
+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;
+
+        /// <summary>
+        /// The event which is set when we receive packets.
+        /// </summary>
+        private readonly AutoResetEvent _packetReceivedEvent;
+
+        /// <summary>
+        /// The event which is set when we should shut down.
+        /// </summary>
+        private readonly ManualResetEvent _shutdownEvent;
+
+        /// <summary>
+        /// The reason we are shutting down.
+        /// </summary>
+        private NodeEngineShutdownReason _shutdownReason;
+
+        /// <summary>
+        /// The exception, if any, which caused shutdown.
+        /// </summary>
+        private Exception _shutdownException = null;
+
+        /// <summary>
+        /// Flag indicating if we should debug communications or not.
+        /// </summary>
+        private readonly bool _debugCommunications;
+
+        private string _serverBusyMutexName;
+
+        public OutOfProcEntryNode(Func<string, (int exitCode, string exitType)> buildFunction)
+        {
+            _buildFunction = buildFunction;
+            new Dictionary<string, string>();
+            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
+
+            _receivedPackets = new ConcurrentQueue<INodePacket>();
+            _packetReceivedEvent = new AutoResetEvent(false);
+            _shutdownEvent = new ManualResetEvent(false);
+            _packetFactory = new NodePacketFactory();
+
+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.EntryNodeCommand, EntryNodeCommand.FactoryForDeserialization, this);
+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);
+        }
+
+        #region INode Members
+
+        /// <summary>
+        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// Assumes no node reuse.
+        /// Assumes low priority is disabled.
+        /// </summary>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <returns>The reason for shutting down.</returns>
+        public NodeEngineShutdownReason Run(out Exception shutdownException)
+        {
+            return Run(false, false, out shutdownException);
+        }
+
+        /// <summary>
+        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// Assumes low priority is disabled.
+        /// </summary>
+        /// <param name="enableReuse">Whether this node is eligible for reuse later.</param>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <returns>The reason for shutting down.</returns>
+        public NodeEngineShutdownReason Run(bool enableReuse, out Exception shutdownException)
+        {
+            return Run(enableReuse, false, out shutdownException);
+        }
+
+        /// <summary>
+        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// </summary>
+        /// <param name="enableReuse">Whether this node is eligible for reuse later.</param>
+        /// <param name="lowPriority">Whether this node should be running with low priority.</param>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <returns>The reason for shutting down.</returns>
+        public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception shutdownException)
+        {
+            // Console.WriteLine("Run called at {0}", DateTime.Now);
+            string msBuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+            var handshake = new EntryNodeHandshake(
+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableReuse, lowPriority: lowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess),
+                msBuildLocation);
+
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuildServer-" + handshake.ComputeHash());
+
+            string serverRunningMutexName = $@"Global\server-running-{pipeName}";
+            _serverBusyMutexName = $@"Global\server-busy-{pipeName}";
+
+            // TODO: shall we address possible race condition. It is harmless as it, with acceptable probability, just cause unnecessary process spawning
+            // and of two processes will become victim and fails, build will not be affected
+            using var serverRunningMutex = CommunicationsUtilities.OpenOrCreateMutex(serverRunningMutexName, out bool mutexCreatedNew);
+            if (!mutexCreatedNew)
+            {
+                shutdownException = new InvalidOperationException("MSBuild server is already running!");
+                return NodeEngineShutdownReason.Error;
+            }
+
+            _nodeEndpoint = new EntryNodeEndpointOutOfProc(pipeName, handshake);
+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
+            _nodeEndpoint.Listen(this);
+
+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+
+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
+            while (true)
+            {
+                int index = WaitHandle.WaitAny(waitHandles);
+                switch (index)
+                {
+                    case 0:
+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);
+                        return shutdownReason;
+
+                    case 1:
+
+                        while (_receivedPackets.TryDequeue(out INodePacket packet))
+                        {
+                            if (packet != null)
+                            {
+                                HandlePacket(packet);
+                            }
+                        }
+
+                        break;
+                }
+            }
+
+            // UNREACHABLE
+        }
+
+        #endregion
+
+        #region INodePacketFactory Members
+
+        /// <summary>
+        /// Registers a packet handler.
+        /// </summary>
+        /// <param name="packetType">The packet type for which the handler should be registered.</param>
+        /// <param name="factory">The factory used to create packets.</param>
+        /// <param name="handler">The handler for the packets.</param>
+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)
+        {
+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);
+        }
+
+        /// <summary>
+        /// Unregisters a packet handler.
+        /// </summary>
+        /// <param name="packetType">The type of packet for which the handler should be unregistered.</param>
+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)
+        {
+            _packetFactory.UnregisterPacketHandler(packetType);
+        }
+
+        /// <summary>
+        /// Deserializes and routes a packer to the appropriate handler.
+        /// </summary>
+        /// <param name="nodeId">The node from which the packet was received.</param>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        {
+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+        }
+
+        /// <summary>
+        /// Routes a packet to the appropriate handler.
+        /// </summary>
+        /// <param name="nodeId">The node id from which the packet was received.</param>
+        /// <param name="packet">The packet to route.</param>
+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)
+        {
+            _packetFactory.RoutePacket(nodeId, packet);
+        }
+
+        #endregion
+
+        #region INodePacketHandler Members
+
+        /// <summary>
+        /// Called when a packet has been received.
+        /// </summary>
+        /// <param name="node">The node from which the packet was received.</param>
+        /// <param name="packet">The packet.</param>
+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)
+        {
+            _receivedPackets.Enqueue(packet);
+            _packetReceivedEvent.Set();
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Perform necessary actions to shut down the node.
+        /// </summary>
+        // TODO: it is too complicated, for simple role of entry node it needs to be simplified
+        private NodeEngineShutdownReason HandleShutdown(out Exception exception)
+        {
+            CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}.", _shutdownReason, _shutdownException);
+
+            exception = _shutdownException;
+
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;
+            }
+
+            _nodeEndpoint.Disconnect();
+
+            CommunicationsUtilities.Trace("Shut down complete.");
+
+            return _shutdownReason;
+        }
+
+        /// <summary>
+        /// Event handler for the node endpoint's LinkStatusChanged event.
+        /// </summary>
+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)
+        {
+            switch (status)
+            {
+                case LinkStatus.ConnectionFailed:
+                case LinkStatus.Failed:
+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;
+                    _shutdownEvent.Set();
+                    break;
+
+                case LinkStatus.Inactive:
+                    break;
+
+                case LinkStatus.Active:
+                    break;
+
+                default:
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Callback for logging packets to be sent.
+        /// </summary>
+        private void SendPacket(INodePacket packet)
+        {
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                _nodeEndpoint.SendData(packet);
+            }
+        }
+
+        /// <summary>
+        /// Dispatches the packet to the correct handler.
+        /// </summary>
+        private void HandlePacket(INodePacket packet)
+        {
+            switch (packet.Type)
+            {
+                case NodePacketType.EntryNodeCommand:
+                    HandleEntryNodeCommand(packet as EntryNodeCommand);
+                    break;
+                case NodePacketType.NodeBuildComplete:
+                    HandleNodeBuildComplete(packet as NodeBuildComplete);
+                    break;
+            }
+        }
+
+        private void HandleEntryNodeCommand(EntryNodeCommand command)
+        {
+            using var serverBusyMutex = CommunicationsUtilities.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);
+            if (!holdsMutex)
+            {
+                // Client must have send request message to server even though serer is busy.
+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.
+                _shutdownException = new InvalidOperationException("Client requested build while server is busy processing previous client build request.");
+                _shutdownReason = NodeEngineShutdownReason.Error;
+                _shutdownEvent.Set();
+            }
+
+            // set build process context
+            Directory.SetCurrentDirectory(command.StartupDirectory);
+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);
+            Thread.CurrentThread.CurrentCulture = command.Culture;
+            Thread.CurrentThread.CurrentUICulture = command.UICulture;
+
+            // configure console output redirection
+            var oldOut = Console.Out;
+            var oldErr = Console.Error;
+
+            using var outWriter = new RedirectConsoleWriter((text, foreground, background) =>
+            {
+                SendPacket(new EntryNodeConsoleWrite(text, foreground, background, 1));
+            });
+            using var errWriter = new RedirectConsoleWriter((text, foreground, background) =>
+            {
+                SendPacket(new EntryNodeConsoleWrite(text, foreground, background, 2));
+            });
+
+            Console.SetOut(outWriter);
+            Console.SetError(errWriter);
+
+            var (exitCode, exitType) = _buildFunction(command.CommandLine);
+
+            Console.SetOut(oldOut);
+            Console.SetError(oldErr);
+            outWriter.Dispose();
+            errWriter.Dispose();
+
+            // On Windows, a process holds a handle to the current directory,
+            // so reset it away from a user-requested folder that may get deleted.
+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
+
+            var response = new EntryNodeResponse(exitCode, exitType);
+            SendPacket(response);
+
+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;
+            _shutdownEvent.Set();
+        }
+
+        // TODO: unit tests
+        internal class RedirectConsoleWriter : StringWriter
+        {
+            private readonly string _newLineString;
+
+            private readonly Action<string, ConsoleColor, ConsoleColor> _writeCallback;
+            private ConsoleColor _lastBackgroundColor;
+            private ConsoleColor _lastForegroundColor;
+
+            public RedirectConsoleWriter(Action<string, ConsoleColor, ConsoleColor> writeCallback)
+            {
+                _newLineString = new String(CoreNewLine);
+                _writeCallback = writeCallback;
+
+                _lastBackgroundColor = Console.BackgroundColor;
+                _lastForegroundColor = Console.ForegroundColor;
+            }
+
+            private void FlushIfColorChanged()
+            {
+                if (Console.ForegroundColor != _lastForegroundColor || Console.BackgroundColor != _lastBackgroundColor)
+                {
+                    Flush();
+                }
+            }
+
+            private void MaybeFlushCaptured(bool force)
+            {
+                if (force || GetStringBuilder().Length > 200)
+                {
+                    Flush();
+                }
+            }
+
+            protected override void Dispose(bool disposing)
+            {
+                if (disposing)
+                {
+                    Flush();
+                }
+
+                base.Dispose(disposing);
+            }
+
+            public override void Flush()
+            {
+                var sb = GetStringBuilder();
+                var captured = sb.ToString();
+                sb.Clear();
+                _writeCallback(captured, _lastForegroundColor, _lastBackgroundColor);
+
+                _lastForegroundColor = Console.ForegroundColor;
+                _lastBackgroundColor = Console.BackgroundColor;
+
+                base.Flush();
+            }
+
+            public override void Write(char value)
+            {
+                FlushIfColorChanged();
+                base.Write(value);
+                MaybeFlushCaptured(false);
+            }
+
+            public override void Write(char[] buffer, int index, int count)
+            {
+                FlushIfColorChanged();
+                base.Write(buffer, index, count);
+                MaybeFlushCaptured(buffer.SequenceEqual(CoreNewLine));
+            }
+
+            public override void Write(string value)
+            {
+                FlushIfColorChanged();
+                base.Write(value);
+                MaybeFlushCaptured(value.Contains(_newLineString));
+            }
+        }
+
+        /// <summary>
+        /// Handles the NodeBuildComplete packet.
+        /// </summary>
+        private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
+        {
+            _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
+            _shutdownEvent.Set();
+        }
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 8b51e260d1f..7cf15a749af 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -157,8 +157,12 @@
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
+    <Compile Include="BackEnd\Components\Communications\EntryNodeEndpointOutOfProc.cs" />
+    <Compile Include="BackEnd\Components\Communications\EntryNodeHandshake.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="BackEnd\Node\EntryNodeCommand.cs" />
+    <Compile Include="BackEnd\Node\OutOfProcEntryNode.cs" />
     <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ExternalProjectsProvider.cs" />
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index a03db6f636f..c8eed0ea89b 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -27,7 +27,7 @@ internal NodeEndpointOutOfProcTaskHost(string pipeName)
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected override Handshake GetHandshake()
+        protected override IHandshake GetHandshake()
         {
             return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: true));
         }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 09a0f38eaf3..945ba1015e0 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2679,6 +2679,46 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
                         OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                         shutdownReason = node.Run(out nodeException);
                     }
+                    else if (nodeModeNumber == 8)
+                    {
+                        // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
+                        bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
+                        string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];
+                        bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals("true");
+
+                        // Since build function has to reuse code from *this* class and OutOfProcEntryNode is in different assembly
+                        // we have to pass down xmake build invocation to avoid circular dependency
+                        Func<string, (int exitCode, string exitType)> buildFunction = (commandLine) =>
+                        {
+                            int exitCode;
+                            ExitType exitType;
+
+                            if (!s_initialized)
+                            {
+                                exitType = ExitType.InitializationError;
+                            }
+                            else
+                            {
+                                exitType = Execute(
+#if FEATURE_GET_COMMANDLINE
+                                    commandLine
+#else
+                                    QuotingUtilities.SplitUnquoted(commandLine).ToArray()
+#endif
+                                );
+                                exitCode = exitType == ExitType.Success ? 0 : 1;
+                            }
+                            exitCode = exitType == ExitType.Success ? 0 : 1;
+
+                            return (exitCode, exitType.ToString());
+                        };
+
+                        OutOfProcEntryNode node = new(buildFunction);
+
+                        shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);
+
+                        FileUtilities.ClearCacheDirectory();
+                    }
                     else
                     {
                         CommandLineSwitchException.Throw("InvalidNodeNumberValue", nodeModeNumber.ToString());
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index e5333429e68..ce62614ab00 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -59,7 +59,24 @@ internal enum HandshakeOptions
         Administrator = 32
     }
 
-    internal readonly struct Handshake
+    internal interface IHandshake
+    {
+        int[] RetrieveHandshakeComponents();
+
+        /// <summary>
+        /// Get string key representing all handshake values. It does not need to be human readable.
+        /// </summary>
+        string GetKey();
+
+        /// <summary>
+        /// Some handshakes uses very 1st byte to encode version of handshake in it,
+        /// so if it does not match it can reject it early based on very first byte.
+        /// Null means that no such encoding is used
+        /// </summary>
+        byte? ExpectedVersionInFirstByte { get; }
+    }
+
+    internal readonly struct Handshake : IHandshake
     {
         readonly int options;
         readonly int salt;
@@ -87,13 +104,7 @@ internal Handshake(HandshakeOptions nodeType)
             sessionId = Process.GetCurrentProcess().SessionId;
         }
 
-        // This is used as a key, so it does not need to be human readable.
-        public override string ToString()
-        {
-            return String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
-        }
-
-        internal int[] RetrieveHandshakeComponents()
+        public int[] RetrieveHandshakeComponents()
         {
             return new int[]
             {
@@ -106,6 +117,10 @@ internal int[] RetrieveHandshakeComponents()
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
             };
         }
+
+        public string GetKey() => $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}".ToString(CultureInfo.InvariantCulture);
+
+        public byte? ExpectedVersionInFirstByte => CommunicationsUtilities.handshakeVersion;
     }
 
     /// <summary>
@@ -630,5 +645,85 @@ internal static int AvoidEndOfHandshakeSignal(int x)
         {
             return x == EndOfHandshakeSignal ? ~x : x;
         }
+
+        internal static IServerMutex OpenOrCreateMutex(string name, out bool createdNew)
+        {
+            // TODO: verify it is not needed anymore
+            //if (PlatformInformation.IsRunningOnMono)
+            //{
+            //    return new ServerFileMutexPair(name, initiallyOwned: true, out createdNew);
+            //}
+            //else
+
+            return new ServerNamedMutex(name, out createdNew);
+        }
+
+        internal interface IServerMutex : IDisposable
+        {
+            bool TryLock(int timeoutMs);
+            bool IsDisposed { get; }
+        }
+
+        internal sealed class ServerNamedMutex : IServerMutex
+        {
+            public readonly Mutex ServerMutex;
+
+            public bool IsDisposed { get; private set; }
+            public bool IsLocked { get; private set; }
+
+            public ServerNamedMutex(string mutexName, out bool createdNew)
+            {
+                ServerMutex = new Mutex(
+                    initiallyOwned: true,
+                    name: mutexName,
+                    createdNew: out createdNew
+                );
+                if (createdNew)
+                    IsLocked = true;
+            }
+
+            public static bool WasOpen(string mutexName)
+            {
+                try
+                {
+                    // we can't use TryOpenExisting as it is not supported in net3.5
+                    using var m = Mutex.OpenExisting(mutexName);
+                    return true;
+                }
+                catch
+                {
+                    // In the case an exception occurred trying to open the Mutex then 
+                    // the assumption is that it's not open.
+                    return false;
+                }
+            }
+
+            public bool TryLock(int timeoutMs)
+            {
+                if (IsDisposed)
+                    throw new ObjectDisposedException("Mutex");
+                if (IsLocked)
+                    throw new InvalidOperationException("Lock already held");
+                return IsLocked = ServerMutex.WaitOne(timeoutMs);
+            }
+
+            public void Dispose()
+            {
+                if (IsDisposed)
+                    return;
+                IsDisposed = true;
+
+                try
+                {
+                    if (IsLocked)
+                        ServerMutex.ReleaseMutex();
+                }
+                finally
+                {
+                    (ServerMutex as IDisposable).Dispose();
+                    IsLocked = false;
+                }
+            }
+        }
     }
 }
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 501402c8756..94ab499412b 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -187,6 +187,24 @@ internal enum NodePacketType : byte
         /// Message sent back to a node informing it about the resource that were granted by the scheduler.
         /// </summary>
         ResourceResponse,
+
+        /// <summary>
+        /// Command in form of MSBuild command line for entry node - MSBuild Server.
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        EntryNodeCommand = 0xF0,
+
+        /// <summary>
+        /// Response from Entry node command
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        EntryNodeResponse = 0xF1,
+
+        /// <summary>
+        /// Info about server console activity. 
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        EntryNodeConsole = 0xF2,
     }
     #endregion
 
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index c58bc449a1c..707042f5b0d 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -251,7 +251,7 @@ internal void InternalConstruct(string pipeName)
         /// <summary>
         /// Returns the host handshake for this node endpoint
         /// </summary>
-        protected abstract Handshake GetHandshake();
+        protected abstract IHandshake GetHandshake();
 
         /// <summary>
         /// Updates the current link status if it has changed and notifies any registered delegates.
@@ -379,13 +379,13 @@ private void PacketPumpProc()
                     // The handshake protocol is a series of int exchanges.  The host sends us a each component, and we
                     // verify it. Afterwards, the host sends an "End of Handshake" signal, to which we respond in kind.
                     // Once the handshake is complete, both sides can be assured the other is ready to accept data.
-                    Handshake handshake = GetHandshake();
+                    IHandshake handshake = GetHandshake();
                     try
                     {
                         int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
                         for (int i = 0; i < handshakeComponents.Length; i++)
                         {
-                            int handshakePart = _pipeServer.ReadIntForHandshake(i == 0 ? (byte?)CommunicationsUtilities.handshakeVersion : null /* this will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard */
+                            int handshakePart = _pipeServer.ReadIntForHandshake(i == 0 ? handshake.ExpectedVersionInFirstByte : null /* this will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard */
 #if NETCOREAPP2_1 || MONO
                             , ClientConnectTimeout /* wait a long time for the handshake from this side */
 #endif
