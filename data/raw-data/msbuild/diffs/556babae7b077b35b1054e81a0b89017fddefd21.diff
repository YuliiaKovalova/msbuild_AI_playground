diff --git a/src/Build.UnitTests/BufferedBinaryReader_Tests.cs b/src/Build.UnitTests/BufferedBinaryReader_Tests.cs
new file mode 100644
index 00000000000..9f9a9c7e136
--- /dev/null
+++ b/src/Build.UnitTests/BufferedBinaryReader_Tests.cs
@@ -0,0 +1,321 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Logging;
+using Microsoft.Build.Shared;
+using Xunit;
+
+namespace Microsoft.Build.Engine.UnitTests
+{
+    public class BufferedBinaryReader_Tests
+    {
+        /// <summary>
+        /// Test ReadString
+        /// </summary>
+        [Fact]
+        public void Test_ReadString()
+        {
+            var testString = new string[] { "foobar", "catbar", "dogbar" };
+            using var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            foreach (string test in testString)
+            {
+                writer.Write(test);
+            }
+
+            stream.Position = 0;
+
+            using var reader = new BufferedBinaryReader(stream);
+            foreach (string test in testString)
+            {
+                string result = reader.ReadString();
+                Assert.Equal(test, result);
+            }
+        }
+
+        /// <summary>
+        /// Test ReadString support strings that are larger than the internal buffer.
+        /// </summary>
+        [Fact]
+        public void Test_ReadString_LongString()
+        {
+            var testString = new string[]
+            {
+                "FoobarCatbarDogbarDiveBarSandBar",
+                "FoobarCatbarDogbarDiveBarSandBar2",
+                "FoobarCatbarDogbarDiveBarSandBar3",
+            };
+
+            var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            foreach (string test in testString)
+            {
+                writer.Write(test);
+            }
+
+            stream.Position = 0;
+
+            using var reader = new BufferedBinaryReader(stream, bufferCapacity: 10);
+            foreach (string test in testString)
+            {
+                string result = reader.ReadString();
+                Assert.Equal(test, result);
+            }
+        }
+
+        /// <summary>
+        /// Test ReadInt64.
+        /// </summary>
+        [Fact]
+        public void Test_ReadInt64()
+        {
+            Int64 test = Int64.MaxValue;
+            var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            writer.Write(test);
+
+            stream.Position = 0;
+
+            using var reader = new BufferedBinaryReader(stream);
+            var result = reader.ReadInt64();
+
+            Assert.Equal(test, result);
+        }
+
+        /// <summary>
+        /// Test Read 7BitEncoded Integer.
+        /// </summary>
+        [Fact]
+        public void Test_Read7BitEncodedInt()
+        {
+            int test = 100;
+            using var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            writer.Write7BitEncodedInt(test);
+
+            stream.Position = 0;
+
+            using var reader = new BufferedBinaryReader(stream);
+            var result = reader.Read7BitEncodedInt();
+
+            Assert.Equal(test, result);
+        }
+
+        /// <summary>
+        /// Test Read7BitEncodedInt with varied length.
+        /// </summary>
+        [Fact]
+        public void Test_Read7BitEncodedInt_VariedLength()
+        {
+            int[] ints = new[] { 0, 1, 10, 254, 255, 256, 500, 1024, 1025, 100_000, 100_000_000, int.MaxValue };
+            using var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            foreach (int number in ints)
+            {
+                writer.Write7BitEncodedInt(number);
+            }
+
+            stream.Position = 0;
+
+            int result = 0;
+
+            using var reader = new BufferedBinaryReader(stream);
+            foreach (int number in ints)
+            {
+                result = reader.Read7BitEncodedInt();
+                Assert.Equal(number, result);
+            }
+        }
+
+        /// <summary>
+        /// Test Reading multiple 7BitEncoded Integer.
+        /// </summary>
+        [Fact]
+        public void Test_BulkRead7Bit()
+        {
+            int initialCount = BufferedBinaryReader.MaxBulkRead7BitLength;
+            int test = initialCount;
+            using var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            while (test > 0)
+            {
+                writer.Write7BitEncodedInt(test);
+                test--;
+            }
+
+            stream.Position = 0;
+            test = initialCount;
+
+            using var reader = new BufferedBinaryReader(stream);
+            int[] results = reader.BulkRead7BitEncodedInt(initialCount);
+
+            foreach (int result in results)
+            {
+                Assert.Equal(test, result);
+                test--;
+            }
+        }
+
+        /// <summary>
+        /// Test Reading multiple 7BitEncoded Integer.
+        /// </summary>
+        [Fact]
+        public void Test_Read7BitArray_Looped()
+        {
+            int initialCount = BufferedBinaryReader.MaxBulkRead7BitLength * 100;
+            int test = initialCount;
+            using var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            while (test > 0)
+            {
+                writer.Write7BitEncodedInt(test);
+                test--;
+            }
+
+            stream.Position = 0;
+            test = initialCount;
+
+            using var reader = new BufferedBinaryReader(stream);
+
+            do
+            {
+                int[] results = reader.BulkRead7BitEncodedInt(BufferedBinaryReader.MaxBulkRead7BitLength);
+
+                foreach (int result in results)
+                {
+                    Assert.Equal(test, result);
+                    test--;
+                }
+            } while (test > 0);
+        }
+
+        /// <summary>
+        /// Test ReadInt64 that are larger than the internal buffer.
+        /// </summary>
+        [Fact]
+        public void Test_FillBuffer_Int64()
+        {
+            Int64 initialCount = 200; // a large enough value to saturate a buffer
+            Int64 test = initialCount;
+            using var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            while (test > 0)
+            {
+                writer.Write(test);
+                test--;
+            }
+
+            stream.Position = 0;
+            test = initialCount;
+            Int64 result = 0;
+
+            using var reader = new BufferedBinaryReader(stream, bufferCapacity: 20);  // Reduced buffer size
+            while (test > 0)
+            {
+                result = reader.ReadInt64();
+                Assert.Equal(test, result);
+                test--;
+            }
+        }
+
+        /// <summary>
+        /// Test Read7BitEncodedInt that are larger than the internal buffer.
+        /// </summary>
+        [Fact]
+        public void Test_FillBuffer_Read7Bit()
+        {
+            int initialCount = 200; // a large enough value to saturate a buffer
+            int test = initialCount;
+            using var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            while (test > 0)
+            {
+                writer.Write7BitEncodedInt(test);
+                test--;
+            }
+
+            stream.Position = 0;
+            test = initialCount;
+            int result = 0;
+
+            using var reader = new BufferedBinaryReader(stream, bufferCapacity: 20);  // Reduced buffer size
+            while (test > 0)
+            {
+                result = reader.Read7BitEncodedInt();
+                Assert.Equal(test, result);
+                test--;
+            }
+        }
+
+        /// <summary>
+        /// Test ReadString support strings that are larger than the internal buffer.
+        /// </summary>
+        [Fact]
+        public void Test_FillBuffer_ReadString()
+        {
+            var testString = new string[] { "foobar", "catbar", "dogbar" };
+            using var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            foreach (string test in testString)
+            {
+                writer.Write(test);
+            }
+
+            stream.Position = 0;
+
+            using var reader = new BufferedBinaryReader(stream, bufferCapacity: 10);
+            foreach (string test in testString)
+            {
+                string result = reader.ReadString();
+                Assert.Equal(test, result);
+            }
+        }
+
+        /// <summary>
+        /// Test Slice function to correctly stream with correct position.
+        /// </summary>
+        [Fact]
+        public void Test_SliceBuffer()
+        {
+            var testString = new string[] { "foobar", "catbar", "dogbar" };
+            using var stream = new MemoryStream();
+
+            using var writer = new BinaryWriter(stream);
+            foreach (string test in testString)
+            {
+                writer.Write(test);
+            }
+
+            stream.Position = 0;
+
+            using var reader = new BufferedBinaryReader(stream, bufferCapacity: 10);
+            string firstResult = reader.ReadString();
+            Assert.Equal(testString[0], firstResult);
+
+            var sliceStream = reader.Slice(100);
+            using var binaryReader = new BinaryReader(sliceStream);
+
+            foreach (string test in testString.Skip(1))
+            {
+                string result = binaryReader.ReadString();
+                Assert.Equal(test, result);
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 912c37ee0ca..021da18e35f 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -25,7 +25,7 @@ internal static class TranslatorExtensions
         /// <summary>
         /// Translates a PropertyDictionary of ProjectPropertyInstances.
         /// </summary>
-        /// <param name="translator">The tranlator doing the translating</param>
+        /// <param name="translator">The translator doing the translating</param>
         /// <param name="value">The dictionary to translate.</param>
         public static void TranslateProjectPropertyInstanceDictionary(this ITranslator translator, ref PropertyDictionary<ProjectPropertyInstance> value)
         {
diff --git a/src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs b/src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs
new file mode 100644
index 00000000000..9ff46e0e5cb
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/BufferedBinaryReader.cs
@@ -0,0 +1,428 @@
+ï»¿using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Runtime.CompilerServices;
+using System.Text;
+using Microsoft.Build.Framework.Logging;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// Combines BufferedStream, BinaryReader, and TransparentReadStream into a single optimized class.
+    /// </summary>
+    /// <remarks>
+    /// This class combines BinaryReader and BufferedStream by pre-reading from the stream and inlining ReadBytes().
+    /// For example, BinaryReader.Read7BitEncodedInt() calls ReadByte() byte by byte with a high overhead
+    /// while this class will prefill 5 bytes for quick access.  Unused bytes will remain the buffer for next read operation.
+    /// This class assumes that it is the only reader of the stream and does not support concurrent reads from the stream.
+    /// Use the Slice() method to create a new stream.
+    /// </remarks>
+    internal class BufferedBinaryReader : IBinaryReader
+    {
+        private Stream baseStream;
+        private long baseStreamPosition = 0;  // virtual Position of the base stream.
+        private long maxAllowedPosition = long.MaxValue;
+        private int bufferCapacity;
+        private byte[] buffer;
+        private int bufferOffset = 0;
+        private int bufferLength = 0;
+        private Encoding encoding;
+
+        public BufferedBinaryReader(Stream stream, Encoding? encoding = null, int bufferCapacity = 32768)
+        {
+            if (!stream.CanRead)
+            {
+                throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_MustBeReadable"));
+            }
+
+            baseStream = stream;
+            this.bufferCapacity = bufferCapacity;  // Note: bufferSize must be large enough for an Read operation.
+            this.encoding = encoding ?? new UTF8Encoding();
+            buffer = new byte[this.bufferCapacity];
+        }
+
+        /// <summary>
+        /// Position of the base stream.
+        /// </summary>
+        public long Position => baseStreamPosition;
+
+        /// <summary>
+        /// Number of bytes allowed to read.  If set, then read functions will throw if exceeded by the amount.
+        /// </summary>
+        public int? BytesCountAllowedToRead
+        {
+            set
+            {
+                if (value.HasValue)
+                {
+                    if (value.Value < 0)
+                    {
+                        throw new Exception();
+                    }
+
+                    maxAllowedPosition = baseStreamPosition + value.Value;
+                }
+                else
+                {
+                    maxAllowedPosition = long.MaxValue;
+                }
+            }
+        }
+
+        /// <summary>
+        /// If <see cref="BytesCountAllowedToRead"/> is set, then this is the number of bytes remaining to read.  Otherwise, 0.
+        /// </summary>
+        public int BytesCountAllowedToReadRemaining => maxAllowedPosition == long.MaxValue ? 0 : (int)(maxAllowedPosition - baseStreamPosition);
+
+        /// <summary>
+        /// Reads a 32-bit signed integer.
+        /// </summary>
+        /// <returns>Return a integer.</returns>
+        public int ReadInt32()
+        {
+            FillBuffer(4);
+
+            var result = (int)(buffer[bufferOffset] | buffer[bufferOffset + 1] << 8 | buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);
+            bufferOffset += 4;
+            baseStreamPosition += 4;
+            return result;
+        }
+
+        // Reusable StringBuilder for ReadString().
+        private StringBuilder? cachedBuilder;
+
+        // Reusable char[] for ReadString().
+        private char[]? charBuffer;
+
+        /// <summary>
+        /// Reads a string with a prefixed of the length.
+        /// </summary>
+        /// <returns>A string.</returns>
+        public string ReadString()
+        {
+            int stringLength = Read7BitEncodedInt();
+            int stringOffsetPos = 0;
+            int readChunk = 0;
+
+            if (stringLength == 0)
+            {
+                return string.Empty;
+            }
+
+            if (stringLength < 0)
+            {
+                throw new Exception();
+            }
+
+            if (charBuffer == null)
+            {
+                charBuffer = new char[bufferCapacity + 1];
+            }
+
+            int charRead = 0;
+
+            if (bufferLength > 0)
+            {
+                // Read content in the buffer.
+                readChunk = stringLength < (bufferLength - bufferOffset) ? stringLength : bufferLength - bufferOffset;
+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);
+                bufferOffset += readChunk;
+                baseStreamPosition += readChunk;
+                if (stringLength == readChunk)
+                {
+                    // if the string is fits in the buffer, then cast to string without using string builder.
+                    return new string(charBuffer, 0, charRead);
+                }
+                else
+                {
+                    cachedBuilder ??= new StringBuilder();
+                    cachedBuilder.Append(charBuffer, 0, charRead);
+                }
+            }
+
+            cachedBuilder ??= new StringBuilder();
+            stringOffsetPos += readChunk;
+
+            do
+            {
+                // Read up to bufferCapacity;
+                readChunk = Math.Min(stringLength - stringOffsetPos, bufferCapacity);
+                FillBuffer(readChunk);
+                charRead = encoding.GetChars(buffer, bufferOffset, readChunk, charBuffer, 0);
+                bufferOffset += readChunk;
+                baseStreamPosition += readChunk;
+                cachedBuilder.Append(charBuffer, 0, charRead);
+                stringOffsetPos += readChunk;
+            } while (stringOffsetPos < stringLength);
+
+            string result = cachedBuilder.ToString();
+            cachedBuilder.Clear();
+            return result;
+        }
+
+        /// <summary>
+        /// Reads an 8-byte signed integer.
+        /// </summary>
+        /// <returns></returns>
+        public long ReadInt64()
+        {
+            FillBuffer(8);
+            uint lo = (uint)(buffer[bufferOffset + 0] | buffer[bufferOffset + 1] << 8 |
+                             buffer[bufferOffset + 2] << 16 | buffer[bufferOffset + 3] << 24);
+            uint hi = (uint)(buffer[bufferOffset + 4] | buffer[bufferOffset + 5] << 8 |
+                             buffer[bufferOffset + 6] << 16 | buffer[bufferOffset + 7] << 24);
+            var result = (long)((ulong)hi) << 32 | lo;
+            bufferOffset += 8;
+            baseStreamPosition += 8;
+            return result;
+        }
+
+        /// <summary>
+        /// Reads a Boolean value.
+        /// </summary>
+        /// <returns>true if the byte is nonzero; otherwise, false.</returns>
+        public bool ReadBoolean()
+        {
+            FillBuffer(1);
+            var result = (buffer[bufferOffset] != 0);
+            bufferOffset++;
+            baseStreamPosition++;
+            return result;
+        }
+
+        /// <summary>
+        /// Reads the specified number of bytes into a new byte array.
+        /// </summary>
+        /// <param name="count">The number of bytes to read.</param>
+        /// <returns>A byte array containing data read.</returns>
+        public byte[] ReadBytes(int count)
+        {
+            if (count == 0)
+            {
+                return Array.Empty<byte>();
+            }
+
+            FillBuffer(count);
+            if (bufferLength == 0)
+            {
+                return Array.Empty<byte>();
+            }
+
+            var result = new byte[count];
+            Array.Copy(buffer, bufferOffset, result, 0, count);
+            bufferOffset += count;
+            baseStreamPosition += count;
+            return result;
+        }
+
+        /// <summary>
+        /// Reads the next byte.
+        /// </summary>
+        /// <returns>A byte.</returns>
+        public byte ReadByte()
+        {
+            FillBuffer(1);
+            return InternalReadByte();
+        }
+
+        /// <summary>
+        /// Reads in a 32-bit integer in compressed format.
+        /// </summary>
+        /// <returns>A 32-bit integer.</returns>
+        public int Read7BitEncodedInt()
+        {
+            FillBuffer(5);
+            // Read out an Int32 7 bits at a time.  The high bit
+            // of the byte when on means to continue reading more bytes.
+            int count = 0;
+            int shift = 0;
+            byte b;
+            do
+            {
+                // Check for a corrupted stream.  Read a max of 5 bytes.
+                // In a future version, add a DataFormatException.
+                if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7
+                {
+                    throw new FormatException();
+                }
+
+                b = InternalReadByte();
+                count |= (b & 0x7F) << shift;
+                shift += 7;
+            } while ((b & 0x80) != 0);
+
+            return count;
+        }
+
+        public const int MaxBulkRead7BitLength = 10;
+        private int[] resultInt = new int[MaxBulkRead7BitLength];
+
+        /// <summary>
+        /// An optimized bulk read of many continuous 7BitEncodedInt.
+        /// </summary>
+        /// <param name="numIntegers">Number of 7BitEncodedInt to read up to <see cref="MaxBulkRead7BitLength"/>.</param>
+        /// <returns>An array of Integers with the results.</returns>
+        /// <remarks>This will reuse the same result buffer so further calls will clear the results.</remarks>
+        public int[] BulkRead7BitEncodedInt(int numIntegers)
+        {
+            FillBuffer(5 * numIntegers);
+            int count = 0;
+            int shift = 0;
+            byte b;
+
+            for (int i = 0; i < numIntegers; i++)
+            {
+                // Read out an Int32 7 bits at a time.  The high bit
+                // of the byte when on means to continue reading more bytes.
+                count = 0;
+                shift = 0;
+                b = 0;
+
+                do
+                {
+                    // Check for a corrupted stream.  Read a max of 5 bytes.
+                    // In a future version, add a DataFormatException.
+                    if (shift == 5 * 7)  // 5 bytes max per Int32, shift += 7
+                    {
+                        throw new FormatException();
+                    }
+
+                    b = InternalReadByte();
+                    count |= (b & 0x7F) << shift;
+                    shift += 7;
+                } while ((b & 0x80) != 0);
+
+                resultInt[i] = count;
+            }
+
+            return resultInt;
+        }
+
+        /// <summary>
+        /// See forward by a number of bytes.
+        /// </summary>
+        /// <param name="count">Number of bytes to advance forward.</param>
+        /// <param name="current">Must be <see cref="SeekOrigin.Current"/>.</param>
+        public void Seek(int count, SeekOrigin current)
+        {
+            if (current != SeekOrigin.Current || count < 0)
+            {
+                throw new NotSupportedException("Only seeking from SeekOrigin.Current and forward.");
+            }
+
+            if (count == 0)
+            {
+                return;
+            }
+
+            // TODO: optimized to avoid writing to the buffer.
+            FillBuffer(count);
+            bufferOffset += count;
+            baseStreamPosition += count;
+        }
+
+        /// <summary>
+        /// Slice a portion the stream into a new stream.
+        /// </summary>
+        /// <param name="numBytes">Number of bytes to consume.</param>
+        /// <returns>A new stream from the current position.</returns>
+        /// <remarks>Slice a portion of the current stream into a new stream.  This will advance <see cref="BufferedBinaryReader"/>.</remarks>
+        public Stream Slice(int numBytes)
+        {
+            // create a memory stream of this number of bytes.
+            if (numBytes == 0)
+            {
+                return Stream.Null;
+            }
+
+            if (numBytes < 0)
+            {
+                throw new ArgumentOutOfRangeException(nameof(numBytes));
+            }
+
+            Stream resultStream;
+            if (numBytes < bufferLength - bufferOffset)
+            {
+                MemoryStream memoryStream = new MemoryStream(numBytes);
+                memoryStream.Write(buffer, bufferOffset, numBytes);
+                memoryStream.Position = 0;
+                resultStream = memoryStream;
+            }
+            else
+            {
+                MemoryStream memoryStream = new MemoryStream(bufferLength - bufferOffset);
+                memoryStream.Write(buffer, bufferOffset, bufferLength - bufferOffset);
+                memoryStream.Position = 0;
+                resultStream = memoryStream.Concat(baseStream.Slice(numBytes - (bufferLength - bufferOffset)));
+            }
+
+            bufferOffset += numBytes;
+            baseStreamPosition += numBytes;
+
+            return resultStream;
+        }
+
+        public void Dispose()
+        {
+            ((IDisposable)baseStream).Dispose();
+        }
+
+        /// <summary>
+        /// Prefill the buffer.
+        /// </summary>
+        /// <param name="numBytes">Number of bytes to prefill.</param>
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        private void FillBuffer(int numBytes)
+        {
+            if (bufferLength - bufferOffset >= numBytes)
+            {
+                return;  // enough space in the current buffer;
+            }
+
+            LoadBuffer();
+        }
+
+        private void LoadBuffer()
+        {
+            int numBytes = bufferCapacity;  // fill as much of the buffer as possible.
+            int bytesRead = 0;
+            int offset = bufferLength - bufferOffset;
+
+            // Copy the remainder to the start.
+            if (offset > 0)
+            {
+                Array.Copy(buffer, bufferOffset, buffer, 0, offset);
+                bytesRead = offset;
+            }
+
+            do
+            {
+                offset = baseStream.Read(buffer, bytesRead, numBytes - bytesRead);
+                if (offset == 0)
+                {
+                    break;  // Reached the End Of Stream
+                }
+                bytesRead += offset;
+            } while (bytesRead < numBytes);
+
+            bufferLength = bytesRead;
+            bufferOffset = 0;
+        }
+
+        /// <summary>
+        /// Inlined ReadByte that assumes that there is enough space created by FillBuffer().
+        /// </summary>
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        private byte InternalReadByte()
+        {
+            if (maxAllowedPosition < baseStreamPosition + 1)
+            {
+                throw new EndOfStreamException();
+            }
+
+            baseStreamPosition++;
+            return buffer[bufferOffset++];
+        }
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index dc7b097be1a..074844ffd7c 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
@@ -25,9 +26,10 @@ namespace Microsoft.Build.Logging
     /// </summary>
     public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposable
     {
-        private readonly BinaryReader _binaryReader;
+        private readonly IBinaryReader _binaryReader;
+        private readonly BinaryReader _basedBinaryReader;
         // This is used to verify that events deserialization is not overreading expected size.
-        private readonly TransparentReadStream _readStream;
+        // private readonly TransparentReadStream _readStream;
         private readonly int _fileFormatVersion;
         private long _recordNumber = 0;
         private bool _skipUnknownEvents;
@@ -68,12 +70,9 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa
         /// <param name="fileFormatVersion">The file format version of the log file being read.</param>
         public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)
         {
-            this._readStream = TransparentReadStream.EnsureTransparentReadStream(binaryReader.BaseStream);
-            // make sure the reader we're going to use wraps the transparent stream wrapper
-            this._binaryReader = binaryReader.BaseStream == _readStream
-                ? binaryReader
-                : new BinaryReader(_readStream);
+            this._binaryReader = new BufferedBinaryReader(binaryReader.BaseStream);
             this._fileFormatVersion = fileFormatVersion;
+            this._basedBinaryReader = binaryReader;
         }
 
         /// <summary>
@@ -137,6 +136,7 @@ public void Dispose()
             if (CloseInput)
             {
                 _binaryReader.Dispose();
+                _basedBinaryReader.Dispose();
             }
         }
 
@@ -184,7 +184,7 @@ internal RawRecord ReadRaw()
             }
 
             int serializedEventLength = ReadInt32();
-            Stream stream = _binaryReader.BaseStream.Slice(serializedEventLength);
+            Stream stream = _binaryReader.Slice(serializedEventLength);
 
             _lastSubStream = stream as SubStream;
             _recordNumber += 1;
@@ -226,7 +226,7 @@ private void CheckErrorsSubscribed()
                 if (_fileFormatVersion >= BinaryLogger.ForwardCompatibilityMinimalVersion)
                 {
                     serializedEventLength = ReadInt32(); // record length
-                    _readStream.BytesCountAllowedToRead = serializedEventLength;
+                    _binaryReader.BytesCountAllowedToRead = serializedEventLength;
                 }
 
                 bool hasError = false;
@@ -240,7 +240,7 @@ e is InvalidDataException ||
                     // Thrown when BinaryReader is unable to deserialize binary data into expected type.
                     e is FormatException ||
                     // Thrown when we attempt to read more bytes than what is in the next event chunk.
-                    (e is EndOfStreamException && _readStream.BytesCountAllowedToReadRemaining <= 0))
+                    (e is EndOfStreamException && _binaryReader.BytesCountAllowedToReadRemaining <= 0))
                 {
                     hasError = true;
 
@@ -264,11 +264,11 @@ string ErrorFactory() =>
                     HandleError(ErrorFactory, _skipUnknownEvents, ReaderErrorType.UnknownEventType, recordKind);
                 }
 
-                if (_readStream.BytesCountAllowedToReadRemaining > 0)
+                if (_binaryReader.BytesCountAllowedToReadRemaining > 0)
                 {
                     string ErrorFactory() => ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
                         "Binlog_ReaderUnderRead", _recordNumber, serializedEventLength,
-                        serializedEventLength - _readStream.BytesCountAllowedToReadRemaining);
+                        serializedEventLength - _binaryReader.BytesCountAllowedToReadRemaining);
 
                     HandleError(ErrorFactory, _skipUnknownEventParts, ReaderErrorType.UnknownEventData, recordKind);
                 }
@@ -283,7 +283,7 @@ void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType re
                 if (noThrow)
                 {
                     RecoverableReadError?.Invoke(new BinaryLogReaderErrorEventArgs(readerErrorType, recordKind, msgFactory));
-                    SkipBytes(_readStream.BytesCountAllowedToReadRemaining);
+                    SkipBytes(_binaryReader.BytesCountAllowedToReadRemaining);
                 }
                 else
                 {
@@ -330,12 +330,12 @@ void HandleError(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType re
 
         private void SkipBytes(int count)
         {
-            _binaryReader.BaseStream.Seek(count, SeekOrigin.Current);
+            _binaryReader.Seek(count, SeekOrigin.Current);
         }
 
         private BinaryLogRecordKind PreprocessRecordsTillNextEvent(Func<BinaryLogRecordKind, bool> isPreprocessRecord)
         {
-            _readStream.BytesCountAllowedToRead = null;
+            _binaryReader.BytesCountAllowedToRead = null;
 
             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();
 
@@ -351,7 +351,7 @@ private BinaryLogRecordKind PreprocessRecordsTillNextEvent(Func<BinaryLogRecordK
                 else if (recordKind == BinaryLogRecordKind.NameValueList)
                 {
                     ReadNameValueList();
-                    _readStream.BytesCountAllowedToRead = null;
+                    _binaryReader.BytesCountAllowedToRead = null;
                 }
                 else if (recordKind == BinaryLogRecordKind.ProjectImportArchive)
                 {
@@ -396,7 +396,7 @@ private void ReadEmbeddedContent(BinaryLogRecordKind recordKind)
                         new ProjectImportsCollector(Path.GetRandomFileName(), false, runOnBackground: false);
                 }
 
-                Stream embeddedStream = _binaryReader.BaseStream.Slice(length);
+                Stream embeddedStream = _binaryReader.Slice(length);
 
                 // We are intentionally not grace handling corrupt embedded stream
 
@@ -446,7 +446,7 @@ private void ReadEmbeddedContent(BinaryLogRecordKind recordKind)
             {
                 EmbeddedContentRead(new EmbeddedContentEventArgs(
                     recordKind,
-                    _binaryReader.BaseStream.Slice(length)));
+                    _binaryReader.Slice(length)));
             }
             else
             {
@@ -458,7 +458,7 @@ private void ReadNameValueList()
         {
             if (_fileFormatVersion >= BinaryLogger.ForwardCompatibilityMinimalVersion)
             {
-                _readStream.BytesCountAllowedToRead = ReadInt32();
+                _binaryReader.BytesCountAllowedToRead = ReadInt32();
             }
 
             int count = ReadInt32();
@@ -1714,7 +1714,7 @@ private int ReadInt32()
             // on some platforms (net5) this method was added to BinaryReader
             // but it's not available on others. Call our own extension method
             // explicitly to avoid ambiguity.
-            return BinaryReaderExtensions.Read7BitEncodedInt(_binaryReader);
+            return _binaryReader.Read7BitEncodedInt();
         }
 
         private long ReadInt64()
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/ConcatenatedReadStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/ConcatenatedReadStream.cs
new file mode 100644
index 00000000000..1680fe8d4d2
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/ConcatenatedReadStream.cs
@@ -0,0 +1,102 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+
+namespace Microsoft.Build.Logging
+{
+    internal class ConcatenatedReadStream : Stream
+    {
+        private readonly Queue<Stream> _streams;
+        private long _position;
+
+        public ConcatenatedReadStream(IEnumerable<Stream> streams)
+            => _streams = EnsureStreamsAreReadable(streams);
+
+        public ConcatenatedReadStream(params Stream[] streams)
+            => _streams = EnsureStreamsAreReadable(streams);
+
+        private static Queue<Stream> EnsureStreamsAreReadable(IEnumerable<Stream> streams)
+        {
+            var result = (streams is ICollection<Stream> collection) ? new Queue<Stream>(collection.Count) : new Queue<Stream>();
+
+            foreach (Stream stream in streams)
+            {
+                if (!stream.CanRead)
+                {
+                    throw new ArgumentException("All streams must be readable", nameof(streams));
+                }
+
+                if (stream is ConcatenatedReadStream concatenatedStream)
+                {
+                    foreach (Stream subStream in concatenatedStream._streams)
+                    {
+                        result.Enqueue(subStream);
+                    }
+                }
+                else
+                {
+                    result.Enqueue(stream);
+                }
+            }
+
+            return result;
+        }
+
+        public override void Flush()
+        {
+            throw new NotSupportedException("ConcatenatedReadStream is forward-only read-only");
+        }
+
+        public override int Read(byte[] buffer, int offset, int count)
+        {
+            int totalBytesRead = 0;
+
+            while (count > 0 && _streams.Count > 0)
+            {
+                int bytesRead = _streams.Peek().Read(buffer, offset, count);
+                if (bytesRead == 0)
+                {
+                    _streams.Dequeue().Dispose();
+                    continue;
+                }
+
+                totalBytesRead += bytesRead;
+                offset += bytesRead;
+                count -= bytesRead;
+            }
+
+            _position += totalBytesRead;
+            return totalBytesRead;
+        }
+
+        public override long Seek(long offset, SeekOrigin origin)
+        {
+            throw new NotSupportedException("ConcatenatedReadStream is forward-only read-only");
+        }
+
+        public override void SetLength(long value)
+        {
+            throw new NotSupportedException("ConcatenatedReadStream is forward-only read-only");
+        }
+
+        public override void Write(byte[] buffer, int offset, int count)
+        {
+            throw new NotSupportedException("ConcatenatedReadStream is forward-only read-only");
+        }
+
+        public override bool CanRead => true;
+        public override bool CanSeek => false;
+        public override bool CanWrite => false;
+        public override long Length => _streams.Sum(s => s.Length);
+
+        public override long Position
+        {
+            get => _position;
+            set => throw new NotSupportedException("ConcatenatedReadStream is forward-only read-only");
+        }
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
index d8eca6c3848..492a503294b 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -85,11 +85,6 @@ public static bool TryGetLength(this Stream stream, out long length)
             }
         }
 
-        public static Stream ToReadableSeekableStream(this Stream stream)
-        {
-            return TransparentReadStream.EnsureSeekableStream(stream);
-        }
-
         /// <summary>
         /// Creates bounded read-only, forward-only view over an underlying stream.
         /// </summary>
@@ -100,5 +95,16 @@ public static Stream Slice(this Stream stream, long length)
         {
             return new SubStream(stream, length);
         }
+
+        /// <summary>
+        /// Creates a stream that concatenates the current stream with another stream.
+        /// </summary>
+        /// <param name="stream"></param>
+        /// <param name="other"></param>
+        /// <returns></returns>
+        public static Stream Concat(this Stream stream, Stream other)
+        {
+            return new ConcatenatedReadStream(stream, other);
+        }
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
deleted file mode 100644
index 4dd9afa0300..00000000000
--- a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
+++ /dev/null
@@ -1,114 +0,0 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.IO;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.Logging
-{
-    /// <summary>
-    /// A wrapper stream that allows position tracking and forward seeking.
-    /// </summary>
-    internal sealed class TransparentReadStream : Stream
-    {
-        private readonly Stream _stream;
-        private long _position;
-        private long _maxAllowedPosition = long.MaxValue;
-
-        public static Stream EnsureSeekableStream(Stream stream)
-        {
-            if (stream.CanSeek)
-            {
-                return stream;
-            }
-
-            if (!stream.CanRead)
-            {
-                throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_MustBeReadable"));
-            }
-
-            return new TransparentReadStream(stream);
-        }
-
-        public static TransparentReadStream EnsureTransparentReadStream(Stream stream)
-        {
-            if (stream is TransparentReadStream transparentReadStream)
-            {
-                return transparentReadStream;
-            }
-
-            if (!stream.CanRead)
-            {
-                throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_MustBeReadable"));
-            }
-
-            return new TransparentReadStream(stream);
-        }
-
-        private TransparentReadStream(Stream stream)
-        {
-            _stream = stream;
-        }
-
-        public int? BytesCountAllowedToRead
-        {
-            set { _maxAllowedPosition = value.HasValue ? _position + value.Value : long.MaxValue; }
-        }
-
-        // if we haven't constrained the allowed read size - do not report it being unfinished either.
-        public int BytesCountAllowedToReadRemaining =>
-            _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);
-
-        public override bool CanRead => _stream.CanRead;
-        public override bool CanSeek => true;
-        public override bool CanWrite => false;
-        public override long Length => _stream.Length;
-        public override long Position
-        {
-            get => _position;
-            set => this.SkipBytes(value - _position);
-        }
-
-        public override void Flush()
-        {
-            _stream.Flush();
-        }
-
-        public override int Read(byte[] buffer, int offset, int count)
-        {
-            if (_position + count > _maxAllowedPosition)
-            {
-                count = (int)(_maxAllowedPosition - _position);
-            }
-
-            int cnt = _stream.Read(buffer, offset, count);
-            _position += cnt;
-            return cnt;
-        }
-
-        public override long Seek(long offset, SeekOrigin origin)
-        {
-            if (origin != SeekOrigin.Current)
-            {
-                throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_SeekNonOrigin"));
-            }
-
-            this.SkipBytes(offset);
-
-            return _position;
-        }
-
-        public override void SetLength(long value)
-        {
-            throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_SetLengthUnsupported"));
-        }
-
-        public override void Write(byte[] buffer, int offset, int count)
-        {
-            throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_WriteUnsupported"));
-        }
-
-        public override void Close() => _stream.Close();
-    }
-}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index b06858fa47a..068000050b2 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -170,6 +170,7 @@
     <Compile Include="FileAccess\ReportedFileOperation.cs" />
     <Compile Include="FileAccess\RequestedAccess.cs" />
     <Compile Include="Instance\IPropertyElementWithLocation.cs" />
+    <Compile Include="Logging\BinaryLogger\BufferedBinaryReader.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
diff --git a/src/Framework/Logging/IBinaryReader.cs b/src/Framework/Logging/IBinaryReader.cs
new file mode 100644
index 00000000000..f3ce624f2f0
--- /dev/null
+++ b/src/Framework/Logging/IBinaryReader.cs
@@ -0,0 +1,41 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Framework.Logging
+{
+    public interface IBinaryReader : IDisposable
+    {
+        public int BytesCountAllowedToReadRemaining { get; }
+
+        public int? BytesCountAllowedToRead { set; }
+
+        public long Position { get; }
+
+        public byte ReadByte();
+
+        public byte[] ReadBytes(int count);
+
+        public bool ReadBoolean();
+
+        public long ReadInt64();
+
+        public string ReadString();
+
+        public int ReadInt32();
+
+        public void Seek(int count, SeekOrigin current);
+
+        public Stream Slice(int numBytes);
+
+        public int Read7BitEncodedInt();
+
+        public int[] BulkRead7BitEncodedInt(int numIntegers);
+    }
+}
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index 822af5c1a96..95481f28a76 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -6,6 +6,7 @@
 using System.IO;
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Logging;
 
 namespace Microsoft.Build.Shared
 {
@@ -91,6 +92,32 @@ public static BuildEventContext ReadBuildEventContext(this BinaryReader reader)
             var buildEventContext = new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, targetId, taskId);
             return buildEventContext;
         }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static BuildEventContext? ReadOptionalBuildEventContext(this IBinaryReader reader)
+        {
+            if (reader.ReadByte() == 0)
+            {
+                return null;
+            }
+
+            return reader.ReadBuildEventContext();
+        }
+
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static BuildEventContext ReadBuildEventContext(this IBinaryReader reader)
+        {
+            int nodeId = reader.ReadInt32();
+            int projectContextId = reader.ReadInt32();
+            int targetId = reader.ReadInt32();
+            int taskId = reader.ReadInt32();
+            int submissionId = reader.ReadInt32();
+            int projectInstanceId = reader.ReadInt32();
+            int evaluationId = reader.ReadInt32();
+
+            var buildEventContext = new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, targetId, taskId);
+            return buildEventContext;
+        }
 #endif
 
 #if !TASKHOST
