diff --git a/eng/Packages.props b/eng/Packages.props
index 7334fbeb8d7..b6e51805983 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -10,7 +10,7 @@
   <ItemGroup>
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="4.2.0-1.22102.8" />
+    <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="4.0.0-4.21379.20" />
     <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
     <PackageReference Update="Microsoft.IO.Redist" Version="6.0.0" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 8ddca6108ac..95001217b5d 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -36,9 +36,9 @@
     <ProjectReference Include="..\Samples\TaskWithDependency\TaskWithDependency.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="TaskWithDependencyResolvedProjectReferencePath">
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' == 'true'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
-      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=net6.0</SetTargetFramework>
+      <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=netstandard2.0</SetTargetFramework>
     </ProjectReference>
-    <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="PortableTaskResolvedProjectReferencePath" />
+    <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="PortableTaskResolvedProjectReferencePath" SetTargetFramework="TargetFramework=netstandard2.0" />
 
     <ProjectReference Include="..\Samples\ProjectCachePlugin\ProjectCachePlugin.csproj" Private="false" ReferenceOutputAssembly="false">
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index e238270ae6a..81b11a5b4ed 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -82,7 +82,7 @@
 
   <PropertyGroup Condition="'$(MonoBuild)' != 'true' and ($([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETCoreApp' or $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETStandard')">
     <NetCoreBuild>true</NetCoreBuild>
-    <DefineConstants>$(DefineConstants);RUNTIME_TYPE_NETCORE;FEATURE_FASTSPAN</DefineConstants>
+    <DefineConstants>$(DefineConstants);RUNTIME_TYPE_NETCORE</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(NetCoreBuild)'=='true'">
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index de2ef19eb31..dad17637aba 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -15,9 +15,6 @@
     <!-- Ensure that compiler errors emit full paths so that files
          can be correctly annotated in GitHub. -->
     <GenerateFullPaths>true</GenerateFullPaths>
-    
-    <!-- https://github.com/NuGet/Home/issues/8684 -->
-    <NoWarn>$(NoWarn);NU5131</NoWarn>
 
     <!-- Do not mangle paths for test assemblies, because Shoudly assertions want actual on-disk paths. -->
     <DeterministicSourcePaths Condition="'$(IsTestProject)' == 'true'">false</DeterministicSourcePaths>
@@ -30,9 +27,8 @@
     <Platforms>AnyCPU;x64</Platforms>
 
     <!-- Defaults for target frameworks and architecture -->
-    <LibraryTargetFrameworks>$(FullFrameworkTFM);net6.0;netstandard2.0</LibraryTargetFrameworks>
-    <LibraryTargetFrameworks Condition="'$(DotNetBuildFromSource)' == 'true'">net6.0;netstandard2.0</LibraryTargetFrameworks>
-    <LibraryTargetFrameworks Condition="'$(MonoBuild)'=='true'">$(FullFrameworkTFM);netstandard2.0</LibraryTargetFrameworks>
+    <LibraryTargetFrameworks>$(FullFrameworkTFM);netstandard2.0</LibraryTargetFrameworks>
+    <LibraryTargetFrameworks Condition="'$(MonoBuild)'=='true'">$(FullFrameworkTFM)</LibraryTargetFrameworks>
     <PlatformTarget>AnyCPU</PlatformTarget>
 
     <!-- Target frameworks for Exe and unit test projects (ie projects with runtime output) -->
@@ -75,34 +71,4 @@
     <!-- When targeting .NET Core, Exe and unit tests projects always use AnyCPU architecture -->
     <RuntimeOutputPlatformTarget>AnyCPU</RuntimeOutputPlatformTarget>
   </PropertyGroup>
-
-  <PropertyGroup>
-    <TargetsForTfmSpecificBuildOutput>$(TargetsForTfmSpecificContentInPackage);ShipRefAssembliesToNuGetPackage</TargetsForTfmSpecificBuildOutput>
-  </PropertyGroup>
-
-  <!-- Produce ONLY reference assemblies and SKIP roslyn analyzers for netstandard2.0 builds. -->
-  <PropertyGroup Condition="'$(TargetFramework)' == 'netstandard2.0' and '$(MSBuildProjectFile)' != 'PortableTask.csproj'">
-    <!-- ProduceOnlyReferenceAssembly and ProduceReferenceAssembly are mutually exclusive compiler flags. -->
-    <ProduceOnlyReferenceAssembly>true</ProduceOnlyReferenceAssembly>
-    <ProduceReferenceAssembly>false</ProduceReferenceAssembly>
-    <RunAnalyzers>false</RunAnalyzers>
-    <TargetsForTfmSpecificBuildOutput>$(TargetsForTfmSpecificContentInPackage);ShipRefAssembliesToNuGetPackage</TargetsForTfmSpecificBuildOutput>
-    <IncludeBuildOutput>false</IncludeBuildOutput>
-    <!-- pdb publishing fails builds for reference-only assemblies. -->
-    <!-- https://github.com/dotnet/msbuild/pull/6148. -->
-    <PublishWindowsPdb>false</PublishWindowsPdb>
-  </PropertyGroup>
-
-  <!-- Ensure ref assemblies are placed under `ref/$(TargetFramework)` in the NuGet package -->
-  <Target Name="ShipRefAssembliesToNuGetPackage" BeforeTargets="Pack" Condition="$(IsInnerBuild) == true">
-    <ItemGroup>
-      <TfmSpecificPackageFile Include="$(TargetRefPath);@(FinalDocFile)">
-          <PackagePath>ref\$(TargetFramework)</PackagePath>
-      </TfmSpecificPackageFile>
-      <!-- ns2.0 builds use `BuiltProjectOutputGroupOutput` for output ref assemblies -->
-      <TfmSpecificPackageFile Include="@(BuiltProjectOutputGroupOutput)" Condition="'$(TargetFramework)' == 'netstandard2.0'">
-          <PackagePath>ref\$(TargetFramework)</PackagePath>
-      </TfmSpecificPackageFile>
-    </ItemGroup>
-  </Target>
 </Project>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 44670733c34..37d12cf7268 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -9,7 +9,6 @@
 using System.IO;
 using System.Reflection;
 using System.Runtime.InteropServices;
-using System.Runtime.Versioning;
 using System.Text;
 using System.Threading;
 
@@ -22,10 +21,9 @@
 #nullable disable
 
 namespace Microsoft.Build.Framework;
-
 internal static class NativeMethods
 {
-#region Constants
+    #region Constants
 
     internal const uint ERROR_INSUFFICIENT_BUFFER = 0x8007007A;
     internal const uint STARTUP_LOADER_SAFEMODE = 0x10;
@@ -72,9 +70,9 @@ internal static class NativeMethods
     internal const uint WAIT_OBJECT_0 = 0x00000000;
     internal const uint WAIT_TIMEOUT = 0x00000102;
 
-#endregion
+    #endregion
 
-#region Enums
+    #region Enums
 
     private enum PROCESSINFOCLASS : int
     {
@@ -199,9 +197,9 @@ internal enum ProcessorArchitectures
         Unknown
     }
 
-#endregion
+    #endregion
 
-#region Structs
+    #region Structs
 
     /// <summary>
     /// Structure that contain information about the system on which we are running
@@ -569,9 +567,9 @@ private unsafe static int GetLogicalCoreCountOnWindows()
         return -1;
     }
 
-#endregion
+    #endregion
 
-#region Member data
+    #region Member data
 
     internal static bool HasMaxPath => MaxPath == MAX_PATH;
 
@@ -710,10 +708,10 @@ internal static bool IsMono
 #if !CLR2COMPATIBILITY
     private static bool? _isWindows;
 #endif
+
     /// <summary>
     /// Gets a flag indicating if we are running under some version of Windows
     /// </summary>
-    [SupportedOSPlatformGuard("windows")]
     internal static bool IsWindows
     {
 #if CLR2COMPATIBILITY
@@ -868,9 +866,9 @@ private static SystemInformationData SystemInformation
     /// </summary>
     internal static ProcessorArchitectures ProcessorArchitectureNative => SystemInformation.ProcessorArchitectureTypeNative;
 
-#endregion
+    #endregion
 
-#region Wrapper methods
+    #region Wrapper methods
 
     /// <summary>
     /// Really truly non pumping wait.
@@ -1452,9 +1450,9 @@ internal static void VerifyThrowWin32Result(int result)
         }
     }
 
-#endregion
+    #endregion
 
-#region PInvoke
+    #region PInvoke
 
     /// <summary>
     /// Gets the current OEM code page which is used by console apps
@@ -1587,9 +1585,9 @@ out FILETIME lpLastWriteTime
     [DllImport("kernel32.dll", SetLastError = true)]
     internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
 
-#endregion
+    #endregion
 
-#region Extensions
+    #region Extensions
 
     /// <summary>
     /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
@@ -1632,9 +1630,9 @@ internal static bool MsgWaitOne(this WaitHandle handle, int timeout)
         return returnValue == 0;
     }
 
-#endregion
+    #endregion
 
-#region helper methods
+    #region helper methods
 
     internal static bool DirectoryExists(string fullPath)
     {
@@ -1677,6 +1675,6 @@ internal static bool FileOrDirectoryExistsWindows(string path)
         return GetFileAttributesEx(path, 0, ref data);
     }
 
-#endregion
+    #endregion
 
 }
diff --git a/src/Framework/README.md b/src/Framework/README.md
index 1b72454f526..32c4e063b2b 100644
--- a/src/Framework/README.md
+++ b/src/Framework/README.md
@@ -4,8 +4,3 @@ This package contains `Microsoft.Build.Framework.dll`, which defines [fundamenta
 
 The items in this namespace are primarily base-level classes and interfaces shared across MSBuild's object model.  MSBuild task or extension developers can reference this package to implement interfaces such as
 [`ITask`](https://docs.microsoft.com/dotnet/api/microsoft.build.framework.itask), and [`ILogger`](https://docs.microsoft.com/dotnet/api/microsoft.build.framework.ilogger).
-
-### netstandard2.0 target
-The `netstandard2.0` target of this build is configured only to output reference assemblies; at runtime MSBuild will be `net6.0` or `net472`. Please use the `net6.0`-targeted assemblies for .NET Core 6+ scenarios.
-
-For context, see https://github.com/dotnet/msbuild/pull/6148
\ No newline at end of file
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
index febbbeffabc..cff07bb8bf7 100644
--- a/src/Framework/Sdk/SdkResultItem.cs
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -36,7 +36,7 @@ public SdkResultItem(string itemSpec, Dictionary<string, string>? metadata)
             Metadata = metadata;
         }
 
-        public override bool Equals(object? obj)
+        public override bool Equals(object obj)
         {
             if (obj is SdkResultItem item &&
                    ItemSpec == item.ItemSpec &&
diff --git a/src/Framework/SupportedOSPlatform.cs b/src/Framework/SupportedOSPlatform.cs
deleted file mode 100644
index 8a50d7c82f0..00000000000
--- a/src/Framework/SupportedOSPlatform.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-#if !NET6_0_OR_GREATER
-namespace System.Runtime.Versioning
-{
-    /// <summary>
-    /// SupportedOSPlatform is a net5.0+ Attribute.
-    /// Create the same type only in full-framework and netstandard2.0 builds
-    /// to prevent many #if RUNTIME_TYPE_NETCORE checks.
-    /// </summary>
-    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property)]
-    internal class SupportedOSPlatformGuard : Attribute
-    {
-        internal SupportedOSPlatformGuard(string platformName)
-        {
-        }
-    }
-    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Class)]
-    internal class SupportedOSPlatform : Attribute
-    {
-        internal SupportedOSPlatform(string platformName)
-        {
-        }
-    }
-}
-#endif
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 337e3260d18..803083dd1fc 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -211,13 +211,6 @@
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
-    <!-- Manually download this library for RoslynCodeTaskFactory.
-           See target AddRefAssemblies below. -->
-    <ItemGroup>
-      <PackageDownload Include="netstandard.library">
-        <Version>[2.0.3]</Version>
-      </PackageDownload>
-    </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- File for Assemblies we depend on -->
     <Reference Include="System" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index e7dba840e1a..f56435ec284 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -142,9 +142,6 @@
     <Compile Include="..\Framework\StringBuilderCache.cs">
       <Link>StringBuilderCache.cs</Link>
     </Compile>
-    <Compile Include="..\Framework\SupportedOSPlatform.cs">
-      <Link>SupportedOSPlatform.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
       <Link>TaskEngineAssemblyResolver.cs</Link>
     </Compile>
diff --git a/src/Samples/PortableTask/PortableTask.csproj b/src/Samples/PortableTask/PortableTask.csproj
index a497a305fb2..6a4541787a1 100644
--- a/src/Samples/PortableTask/PortableTask.csproj
+++ b/src/Samples/PortableTask/PortableTask.csproj
@@ -3,7 +3,7 @@
     <UseProductOutputPath>true</UseProductOutputPath>
     <CopyNuGetImplementations>false</CopyNuGetImplementations>
     <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
-    <TargetFramework>netstandard2.0</TargetFramework>
+    <TargetFrameworks>netstandard2.0</TargetFrameworks>
   </PropertyGroup>
   <ItemGroup>
     <Content Include="portableTaskTest.proj">
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
index f04d2a9e931..302d50bfd6c 100644
--- a/src/StringTools/InternableString.cs
+++ b/src/StringTools/InternableString.cs
@@ -96,7 +96,7 @@ public bool MoveNext()
         /// </summary>
         private readonly ReadOnlySpan<char> _inlineSpan;
 
-#if FEATURE_FASTSPAN
+#if NETSTANDARD
         /// <summary>
         /// .NET Core does not keep a reference to the containing object in <see cref="ReadOnlySpan{T}"/>. In particular,
         /// it cannot recover the string if the span represents one. We have to hold the reference separately to be able to
@@ -122,7 +122,7 @@ internal InternableString(ReadOnlySpan<char> span)
             _inlineSpan = span;
             _spans = null;
             Length = span.Length;
-#if FEATURE_FASTSPAN
+#if NETSTANDARD
             _inlineSpanString = null;
 #endif
         }
@@ -141,7 +141,7 @@ internal InternableString(string str)
             _inlineSpan = str.AsSpan();
             _spans = null;
             Length = str.Length;
-#if FEATURE_FASTSPAN
+#if NETSTANDARD
             _inlineSpanString = str;
 #endif
         }
@@ -154,7 +154,7 @@ internal InternableString(SpanBasedStringBuilder stringBuilder)
             _inlineSpan = default(ReadOnlySpan<char>);
             _spans = stringBuilder.Spans;
             Length = stringBuilder.Length;
-#if FEATURE_FASTSPAN
+#if NETSTANDARD
             _inlineSpanString = null;
 #endif
         }
@@ -220,7 +220,7 @@ public unsafe string ExpensiveConvertToString()
             // Special case: if we hold just one string, we can directly return it.
             if (_inlineSpan.Length == Length)
             {
-#if FEATURE_FASTSPAN
+#if NETSTANDARD
                 if (_inlineSpanString != null)
                 {
                     return _inlineSpanString;
diff --git a/src/StringTools/WeakStringCache.Concurrent.cs b/src/StringTools/WeakStringCache.Concurrent.cs
index 3261141fcbf..6110475e946 100644
--- a/src/StringTools/WeakStringCache.Concurrent.cs
+++ b/src/StringTools/WeakStringCache.Concurrent.cs
@@ -32,7 +32,7 @@ public string GetOrCreateEntry(ref InternableString internable, out bool cacheHi
         {
             int hashCode = internable.GetHashCode();
 
-            StringWeakHandle? handle;
+            StringWeakHandle handle;
             string? result;
 
             // Get the existing handle from the cache and lock it while we're dereferencing it to prevent a race with the Scavenge
@@ -98,7 +98,7 @@ public void Scavenge()
             foreach (KeyValuePair<int, StringWeakHandle> entry in _stringsByHashCode)
             {
                 // We can safely dereference entry.Value as the caller guarantees that Scavenge runs only on one thread.
-                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle? removedHandle))
+                if (!entry.Value.IsUsed && _stringsByHashCode.TryRemove(entry.Key, out StringWeakHandle removedHandle))
                 {
                     lock (removedHandle)
                     {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index beec4a1d226..9fe18eaef93 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -14,6 +14,7 @@
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 using Xunit.Abstractions;
 using Shouldly;
+using System.Text;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 4bf53a812a9..9d9813898bc 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -25,7 +25,7 @@
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
-    <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" ReferenceOutputAssembly="false" Private="false" />
+    <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" ReferenceOutputAssembly="false" Private="false" SetTargetFramework="TargetFramework=netstandard2.0" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index b8960252b8a..39469981e66 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -17,7 +17,6 @@
 using System.Xml.XPath;
 using System.Xml.Xsl;
 using Microsoft.Build.Shared.FileSystem;
-using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -29,7 +28,6 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     [ComVisible(true)]
     [Guid("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
     [ClassInterface(ClassInterfaceType.None)]
-    [SupportedOSPlatform("windows")]
     public class BootstrapperBuilder : IBootstrapperBuilder
     {
         private static readonly bool s_logging = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("VSPLOG"));
@@ -1645,7 +1643,7 @@ private static string GetFileHash(string filePath)
             // the .NET Framework we are targeting.  In ideal situations, bootstrapper files will be
             // pre-signed anwyay; this is a fallback in case we ever encounter a bootstrapper that is
             // not signed.  
-            System.Security.Cryptography.SHA256 sha = System.Security.Cryptography.SHA256.Create("System.Security.Cryptography.SHA256CryptoServiceProvider");
+            System.Security.Cryptography.SHA256CryptoServiceProvider sha = new System.Security.Cryptography.SHA256CryptoServiceProvider();
 
             using (Stream s = fi.OpenRead())
             {
@@ -1908,7 +1906,7 @@ private static XmlElement CreateApplicationElement(XmlElement configElement, Bui
                     XmlElement filesNode = applicationElement.OwnerDocument.CreateElement("Files");
                     XmlElement fileNode = filesNode.OwnerDocument.CreateElement("File");
                     AddAttribute(fileNode, "Name", settings.ApplicationFile);
-                    AddAttribute(fileNode, URLNAME_ATTRIBUTE, Uri.EscapeDataString(settings.ApplicationFile));
+                    AddAttribute(fileNode, URLNAME_ATTRIBUTE, Uri.EscapeUriString(settings.ApplicationFile));
                     filesNode.AppendChild(fileNode);
                     applicationElement.AppendChild(filesNode);
                 }
diff --git a/src/Tasks/BootstrapperUtil/Util.cs b/src/Tasks/BootstrapperUtil/Util.cs
index d62c8247070..0ed5be1dea0 100644
--- a/src/Tasks/BootstrapperUtil/Util.cs
+++ b/src/Tasks/BootstrapperUtil/Util.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
-using System.Runtime.Versioning;
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
 
@@ -76,7 +75,6 @@ public static CultureInfo GetCultureInfoFromString(string cultureName)
 
         public static CultureInfo DefaultCultureInfo => System.Threading.Thread.CurrentThread.CurrentUICulture;
 
-        [SupportedOSPlatform("windows")]
         // This is the 4.0 property and will always point to the Dev10 registry key so that we don't break backwards compatibility.
         // Applications relying on 4.5 will need to use the new method that is introduced in 4.5.
         public static string DefaultPath
@@ -104,7 +102,6 @@ public static string DefaultPath
             }
         }
 
-        [SupportedOSPlatform("windows")]
         // A new method in 4.5 to get the default path for bootstrapper packages.
         // This method is not going to cache the path as it could be different depending on the Visual Studio version.
         public static string GetDefaultPath(string visualStudioVersion)
@@ -156,7 +153,6 @@ public static string GetDefaultPath(string visualStudioVersion)
             return Directory.GetCurrentDirectory();
         }
 
-        [SupportedOSPlatform("windows")]
         // Gets the list of additional paths to inspect for packages as defined in the registry
         public static List<string> AdditionalPackagePaths
         {
@@ -206,7 +202,6 @@ public static List<string> AdditionalPackagePaths
             }
         }
 
-        [SupportedOSPlatform("windows")]
         private static string ReadRegistryString(RegistryKey key, string path, string registryValue)
         {
             RegistryKey subKey = key.OpenSubKey(path, false);
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 5192719aa13..c55eedb3974 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -146,17 +146,11 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                     {
                         response.EnsureSuccessStatusCode();
                     }
-#if NET6_0_OR_GREATER
-                    catch (HttpRequestException)
-                    {
-                        throw;
-#else
                     catch (HttpRequestException e)
                     {
-                        // MSBuild History: CustomHttpRequestException was created as a wrapper over HttpRequestException
-                        // so it could include the StatusCode. As of net5.0, the statuscode is now in HttpRequestException.
+                        // HttpRequestException does not have the status code so its wrapped and thrown here so that later on we can determine
+                        // if a retry is possible based on the status code
                         throw new CustomHttpRequestException(e.Message, e.InnerException, response.StatusCode);
-#endif
                     }
 
                     if (!TryGetFileName(response, out string filename))
@@ -187,11 +181,7 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                         {
                             Log.LogMessageFromResources(MessageImportance.High, "DownloadFile.Downloading", SourceUrl, destinationFile.FullName, response.Content.Headers.ContentLength);
 
-                            using (Stream responseStream = await response.Content.ReadAsStreamAsync(
-#if NET6_0_OR_GREATER
-                            cancellationToken
-#endif
-                            ).ConfigureAwait(false))
+                            using (Stream responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                             {
                                 await responseStream.CopyToAsync(target, 1024, cancellationToken).ConfigureAwait(false);
                             }
@@ -230,34 +220,20 @@ private static bool IsRetriable(Exception exception, out Exception actualExcepti
             }
 
             // Some HttpRequestException have an inner exception that has the real error
-            if (actualException is HttpRequestException httpRequestException)
+            if (actualException is HttpRequestException httpRequestException && httpRequestException.InnerException != null)
             {
-                if (httpRequestException.InnerException != null)
-                {
-                    actualException = httpRequestException.InnerException;
+                actualException = httpRequestException.InnerException;
 
-                    // An IOException inside of a HttpRequestException means that something went wrong while downloading
-                    if (actualException is IOException)
-                    {
-                        return true;
-                    }
-                }
-
-#if NET6_0_OR_GREATER
-                // net5.0 included StatusCode in the HttpRequestException.
-                switch (httpRequestException.StatusCode)
+                // An IOException inside of a HttpRequestException means that something went wrong while downloading
+                if (actualException is IOException)
                 {
-                    case HttpStatusCode.InternalServerError:
-                    case HttpStatusCode.RequestTimeout:
-                        return true;
+                    return true;
                 }
             }
-#else
-            }
 
-            // framework workaround for HttpRequestException not containing StatusCode
             if (actualException is CustomHttpRequestException customHttpRequestException)
             {
+                // A wrapped CustomHttpRequestException has the status code from the error
                 switch (customHttpRequestException.StatusCode)
                 {
                     case HttpStatusCode.InternalServerError:
@@ -265,7 +241,6 @@ private static bool IsRetriable(Exception exception, out Exception actualExcepti
                         return true;
                 }
             }
-#endif
 
             if (actualException is WebException webException)
             {
@@ -312,10 +287,8 @@ private bool TryGetFileName(HttpResponseMessage response, out string filename)
             return !String.IsNullOrWhiteSpace(filename);
         }
 
-#if !NET6_0_OR_GREATER
         /// <summary>
         /// Represents a wrapper around the <see cref="HttpRequestException"/> that also contains the <see cref="HttpStatusCode"/>.
-        /// DEPRECATED as of net5.0, which included the StatusCode in the HttpRequestException class.
         /// </summary>
         private sealed class CustomHttpRequestException : HttpRequestException
         {
@@ -327,7 +300,6 @@ public CustomHttpRequestException(string message, Exception inner, HttpStatusCod
 
             public HttpStatusCode StatusCode { get; }
         }
-#endif
 
         private bool ShouldSkip(HttpResponseMessage response, FileInfo destinationFile)
         {
diff --git a/src/Tasks/FormatUrl.cs b/src/Tasks/FormatUrl.cs
index 4b600c49ef9..f742f4d238b 100644
--- a/src/Tasks/FormatUrl.cs
+++ b/src/Tasks/FormatUrl.cs
@@ -1,11 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#if !RUNTIME_TYPE_NETCORE
 using System;
-using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-#endif
 using Microsoft.Build.Framework;
+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 
 #nullable disable
 
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index a6361b25472..bece4016d94 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -5,7 +5,6 @@
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.Runtime.Versioning;
 using System.Xml;
 
 using Microsoft.Build.Framework;
@@ -18,7 +17,6 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Generates an application manifest for ClickOnce projects.
     /// </summary>
-    [SupportedOSPlatform("windows")]
     public sealed class GenerateApplicationManifest : GenerateManifestBase
     {
         private enum _ManifestType
@@ -110,16 +108,6 @@ public bool UseApplicationTrust
             set => _useApplicationTrust = value;
         }
 
-        public override bool Execute()
-        {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GenerateApplicationManifest));
-                return false;
-            }
-            return base.Execute();
-        }
-
         protected override Type GetObjectType()
         {
             return typeof(ApplicationManifest);
diff --git a/src/Tasks/GenerateDeploymentManifest.cs b/src/Tasks/GenerateDeploymentManifest.cs
index 6867f27717b..d4ff40421a4 100644
--- a/src/Tasks/GenerateDeploymentManifest.cs
+++ b/src/Tasks/GenerateDeploymentManifest.cs
@@ -5,7 +5,6 @@
 using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -14,7 +13,6 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Generates a deploy manifest for ClickOnce projects.
     /// </summary>
-    [SupportedOSPlatform("windows")]
     public sealed class GenerateDeploymentManifest : GenerateManifestBase
     {
         private bool? _createDesktopShortcut;
@@ -144,7 +142,6 @@ private bool BuildResolvedSettings(DeployManifest manifest)
             else if (String.IsNullOrEmpty(manifest.Publisher))
             {
                 string org = Util.GetRegisteredOrganization();
-
                 manifest.Publisher = !String.IsNullOrEmpty(org) ? org : manifest.Product;
             }
             Debug.Assert(!String.IsNullOrEmpty(manifest.Publisher));
@@ -152,16 +149,6 @@ private bool BuildResolvedSettings(DeployManifest manifest)
             return true;
         }
 
-        public override bool Execute()
-        {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GenerateDeploymentManifest));
-                return false;
-            }
-            return base.Execute();
-        }
-
         protected override Type GetObjectType()
         {
             return typeof(DeployManifest);
diff --git a/src/Tasks/GenerateLauncher.cs b/src/Tasks/GenerateLauncher.cs
index 683736168cc..6bedd918410 100644
--- a/src/Tasks/GenerateLauncher.cs
+++ b/src/Tasks/GenerateLauncher.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using System.Runtime.Versioning;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks.Deployment.Bootstrapper;
@@ -17,7 +16,6 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Generates a bootstrapper for ClickOnce deployment projects.
     /// </summary>
-    [SupportedOSPlatform("windows")]
     public sealed class GenerateLauncher : TaskExtension
     {
         private const string LAUNCHER_EXE = "Launcher.exe";
@@ -41,12 +39,6 @@ public sealed class GenerateLauncher : TaskExtension
 
         public override bool Execute()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GenerateLauncher));
-                return false;
-            }
-
             if (LauncherPath == null)
             {
                 // Launcher lives next to ClickOnce bootstrapper.
@@ -65,17 +57,17 @@ public override bool Execute()
 
             var launcherBuilder = new LauncherBuilder(LauncherPath);
             string entryPointFileName = Path.GetFileName(EntryPoint.ItemSpec);
-
+            //
             // If the EntryPoint specified is apphost.exe or singlefilehost.exe, we need to replace the EntryPoint
             // with the AssemblyName instead since apphost.exe/singlefilehost.exe is an intermediate file for
             // for final published {assemblyname}.exe.
+            //
             if ((entryPointFileName.Equals(Constants.AppHostExe, StringComparison.InvariantCultureIgnoreCase) || 
                 entryPointFileName.Equals(Constants.SingleFileHostExe, StringComparison.InvariantCultureIgnoreCase)) &&
-                !string.IsNullOrEmpty(AssemblyName))
+                !String.IsNullOrEmpty(AssemblyName))
             {
                 entryPointFileName = AssemblyName;
             }
-
             BuildResults results = launcherBuilder.Build(entryPointFileName, OutputPath);
 
             BuildMessage[] messages = results.Messages;
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index ef8aed08163..65ea58c62b0 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -272,12 +272,6 @@ private AssemblyIdentity CreateAssemblyIdentity(AssemblyIdentity baseIdentity, A
 
         public override bool Execute()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GenerateManifestBase));
-                return false;
-            }
-
             bool success = true;
 
             Type manifestType = GetObjectType();
diff --git a/src/Tasks/ManifestUtil/ComImporter.cs b/src/Tasks/ManifestUtil/ComImporter.cs
index 96a941a43e0..86e28d204d0 100644
--- a/src/Tasks/ManifestUtil/ComImporter.cs
+++ b/src/Tasks/ManifestUtil/ComImporter.cs
@@ -10,13 +10,11 @@
 #if RUNTIME_TYPE_NETCORE
 using System.Runtime.InteropServices.ComTypes;
 #endif
-using System.Runtime.Versioning;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
 {
-    [SupportedOSPlatform("windows")]
     internal class ComImporter
     {
         private readonly OutputMessageCollection _outputMessages;
diff --git a/src/Tasks/ManifestUtil/FileReference.cs b/src/Tasks/ManifestUtil/FileReference.cs
index e13dad0af4f..e2e0f6b75d8 100644
--- a/src/Tasks/ManifestUtil/FileReference.cs
+++ b/src/Tasks/ManifestUtil/FileReference.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.ComponentModel;
 using System.Runtime.InteropServices;
-using System.Runtime.Versioning;
 using System.Text;
 using System.Xml.Serialization;
 
@@ -45,7 +44,6 @@ public FileReference(string path) : base(path)
         [XmlIgnore]
         public ComClass[] ComClasses => _comClasses;
 
-        [SupportedOSPlatform("windows")]
         internal bool ImportComComponent(string path, OutputMessageCollection outputMessages, string outputDisplayName)
         {
             var importer = new ComImporter(path, outputMessages, outputDisplayName);
@@ -105,7 +103,7 @@ public bool IsDataFile
         [XmlIgnore]
         public TypeLib[] TypeLibs => _typeLibs;
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -143,7 +141,7 @@ public string XmlWriteableType
             set => _writeableType = value;
         }
 
-#endregion
+        #endregion
     }
 
     [ComVisible(false)]
@@ -183,7 +181,7 @@ internal ComClass(Guid tlbId, Guid clsId, string progId, string threadingModel,
         [XmlIgnore]
         public string TlbId => _tlbid;
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -230,7 +228,7 @@ public string XmlTlbId
             set => _tlbid = value;
         }
 
-#endregion
+        #endregion
     }
 
     [ComVisible(false)]
@@ -295,7 +293,7 @@ private static string FlagsFromInt(int flags)
         [XmlIgnore]
         public string Version => _version;
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -342,7 +340,7 @@ public string XmlVersion
             set => _version = value;
         }
 
-#endregion
+        #endregion
     }
 
     [ComVisible(false)]
@@ -382,7 +380,7 @@ public bool Versioned
             }
         }
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -402,7 +400,7 @@ public string XmlVersioned
             set => _versioned = value;
         }
 
-#endregion
+        #endregion
     }
 
     [ComVisible(false)]
@@ -429,7 +427,7 @@ public class ProxyStub
         [XmlIgnore]
         public string TlbId => _tlbid;
 
-#region " XmlSerializer "
+        #region " XmlSerializer "
 
         [Browsable(false)]
         [EditorBrowsable(EditorBrowsableState.Never)]
@@ -476,6 +474,6 @@ public string XmlTlbId
             set => _tlbid = value;
         }
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 986370caf84..54a9221d899 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -1,7 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if !RUNTIME_TYPE_NETCORE
 using Microsoft.Build.Framework;
+#endif
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using System;
@@ -20,7 +22,6 @@
 using System.Reflection;
 #endif
 using System.Runtime.InteropServices;
-using System.Runtime.Versioning;
 using System.Security;
 using System.Security.Cryptography;
 using System.Security.Cryptography.X509Certificates;
@@ -31,6 +32,9 @@
 using System.Text;
 using System.Xml;
 using Microsoft.Build.Shared.FileSystem;
+#if !RUNTIME_TYPE_NETCORE
+using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
+#endif
 
 #nullable disable
 
@@ -139,15 +143,15 @@ private static PermissionSet GetNamedPermissionSetFromZone(string targetZone, st
 
         private static PermissionSet GetNamedPermissionSet(string targetZone, string targetFrameworkMoniker)
         {
-            FrameworkName fn;
+            FrameworkNameVersioning fn;
 
             if (!string.IsNullOrEmpty(targetFrameworkMoniker))
             {
-                fn = new FrameworkName(targetFrameworkMoniker);
+                fn = new FrameworkNameVersioning(targetFrameworkMoniker);
             }
             else
             {
-                fn = new FrameworkName(".NETFramework", s_dotNet40Version);
+                fn = new FrameworkNameVersioning(".NETFramework", s_dotNet40Version);
             }
 
             int majorVersion = fn.Version.Major;
@@ -166,7 +170,7 @@ private static PermissionSet GetNamedPermissionSet(string targetZone, string tar
             }
         }
 
-        private static XmlElement GetXmlElement(string targetZone, FrameworkName fn)
+        private static XmlElement GetXmlElement(string targetZone, FrameworkNameVersioning fn)
         {
             IList<string> paths = ToolLocationHelper.GetPathToReferenceAssemblies(fn);
 
@@ -491,7 +495,6 @@ public static PermissionSet XmlToPermissionSet(XmlElement element)
         /// <param name="certThumbprint">Hexadecimal string that contains the SHA-1 hash of the certificate.</param>
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
-        [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint, Uri timestampUrl, string path)
         {
             SignFile(certThumbprint, timestampUrl, path, null, null);
@@ -504,7 +507,6 @@ public static void SignFile(string certThumbprint, Uri timestampUrl, string path
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
         /// <param name="targetFrameworkVersion">Version of the .NET Framework for the target.</param>
-        [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint,
                                     Uri timestampUrl,
                                     string path,
@@ -521,7 +523,6 @@ public static void SignFile(string certThumbprint,
         /// <param name="path">Path of the file to sign with the certificate.</param>
         /// <param name="targetFrameworkVersion">Version of the .NET Framework for the target.</param>
         /// <param name="targetFrameworkIdentifier">.NET Framework identifier for the target.</param>
-        [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint,
                                     Uri timestampUrl,
                                     string path,
@@ -540,7 +541,6 @@ public static void SignFile(string certThumbprint,
         /// <param name="targetFrameworkVersion">Version of the .NET Framework for the target.</param>
         /// <param name="targetFrameworkIdentifier">.NET Framework identifier for the target.</param>
         /// <param name="disallowMansignTimestampFallback">Disallow fallback to legacy timestamping when RFC3161 timestamping fails during manifest signing</param>
-        [SupportedOSPlatform("windows")]
         public static void SignFile(string certThumbprint,
                                     Uri timestampUrl,
                                     string path,
@@ -599,7 +599,6 @@ public static void SignFile(string certThumbprint,
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
         /// <remarks>This function is only for signing a manifest, not a PE file.</remarks>
-        [SupportedOSPlatform("windows")]
         public static void SignFile(string certPath, SecureString certPassword, Uri timestampUrl, string path)
         {
             X509Certificate2 cert = new X509Certificate2(certPath, certPassword, X509KeyStorageFlags.PersistKeySet);
@@ -624,7 +623,6 @@ private static bool UseSha256Algorithm(X509Certificate2 cert)
         /// <param name="path">Path of the file to sign with the certificate.</param>
         /// <remarks>This function can only sign a PE file if the X509Certificate2 parameter represents a certificate in the
         /// current user's personal certificate store.</remarks>
-        [SupportedOSPlatform("windows")]
         public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path)
         {
             // setup resources
@@ -632,7 +630,6 @@ public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path
             SignFileInternal(cert, timestampUrl, path, true, resources);
         }
 
-        [SupportedOSPlatform("windows")]
         private static void SignFileInternal(X509Certificate2 cert,
                                             Uri timestampUrl,
                                             string path,
@@ -842,7 +839,7 @@ internal static string GetPathToTool(System.Resources.ResourceManager resources)
                     toolPath = Path.Combine(pathToDotNetFrameworkSdk, "bin", ToolName);
                 }
             }
-            if (NativeMethodsShared.IsWindows && (toolPath == null || !FileSystems.Default.FileExists(toolPath)))
+            if (toolPath == null || !FileSystems.Default.FileExists(toolPath))
             {
                 toolPath = GetVersionIndependentToolPath(ToolName);
             }
@@ -896,7 +893,6 @@ private static bool IsCertInStore(X509Certificate2 cert)
             return false;
         }
 
-        [SupportedOSPlatform("windows")]
         private static string GetVersionIndependentToolPath(string toolName)
         {
             const string versionIndependentToolKeyName = @"Software\Microsoft\ClickOnce\SignTool";
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 56ba265c495..4f098df2091 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -13,7 +13,6 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Runtime.Versioning;
 using System.Security;
 using System.Security.Cryptography;
 using System.Text;
@@ -227,11 +226,11 @@ private static void GetFileInfoImpl(string path, string targetFrameWorkVersion,
 
                 if (string.IsNullOrEmpty(targetFrameWorkVersion) || CompareFrameworkVersions(targetFrameWorkVersion, Constants.TargetFrameworkVersion40) <= 0)
                 {
-                    hashAlg = SHA1.Create("System.Security.Cryptography.SHA1CryptoServiceProvider");
+                    hashAlg = new SHA1CryptoServiceProvider();
                 }
                 else
                 {
-                    hashAlg = SHA256.Create("System.Security.Cryptography.SHA256CryptoServiceProvider");
+                    hashAlg = new SHA256CryptoServiceProvider();
                 }
                 byte[] hashBytes = hashAlg.ComputeHash(s);
                 hash = Convert.ToBase64String(hashBytes);
@@ -251,7 +250,6 @@ private static string GetLogPath()
             return logPath;
         }
 
-        [SupportedOSPlatform("windows")]
         public static string GetRegisteredOrganization()
         {
             RegistryKey key = Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", false);
@@ -517,7 +515,7 @@ public static string WriteTempFile(string s)
             return path;
         }
 
-#region ItemComparer 
+        #region ItemComparer 
         private static readonly ItemComparer s_itemComparer = new ItemComparer();
         private class ItemComparer : IComparer
         {
@@ -543,7 +541,7 @@ int IComparer.Compare(object obj1, object obj2)
                 return String.Compare(item1.ItemSpec, item2.ItemSpec, StringComparison.Ordinal);
             }
         }
-#endregion
+        #endregion
 
         public static Version ConvertFrameworkVersionToString(string version)
         {
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 8d0d9fbf267..d94b4f12a9a 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -12,7 +12,6 @@
 using System.Text;
 using System.Xml;
 using System.Runtime.InteropServices;
-using System.Runtime.Versioning;
 
 using _FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
 
@@ -274,7 +273,7 @@ private void init()
                                Sha256SignatureMethodUri);
 
 #if RUNTIME_TYPE_NETCORE
-            CryptoConfig.AddAlgorithm(typeof(SHA256),
+            CryptoConfig.AddAlgorithm(typeof(SHA256Managed),
                                Sha256DigestMethod);
 #else
             CryptoConfig.AddAlgorithm(typeof(System.Security.Cryptography.SHA256Cng),
@@ -295,7 +294,6 @@ public override XmlElement GetIdElement(XmlDocument document, string idValue)
         }
     }
 
-    [SupportedOSPlatform("windows")]
     internal class SignedCmiManifest2
     {
         private XmlDocument _manifestDom = null;
@@ -555,7 +553,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
 
                 if (useSha256)
                 {
-                    using (SHA256 sha2 = SHA256.Create("System.Security.Cryptography.SHA256CryptoServiceProvider"))
+                    using (SHA256CryptoServiceProvider sha2 = new SHA256CryptoServiceProvider())
                     {
                         byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
                         if (hash == null)
@@ -568,7 +566,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
                 }
                 else
                 {
-                    using (SHA1 sha1 = SHA1.Create("System.Security.Cryptography.SHA1CryptoServiceProvider"))
+                    using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider())
                     {
                         byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
                         if (hash == null)
@@ -603,7 +601,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
 
                 if (useSha256)
                 {
-                    using (SHA256 sha2 = SHA256.Create("System.Security.Cryptography.SHA256CryptoServiceProvider"))
+                    using (SHA256CryptoServiceProvider sha2 = new SHA256CryptoServiceProvider())
                     {
                         byte[] hash = sha2.ComputeHash(exc.GetOutput() as MemoryStream);
                         if (hash == null)
@@ -616,7 +614,7 @@ private static byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldF
                 }
                 else
                 {
-                    using (SHA1 sha1 = SHA1.Create("System.Security.Cryptography.SHA1CryptoServiceProvider"))
+                    using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider())
                     {
                         byte[] hash = sha1.ComputeHash(exc.GetOutput() as MemoryStream);
                         if (hash == null)
@@ -1208,7 +1206,6 @@ internal AsymmetricAlgorithm PublicKey
         }
     }
 
-    [SupportedOSPlatform("windows")]
     internal class CmiAuthenticodeSignerInfo
     {
         private int _error = 0;
@@ -1335,7 +1332,6 @@ internal X509Chain SignerChain
         }
     }
 
-    [SupportedOSPlatform("windows")]
     internal class CmiAuthenticodeTimestamperInfo
     {
         private int _error = 0;
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index d85daf277ed..29e5289bca5 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -956,10 +956,8 @@
     <Reference Include="System.Xaml" />
   </ItemGroup>
   <ItemGroup>
-    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
-    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" SetTargetFramework="TargetFramework=netstandard2.0" OutputItemType="NetstandardRefAssemblies" />
-    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj"/>
-    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj"/>
+    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
+    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
   <ItemGroup>
@@ -969,15 +967,6 @@
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
 
-  <!-- Mimics AddRefAssemblies from MSBuild.csproj -->
-  <Target Name="AddRefAssemblies" 
-          DependsOnTargets="ResolveAssemblyReferences"
-          BeforeTargets="AssignTargetPaths">
-    <ItemGroup>
-      <Content Include="@(NetstandardRefAssemblies)" CopyToOutputDirectory="PreserveNewest" Link="ref\%(Filename)%(Extension)"/>
-    </ItemGroup>
-  </Target>
-
   <!-- Tasks need to mimic redistributing the compilers, so add references to both full framework and .net core -->
   <ItemGroup>
     <!-- Reference this package to get binaries at runtime even when Arcade is not adding compiler references -->
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 42368e48d88..54b21a7a904 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -3,12 +3,9 @@
 
 using System;
 using System.IO;
-using System.Runtime.InteropServices;
-using Microsoft.Build.Shared.FileSystem;
-
-#if FEATURE_COM_INTEROP
 using System.Text;
 using System.Reflection;
+using System.Runtime.InteropServices;
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using System.Collections;
@@ -16,7 +13,7 @@
 using System.Linq;
 using System.Runtime.ExceptionServices;
 using System.Text.RegularExpressions;
-#endif
+using Microsoft.Build.Shared.FileSystem;
 
 #nullable disable
 
@@ -525,7 +522,7 @@ internal enum SymbolicLink
     /// </summary>
     internal static class NativeMethods
     {
-#region Constants
+        #region Constants
 
         internal static readonly IntPtr NullPtr = IntPtr.Zero;
         internal static readonly IntPtr InvalidIntPtr = new IntPtr(-1);
@@ -630,9 +627,9 @@ internal enum MoveFileFlags
             MOVEFILE_FAIL_IF_NOT_TRACKABLE = 0x00000020
         }
 
-#endregion
+        #endregion
 
-#region NT header stuff
+        #region NT header stuff
 
         internal const uint IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
         internal const uint IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b;
@@ -783,9 +780,9 @@ internal struct CRYPTOAPI_BLOB
             internal IntPtr pbData;
         }
 
-#endregion
+        #endregion
 
-#region PInvoke
+        #region PInvoke
         private const string Crypt32DLL = "crypt32.dll";
         private const string Advapi32DLL = "advapi32.dll";
 #if !RUNTIME_TYPE_NETCORE
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
index 5f9ec5dc2a5..78e394ce7bc 100644
--- a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,5 +1,3 @@
 Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
 Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 5f9ec5dc2a5..78e394ce7bc 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,5 +1,3 @@
 Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
 Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index d0dd9311e15..07b5097294d 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -571,10 +571,6 @@
     <value>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</value>
     <comment>{StrBegin="MSB3094: "}</comment>
   </data>
-  <data name="General.TaskRequiresWindows">
-    <value>MSB3096: Task "{0}" is only supported when building on Windows.</value>
-    <comment>{StrBegin="MSB3096: "}</comment>
-  </data>
   <!--
         The GenerateBindingRedirects message bucket is: MSB3831 - MSB3840
 
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 632d5d42323..6d8a68b4bb2 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: V {0} už nějaký soubor existuje. Pokud se pokoušíte vytvořit předvypočítanou mezipaměť, ujistěte se, že sestavujete jeden projekt, který závisí na sestaveních, nikoli sestavení samotná. Pokud spouštíte úlohu ResolveAssemblyReference běžným způsobem, nenastavujte v úloze ResolveAssemblyReference parametr AssemblyInformationCacheOutputPath.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Odstraňování vlastností:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 81c057f5e8e..2b9789a8096 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: Unter "{0}" ist bereits eine Datei vorhanden. Wenn Sie einen vorab berechneten Cache erstellen möchten, stellen Sie sicher, dass Sie ein einzelnes Projekt erstellen, das von Ihren Assemblys abhängt, statt Ihre Assemblys selbst zu erstellen. Wenn Sie die Aufgabe "ResolveAssemblyReference" normal ausführen, legen Sie den Parameter "AssemblyInformationCacheOutputPath" der Aufgabe "ResolveAssemblyReference" nicht fest.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Eigenschaften werden entfernt:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index e270e6039eb..614f167e8d3 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: Ya hay un archivo en "{0}". Si está intentando crear una memoria caché precalculada, asegúrese de estar compilando un solo proyecto que dependa de sus ensamblados, en lugar de compilar los ensamblados en sí. Si está ejecutando la tarea ResolveAssemblyReference normalmente, no establezca el parámetro "AssemblyInformationCacheOutputPath" de la tarea ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Quitando propiedades:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 401d40dffdb..fd0b120daf9 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: il existe déjà un fichier sur "{0}". Si vous essayez de créer un cache précalculé, vérifiez que vous générez un seul projet qui dépend de vos assemblys au lieu de générer les assemblys eux-mêmes. Si vous exécutez la tâche ResolveAssemblyReference normalement, ne définissez pas le paramètre "AssemblyInformationCacheOutputPath" de la tâche ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Suppression des propriétés :</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 40a44c86be9..a1eecfebd2f 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: alla posizione "{0}" esiste già un file. Se si prova a creare una cache precalcolata, assicurarsi di compilare un singolo progetto che dipende dagli assembly invece di compilare gli assembly stessi. Se si esegue normalmente l'attività ResolveAssemblyReference, non impostare il parametro "AssemblyInformationCacheOutputPath" dell'attività ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Rimozione proprietà:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 2fa257164bb..f8741ff1fec 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: "{0}" には既にファイルが存在します。事前計算済みキャッシュを作成しようとしている場合は、アセンブリ自体をビルドするのではなく、アセンブリに依存する単一のプロジェクトをビルドしてください。ResolveAssemblyReference タスクを正常に実行している場合は、ResolveAssemblyReference タスクの "AssemblyInformationCacheOutputPath" パラメーターを設定しないでください。</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">プロパティの削除:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index ee1ea74d0d1..c8f09c65f9f 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: "{0}"에 파일이 이미 있습니다. 사전 계산 캐시를 만들려면 어셈블리 자체를 빌드하는 대신 어셈블리에 종속되는 단일 프로젝트를 빌드하고 있는지 확인하세요. ResolveAssemblyReference 작업을 정상적으로 실행 중인 경우 ResolveAssemblyReference 작업의 "AssemblyInformationCacheOutputPath" 매개 변수를 설정하지 마세요.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">속성 제거:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index bb801b70a60..01c5946d62b 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: W lokalizacji „{0}” już istnieje plik. Jeśli próbujesz utworzyć wstępnie obliczoną pamięć podręczną, upewnij się, że kompilujesz pojedynczy projekt zależący od zestawów, a nie same zestawy. Jeśli uruchamiasz zadanie ResolveAssemblyReference w normalny sposób, nie ustawiaj parametru „AssemblyInformationCacheOutputPath” zadania ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Usuwanie właściwości:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 47364541ad1..f2a99ffe115 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: já existe um arquivo em "{0}". Se você está tentando criar um cache pré-computado, crie um projeto que dependa dos assemblies em vez de criar seus assemblies sozinhos. Se você está executando a tarefa ResolveAssemblyReference normalmente, não defina o parâmetro "AssemblyInformationCacheOutputPath" da tarefa ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Removendo Propriedades:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 74137408038..c8a5ab425e4 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: в "{0}" уже существует файл. Если вы пытаетесь создать предварительно вычисляемый кэш, убедитесь, что выполняется сборка отдельного проекта, который зависит от ваших сборок, а не создание самих сборок. Если вы выполняете задачу ResolveAssemblyReference обычным образом, не устанавливайте параметр "AssemblyInformationCacheOutputPath" задачи ResolveAssemblyReference.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Удаление свойств:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 0ed6814b589..64ba0d8599b 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: "{0}" konumunda zaten bir dosya var. Önceden hesaplanan bir önbellek oluşturmayı deniyorsanız bütünleştirilmiş kodlarınızı derlemek yerine bütünleştirilmiş kodlarınızı temel alan tek bir proje derlediğinizden emin olun. ResolveAssemblyReference görevini normal bir şekilde çalıştırıyorsanız ResolveAssemblyReference görevinin "AssemblyInformationCacheOutputPath" parametresini ayarlamayın.</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Özellikler kaldırılıyor:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index ac772ecf0bf..4e9da2c3e45 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: “{0}”处已存在文件。若要尝试创建预计算缓存，请务必生成单个依赖于程序集的项目，而不是生成程序集本身。如果在正常运行 ResolveAssemblyReference 任务，请不要设置 ResolveAssemblyReference 任务的 "AssemblyInformationCacheOutputPath" 参数。</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">移除属性:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 3ba672a7452..182b61ffc4c 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -514,11 +514,6 @@
         <target state="translated">MSB3667: "{0}" 上已有檔案。若要嘗試建立預先計算的快取，請務必建立一個需要使用組件的專案，而非建立組件本身。若是正常執行 ResolveAssemblyReference 工作，請勿為 ResolveAssemblyReference 工作設定 "AssemblyInformationCacheOutputPath" 參數。</target>
         <note>{StrBegin="MSB3667: "}</note>
       </trans-unit>
-      <trans-unit id="General.TaskRequiresWindows">
-        <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
-        <note>{StrBegin="MSB3096: "}</note>
-      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">正在移除屬性:</target>
diff --git a/src/Tasks/SignFile.cs b/src/Tasks/SignFile.cs
index 379fe059587..2c346a29487 100644
--- a/src/Tasks/SignFile.cs
+++ b/src/Tasks/SignFile.cs
@@ -4,7 +4,6 @@
 using System;
 using System.ComponentModel;
 using System.IO;
-using System.Runtime.Versioning;
 using System.Security.Cryptography;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -20,7 +19,6 @@ namespace Microsoft.Build.Tasks
     /// provided and optionally uses a timestamp if a URL is provided.
     /// It can sign ClickOnce manifests as well as exe's.
     /// </summary>
-    [SupportedOSPlatform("windows")]
     public sealed class SignFile : Task
     {
         public SignFile()
@@ -39,15 +37,11 @@ public SignFile()
         public String TargetFrameworkVersion { get; set; }
 
         public string TimestampUrl { get; set; }
+
         public bool DisallowMansignTimestampFallback { get; set; } = false;
 
         public override bool Execute()
         {
-            if (!NativeMethodsShared.IsWindows)
-            {
-                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(SignFile));
-                return false;
-            }
             try
             {
                 SecurityUtilities.SignFile(
diff --git a/src/Utilities/README.md b/src/Utilities/README.md
index a85d56e11cc..16961c90367 100644
--- a/src/Utilities/README.md
+++ b/src/Utilities/README.md
@@ -5,8 +5,3 @@ This package contains `Microsoft.Build.Utilities.Core.dll`, which defines helper
 * [`Task`](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities.task), a base class for custom tasks,
 * [`ToolTask`](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities.tooltask), a base class for tasks that run a command-line tool, and
 * [`Logger`](https://docs.microsoft.com/dotnet/api/microsoft.build.utilities.logger), a base class for custom logging functionality.
-
-### netstandard2.0 target
-The `netstandard2.0` target of this build is configured only to output reference assemblies; at runtime MSBuild will be `net6.0` or `net472`. Please use the `net6.0`-targeted assemblies for .NET Core 6+ scenarios.
-
-For context, see https://github.com/dotnet/msbuild/pull/6148
\ No newline at end of file
