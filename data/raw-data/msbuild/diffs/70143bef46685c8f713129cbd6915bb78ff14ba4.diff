diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 03b9e7d5087..7164804a6c1 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -5,23 +5,30 @@
 ## EventSource in MSBuild
 EventSource is primarily used to profile code. For MSBuild specifically, a major goal is to reduce the time it takes to run, as measured (among other metrics) by the Regression Prevention System (RPS), i.e., running specific scenarios. To find which code segments were likely candidates for improvement, EventSources were added around a mix of code segments. Larger segments that encompass several steps within a build occur nearly every time MSBuild is run and take a long time. They generally run relatively few times. Smaller methods with well-defined purposes may occur numerous times. Profiling both types of events provides both broad strokes to identify large code segments that underperform and, more specifically, which parts of them. Profiled functions include:
 
-* MSBuildExe: Executes MSBuild from the command line.
-* Build: Sets up a BuildManager to receive build requests.
-* BuildProject: Builds a project file.
-* RequestThreadProc: A function to requesting a new builder thread.
-* LoadDocument: Loads an XMLDocumentWithLocation from a path.
-* RarRemoveReferencesMarkedForExclusion: Removes blacklisted references from the reference table, putting primary and dependency references in invalid file lists.
-* RarComputeClosure: Resolves references from, for example, properties to explicit values. Used in resolving assembly references (RAR).
-* EvaluateCondition: Checks whether a condition is true and removes false conditionals.
-* Parse: Parses an XML document into a ProjectRootElement.
-* Evaluate: Evaluates a project, running several other parts of MSBuild in the process.
-* GenerateResourceOverall: Uses resource APIs to transform resource files into strongly-typed resource classes.
-* ExpandGlob: Identifies a list of files that correspond to an item, potentially with a wildcard.
-* ApplyLazyItemOperations: Collects a set of items, mutates them in a specified way, and saves the results in a lazy way.
-* RarOverall: Initiates the process of resolving assembly references (RAR).
-* Save: Saves a project to the file system if dirty, creating directories as necessary.
-* Target: Executes a target.
-* RarLogResults: Logs the results from having resolved assembly references (RAR).
+| Event | Description |
+| ------| ------------|
+| MSBuildExe | Executes MSBuild from the command line. |
+| Build | Sets up a BuildManager to receive build requests. |
+| BuildProject | Builds a project file. |
+| RequestThreadProc | A function to requesting a new builder thread. |
+| LoadDocument | Loads an XMLDocumentWithLocation from a path.
+| RarRemoveReferencesMarkedForExclusion | Removes blacklisted references from the reference table, putting primary and dependency references in invalid file lists. |
+| RarComputeClosure | Resolves references from, for example, properties to explicit values. Used in resolving assembly references (RAR). |
+| EvaluateCondition | Checks whether a condition is true and removes false conditionals. |
+| Parse | Parses an XML document into a ProjectRootElement. |
+| Evaluate | Evaluates a project, running several other parts of MSBuild in the process. |
+| GenerateResourceOverall | Uses resource APIs to transform resource files into strongly-typed resource classes. |
+| ExpandGlob | Identifies a list of files that correspond to an item, potentially with a wildcard. |
+| ApplyLazyItemOperations | Collects a set of items, mutates them in a specified way, and saves the results in a lazy way. |
+| RarOverall | Initiates the process of resolving assembly references (RAR). |
+| Save | Saves a project to the file system if dirty, creating directories as necessary. |
+| Target | Executes a target. |
+| RarLogResults | Logs the results from having resolved assembly references (RAR). |
+| SdkResolverServiceInitialize | Initializes SDK resolvers. |
+| SdkResolverResolveSdk | A single SDK resolver is called. |
+| CachedSdkResolverServiceResolveSdk | The caching SDK resolver service is resolving an SDK. |
+| SdkResolverEvent | An SDK resolver logs an event. |
+| OutOfProcSdkResolverServiceRequestSdkPathFromMainNode | An out-of-proc node requests an SDK be resolved from the main node. |
 
 One can run MSBuild with eventing using the following command:
 
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
index 723cc6d3507..10041d58494 100644
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ b/documentation/wiki/ResolveAssemblyReference.md
@@ -149,16 +149,16 @@ There were recent fixes made to RAR to alleviate the situation. You can control
 There are two ways to customize the list of paths RAR will search in attempting to locate an assembly. To fully customize the list, the property `AssemblySearchPaths` can be set ahead of time. Note that the order matters; if an assembly is in two locations, RAR will stop after it finds it at the first location.
 
 By default, there are ten locations RAR will search (four if using the .NET SDK), and each can be disabled by setting the relevant flag to false:
-1. Searching files from the current project is disabled by setting the `AssemblySearchPathUseCandidateAssemblyFiles` property to false.
-2. Searching the reference path property (from a .user file) is disabled by setting the `AssemblySearchPathUseReferencePath` property to false.
-3. Using the hint path from the item is disabled by setting the `AssemblySearchPathUseHintPathFromItem` property to false.
-4. Using the directory with MSBuild's target runtime is disabled by setting the `AssemblySearchPathUseTargetFrameworkDirectory` property to false.
-5. Searching assembly folders from AssemblyFolders.config is disabled by setting the `AssemblySearchPathUseAssemblyFoldersConfigFileSearchPath` property to false.
-6. Searching the registry is disabled by setting the `AssemblySearchPathUseRegistry` property to false.
-7. Searching legacy registered assembly folders is disabled by setting the `AssemblySearchPathUseAssemblyFolders` property to false.
-8. Looking in the GAC is disabled by setting the `AssemblySearchPathUseGAC` property to false.
-9. Treating the reference's Include as a real file name is disabled by setting the `AssemblySearchPathUseRawFileName` property to false.
-10. Checking the application's output folder is disabled by setting the `AssemblySearchPathUseOutDir` property to false.
+1. Searching files from the current project is disabled by setting the `AssemblySearchPath_UseCandidateAssemblyFiles` property to false.
+2. Searching the reference path property (from a .user file) is disabled by setting the `AssemblySearchPath_UseReferencePath` property to false.
+3. Using the hint path from the item is disabled by setting the `AssemblySearchPath_UseHintPathFromItem` property to false.
+4. Using the directory with MSBuild's target runtime is disabled by setting the `AssemblySearchPath_UseTargetFrameworkDirectory` property to false.
+5. Searching assembly folders from AssemblyFolders.config is disabled by setting the `AssemblySearchPath_UseAssemblyFoldersConfigFileSearchPath` property to false.
+6. Searching the registry is disabled by setting the `AssemblySearchPath_UseRegistry` property to false.
+7. Searching legacy registered assembly folders is disabled by setting the `AssemblySearchPath_UseAssemblyFolders` property to false.
+8. Looking in the GAC is disabled by setting the `AssemblySearchPath_UseGAC` property to false.
+9. Treating the reference's Include as a real file name is disabled by setting the `AssemblySearchPath_UseRawFileName` property to false.
+10. Checking the application's output folder is disabled by setting the `AssemblySearchPath_UseOutDir` property to false.
 
 ## There was a conflict
 
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index 7c8162be341..b9c1cf4fe0c 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -26,23 +26,20 @@ function Stop-Processes() {
 }
 
 function KillProcessesFromRepo {
-  # Jenkins does not allow taskkill
-  if (-not $ci) {
-    # Kill compiler server and MSBuild node processes from bootstrapped MSBuild (otherwise a second build will fail to copy files in use)
-    foreach ($process in Get-Process | Where-Object {'msbuild', 'dotnet', 'vbcscompiler' -contains $_.Name})
+  # Kill compiler server and MSBuild node processes from bootstrapped MSBuild (otherwise a second build will fail to copy files in use)
+  foreach ($process in Get-Process | Where-Object {'msbuild', 'dotnet', 'vbcscompiler' -contains $_.Name})
+  {
+
+    if ([string]::IsNullOrEmpty($process.Path))
     {
+      Write-Host "Process $($process.Id) $($process.Name) does not have a Path. Skipping killing it."
+      continue
+    }
 
-      if ([string]::IsNullOrEmpty($process.Path))
-      {
-        Write-Host "Process $($process.Id) $($process.Name) does not have a Path. Skipping killing it."
-        continue
-      }
-
-      if ($process.Path.StartsWith($RepoRoot, [StringComparison]::InvariantCultureIgnoreCase))
-      {
-        Write-Host "Killing $($process.Name) from $($process.Path)"
-        taskkill /f /pid $process.Id
-      }
+    if ($process.Path.StartsWith($RepoRoot, [StringComparison]::InvariantCultureIgnoreCase))
+    {
+      Write-Host "Killing $($process.Name) from $($process.Path)"
+      taskkill /f /pid $process.Id
     }
   }
 }
@@ -63,10 +60,6 @@ if ($msbuildEngine -eq '')
 $msbuildToUse = "msbuild"
 
 try {
-
-  # turning off vbcscompiler.exe because it causes the move-item call below to fail
-  $env:UseSharedCompilation="false"
-
   KillProcessesFromRepo
 
   if ($buildStage1)
@@ -74,6 +67,8 @@ try {
     & $PSScriptRoot\Common\Build.ps1 -restore -build -ci -msbuildEngine $msbuildEngine /p:CreateBootstrap=true @properties
   }
 
+  KillProcessesFromRepo
+
   $bootstrapRoot = Join-Path $Stage1BinDir "bootstrap"
 
   # we need to do this to guarantee we have/know where dotnet.exe is installed
@@ -118,9 +113,6 @@ try {
   $buildTool = @{ Path = $buildToolPath; Command = $buildToolCommand; Tool = $msbuildEngine; Framework = $buildToolFramework }
   $global:_BuildTool = $buildTool
 
-  # turn vbcscompiler back on to save on time. It speeds up the build considerably
-  $env:UseSharedCompilation="true"
-
   # Ensure that debug bits fail fast, rather than hanging waiting for a debugger attach.
   $env:MSBUILDDONOTLAUNCHDEBUGGER="true"
 
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index c6d4436ed77..80609e1b593 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -81,6 +81,17 @@ public void ConstructionMetricsAreAvailable()
             graph.ConstructionMetrics.EdgeCount.ShouldBe(2);
         }
 
+        [Fact]
+        public void CycleInGraphDoesNotThrowStackOverflowException()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                TransientTestFile entryProject = CreateProjectFile(env, 1, new[] { 2 });
+                CreateProjectFile(env, 2, new[] { 2 }, extraContent: @"<PropertyGroup><UsingMicrosoftNETSdk>true</UsingMicrosoftNETSdk></PropertyGroup>");
+                Should.Throw<CircularDependencyException>(() => new ProjectGraph(entryProject.Path));
+            }
+        }
+
         [Fact]
         public void ConstructWithSingleNodeWithProjectInstanceFactory()
         {
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 38dda361add..97e1c8f55bf 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -38,10 +38,12 @@ public override void ClearCaches()
 
         public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
-            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath, projectPath);
-
             SdkResult result;
 
+            bool wasResultCached = true;
+
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath, projectPath);
+
             if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
             {
                 result = base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
@@ -59,7 +61,12 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                  */
                 Lazy<SdkResult> resultLazy = cached.GetOrAdd(
                     sdk.Name,
-                    key => new Lazy<SdkResult>(() => base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio)));
+                    key => new Lazy<SdkResult>(() =>
+                    {
+                        wasResultCached = false;
+
+                        return base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                    }));
 
                 // Get the lazy value which will block all waiting threads until the SDK is resolved at least once while subsequent calls get cached results.
                 result = resultLazy.Value;
@@ -73,7 +80,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, result.Version, result.ElementLocation, sdk.Version);
             }
 
-            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath, projectPath, result.Success);
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath, projectPath, result.Success, wasResultCached);
 
             return result;
         }
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 1a449cf0c44..9db962d2a21 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -4,6 +4,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System;
@@ -28,7 +29,7 @@ internal sealed class OutOfProcNodeSdkResolverService : HostedSdkResolverService
         /// <summary>
         /// The cache of responses which is cleared between builds.
         /// </summary>
-        private readonly ConcurrentDictionary<string, SdkResult> _responseCache = new ConcurrentDictionary<string, SdkResult>(MSBuildNameIgnoreCaseComparer.Default);
+        private readonly ConcurrentDictionary<string, Lazy<SdkResult>> _responseCache = new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
         /// An event to signal when a response has been received.
@@ -65,14 +66,21 @@ public override void PacketReceived(int node, INodePacket packet)
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
         public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
+            bool wasResultCached = true;
+
+            MSBuildEventSource.Log.OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStart(submissionId, sdk.Name, solutionPath, projectPath);
+
             // Get a cached response if possible, otherwise send the request
-            var sdkResult = _responseCache.GetOrAdd(
+            Lazy<SdkResult> sdkResultLazy = _responseCache.GetOrAdd(
                 sdk.Name,
-                key =>
+                key => new Lazy<SdkResult>(() =>
                 {
-                    var result = RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
-                    return result;
-                });
+                    wasResultCached = false;
+
+                    return RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                }));
+
+            SdkResult sdkResult = sdkResultLazy.Value;
 
             if (sdkResult.Version != null && !SdkResolverService.IsReferenceSameVersion(sdk, sdkResult.Version))
             {
@@ -80,6 +88,8 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, sdkResult.Version, sdkResult.ElementLocation, sdk.Version);
             }
 
+            MSBuildEventSource.Log.OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(submissionId, sdk.Name, solutionPath, projectPath, _lastResponse.Success, wasResultCached);
+
             return sdkResult;
         }
 
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 1983d6c976c..53f192f268d 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -2159,11 +2159,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                         // clearing the weak cache (and therefore setting explicitload=false) for projects the project system never
                         // was directly interested in (i.e. the ones that were reached for purposes of building a P2P.)
                         bool explicitlyLoaded = importElement.ContainingProject.IsExplicitlyLoaded;
-                        importedProjectElement = _projectRootElementCache.Get(
-                            importFileUnescaped,
-                            (p, c) =>
-                            {
-                                return ProjectRootElement.OpenProjectOrSolution(
+                        importedProjectElement = ProjectRootElement.OpenProjectOrSolution(
                                     importFileUnescaped,
                                     new ReadOnlyConvertingDictionary<string, ProjectPropertyInstance, string>(
                                         _data.GlobalPropertiesDictionary,
@@ -2171,10 +2167,6 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                                     _data.ExplicitToolsVersion,
                                     _projectRootElementCache,
                                     explicitlyLoaded);
-                            },
-                            explicitlyLoaded,
-                            // don't care about formatting, reuse whatever is there
-                            preserveFormatting: null);
 
                         if (duplicateImport)
                         {
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 8c4a2a95a9c..ca0891883b2 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -86,6 +86,15 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// </remarks>
         private static bool s_сheckFileContent;
 
+#if DEBUG
+        /// <summary>
+        /// Number of entries into Get function of the ProjectRootElementCache.
+        /// Shall be always 0 or 1. Reentrance to the Get function (value > 1) could lead to race condition.
+        /// </summary>
+        [ThreadStatic]
+        private static int s_getEntriesNumber = 0;
+#endif
+
         /// <summary>
         /// The map of weakly-held ProjectRootElement's
         /// </summary>
@@ -211,92 +220,115 @@ private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootEl
         /// If item is found, boosts it to the top of the strong cache.
         /// </remarks>
         /// <param name="projectFile">The project file which contains the ProjectRootElement.  Must be a full path.</param>
-        /// <param name="openProjectRootElement">The delegate to use to load if necessary. May be null. Must not update the cache.</param>
+        /// <param name="loadProjectRootElement">The delegate to use to load if necessary. May be null. Must not update the cache.</param>
         /// <param name="isExplicitlyLoaded"><code>true</code> if the project is explicitly loaded, otherwise <code>false</code>.</param>
         /// <param name="preserveFormatting"><code>true</code> to the project was loaded with the formated preserved, otherwise <code>false</code>.</param>
         /// <returns>The ProjectRootElement instance if one exists.  Null otherwise.</returns>
-        internal override ProjectRootElement Get(string projectFile, OpenProjectRootElement openProjectRootElement, bool isExplicitlyLoaded,
+        internal override ProjectRootElement Get(string projectFile, OpenProjectRootElement loadProjectRootElement, bool isExplicitlyLoaded,
             bool? preserveFormatting)
         {
-            // Should already have been canonicalized
-            ErrorUtilities.VerifyThrowInternalRooted(projectFile);
+#if DEBUG
+            // Verify that loadProjectRootElement delegate does not call ProjectRootElementCache.Get().
+            s_getEntriesNumber++;
+            ErrorUtilities.VerifyThrow(
+                s_getEntriesNumber == 1,
+                "Reentrance to the ProjectRootElementCache.Get function detected."
+            );
+
+            try {
+#endif
+                // Should already have been canonicalized
+                ErrorUtilities.VerifyThrowInternalRooted(projectFile);
+
+                ProjectRootElement projectRootElement;
+                lock (_locker)
+                {
+                    _weakCache.TryGetValue(projectFile, out projectRootElement);
 
-            ProjectRootElement projectRootElement;
-            lock (_locker)
-            {
-                _weakCache.TryGetValue(projectFile, out projectRootElement);
+                    if (projectRootElement != null)
+                    {
+                        BoostEntryInStrongCache(projectRootElement);
 
-                if (projectRootElement != null)
-                {
-                    BoostEntryInStrongCache(projectRootElement);
+                        // An implicit load will never reset the explicit flag.
+                        if (isExplicitlyLoaded)
+                        {
+                            projectRootElement.MarkAsExplicitlyLoaded();
+                        }
+                    }
+                    else
+                    {
+                        DebugTraceCache("Not found in cache: ", projectFile);
+                    }
 
-                    // An implicit load will never reset the explicit flag.
-                    if (isExplicitlyLoaded)
+                    if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)
                     {
-                        projectRootElement.MarkAsExplicitlyLoaded();
+                        //  Cached project doesn't match preserveFormatting setting, so reload it
+                        projectRootElement.Reload(true, preserveFormatting);
                     }
                 }
-                else
+
+                bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);
+                if (projectRootElementIsInvalid)
                 {
-                    DebugTraceCache("Not found in cache: ", projectFile);
+                    DebugTraceCache("Not satisfied from cache: ", projectFile);
+                    ForgetEntryIfExists(projectRootElement);
                 }
 
-                if (preserveFormatting != null && projectRootElement != null && projectRootElement.XmlDocument.PreserveWhitespace != preserveFormatting)
+                if (loadProjectRootElement == null)
                 {
-                    //  Cached project doesn't match preserveFormatting setting, so reload it
-                    projectRootElement.Reload(true, preserveFormatting);
+                    if (projectRootElement == null || projectRootElementIsInvalid)
+                    {
+                        return null;
+                    }
+                    else
+                    {
+                        DebugTraceCache("Satisfied from XML cache: ", projectFile);
+                        return projectRootElement;
+                    }
                 }
-            }
-
-            bool projectRootElementIsInvalid = IsInvalidEntry(projectFile, projectRootElement);
-            if (projectRootElementIsInvalid)
-            {
-                DebugTraceCache("Not satisfied from cache: ", projectFile);
-                ForgetEntryIfExists(projectRootElement);
-            }
 
-            if (openProjectRootElement == null)
-            {
+                // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.
                 if (projectRootElement == null || projectRootElementIsInvalid)
                 {
-                    return null;
+                    // We do not lock loading with common _locker of the cache, to avoid lock contention.
+                    // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplication, as
+                    // it is not likely that two threads would use Get function for the same project simultaneously and it is not a big deal if in some cases we load the same project twice.
+
+                    projectRootElement = loadProjectRootElement(projectFile, this);
+                    ErrorUtilities.VerifyThrowInternalNull(projectRootElement, "projectRootElement");
+                    ErrorUtilities.VerifyThrow(
+                        projectRootElement.FullPath.Equals(projectFile, StringComparison.OrdinalIgnoreCase),
+                        "Got project back with incorrect path. Expected path: {0}, received path: {1}.",
+                        projectFile,
+                        projectRootElement.FullPath
+                    );
+
+                    // An implicit load will never reset the explicit flag.
+                    if (isExplicitlyLoaded)
+                    {
+                        projectRootElement.MarkAsExplicitlyLoaded();
+                    }
+
+                    // Update cache element.
+                    // It is unlikely, but it might be that while without the lock, the projectRootElement in cache was updated by another thread.
+                    // And here its entry will be replaced with the loaded projectRootElement. This is fine:
+                    // if loaded projectRootElement is out of date (so, it changed since the time we loaded it), it will be updated the next time some thread calls Get function.
+                    AddEntry(projectRootElement);
                 }
                 else
                 {
                     DebugTraceCache("Satisfied from XML cache: ", projectFile);
-                    return projectRootElement;
                 }
-            }
-
-            // Use openProjectRootElement to reload the element if the cache element does not exist or need to be reloaded.
-            if (projectRootElement == null || projectRootElementIsInvalid)
-            {
-                // We do not lock loading with common _locker of the cache, to avoid lock contention.
-                // Decided also not to lock this section with the key specific locker to avoid the overhead and code overcomplication, as
-                // it is not likely that two threads would use Get function for the same project simulteniously and it is not a big deal if in some cases we load the same project twice.
 
-                projectRootElement = openProjectRootElement(projectFile, this);
-                ErrorUtilities.VerifyThrowInternalNull(projectRootElement, "projectRootElement");
-                ErrorUtilities.VerifyThrow(projectRootElement.FullPath == projectFile, "Got project back with incorrect path");
 
-                // An implicit load will never reset the explicit flag.
-                if (isExplicitlyLoaded)
-                {
-                    projectRootElement.MarkAsExplicitlyLoaded();
-                }
-
-                // Update cache element.
-                // It is unlikely, but it might be that while without the lock, the projectRootElement in cache was updated by another thread.
-                // And here its entry will be replaced with the loaded projectRootElement. This is fine:
-                // if loaded projectRootElement is out of date (so, it changed since the time we loaded it), it will be updated the next time some thread calls Get function.
-                AddEntry(projectRootElement);
+                return projectRootElement;
+#if DEBUG
             }
-            else
+            finally
             {
-                DebugTraceCache("Satisfied from XML cache: ", projectFile);
+                s_getEntriesNumber--;
             }
-
-            return projectRootElement;
+#endif
         }
 
         /// <summary>
@@ -342,7 +374,7 @@ internal override ProjectRootElement TryGet(string projectFile, bool? preserveFo
         {
             ProjectRootElement result = Get(
                 projectFile,
-                openProjectRootElement: null, // no delegate to load it
+                loadProjectRootElement: null, // no delegate to load it
                 isExplicitlyLoaded: false, // Since we are not creating a PRE this can be true or false
                 preserveFormatting: preserveFormatting);
 
diff --git a/src/Build/Evaluation/ProjectRootElementCacheBase.cs b/src/Build/Evaluation/ProjectRootElementCacheBase.cs
index ebc505ad699..69f0fe3137c 100644
--- a/src/Build/Evaluation/ProjectRootElementCacheBase.cs
+++ b/src/Build/Evaluation/ProjectRootElementCacheBase.cs
@@ -47,7 +47,7 @@ internal abstract class ProjectRootElementCacheBase
         /// </summary>
         internal event EventHandler<ProjectChangedEventArgs> ProjectDirtied;
 
-        internal abstract ProjectRootElement Get(string projectFile, OpenProjectRootElement openProjectRootElement,
+        internal abstract ProjectRootElement Get(string projectFile, OpenProjectRootElement loadProjectRootElement,
             bool isExplicitlyLoaded,
             bool? preserveFormatting);
 
diff --git a/src/Build/Evaluation/SimpleProjectRootElementCache.cs b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
index 7864a3a5813..a5cb9278e33 100644
--- a/src/Build/Evaluation/SimpleProjectRootElementCache.cs
+++ b/src/Build/Evaluation/SimpleProjectRootElementCache.cs
@@ -35,16 +35,16 @@ internal SimpleProjectRootElementCache()
 
         internal override ProjectRootElement Get(
             string projectFile,
-            OpenProjectRootElement openProjectRootElement,
+            OpenProjectRootElement loadProjectRootElement,
             bool isExplicitlyLoaded,
             bool? preserveFormatting)
         {
             // Should already have been canonicalized
             ErrorUtilities.VerifyThrowInternalRooted(projectFile);
 
-            return openProjectRootElement == null
+            return loadProjectRootElement == null
                 ? GetFromCache(projectFile)
-                : GetFromOrAddToCache(projectFile, openProjectRootElement);
+                : GetFromOrAddToCache(projectFile, loadProjectRootElement);
         }
 
         private ProjectRootElement GetFromCache(string projectFile)
@@ -57,14 +57,18 @@ private ProjectRootElement GetFromCache(string projectFile)
             return null;
         }
 
-        private ProjectRootElement GetFromOrAddToCache(string projectFile, OpenProjectRootElement openFunc)
+        private ProjectRootElement GetFromOrAddToCache(string projectFile, OpenProjectRootElement loadFunc)
         {
             return _cache.GetOrAdd(projectFile, key =>
             {
-                ProjectRootElement rootElement = openFunc(key, this);
+                ProjectRootElement rootElement = loadFunc(key, this);
                 ErrorUtilities.VerifyThrowInternalNull(rootElement, "projectRootElement");
-                ErrorUtilities.VerifyThrow(rootElement.FullPath.Equals(key, StringComparison.OrdinalIgnoreCase),
-                    "Got project back with incorrect path");
+                ErrorUtilities.VerifyThrow(
+                    rootElement.FullPath.Equals(key, StringComparison.OrdinalIgnoreCase),
+                    "Got project back with incorrect path. Expected path: {0}, received path: {1}.",
+                    key,
+                    rootElement.FullPath
+                );
 
                 AddEntry(rootElement);
 
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index f39c9230244..0ef1ed15d72 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -163,28 +163,52 @@ private void AddEdgesFromProjectReferenceItems(Dictionary<ConfigurationMetadata,
             }
 
             HashSet<ProjectGraphNode> GetTransitiveProjectReferencesExcludingSelf(ParsedProject parsedProject)
+            {
+                HashSet<ProjectGraphNode> references = new();
+                GetTransitiveProjectReferencesExcludingSelfHelper(parsedProject, references, null);
+                return references;
+            }
+
+            // transitiveReferences contains all of the references we've found so far from the initial GetTransitiveProjectReferencesExcludingSelf call.
+            // referencesFromHere is essentially "reset" at each level of the recursion.
+            // The first is important because if we find a cycle at some point, we need to know not to keep recursing. We wouldn't have added to transitiveReferenceCache yet, since we haven't finished
+            // finding all the transitive references yet.
+            // On the other hand, the second is important to help us fill that cache afterwards. The cache is from a particular node to all of its references, including transitive references
+            // but not including itself, which means we can't include parents as we would if we used transitiveReferences. You can see that for any particular call, it creates a new "toCache"
+            // HashSet that we fill with direct references and pass as referencesFromHere in recursive calls to fill it with transitive references. It is then used to populate the cache.
+            // Meanwhile, we avoid going into the recursive step at all if transitiveReferences already includes a particular node to avoid a StackOverflowException if there's a loop.
+            void GetTransitiveProjectReferencesExcludingSelfHelper(ParsedProject parsedProject, HashSet<ProjectGraphNode> traversedReferences, HashSet<ProjectGraphNode> incompleteReferencesOfDirectlyReferencingNode)
             {
                 if (transitiveReferenceCache.TryGetValue(parsedProject.GraphNode, out HashSet<ProjectGraphNode> cachedTransitiveReferences))
                 {
-                    return cachedTransitiveReferences;
+                    traversedReferences.UnionWith(cachedTransitiveReferences);
                 }
                 else
                 {
-                    var transitiveReferences = new HashSet<ProjectGraphNode>();
-
-                    foreach (var referenceInfo in parsedProject.ReferenceInfos)
+                    HashSet<ProjectGraphNode> referencesFromThisNode = new();
+                    foreach (ProjectInterpretation.ReferenceInfo referenceInfo in parsedProject.ReferenceInfos)
                     {
-                        transitiveReferences.Add(allParsedProjects[referenceInfo.ReferenceConfiguration].GraphNode);
-
-                        foreach (var transitiveReference in GetTransitiveProjectReferencesExcludingSelf(allParsedProjects[referenceInfo.ReferenceConfiguration]))
+                        ParsedProject reference = allParsedProjects[referenceInfo.ReferenceConfiguration];
+                        if (traversedReferences.Add(reference.GraphNode))
                         {
-                            transitiveReferences.Add(transitiveReference);
+                            GetTransitiveProjectReferencesExcludingSelfHelper(reference, traversedReferences, referencesFromThisNode);
                         }
+                        else if (transitiveReferenceCache.TryGetValue(reference.GraphNode, out cachedTransitiveReferences))
+                        {
+                            referencesFromThisNode.UnionWith(cachedTransitiveReferences);
+                        }
+                        referencesFromThisNode.Add(reference.GraphNode);
                     }
 
-                    transitiveReferenceCache.Add(parsedProject.GraphNode, transitiveReferences);
-
-                    return transitiveReferences;
+                    // We've returned from recursing through all transitive references
+                    // of this node, so add that set to the cache
+                    transitiveReferenceCache[parsedProject.GraphNode] = referencesFromThisNode;
+                    if (incompleteReferencesOfDirectlyReferencingNode is not null)
+                    {
+                        // Also add it to the set of transitive dependencies of
+                        // the referencing node (which are probably still incomplete)
+                        incompleteReferencesOfDirectlyReferencingNode.UnionWith(referencesFromThisNode);
+                    }
                 }
             }
         }
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 742a09f2d23..092b844562f 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -487,9 +487,9 @@ public void CachedSdkResolverServiceResolveSdkStart(string sdkName, string solut
         }
 
         [Event(67, Keywords = Keywords.All)]
-        public void CachedSdkResolverServiceResolveSdkStop(string sdkName, string solutionPath, string projectPath, bool success)
+        public void CachedSdkResolverServiceResolveSdkStop(string sdkName, string solutionPath, string projectPath, bool success, bool wasResultCached)
         {
-            WriteEvent(67, sdkName, solutionPath, projectPath, success);
+            WriteEvent(67, sdkName, solutionPath, projectPath, success, wasResultCached);
         }
 
         /// <remarks>
@@ -521,6 +521,36 @@ public void ReusableStringBuilderFactoryUnbalanced(int oldHash, int newHash)
             WriteEvent(70, oldHash, newHash);
         }
 
-#endregion
+        [Event(71, Keywords = Keywords.All)]
+        public void SdkResolverEvent(params object[] args)
+        {
+            WriteEvent(71, args);
+        }
+
+        [Event(72, Keywords = Keywords.All)]
+        public void SdkResolverEventStart(params object[] args)
+        {
+            WriteEvent(72, args);
+        }
+
+        [Event(73, Keywords = Keywords.All)]
+        public void SdkResolverEventStop(params object[] args)
+        {
+            WriteEvent(73, args);
+        }
+
+        [Event(74, Keywords = Keywords.All)]
+        public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStart(int submissionId, string sdkName, string solutionPath, string projectPath)
+        {
+            WriteEvent(74, submissionId, sdkName, solutionPath, projectPath);
+        }
+
+        [Event(75, Keywords = Keywords.All)]
+        public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submissionId, string sdkName, string solutionPath, string projectPath, bool success, bool wasResultCached)
+        {
+            WriteEvent(75, submissionId, sdkName, solutionPath, projectPath, success, wasResultCached);
+        }
+
+        #endregion
     }
 }
diff --git a/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt
index e69de29bb2d..ad0d0a96b42 100644
--- a/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -0,0 +1,3 @@
+virtual Microsoft.Build.Framework.SdkLogger.LogEvent(params object[] args) -> void
+virtual Microsoft.Build.Framework.SdkLogger.LogEventStart(params object[] args) -> void
+virtual Microsoft.Build.Framework.SdkLogger.LogEventStop(params object[] args) -> void
\ No newline at end of file
diff --git a/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index e69de29bb2d..ad0d0a96b42 100644
--- a/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -0,0 +1,3 @@
+virtual Microsoft.Build.Framework.SdkLogger.LogEvent(params object[] args) -> void
+virtual Microsoft.Build.Framework.SdkLogger.LogEventStart(params object[] args) -> void
+virtual Microsoft.Build.Framework.SdkLogger.LogEventStop(params object[] args) -> void
\ No newline at end of file
diff --git a/src/Framework/Sdk/SdkLogger.cs b/src/Framework/Sdk/SdkLogger.cs
index cbf47f81245..0cdb5485797 100644
--- a/src/Framework/Sdk/SdkLogger.cs
+++ b/src/Framework/Sdk/SdkLogger.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Eventing;
+
 #nullable disable
 
 namespace Microsoft.Build.Framework
@@ -17,5 +19,32 @@ public abstract class SdkLogger
         /// <param name="message">Message string.</param>
         /// <param name="messageImportance">Optional message importances. Default to low.</param>
         public abstract void LogMessage(string message, MessageImportance messageImportance = MessageImportance.Low);
+
+        /// <summary>
+        /// Logs that an event.
+        /// </summary>
+        /// <param name="args">An array of arguments to log with the event.</param>
+        public virtual void LogEvent(params object[] args)
+        {
+            MSBuildEventSource.Log.SdkResolverEvent(args);
+        }
+
+        /// <summary>
+        /// Logs that an event when an operation has started.
+        /// </summary>
+        /// <param name="args">An array of arguments to log with the event.</param>
+        public virtual void LogEventStart(params object[] args)
+        {
+            MSBuildEventSource.Log.SdkResolverEventStart(args);
+        }
+
+        /// <summary>
+        /// Logs that an event when an operation has completed.
+        /// </summary>
+        /// <param name="args">An array of arguments to log with the event.</param>
+        public virtual void LogEventStop(params object[] args)
+        {
+            MSBuildEventSource.Log.SdkResolverEventStop(args);
+        }
     }
 }
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 5d45a8377c2..c9d62a76669 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1691,7 +1691,7 @@ elementFormDefault="qualified">
     <xs:element name="DeployDirSuffix" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="DisableFastUpToDateCheck" type="msb:boolean" substitutionGroup="msb:Property">
         <xs:annotation>
-            <xs:documentation><!-- _locID_text="DisableFastUpToDateCheck" _locComment="" -->Whether Visual Studio should do its own faster up-to-date check before Building, rather than invoke MSBuild to do a possibly more accurate one. You would set this to false if you have a heavily customized build process and builds in Visual Studio are not occurring when they should.</xs:documentation>
+            <xs:documentation><!-- _locID_text="DisableFastUpToDateCheck" _locComment="" -->Whether Visual Studio should do its own faster up-to-date check before Building, rather than invoke MSBuild to do a possibly more accurate one. You would set this to true if you have a heavily customized build process and builds in Visual Studio are not occurring when they should.</xs:documentation>
         </xs:annotation>
     </xs:element>
     <xs:element name="DocumentationFile" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -3201,25 +3201,25 @@ elementFormDefault="qualified">
             </xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="AssemblySearchPathUseCandidateAssemblyFiles" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseCandidateAssemblyFiles" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
-    <xs:element name="AssemblySearchPathUseReferencePath" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseReferencePath" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
-    <xs:element name="AssemblySearchPathUseHintPathFromItem" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseHintPathFromItem" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
-    <xs:element name="AssemblySearchPathUseTargetFrameworkDirectory" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseTargetFrameworkDirectory" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
-    <xs:element name="AssemblySearchPathUseAssemblyFoldersConfigFileSearchPath" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseAssemblyFoldersConfigFileSearchPath" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
-    <xs:element name="AssemblySearchPathUseRegistry" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseRegistry" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
-    <xs:element name="AssemblySearchPathUseAssemblyFolders" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseAssemblyFolders" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
-    <xs:element name="AssemblySearchPathUseGAC" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseGAC" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
-    <xs:element name="AssemblySearchPathUseRawFileName" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseRawFileName" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
-    <xs:element name="AssemblySearchPathUseOutDir" type="msb:boolean" substitutionGroup="msb:Property">
+    <xs:element name="AssemblySearchPath_UseOutDir" type="msb:boolean" substitutionGroup="msb:Property">
     </xs:element>
     <xs:element name="ResolveAssemblyReference" substitutionGroup="msb:Task">
         <xs:complexType>
@@ -5381,6 +5381,81 @@ elementFormDefault="qualified">
         </xs:complexType>
     </xs:element>
 
+    <!-- ============================ -->
+    <!-- Fast up-to-date check items. -->
+    <!-- ============================ -->
+
+    <xs:element name="UpToDateCheckInput" substitutionGroup="msb:Item">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="UpToDateCheckInputDescription" _locComment="" -->Defines an item to be considered an input to the project for the fast up-to-date check.</xs:documentation>
+        </xs:annotation>
+        <xs:complexType>
+            <xs:complexContent>
+                <xs:extension base="msb:SimpleItemType">
+                    <xs:attribute name="Set">
+                        <xs:annotation>
+                            <xs:documentation><!-- _locID_text="UpToDateCheckInput_Set" _locComment="" -->Optional group(s) of inputs and outputs that should be considered in isolation during build. Useful when a build involves multiple discrete compilation/transpilation steps. Semicolon-delimited when multiple sets are required.</xs:documentation>
+                        </xs:annotation>
+                    </xs:attribute>
+                    <xs:attribute name="Kind">
+                        <xs:annotation>
+                            <xs:documentation><!-- _locID_text="UpToDateCheckInput_Kind" _locComment="" -->Optional identifier for this item that allows it to be omitted from the fast up-to-date check via a global property.</xs:documentation>
+                        </xs:annotation>
+                    </xs:attribute>
+                </xs:extension>
+            </xs:complexContent>
+        </xs:complexType>
+    </xs:element>
+
+    <xs:element name="UpToDateCheckOutput" substitutionGroup="msb:Item">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="UpToDateCheckOutputDescription" _locComment="" -->Defines an item to be considered an output of the project for the fast up-to-date check.</xs:documentation>
+        </xs:annotation>
+        <xs:complexType>
+            <xs:complexContent>
+                <xs:extension base="msb:SimpleItemType">
+                    <xs:attribute name="Set">
+                        <xs:annotation>
+                            <xs:documentation><!-- _locID_text="UpToDateCheckOutput_Set" _locComment="" -->Optional group(s) of inputs and outputs that should be considered in isolation during build. Useful when a build involves multiple discrete compilation/transpilation steps. Semicolon-delimited when multiple sets are required.</xs:documentation>
+                        </xs:annotation>
+                    </xs:attribute>
+                    <xs:attribute name="Kind">
+                        <xs:annotation>
+                            <xs:documentation><!-- _locID_text="UpToDateCheckOutput_Kind" _locComment="" -->Optional identifier for this item that allows it to be omitted from the fast up-to-date check via a global property.</xs:documentation>
+                        </xs:annotation>
+                    </xs:attribute>
+                </xs:extension>
+            </xs:complexContent>
+        </xs:complexType>
+    </xs:element>
+
+    <xs:element name="UpToDateCheckBuilt" substitutionGroup="msb:Item">
+        <xs:annotation>
+            <xs:documentation><!-- _locID_text="UpToDateCheckBuiltDescription" _locComment="" -->Defines an item to be considered an output of the project for the fast up-to-date check, with optional corresponding input via 'Original' metadata. When 'Original' metadata is specified, the input and output are considered in isolation. Useful when a single file will be copied (and potentially transformed in doing so) during build.</xs:documentation>
+        </xs:annotation>
+        <xs:complexType>
+            <xs:complexContent>
+                <xs:extension base="msb:SimpleItemType">
+                    <xs:attribute name="Set">
+                        <xs:annotation>
+                            <xs:documentation><!-- _locID_text="UpToDateCheckBuilt_Set" _locComment="" -->Optional group(s) of inputs and outputs that should be considered in isolation during build. Useful when a build involves multiple discrete compilation/transpilation steps. Semicolon-delimited when multiple sets are required.</xs:documentation>
+                        </xs:annotation>
+                    </xs:attribute>
+                    <xs:attribute name="Kind">
+                        <xs:annotation>
+                            <xs:documentation><!-- _locID_text="UpToDateCheckBuilt_Kind" _locComment="" -->Optional identifier for this item that allows it to be omitted from the fast up-to-date check via a global property.</xs:documentation>
+                        </xs:annotation>
+                    </xs:attribute>
+                    <xs:attribute name="Original">
+                        <xs:annotation>
+                            <xs:documentation><!-- _locID_text="UpToDateCheckBuilt_Original" _locComment="" -->Optional location of the input item that produces this output. Useful when a file is copied (and potentially transformed in doing so) during build. If multiple inputs and/or outputs are involved, use 'Set' metadata instead.</xs:documentation>
+                        </xs:annotation>
+                    </xs:attribute>
+                </xs:extension>
+            </xs:complexContent>
+        </xs:complexType>
+    </xs:element>
+
     <!-- ================ -->
     <!-- Packaging tasks. -->
     <!-- ================ -->
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 84e86faf711..260448aa946 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -625,16 +625,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
             (9) Treat the reference's Include as if it were a real file name.
             (10) Look in the application's output folder (like bin\debug)
         -->
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseCandidateAssemblyFiles) != 'false'">{CandidateAssemblyFiles}</AssemblySearchPaths>
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseReferencePath) != 'false'">$(AssemblySearchPaths);$(ReferencePath)</AssemblySearchPaths>
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseHintPathFromItem) != 'false'">$(AssemblySearchPaths);{HintPathFromItem}</AssemblySearchPaths>
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseTargetFrameworkDirectory) != 'false'">$(AssemblySearchPaths);{TargetFrameworkDirectory}</AssemblySearchPaths>
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseAssemblyFoldersConfigFileSearchPath) != 'false'">$(AssemblySearchPaths);$(AssemblyFoldersConfigFileSearchPath)</AssemblySearchPaths>
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseRegistry) != 'false'">$(AssemblySearchPaths);{Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)}</AssemblySearchPaths>
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseAssemblyFolders) != 'false'">$(AssemblySearchPaths);{AssemblyFolders}</AssemblySearchPaths>
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseGAC) != 'false'">$(AssemblySearchPaths);{GAC}</AssemblySearchPaths>
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseRawFileName) != 'false'">$(AssemblySearchPaths);{RawFileName}</AssemblySearchPaths>
-    <AssemblySearchPaths Condition="$(AssemblySearchPathUseOutDir) != 'false'">$(AssemblySearchPaths);$(OutDir)</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseCandidateAssemblyFiles)' != 'false'">{CandidateAssemblyFiles}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseReferencePath)' != 'false'">$(AssemblySearchPaths);$(ReferencePath)</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseHintPathFromItem)' != 'false'">$(AssemblySearchPaths);{HintPathFromItem}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseTargetFrameworkDirectory)' != 'false'">$(AssemblySearchPaths);{TargetFrameworkDirectory}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseAssemblyFoldersConfigFileSearchPath)' != 'false'">$(AssemblySearchPaths);$(AssemblyFoldersConfigFileSearchPath)</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRegistry)' != 'false'">$(AssemblySearchPaths);{Registry:$(FrameworkRegistryBase),$(TargetFrameworkVersion),$(AssemblyFoldersSuffix)$(AssemblyFoldersExConditions)}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseAssemblyFolders)' != 'false'">$(AssemblySearchPaths);{AssemblyFolders}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseGAC)' != 'false'">$(AssemblySearchPaths);{GAC}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseRawFileName)' != 'false'">$(AssemblySearchPaths);{RawFileName}</AssemblySearchPaths>
+    <AssemblySearchPaths Condition="'$(AssemblySearchPath_UseOutDir)' != 'false'">$(AssemblySearchPaths);$(OutDir)</AssemblySearchPaths>
   </PropertyGroup>
 
   <!-- ContinueOnError takes 3 values:  WarnAndContinue (true), ErrorAndStop (false), and ErrorAndContinue.
