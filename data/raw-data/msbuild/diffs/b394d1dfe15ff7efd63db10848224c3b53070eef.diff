diff --git a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
index 6a652802962..921847004ab 100644
--- a/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskRegistry_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -114,11 +115,11 @@ public void RegisterTaskSimple()
 
             foreach (ProjectUsingTaskElement taskElement in elementList)
             {
-                List<TaskRegistry.RegisteredTaskRecord> registrationRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(taskElement.TaskName, null)];
+                ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registrationRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(taskElement.TaskName, null)];
                 Assert.NotNull(registrationRecords); // "Task registrationrecord not found in TaskRegistry.TaskRegistrations!"
                 Assert.Single(registrationRecords); // "Expected only one record registered under this TaskName!"
 
-                AssemblyLoadInfo taskAssemblyLoadInfo = registrationRecords[0].TaskFactoryAssemblyLoadInfo;
+                AssemblyLoadInfo taskAssemblyLoadInfo = registrationRecords.First().TaskFactoryAssemblyLoadInfo;
                 string assemblyName = String.IsNullOrEmpty(taskElement.AssemblyName) ? null : taskElement.AssemblyName;
                 string assemblyFile = String.IsNullOrEmpty(taskElement.AssemblyFile) ? null : taskElement.AssemblyFile;
                 Assert.Equal(taskAssemblyLoadInfo, AssemblyLoadInfo.Create(assemblyName, assemblyFile)); // "Task record was not properly registered by TaskRegistry.RegisterTask!"
@@ -154,11 +155,11 @@ public void RegisterMultipleTasksWithDifferentNames()
 
             foreach (ProjectUsingTaskElement taskElement in elementList)
             {
-                List<TaskRegistry.RegisteredTaskRecord> registrationRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(taskElement.TaskName, null)];
+                ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registrationRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(taskElement.TaskName, null)];
                 Assert.NotNull(registrationRecords); // "Task registrationrecord not found in TaskRegistry.TaskRegistrations!"
                 Assert.Single(registrationRecords); // "Expected only one record registered under this TaskName!"
 
-                AssemblyLoadInfo taskAssemblyLoadInfo = registrationRecords[0].TaskFactoryAssemblyLoadInfo;
+                AssemblyLoadInfo taskAssemblyLoadInfo = registrationRecords.First().TaskFactoryAssemblyLoadInfo;
 
                 string assemblyName = String.IsNullOrEmpty(taskElement.AssemblyName) ? null : taskElement.AssemblyName;
                 string assemblyFile = String.IsNullOrEmpty(taskElement.AssemblyFile) ? null : taskElement.AssemblyFile;
@@ -198,16 +199,16 @@ public void RegisterMultipleTasksSomeWithSameName()
             Assert.Equal(2, registry.TaskRegistrations.Count); // "Expected only two buckets since two of three tasks have the same name!"
 
             // Now let's look at the bucket with only one task
-            List<TaskRegistry.RegisteredTaskRecord> singletonBucket = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(elementList[1].TaskName, null)];
+            ConcurrentBag<TaskRegistry.RegisteredTaskRecord> singletonBucket = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(elementList[1].TaskName, null)];
             Assert.NotNull(singletonBucket); // "Record not found in TaskRegistry.TaskRegistrations!"
             Assert.Single(singletonBucket); // "Expected only Record registered under this TaskName!"
-            AssemblyLoadInfo singletonAssemblyLoadInfo = singletonBucket[0].TaskFactoryAssemblyLoadInfo;
+            AssemblyLoadInfo singletonAssemblyLoadInfo = singletonBucket.First().TaskFactoryAssemblyLoadInfo;
             string assemblyName = String.IsNullOrEmpty(elementList[1].AssemblyName) ? null : elementList[1].AssemblyName;
             string assemblyFile = String.IsNullOrEmpty(elementList[1].AssemblyFile) ? null : elementList[1].AssemblyFile;
             Assert.Equal(singletonAssemblyLoadInfo, AssemblyLoadInfo.Create(assemblyName, assemblyFile)); // "Task record was not properly registered by TaskRegistry.RegisterTask!"
 
             // Now let's look at the bucket with two tasks
-            List<TaskRegistry.RegisteredTaskRecord> duplicateBucket = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(elementList[0].TaskName, null)];
+            ConcurrentBag<TaskRegistry.RegisteredTaskRecord> duplicateBucket = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(elementList[0].TaskName, null)];
             Assert.NotNull(duplicateBucket); // "Records not found in TaskRegistry.TaskRegistrations!"
             Assert.Equal(2, duplicateBucket.Count); // "Expected two Records registered under this TaskName!"
 
@@ -261,11 +262,11 @@ public void RegisterMultipleTasksWithDifferentNamesFromSameAssembly()
 
             foreach (ProjectUsingTaskElement taskElement in elementList)
             {
-                List<TaskRegistry.RegisteredTaskRecord> registrationRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(taskElement.TaskName, null)];
+                ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registrationRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(taskElement.TaskName, null)];
                 Assert.NotNull(registrationRecords); // "Task registrationrecord not found in TaskRegistry.TaskRegistrations!"
                 Assert.Single(registrationRecords); // "Expected only one record registered under this TaskName!"
 
-                AssemblyLoadInfo taskAssemblyLoadInfo = registrationRecords[0].TaskFactoryAssemblyLoadInfo;
+                AssemblyLoadInfo taskAssemblyLoadInfo = registrationRecords.First().TaskFactoryAssemblyLoadInfo;
                 string assemblyName = String.IsNullOrEmpty(taskElement.AssemblyName) ? null : taskElement.AssemblyName;
                 string assemblyFile = String.IsNullOrEmpty(taskElement.AssemblyFile) ? null : taskElement.AssemblyFile;
                 Assert.Equal(taskAssemblyLoadInfo, AssemblyLoadInfo.Create(assemblyName, assemblyFile == null ? null : Path.GetFullPath(assemblyFile))); // "Task record was not properly registered by TaskRegistry.RegisterTask!"
@@ -1127,7 +1128,7 @@ public void AllUsingTaskAttributesAreExpanded()
             int registeredTaskCount = GetDeepCountOfRegisteredTasks(registry.TaskRegistrations);
             Assert.Equal(3, registeredTaskCount); // "Expected three registered tasks in TaskRegistry.TaskRegistrations!"
 
-            IDictionary<TaskRegistry.RegisteredTaskIdentity, List<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
+            IDictionary<TaskRegistry.RegisteredTaskIdentity, ConcurrentBag<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
 
             foreach (ProjectUsingTaskElement taskElement in elementList)
             {
@@ -1140,13 +1141,13 @@ public void AllUsingTaskAttributesAreExpanded()
                 expandedAssemblyFile = String.IsNullOrEmpty(expandedAssemblyFile) ? null : expandedAssemblyFile;
                 expandedTaskFactory = String.IsNullOrEmpty(expandedTaskFactory) ? "AssemblyTaskFactory" : expandedTaskFactory;
 
-                List<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(expandedtaskName, null)];
+                ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(expandedtaskName, null)];
                 Assert.NotNull(registeredTaskRecords); // "Task to be found in TaskRegistry.TaskRegistrations!"
                 Assert.Single(registeredTaskRecords); // "Expected only one task registered under this TaskName!"
 
-                Assert.Equal(expandedTaskFactory, registeredTaskRecords[0].TaskFactoryAttributeName);
+                Assert.Equal(expandedTaskFactory, registeredTaskRecords.First().TaskFactoryAttributeName);
 
-                AssemblyLoadInfo taskAssemblyLoadInfo = registeredTaskRecords[0].TaskFactoryAssemblyLoadInfo;
+                AssemblyLoadInfo taskAssemblyLoadInfo = registeredTaskRecords.First().TaskFactoryAssemblyLoadInfo;
                 Assert.Equal(taskAssemblyLoadInfo, AssemblyLoadInfo.Create(expandedAssemblyName, expandedAssemblyFile == null ? null : Path.GetFullPath(expandedAssemblyFile))); // "Task record was not properly registered by TaskRegistry.RegisterTask!"
             }
         }
@@ -1183,7 +1184,7 @@ public void TaskRegisteredOnlyIfConditionIsTrue()
             int registeredTaskCount = GetDeepCountOfRegisteredTasks(registry.TaskRegistrations);
             Assert.Equal(2, registeredTaskCount); // "Expected two registered tasks in TaskRegistry.TaskRegistrations!"
 
-            IDictionary<TaskRegistry.RegisteredTaskIdentity, List<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
+            IDictionary<TaskRegistry.RegisteredTaskIdentity, ConcurrentBag<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
 
             for (int i = 0; i <= 2; i += 2)
             {
@@ -1195,11 +1196,11 @@ public void TaskRegisteredOnlyIfConditionIsTrue()
                 expandedAssemblyName = String.IsNullOrEmpty(expandedAssemblyName) ? null : expandedAssemblyName;
                 expandedAssemblyFile = String.IsNullOrEmpty(expandedAssemblyFile) ? null : expandedAssemblyFile;
 
-                List<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(expandedtaskName, null)];
+                ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity(expandedtaskName, null)];
                 Assert.NotNull(registeredTaskRecords); // "Task to be found in TaskRegistry.TaskRegistrations!"
                 Assert.Single(registeredTaskRecords); // "Expected only one task registered under this TaskName!"
 
-                AssemblyLoadInfo taskAssemblyLoadInfo = registeredTaskRecords[0].TaskFactoryAssemblyLoadInfo;
+                AssemblyLoadInfo taskAssemblyLoadInfo = registeredTaskRecords.First().TaskFactoryAssemblyLoadInfo;
                 Assert.Equal(taskAssemblyLoadInfo, AssemblyLoadInfo.Create(expandedAssemblyName, Path.GetFullPath(expandedAssemblyFile))); // "Task record was not properly registered by TaskRegistry.RegisterTask!"
             }
         }
@@ -1221,14 +1222,14 @@ public void NoChildrenElements()
             int registeredTaskCount = GetDeepCountOfRegisteredTasks(registry.TaskRegistrations);
             Assert.Equal(1, registeredTaskCount); // "Expected three registered tasks in TaskRegistry.TaskRegistrations!"
 
-            IDictionary<TaskRegistry.RegisteredTaskIdentity, List<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
+            IDictionary<TaskRegistry.RegisteredTaskIdentity, ConcurrentBag<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
 
             ProjectUsingTaskElement taskElement = elementList[0];
-            List<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Hello", null)];
+            ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Hello", null)];
             Assert.NotNull(registeredTaskRecords); // "Task to be found in TaskRegistry.TaskRegistrations!"
             Assert.Single(registeredTaskRecords); // "Expected only one task registered under this TaskName!"
-            Assert.Empty(registeredTaskRecords[0].ParameterGroupAndTaskBody.UsingTaskParameters);
-            Assert.Null(registeredTaskRecords[0].ParameterGroupAndTaskBody.InlineTaskXmlBody);
+            Assert.Empty(registeredTaskRecords.First().ParameterGroupAndTaskBody.UsingTaskParameters);
+            Assert.Null(registeredTaskRecords.First().ParameterGroupAndTaskBody.InlineTaskXmlBody);
         }
 
         [Fact]
@@ -1273,13 +1274,13 @@ public void EmptyParameterGroup()
 
             int registeredTaskCount = GetDeepCountOfRegisteredTasks(registry.TaskRegistrations);
             Assert.Equal(1, registeredTaskCount); // "Expected three registered tasks in TaskRegistry.TaskRegistrations!"
-            IDictionary<TaskRegistry.RegisteredTaskIdentity, List<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
+            IDictionary<TaskRegistry.RegisteredTaskIdentity, ConcurrentBag<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
 
             ProjectUsingTaskElement taskElement = elementList[0];
-            List<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
+            ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
             Assert.NotNull(registeredTaskRecords); // "Task to be found in TaskRegistry.TaskRegistrations!"
             Assert.Single(registeredTaskRecords); // "Expected only one task registered under this TaskName!"
-            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords[0].ParameterGroupAndTaskBody;
+            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords.First().ParameterGroupAndTaskBody;
             Assert.NotNull(inlineTaskRecord);
             Assert.Null(inlineTaskRecord.InlineTaskXmlBody);
             Assert.Empty(inlineTaskRecord.UsingTaskParameters);
@@ -1309,14 +1310,14 @@ public void MultipleGoodParameters()
 
             int registeredTaskCount = GetDeepCountOfRegisteredTasks(registry.TaskRegistrations);
             Assert.Equal(1, registeredTaskCount); // "Expected three registered tasks in TaskRegistry.TaskRegistrations!"
-            IDictionary<TaskRegistry.RegisteredTaskIdentity, List<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
+            IDictionary<TaskRegistry.RegisteredTaskIdentity, ConcurrentBag<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
 
             ProjectUsingTaskElement taskElement = elementList[0];
-            List<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
+            ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
             Assert.NotNull(registeredTaskRecords); // "Task to be found in TaskRegistry.TaskRegistrations!"
             Assert.Single(registeredTaskRecords); // "Expected only one task registered under this TaskName!"
 
-            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords[0].ParameterGroupAndTaskBody;
+            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords.First().ParameterGroupAndTaskBody;
             Assert.NotNull(inlineTaskRecord);
             Assert.Null(inlineTaskRecord.InlineTaskXmlBody);
             Assert.Equal(2, inlineTaskRecord.UsingTaskParameters.Count);
@@ -1348,7 +1349,7 @@ public void EmptyTypeOnParameter()
 
             List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"].PropertyType.Equals(typeof(String)));
+            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"].PropertyType.Equals(typeof(String)));
         }
 
         /// <summary>
@@ -1363,7 +1364,7 @@ public void NullTypeOnParameter()
 
             List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"].PropertyType.Equals(typeof(String)));
+            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"].PropertyType.Equals(typeof(String)));
         }
 
         /// <summary>
@@ -1573,7 +1574,7 @@ public void EmptyOutput()
 
             List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-            Assert.False(((TaskPropertyInfo)registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"]).Output);
+            Assert.False(((TaskPropertyInfo)registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"]).Output);
         }
 
         /// <summary>
@@ -1588,7 +1589,7 @@ public void NullOutput()
 
             List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-            Assert.False(((TaskPropertyInfo)registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"]).Output);
+            Assert.False(((TaskPropertyInfo)registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"]).Output);
         }
 
         /// <summary>
@@ -1620,7 +1621,7 @@ public void EmptyRequired()
 
             List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-            Assert.False(((TaskPropertyInfo)registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"]).Required);
+            Assert.False(((TaskPropertyInfo)registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"]).Required);
         }
 
         /// <summary>
@@ -1635,7 +1636,7 @@ public void NullRequired()
 
             List<ProjectUsingTaskElement> elementList = CreateParameterElementWithAttributes(output, required, type);
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-            Assert.False(((TaskPropertyInfo)registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"]).Required);
+            Assert.False(((TaskPropertyInfo)registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"]).Required);
         }
 
         /// <summary>
@@ -1682,14 +1683,14 @@ public void ExpandedGoodParameters()
 
             int registeredTaskCount = GetDeepCountOfRegisteredTasks(registry.TaskRegistrations);
             Assert.Equal(1, registeredTaskCount); // "Expected three registered tasks in TaskRegistry.TaskRegistrations!"
-            IDictionary<TaskRegistry.RegisteredTaskIdentity, List<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
+            IDictionary<TaskRegistry.RegisteredTaskIdentity, ConcurrentBag<TaskRegistry.RegisteredTaskRecord>> registeredTasks = registry.TaskRegistrations;
 
             ProjectUsingTaskElement taskElement = elementList[0];
-            List<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
+            ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
             Assert.NotNull(registeredTaskRecords); // "Task to be found in TaskRegistry.TaskRegistrations!"
             Assert.Single(registeredTaskRecords); // "Expected only one task registered under this TaskName!"
 
-            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords[0].ParameterGroupAndTaskBody;
+            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords.First().ParameterGroupAndTaskBody;
             Assert.NotNull(inlineTaskRecord);
             Assert.Null(inlineTaskRecord.InlineTaskXmlBody);
             Assert.Equal(2, inlineTaskRecord.UsingTaskParameters.Count);
@@ -1734,10 +1735,10 @@ public void ExpandedPropertyEvaluate()
 
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
 
-            List<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
+            ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
             Assert.Single(registeredTaskRecords); // "Expected only one task registered under this TaskName!"
 
-            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords[0].ParameterGroupAndTaskBody;
+            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords.First().ParameterGroupAndTaskBody;
             Assert.NotNull(inlineTaskRecord);
             Assert.False(inlineTaskRecord.TaskBodyEvaluated);
         }
@@ -1758,10 +1759,10 @@ public void ExpandedItemEvaluate()
 
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
 
-            List<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
+            ConcurrentBag<TaskRegistry.RegisteredTaskRecord> registeredTaskRecords = registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)];
             Assert.Single(registeredTaskRecords); // "Expected only one task registered under this TaskName!"
 
-            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords[0].ParameterGroupAndTaskBody;
+            TaskRegistry.RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord = registeredTaskRecords.First().ParameterGroupAndTaskBody;
             Assert.NotNull(inlineTaskRecord);
             Assert.True(inlineTaskRecord.TaskBodyEvaluated);
         }
@@ -1777,7 +1778,7 @@ public void FalseEvaluateWithBody()
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
 
             // Make sure when evaluate is false the string passed in is not expanded
-            Assert.False(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.TaskBodyEvaluated.Equals(body));
+            Assert.False(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.TaskBodyEvaluated.Equals(body));
         }
 
         /// <summary>
@@ -1795,7 +1796,7 @@ public void EvaluateWithBody()
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
 
             // Make sure when evaluate is false the string passed in is not expanded
-            Assert.False(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.TaskBodyEvaluated.Equals(expandedBody));
+            Assert.False(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.TaskBodyEvaluated.Equals(expandedBody));
         }
 
         /// <summary>
@@ -1821,7 +1822,7 @@ public void FalseEvaluate()
             string evaluate = bool.FalseString;
             List<ProjectUsingTaskElement> elementList = CreateTaskBodyElementWithAttributes(evaluate, "");
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-            Assert.False(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.TaskBodyEvaluated);
+            Assert.False(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.TaskBodyEvaluated);
         }
 
         /// <summary>
@@ -1833,7 +1834,7 @@ public void EmptyEvaluate()
             string evaluate = "";
             List<ProjectUsingTaskElement> elementList = CreateTaskBodyElementWithAttributes(evaluate, "");
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.TaskBodyEvaluated);
+            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.TaskBodyEvaluated);
         }
 
         /// <summary>
@@ -1845,7 +1846,7 @@ public void NullEvaluate()
             string evaluate = null;
             List<ProjectUsingTaskElement> elementList = CreateTaskBodyElementWithAttributes(evaluate, "");
             TaskRegistry registry = CreateTaskRegistryAndRegisterTasks(elementList);
-            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.TaskBodyEvaluated);
+            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.TaskBodyEvaluated);
         }
         #endregion
 
@@ -2125,7 +2126,7 @@ private void VerifyTypeParameter(string output, string required, string type)
                     true /* case-insensitive */);
             }
 
-            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)][0].ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"].PropertyType.Equals(paramType));
+            Assert.True(registry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("Name", null)].First().ParameterGroupAndTaskBody.UsingTaskParameters["ParameterWithAllAttributesHardCoded"].PropertyType.Equals(paramType));
         }
 
         /// <summary>
@@ -2169,7 +2170,7 @@ private static List<ProjectUsingTaskElement> CreateTaskBodyElementWithAttributes
         /// <summary>
         /// Count the number of registry records which exist in the task registry
         /// </summary>
-        internal static int GetDeepCountOfRegisteredTasks(IDictionary<TaskRegistry.RegisteredTaskIdentity, List<TaskRegistry.RegisteredTaskRecord>> registryRecords)
+        internal static int GetDeepCountOfRegisteredTasks(IDictionary<TaskRegistry.RegisteredTaskIdentity, ConcurrentBag<TaskRegistry.RegisteredTaskRecord>> registryRecords)
         {
             return registryRecords?.Values.Sum(recordList => recordList.Count) ?? 0;
         }
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index cb3ceade820..fcadf84c2fa 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -71,10 +71,10 @@ public void GetTaskRegistrations()
                 ProjectInstance project = new Project(projectRootElementFromString.Project).CreateProjectInstance();
 
                 project.TaskRegistry.TaskRegistrations.Count.ShouldBe(3);
-                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t0", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af0"));
-                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af1a"));
-                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)][1].TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an1");
-                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t2", null)][0].TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an2");
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t0", null)].First().TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af0"));
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)].First().TaskFactoryAssemblyLoadInfo.AssemblyFile.ShouldBe(Path.Combine(Directory.GetCurrentDirectory(), "af1a"));
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t1", null)].Skip(1).First().TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an1");
+                project.TaskRegistry.TaskRegistrations[new TaskRegistry.RegisteredTaskIdentity("t2", null)].First().TaskFactoryAssemblyLoadInfo.AssemblyName.ShouldBe("an2");
             }
             finally
             {
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 582ea3dec52..db0876bff54 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -64,29 +64,17 @@ internal IDictionary<int, BuildResult> ResultsDictionary
         /// <param name="result">The result to add.</param>
         public void AddResult(BuildResult result)
         {
-            lock (_resultsByConfiguration)
+            _resultsByConfiguration.AddOrUpdate(result.ConfigurationId, static (key, newResult) => newResult, static (key, existingResult, newResult) =>
             {
-                if (_resultsByConfiguration.TryGetValue(result.ConfigurationId, out BuildResult buildResult))
+                // Merging results would be meaningless as we would be merging the object with itself.
+                if (!Object.ReferenceEquals(existingResult, newResult))
                 {
-                    if (Object.ReferenceEquals(buildResult, result))
-                    {
-                        // Merging results would be meaningless as we would be merging the object with itself.
-                        return;
-                    }
-
-                    buildResult.MergeResults(result);
+                    existingResult.MergeResults(newResult);
                 }
-                else
-                {
-                    // Note that we are not making a copy here.  This is by-design.  The TargetBuilder uses this behavior
-                    // to ensure that re-entering a project will be able to see all previously built targets and avoid
-                    // building them again.
-                    if (!_resultsByConfiguration.TryAdd(result.ConfigurationId, result))
-                    {
-                        ErrorUtilities.ThrowInternalError("Failed to add result for configuration {0}", result.ConfigurationId);
-                    }
-                }
-            }
+
+                return existingResult;
+            },
+                result);
         }
 
         /// <summary>
@@ -94,15 +82,12 @@ public void AddResult(BuildResult result)
         /// </summary>
         public void ClearResults()
         {
-            lock (_resultsByConfiguration)
+            foreach (KeyValuePair<int, BuildResult> result in _resultsByConfiguration)
             {
-                foreach (KeyValuePair<int, BuildResult> result in _resultsByConfiguration)
-                {
-                    result.Value.ClearCachedFiles();
-                }
-
-                _resultsByConfiguration.Clear();
+                result.Value.ClearCachedFiles();
             }
+
+            _resultsByConfiguration.Clear();
         }
 
         /// <summary>
@@ -114,17 +99,14 @@ public BuildResult GetResultForRequest(BuildRequest request)
         {
             ErrorUtilities.VerifyThrow(request.IsConfigurationResolved, "UnresolvedConfigurationInRequest");
 
-            lock (_resultsByConfiguration)
+            if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult result))
             {
-                if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult result))
+                foreach (string target in request.Targets)
                 {
-                    foreach (string target in request.Targets)
-                    {
-                        ErrorUtilities.VerifyThrow(result.HasResultsForTarget(target), "No results in cache for target " + target);
-                    }
-
-                    return result;
+                    ErrorUtilities.VerifyThrow(result.HasResultsForTarget(target), "No results in cache for target " + target);
                 }
+
+                return result;
             }
 
             return null;
@@ -138,10 +120,7 @@ public BuildResult GetResultForRequest(BuildRequest request)
         public BuildResult GetResultsForConfiguration(int configurationId)
         {
             BuildResult results;
-            lock (_resultsByConfiguration)
-            {
-                _resultsByConfiguration.TryGetValue(configurationId, out results);
-            }
+            _resultsByConfiguration.TryGetValue(configurationId, out results);
 
             return results;
         }
@@ -168,57 +147,54 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
             ErrorUtilities.VerifyThrow(request.IsConfigurationResolved, "UnresolvedConfigurationInRequest");
             ResultsCacheResponse response = new(ResultsCacheResponseType.NotSatisfied);
 
-            lock (_resultsByConfiguration)
+            if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult allResults))
             {
-                if (_resultsByConfiguration.TryGetValue(request.ConfigurationId, out BuildResult allResults))
+                bool buildDataFlagsSatisfied = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
+                    ? AreBuildResultFlagsCompatible(request, allResults) : true;
+
+                if (buildDataFlagsSatisfied)
                 {
-                    bool buildDataFlagsSatisfied = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_12)
-                        ? AreBuildResultFlagsCompatible(request, allResults) : true;
+                    // Check for targets explicitly specified.
+                    bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, checkTargetsMissingResults: true, skippedResultsDoNotCauseCacheMiss);
 
-                    if (buildDataFlagsSatisfied)
+                    if (explicitTargetsSatisfied)
                     {
-                        // Check for targets explicitly specified.
-                        bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, checkTargetsMissingResults: true, skippedResultsDoNotCauseCacheMiss);
+                        // All of the explicit targets, if any, have been satisfied
+                        response.Type = ResultsCacheResponseType.Satisfied;
 
-                        if (explicitTargetsSatisfied)
+                        // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
+                        if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, checkTargetsMissingResults: false, skippedResultsDoNotCauseCacheMiss))
                         {
-                            // All of the explicit targets, if any, have been satisfied
-                            response.Type = ResultsCacheResponseType.Satisfied;
+                            response.Type = ResultsCacheResponseType.NotSatisfied;
+                        }
 
-                            // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
-                            if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, checkTargetsMissingResults: false, skippedResultsDoNotCauseCacheMiss))
+                        // We could still be missing implicit targets, so check those...
+                        if (request.Targets.Count == 0)
+                        {
+                            // Check for the default target, if necessary.  If we don't know what the default targets are, we
+                            // assume they are not satisfied.
+                            if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, checkTargetsMissingResults: false, skippedResultsDoNotCauseCacheMiss))
                             {
                                 response.Type = ResultsCacheResponseType.NotSatisfied;
                             }
+                        }
 
-                            // We could still be missing implicit targets, so check those...
-                            if (request.Targets.Count == 0)
+                        // Now report those results requested, if they are satisfied.
+                        if (response.Type == ResultsCacheResponseType.Satisfied)
+                        {
+                            List<string> targetsToAddResultsFor = new List<string>(configInitialTargets);
+
+                            // Now report either the explicit targets or the default targets
+                            if (request.Targets.Count > 0)
                             {
-                                // Check for the default target, if necessary.  If we don't know what the default targets are, we
-                                // assume they are not satisfied.
-                                if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, checkTargetsMissingResults: false, skippedResultsDoNotCauseCacheMiss))
-                                {
-                                    response.Type = ResultsCacheResponseType.NotSatisfied;
-                                }
+                                targetsToAddResultsFor.AddRange(request.Targets);
                             }
-
-                            // Now report those results requested, if they are satisfied.
-                            if (response.Type == ResultsCacheResponseType.Satisfied)
+                            else
                             {
-                                List<string> targetsToAddResultsFor = new List<string>(configInitialTargets);
-
-                                // Now report either the explicit targets or the default targets
-                                if (request.Targets.Count > 0)
-                                {
-                                    targetsToAddResultsFor.AddRange(request.Targets);
-                                }
-                                else
-                                {
-                                    targetsToAddResultsFor.AddRange(configDefaultTargets);
-                                }
-
-                                response.Results = new BuildResult(request, allResults, targetsToAddResultsFor.ToArray(), null);
+                                targetsToAddResultsFor.AddRange(configDefaultTargets);
                             }
+
+                            response.Results = new BuildResult(request, allResults, targetsToAddResultsFor.ToArray(), null);
                         }
                     }
                 }
@@ -233,12 +209,9 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
         /// <param name="configurationId">The configuration</param>
         public void ClearResultsForConfiguration(int configurationId)
         {
-            lock (_resultsByConfiguration)
-            {
-                _resultsByConfiguration.TryRemove(configurationId, out BuildResult removedResult);
+            _resultsByConfiguration.TryRemove(configurationId, out BuildResult removedResult);
 
-                removedResult?.ClearCachedFiles();
-            }
+            removedResult?.ClearCachedFiles();
         }
 
         public void Translate(ITranslator translator)
@@ -262,12 +235,9 @@ public void Translate(ITranslator translator)
         /// </summary>
         public void WriteResultsToDisk()
         {
-            lock (_resultsByConfiguration)
+            foreach (BuildResult resultToCache in _resultsByConfiguration.Values)
             {
-                foreach (BuildResult resultToCache in _resultsByConfiguration.Values)
-                {
-                    resultToCache.CacheIfPossible();
-                }
+                resultToCache.CacheIfPossible();
             }
         }
 
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 40c16dc66da..a5f12d19320 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -12,6 +12,7 @@
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
@@ -56,8 +57,6 @@ namespace Microsoft.Build.Execution
     /// </example>
     internal sealed class TaskRegistry : ITranslatable
     {
-        private static readonly object lockObject = new object();
-
         /// <summary>
         /// The fallback task registry
         /// </summary>
@@ -155,14 +154,14 @@ internal sealed class TaskRegistry : ITranslatable
         /// This field may be null.
         /// This is expected to be modified only during initialization via a single call, and all reads will occur only after the initialization is done - so no need for a concurrent dictionary.
         /// </summary>
-        private ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> _taskRegistrations;
+        private ConcurrentDictionary<RegisteredTaskIdentity, ConcurrentBag<RegisteredTaskRecord>> _taskRegistrations;
 
         /// <summary>
         /// Create another set containing architecture-specific task entries.
         ///  Then when we look for them, check if the name exists in that.
         /// This is expected to be modified only during initialization via a single call, and all reads will occur only after the initialization is done - so no need for a concurrent dictionary.
         /// </summary>
-        private readonly Dictionary<string, List<RegisteredTaskRecord>> _overriddenTasks = new Dictionary<string, List<RegisteredTaskRecord>>();
+        private readonly ConcurrentDictionary<string, ConcurrentBag<RegisteredTaskRecord>> _overriddenTasks = new ConcurrentDictionary<string, ConcurrentBag<RegisteredTaskRecord>>();
 
 #if DEBUG
         /// <summary>
@@ -231,20 +230,16 @@ internal Toolset Toolset
         /// Access list of task registrations.
         /// FOR UNIT TESTING ONLY.
         /// </summary>
-        internal IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> TaskRegistrations
+        internal IDictionary<RegisteredTaskIdentity, ConcurrentBag<RegisteredTaskRecord>> TaskRegistrations
         {
             get
             {
-                lock (lockObject)
+                if (_taskRegistrations == null)
                 {
-
-                    if (_taskRegistrations == null)
-                    {
-                        _taskRegistrations = CreateRegisteredTaskDictionary();
-                    }
-
-                    return _taskRegistrations;
+                    Interlocked.CompareExchange(ref _taskRegistrations, CreateRegisteredTaskDictionary(), null);
                 }
+
+                return _taskRegistrations;
             }
         }
 
@@ -265,24 +260,21 @@ internal static void InitializeTaskRegistryFromUsingTaskElements<P, I>(
             where P : class, IProperty
             where I : class, IItem
         {
-            lock (lockObject)
+            foreach ((ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile) registration in registrations)
             {
-                foreach ((ProjectUsingTaskElement projectUsingTaskXml, string directoryOfImportingFile) registration in registrations)
-                {
-                    RegisterTasksFromUsingTaskElement(
-                        loggingContext,
-                        registration.directoryOfImportingFile,
-                        registration.projectUsingTaskXml,
-                        taskRegistry,
-                        expander,
-                        expanderOptions,
-                        fileSystem);
-                }
+                RegisterTasksFromUsingTaskElement(
+                    loggingContext,
+                    registration.directoryOfImportingFile,
+                    registration.projectUsingTaskXml,
+                    taskRegistry,
+                    expander,
+                    expanderOptions,
+                    fileSystem);
+            }
 #if DEBUG
-                taskRegistry._isInitialized = true;
-                taskRegistry._taskRegistrations ??= TaskRegistry.CreateRegisteredTaskDictionary();
+            taskRegistry._isInitialized = true;
+            taskRegistry._taskRegistrations ??= TaskRegistry.CreateRegisteredTaskDictionary();
 #endif
-            }
         }
 
         /// <summary>
@@ -529,148 +521,159 @@ internal RegisteredTaskRecord GetTaskRegistrationRecord(
             ElementLocation elementLocation,
             out bool retrievedFromCache)
         {
-            lock (lockObject)
-            {
-                RegisteredTaskRecord taskRecord = null;
-                retrievedFromCache = false;
-                RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);
+            retrievedFromCache = false;
+            RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);
 
-                // Project-level override tasks are keyed by task name (unqualified).
-                // Because Foo.Bar and Baz.Bar are both valid, they are stored
-                // in a dictionary keyed as `Bar` because most tasks are called unqualified
-                if (_overriddenTasks.TryGetValue(taskName, out List<RegisteredTaskRecord> recs))
+            // Project-level override tasks are keyed by task name (unqualified).
+            // Because Foo.Bar and Baz.Bar are both valid, they are stored
+            // in a dictionary keyed as `Bar` because most tasks are called unqualified
+            if (_overriddenTasks.TryGetValue(taskName, out ConcurrentBag<RegisteredTaskRecord> recs))
+            {
+                // When we determine this task was overridden, search all task records
+                // to find the most correct registration. Search with the fully qualified name (if applicable)
+                // Behavior is intended to be "first one wins"
+                foreach (RegisteredTaskRecord rec in recs)
                 {
-                    // When we determine this task was overridden, search all task records
-                    // to find the most correct registration. Search with the fully qualified name (if applicable)
-                    // Behavior is intended to be "first one wins"
-                    foreach (RegisteredTaskRecord rec in recs)
+                    if (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, rec.TaskIdentity))
                     {
-                        if (RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, rec.TaskIdentity))
-                        {
-                            return rec;
-                        }
+                        return rec;
                     }
                 }
+            }
 
-                // Try the override task registry first
-                if (_toolset != null)
+            RegisteredTaskRecord taskRecord = null;
+            // Try the override task registry first
+            if (_toolset != null)
+            {
+                TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext, RootElementCache);
+                taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
+            }
+
+            // Try the current task registry
+            if (taskRecord == null && _taskRegistrations is not null && !_taskRegistrations.IsEmpty)
+            {
+                if (exactMatchRequired)
                 {
-                    TaskRegistry toolsetRegistry = _toolset.GetOverrideTaskRegistry(targetLoggingContext, RootElementCache);
-                    taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
+                    if (_cachedTaskRecordsWithExactMatch.TryGetValue(taskIdentity, out taskRecord))
+                    {
+                        retrievedFromCache = true;
+                        return taskRecord;
+                    }
                 }
-
-                // Try the current task registry
-                if (taskRecord == null && _taskRegistrations?.Count > 0)
+                else
                 {
-                    if (exactMatchRequired)
+                    if (_cachedTaskRecordsWithFuzzyMatch.TryGetValue(taskIdentity.Name, out ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords))
                     {
-                        if (_cachedTaskRecordsWithExactMatch.TryGetValue(taskIdentity, out taskRecord))
+                        // if we've looked up this exact one before, just grab it and return
+                        if (taskRecords.TryGetValue(taskIdentity, out taskRecord))
                         {
                             retrievedFromCache = true;
                             return taskRecord;
                         }
-                    }
-                    else
-                    {
-                        if (_cachedTaskRecordsWithFuzzyMatch.TryGetValue(taskIdentity.Name, out ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords))
+                        else
                         {
-                            // if we've looked up this exact one before, just grab it and return
-                            if (taskRecords.TryGetValue(taskIdentity, out taskRecord))
+                            // otherwise, check the "short list" of everything else included here to see if one of them matches
+                            foreach (RegisteredTaskRecord record in taskRecords.Values)
                             {
-                                retrievedFromCache = true;
-                                return taskRecord;
-                            }
-                            else
-                            {
-                                // otherwise, check the "short list" of everything else included here to see if one of them matches
-                                foreach (RegisteredTaskRecord record in taskRecords.Values)
+                                // Just return the first one that actually matches.  There may be nulls in here as well, if we've previously attempted to
+                                // find a variation on this task record and failed.  In that case, since it wasn't an exact match (otherwise it would have
+                                // been picked up by the check above) just ignore it, the way we ignore task records that don't work with this set of
+                                // parameters.
+                                if (record != null)
                                 {
-                                    // Just return the first one that actually matches.  There may be nulls in here as well, if we've previously attempted to
-                                    // find a variation on this task record and failed.  In that case, since it wasn't an exact match (otherwise it would have
-                                    // been picked up by the check above) just ignore it, the way we ignore task records that don't work with this set of
-                                    // parameters.
-                                    if (record != null)
+                                    if (record.CanTaskBeCreatedByFactory(taskName, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation))
                                     {
-                                        if (record.CanTaskBeCreatedByFactory(taskName, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation))
-                                        {
-                                            retrievedFromCache = true;
-                                            return record;
-                                        }
+                                        retrievedFromCache = true;
+                                        return record;
                                     }
                                 }
                             }
-
-                            // otherwise, nothing fit, so act like we never hit the cache at all.
                         }
+
+                        // otherwise, nothing fit, so act like we never hit the cache at all.
                     }
+                }
 
-                    IEnumerable<RegisteredTaskRecord> registrations = GetRelevantOrderedRegistrations(taskIdentity, exactMatchRequired);
+                IEnumerable<RegisteredTaskRecord> registrations = GetRelevantOrderedRegistrations(taskIdentity, exactMatchRequired);
 
-                    // look for the given task name in the registry; if not found, gather all registered task names that partially
-                    // match the given name
-                    taskRecord = GetMatchingRegistration(taskName, registrations, taskProjectFile, taskIdentityParameters, targetLoggingContext, elementLocation);
+                // look for the given task name in the registry; if not found, gather all registered task names that partially
+                // match the given name
+                foreach (RegisteredTaskRecord r in registrations)
+                {
+                    if (r.CanTaskBeCreatedByFactory(
+                                    // if the given task name is longer than the registered task name
+                                    // we will use the longer name to help disambiguate between multiple matches
+                                    (taskName.Length > r.TaskIdentity.Name.Length) ? taskName : r.TaskIdentity.Name,
+                                    taskProjectFile,
+                                    taskIdentityParameters,
+                                    targetLoggingContext,
+                                    elementLocation))
+                    {
+                        taskRecord = r;
+                        break;
+                    }
                 }
+            }
 
-                // If we didn't find the task but we have a fallback registry in the toolset state, try that one.
-                if (taskRecord == null && _toolset != null)
+            // If we didn't find the task but we have a fallback registry in the toolset state, try that one.
+            if (taskRecord == null && _toolset != null)
+            {
+                TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext, RootElementCache);
+                taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
+            }
+
+            // Cache the result, even if it is null.  We should never again do the work we just did, for this task name.
+            if (exactMatchRequired)
+            {
+                _cachedTaskRecordsWithExactMatch[taskIdentity] = taskRecord;
+            }
+            else
+            {
+                // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
+                // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.
+                //
+                // To prevent us inadvertently leaking something incompatible, in this case, we need to store not just the
+                // record that we got this time, but ALL of the records that have previously matched this key.
+                //
+                // Furthermore, the first level key needs to be the name of the task, not its identity -- otherwise we might
+                // end up with multiple entries containing subsets of the same fuzzy-matchable tasks.  E.g. with the following
+                // set of steps:
+                // 1. Look up Foo | bar
+                // 2. Look up Foo | * (goes into Foo | bar cache entry)
+                // 3. Look up Foo | baz (gets its own entry because it doesn't match Foo | bar)
+                // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up
+                //    first, might get Foo | baz, which also matches, instead)
+                ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords
+                    = _cachedTaskRecordsWithFuzzyMatch.GetOrAdd(taskIdentity.Name,
+                        _ => new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));
+
+                taskRecords[taskIdentity] = taskRecord;
+                _cachedTaskRecordsWithFuzzyMatch[taskIdentity.Name] = taskRecords;
+            }
+
+            return taskRecord;
+
+            // Searches all task declarations for the given task name.
+            // If no exact match is found, looks for partial matches.
+            // A task name that is not fully qualified may produce several partial matches.
+            IEnumerable<RegisteredTaskRecord> GetRelevantOrderedRegistrations(RegisteredTaskIdentity taskIdentity, bool exactMatchRequired)
+            {
+                if (_taskRegistrations.TryGetValue(taskIdentity, out ConcurrentBag<RegisteredTaskRecord> taskAssemblies))
                 {
-                    TaskRegistry toolsetRegistry = _toolset.GetTaskRegistry(targetLoggingContext, RootElementCache);
-                    taskRecord = toolsetRegistry.GetTaskRegistrationRecord(taskName, taskProjectFile, taskIdentityParameters, exactMatchRequired, targetLoggingContext, elementLocation, out retrievedFromCache);
+                    // (records for single key should be ordered by order of registrations - as they are inserted into the list)
+                    return taskAssemblies;
                 }
 
-                // Cache the result, even if it is null.  We should never again do the work we just did, for this task name.
                 if (exactMatchRequired)
                 {
-                    _cachedTaskRecordsWithExactMatch[taskIdentity] = taskRecord;
-                }
-                else
-                {
-                    // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
-                    // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.
-                    //
-                    // To prevent us inadvertently leaking something incompatible, in this case, we need to store not just the
-                    // record that we got this time, but ALL of the records that have previously matched this key.
-                    //
-                    // Furthermore, the first level key needs to be the name of the task, not its identity -- otherwise we might
-                    // end up with multiple entries containing subsets of the same fuzzy-matchable tasks.  E.g. with the following
-                    // set of steps:
-                    // 1. Look up Foo | bar
-                    // 2. Look up Foo | * (goes into Foo | bar cache entry)
-                    // 3. Look up Foo | baz (gets its own entry because it doesn't match Foo | bar)
-                    // 4. Look up Foo | * (should get the Foo | * under Foo | bar, but depending on what the dictionary looks up
-                    //    first, might get Foo | baz, which also matches, instead)
-                    ConcurrentDictionary<RegisteredTaskIdentity, RegisteredTaskRecord> taskRecords
-                        = _cachedTaskRecordsWithFuzzyMatch.GetOrAdd(taskIdentity.Name,
-                            _ => new(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact));
-
-                    taskRecords[taskIdentity] = taskRecord;
-                    _cachedTaskRecordsWithFuzzyMatch[taskIdentity.Name] = taskRecords;
+                    return [];
                 }
 
-                return taskRecord;
-
-                // Searches all task declarations for the given task name.
-                // If no exact match is found, looks for partial matches.
-                // A task name that is not fully qualified may produce several partial matches.
-                IEnumerable<RegisteredTaskRecord> GetRelevantOrderedRegistrations(RegisteredTaskIdentity taskIdentity, bool exactMatchRequired)
-                {
-                    if (_taskRegistrations.TryGetValue(taskIdentity, out List<RegisteredTaskRecord> taskAssemblies))
-                    {
-                        // (records for single key should be ordered by order of registrations - as they are inserted into the list)
-                        return taskAssemblies;
-                    }
-
-                    if (exactMatchRequired)
-                    {
-                        return [];
-                    }
-
-                    // look through all task declarations for partial matches
-                    return _taskRegistrations
-                        .Where(tp => RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, tp.Key))
-                        .SelectMany(tp => tp.Value)
-                        .OrderBy(r => r.RegistrationOrderId);
-                }
+                // look through all task declarations for partial matches
+                return _taskRegistrations
+                    .Where(tp => RegisteredTaskIdentity.RegisteredTaskIdentityComparer.IsPartialMatch(taskIdentity, tp.Key))
+                    .SelectMany(tp => tp.Value)
+                    .OrderBy(r => r.RegistrationOrderId);
             }
         }
 
@@ -701,95 +704,67 @@ private void RegisterTask(
             ErrorUtilities.VerifyThrowInternalLength(taskName, nameof(taskName));
             ErrorUtilities.VerifyThrowInternalNull(assemblyLoadInfo);
 
-            lock (lockObject)
+            // Lazily allocate the hashtable
+            if (_taskRegistrations == null)
             {
-                // Lazily allocate the hashtable
-                if (_taskRegistrations == null)
-                {
-                    _taskRegistrations = CreateRegisteredTaskDictionary();
-                }
+                Interlocked.CompareExchange(ref _taskRegistrations, CreateRegisteredTaskDictionary(), null);
+            }
 
-                // since more than one task can have the same name, we want to keep track of all assemblies that are declared to
-                // contain tasks with a given name...
-                List<RegisteredTaskRecord> registeredTaskEntries;
-                RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskFactoryParameters);
-                if (!_taskRegistrations.TryGetValue(taskIdentity, out registeredTaskEntries))
-                {
-                    registeredTaskEntries = new List<RegisteredTaskRecord>();
-                    _taskRegistrations[taskIdentity] = registeredTaskEntries;
-                }
+            // since more than one task can have the same name, we want to keep track of all assemblies that are declared to
+            // contain tasks with a given name...
+            RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskFactoryParameters);
+            ConcurrentBag<RegisteredTaskRecord> registeredTaskEntries = _taskRegistrations.GetOrAdd(taskIdentity, _ => new ConcurrentBag<RegisteredTaskRecord>());
 
-                RegisteredTaskRecord newRecord = new RegisteredTaskRecord(
-                    taskName,
-                    assemblyLoadInfo,
-                    taskFactory,
-                    taskFactoryParameters,
-                    inlineTaskRecord,
-                    Interlocked.Increment(ref _nextRegistrationOrderId));
+            RegisteredTaskRecord newRecord = new RegisteredTaskRecord(
+                taskName,
+                assemblyLoadInfo,
+                taskFactory,
+                taskFactoryParameters,
+                inlineTaskRecord,
+                Interlocked.Increment(ref _nextRegistrationOrderId));
 
-                if (overrideTask)
-                {
-                    // Key the dictionary based on Unqualified task names
-                    // This is to support partial matches on tasks like Foo.Bar and Baz.Bar
-                    string[] nameComponents = taskName.Split('.');
-                    string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];
+            if (overrideTask)
+            {
+                // Key the dictionary based on Unqualified task names
+                // This is to support partial matches on tasks like Foo.Bar and Baz.Bar
+                string[] nameComponents = taskName.Split('.');
+                string unqualifiedTaskName = nameComponents[nameComponents.Length - 1];
 
-                    // Is the task already registered?
-                    if (_overriddenTasks.TryGetValue(unqualifiedTaskName, out List<RegisteredTaskRecord> recs))
+                // Is the task already registered?
+                if (_overriddenTasks.TryGetValue(unqualifiedTaskName, out ConcurrentBag<RegisteredTaskRecord> recs))
+                {
+                    foreach (RegisteredTaskRecord rec in recs)
                     {
-                        foreach (RegisteredTaskRecord rec in recs)
+                        if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))
                         {
-                            if (rec.RegisteredName.Equals(taskIdentity.Name, StringComparison.OrdinalIgnoreCase))
-                            {
-                                loggingContext.LogError(new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
-                                break;
-                            }
+                            loggingContext.LogError(new BuildEventFileInfo(projectUsingTaskInXml.OverrideLocation), "DuplicateOverrideUsingTaskElement", taskName);
+                            break;
                         }
-                        recs.Add(newRecord);
-                    }
-                    else
-                    {
-                        // New record's name may be fully qualified. Use it anyway to account for partial matches.
-                        List<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();
-                        unqualifiedTaskNameMatches.Add(newRecord);
-                        _overriddenTasks.Add(unqualifiedTaskName, unqualifiedTaskNameMatches);
-                        loggingContext.LogComment(MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
                     }
+                    recs.Add(newRecord);
                 }
+                else
+                {
+                    // New record's name may be fully qualified. Use it anyway to account for partial matches.
+                    ConcurrentBag<RegisteredTaskRecord> unqualifiedTaskNameMatches = new();
+                    var concurrentBag = _overriddenTasks.GetOrAdd(unqualifiedTaskName, _ => new ConcurrentBag<RegisteredTaskRecord>());
+
+                    concurrentBag.Add(newRecord);
 
-                registeredTaskEntries.Add(newRecord);
+                    loggingContext.LogComment(MessageImportance.Low, "OverrideUsingTaskElementCreated", taskName, projectUsingTaskInXml.OverrideLocation);
+                }
             }
+
+            registeredTaskEntries.Add(newRecord);
         }
 
-        private static ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)
+        private static ConcurrentDictionary<RegisteredTaskIdentity, ConcurrentBag<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(int? capacity = null)
         {
             return capacity != null
-                ? new ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(Environment.ProcessorCount, capacity.Value, RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact)
-                : new ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
+                ? new ConcurrentDictionary<RegisteredTaskIdentity, ConcurrentBag<RegisteredTaskRecord>>(Environment.ProcessorCount, capacity.Value, RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact)
+                : new ConcurrentDictionary<RegisteredTaskIdentity, ConcurrentBag<RegisteredTaskRecord>>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
         }
 
-        /// <summary>
-        /// Given a task name and a list of records which may contain the task, this helper method will ask the records to see if the task name
-        /// can be created by the factories which are wrapped by the records. (this is done by instantiating the task factory and asking it).
-        /// </summary>
-        private RegisteredTaskRecord GetMatchingRegistration(
-            string taskName,
-            IEnumerable<RegisteredTaskRecord> taskRecords,
-            string taskProjectFile,
-            IDictionary<string, string> taskIdentityParameters,
-            TargetLoggingContext targetLoggingContext,
-            ElementLocation elementLocation)
-            =>
-                taskRecords.FirstOrDefault(r =>
-                    r.CanTaskBeCreatedByFactory(
-                        // if the given task name is longer than the registered task name
-                        // we will use the longer name to help disambiguate between multiple matches
-                        (taskName.Length > r.TaskIdentity.Name.Length) ? taskName : r.TaskIdentity.Name,
-                        taskProjectFile,
-                        taskIdentityParameters,
-                        targetLoggingContext,
-                        elementLocation));
-
         /// <summary>
         /// An object representing the identity of a task -- not just task name, but also
         /// the set of identity parameters
@@ -1278,9 +1253,10 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody
             internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile, IDictionary<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)
             {
                 // Keep a cache of task identities which have been checked against the factory, this is useful because we ask this question everytime we get a registered task record or a taskFactory wrapper.
+
                 if (_taskNamesCreatableByFactory == null)
                 {
-                    _taskNamesCreatableByFactory = new ConcurrentDictionary<RegisteredTaskIdentity, object>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
+                    Interlocked.CompareExchange(ref _taskNamesCreatableByFactory, new ConcurrentDictionary<RegisteredTaskIdentity, object>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact), null);
                 }
 
                 RegisteredTaskIdentity taskIdentity = new RegisteredTaskIdentity(taskName, taskIdentityParameters);
@@ -1849,20 +1825,17 @@ internal static RegisteredTaskRecord FactoryForDeserialization(ITranslator trans
 
         public void Translate(ITranslator translator)
         {
-            lock (lockObject)
-            {
-                translator.Translate(ref _toolset, Toolset.FactoryForDeserialization);
-                translator.Translate(ref _nextRegistrationOrderId);
-                IDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> copy = _taskRegistrations;
-                translator.TranslateDictionary(ref copy, TranslateTaskRegistrationKey, TranslateTaskRegistrationValue, count => CreateRegisteredTaskDictionary(count));
+            translator.Translate(ref _toolset, Toolset.FactoryForDeserialization);
+            translator.Translate(ref _nextRegistrationOrderId);
+            IDictionary<RegisteredTaskIdentity, ConcurrentBag<RegisteredTaskRecord>> copy = _taskRegistrations;
+            translator.TranslateDictionary(ref copy, TranslateTaskRegistrationKey, TranslateTaskRegistrationValue, count => CreateRegisteredTaskDictionary(count));
 
-                if (translator.Mode == TranslationDirection.ReadFromStream)
-                {
-                    _taskRegistrations = (ConcurrentDictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>>)copy;
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                _taskRegistrations = (ConcurrentDictionary<RegisteredTaskIdentity, ConcurrentBag<RegisteredTaskRecord>>)copy;
 #if DEBUG
-                    _isInitialized = _taskRegistrations != null;
+                _isInitialized = _taskRegistrations != null;
 #endif
-                }
             }
         }
 
@@ -1873,9 +1846,12 @@ private void TranslateTaskRegistrationKey(ITranslator translator, ref Registered
         }
 
         // todo make nested after C# 7
-        private void TranslateTaskRegistrationValue(ITranslator translator, ref List<RegisteredTaskRecord> taskRecords)
+        private void TranslateTaskRegistrationValue(ITranslator translator, ref ConcurrentBag<RegisteredTaskRecord> taskRecords)
         {
-            translator.Translate(ref taskRecords, RegisteredTaskRecord.FactoryForDeserialization);
+            List<RegisteredTaskRecord> recordsList = taskRecords.ToList();
+            translator.Translate(ref recordsList, RegisteredTaskRecord.FactoryForDeserialization);
+
+            taskRecords = new ConcurrentBag<RegisteredTaskRecord>(recordsList);
         }
 
         public static TaskRegistry FactoryForDeserialization(ITranslator translator)
diff --git a/src/Build/Resources/AssemblyResources.cs b/src/Build/Resources/AssemblyResources.cs
index 29a5f239bf6..9d21ceb26ed 100644
--- a/src/Build/Resources/AssemblyResources.cs
+++ b/src/Build/Resources/AssemblyResources.cs
@@ -20,7 +20,8 @@ internal static class AssemblyResources
         /// </summary>
         private static ResourceManager s_msbuildExeResourceManager;
 
-        private static ConcurrentDictionary<string, string> resourceCache = new();
+        private static ConcurrentDictionary<string, string> engineResourceCache = new();
+        private static ConcurrentDictionary<string, string> msbuildExeResourceCache = new();
 
         /// <summary>
         /// The internals of the Engine are exposed to MSBuild.exe, so they must share the same AssemblyResources class and
@@ -78,21 +79,20 @@ internal static string GetStringLookingInMSBuildExeResourcesFirst(string name)
         /// <returns>The resource string, or null if not found.</returns>
         private static string GetStringFromEngineResources(string name)
         {
-            if (resourceCache.TryGetValue(name, out string resource))
+            string resource = engineResourceCache.GetOrAdd(name, static key =>
             {
-                return resource;
-            }
-
-            resource = s_resources.GetString(name, CultureInfo.CurrentUICulture);
+                CultureInfo currentUICulture = CultureInfo.CurrentUICulture;
+                string retrievedResource = s_resources.GetString(key, currentUICulture);
 
-            if (resource == null)
-            {
-                resource = s_sharedResources.GetString(name, CultureInfo.CurrentUICulture);
-            }
+                if (retrievedResource == null)
+                {
+                    retrievedResource = s_sharedResources.GetString(key, currentUICulture);
+                }
 
-            ErrorUtilities.VerifyThrow(resource != null, "Missing resource '{0}'", name);
+                ErrorUtilities.VerifyThrow(retrievedResource != null, $"Missing resource '{key}'");
 
-            resourceCache[name] = resource;
+                return retrievedResource;
+            });
 
             return resource;
         }
@@ -108,7 +108,7 @@ private static string GetStringFromMSBuildExeResources(string name)
             if (s_msbuildExeResourceManager != null)
             {
                 // Try MSBuild.exe's resources
-                resource = s_msbuildExeResourceManager.GetString(name, CultureInfo.CurrentUICulture);
+                msbuildExeResourceCache.GetOrAdd(name, static key => s_msbuildExeResourceManager.GetString(key, CultureInfo.CurrentUICulture));
             }
 
             return resource;
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index c302b537038..34c757aaef0 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -1054,6 +1054,29 @@ public void Translate<T>(ref List<T> list, ObjectTranslator<T> objectTranslator)
                 }
             }
 
+            /// <summary>
+            /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
+            /// </summary>
+            /// <param name="list">The list to be translated.</param>
+            /// <param name="objectTranslator">The translator to use for the items in the list</param>
+            /// <typeparam name="T">A TaskItemType</typeparam>
+            public void Translate<T>(ref IReadOnlyCollection<T> list, ObjectTranslator<T> objectTranslator)
+            {
+                if (!TranslateNullable(list))
+                {
+                    return;
+                }
+
+                int count = list.Count;
+                _writer.Write(count);
+
+                foreach (T value in list)
+                {
+                    T loopValue = value;
+                    objectTranslator(this, ref loopValue);
+                }
+            }
+
             /// <summary>
             /// Translates a list of T using an <see cref="ObjectTranslator{T}"/>
             /// </summary>
diff --git a/src/Utilities/AssemblyResources.cs b/src/Utilities/AssemblyResources.cs
index 3258aecf36d..fe14bdf89ba 100644
--- a/src/Utilities/AssemblyResources.cs
+++ b/src/Utilities/AssemblyResources.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Collections.Concurrent;
 using System.Globalization;
 using System.Reflection;
 using System.Resources;
@@ -14,6 +15,7 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal static class AssemblyResources
     {
+        private static readonly ConcurrentDictionary<string, string> s_resourceStrings = new ConcurrentDictionary<string, string>();
         /// <summary>
         /// Loads the specified resource string, either from the assembly's primary resources, or its shared resources.
         /// </summary>
@@ -22,12 +24,16 @@ internal static class AssemblyResources
         /// <returns>The resource string, or null if not found.</returns>
         internal static string GetString(string name)
         {
-            string resource = PrimaryResources.GetString(name, CultureInfo.CurrentUICulture)
-                ?? SharedResources.GetString(name, CultureInfo.CurrentUICulture);
+            return s_resourceStrings.GetOrAdd(name, static key =>
+            {
+                CultureInfo currentUICulture = CultureInfo.CurrentUICulture;
+                string resource = PrimaryResources.GetString(key, currentUICulture)
+                    ?? SharedResources.GetString(key, currentUICulture);
 
-            ErrorUtilities.VerifyThrow(resource != null, "Missing resource '{0}'", name);
+                ErrorUtilities.VerifyThrow(resource != null, "Missing resource '{0}'", key);
 
-            return resource;
+                return resource;
+            });
         }
 
         /// <summary>
