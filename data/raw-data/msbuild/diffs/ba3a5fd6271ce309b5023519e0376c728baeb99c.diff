diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index 1d787f19f91..1a95d65d2bb 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -57,8 +57,6 @@ internal class MockHost : MockLoggingService, IBuildComponentHost, IBuildCompone
         /// </summary>
         private LegacyThreadingData _legacyThreadingData;
 
-        private ISdkResolverService _sdkResolverService;
-
         #region SystemParameterFields
 
         #endregion;
@@ -100,8 +98,8 @@ public MockHost(BuildParameters buildParameters)
             _targetBuilder = new TestTargetBuilder();
             ((IBuildComponent)_targetBuilder).InitializeComponent(this);
 
-            _sdkResolverService = new MockSdkResolverService();
-            ((IBuildComponent)_sdkResolverService).InitializeComponent(this);
+            SdkResolverService = new MockSdkResolverService();
+            ((IBuildComponent)SdkResolverService).InitializeComponent(this);
         }
 
         /// <summary>
@@ -113,6 +111,8 @@ public ILoggingService LoggingService
             internal set { _loggingService = value; }
         }
 
+        public ISdkResolverService SdkResolverService { get; }
+
         /// <summary>
         /// Retrieves the name of the host.
         /// </summary>
@@ -169,7 +169,7 @@ public IBuildComponent GetComponent(BuildComponentType type)
                 BuildComponentType.TargetBuilder => (IBuildComponent)_targetBuilder,
                 BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
                 BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
-                BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                BuildComponentType.SdkResolverService => (IBuildComponent)SdkResolverService,
                 _ => throw new ArgumentException("Unexpected type " + type),
             };
         }
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 6791d729dd8..c252a7efb5c 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Shared;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 using Xunit;
+using Microsoft.Build.BackEnd.SdkResolution;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -45,6 +46,14 @@ public ILoggingService LoggingService
                 }
             }
 
+            public ISdkResolverService SdkResolverService
+            {
+                get
+                {
+                    throw new NotImplementedException();
+                }
+            }
+
             /// <summary>
             /// Retrieves the LegacyThreadingData associated with a particular component host
             /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index cbfd97c5f83..138e88862c5 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -39,11 +39,11 @@ public SdkResolverService_Tests()
         [Fact]
         public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
         {
-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(new MockLoaderStrategy());
 
             SdkReference sdk = new SdkReference("notfound", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeFalse();
             result.ShouldNotBeNull();
@@ -63,8 +63,8 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
         {
             var sdk = new SdkReference("foo", "1.0.0", null);
 
-            SdkResolverService.Instance.InitializeForTests(
-                null,
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(
+                resolverLoader: null,
                 new List<SdkResolver>
                 {
                     new SdkUtilities.ConfigurableMockSdkResolver(
@@ -76,7 +76,7 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
                             ))
                 });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Path.ShouldBe("path");
 
@@ -87,12 +87,12 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
         [Fact]
         public void AssertResolverThrows()
         {
-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy(includeErrorResolver: true));
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(new MockLoaderStrategy(includeErrorResolver: true));
 
             SdkReference sdk = new SdkReference("1sdkName", "version1", "minimumVersion");
 
             // When an SDK resolver throws, the expander will catch it and stop the build.
-            SdkResolverException e = Should.Throw<SdkResolverException>(() => SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false));
+            SdkResolverException e = Should.Throw<SdkResolverException>(() => sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false));
             e.Resolver.Name.ShouldBe("MockSdkResolverThrows");
             e.Sdk.Name.ShouldBe("1sdkName");
         }
@@ -100,11 +100,11 @@ public void AssertResolverThrows()
         [Fact]
         public void AssertFirstResolverCanResolve()
         {
-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(new MockLoaderStrategy());
 
             SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Path.ShouldBe("resolverpath1");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
@@ -113,13 +113,13 @@ public void AssertFirstResolverCanResolve()
         [Fact]
         public void AssertFirstResolverErrorsSupressedWhenResolved()
         {
-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(new MockLoaderStrategy());
 
             // 2sdkName will cause MockSdkResolver1 to fail with an error reason. The error will not
             // be logged because MockSdkResolver2 will succeed.
             SdkReference sdk = new SdkReference("2sdkName", "version2", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Path.ShouldBe("resolverpath2");
 
@@ -137,15 +137,13 @@ public void AssertResolverHasStatePreserved()
         {
             const int submissionId = 5;
 
-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
-
-            SdkReference sdk = new SdkReference("othersdk", "1.0", "minimumVersion");
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(new MockLoaderStrategy());
 
             // First call should not know state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
+            sdkResolverService.ResolveSdk(submissionId, new SdkReference("sdk1", "1.0", "minimumVersion"), _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
 
             // Second call should have received state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe(MockSdkResolverWithState.Expected);
+            sdkResolverService.ResolveSdk(submissionId, new SdkReference("sdk2", "1.0", "minimumVersion"), _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe(MockSdkResolverWithState.Expected);
         }
 
         [Fact]
@@ -153,15 +151,15 @@ public void AssertResolverStateNotPreserved()
         {
             const int submissionId = BuildEventContext.InvalidSubmissionId;
 
-            SdkResolverService.Instance.InitializeForTests(new MockLoaderStrategy());
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(new MockLoaderStrategy());
 
             SdkReference sdk = new SdkReference("othersdk", "1.0", "minimumVersion");
 
             // First call should not know state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
+            sdkResolverService.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
 
             // Second call should have received state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
+            sdkResolverService.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
         }
 
         [Theory]
@@ -194,9 +192,8 @@ public void CachingWrapperShouldWarnWhenMultipleVersionsAreReferenced()
                     Enumerable.Empty<string>()
                     ));
 
-            var service = new CachingSdkResolverService();
-            service.InitializeForTests(
-                null,
+            var service = SdkResolverService.CreateForUnitTests(
+                resolverLoader: null,
                 new List<SdkResolver>
                 {
                     resolver
@@ -282,9 +279,14 @@ public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
                     warnings: null
                     ));
 
-            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(
+                resolverLoader: null,
+                new List<SdkResolver>
+                {
+                    resolver
+                });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeTrue();
             result.Path.ShouldBeNull();
@@ -319,9 +321,14 @@ public void SdkResultCanReturnPropertiesAndItems()
                     warnings: null
                     ));
 
-            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(
+                resolverLoader: null,
+                new List<SdkResolver>
+                {
+                    resolver
+                });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeTrue();
             result.Path.ShouldBe(expectedPath);
@@ -366,9 +373,14 @@ public void SdkResultCanReturnMultiplePaths(bool includePropertiesAndItems)
                     warnings: null
                     ));
 
-            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(
+                resolverLoader: null,
+                new List<SdkResolver>
+                {
+                    resolver
+                });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeTrue();
 
@@ -412,9 +424,14 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
                     warnings: null
                     ));
 
-            SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(
+                resolverLoader: null,
+                new List<SdkResolver>
+                {
+                    resolver
+                });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
 
             result.Success.ShouldBeTrue();
 
@@ -450,9 +467,8 @@ public void CachingWrapperShouldOnlyResolveOnce()
                     Enumerable.Empty<string>()
                 ));
 
-            var service = new CachingSdkResolverService();
-            service.InitializeForTests(
-                null,
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(
+                resolverLoader: null,
                 new List<SdkResolver>
                 {
                     resolver
@@ -462,7 +478,7 @@ public void CachingWrapperShouldOnlyResolveOnce()
             Parallel.For(
                 0,
                 10,
-                _ => service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false));
+                _ => sdkResolverService.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false));
 
             var result = resolver.ResolvedCalls.ShouldHaveSingleItem();
 
@@ -478,9 +494,7 @@ public void InteractiveIsSetForResolverContext()
             // Start with interactive false
             bool interactive = false;
 
-            var service = new CachingSdkResolverService();
-
-            service.InitializeForTests(
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(
                 resolvers: new List<SdkResolver>
                 {
                     new SdkUtilities.ConfigurableMockSdkResolver((sdkRference, resolverContext, factory) =>
@@ -491,7 +505,8 @@ public void InteractiveIsSetForResolverContext()
                     })
                 });
 
-            service.ResolveSdk(
+
+            sdkResolverService.ResolveSdk(
                 BuildEventContext.InvalidSubmissionId,
                 new SdkReference("foo", "1.0.0", null),
                 _loggingContext,
@@ -510,8 +525,7 @@ public void IsRunningInVisualStudioIsSetForResolverContext()
         {
             bool isRunningInVisualStudio = false;
 
-            var service = new CachingSdkResolverService();
-            service.InitializeForTests(
+            var sdkResolverService = SdkResolverService.CreateForUnitTests(
                 resolvers: new List<SdkResolver>
                 {
                     new SdkUtilities.ConfigurableMockSdkResolver((sdkRference, resolverContext, factory) =>
@@ -521,7 +535,7 @@ public void IsRunningInVisualStudioIsSetForResolverContext()
                     })
                 });
 
-            var result = service.ResolveSdk(
+            var result = sdkResolverService.ResolveSdk(
                 BuildEventContext.InvalidSubmissionId,
                 new SdkReference("foo", "1.0.0", null),
                 _loggingContext,
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
index 562ac26f280..ada62f6c47c 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -258,16 +258,20 @@ private SdkResolver SetupSdkResolver(string projectFolder)
 
             EvaluationContext.TestOnlyHookOnCreate = context =>
             {
-                var sdkService = (SdkResolverService)context.SdkResolverService;
-
-                sdkService.InitializeForTests(null, new List<SdkResolver> { sdkResolver });
+                context.SdkResolverService = SdkResolverService.CreateForUnitTests(
+                    resolvers: new List<SdkResolver>
+                    {
+                        sdkResolver
+                    });
             };
 
             ((IBuildComponentHost)_buildManager).RegisterFactory(BuildComponentType.SdkResolverService, type =>
             {
-                var resolverService = new MainNodeSdkResolverService();
-                resolverService.InitializeForTests(null, new List<SdkResolver> { sdkResolver });
-                return resolverService;
+                return SdkResolverService.CreateForUnitTests(
+                    resolvers: new List<SdkResolver>
+                    {
+                        sdkResolver
+                    });
             });
 
             return sdkResolver;
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 62674749d33..9172df71503 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -1703,8 +1703,6 @@ private class MockHost : MockLoggingService, IBuildComponentHost, IBuildComponen
             /// </summary>
             private LegacyThreadingData _legacyThreadingData;
 
-            private ISdkResolverService _sdkResolverService;
-
             /// <summary>
             /// Constructor
             /// </summary>
@@ -1730,8 +1728,8 @@ public MockHost()
                 _targetBuilder = new TargetBuilder();
                 ((IBuildComponent)_targetBuilder).InitializeComponent(this);
 
-                _sdkResolverService = new MockSdkResolverService();
-                ((IBuildComponent)_sdkResolverService).InitializeComponent(this);
+                SdkResolverService = new MockSdkResolverService();
+                ((IBuildComponent)SdkResolverService).InitializeComponent(this);
             }
 
             /// <summary>
@@ -1779,6 +1777,9 @@ public BuildParameters BuildParameters
                 }
             }
 
+            /// <inheritdoc cref="IBuildComponentHost.SdkResolverService" />
+            public ISdkResolverService SdkResolverService { get; }
+
             /// <summary>
             /// Constructs and returns a component of the specified type.
             /// </summary>
@@ -1794,7 +1795,7 @@ public IBuildComponent GetComponent(BuildComponentType type)
                     BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
                     BuildComponentType.TaskBuilder => (IBuildComponent)_taskBuilder,
                     BuildComponentType.TargetBuilder => (IBuildComponent)_targetBuilder,
-                    BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                    BuildComponentType.SdkResolverService => (IBuildComponent)SdkResolverService,
                     _ => throw new ArgumentException("Unexpected type " + type),
                 };
             }
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 3446700cae3..a2af9655a04 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -1235,8 +1235,6 @@ private class MockHost : MockLoggingService, IBuildComponentHost, IBuildComponen
             /// </summary>
             private LegacyThreadingData _legacyThreadingData;
 
-            private ISdkResolverService _sdkResolverService;
-
             /// <summary>
             /// Constructor
             /// </summary>
@@ -1259,8 +1257,8 @@ public MockHost()
                 _taskBuilder = new MockTaskBuilder();
                 ((IBuildComponent)_taskBuilder).InitializeComponent(this);
 
-                _sdkResolverService = new MockSdkResolverService();
-                ((IBuildComponent)_sdkResolverService).InitializeComponent(this);
+                SdkResolverService = new MockSdkResolverService();
+                ((IBuildComponent)SdkResolverService).InitializeComponent(this);
             }
 
             /// <summary>
@@ -1308,6 +1306,9 @@ public BuildParameters BuildParameters
                 }
             }
 
+            /// <inheritdoc cref="IBuildComponentHost.SdkResolverService" />
+            public ISdkResolverService SdkResolverService { get; }
+
             /// <summary>
             /// Gets the component of the specified type.
             /// </summary>
@@ -1322,7 +1323,7 @@ public IBuildComponent GetComponent(BuildComponentType type)
                     BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
                     BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
                     BuildComponentType.TaskBuilder => (IBuildComponent)_taskBuilder,
-                    BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                    BuildComponentType.SdkResolverService => (IBuildComponent)SdkResolverService,
                     _ => throw new ArgumentException("Unexpected type " + type),
                 };
             }
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 7ba76a5b89d..d8b5c6f1b42 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -1181,8 +1181,6 @@ private class MockHost : MockLoggingService, IBuildComponentHost, IBuildComponen
             /// </summary>
             private LegacyThreadingData _legacyThreadingData;
 
-            private ISdkResolverService _sdkResolverService;
-
             /// <summary>
             /// Constructor
             ///
@@ -1208,8 +1206,8 @@ public MockHost()
                 _targetBuilder = new TargetBuilder();
                 ((IBuildComponent)_targetBuilder).InitializeComponent(this);
 
-                _sdkResolverService = new MockSdkResolverService();
-                ((IBuildComponent)_sdkResolverService).InitializeComponent(this);
+                SdkResolverService = new MockSdkResolverService();
+                ((IBuildComponent)SdkResolverService).InitializeComponent(this);
             }
 
             /// <summary>
@@ -1256,6 +1254,9 @@ LegacyThreadingData IBuildComponentHost.LegacyThreadingData
                 }
             }
 
+            /// <inheritdoc cref="IBuildComponentHost.SdkResolverService" />
+            public ISdkResolverService SdkResolverService { get; }
+
             /// <summary>
             /// Constructs and returns a component of the specified type.
             /// </summary>
@@ -1270,7 +1271,7 @@ public IBuildComponent GetComponent(BuildComponentType type)
                     BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
                     BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
                     BuildComponentType.TargetBuilder => (IBuildComponent)_targetBuilder,
-                    BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
+                    BuildComponentType.SdkResolverService => (IBuildComponent)SdkResolverService,
                     _ => throw new ArgumentException("Unexpected type " + type),
                 };
             }
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 4605aa5827e..f6d0a1e2f3d 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -47,9 +47,11 @@ public void Dispose()
 
         private static void SetResolverForContext(EvaluationContext context, SdkResolver resolver)
         {
-            var sdkService = (SdkResolverService) context.SdkResolverService;
-
-            sdkService.InitializeForTests(null, new List<SdkResolver> {resolver});
+            context.SdkResolverService = SdkResolverService.CreateForUnitTests(
+                resolvers: new List<SdkResolver>
+                {
+                    resolver
+                });
         }
 
         [Theory]
diff --git a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
index a25dec785b1..5c69781b4e4 100644
--- a/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectSdkImplicitImport_Tests.cs
@@ -20,6 +20,7 @@
 using SdkResult = Microsoft.Build.Framework.SdkResult;
 using SdkResultFactory = Microsoft.Build.Framework.SdkResultFactory;
 using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
+using Microsoft.Build.BackEnd.SdkResolution;
 
 namespace Microsoft.Build.UnitTests.OM.Construction
 {
@@ -89,6 +90,9 @@ public ProjectSdkImplicitImport_Tests()
             _sdkTargetsPath = Path.Combine(_testSdkDirectory, "Sdk.targets");
 
             Directory.CreateDirectory(_testSdkDirectory);
+
+            // Disable SDK resolver result cache since the tests in this class re-use the same SDK name in a different location
+            SdkResolverService.Instance.DisableResultCacheForUnitTests();
         }
 
         [Theory]
diff --git a/src/Build.UnitTests/InternalEngineHelpers.cs b/src/Build.UnitTests/InternalEngineHelpers.cs
index aa0ae0c34be..5160b0e619f 100644
--- a/src/Build.UnitTests/InternalEngineHelpers.cs
+++ b/src/Build.UnitTests/InternalEngineHelpers.cs
@@ -25,8 +25,12 @@ internal static class SdkUtilities
         public static ProjectOptions CreateProjectOptionsWithResolver(SdkResolver resolver)
         {
             var context = EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated);
-            var sdkService = (SdkResolverService)context.SdkResolverService;
-            sdkService.InitializeForTests(null, new List<SdkResolver>() { resolver });
+            
+            context.SdkResolverService = SdkResolverService.CreateForUnitTests(
+                resolvers: new List<SdkResolver>
+                {
+                    resolver
+                });
 
             return new ProjectOptions
             {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index d1a29b8abaf..3a5593114f5 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -347,9 +347,9 @@ public static BuildManager DefaultBuildManager
         }
 
         /// <summary>
-        /// Retrieves a hosted<see cref="ISdkResolverService"/> instance for resolving SDKs.
+        /// Retrieves a hosted <see cref="ISdkResolverService"/> instance for resolving SDKs.
         /// </summary>
-        private ISdkResolverService SdkResolverService => (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
+        ISdkResolverService IBuildComponentHost.SdkResolverService => (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
 
         /// <summary>
         /// Retrieves the logging service associated with a particular build
@@ -465,7 +465,7 @@ public void BeginBuild(BuildParameters parameters)
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse, BuildRequestConfigurationResponse.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildResult, BuildResult.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.NodeShutdown, NodeShutdown.FactoryForDeserialization, this);
-                _nodeManager.RegisterPacketHandler(NodePacketType.ResolveSdkRequest, SdkResolverRequest.FactoryForDeserialization, SdkResolverService as INodePacketHandler);
+                _nodeManager.RegisterPacketHandler(NodePacketType.ResolveSdkRequest, SdkResolverRequest.FactoryForDeserialization, ((IBuildComponentHost)this).SdkResolverService as INodePacketHandler);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResourceRequest, ResourceRequest.FactoryForDeserialization, this);
 
                 if (_threadException != null)
@@ -1377,7 +1377,7 @@ private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bui
                 request.BuildEventContext,
                 false /* loaded by solution parser*/,
                 config.TargetNames,
-                SdkResolverService,
+                ((IBuildComponentHost)this).SdkResolverService,
                 request.SubmissionId);
 
             // The first instance is the traversal project, which goes into this configuration
@@ -1812,7 +1812,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                                     BuildEventContext.InvalidProjectContextId,
                                     BuildEventContext.InvalidTargetId,
                                     BuildEventContext.InvalidTaskId),
-                                SdkResolverService,
+                                ((IBuildComponentHost)this).SdkResolverService,
                                 submission.SubmissionId,
                                 projectLoadSettings);
                         });
@@ -2727,7 +2727,7 @@ private void CheckSubmissionCompletenessAndRemove(BuildSubmission submission)
                     _buildSubmissions.Remove(submission.SubmissionId);
 
                     // Clear all cached SDKs for the submission
-                    SdkResolverService.ClearCache(submission.SubmissionId);
+                    ((IBuildComponentHost)this).SdkResolverService.ClearCache(submission.SubmissionId);
                 }
 
                 CheckAllSubmissionsComplete(submission.BuildRequestData?.Flags);
@@ -2747,7 +2747,7 @@ private void CheckSubmissionCompletenessAndRemove(GraphBuildSubmission submissio
                     _graphBuildSubmissions.Remove(submission.SubmissionId);
 
                     // Clear all cached SDKs for the submission
-                    SdkResolverService.ClearCache(submission.SubmissionId);
+                    ((IBuildComponentHost)this).SdkResolverService.ClearCache(submission.SubmissionId);
                 }
 
                 CheckAllSubmissionsComplete(submission.BuildRequestData?.Flags);
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index 05ea23f5425..27a5a176e0b 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -77,7 +77,7 @@ public void RegisterDefaultFactories()
             _componentEntriesByType[BuildComponentType.RegisteredTaskObjectCache] = new BuildComponentEntry(BuildComponentType.RegisteredTaskObjectCache, RegisteredTaskObjectCache.CreateComponent, CreationPattern.Singleton);
 
             // SDK resolution
-            _componentEntriesByType[BuildComponentType.SdkResolverService] = new BuildComponentEntry(BuildComponentType.SdkResolverService, MainNodeSdkResolverService.CreateComponent, CreationPattern.Singleton);
+            _componentEntriesByType[BuildComponentType.SdkResolverService] = new BuildComponentEntry(BuildComponentType.SdkResolverService, SdkResolverService.CreateComponent, CreationPattern.Singleton);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 4e57c5f2ae1..ded1efbdd38 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -4,6 +4,7 @@
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
 using BuildParameters = Microsoft.Build.Execution.BuildParameters;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
+using ISdkResolverService = Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -157,6 +158,11 @@ internal interface IBuildComponentHost
         /// </summary>
         ILoggingService LoggingService { get; }
 
+        /// <summary>
+        /// Retrieves an <see cref="ISdkResolverService" /> to use for resolving MSBuild project SDKs.
+        /// </summary>
+        ISdkResolverService SdkResolverService { get; }
+
         /// <summary>
         /// Registers a factory which will be used to create the necessary components of the build
         /// system.
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
deleted file mode 100644
index 23c505ff896..00000000000
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ /dev/null
@@ -1,79 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Concurrent;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Eventing;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
-
-namespace Microsoft.Build.BackEnd.SdkResolution
-{
-    internal sealed class CachingSdkResolverService: SdkResolverService
-    {
-        /// <summary>
-        /// Stores the cache in a set of concurrent dictionaries.  The main dictionary is by build submission ID and the inner dictionary contains a case-insensitive SDK name and the cached <see cref="SdkResult"/>.
-        /// </summary>
-        private readonly ConcurrentDictionary<int, ConcurrentDictionary<string, Lazy<SdkResult>>> _cache = new ConcurrentDictionary<int, ConcurrentDictionary<string, Lazy<SdkResult>>>();
-
-        public override void ClearCache(int submissionId)
-        {
-            base.ClearCache(submissionId);
-
-            _cache.TryRemove(submissionId, out _);
-        }
-
-        public override void ClearCaches()
-        {
-            base.ClearCaches();
-
-            _cache.Clear();
-        }
-
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
-        {
-            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath, projectPath);
-
-            SdkResult result;
-
-            if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
-            {
-                result = base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
-            }
-            else
-            {
-                // Get the dictionary for the specified submission if one is already added otherwise create a new dictionary for the submission.
-                ConcurrentDictionary<string, Lazy<SdkResult>> cached = _cache.GetOrAdd(
-                    submissionId,
-                    _ => new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default));
-
-                /*
-                 * Get a Lazy<SdkResult> if available, otherwise create a Lazy<SdkResult> which will resolve the SDK with the SdkResolverService.Instance.  If multiple projects are attempting to resolve
-                 * the same SDK, they will all get back the same Lazy<SdkResult> which ensures that a single build submission resolves each unique SDK only one time.
-                 */
-                Lazy<SdkResult> resultLazy = cached.GetOrAdd(
-                    sdk.Name,
-                    key => new Lazy<SdkResult>(() => base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio)));
-
-                // Get the lazy value which will block all waiting threads until the SDK is resolved at least once while subsequent calls get cached results.
-                result = resultLazy.Value;
-            }
-
-            if (result != null &&
-                !SdkResolverService.IsReferenceSameVersion(sdk, result.SdkReference.Version) &&
-                !SdkResolverService.IsReferenceSameVersion(sdk, result.Version))
-            {
-                // MSB4240: Multiple versions of the same SDK "{0}" cannot be specified. The previously resolved SDK version "{1}" from location "{2}" will be used and the version "{3}" will be ignored.
-                loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, result.Version, result.ElementLocation, sdk.Version);
-            }
-
-            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath, projectPath, result.Success);
-
-            return result;
-        }
-    }
-}
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
deleted file mode 100644
index d0ba73f4f8d..00000000000
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ /dev/null
@@ -1,223 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using Microsoft.Build.BackEnd.Components.Logging;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using System;
-using System.Collections.Concurrent;
-using System.Collections.Generic;
-using System.Threading;
-using System.Threading.Tasks;
-
-namespace Microsoft.Build.BackEnd.SdkResolution
-{
-    /// <summary>
-    /// An implementation of <see cref="ISdkResolverService"/> that is hosted in the main node for multi-proc builds.  This instance of the service
-    /// listens for requests from out-of-proc nodes so that SDK resolution is handled in a central location.  This instance is registered in <see cref="BuildComponentFactoryCollection.RegisterDefaultFactories"/>
-    /// and can be overridden for different contexts.  This service calls the <see cref="SdkResolverService"/> to do any actual SDK resolution
-    /// because the <see cref="SdkResolverService"/> is used for stand-alone evaluations where there is no build context available so caching
-    /// is not an option.
-    ///
-    /// Since this object is a registered <see cref="IBuildComponent"/>, it is a singleton for the main process.  To get an instance of it, you
-    /// must have access to an <see cref="IBuildComponentHost"/> and call <see cref="IBuildComponentHost.GetComponent"/> and pass <see cref="BuildComponentType.SdkResolverService"/>.
-    /// </summary>
-    internal sealed class MainNodeSdkResolverService : HostedSdkResolverServiceBase
-    {
-        /// <summary>
-        /// An object used for locking in this class instance.
-        /// </summary>
-        private readonly object _lockObject = new object();
-
-        /// <summary>
-        /// A <see cref="Task"/> running in the background which handles requests from remote nodes.
-        /// </summary>
-        private Task _requestHandler;
-
-        /// <summary>
-        /// An event which is signaled when a request is received from a remote host.
-        /// </summary>
-        private ManualResetEvent _requestReceivedEvent;
-
-        /// <summary>
-        /// A list of requests from remote hosts which need to be processed.
-        /// </summary>
-        private ConcurrentQueue<SdkResolverRequest> _requests;
-
-        private readonly ISdkResolverService _cachedSdkResolver = new CachingSdkResolverService();
-
-        /// <summary>
-        /// A factory which is registered to create an instance of this class.
-        /// </summary>
-        public static IBuildComponent CreateComponent(BuildComponentType type)
-        {
-            return new MainNodeSdkResolverService();
-        }
-
-        //  Test hook
-        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<SdkResolver> resolvers = null)
-        {
-            ((CachingSdkResolverService)_cachedSdkResolver).InitializeForTests(resolverLoader, resolvers);
-        }
-
-        /// <inheritdoc cref="ISdkResolverService.ClearCache"/>
-        public override void ClearCache(int submissionId)
-        {
-            _cachedSdkResolver.ClearCache(submissionId);
-        }
-
-        public override void ClearCaches()
-        {
-            _cachedSdkResolver.ClearCaches();
-        }
-
-        /// <inheritdoc cref="INodePacketHandler.PacketReceived"/>
-        public override void PacketReceived(int node, INodePacket packet)
-        {
-            switch (packet.Type)
-            {
-                case NodePacketType.ResolveSdkRequest:
-                    HandleRequest(node, packet as SdkResolverRequest);
-                    break;
-            }
-        }
-
-        /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
-        {
-            ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));
-            ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));
-            ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));
-            ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));
-
-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
-        }
-
-        /// <summary>
-        /// Handles a request from a remote node.
-        /// </summary>
-        /// <param name="node">The ID of the remote node.</param>
-        /// <param name="request">The <see cref="SdkResolverRequest"/> containing information about the SDK to resolve.</param>
-        /// <remarks>This method must not directly handle requests because it would block requests from other nodes.  Instead, it simply
-        /// adds requests to a queue which are processed by a background thread.</remarks>
-        private void HandleRequest(int node, SdkResolverRequest request)
-        {
-            if (_requestHandler == null)
-            {
-                // Start the background thread which will process queued requests if it has not already been started.
-                lock (_lockObject)
-                {
-                    if (_requestHandler == null)
-                    {
-                        // Create the event used to signal that a request was received
-                        _requestReceivedEvent = new ManualResetEvent(initialState: false);
-
-                        // Create the queue used to store requests that need to be processed
-                        _requests = new ConcurrentQueue<SdkResolverRequest>();
-
-                        // Create the thread which processes requests
-                        _requestHandler = Task.Factory.StartNew(RequestHandlerPumpProc, TaskCreationOptions.LongRunning);
-                    }
-                }
-            }
-
-            // Associate the node with the request
-            request.NodeId = node;
-
-            _requests.Enqueue(request);
-
-            // Signal that one or more requests have been received
-            _requestReceivedEvent.Set();
-        }
-
-        /// <summary>
-        /// Processes all requests that are currently in the queue.
-        /// </summary>
-        private void ProcessRequests()
-        {
-            // Store a list of threads which are resolving SDKs
-            List<Task> tasks = new List<Task>(_requests.Count);
-
-            SdkResolverRequest item;
-
-            while (_requests.TryDequeue(out item))
-            {
-                SdkResolverRequest request = item;
-
-                // Start a thread to resolve an SDK and add it to the list of threads
-                tasks.Add(Task.Run(() =>
-                {
-                    SdkResult response = null;
-                    try
-                    {
-                        // Create an SdkReference from the request
-                        SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
-
-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
-
-                        // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
-                        response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);
-                    }
-                    catch (Exception e)
-                    {
-                        ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
-
-                        EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);
-
-                        loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));
-                    }
-                    finally
-                    {
-                        // Get the node manager and send the response back to the node that requested the SDK
-                        INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;
-
-                        nodeManager.SendData(request.NodeId, response);
-                    }
-                }));
-            }
-
-            // Wait for all tasks to complete
-            Task.WaitAll(tasks.ToArray());
-        }
-
-        /// <summary>
-        /// A background thread that waits for requests to be received.
-        /// </summary>
-        private void RequestHandlerPumpProc()
-        {
-            try
-            {
-                Thread.CurrentThread.Name = "MSBuild SDK Resolver";
-
-                while (true)
-                {
-                    WaitHandle[] handles = new WaitHandle[] { ShutdownEvent, _requestReceivedEvent };
-
-                    int waitId = WaitHandle.WaitAny(handles);
-                    switch (waitId)
-                    {
-                        case 0:
-                            return;
-
-                        case 1:
-                            _requestReceivedEvent.Reset();
-
-                            ProcessRequests();
-                            break;
-
-                        default:
-                            ErrorUtilities.ThrowInternalError("waitId {0} out of range.", waitId);
-                            break;
-                    }
-                }
-            }
-            catch (Exception e)
-            {
-                ExceptionHandling.DumpExceptionToFile(e);
-                throw;
-            }
-        }
-    }
-}
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 6ae4a89268e..7f1723248ef 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -26,7 +26,7 @@ internal sealed class OutOfProcNodeSdkResolverService : HostedSdkResolverService
         /// <summary>
         /// The cache of responses which is cleared between builds.
         /// </summary>
-        private readonly ConcurrentDictionary<string, SdkResult> _responseCache = new ConcurrentDictionary<string, SdkResult>(MSBuildNameIgnoreCaseComparer.Default);
+        private readonly ConcurrentDictionary<string, Lazy<SdkResult>> _responseCache = new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
         /// An event to signal when a response has been received.
@@ -52,25 +52,27 @@ public OutOfProcNodeSdkResolverService(Action<INodePacket> sendPacket)
         /// <inheritdoc cref="INodePacketHandler.PacketReceived"/>
         public override void PacketReceived(int node, INodePacket packet)
         {
-            switch (packet.Type)
+            if (packet.Type != NodePacketType.ResolveSdkResponse || packet is not SdkResult response)
             {
-                case NodePacketType.ResolveSdkResponse:
-                    HandleResponse(packet as SdkResult);
-                    break;
+                return;
             }
+
+            // Store the last response so the awaiting thread can use it
+            _lastResponse = response;
+
+            // Signal that a response has been received
+            _responseReceivedEvent.Set();
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
         public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             // Get a cached response if possible, otherwise send the request
-            var sdkResult = _responseCache.GetOrAdd(
+            var resultLazy = _responseCache.GetOrAdd(
                 sdk.Name,
-                key =>
-                {
-                    var result = RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
-                    return result;
-                });
+                key => new Lazy<SdkResult>(() => RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio)));
+
+            var sdkResult = resultLazy.Value;
 
             if (sdkResult.Version != null && !SdkResolverService.IsReferenceSameVersion(sdk, sdkResult.Version))
             {
@@ -90,19 +92,6 @@ public override void ShutdownComponent()
             _responseCache.Clear();
         }
 
-        /// <summary>
-        /// Handles a response from the main node.
-        /// </summary>
-        /// <param name="response"></param>
-        private void HandleResponse(SdkResult response)
-        {
-            // Store the last response so the awaiting thread can use it
-            _lastResponse = response;
-
-            // Signal that a response has been received
-            _responseReceivedEvent.Set();
-        }
-
         private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             // Clear out the last response for good measure
@@ -114,10 +103,13 @@ private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk,
             SendPacket(packet);
 
             // Wait for either the response or a shutdown event.  Either event means this thread should return
-            WaitHandle.WaitAny(new WaitHandle[] {_responseReceivedEvent, ShutdownEvent});
+            WaitHandle.WaitAny(new WaitHandle[] { _responseReceivedEvent, ShutdownEvent });
 
-            // Keep track of the element location of the reference
-            _lastResponse.ElementLocation = sdkReferenceLocation;
+            if (_lastResponse != null)
+            {
+                // Keep track of the element location of the reference
+                _lastResponse.ElementLocation = sdkReferenceLocation;
+            }
 
             // Return the response which was set by another thread.  In the case of shutdown, it should be null.
             return _lastResponse;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index ff98112817b..cfed8c40baa 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -1,17 +1,21 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using System;
-using System.IO;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.IO;
 using System.Reflection;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
@@ -19,12 +23,12 @@ namespace Microsoft.Build.BackEnd.SdkResolution
     /// The main implementation of <see cref="ISdkResolverService"/> which resolves SDKs.  This class is the central location for all SDK resolution and is used
     /// directly by the main node and non-build evaluations and is used indirectly by the out-of-proc node when it sends requests to the main node.
     /// </summary>
-    internal class SdkResolverService : ISdkResolverService
+    internal class SdkResolverService : HostedSdkResolverServiceBase
     {
         /// <summary>
         /// Stores the singleton instance for a particular process.
         /// </summary>
-        private static readonly Lazy<SdkResolverService> InstanceLazy = new Lazy<SdkResolverService>(() => new SdkResolverService(), isThreadSafe: true);
+        private static readonly Lazy<SdkResolverService> InstanceLazy = new Lazy<SdkResolverService>(() => new SdkResolverService());
 
         /// <summary>
         /// A lock object used for this class.
@@ -36,6 +40,13 @@ internal class SdkResolverService : ISdkResolverService
         /// </summary>
         private readonly ConcurrentDictionary<int, ConcurrentDictionary<SdkResolver, object>> _resolverStateBySubmission = new ConcurrentDictionary<int, ConcurrentDictionary<SdkResolver, object>>();
 
+        /// <summary>
+        /// Stores the cache in a set of concurrent dictionaries.  The main dictionary is by build submission ID and the inner dictionary contains a case-insensitive SDK name and the cached <see cref="SdkResult"/>.
+        /// </summary>
+        private readonly ConcurrentDictionary<int, ConcurrentDictionary<string, Lazy<SdkResult>>> _resultCacheBySubmissionId = new ConcurrentDictionary<int, ConcurrentDictionary<string, Lazy<SdkResult>>>();
+
+        private bool _isResultCacheDisabled = Traits.Instance.EscapeHatches.DisableSdkResolutionCache;
+
         /// <summary>
         /// Stores the list of SDK resolvers which were loaded.
         /// </summary>
@@ -46,8 +57,14 @@ internal class SdkResolverService : ISdkResolverService
         /// </summary>
         private SdkResolverLoader _sdkResolverLoader = new SdkResolverLoader();
 
-        public SdkResolverService()
+        private SdkResolverService(SdkResolverLoader resolverLoader = null, IList<SdkResolver> resolvers = null)
         {
+            if (resolverLoader != null)
+            {
+                _sdkResolverLoader = resolverLoader;
+            }
+
+            _resolvers ??= resolvers;
         }
 
         /// <summary>
@@ -55,8 +72,13 @@ public SdkResolverService()
         /// </summary>
         public static SdkResolverService Instance => InstanceLazy.Value;
 
-        /// <inheritdoc cref="ISdkResolverService.SendPacket"/>
-        public Action<INodePacket> SendPacket { get; }
+        /// <summary>
+        /// A factory which is registered to create an instance of this class.
+        /// </summary>
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            return Instance;
+        }
 
         /// <summary>
         /// Determines if the <see cref="SdkReference"/> is the same as the specified version.  If the <paramref name="sdk"/> object has <code>null</code> for the version,
@@ -68,27 +90,191 @@ public SdkResolverService()
         public static bool IsReferenceSameVersion(SdkReference sdk, string version)
         {
             // If the reference has a null version, it matches any result
-            if (String.IsNullOrEmpty(sdk.Version))
+            if (string.IsNullOrEmpty(sdk.Version))
             {
                 return true;
             }
 
-            return String.Equals(sdk.Version, version, StringComparison.OrdinalIgnoreCase);
+            return string.Equals(sdk.Version, version, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <inheritdoc cref="ISdkResolverService.ClearCache"/>
-        public virtual void ClearCache(int submissionId)
+        public override void ClearCache(int submissionId)
         {
             _resolverStateBySubmission.TryRemove(submissionId, out _);
         }
 
-        public virtual void ClearCaches()
+        public override void ClearCaches()
         {
             _resolverStateBySubmission.Clear();
         }
 
+        /// <inheritdoc cref="INodePacketHandler.PacketReceived"/>
+        public override void PacketReceived(int node, INodePacket packet)
+        {
+            if (packet.Type != NodePacketType.ResolveSdkRequest || packet is not SdkResolverRequest request)
+            {
+                return;
+            }
+
+            Task.Run(() => HandleRequest(node, request)).ConfigureAwait(continueOnCapturedContext: false);
+        }
+
+        /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        {
+            SdkResult result;
+
+            if (_isResultCacheDisabled)
+            {
+                result = ResolveSdkWithResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+            }
+            else
+            {
+                // Get the dictionary for the specified submission if one is already added otherwise create a new dictionary for the submission.
+                ConcurrentDictionary<string, Lazy<SdkResult>> cached = _resultCacheBySubmissionId.GetOrAdd(submissionId, new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default));
+
+                /*
+                 * Get a Lazy<SdkResult> if available, otherwise create a Lazy<SdkResult> which will resolve the SDK with the SdkResolverService.Instance.  If multiple projects are attempting to resolve
+                 * the same SDK, they will all get back the same Lazy<SdkResult> which ensures that a single build submission resolves each unique SDK only one time.
+                 */
+                Lazy<SdkResult> resultLazy = cached.GetOrAdd(
+                    sdk.Name,
+                    key => new Lazy<SdkResult>(() =>
+                    {
+                        if (sdk.Name.StartsWith("Test"))
+                        {
+                            System.IO.File.WriteAllText($@"D:\Temp\nugetsdkresolverrepro\Logs\{sdk.Name}-{System.IO.Path.GetFileNameWithoutExtension(sdkReferenceLocation.File)}-msbuild.resolvesdk-[{System.Diagnostics.Process.GetCurrentProcess().Id}]-({submissionId})-{Guid.NewGuid()}", $"submissionId={submissionId}");
+                        }
+
+                        return ResolveSdkWithResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                    }));
+
+                // Get the lazy value which will block all waiting threads until the SDK is resolved at least once while subsequent calls get cached results.
+                result = resultLazy.Value;
+            }
+
+            if (result != null &&
+                !SdkResolverService.IsReferenceSameVersion(sdk, result.SdkReference.Version) &&
+                !SdkResolverService.IsReferenceSameVersion(sdk, result.Version))
+            {
+                // MSB4240: Multiple versions of the same SDK "{0}" cannot be specified. The previously resolved SDK version "{1}" from location "{2}" will be used and the version "{3}" will be ignored.
+                loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, result.Version, result.ElementLocation, sdk.Version);
+            }
+
+            return result;
+        }
+
+        /// <summary>
+        /// UNIT TEST CONSTRUCTOR ONLY
+        /// </summary>
+        /// <param name="resolverLoader">An optional <see cref="SdkResolverLoader" /> to use when loading SDK resolvers.</param>
+        /// <param name="resolvers">An optional <see cref="IList{T}" /> containing <see cref="SdkResolver" /> objects to use to resolver SDKs.</param>
+        internal static SdkResolverService CreateForUnitTests(SdkResolverLoader resolverLoader = null, IList<SdkResolver> resolvers = null)
+        {
+            return new SdkResolverService(resolverLoader, resolvers);
+        }
+
+        /// <summary>
+        /// Disables the result cache for unit tests that are resolving multiple SDKs with the same name in a different location.
+        /// </summary>
+        internal void DisableResultCacheForUnitTests()
+        {
+            _isResultCacheDisabled = true;
+
+            _resultCacheBySubmissionId.Clear();
+        }
+
+        private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, SdkResult result)
+        {
+            if (result.Warnings == null)
+            {
+                return;
+            }
+
+            foreach (string warning in result.Warnings)
+            {
+                loggingContext.LogWarningFromText(null, null, null, new BuildEventFileInfo(location), warning);
+            }
+        }
+
+        private object GetResolverState(int submissionId, SdkResolver resolver)
+        {
+            // Do not fetch state for resolution requests that are not associated with a valid build submission ID
+            if (submissionId != BuildEventContext.InvalidSubmissionId)
+            {
+                ConcurrentDictionary<SdkResolver, object> resolverState;
+
+                if (_resolverStateBySubmission.TryGetValue(submissionId, out resolverState))
+                {
+                    object state;
+
+                    if (resolverState.TryGetValue(resolver, out state))
+                    {
+                        return state;
+                    }
+                }
+            }
+
+            return null;
+        }
+
+        /// <summary>
+        /// Handles a request from a remote node.
+        /// </summary>
+        /// <param name="node">The ID of the remote node.</param>
+        /// <param name="request">The <see cref="SdkResolverRequest"/> containing information about the SDK to resolve.</param>
+        private void HandleRequest(int node, SdkResolverRequest request)
+        {
+            Thread.CurrentThread.Name ??= $"Handle request for SDK {request.Name}/{request.Version} from out-of-proc node {node}";
+
+            request.NodeId = node;
+
+            SdkResult response = null;
+            try
+            {
+                // Create an SdkReference from the request
+                SdkReference sdkReference = new SdkReference(request.Name, request.Version, request.MinimumVersion);
+
+                ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
+
+                // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
+                response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);
+            }
+            catch (Exception e)
+            {
+                ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
+
+                EvaluationLoggingContext loggingContext = new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath);
+
+                loggingService.LogFatalBuildError(loggingContext.BuildEventContext, e, new BuildEventFileInfo(request.ElementLocation));
+            }
+            finally
+            {
+                // Get the node manager and send the response back to the node that requested the SDK
+                INodeManager nodeManager = Host.GetComponent(BuildComponentType.NodeManager) as INodeManager;
+
+                nodeManager.SendData(request.NodeId, response);
+            }
+        }
+
+        private void Initialize(LoggingContext loggingContext, ElementLocation location)
+        {
+            lock (_lockObject)
+            {
+                if (_resolvers != null)
+                {
+                    return;
+                }
+
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStart();
+                _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);
+            }
+        }
+
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        private SdkResult ResolveSdkWithResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
             // Lazy initialize the SDK resolvers
             if (_resolvers == null)
@@ -177,71 +363,6 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
             return new SdkResult(sdk, null, null);
         }
 
-        /// <summary>
-        /// Used for unit tests only.  This is currently only called through reflection in Microsoft.Build.Engine.UnitTests.TransientSdkResolution.CallResetForTests
-        /// </summary>
-        /// <param name="resolverLoader">An <see cref="SdkResolverLoader"/> to use for loading SDK resolvers.</param>
-        /// <param name="resolvers">Explicit set of SdkResolvers to use for all SDK resolution.</param>
-        internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<SdkResolver> resolvers = null)
-        {
-            if (resolverLoader != null)
-            {
-                _sdkResolverLoader = resolverLoader;
-            }
-
-            _resolvers = resolvers;
-        }
-
-        private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, SdkResult result)
-        {
-            if (result.Warnings == null)
-            {
-                return;
-            }
-
-            foreach (string warning in result.Warnings)
-            {
-                loggingContext.LogWarningFromText(null, null, null, new BuildEventFileInfo(location), warning);
-            }
-        }
-
-        private object GetResolverState(int submissionId, SdkResolver resolver)
-        {
-            // Do not fetch state for resolution requests that are not associated with a valid build submission ID
-            if (submissionId != BuildEventContext.InvalidSubmissionId)
-            {
-                ConcurrentDictionary<SdkResolver, object> resolverState;
-
-                if (_resolverStateBySubmission.TryGetValue(submissionId, out resolverState))
-                {
-                    object state;
-
-                    if (resolverState.TryGetValue(resolver, out state))
-                    {
-                        return state;
-                    }
-                }
-            }
-
-            return null;
-        }
-
-        private void Initialize(LoggingContext loggingContext, ElementLocation location)
-        {
-            lock (_lockObject)
-            {
-                if (_resolvers != null)
-                {
-                    return;
-                }
-
-                MSBuildEventSource.Log.SdkResolverServiceInitializeStart();
-                _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);
-                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);
-            }
-
-        }
-
         private void SetResolverState(int submissionId, SdkResolver resolver, object state)
         {
             // Do not set state for resolution requests that are not associated with a valid build submission ID
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index ae59a7b50af..3573d9e326e 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -187,6 +187,11 @@ public OutOfProcNode()
         /// </summary>
         LegacyThreadingData IBuildComponentHost.LegacyThreadingData => _legacyThreadingData;
 
+        /// <summary>
+        /// Gets the <see cref="ISdkResolverService" /> for a build.
+        /// </summary>
+        ISdkResolverService IBuildComponentHost.SdkResolverService => _sdkResolverService;
+
         /// <summary>
         /// Retrieves the name of this component host.
         /// </summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 6d55273c55c..a9efe8c41c5 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -449,9 +449,6 @@ internal void LoadProjectIntoConfiguration(
 
                 string toolsVersionOverride = ExplicitToolsVersionSpecified ? ToolsVersion : null;
 
-                // Get the hosted ISdkResolverService.  This returns either the MainNodeSdkResolverService or the OutOfProcNodeSdkResolverService depending on who created the current RequestBuilder
-                ISdkResolverService sdkResolverService = componentHost.GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
-
                 // Use different project load settings if the build request indicates to do so
                 ProjectLoadSettings projectLoadSettings = componentHost.BuildParameters.ProjectLoadSettings;
 
@@ -478,7 +475,7 @@ internal void LoadProjectIntoConfiguration(
                         BuildEventContext.InvalidProjectContextId,
                         BuildEventContext.InvalidTargetId,
                         BuildEventContext.InvalidTaskId),
-                    sdkResolverService,
+                    componentHost.SdkResolverService,
                     submissionId,
                     projectLoadSettings);
             });
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 19510f6d663..3cf0a73113c 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -40,7 +40,7 @@ public enum SharingPolicy
 
         internal SharingPolicy Policy { get; }
 
-        internal ISdkResolverService SdkResolverService { get; }
+        internal ISdkResolverService SdkResolverService { get; set; }
         internal IFileSystem FileSystem { get; }
         internal FileMatcher FileMatcher { get; }
 
@@ -54,7 +54,7 @@ private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem, ISdkReso
         {
             Policy = policy;
 
-            SdkResolverService = sdkResolverService ?? new CachingSdkResolverService();
+            SdkResolverService = sdkResolverService ?? BackEnd.SdkResolution.SdkResolverService.Instance;
             FileEntryExpansionCache = fileEntryExpansionCache ?? new ConcurrentDictionary<string, IReadOnlyList<string>>();
             FileSystem = fileSystem ?? new CachingFileSystemWrapper(FileSystems.Default);
             FileMatcher = new FileMatcher(FileSystem, FileEntryExpansionCache);
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index cd99bc84721..e33f8679cd1 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -207,12 +207,10 @@
     <Compile Include="BackEnd\Components\SdkResolution\OutOfProcNodeSdkResolverService.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\OutOfProcNodeSdkResolverServiceFactory.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkLogger.cs" />
-    <Compile Include="BackEnd\Components\SdkResolution\CachingSdkResolverService.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverContext.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverLoader.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverManifest.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverRequest.cs" />
-    <Compile Include="BackEnd\Components\SdkResolution\MainNodeSdkResolverService.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverService.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\HostedSdkResolverServiceBase.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResult.cs" />
