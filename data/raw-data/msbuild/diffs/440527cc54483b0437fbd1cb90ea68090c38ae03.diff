diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index 3557170f825..e9a4c04a20f 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -21,7 +21,7 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are
 Notes: 
  * What does the 'N/A' scope mean? The scope of checks are only applicable and configurable in cases where evaluation-time data are being used and the source of the data is determinable and available. Otherwise the scope of whole build is always checked.
  * How can you alter the default configuration? [Please check the Configuration section of the BuildCheck documentation](./BuildCheck.md#sample-configuration)
- * To enable verbose logging in order to troubleshoot issue(s), enable [binary logging](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md#msbuild-binary-log-overview
+ * To enable verbose logging in order to troubleshoot issue(s), enable [binary logging](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md#msbuild-binary-log-overview)
    _Cmd:_
    ```cmd
    dotnet build -bl -check
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 198791bb356..dcaab9c9cba 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -3,6 +3,7 @@
 [EventSource](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventsource?view=netframework-4.8) is the tool that allows Event Tracing for Windows (ETW) used in MSBuild. Among its useful features, functions with names ending in "start" and "stop" correlate between calls such that it can automatically record how long the event between the two calls took. It also provides an easy way to cheaply opt in or out, log auxiliary messages in addition to time, and add progress updates in the middle of an event as needed.
 
 ## EventSource in MSBuild
+
 EventSource is primarily used to profile code. For MSBuild specifically, a major goal is to reduce the time it takes to run, as measured (among other metrics) by the Regression Prevention System (RPS), i.e., running specific scenarios. To find which code segments were likely candidates for improvement, EventSources were added around a mix of code segments. Larger segments that encompass several steps within a build occur nearly every time MSBuild is run and take a long time. They generally run relatively few times. Smaller methods with well-defined purposes may occur numerous times. Profiling both types of events provides both broad strokes to identify large code segments that underperform and, more specifically, which parts of them. Profiled functions include:
 
 | Event | Description |
@@ -20,7 +21,7 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | ExecuteTaskYield | Requests to yield the node, often while the task completes other work. |
 | ExpandGlob | Identifies a list of files that correspond to an item, potentially with a wildcard. |
 | GenerateResourceOverall | Uses resource APIs to transform resource files into strongly-typed resource classes. |
-| LoadDocument | Loads an XMLDocumentWithLocation from a path.
+| LoadDocument | Loads an XMLDocumentWithLocation from a path. |
 | MSBuildExe | Executes MSBuild from the command line. |
 | MSBuildServerBuild | Executes a build from the MSBuildServer node. |
 | PacketReadSize | Reports the size of a packet sent between nodes. Note that this does not include time information. |
diff --git a/documentation/specs/low-priority-switch.md b/documentation/specs/low-priority-switch.md
index ba33826a89e..bec5a72fc74 100644
--- a/documentation/specs/low-priority-switch.md
+++ b/documentation/specs/low-priority-switch.md
@@ -17,7 +17,6 @@ Visual Studio, on the other hand, should always run at normal priority. This ens
 4. Any reused nodes are at the priority they themselves specify. Normal priority nodes are actually at normal priority, and low priority nodes are actually at BelowNormal priority.
 5. All nodes are at the priority they should be when being used to build even if a normal priority process had connected to them as normal priority worker nodes, and they are now executing a low priority build.
 
-
 ## Non-goals
 
 Perfect parity between windows and mac or linux. Windows permits processes to raise their own priority or that of another process, whereas other operating systems do not. This is very efficient, so we should use it. As we expect this feature to be used in Visual Studio, we anticipate it being less used on mac and linux, hence not being as high priority to make it just as efficient.
@@ -27,6 +26,7 @@ Perfect parity between windows and mac or linux. Windows permits processes to ra
 Each node (including worker nodes) initially takes its priority from its parent process. Since we now need the priority to align with what it is passed instead of its parent, attempt to adjust priority afterwards if necessary as part of node startup.
 
 BuildManager.cs remembers the priority of the previous build it had executed. If that was set to a value that differs from the priority of the current build:
+
 1. On windows or when decreasing the priority: lowers the priority of all connected nodes
 2. On linux and mac when increasing the priority: disconnects from all nodes.
 
diff --git a/documentation/specs/project-cache.md b/documentation/specs/project-cache.md
index b0ce961313d..90d19466fdc 100644
--- a/documentation/specs/project-cache.md
+++ b/documentation/specs/project-cache.md
@@ -1,8 +1,10 @@
-# Summary
+# Project Cache
+
+## Summary
 
 Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](static-graph.md#weakness-of-the-old-model-caching-and-distributability).
 
-# Motivation
+## Motivation
 
 As the introduction to [static graph](static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
 
@@ -10,31 +12,33 @@ Visual Studio is one beneficiary. This plugin inverts dependencies among build s
 
 This change also simplifies and unifies user experiences. MSBuild works the same from Visual Studio or the command line without dramatically changing how it works.
 
-# Plugin requirements
+## Plugin requirements
 
 - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:
   - it makes the filesystem look as if the project built
   - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.
 
-# High-level design
+## High-level design
 
 Conceptually, there are two parts of caching: "cache get" and "cache add". "Cache get" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. "Cache add" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.
 
 The "cache get" functionality was introduced in 16.9, while "cache add" was added in 17.8.
 
-## Plugin discovery
+### Plugin discovery
 
 - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).
   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.
   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.
-```xml
-<ItemGroup>
-  <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll" />
-</ItemGroup>
-```
+
+    ```xml
+    <ItemGroup>
+    <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll" />
+    </ItemGroup>
+    ```
+
 - Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.
 
-## Plugin lifetime
+### Plugin lifetime
 
 - Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.
 - `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a "fire-and-forget" call at this point. The first query on the plugin will wait for plugin initialization.
@@ -43,10 +47,10 @@ The "cache get" functionality was introduced in 16.9, while "cache add" was adde
 - The plugin instance will get called in reverse topological sort order (from referenced projects up towards referencing projects). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.
 - Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that projects which are not well-described in the graph (e.g. using `<MSBuild>` tasks directly) will not benefit from the cache.
 
-## Cache get scenario
+### Cache get scenario
 
 - For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.
-  
+
   - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.
 - If the plugin decides to build, then MSBuild proceeds building the project as usual.
 - If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets ("proxy targets").
@@ -62,7 +66,7 @@ The "cache get" functionality was introduced in 16.9, while "cache add" was adde
     - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.
       - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.
 
-## Cache add scenario
+### Cache add scenario
 
 - Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.
 - MSBuild uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. To facilitate the plugin being able to handle future builds, it forwards this information as well as the build result to the plugin for it to use as desired, for example to add to a cache.
@@ -72,9 +76,10 @@ The "cache get" functionality was introduced in 16.9, while "cache add" was adde
 - Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`), only for the x64 flavor (not x86 or arm64), and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.
 - As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.
 
-# APIs and calling patterns
+## APIs and calling patterns
+
+### Plugin API
 
-## Plugin API
 [ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass.
 
 See the [Plugin implementation guidance and simple example design](#plugin-implementation-guidance-and-simple-example-design) section for guidance for plugin implementations.
@@ -97,14 +102,14 @@ This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via
 
 Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.
 
-## Enabling from command line
+### Enabling from command line
 
 - Requires `/graph` to light up cache get scenarios.
 - Requires `/reportfileaccesses` to light up cache add scenarios.
 - The static graph has all the project instances in the same process, making it easy to find and keep plugin instances in one process.
 - MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.
 
-## Enabling from Visual Studio, a temporary workaround
+### Enabling from Visual Studio, a temporary workaround
 
 - Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.
 - The workaround logic activates only when MSBuild detects that it's running under VS.
@@ -113,29 +118,30 @@ Note: As it is likely that plugins will be distributed through NuGet packages an
 - Plugins will be given the graph entry points instead of the entire graph in this scenario.
 - There is currently no way to enable cache add scenarios in Visual Studio.
 
-# Detours (cache add scenario)
+## Detours (cache add scenario)
 
 In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will emit events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.
 
 Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.
 
-## Pipe synchronization
+### Pipe synchronization
 
 Because the Detours implementation being used communicates over a pipe, and nodes communicate over a pipe as well, and pipes are async, there is some coordination required to ensure that file accesses are associated with the proper build request. For example, if a "project finished" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.
 
 To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler node receives as "project finished" event over the node communication pipe, it will wait to determine that the project is actually finished until it also receives the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler determines the project is finished and schedules new work to the worker node (which would trigger new file accesses).
 
-# Plugin implementation guidance and simple example design
+## Plugin implementation guidance and simple example design
 
 The following will describe a very basic (and not very correct) plugin implementation.
 
 In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build ("if Tuesday copy this file"), but if considered caching would be quite infeasible.
 
-## Fingerprinting
+### Fingerprinting
 
 A "fingerprint" describes each unique input which went into the building a build request. The more granular the fingerprint, the more "correct" the caching is, as described above.
 
 In this example, we will only consider the following as inputs, and thus part of the fingerprint:
+
 - The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)
 - The content hash of the project file
 - The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`
@@ -147,13 +153,13 @@ It can make sense for a fingerprint to be a hash of its inputs, so effectively i
 
 At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.
 
-## Cache storage
+### Cache storage
 
 Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.
 
 For illustration purposes, consider our cache implementation is based on a simple filesystem with a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.
 
-## First build (cache population)
+### First build (cache population)
 
 In the very first build there will be no cache hits so the "cache add" scenario will be most relevant here.
 
@@ -168,22 +174,24 @@ In our example, we can use the read files to construct a fingerprint for the bui
 The plugin would then create some metadata describing the outputs (eg. the paths and hashes) and the serialized `BuildResult`, and associate it with the fingerprint and put that assocation in the cache.
 
 To illustrate this, consider a project with fingerprint `F` which wrote a single file `O` with hash `H` and had `BuildResult R`. The plugin could create a metadata file `M` which describes the outputs of the build (the path and hash of `O`) as well as the serialized `R`. Using the cache implementation described above, the plugin would write the following two files to the cache:
- - `metadata/F -> M:"{outputs: [{path: 'path/to/O', hash: H}], result: R}"`
- - `content/H -> O`
+
+- `metadata/F -> M:"{outputs: [{path: 'path/to/O', hash: H}], result: R}"`
+- `content/H -> O`
 
 This can then be used for future builds.
 
- ## Second Build (cache hits)
- 
- In the second build we have a populated cache and so it could be possible to get cache hits.
+### Second Build (cache hits)
 
- For a given project, `GetCacheResultAsync` will be invoked. The plugin can fingerprint the request and use that fingerprint to look up in its cache. If the cache entry exists, it can declare a cache hit.
+In the second build we have a populated cache and so it could be possible to get cache hits.
+
+For a given project, `GetCacheResultAsync` will be invoked. The plugin can fingerprint the request and use that fingerprint to look up in its cache. If the cache entry exists, it can declare a cache hit.
 
 In the example above, if all inputs are the same as in the first build, we should end up with a fingerprint `F`. We look up in the metadata part of the cache (file `metadata/F`) and find that it exists. This means we have a cache hit. We can fetch that metadata `M` from the cache and find that it describes the output with path `O` and hash `H`. The plugin would then copy `content/H` to `O` and return the deserialized `BuildResult R` contained in `M` to MSBuild.
 
 If the inputs were not the same as in the first build, for example if a `Compile` item (a .cs file) changed, the fingerprint would be something else besides `F` and so would not have corresponding cache entries for it, indicating a cache miss. This will then go through the "cache add" scenario described above to populate the cache with the new fingerprint.
 
-# Caveats
+## Caveats
+
 - Without the "cache add" scenario enabled, the content which powers "cache get" must be populated by some external entity, for example some higher-order build engine.
 - Absolute paths circulating through the saved build results
   - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.
@@ -193,6 +201,7 @@ If the inputs were not the same as in the first build, for example if a `Compile
   - Msbuild /graph requires that the [target inference protocol](static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
 - Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.
 
-# Potential future work of dubious value
+## Potential future work of dubious value
+
 - Enable plugins to work with the just-in-time top down msbuild traversal that msbuild natively does when it's not using `/graph`.
 - Extend the project cache API to allow skipping individual targets or tasks instead of entire projects. This would allow for smaller specialized plugins, like plugins that only know to distribute, cache, and skip CSC.exe calls.
diff --git a/documentation/specs/question.md b/documentation/specs/question.md
index 84fac8ed9f3..f46aa910af8 100644
--- a/documentation/specs/question.md
+++ b/documentation/specs/question.md
@@ -8,15 +8,19 @@ Question switch ask if the next build is up-to-date. It will start a build, but
 [Fast Up-To-Date Check](https://github.com/dotnet/project-system/blob/cd275918ef9f181f6efab96715a91db7aabec832/docs/up-to-date-check.md) is a system that is implemented by the Project System, that decides, if it needs to run MSBuild.  MSBuild takes a non-trival amount of time to load, evaluate, and run through each target and task.  Fast Up-To-Date is faster, but can be less accurate, suitable for an IDE and a human interface.  It is not accurate enough for a CI.
 
 ## Usage
+
 Question mode is designed to be used on the command line.  Run your normal build, then run again with /question.
-```
+
+```cmd
 msbuild /p:Configuration=Debug Project1.csproj /bl:build.binlog
 msbuild /p:Configuration=Debug Project1.csproj /bl:incremental.binlog /question
 ```
+
 If there are no errors, then your build is up-to-date.
 If there are errors, then investigate the error.  See common errors below.  Keep both logs to help with your investigation.
 
 ## Custom Tasks
+
 Task author can implement the optional `IIncrementalTask` interface that will expose `FailIfNotIncremental`. `FailIfNotIncremental` is true when /question switch is used. The custom task will need to decide how it want to handle their behavior.  For example.  If there is already a message describing why the task cannot be skipped, then simply convert the message to a error. Remember to return false to stop the build.  For the best reproducibility, do not modify any files on disk.
 
 ```C#
@@ -32,6 +36,7 @@ else
 ```
 
 ## Shipping Tasks
+
 When question switch is used, it will modify the shipping task with these behavior.  Note: this is still experimental and can change.
 
 `Exec`
@@ -73,11 +78,11 @@ Error when SkipUnchangedFiles is true.
 `ZipDirectory`
 Error if the destination zip file doesn't exists.
 
-
 ## Common Error
+
 - **Typographical error**. Spelling, casing, or incorrect path.  Check if the target inputs and outputs real files.
 - Inputs and Outputs are sometimes used for Cross Product. Try to move all to Outputs. If not possible, use Returns instead of Inputs.
 - **Double Checks**.  Since target and task could be incremental, if both are implemented, then it can lead task skipping but not the task.  For example, a Target has inputs A and outputs B.  If A is newer, than B, then the target will start.  If the task compares the content of A and B and deems nothing has changed, then B is not updated.  If such case, this leads to target rerunning.
 - **Exec Task** are not Skipable, thus they should be wrapped with Target Inputs and Outputs or other systems.  For backwards compatibility, Question will not issue an error.
 - **FileWritten**.  The common clean system will remove files that aren't in the FileWritten itemgroup.  Sometimes task output won't be add to FileWritten itemgroup.
-- **Build, then Build**.  Sometimes, a 2nd build will break up to date.  Question after the 2nd build. 
\ No newline at end of file
+- **Build, then Build**.  Sometimes, a 2nd build will break up to date.  Question after the 2nd build.
diff --git a/documentation/specs/rar-core-scenarios.md b/documentation/specs/rar-core-scenarios.md
index 3fb19ad7846..48af2458d6d 100644
--- a/documentation/specs/rar-core-scenarios.md
+++ b/documentation/specs/rar-core-scenarios.md
@@ -139,6 +139,7 @@ effect. Be it eliminating allocations, simplifying tight loops, reordering cases
 address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.
 
 For regular project references the system works as about as efficient as possible.
+
 - In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.
 - In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the
 corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.
@@ -188,6 +189,7 @@ enlistment - the system may prime by building the full solution and then the dev
 cache and get sub-optimal first-time build performance.
 
 Saving of the per-project disk cache may be further optimized by
+
 - Keeping the timestamp of the cache file in memory and skipping the save if the relevant cache items haven't become dirty (i.e. the dependencies have not changed)
 *and* the timestamp of the cache file hasn't changed since the last save. In hot inner loop scenarios this would reduce the save to a timestamp check.
 - Saving the file asynchronously, i.e. not blocking the build on completing the save operation.
diff --git a/documentation/specs/remote-host-object.md b/documentation/specs/remote-host-object.md
index 536535637d2..a64a8836ab4 100644
--- a/documentation/specs/remote-host-object.md
+++ b/documentation/specs/remote-host-object.md
@@ -4,8 +4,9 @@ A remote host object must be registered in the [Running Object Table (ROT)](http
 
 [The registration of interfaces](https://docs.microsoft.com/en-us/dotnet/framework/interop/how-to-register-primary-interop-assemblies) is the only thing interop with COM that need extra care. There are 3 interfaces involved in out-of-proc tasks work: `IVsMSBuildTaskFileManager`, `IPersistFileCheckSum` and `ITaskHost`. `IVsMSBuildTaskFileManager` and `IPersistFileCheckSum` are registered globally in Windows registry by VS existing setup. `ITaskHost` is also configured in VS using registration-free. So the only work is to configure it using registration-free in **MSBuild**. That results the change in msbuild.exe.manifest file and the change to generate tlb file for ITaskHost.
 
-## Annotated additions to the msbuild.exe.manifest file.
-```
+## Annotated additions to the msbuild.exe.manifest file
+
+```xml
 <file name="Microsoft.Build.Framework.tlb"> -- Location of the tlb, it should be in the same directory as msbuild.exe
     <typelib
         tlbid="{D8A9BA71-4724-481D-9CA7-0DA23A1D615C}" -- matches what is embedded in the tlb with ITaskHost
@@ -24,7 +25,7 @@ A remote host object must be registered in the [Running Object Table (ROT)](http
 
 If is part of the work for [allowing out-of-proc tasks to access unsaved changes](https://github.com/dotnet/project-system/issues/4406)
 
-## More reference:
+## More reference
 
 [RegFree COM Walkthrough](https://msdn.microsoft.com/library/ms973913.aspx)
 
diff --git a/documentation/specs/sdk-resolvers-algorithm.md b/documentation/specs/sdk-resolvers-algorithm.md
index e5cd05a0dd3..6cc8ce247c6 100644
--- a/documentation/specs/sdk-resolvers-algorithm.md
+++ b/documentation/specs/sdk-resolvers-algorithm.md
@@ -1,20 +1,26 @@
-## SDK Resolution Algorithm
+# SDK Resolution Algorithm
+
 In 17.3 under ChangeWave 17.4 the sdk resolution algorithm is changed.
 
-### Reason for change
+## Reason for change
+
 Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavior in 17.3 under ChangeWave 17.4.
 
-### New SDK Resolution Algorithm
+## New SDK Resolution Algorithm
+
 Under ChangeWave 17.4 all the resolvers divides into two groups:
+
 - Specific resolvers, i.e. resolvers with specified sdk name pattern `ResolvableSdkPattern`
 - General resolvers, i.e. resolvers without specified sdk name pattern `ResolvableSdkPattern`
 
-The resolving algorithm works in two passes. 
-- On the first pass all the specific resolvers that match the given sdk name would be loaded, ordered by priority and tried one after one. 
+The resolving algorithm works in two passes.
+
+- On the first pass all the specific resolvers that match the given sdk name would be loaded, ordered by priority and tried one after one.
 - If the sdk is not found, on the second pass all general resolvers would be loaded, ordered by priority and tried one after one.
 
 By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `ResolvableSdkPattern` using C# regex format:
-```
+
+```xml
 <SdkResolver>
   <Path>MySdkResolver.dll</Path>
   <ResolvableSdkPattern>MySdk.*</ResolvableSdkPattern>
@@ -23,11 +29,12 @@ By default the resolvers are general. To make all the resolvers from some dll sp
 
 Note, that the manifest file, if exists, from ChangeWave 17.4 would have preference over the dll.
 The sdk discovery works according to the following algorithm:
-- First try locate the manifest file and use it. 
-- If it is not found, we try to locate the dll in the resolver's folder. 
+
+- First try locate the manifest file and use it.
+- If it is not found, we try to locate the dll in the resolver's folder.
 Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
 
-### Failed SDK Resolution
+## Failed SDK Resolution
 
 > ðŸš§ Note
 >
@@ -35,15 +42,15 @@ Both xml and dll name should match the following name pattern `...\SdkResolvers\
 
 SDK resolvers previously attempted to continue when one critically fails (throws an unhandled exception). This lead to misleading error messages such as:
 
-```
+```text
 warning MSB4242: The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed to run. 's' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8.
 error MSB4236: The SDK 'Microsoft.NET.SDK.WorkloadAutoImportPropsLocator' specified could not be found. [C:\foo\bar.csproj]
 ```
 
 `MSB4236` is a red herring while `MSB4242` is the real error despite being logged as a warning. Because of this, SDK resolvers now fail the build _immediately_ upon unhandled exceptions. These exceptions are propogated as `SdkResolverException`s, and `MSB4242` has been promoted to an error code. The new error message appears like so:
 
-```
-C:\src\temp\8-18>"C:\foo\dotnet-sdk-6.0.100-preview.7.21379.14-win-x64\dotnet.exe" build    
+```text
+C:\src\temp\8-18>"C:\foo\dotnet-sdk-6.0.100-preview.7.21379.14-win-x64\dotnet.exe" build
 Microsoft (R) Build Engine version 17.0.0-dev-21420-01+5df152759 for .NET
 Copyright (C) Microsoft Corporation. All rights reserved.
 
@@ -56,4 +63,4 @@ C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Micr
     1 Error(s)
 
 Time Elapsed 00:00:00.15
-```
\ No newline at end of file
+```
diff --git a/documentation/specs/single-project-isolated-builds.md b/documentation/specs/single-project-isolated-builds.md
index 75b15fc5b82..8a8f9e68413 100644
--- a/documentation/specs/single-project-isolated-builds.md
+++ b/documentation/specs/single-project-isolated-builds.md
@@ -19,25 +19,27 @@ In a build, the input and output cache files have the same lifetime as the `Conf
 <!-- constraints -->
 
 When loading input cache files, MSBuild merges incoming instances of `ConfigCache`s and `ResultsCache`s into one instance of each with the help of the [`CacheAggregator`](https://github.com/dotnet/msbuild/blob/51df47643a8ee2715ac67fab8d652b25be070cd2/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L15), which enforces the following constraints:
+
 - No duplicate cache entries
 - Bijection:
-   - `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
-   - `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`
+  - `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
+  - `BuildResult.ConfigurationId == BuildRequestConfiguration.ConfigurationId`
 
 Note that the output cache file contains a single `BuildResult` with the `TargetResult`s from the project specified to be built in the `BeginBuild` / `EndBuild` session, as any `BuildResult`s obtained through isolation exemption are excluded to prevent potential duplicate input cache entries; Entries from input caches are not transferred to the output cache.
 
 <!-- How input / output cache entries are separated with the override caches -->
-Input cache entries are separated from output cache entries with the composite caches [`ConfigCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [`ResultsCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). Each composite cache contains two underlying caches: a cache where input caches files are loaded into (the override cache), and a cache where new results are written into (the current cache).* In the `ConfigCacheWithOverride`, these caches are instances of `ConfigCache`s and, in the `ResultsCacheWithOverride`, these caches are instances of `ResultsCache`s. A query for a cache entry is first attempted from the override cache and, if unsatisfied, a second attempt is made from the current cache. Writes are only written to the current cache, never into the override cache.* It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache query.
+Input cache entries are separated from output cache entries with the composite caches [`ConfigCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [`ResultsCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). Each composite cache contains two underlying caches: a cache where input caches files are loaded into (the override cache), and a cache where new results are written into (the current cache). *In the `ConfigCacheWithOverride`, these caches are instances of `ConfigCache`s and, in the `ResultsCacheWithOverride`, these caches are instances of `ResultsCache`s. A query for a cache entry is first attempted from the override cache and, if unsatisfied, a second attempt is made from the current cache. Writes are only written to the current cache, never into the override cache.* It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache query.
 
 ## Isolation Implementation
 
 [Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the `Scheduler` and  `TaskBuilder`. [`TaskBuilder.ExecuteInstantiatedTask`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in a `ProjectReference` item. [`Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
 
 ### Isolation Exemption
+
 The `Scheduler` [skips isolation constraints](static-graph.md#exempting-references-from-isolation-constraints) on project references via the:
 
-* `GraphIsolationExemptReference` item. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of a `BuildRequest` to `true` if the `RequestBuilder` matches it against a `GraphIsolationExemptReference` item defined in the calling project. Additionally, the `RequestBuilder` marks the `BuildRequest`'s corresponding `BuildRequestConfiguration` as exempt to allow the `TaskBuilder` to verify exemption from isolation constraints.
+- `GraphIsolationExemptReference` item. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of a `BuildRequest` to `true` if the `RequestBuilder` matches it against a `GraphIsolationExemptReference` item defined in the calling project. Additionally, the `RequestBuilder` marks the `BuildRequest`'s corresponding `BuildRequestConfiguration` as exempt to allow the `TaskBuilder` to verify exemption from isolation constraints.
 
-* `isolate:MessageUponIsolationViolation` switch. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of _every_ `BuildRequest` to `true`. The `TaskBuilder` verifies exemption from isolation constraints just by the switch value.
+- `isolate:MessageUponIsolationViolation` switch. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of _every_ `BuildRequest` to `true`. The `TaskBuilder` verifies exemption from isolation constraints just by the switch value.
 
-\* Except in the following scenario when a `ProjectReference` is exempted from isolation constraints: a dependency project A outputs a cache file F containing a `BuildResult` with `TargetResult`s T<sub>cached</sub> for targets t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>m</sub> and a dependent project B uses F as an input cache file but builds and obtains the `TargetResult`s T<sub>new</sub> for targets t<sub>m + 1</sub>, t<sub>m + 2</sub>, ..., t<sub>n</sub> such that 0 < m < n. In this case, T<sub>new</sub> will be placed into the `ResultsCache` containing T<sub>cached</sub> to enforce no overlap between the override and current caches in the `ConfigCacheWithOverride`.
\ No newline at end of file
+\* Except in the following scenario when a `ProjectReference` is exempted from isolation constraints: a dependency project A outputs a cache file F containing a `BuildResult` with `TargetResult`s T<sub>cached</sub> for targets t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>m</sub> and a dependent project B uses F as an input cache file but builds and obtains the `TargetResult`s T<sub>new</sub> for targets t<sub>m + 1</sub>, t<sub>m + 2</sub>, ..., t<sub>n</sub> such that 0 < m < n. In this case, T<sub>new</sub> will be placed into the `ResultsCache` containing T<sub>cached</sub> to enforce no overlap between the override and current caches in the `ConfigCacheWithOverride`.
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 49acebe57fe..6112072349a 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -85,6 +85,7 @@ Static graph functionality can be used in three ways:
 ## Project Graph
 
 ### Constructing the project graph
+
 Calculating the project graph will be very similar to the MS internal build engine's existing Traversal logic. For a given evaluated project, all project references will be identified and recursively evaluated (with deduping).
 Project references are identified via the `ProjectReference` item.
 
@@ -112,14 +113,16 @@ Multitargeting refers to projects that specify multiple build dimensions applica
 
 <!-- how it works: outer builds and inner builds -->
 Multitargeting is implemented by having a project reference itself multiple times, once for each combination of multitargeting global properties. This leads to multiple evaluations of the same project, with different global properties. These evaluations can be classified in two groups
-1.  Multiple inner builds. Each inner build is evaluated with one set of multitargeting global properties (e.g. the `TargetFramework=net472` inner build, or the `TargetFramework=netcoreapp2.2` inner build).
-2.  One outer build. This evaluation does not have any multitargeting global properties set. It can be viewed as a proxy for the inner builds. Other projects query the outer build in order to learn the set of valid multitargeting global properties (the set of valid inner builds). When the outer build is also the root of the project to project graph, the outer build multicasts the entry target (i.e. `Build`, `Clean`, etc) to all inner builds.
+
+1. Multiple inner builds. Each inner build is evaluated with one set of multitargeting global properties (e.g. the `TargetFramework=net472` inner build, or the `TargetFramework=netcoreapp2.2` inner build).
+2. One outer build. This evaluation does not have any multitargeting global properties set. It can be viewed as a proxy for the inner builds. Other projects query the outer build in order to learn the set of valid multitargeting global properties (the set of valid inner builds). When the outer build is also the root of the project to project graph, the outer build multicasts the entry target (i.e. `Build`, `Clean`, etc) to all inner builds.
 
 <!-- contract with the graph -->
 
 In order for the graph to represent inner and outer builds as nodes, it imposes a contract on what multitargeting means, and requires the multitargeting supporting SDKs to implement this contract.
 
 Multitargeting supporting SDKs MUST implement the following properties and semantics:
+
 - `InnerBuildProperty`. It contains the property name that defines the multitargeting build dimension.
 - `InnerBuildPropertyValues`. It contains the property name that holds the possible values for the `InnerBuildProperty`.
 - Project classification:
@@ -136,6 +139,7 @@ These specific rules represent the minimal rules required to represent multitarg
 For example, `InnerBuildProperty` could become `InnerBuildProperties` for SDKs where there's multiple multitargeting global properties.
 
 For example, here is a trimmed down `Microsoft.Net.Sdk` multitargeting project:
+
 ```xml
 <Project Sdk="Microsoft.Net.Sdk">
   <!-- This property group is defined in the sdk -->
@@ -152,14 +156,17 @@ For example, here is a trimmed down `Microsoft.Net.Sdk` multitargeting project:
 ```
 
 To summarize, there are two main patterns for specifying build dimensions:
+
 1. Multitargeting based. A multitargeting project self describes supported build dimensions. In this case the SDK needs to specify the multitargeting build dimensions. The graph then extracts innerbuilds from a given outer build. For example, the `TargetFramework` build dimension gets specified this way.
 2. Global Property based: A top level set of global properties get applied to the graph entrypoints and get propagated downward through the graph. For example, the `Configuration` and `Platform` build dimensions get specified this way.
 
 Why does an outerbuild need to generate speculative edges to all of its innerbuilds? Why can't it use nuget to prune the speculative edges down to the compatible set?
+
 - One big design constraint we imposed on static graph was to keep it agnostic of SDK implementation details. So the graph must not know about particular details of one language's SDK. We wanted a generic design that all language SDKs can leverage. We considered that calling nuget to get the compatible TargetFramework values breaks this rule, as both the concept of "nuget" and the concept of "TargetFramework" are implementation details of the .net SDK. If someone were to write a Java SDK, would "calling nuget to get the compatible TargetFramework" still be relevant? A solution to this is to allow SDKs to configure the graph with an extension point on "how to collapse multiple speculative innerbuild edges into a smaller compatible set", but we didn't have the time to design it yet.
 - There is a conflicting need between build everything or just building a "TF slice" through the graph. Outer loop builds (CI builds) that publish binaries need to build all the packages for all the supported TFs, so they need the graph to express all possible combinations. Inner loop builds (dev-at-work) can be sliced down to only the TF that the dev is working on in order to reduce build times. Again, we didn't have time to design how to express these two things so we went with "express everything" because that allows both scenarios to work.
 
 ### Executing targets on a graph
+
 When building a graph, project references should be built before the projects that reference them, as opposed to the existing msbuild scheduler which builds projects just in time.
 
 For example if project A depends on project B, then project B should build first, then project A. Existing msbuild scheduling would start building project A, reach an MSBuild task for project B, yield project A, build project B, then resume project A once unblocked.
@@ -169,6 +176,7 @@ Building in this way should make better use of parallelism as all CPU cores can
 Note that graph cycles are disallowed, even if they're using disconnected targets. This is a breaking change, as today you can have two projects where each project depends on a target from the other project, but that target doesn't depend on the default target or anything in its target graph.
 
 #### Command line
+
 `msbuild /graph` - msbuild will create a static graph from the entry point project and build it in topological order with the specified targets. Targets to call on each node are inferred via the rules in [this section](#inferring-which-targets-to-run-for-a-project-within-the-graph).
 
 #### APIs
@@ -176,11 +184,12 @@ Note that graph cycles are disallowed, even if they're using disconnected target
 [BuildManager.PendBuildRequest(GraphBuildRequestData requestData)](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/BuildManager.cs#L676)
 
 ### Inferring which targets to run for a project within the graph
+
 In the classic MSBuild build (i.e. execution of targets), the referencing project chooses which targets to call on the referenced projects and may call into a project multiple times with different target lists and global properties (examples in [project reference protocol](../ProjectReference-Protocol.md)). This is a top-down traversal of dependencies. These calls are made via the [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task?view=vs-2019). When building a graph, projects are built before the projects that reference them. This is a bottom-up traversal. Therefore the graph needs to determine the list of targets to execute on a specific project `B` **before** building the referencing projects that reference `B`.
 
 The static graph contains the structural information on which reference projects a referencing project depends on. But it does not contain information on what "depends" means. At build time "depends" means that a referencing evaluated project will call a subset of reference evaluations with some targets. Subset because the static graph is an inferred graph, therefore there are ambiguities during graph construction, and thus it needs to be conservative and represent a superset of the "runtime graph". The "runtime graph" is the actual graph that gets executed during a real build. We cannot know the runtime graph because that would require us to analyze msbuild xml code inside of targets in order to find the `MSBuild task` invocations. This means doing heavy program analysis, like symbolic execution. That would make things very complicated, slower, and would probably introduce even more ambiguity, so a larger superset conservative graph. So we kept it simple and only looked at evaluation time msbuild xml code (i.e. msbuild xml code outside of `<Target>` elements).
 To summarize, the static graph does not have insights into the `MSBuild task` callsites. It does not know callsite specific information such as the `Targets="Foo;Bar"` or `Properties="Foo=Bar"` `MSBuild task` attributes.
-Since the graph does not have access to MSBuild task callsites, it does not know what targets will get called for a given graph edge. 
+Since the graph does not have access to MSBuild task callsites, it does not know what targets will get called for a given graph edge.
 
 To infer target information we use a flow analysis to propagate target information down the graph. The flow analysis uses the `ProjectReferenceTargets` protocol (described further down) to infer how one incoming target on a graph node (e.g. `Build`) generates multiple outgoing targets to its referenced nodes (e.g. `GetTargetFrameworks`, `GetNativeManifest`, `Build`).
 SDKs **must** explicitly describe the project-to-project calling patterns via the `ProjectReferenceTargets` protocol in such a way that a graph based build can correctly infer the entry targets for a graph node.
@@ -189,7 +198,7 @@ Each project needs to specify the project reference protocol targets it supports
 
 For example, a simple recursive rule would be `A -> A`, which says that a project called with target `A` will call target `A` on its referenced projects. Here's an example execution with two nodes:
 
-```
+```text
 Execute target A+-->Proj1   A->A
                     +
                     |
@@ -202,11 +211,12 @@ Execute target A+-->Proj1   A->A
 Proj1 depends on Proj2, and we want to build the graph with target `A`. Proj1 gets inspected for the project reference protocol for target `A` (represented to the right of Proj1). The protocol says the referenced projects will be called with `A`. Therefore Proj2 gets called with target `A`. After Proj2 builds, Proj1 then also builds with `A` because Proj1 is an entry point and `A` is what was requested by the user.
 
 A project reference protocol may contain multiple targets, for example `A -> B, A`. This means that building `A` on the referencing project will lead to `B` and `A` getting called on the referenced projects. If all nodes in the graph repeat the same rule, then the rule is repeated recursively on all nodes. However, a project can choose to implement the protocol differently. In the following example, the entry targets are:
+
 - Proj4 is called with targets `B, A, C, D`. On multiple references, the incoming targets get concatenated. The order of these target lists does not matter, as MSBuild has non-deterministic p2p ordering, however the order within the target lists does. IE. `B, A, C, D` and `C, D, B, A` are valid, while `A, B, C, D` is not.
 - Proj3 and Proj2 get called with `B, A`, as specified by the rule in Proj1.
 - Proj1 builds with `A`, because it's the root of the graph.
 
-```
+```text
             A+-->Proj1   A->B, A
                  /    \
            B, A /      \ B, A
@@ -238,6 +248,7 @@ Here are the rules for the common protocols:
 `Rebuild` actually calls `Clean` and `Build`, which in turn uses the concatenation of the `Clean` and `Build` mappings. `GetTargetFrameworks` is repeated so only the first call to it remains in the final target list.
 
 Restore is a composition of two rules:
+
 - `Restore -> _IsProjectRestoreSupported, _GenerateRestoreProjectPathWalk, _GenerateRestoreGraphProjectEntry`
 - `_GenerateRestoreProjectPathWalk -> _IsProjectRestoreSupported, _GenerateRestoreProjectPathWalk, _GenerateRestoreGraphProjectEntry`
 
@@ -258,22 +269,24 @@ We'll represent the project reference protocols as `ProjectReferenceTargets` ite
 #### Multitargeting details
 
 A multitargeting project can get called with different targets for the outer build and the inner builds. In this case, the `ProjectReferenceTargets` items containing targets for the outer build are marked with the `OuterBuild=true` metadata. Here are the rules for how targets from `ProjectReferenceTargets` get assigned to different project types:
-  - *Outer build*: targets with `OuterBuild=true` metadata
-  - *Dependent inner build*: targets without `OuterBuild=true` metadata
-  - *Standalone inner build*: the same as non multitargeting builds.
-  - *Non multitargeting build*: concatenation of targets with `OuterBuild=true` metadata and targets without `OuterBuild=true` metadata
+
+- *Outer build*: targets with `OuterBuild=true` metadata
+- *Dependent inner build*: targets without `OuterBuild=true` metadata
+- *Standalone inner build*: the same as non multitargeting builds.
+- *Non multitargeting build*: concatenation of targets with `OuterBuild=true` metadata and targets without `OuterBuild=true` metadata
 
 **OPEN ISSUE:** Current implementation does not disambiguate between the two types of inner builds, leading to overbuilding certain targets by conservatively treating both inner build types as standalone inner builds.
 
 For example, consider the graph of `A (non multitargeting) -> B (multitargeting with 2 innerbuilds) -> C (standalone inner build)`, with the following target propagation rules:
-```
+
+```text
 A -> Ao when OuterBuild=true
 A -> Ai, A
 ```
 
 According to the graph construction rules defined in the [multitargeting section](#multitargeting), we get the following graph, annotated with the target propagation for target `A`.
 
-```
+```text
                    A+-->ProjA
                       /   |   \
                      /    |    \
@@ -294,6 +307,7 @@ According to the graph construction rules defined in the [multitargeting section
 ```
 
 ### Underspecified graphs
+
 The intention is that the project graph and the target lists for each node be exactly correct, however MSBuild is quite flexible and particular projects or project types may not adequately describe these for the project graph.
 
 If a project calls into another project which either isn't represented in the graph or with a target list which isn't represented by the graph, it will fall back to classical MSBuild behavior and execute that target on the project reference just-in-time. This has the consequence of still requiring all project state be kept in memory in case any arbitrary project wants to execute targets on any other arbitrary project.
@@ -301,6 +315,7 @@ If a project calls into another project which either isn't represented in the gr
 To enable further optimizations (and strictness), graph builds can run [isolated](#isolated-builds) which enforces that the graph be entirely accurate.
 
 ### Public API
+
 This is a proposal for what the public API for ProjectGraph may look like:
 
 ```csharp
@@ -360,6 +375,7 @@ namespace Microsoft.Build.Experimental.Graph
 ```
 
 ## Isolated builds
+
 Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any `BuildResult` objects for project references must be precomputed and somehow provided as inputs to the referencing project.
 
 If a project uses the MSBuild task, the build result must be in MSBuild's build result cache instead of just-in-time executing targets on that referenced project. If it is not in the build result cache, an error will be logged and the build will fail. If the project is calling into itself either via `CallTarget` or the MSBuild task with a different set of global properties, this will be allowed to support multitargeting and other build dimensions implemented in a similar way.
@@ -367,6 +383,7 @@ If a project uses the MSBuild task, the build result must be in MSBuild's build
 Because referenced projects and their entry targets are guaranteed to be in the cache, they will not build again. Therefore we do not need to set `/p:BuildProjectReferences=false` or any other gesture that tells SDKs to not do recursive operations.
 
 ### Isolated graph builds
+
 When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.
 
 Furthermore, running in this mode enforces that each `(project, global properties)` pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
@@ -374,9 +391,11 @@ Furthermore, running in this mode enforces that each `(project, global propertie
 This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.
 
 ### Single project isolated builds
+
 When building a single project in isolation, all project references' build results must be provided to the project externally. Specifically, the results will need to be [deserialized](#deserialization) from files and loaded into the build result cache in memory.
 
 When MSBuild runs in isolation mode, it fails the build when it detects:
+
 1. `MSBuild` task calls which cannot be served from the cache. Cache misses are illegal.
 2. `MSBuild` task calls to project files which were not defined in the `ProjectReference` item.
 
@@ -389,16 +408,20 @@ These incremental builds could be extended to the entire graph by keeping a proj
 Details on how isolation and cache files are implemented in MSBuild can be found [here](./static-graph-implementation-details.md).
 
 #### APIs
+
 Cache file information is provided via [`BuildParameters`](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one `BuildManager` `BeginBuild`/`EndBuild` session.
 
 Isolation constraints are turned on via [`BuildParameters.IsolateProjects`](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used, except when the `isolate:MessageUponIsolationViolation` switch is used.
 
 #### Command line
+
 Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
 Isolation constraints are turned on via `/isolate` (they are also implicitly activated when either input or output caches are used).
 
 #### Exempting references from isolation constraints
+
 In certain situations one may want to exempt a reference from isolation constraints. A few potential cases:
+
 - debugging / onboarding to isolation constraints
 - exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)
 - relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)
@@ -422,6 +445,7 @@ If multiple projects need to exempt the same reference, all of them need to add
 For now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.
 
 ## I/O Tracking
+
 To help facilitate caching of build outputs by a higher-order build engine, MSBuild needs to track all I/O that happens as part of a build.
 
 **OPEN ISSUE:** This isn't actually true in most scenarios. Today the MS internal build engine can wrap any arbitrary process to track the I/O that happens as part of its execution as well as its children. That's sufficient for all scenarios except compiler servers or an MSBuild server (see below). Additionally, if the MS internal build engine supports any other build type besides MSBuild (or older versions of MSBuild), it will still need to be able to detour the process itself anyway.
@@ -429,6 +453,7 @@ To help facilitate caching of build outputs by a higher-order build engine, MSBu
 **NOTE**: Based on the complexity and challenges involved, the feature of I/O tracking in MSBuild is currently on hold and not scheduled to be implemented. This section intends to describe these challenges and be a dump of the current thinking on the subject.
 
 ### Detours
+
 [Detours](https://github.com/microsoft/detours) will be used to intercept Windows API calls to track I/O. This is the same technology that [FileTracker](../../src/Utilities/TrackedDependencies/FileTracker.cs) and [FullTracking](../../src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs) use as well as what the MS internal build engine ("BuildXL Tracker") uses to track I/O.
 
 Today FileTracker and FullTracking are currently a bit specific to generating tlogs, and do not collect all the I/O operations we would want to collect like directory enumerations and probes. Additionally, the BuildXL Tracker implementation does not currently have the ability to attach to the currently running process.
@@ -438,11 +463,13 @@ Either existing implementation would require some work to fit this scenario. Bec
 Elsewhere in this spec the final Detours-based file tracking implementation will simply be referred to as "Tracker".
 
 ### Isolation requirement
+
 I/O Tracking will only be available when running isolated builds, as the current implementation of project yielding in MSBuild makes it exceedingly difficult to attribute any observed I/O to the correct project. Isolated builds make this feasible since each MSBuild node will be building exactly one project configuration at any given moment and each project configuration has a concrete start and stop time. This allows us to turn on I/O tracking for the MSBuild process and start and stop tracking with the project start and stop.
 
 **OPEN ISSUE:** For graph-based isolated builds, project evaluation happens in parallel on the main node. Any I/O that happens as part of evaluation should be reported for that specific project, but there's no good way to do that here.
 
 ### Tool servers
+
 Tool servers are long-lived processes which can be reused multiple times across builds. This causes problems for Tracker, as that long-lived process is not a child process of MSBuild, so many I/O operations would be missed.
 
 For example, when `SharedCompilation=true`, the Roslyn compiler (csc.exe) will launch in server mode. This causes the `Csc` task to connect to any existing csc.exe process and pass the compilation request over a named pipe.
diff --git a/documentation/specs/task-isolation-and-dependencies.md b/documentation/specs/task-isolation-and-dependencies.md
index 2ec96c8eb18..2994335dfc8 100644
--- a/documentation/specs/task-isolation-and-dependencies.md
+++ b/documentation/specs/task-isolation-and-dependencies.md
@@ -1,39 +1,50 @@
 # Task isolation
+
 ## Problem definition
+
 Tasks in MSBuild are dynamically loaded assemblies with potentially separate and colliding dependency trees. Currently MSBuild on .NET Core has no isolation between tasks and as such only one version of any given assembly can be loaded. Prime example of this is Newtonsoft.Json which has multiple versions, but all the tasks must agree on it to work.
 This problem is also described in #1754.
 
 ## Solution
+
 Use [`AssemblyLoadContext`](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-2.2) (ALC) to provide binding isolation for task assemblies. Each task assembly would be loaded into its own ALC instance.
-* The ALC would resolve all dependencies of the task assemblies (see dependency resolution below)
-* ALC would fallback to the Default for dependencies which the assembly doesn't carry with itself (frameworks and so on)
-* ALC would probably have to forcefully fallback for MSBuild assemblies since it's possible that tasks will carry these, but the system requires for the MSBuild assemblies to be shared.
+
+- The ALC would resolve all dependencies of the task assemblies (see dependency resolution below)
+- ALC would fallback to the Default for dependencies which the assembly doesn't carry with itself (frameworks and so on)
+- ALC would probably have to forcefully fallback for MSBuild assemblies since it's possible that tasks will carry these, but the system requires for the MSBuild assemblies to be shared.
 
 We also want to load groups of tasks which belong together into the same ALC (for example based on their location on disk) to improve performance. This will need some care as there's no guarantee that two random tasks have compatible dependency trees. As implemented, each task assembly is loaded into its own ALC.
 
 ## Potential risks
-* Has some small probability of causing breaks. Currently all assemblies from all tasks are loaded into the default context and thus are "visible" to everybody. Tasks with following properties might not work:
-  * Task has a dependency on an assembly, but it doesn't declare this dependency in its .deps.json and this dependency gets loaded through some other task. This is mostly fixable by implementing probing similar to today's behavior.
-  * Two tasks from different assemblies which somehow rely on sharing certain types. If the new system decides to load these in isolation they won't share types anymore and might not work.
-* Performance - task isolation inherently (and by design) leads to loading certain assemblies multiple times. This increases memory pressure and causes additional JITing and other related work.
+
+- Has some small probability of causing breaks. Currently all assemblies from all tasks are loaded into the default context and thus are "visible" to everybody. Tasks with following properties might not work:
+  - Task has a dependency on an assembly, but it doesn't declare this dependency in its .deps.json and this dependency gets loaded through some other task. This is mostly fixable by implementing probing similar to today's behavior.
+  - Two tasks from different assemblies which somehow rely on sharing certain types. If the new system decides to load these in isolation they won't share types anymore and might not work.
+- Performance - task isolation inherently (and by design) leads to loading certain assemblies multiple times. This increases memory pressure and causes additional JITing and other related work.
 
 ## Additional consideration
-* None of these changes would have any effect on MSBuild on .NET Framework
-* Task isolation alone could be achieved on existing MSBuild
+
+- None of these changes would have any effect on MSBuild on .NET Framework
+- Task isolation alone could be achieved on existing MSBuild
 
 # Task dependency resolution
+
 ## Problem definition
+
 Tasks with complex and specifically platform specific dependencies don't work out of the box. For example if a task uses [`LibGit2Sharp`](https://www.nuget.org/packages/LibGit2Sharp) package it will not work as is. `LibGit2Sharp` has native dependencies which are platform specific. While the package carries all of them, there's no built in support for the task to load the right ones. For example [source link](https://github.com/dotnet/sourcelink/blob/29b3197e824c05d03427c05d56700e4c704233e4/src/Microsoft.Build.Tasks.Git/GitLoaderContext.cs) runs into this problem.
 
 ## Solution
+
 .NET Core uses `.deps.json` files to describe dependencies of components. It would be natural to treat task assemblies as components and use associated .deps.json file to determine their dependencies. This would make the system work nicely end to end with the .NET Core CLI/SDK and VS integration.
 In .NET Core 3 there's a new type [`AssemblyDependencyResolver`](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyDependencyResolver.cs) which implements parsing and processing of a `.deps.json` for a component (or assembly). The usage is to create an instance of the resolver pointing to the assembly (in MSBuild case the task assembly). The resolver parses the `.deps.json` and stores the information. It exposes two methods to resolve managed and native dependencies.
 It was designed to be used as the underlying piece to implement custom ALC. So it would work nicely with task isolation above.
 
 ## Potential risks
-* Small probability of breaking tasks which have `.deps.json` with them and those are not correct. With this change the file would suddenly be used and could cause either load failures or different versions of assemblies to get loaded.
+
+- Small probability of breaking tasks which have `.deps.json` with them and those are not correct. With this change the file would suddenly be used and could cause either load failures or different versions of assemblies to get loaded.
 
 ## Additional consideration
-* Task dependency resolution requires APIs which are only available in .NET Core 3.0 (no plan to backport), as such MSBuild will have to target netcoreapp3.0 to use these APIs.
+
+- Task dependency resolution requires APIs which are only available in .NET Core 3.0 (no plan to backport), as such MSBuild will have to target netcoreapp3.0 to use these APIs.
 
 We decided not to implement `AssemblyDependencyResolver` in the .NET Core 3.x timeframe because of the uncertain impact of the change. We should reconsider in the .NET 5 timeframe.
diff --git a/documentation/specs/test-target.md b/documentation/specs/test-target.md
index 7726f1f6971..e5818eb6c81 100644
--- a/documentation/specs/test-target.md
+++ b/documentation/specs/test-target.md
@@ -1,62 +1,77 @@
-## MSBuild Test Target and Task 
+# MSBuild Test Target and Task
+
 See: [MSBuild Test Target](https://github.com/dotnet/msbuild/pull/9193)
 
-### Motivation
+## Motivation
+
 The primary motivation of the MSBuild Test Target is to offer a convienent and standardardized way for executing tests within the msbuild environment. This is inspired by the simplicity of the `dotnet test` command. The proposed command for initiating test within MSBuild would be `msbuild /t:Test`
 
 Another significatnt benefit of integrating this target is to faciliatet the caching of test executions, using MSBuild project caching capabilities. This enhancement will optimize the testing process by reducing test runs which could significantly reduce time spent building and testing, as tests would only execute, (after the initial run) if there are changes to those tests. As an example running with [MSBuildCache](https://github.com/microsoft/MSBuildCache) we can cache both build and test executions. Functionally, this means skipping test executions that have been determined to have not changed.
 Example usage:
 `msbuild /graph /restore:false /m /nr:false /reportfileaccesses /t:"Build;Test"`
 
-### Design Overview
+## Design Overview
+
 The 'Microsoft.Common.Test.targets' file contains a stub test target.
-```
+
+```xml
 <Project>
     <Target Name="Test"></Target>
 </Project>
 ```
+
 This target serves a placeholder and entry point for test target implementations.
 
-#### Conditional Import
-* This stub target is conditionally imported, determined by a condition named 
+### Conditional Import
+
+- This stub target is conditionally imported, determined by a condition named
 `$(UseMSBuildTestInfrastructure)`.
-* This condition allows for users to opt-in to this test target, which helps to prevent breaking changes, with respect the the target name, since there are likely 'Test' targets that exist in the wild already.
+- This condition allows for users to opt-in to this test target, which helps to prevent breaking changes, with respect the the target name, since there are likely 'Test' targets that exist in the wild already.
 
 The 'Microsoft.Common.CurrentVersion.targets' file contains.
-```
+
+```xml
   <PropertyGroup>
     <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
   </PropertyGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.Common.Test.targets" Condition="'$(UseMSBuildTestInfrastructure)' == 'true'"/>
 
 ```
-#### Extensibility for Test Runners
-* Test runner implemenations can hook into the provided stub using the `AfterTargets` property.
-* This approach enables different test runners to extend the basic funcionarlity of the test target.
+
+### Extensibility for Test Runners
+
+- Test runner implemenations can hook into the provided stub using the `AfterTargets` property.
+- This approach enables different test runners to extend the basic funcionarlity of the test target.
 
 For instance, an implementation for running VSTest would look like:
-```
+
+```xml
 <Target Name="RunVSTest" AfterTargets="Test">
   <!-- Implementation details here -->
 </Target>
 ```
 
-#### Usage Scenario
-* Users who wish to utilize this target will set the `$(UseMSBuildTestInfrastructure)` condition in their project file, rsp or via the command line.
-* By executing `msbuild /t:Test`, the MSBuild engine will envoke the `Test` taget, which in turn triggers any test runner targets defined to run after it.
+### Usage Scenario
+
+- Users who wish to utilize this target will set the `$(UseMSBuildTestInfrastructure)` condition in their project file, rsp or via the command line.
+- By executing `msbuild /t:Test`, the MSBuild engine will envoke the `Test` taget, which in turn triggers any test runner targets defined to run after it.
+
+## Default Task Implementation
 
-### Default Task Implementation
 See: [MSBuild Test Task](https://github.com/microsoft/MSBuildSdks/pull/473)
 
-#### Nuget package for default implementaion
-* The default implementation will be provided through a nuget package.
-* This package will contain an MSBuild Task deigned to execute `vstest.console.exe`.
+### Nuget package for default implementaion
+
+- The default implementation will be provided through a nuget package.
+- This package will contain an MSBuild Task deigned to execute `vstest.console.exe`.
+
+### MSBuild Task Functionality
+
+- The core of this implemenation is an MSBuild task that interfaces with `vstest.console.exe`.
+- This task will accept arguments as properties and pass them directly into the command line test runner.
 
-#### MSBuild Task Functionality
-* The core of this implemenation is an MSBuild task that interfaces with `vstest.console.exe`.
-* This task will accept arguments as properties and pass them directly into the command line test runner.
+### Using The Default Implementation
 
-#### Using The Default Implementation
-* Users would install the provided Nuget Package to incorporate it into their projects.
-* Add the package to their GlobalPackageReferences or specific projects.
-* Once integrated, executing `msbuild /t:Test` would trigger the MSBuild Task, ultimately executing `vstest.console.exe`.
+- Users would install the provided Nuget Package to incorporate it into their projects.
+- Add the package to their GlobalPackageReferences or specific projects.
+- Once integrated, executing `msbuild /t:Test` would trigger the MSBuild Task, ultimately executing `vstest.console.exe`.
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 549504dec70..1f86224d271 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -2,9 +2,9 @@
 <Dependencies>
   <ProductDependencies>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.25081.6">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.25170.3">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>1cec3b4a8fb07138136a1ca1e04763bfcf7841db</Sha>
+      <Sha>6968f7059f4418e985febe704a3b1320f9e5887d</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
@@ -141,13 +141,13 @@
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>181b65dad9f440c7a31fe673abc59c258f224ada</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25164.10">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25171.27">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>517e95f9430d387e0e387a23fa2c8351a0863c4a</Sha>
+      <Sha>1def752c5d33903795069ccddb78599ba6da39d3</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.14.0-3.25164.10">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.14.0-3.25171.27">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>517e95f9430d387e0e387a23fa2c8351a0863c4a</Sha>
+      <Sha>1def752c5d33903795069ccddb78599ba6da39d3</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25164.2">
diff --git a/eng/Versions.props b/eng/Versions.props
index cc5d3cf10a1..3093e9241f6 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -6,7 +6,12 @@
     <PackageValidationBaselineVersion>17.14.0-preview-25161-14</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
-    <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
+    <!--
+      Don't use shipping versions when building in the VMR unless the VMR directs the build to use shipping versions.
+      This can cause issues when building downstream repos in the orchestrated build if the time MSBuild
+      is built crosses a UTC date boundary.
+    -->
+    <DotNetUseShippingVersions Condition="'$(DotNetBuildOrchestrator)' != 'true'">true</DotNetUseShippingVersions>
     <!-- Workaround for https://github.com/dotnet/roslyn/issues/35793 -->
     <SemanticVersioningV1>true</SemanticVersioningV1>
     <MicroBuildPluginsSwixBuildVersion>1.1.87</MicroBuildPluginsSwixBuildVersion>
@@ -25,8 +30,9 @@
        already consuming the newest version of these same dependencies. -->
   <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' == 'true'">
     <!-- Use newest package versions. -->
-    <SystemMemoryVersion>4.6.0</SystemMemoryVersion>
-    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.0</SystemRuntimeCompilerServicesUnsafeVersion>
+    <SystemMemoryVersion>4.6.2</SystemMemoryVersion>
+    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.1</SystemRuntimeCompilerServicesUnsafeVersion>
+    <MicrosoftIORedistVersion>6.1.2</MicrosoftIORedistVersion>
   </PropertyGroup>
   <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' != 'true'">
     <!-- Keep using older versions. Upgrade carefully. -->
@@ -37,10 +43,10 @@
     -->
     <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
+    <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
   </PropertyGroup>
   <PropertyGroup>
     <!-- manually maintained versions -->
-    <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
     <MicrosoftVisualStudioOpenTelemetryVersion>0.2.104-beta</MicrosoftVisualStudioOpenTelemetryVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
   </PropertyGroup>
@@ -78,7 +84,7 @@
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
     <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25164.2</MicrosoftDotNetXUnitExtensionsVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25164.10</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25171.27</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.14.0-preview.1.66</NuGetBuildTasksVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 5a1eb10715b..fd8178dcadd 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -101,7 +101,7 @@ public void UnregisterPacketHandler(NodePacketType packetType)
                 throw new NotImplementedException();
             }
 
-            public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+            public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
             {
                 throw new NotImplementedException();
             }
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 0abf86a2aa2..5cceeb22d66 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -7,7 +7,6 @@
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.IO.Pipes;
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Client;
@@ -75,19 +74,9 @@ public sealed class MSBuildClient
         private readonly string _pipeName;
 
         /// <summary>
-        /// The named pipe stream for client-server communication.
+        /// The named pipe client for client-server communication.
         /// </summary>
-        private NamedPipeClientStream _nodeStream = null!;
-
-        /// <summary>
-        /// A way to cache a byte array when writing out packets
-        /// </summary>
-        private readonly MemoryStream _packetMemoryStream;
-
-        /// <summary>
-        /// A binary writer to help write into <see cref="_packetMemoryStream"/>
-        /// </summary>
-        private readonly BinaryWriter _binaryWriter;
+        private NodePipeClient _pipeClient = null!;
 
         /// <summary>
         /// Used to estimate the size of the build with an ETW trace.
@@ -130,26 +119,14 @@ public MSBuildClient(
             // Client <-> Server communication stream
             _handshake = GetHandshake();
             _pipeName = OutOfProcServerNode.GetPipeName(_handshake);
-            _packetMemoryStream = new MemoryStream();
-            _binaryWriter = new BinaryWriter(_packetMemoryStream);
 
             CreateNodePipeStream();
         }
 
         private void CreateNodePipeStream()
         {
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            _nodeStream = new NamedPipeClientStream(
-                serverName: ".",
-                _pipeName,
-                PipeDirection.InOut,
-                PipeOptions.Asynchronous
-#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                | PipeOptions.CurrentUserOnly
-#endif
-            );
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            _packetPump = new MSBuildClientPacketPump(_nodeStream);
+            _pipeClient = new NodePipeClient(_pipeName, _handshake);
+            _packetPump = new MSBuildClientPacketPump(_pipeClient);
         }
 
         /// <summary>
@@ -423,7 +400,7 @@ private bool TrySendPacket(Func<INodePacket> packetResolver)
             try
             {
                 packet = packetResolver();
-                WritePacket(_nodeStream, packet);
+                _pipeClient.WritePacket(packet);
                 CommunicationsUtilities.Trace("Command packet of type '{0}' sent...", packet.Type);
             }
             catch (Exception ex)
@@ -621,7 +598,7 @@ private bool TryConnectToServer(int timeoutMilliseconds)
                 tryAgain = false;
                 try
                 {
-                    NodeProviderOutOfProcBase.ConnectToPipeStream(_nodeStream, _pipeName, _handshake, Math.Max(1, timeoutMilliseconds - (int)sw.ElapsedMilliseconds));
+                    _pipeClient.ConnectToServer(Math.Max(1, timeoutMilliseconds - (int)sw.ElapsedMilliseconds));
                 }
                 catch (Exception ex)
                 {
@@ -644,30 +621,5 @@ private bool TryConnectToServer(int timeoutMilliseconds)
 
             return true;
         }
-
-        private void WritePacket(Stream nodeStream, INodePacket packet)
-        {
-            MemoryStream memoryStream = _packetMemoryStream;
-            memoryStream.SetLength(0);
-
-            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(memoryStream);
-
-            // Write header
-            memoryStream.WriteByte((byte)packet.Type);
-
-            // Pad for packet length
-            _binaryWriter.Write(0);
-
-            // Reset the position in the write buffer.
-            packet.Translate(writeTranslator);
-
-            int packetStreamLength = (int)memoryStream.Position;
-
-            // Now write in the actual packet length
-            memoryStream.Position = 1;
-            _binaryWriter.Write(packetStreamLength - 5);
-
-            nodeStream.Write(memoryStream.GetBuffer(), 0, packetStreamLength);
-        }
     }
 }
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index a7234030b5c..34ec9d28df1 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -2,15 +2,11 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Buffers.Binary;
 using System.Collections.Concurrent;
-using System.IO;
 using System.Threading;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-#if !FEATURE_APM
 using System.Threading.Tasks;
-#endif
 
 namespace Microsoft.Build.BackEnd.Client
 {
@@ -46,25 +42,15 @@ internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketF
         /// </summary>
         private readonly NodePacketFactory _packetFactory;
 
-        /// <summary>
-        /// The memory stream for a read buffer.
-        /// </summary>
-        private readonly MemoryStream _readBufferMemoryStream;
-
         /// <summary>
         /// The thread which runs the asynchronous packet pump
         /// </summary>
         private Thread? _packetPumpThread;
 
         /// <summary>
-        /// The stream from where to read packets.
-        /// </summary>
-        private readonly Stream _stream;
-
-        /// <summary>
-        /// The binary translator for reading packets.
+        /// The pipe client from where to read packets.
         /// </summary>
-        private readonly ITranslator _binaryReadTranslator;
+        private readonly NodePipeClient _pipeClient;
 
         /// <summary>
         /// True if this side is gracefully disconnecting.
@@ -73,11 +59,12 @@ internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketF
         /// </summary>
         private bool _isServerDisconnecting;
 
-        public MSBuildClientPacketPump(Stream stream)
+        public MSBuildClientPacketPump(NodePipeClient pipeClient)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(stream);
+            ErrorUtilities.VerifyThrowArgumentNull(pipeClient);
 
-            _stream = stream;
+            _pipeClient = pipeClient;
+            _pipeClient.RegisterPacketFactory(this);
             _isServerDisconnecting = false;
             _packetFactory = new NodePacketFactory();
 
@@ -85,9 +72,6 @@ public MSBuildClientPacketPump(Stream stream)
             PacketReceivedEvent = new AutoResetEvent(false);
             PacketPumpCompleted = new ManualResetEvent(false);
             _packetPumpShutdownEvent = new ManualResetEvent(false);
-
-            _readBufferMemoryStream = new MemoryStream();
-            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());
         }
 
         #region INodePacketFactory Members
@@ -113,14 +97,13 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         }
 
         /// <summary>
-        /// Deserializes and routes a packer to the appropriate handler.
+        /// Deserializes a packet.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator to use as a source for packet data.</param>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
-            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+            return _packetFactory.DeserializePacket(packetType, translator);
         }
 
         /// <summary>
@@ -182,21 +165,16 @@ public void Stop()
         /// </remarks>
         private void PacketPumpProc()
         {
-            RunReadLoop(_stream, _packetPumpShutdownEvent);
+            RunReadLoop(_pipeClient, _packetPumpShutdownEvent);
         }
 
-        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)
+        private void RunReadLoop(NodePipeClient pipeClient, ManualResetEvent localPacketPumpShutdownEvent)
         {
             CommunicationsUtilities.Trace("Entering read loop.");
 
             try
             {
-                byte[] headerByte = new byte[5];
-#if FEATURE_APM
-                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);
-#else
-                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length).AsTask();
-#endif
+                Task<INodePacket> readTask = pipeClient.ReadPacketAsync();
 
                 bool continueReading = true;
                 do
@@ -208,11 +186,7 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                     WaitHandle[] handles =
                     [
                         localPacketPumpShutdownEvent,
-#if FEATURE_APM
-                        result.AsyncWaitHandle
-#else
                         ((IAsyncResult)readTask).AsyncWaitHandle
-#endif
                     ];
                     int waitId = WaitHandle.WaitAny(handles);
                     switch (waitId)
@@ -224,80 +198,27 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                             break;
 
                         case 1:
+                            INodePacket packet = readTask.GetAwaiter().GetResult();
+
+                            if (packet.Type == NodePacketType.NodeShutdown)
                             {
-                                // Client recieved a packet header. Read the rest of it.
-                                int headerBytesRead = 0;
-#if FEATURE_APM
-                                headerBytesRead = localStream.EndRead(result);
-#else
-                                headerBytesRead = readTask.Result;
-#endif
-
-                                if ((headerBytesRead != headerByte.Length) && !localPacketPumpShutdownEvent.WaitOne(0))
+                                if (!_isServerDisconnecting)
                                 {
-                                    // Incomplete read. Abort.
-                                    if (headerBytesRead == 0)
-                                    {
-                                        if (_isServerDisconnecting)
-                                        {
-                                            continueReading = false;
-                                            break;
-                                        }
-
-                                        ErrorUtilities.ThrowInternalError("Server disconnected abruptly");
-                                    }
-                                    else
-                                    {
-                                        ErrorUtilities.ThrowInternalError("Incomplete header read.  {0} of {1} bytes read", headerBytesRead, headerByte.Length);
-                                    }
+                                    ErrorUtilities.ThrowInternalError("Server disconnected abruptly.");
                                 }
 
-                                NodePacketType packetType = (NodePacketType)Enum.ToObject(typeof(NodePacketType), headerByte[0]);
-
-                                int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(headerByte, 1, 4));
-                                int packetBytesRead = 0;
-
-                                _readBufferMemoryStream.Position = 0;
-                                _readBufferMemoryStream.SetLength(packetLength);
-                                byte[] packetData = _readBufferMemoryStream.GetBuffer();
-
-                                while (packetBytesRead < packetLength)
-                                {
-                                    int bytesRead = localStream.Read(packetData, packetBytesRead, packetLength - packetBytesRead);
-                                    if (bytesRead == 0)
-                                    {
-                                        // Incomplete read.  Abort.
-                                        ErrorUtilities.ThrowInternalError("Incomplete packet read. {0} of {1} bytes read", packetBytesRead, packetLength);
-                                    }
-
-                                    packetBytesRead += bytesRead;
-                                }
+                                continueReading = false;
+                                break;
+                            }
 
-                                try
-                                {
-                                    _packetFactory.DeserializeAndRoutePacket(0, packetType, _binaryReadTranslator);
-                                }
-                                catch
-                                {
-                                    // Error while deserializing or handling packet. Logging additional info.
-                                    CommunicationsUtilities.Trace("Packet factory failed to receive package. Exception while deserializing packet {0}.", packetType);
-                                    throw;
-                                }
+                            _packetFactory.RoutePacket(0, packet);
 
-                                if (packetType == NodePacketType.ServerNodeBuildResult)
-                                {
-                                    continueReading = false;
-                                }
-                                else
-                                {
-                                    // Start reading the next package header.
-#if FEATURE_APM
-                                    result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);
-#else
-                                    readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length).AsTask();
-#endif
-                                }
+                            continueReading = packet.Type != NodePacketType.ServerNodeBuildResult;
+                            if (continueReading)
+                            {
+                                readTask = pipeClient.ReadPacketAsync();
                             }
+
                             break;
 
                         default:
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index b0031746031..96cb184f1c2 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -240,19 +240,13 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         }
 
         /// <summary>
-        /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
+        /// Takes a serializer and deserializes the packet.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
-            if (packetType == NodePacketType.NodeShutdown)
-            {
-                RemoveNodeFromMapping(nodeId);
-            }
-
-            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+            return _packetFactory.DeserializePacket(packetType, translator);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 61ff495b01f..a2709281af4 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -285,10 +285,11 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         /// <summary>
         /// Deserializes and routes a packet.  Not used in the in-proc node.
         /// </summary>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
             // Not used
             ErrorUtilities.ThrowInternalErrorUnreachable();
+            return null;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index b1e380b5fa2..d346a6f3fe6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -1,32 +1,22 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#nullable disable
+
 using System;
-using System.Buffers.Binary;
-using System.Collections.Generic;
 using System.Collections.Concurrent;
+using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
-using System.IO.Pipes;
 using System.Diagnostics;
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
-#if FEATURE_PIPE_SECURITY
-using System.Security.Principal;
-#endif
-
-#if FEATURE_APM
-using Microsoft.Build.Eventing;
-#endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Task = System.Threading.Tasks.Task;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd.Logging;
 
-#nullable disable
-
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
@@ -35,11 +25,6 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal abstract class NodeProviderOutOfProcBase
     {
-        /// <summary>
-        /// The maximum number of bytes to write
-        /// </summary>
-        private const int MaxPacketWriteSize = 1048576;
-
         /// <summary>
         /// The number of times to retry creating an out-of-proc node.
         /// </summary>
@@ -55,9 +40,6 @@ internal abstract class NodeProviderOutOfProcBase
         /// </summary>
         private const int TimeoutForWaitForExit = 30000;
 
-#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-        private static readonly WindowsIdentity s_currentWindowsIdentity = WindowsIdentity.GetCurrent();
-#endif
         /// <summary>
         /// The build component host.
         /// </summary>
@@ -163,21 +145,18 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                 int timeout = 30;
 
                 // Attempt to connect to the process with the handshake without low priority.
-                Stream nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, false));
+                NodePipeClient pipeClient = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, false));
 
-                if (nodeStream == null)
-                {
-                    // If we couldn't connect attempt to connect to the process with the handshake including low priority.
-                    nodeStream = TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, true));
-                }
+                // If we couldn't connect attempt to connect to the process with the handshake including low priority.
+                pipeClient ??= TryConnectToProcess(nodeProcess.Id, timeout, NodeProviderOutOfProc.GetHandshake(nodeReuse, true));
 
-                if (nodeStream != null)
+                if (pipeClient != null)
                 {
                     // If we're able to connect to such a process, send a packet requesting its termination
                     CommunicationsUtilities.Trace("Shutting down node with pid = {0}", nodeProcess.Id);
-                    NodeContext nodeContext = new NodeContext(0, nodeProcess, nodeStream, factory, terminateNode);
+                    NodeContext nodeContext = new(0, nodeProcess, pipeClient, factory, terminateNode);
                     nodeContext.SendData(new NodeBuildComplete(false /* no node reuse */));
-                    nodeStream.Dispose();
+                    pipeClient.Dispose();
                 }
             }
         }
@@ -284,8 +263,8 @@ bool TryReuseAnyFromPossibleRunningNodes(int currentProcessId, int nodeId)
                     _processesToIgnore.TryAdd(nodeLookupKey, default);
 
                     // Attempt to connect to each process in turn.
-                    Stream nodeStream = TryConnectToProcess(nodeToReuse.Id, 0 /* poll, don't wait for connections */, hostHandshake);
-                    if (nodeStream != null)
+                    NodePipeClient pipeClient = TryConnectToProcess(nodeToReuse.Id, 0 /* poll, don't wait for connections */, hostHandshake);
+                    if (pipeClient != null)
                     {
                         // Connection successful, use this node.
                         CommunicationsUtilities.Trace("Successfully connected to existed node {0} which is PID {1}", nodeId, nodeToReuse.Id);
@@ -295,7 +274,7 @@ bool TryReuseAnyFromPossibleRunningNodes(int currentProcessId, int nodeId)
                             BuildEventContext = new BuildEventContext(nodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId)
                         });
 
-                        CreateNodeContext(nodeId, nodeToReuse, nodeStream);
+                        CreateNodeContext(nodeId, nodeToReuse, pipeClient);
                         return true;
                     }
                 }
@@ -344,13 +323,13 @@ bool StartNewNode(int nodeId)
                     // to the debugger process. Instead, use MSBUILDDEBUGONSTART=1
 
                     // Now try to connect to it.
-                    Stream nodeStream = TryConnectToProcess(msbuildProcess.Id, TimeoutForNewNodeCreation, hostHandshake);
-                    if (nodeStream != null)
+                    NodePipeClient pipeClient = TryConnectToProcess(msbuildProcess.Id, TimeoutForNewNodeCreation, hostHandshake);
+                    if (pipeClient != null)
                     {
                         // Connection successful, use this node.
                         CommunicationsUtilities.Trace("Successfully connected to created node {0} which is PID {1}", nodeId, msbuildProcess.Id);
 
-                        CreateNodeContext(nodeId, msbuildProcess, nodeStream);
+                        CreateNodeContext(nodeId, msbuildProcess, pipeClient);
                         return true;
                     }
 
@@ -379,9 +358,9 @@ bool StartNewNode(int nodeId)
                 return false;
             }
 
-            void CreateNodeContext(int nodeId, Process nodeToReuse, Stream nodeStream)
+            void CreateNodeContext(int nodeId, Process nodeToReuse, NodePipeClient pipeClient)
             {
-                NodeContext nodeContext = new(nodeId, nodeToReuse, nodeStream, factory, terminateNode);
+                NodeContext nodeContext = new(nodeId, nodeToReuse, pipeClient, factory, terminateNode);
                 nodeContexts.Enqueue(nodeContext);
                 createNode(nodeContext);
             }
@@ -423,52 +402,22 @@ private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessI
 #endif
         }
 
-#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-        // This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code
-        //  on non-Windows operating systems
-        private static void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStream)
-        {
-            SecurityIdentifier identifier = s_currentWindowsIdentity.Owner;
-#if FEATURE_PIPE_SECURITY
-            PipeSecurity remoteSecurity = nodeStream.GetAccessControl();
-#else
-            var remoteSecurity = new PipeSecurity(nodeStream.SafePipeHandle, System.Security.AccessControl.AccessControlSections.Access |
-                System.Security.AccessControl.AccessControlSections.Owner | System.Security.AccessControl.AccessControlSections.Group);
-#endif
-            IdentityReference remoteOwner = remoteSecurity.GetOwner(typeof(SecurityIdentifier));
-            if (remoteOwner != identifier)
-            {
-                CommunicationsUtilities.Trace("The remote pipe owner {0} does not match {1}", remoteOwner.Value, identifier.Value);
-                throw new UnauthorizedAccessException();
-            }
-        }
-#endif
-
         /// <summary>
         /// Attempts to connect to the specified process.
         /// </summary>
-        private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
+        private NodePipeClient TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
             string pipeName = NamedPipeUtil.GetPlatformSpecificPipeName(nodeProcessId);
 
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            NamedPipeClientStream nodeStream = new NamedPipeClientStream(
-                serverName: ".",
-                pipeName,
-                PipeDirection.InOut,
-                PipeOptions.Asynchronous
-#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                | PipeOptions.CurrentUserOnly
-#endif
-            );
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            CommunicationsUtilities.Trace("Attempting connect to PID {0} with pipe {1} with timeout {2} ms", nodeProcessId, pipeName, timeout);
+            NodePipeClient pipeClient = new(pipeName, handshake);
+
+            CommunicationsUtilities.Trace("Attempting connect to PID {0}", nodeProcessId);
 
             try
             {
-                ConnectToPipeStream(nodeStream, pipeName, handshake, timeout);
-                return nodeStream;
+                pipeClient.ConnectToServer(timeout);
+                return pipeClient;
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
@@ -480,56 +429,12 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake han
                 CommunicationsUtilities.Trace("Failed to connect to pipe {0}. {1}", pipeName, e.Message.TrimEnd());
 
                 // If we don't close any stream, we might hang up the child
-                nodeStream?.Dispose();
+                pipeClient?.Dispose();
             }
 
             return null;
         }
 
-        /// <summary>
-        /// Connect to named pipe stream and ensure validate handshake and security.
-        /// </summary>
-        /// <remarks>
-        /// Reused by MSBuild server client <see cref="Microsoft.Build.Experimental.MSBuildClient"/>.
-        /// </remarks>
-        internal static void ConnectToPipeStream(NamedPipeClientStream nodeStream, string pipeName, Handshake handshake, int timeout)
-        {
-            nodeStream.Connect(timeout);
-
-#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-            if (NativeMethodsShared.IsWindows)
-            {
-                // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has
-                // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to
-                // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can
-                // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up
-                // remote node could set the owner to something else would also let it change owners on other objects, so
-                // this would be a security flaw upstream of us.
-                ValidateRemotePipeSecurityOnWindows(nodeStream);
-            }
-#endif
-
-            int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
-            for (int i = 0; i < handshakeComponents.Length; i++)
-            {
-                CommunicationsUtilities.Trace("Writing handshake part {0} ({1}) to pipe {2}", i, handshakeComponents[i], pipeName);
-                nodeStream.WriteIntForHandshake(handshakeComponents[i]);
-            }
-
-            // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
-            nodeStream.WriteEndOfHandshakeSignal();
-
-            CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
-
-#if NETCOREAPP2_1_OR_GREATER
-            nodeStream.ReadEndOfHandshakeSignal(true, timeout);
-#else
-            nodeStream.ReadEndOfHandshakeSignal(true);
-#endif
-            // We got a connection.
-            CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", pipeName);
-        }
-
         /// <summary>
         /// Class which wraps up the communications infrastructure for a given node.
         /// </summary>
@@ -542,14 +447,13 @@ private enum ExitPacketState
                 ExitPacketSent
             }
 
-            // The pipe(s) used to communicate with the node.
-            private Stream _clientToServerStream;
-            private Stream _serverToClientStream;
+            // The pipe client used to communicate with the node.
+            private readonly NodePipeClient _pipeClient;
 
             /// <summary>
             /// The factory used to create packets from data read off the pipe.
             /// </summary>
-            private INodePacketFactory _packetFactory;
+            private readonly INodePacketFactory _packetFactory;
 
             /// <summary>
             /// The node id assigned by the node provider.
@@ -563,23 +467,6 @@ private enum ExitPacketState
 
             internal Process Process { get { return _process; } }
 
-            /// <summary>
-            /// An array used to store the header byte for each packet when read.
-            /// </summary>
-            private byte[] _headerByte;
-
-            /// <summary>
-            /// A buffer typically big enough to handle a packet body.
-            /// We use this as a convenient way to manage and cache a byte[] that's resized
-            /// automatically to fit our payload.
-            /// </summary>
-            private MemoryStream _readBufferMemoryStream;
-
-            /// <summary>
-            /// A reusable buffer for writing packets.
-            /// </summary>
-            private MemoryStream _writeBufferMemoryStream;
-
             /// <summary>
             /// A queue used for enqueuing packets to write to the stream asynchronously.
             /// </summary>
@@ -602,28 +489,19 @@ private enum ExitPacketState
             /// </summary>
             private ExitPacketState _exitPacketState;
 
-            /// <summary>
-            /// Per node read buffers
-            /// </summary>
-            private BinaryReaderFactory _binaryReaderFactory;
-
             /// <summary>
             /// Constructor.
             /// </summary>
             public NodeContext(int nodeId, Process process,
-                Stream nodePipe,
+                NodePipeClient pipeClient,
                 INodePacketFactory factory, NodeContextTerminateDelegate terminateDelegate)
             {
                 _nodeId = nodeId;
                 _process = process;
-                _clientToServerStream = nodePipe;
-                _serverToClientStream = nodePipe;
+                _pipeClient = pipeClient;
+                _pipeClient.RegisterPacketFactory(factory);
                 _packetFactory = factory;
-                _headerByte = new byte[5]; // 1 for the packet type, 4 for the body length
-                _readBufferMemoryStream = new MemoryStream();
-                _writeBufferMemoryStream = new MemoryStream();
                 _terminateDelegate = terminateDelegate;
-                _binaryReaderFactory = InterningBinaryReader.CreateSharedBuffer();
             }
 
             /// <summary>
@@ -636,73 +514,49 @@ public NodeContext(int nodeId, Process process,
             /// </summary>
             public void BeginAsyncPacketRead()
             {
-#if FEATURE_APM
-                _clientToServerStream.BeginRead(_headerByte, 0, _headerByte.Length, HeaderReadComplete, this);
-#else
-                ThreadPool.QueueUserWorkItem(delegate
-                {
-                    var ignored = RunPacketReadLoopAsync();
-                });
-#endif
+                _ = ThreadPool.QueueUserWorkItem(_ => _ = RunPacketReadLoopAsync());
             }
 
-#if !FEATURE_APM
             public async Task RunPacketReadLoopAsync()
             {
-                while (true)
+                INodePacket packet = null;
+
+                while (packet?.Type != NodePacketType.NodeShutdown)
                 {
                     try
                     {
-                        int bytesRead = await CommunicationsUtilities.ReadAsync(_clientToServerStream, _headerByte, _headerByte.Length);
-                        if (!ProcessHeaderBytesRead(bytesRead))
-                        {
-                            return;
-                        }
+                        packet = await _pipeClient.ReadPacketAsync().ConfigureAwait(false);
                     }
                     catch (IOException e)
                     {
-                        CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in RunPacketReadLoopAsync: {0}", e);
-                        _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                        Close();
-                        return;
+                        CommunicationsUtilities.Trace(_nodeId, "COMMUNICATIONS ERROR (HRC) Node: {0} Process: {1} Exception: {2}", _nodeId, _process.Id, e.Message);
+                        packet = new NodeShutdown(NodeShutdownReason.ConnectionFailed);
                     }
 
-                    NodePacketType packetType = (NodePacketType)_headerByte[0];
-                    int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerByte, 1, 4));
-
-                    _readBufferMemoryStream.SetLength(packetLength);
-                    byte[] packetData = _readBufferMemoryStream.GetBuffer();
-
-                    try
+                    if (packet.Type == NodePacketType.NodeShutdown && (packet as NodeShutdown).Reason == NodeShutdownReason.ConnectionFailed)
                     {
-                        int bytesRead = await CommunicationsUtilities.ReadAsync(_clientToServerStream, packetData, packetLength);
-                        if (!ProcessBodyBytesRead(bytesRead, packetLength, packetType))
+                        try
                         {
-                            return;
+                            if (_process.HasExited)
+                            {
+                                CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} has exited.", _process.Id);
+                            }
+                            else
+                            {
+                                CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} is still running.", _process.Id);
+                            }
+                        }
+                        catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+                        {
+                            CommunicationsUtilities.Trace(_nodeId, "Unable to retrieve remote process information. {0}", e);
                         }
-                    }
-                    catch (IOException e)
-                    {
-                        CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in RunPacketReadLoopAsync (Reading): {0}", e);
-                        _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                        Close();
-                        return;
-                    }
-
-                    // Read and route the packet.
-                    if (!ReadAndRoutePacket(packetType, packetData, packetLength))
-                    {
-                        return;
                     }
 
-                    if (packetType == NodePacketType.NodeShutdown)
-                    {
-                        Close();
-                        return;
-                    }
+                    _packetFactory.RoutePacket(_nodeId, packet);
                 }
+
+                Close();
             }
-#endif
 
             /// <summary>
             /// Sends the specified packet to this node asynchronously.
@@ -748,37 +602,11 @@ private void DrainPacketQueue()
                     static async Task SendDataCoreAsync(Task _, object state)
                     {
                         NodeContext context = (NodeContext)state;
-                        while (context._packetWriteQueue.TryDequeue(out var packet))
+                        while (context._packetWriteQueue.TryDequeue(out INodePacket packet))
                         {
-                            MemoryStream writeStream = context._writeBufferMemoryStream;
-
-                            // clear the buffer but keep the underlying capacity to avoid reallocations
-                            writeStream.SetLength(0);
-
-                            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(writeStream);
                             try
                             {
-                                writeStream.WriteByte((byte)packet.Type);
-
-                                // Pad for the packet length
-                                WriteInt32(writeStream, 0);
-                                packet.Translate(writeTranslator);
-
-                                int writeStreamLength = (int)writeStream.Position;
-
-                                // Now plug in the real packet length
-                                writeStream.Position = 1;
-                                WriteInt32(writeStream, writeStreamLength - 5);
-
-                                byte[] writeStreamBuffer = writeStream.GetBuffer();
-
-                                for (int i = 0; i < writeStreamLength; i += MaxPacketWriteSize)
-                                {
-                                    int lengthToWrite = Math.Min(writeStreamLength - i, MaxPacketWriteSize);
-#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-                                    await context._serverToClientStream.WriteAsync(writeStreamBuffer, i, lengthToWrite, CancellationToken.None);
-#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-                                }
+                                await context._pipeClient.WritePacketAsync(packet).ConfigureAwait(false);
 
                                 if (IsExitPacket(packet))
                                 {
@@ -804,27 +632,12 @@ private static bool IsExitPacket(INodePacket packet)
                 return packet is NodeBuildComplete buildCompletePacket && !buildCompletePacket.PrepareForReuse;
             }
 
-            /// <summary>
-            /// Avoid having a BinaryWriter just to write a 4-byte int
-            /// </summary>
-            private static void WriteInt32(MemoryStream stream, int value)
-            {
-                stream.WriteByte((byte)value);
-                stream.WriteByte((byte)(value >> 8));
-                stream.WriteByte((byte)(value >> 16));
-                stream.WriteByte((byte)(value >> 24));
-            }
-
             /// <summary>
             /// Closes the node's context, disconnecting it from the node.
             /// </summary>
             private void Close()
             {
-                _clientToServerStream.Dispose();
-                if (!object.ReferenceEquals(_clientToServerStream, _serverToClientStream))
-                {
-                    _serverToClientStream.Dispose();
-                }
+                _pipeClient.Dispose();
                 _terminateDelegate(_nodeId);
             }
 
@@ -882,191 +695,6 @@ public async Task WaitForExitAsync(ILoggingService loggingService)
 
                 _process.KillTree(timeoutMilliseconds: 5000);
             }
-
-#if FEATURE_APM
-            /// <summary>
-            /// Completes the asynchronous packet write to the node.
-            /// </summary>
-            private void PacketWriteComplete(IAsyncResult result)
-            {
-                try
-                {
-                    _serverToClientStream.EndWrite(result);
-                }
-                catch (IOException)
-                {
-                    // Do nothing here because any exception will be caught by the async read handler
-                }
-            }
-#endif
-
-            private bool ProcessHeaderBytesRead(int bytesRead)
-            {
-                if (bytesRead != _headerByte.Length)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "COMMUNICATIONS ERROR (HRC) Node: {0} Process: {1} Bytes Read: {2} Expected: {3}", _nodeId, _process.Id, bytesRead, _headerByte.Length);
-                    try
-                    {
-                        if (_process.HasExited)
-                        {
-                            CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} has exited.", _process.Id);
-                        }
-                        else
-                        {
-                            CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} is still running.", _process.Id);
-                        }
-                    }
-                    catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
-                    {
-                        CommunicationsUtilities.Trace(_nodeId, "Unable to retrieve remote process information. {0}", e);
-                    }
-
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return false;
-                }
-
-                return true;
-            }
-
-#if FEATURE_APM
-            /// <summary>
-            /// Callback invoked by the completion of a read of a header byte on one of the named pipes.
-            /// </summary>
-            private void HeaderReadComplete(IAsyncResult result)
-            {
-                int bytesRead;
-                try
-                {
-                    try
-                    {
-                        bytesRead = _clientToServerStream.EndRead(result);
-                    }
-
-                    // Workaround for CLR stress bug; it sporadically calls us twice on the same async
-                    // result, and EndRead will throw on the second one. Pretend the second one never happened.
-                    catch (ArgumentException)
-                    {
-                        CommunicationsUtilities.Trace(_nodeId, "Hit CLR bug #825607: called back twice on same async result; ignoring");
-                        return;
-                    }
-
-                    if (!ProcessHeaderBytesRead(bytesRead))
-                    {
-                        return;
-                    }
-                }
-                catch (IOException e)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in HeaderReadComplete: {0}", e);
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return;
-                }
-
-                int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerByte, 1, 4));
-                MSBuildEventSource.Log.PacketReadSize(packetLength);
-
-                // Ensures the buffer is at least this length.
-                // It avoids reallocations if the buffer is already large enough.
-                _readBufferMemoryStream.SetLength(packetLength);
-                byte[] packetData = _readBufferMemoryStream.GetBuffer();
-
-                _clientToServerStream.BeginRead(packetData, 0, packetLength, BodyReadComplete, new Tuple<byte[], int>(packetData, packetLength));
-            }
-#endif
-
-            private bool ProcessBodyBytesRead(int bytesRead, int packetLength, NodePacketType packetType)
-            {
-                if (bytesRead != packetLength)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "Bad packet read for packet {0} - Expected {1} bytes, got {2}", packetType, packetLength, bytesRead);
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return false;
-                }
-                return true;
-            }
-
-            private bool ReadAndRoutePacket(NodePacketType packetType, byte[] packetData, int packetLength)
-            {
-                try
-                {
-                    // The buffer is publicly visible so that InterningBinaryReader doesn't have to copy to an intermediate buffer.
-                    // Since the buffer is publicly visible dispose right away to discourage outsiders from holding a reference to it.
-                    using (var packetStream = new MemoryStream(packetData, 0, packetLength, /*writeable*/ false, /*bufferIsPubliclyVisible*/ true))
-                    {
-                        ITranslator readTranslator = BinaryTranslator.GetReadTranslator(packetStream, _binaryReaderFactory);
-                        _packetFactory.DeserializeAndRoutePacket(_nodeId, packetType, readTranslator);
-                    }
-                }
-                catch (IOException e)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in ReadAndRoutPacket: {0}", e);
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return false;
-                }
-                return true;
-            }
-
-#if FEATURE_APM
-            /// <summary>
-            /// Method called when the body of a packet has been read.
-            /// </summary>
-            private void BodyReadComplete(IAsyncResult result)
-            {
-                NodePacketType packetType = (NodePacketType)_headerByte[0];
-                var state = (Tuple<byte[], int>)result.AsyncState;
-                byte[] packetData = state.Item1;
-                int packetLength = state.Item2;
-                int bytesRead;
-
-                try
-                {
-                    try
-                    {
-                        bytesRead = _clientToServerStream.EndRead(result);
-                    }
-
-                    // Workaround for CLR stress bug; it sporadically calls us twice on the same async
-                    // result, and EndRead will throw on the second one. Pretend the second one never happened.
-                    catch (ArgumentException)
-                    {
-                        CommunicationsUtilities.Trace(_nodeId, "Hit CLR bug #825607: called back twice on same async result; ignoring");
-                        return;
-                    }
-
-                    if (!ProcessBodyBytesRead(bytesRead, packetLength, packetType))
-                    {
-                        return;
-                    }
-                }
-                catch (IOException e)
-                {
-                    CommunicationsUtilities.Trace(_nodeId, "EXCEPTION in BodyReadComplete (Reading): {0}", e);
-                    _packetFactory.RoutePacket(_nodeId, new NodeShutdown(NodeShutdownReason.ConnectionFailed));
-                    Close();
-                    return;
-                }
-
-                // Read and route the packet.
-                if (!ReadAndRoutePacket(packetType, packetData, packetLength))
-                {
-                    return;
-                }
-
-                if (packetType != NodePacketType.NodeShutdown)
-                {
-                    // Read the next packet.
-                    BeginAsyncPacketRead();
-                }
-                else
-                {
-                    Close();
-                }
-            }
-#endif
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 1d0f0f525d3..d7885edb750 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -270,21 +270,13 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         }
 
         /// <summary>
-        /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
+        /// Takes a serializer and deserializes the packet.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
-            if (_nodeIdToPacketFactory.TryGetValue(nodeId, out INodePacketFactory nodePacketFactory))
-            {
-                nodePacketFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
-            }
-            else
-            {
-                _localPacketFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
-            }
+            return _localPacketFactory.DeserializePacket(packetType, translator);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index e7e66d6b886..cafc95a4f22 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -141,10 +141,9 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         /// <summary>
         /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
             throw new NotSupportedException("not used");
         }
diff --git a/src/Build/BackEnd/Node/InProcNode.cs b/src/Build/BackEnd/Node/InProcNode.cs
index 7b4049f8905..6ac34aabdd4 100644
--- a/src/Build/BackEnd/Node/InProcNode.cs
+++ b/src/Build/BackEnd/Node/InProcNode.cs
@@ -216,10 +216,11 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         /// <summary>
         /// Not necessary for in-proc node - we don't serialize.
         /// </summary>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
             // The in-proc endpoint shouldn't be serializing, just routing.
             ErrorUtilities.ThrowInternalError("Unexpected call to DeserializeAndRoutePacket on the in-proc node.");
+            return null;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index f092add506b..bcd97d15400 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -331,14 +331,13 @@ void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)
         }
 
         /// <summary>
-        /// Deserializes and routes a packer to the appropriate handler.
+        /// Deserializes a packet.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator to use as a source for packet data.</param>
-        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        INodePacket INodePacketFactory.DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
-            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+            return _packetFactory.DeserializePacket(packetType, translator);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index bda79d588cd..6af7462d159 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -202,14 +202,13 @@ void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)
         }
 
         /// <summary>
-        /// Deserializes and routes a packer to the appropriate handler.
+        /// Deserializes a packet.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator to use as a source for packet data.</param>
-        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        INodePacket INodePacketFactory.DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
-            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+            return _packetFactory.DeserializePacket(packetType, translator);
         }
 
         /// <summary>
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 784b67b200c..f0afd81d0a8 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -362,14 +362,13 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         }
 
         /// <summary>
-        /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
+        /// Takes a serializer and deserializes the packet.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
-            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+            return _packetFactory.DeserializePacket(packetType, translator);
         }
 
         /// <summary>
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 89d87896e85..43a5b36d7f5 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -92,7 +92,6 @@
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs">
       <Link>Collections\ReadOnlyEmptyCollection.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\TaskHostConfiguration.cs" />
     <Compile Include="..\Shared\TaskHostTaskCancelled.cs" />
     <Compile Include="..\Shared\TaskHostTaskComplete.cs" />
@@ -102,6 +101,9 @@
     <Compile Include="..\Shared\IKeyed.cs" />
     <Compile Include="..\Shared\INodeEndpoint.cs" />
     <Compile Include="..\Shared\NodeEndpointOutOfProcBase.cs" />
+    <Compile Include="..\Shared\NodePipeBase.cs" />
+    <Compile Include="..\Shared\NodePipeClient.cs" />
+    <Compile Include="..\Shared\NodePipeServer.cs" />
     <Compile Include="..\Shared\INodePacket.cs" />
     <Compile Include="..\Shared\INodePacketFactory.cs" />
     <Compile Include="..\Shared\INodePacketHandler.cs" />
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 541f1fa5bf0..706bb006ec6 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -85,7 +85,6 @@
     <Compile Include="..\Shared\ErrorUtilities.cs" />
     <Compile Include="..\Shared\Modifiers.cs" />
     <Compile Include="..\Shared\XMakeElements.cs" />
-    <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
     <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs" />
@@ -98,6 +97,9 @@
     <Compile Include="..\Shared\XMakeAttributes.cs" />
     <Compile Include="..\Shared\INodeEndpoint.cs" />
     <Compile Include="..\Shared\NodeEndpointOutOfProcBase.cs" />
+    <Compile Include="..\Shared\NodePipeBase.cs" />
+    <Compile Include="..\Shared\NodePipeClient.cs" />
+    <Compile Include="..\Shared\NodePipeServer.cs" />
     <Compile Include="..\Shared\INodePacket.cs" />
     <Compile Include="..\Shared\LogMessagePacketBase.cs" />
     <Compile Include="..\Shared\INodePacketFactory.cs" />
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index f862ae2adca..8aafef70b62 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -582,14 +582,13 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         }
 
         /// <summary>
-        /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
+        /// Takes a serializer and deserializes the packet.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
-            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+            return _packetFactory.DeserializePacket(packetType, translator);
         }
 
         /// <summary>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 24c3f4dcb45..0968a8a75fb 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -841,9 +841,9 @@
             WarningsOnly -- ä»…æ˜¾ç¤ºè­¦å‘Šã€‚
             NoItemAndPropertyList -- åœ¨å¼€å§‹ç”Ÿæˆæ¯ä¸ªé¡¹ç›®æ—¶ä¸æ˜¾ç¤º
               é¡¹å’Œå±žæ€§çš„åˆ—è¡¨ã€‚
-            ShowCommandLine -- æ˜¾ç¤º TaskCommandLineEvent æ¶ˆæ¯
+            ShowCommandLine -- æ˜¾ç¤º TaskCommandLineEvent æ¶ˆæ¯ 
             ShowTimestamp -- å°†æ—¶é—´æˆ³ä½œä¸ºæ‰€æœ‰æ¶ˆæ¯çš„å‰ç¼€
-              æ˜¾ç¤ºã€‚
+              æ˜¾ç¤ºã€‚                      
             ShowEventId -- æ˜¾ç¤ºå·²å¼€å§‹äº‹ä»¶ã€å·²å®Œæˆäº‹ä»¶å’Œæ¶ˆæ¯
               çš„äº‹ä»¶ IDã€‚
             ForceNoAlign -- ä¸å°†æ–‡æœ¬ä¸ŽæŽ§åˆ¶å°ç¼“å†²åŒºçš„å¤§å°
@@ -900,10 +900,10 @@
                      Example:
                        -validate:MyExtendedBuildSchema.xsd
 </source>
-        <target state="translated">  -validate     ä¾æ®é»˜è®¤æž¶æž„éªŒè¯é¡¹ç›®ã€‚(ç¼©å†™:
+        <target state="translated">  -validate     ä¾æ®é»˜è®¤æž¶æž„éªŒè¯é¡¹ç›®ã€‚(ç¼©å†™: 
            -val)
 
- -validate:&lt;schema&gt; ä¾æ®æŒ‡å®šçš„æž¶æž„éªŒè¯é¡¹ç›®ã€‚(ç¼©å†™:
+ -validate:&lt;schema&gt; ä¾æ®æŒ‡å®šçš„æž¶æž„éªŒè¯é¡¹ç›®ã€‚(ç¼©å†™: 
            -val)
            ç¤ºä¾‹:
             -validate:MyExtendedBuildSchema.xsd
@@ -1081,7 +1081,7 @@
         <target state="translated">  -toolsversion:&lt;version&gt;
            è¦åœ¨ç”Ÿæˆè¿‡ç¨‹ä¸­ä½¿ç”¨çš„ MSBuild å·¥å…·é›†
            (ä»»åŠ¡ã€ç›®æ ‡ç­‰)çš„ç‰ˆæœ¬ã€‚æ­¤ç‰ˆæœ¬å°†é‡å†™
-           å„ä¸ªé¡¹ç›®æŒ‡å®šçš„ç‰ˆæœ¬ã€‚(ç¼©å†™:
+           å„ä¸ªé¡¹ç›®æŒ‡å®šçš„ç‰ˆæœ¬ã€‚(ç¼©å†™: 
            -tv)
            ç¤ºä¾‹:
             -toolsversion:3.5
@@ -1137,17 +1137,17 @@
                      template and append the node id to this fileName to
                      create a log file for each node.
     </source>
-        <target state="translated">  -distributedFileLogger
+        <target state="translated">  -distributedFileLogger                            
            å°†ç”Ÿæˆè¾“å‡ºè®°å½•åˆ°å¤šä¸ªæ—¥å¿—æ–‡ä»¶ï¼Œæ¯ä¸ª MSBuild èŠ‚ç‚¹
            ä¸€ä¸ªæ—¥å¿—æ–‡ä»¶ã€‚è¿™äº›æ–‡ä»¶çš„åˆå§‹ä½ç½®ä¸º
            å½“å‰ç›®å½•ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿™äº›æ–‡ä»¶åä¸º
            â€œMSBuild&lt;nodeid&gt;.logâ€ã€‚å¯é€šè¿‡æ·»åŠ 
-           â€œ-fileLoggerParametersâ€å¼€å…³æ¥æŒ‡å®š
+           â€œ-fileLoggerParametersâ€å¼€å…³æ¥æŒ‡å®š 
            è¿™äº›æ–‡ä»¶çš„ä½ç½®å’Œ fileLogger çš„å…¶ä»–å‚æ•°ã€‚
 
            å¦‚æžœæ—¥å¿—æ–‡ä»¶åæ˜¯é€šè¿‡ fileLoggerParameters
            å¼€å…³è®¾ç½®çš„ï¼Œåˆ†å¸ƒå¼è®°å½•å™¨å°†ä½¿ç”¨ fileName ä½œä¸º
-           æ¨¡æ¿å¹¶å°†èŠ‚ç‚¹ ID é™„åŠ åˆ°æ­¤ fileName
+           æ¨¡æ¿å¹¶å°†èŠ‚ç‚¹ ID é™„åŠ åˆ°æ­¤ fileName 
            ä»¥ä¾¿ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ›å»ºä¸€ä¸ªæ—¥å¿—æ–‡ä»¶ã€‚
     </target>
         <note>
@@ -1189,12 +1189,12 @@
                        -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </source>
-        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;
+        <target state="translated">  -fileloggerparameters[n]:&lt;parameters&gt;                
            ä¸ºæ–‡ä»¶è®°å½•å™¨æä¾›ä»»ä½•é¢å¤–çš„å‚æ•°ã€‚
            å­˜åœ¨æ­¤å¼€å…³æ„å‘³ç€
            å­˜åœ¨å¯¹åº”çš„ -filelogger[n] å¼€å…³ã€‚
           â€œnâ€(å¦‚æžœå­˜åœ¨)å¯ä»¥ä¸º 1-9 çš„æ•°å­—ã€‚
-           ä»»ä½•åˆ†å¸ƒå¼æ–‡ä»¶è®°å½•å™¨ä¹Ÿå¯ä»¥ä½¿ç”¨
+           ä»»ä½•åˆ†å¸ƒå¼æ–‡ä»¶è®°å½•å™¨ä¹Ÿå¯ä»¥ä½¿ç”¨ 
            -fileloggerparametersï¼Œå…·ä½“å¯å‚é˜… -distributedFileLogger çš„è¯´æ˜Žã€‚
            (ç¼©å†™: -flp[n])
            ä¸ºæŽ§åˆ¶å°è®°å½•å™¨åˆ—å‡ºçš„ç›¸åŒå‚æ•°
@@ -1214,8 +1214,8 @@
             -fileLoggerParameters:LogFile=MyLog.log;Append;
                       Verbosity=diagnostic;Encoding=UTF-8
 
-            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
-            -flp1:warningsonly;logfile=msbuild.wrn
+            -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
+            -flp1:warningsonly;logfile=msbuild.wrn 
             -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -2200,4 +2200,4 @@
       </trans-unit>
     </body>
   </file>
-</xliff>
+</xliff>
\ No newline at end of file
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 58b406ea531..b2b8fb45067 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -214,7 +214,7 @@
                     çµ‚ç«¯æ©Ÿè¨˜éŒ„å™¨çš„åƒæ•¸ã€‚(ç°¡çŸ­å½¢å¼: -tlp)
                     å¯ç”¨çš„åƒæ•¸ã€‚
                        default -- æŒ‡å®šçµ‚ç«¯æ©Ÿè¨˜éŒ„å™¨çš„é è¨­å€¼ã€‚
-                       å…¶éœ€è¦ä¸‹åˆ—å…¶ä¸­ä¸€å€¼:
+                       å…¶éœ€è¦ä¸‹åˆ—å…¶ä¸­ä¸€å€¼: 
 ã€‚
                           - 'on'ã€'true' æœƒå¼·åˆ¶ä½¿ç”¨ TerminalLoggerï¼Œå³ä½¿
                            å…¶ä¹‹å¾Œå¯èƒ½æœƒåœç”¨ã€‚
@@ -227,7 +227,7 @@
                        -verbosity
                        showCommandLine -- é¡¯ç¤º TaskCommandLineEvent è¨Šæ¯
 
-                     ç¯„ä¾‹:
+                     ç¯„ä¾‹: 
                        -tlp:default=auto;verbosity=diag;shownCommandLine
     </target>
         <note>
@@ -246,7 +246,7 @@
         <target state="translated">  -getResultOutputFile:file
                     å°‡è¼¸å‡ºå¾ž get* é‡æ–°å°Žå‘è‡³æª”æ¡ˆã€‚
 
-                    ç¯„ä¾‹:
+                    ç¯„ä¾‹: 
                     -getProperty:Bar -getResultOutputFile:Biz.txt
                     é€™æœƒå°‡å±¬æ€§åˆ—çš„å€¼å¯«å…¥ Biz.txtã€‚
    </target>
@@ -263,7 +263,7 @@
 	</source>
         <target state="translated">  -check
                      åœ¨å»ºç½®æœŸé–“å•Ÿç”¨ BuildChecksã€‚
-                     BuildCheck æœƒå•Ÿç”¨è©•ä¼°è¦å‰‡ä»¥ç¢ºä¿çµ„å»ºçš„
+                     BuildCheck æœƒå•Ÿç”¨è©•ä¼°è¦å‰‡ä»¥ç¢ºä¿çµ„å»ºçš„ 
                      å±¬æ€§ã€‚å¦‚éœ€è©³ç´°è³‡è¨Šï¼Œè«‹åƒé–± aka.ms/buildcheck
 	</target>
         <note>
@@ -446,8 +446,8 @@
         <target state="translated">  -isolateProjects[:True|MessageUponIsolationViolation|False]
                      å°Žè‡´ MSBuild åœ¨éš”é›¢ä¸­å»ºç½®æ¯å€‹å°ˆæ¡ˆã€‚
 
-                     è¨­å®šç‚º "MessageUponIsolationViolation"
-                     (æˆ–å…¶ç°¡çŸ­å½¢å¼ "Message") æ™‚ï¼Œå¦‚æžœæä¾›
+                     è¨­å®šç‚º "MessageUponIsolationViolation" 
+                     (æˆ–å…¶ç°¡çŸ­å½¢å¼ "Message") æ™‚ï¼Œå¦‚æžœæä¾› 
                      -outputResultsCache åˆ‡æ›ï¼Œå‰‡åªæœƒåºåˆ—åŒ–ä¾†è‡ª
                      é ‚å±¤ç›®æ¨™çš„çµæžœã€‚é€™æ˜¯ç‚ºäº†é™ä½Žç›¸ä¾æ€§å°ˆæ¡ˆä¸Šï¼Œ
                      ç”±æ–¼å…¶ç›¸ä¾æ€§ä½æ–¼å¿«å–ç›®æ¨™ä¸Š (å…¶å‰¯ä½œç”¨
@@ -1081,8 +1081,8 @@
    </source>
         <target state="translated">  -toolsversion:&lt;ç‰ˆæœ¬&gt;
                      å»ºç½®æœŸé–“æ‰€ä½¿ç”¨çš„ MSBuild å·¥å…·çµ„ (å·¥ä½œã€ç›®æ¨™ç­‰)
-                      ç‰ˆæœ¬ã€‚æ­¤ç‰ˆæœ¬å°‡æœƒè¦†å¯«
-                     å€‹åˆ¥å°ˆæ¡ˆæ‰€æŒ‡å®šçš„ç‰ˆæœ¬ã€‚(ç°¡çŸ­å½¢å¼:
+                      ç‰ˆæœ¬ã€‚æ­¤ç‰ˆæœ¬å°‡æœƒè¦†å¯« 
+                     å€‹åˆ¥å°ˆæ¡ˆæ‰€æŒ‡å®šçš„ç‰ˆæœ¬ã€‚(ç°¡çŸ­å½¢å¼: 
                      -tv)
                      ç¯„ä¾‹:
                        -toolsVersion:3.5
@@ -2201,4 +2201,4 @@
       </trans-unit>
     </body>
   </file>
-</xliff>
+</xliff>
\ No newline at end of file
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 479c7d03875..92d8bb29e77 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -64,7 +64,6 @@
     <Compile Include="..\Framework\AssemblyUtilities.cs" />
     <Compile Include="..\Framework\Polyfills\*.cs" />
     <Compile Include="..\Framework\ResponseFileUsedEventArgs.cs" />
-    <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="..\Framework\CopyOnWriteDictionary.cs">
       <Link>CopyOnWriteDictionary.cs</Link>
@@ -140,6 +139,15 @@
     <Compile Include="..\Shared\NodeBuildComplete.cs">
       <Link>NodeBuildComplete.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\NodePipeBase.cs">
+      <Link>NodeComponentBase.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\NodePipeClient.cs">
+      <Link>NodeComponentBase.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\NodePipeServer.cs">
+      <Link>NodeComponentBase.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\NodeEndpointOutOfProcBase.cs">
       <Link>NodeEndpointOutOfProcBase.cs</Link>
     </Compile>
diff --git a/src/Shared/BufferedReadStream.cs b/src/Shared/BufferedReadStream.cs
deleted file mode 100644
index 55bba5986f8..00000000000
--- a/src/Shared/BufferedReadStream.cs
+++ /dev/null
@@ -1,210 +0,0 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using System.IO;
-using System.IO.Pipes;
-using System.Threading;
-
-#if NET451_OR_GREATER || NETCOREAPP
-using System.Threading.Tasks;
-#endif
-
-#nullable disable
-
-namespace Microsoft.Build.BackEnd
-{
-    internal class BufferedReadStream : Stream
-    {
-        private const int BUFFER_SIZE = 1024;
-        private NamedPipeServerStream _innerStream;
-        private byte[] _buffer;
-
-        // The number of bytes in the buffer that have been read from the underlying stream but not read by consumers of this stream
-        private int _currentlyBufferedByteCount;
-        private int _currentIndexInBuffer;
-
-        public BufferedReadStream(NamedPipeServerStream innerStream)
-        {
-            _innerStream = innerStream;
-            _buffer = new byte[BUFFER_SIZE];
-
-            _currentlyBufferedByteCount = 0;
-        }
-
-        public override bool CanRead { get { return _innerStream.CanRead; } }
-
-        public override bool CanSeek { get { return false; } }
-
-        public override bool CanWrite { get { return _innerStream.CanWrite; } }
-
-        public override long Length { get { return _innerStream.Length; } }
-
-        public override long Position
-        {
-            get { throw new NotSupportedException(); }
-            set { throw new NotSupportedException(); }
-        }
-
-        public override void Flush()
-        {
-            _innerStream.Flush();
-        }
-
-        public override int ReadByte()
-        {
-            if (_currentlyBufferedByteCount > 0)
-            {
-                int ret = _buffer[_currentIndexInBuffer];
-                _currentIndexInBuffer++;
-                _currentlyBufferedByteCount--;
-                return ret;
-            }
-            else
-            {
-                // Let the base class handle it, which will end up calling the Read() method
-                return base.ReadByte();
-            }
-        }
-
-        public override int Read(byte[] buffer, int offset, int count)
-        {
-            if (count > BUFFER_SIZE)
-            {
-                // Trying to read more data than the buffer can hold
-                int alreadyCopied = 0;
-                if (_currentlyBufferedByteCount > 0)
-                {
-                    Array.Copy(_buffer, _currentIndexInBuffer, buffer, offset, _currentlyBufferedByteCount);
-                    alreadyCopied = _currentlyBufferedByteCount;
-                    _currentIndexInBuffer = 0;
-                    _currentlyBufferedByteCount = 0;
-                }
-                int innerReadCount = _innerStream.Read(buffer, offset + alreadyCopied, count - alreadyCopied);
-                return innerReadCount + alreadyCopied;
-            }
-            else if (count <= _currentlyBufferedByteCount)
-            {
-                // Enough data buffered to satisfy read request
-                Array.Copy(_buffer, _currentIndexInBuffer, buffer, offset, count);
-                _currentIndexInBuffer += count;
-                _currentlyBufferedByteCount -= count;
-                return count;
-            }
-            else
-            {
-                // Need to read more data
-                int alreadyCopied = 0;
-                if (_currentlyBufferedByteCount > 0)
-                {
-                    Array.Copy(_buffer, _currentIndexInBuffer, buffer, offset, _currentlyBufferedByteCount);
-                    alreadyCopied = _currentlyBufferedByteCount;
-                    _currentIndexInBuffer = 0;
-                    _currentlyBufferedByteCount = 0;
-                }
-
-                int innerReadCount = _innerStream.Read(_buffer, 0, BUFFER_SIZE);
-                _currentIndexInBuffer = 0;
-                _currentlyBufferedByteCount = innerReadCount;
-
-                int remainingCopyCount;
-
-                if (alreadyCopied + innerReadCount >= count)
-                {
-                    remainingCopyCount = count - alreadyCopied;
-                }
-                else
-                {
-                    remainingCopyCount = innerReadCount;
-                }
-
-                Array.Copy(_buffer, 0, buffer, offset + alreadyCopied, remainingCopyCount);
-                _currentIndexInBuffer += remainingCopyCount;
-                _currentlyBufferedByteCount -= remainingCopyCount;
-
-                return alreadyCopied + remainingCopyCount;
-            }
-        }
-
-#if NET451_OR_GREATER || NETCOREAPP
-        public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
-        {
-            if (count > BUFFER_SIZE)
-            {
-                // Trying to read more data than the buffer can hold
-                int alreadyCopied = CopyToBuffer(buffer, offset);
-
-#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-                int innerReadCount = await _innerStream.ReadAsync(buffer, offset + alreadyCopied, count - alreadyCopied, cancellationToken);
-#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-                return innerReadCount + alreadyCopied;
-            }
-            else if (count <= _currentlyBufferedByteCount)
-            {
-                // Enough data buffered to satisfy read request
-                Array.Copy(_buffer, _currentIndexInBuffer, buffer, offset, count);
-                _currentIndexInBuffer += count;
-                _currentlyBufferedByteCount -= count;
-                return count;
-            }
-            else
-            {
-                // Need to read more data
-                int alreadyCopied = CopyToBuffer(buffer, offset);
-
-#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-                int innerReadCount = await _innerStream.ReadAsync(_buffer, 0, BUFFER_SIZE, cancellationToken);
-#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-                _currentIndexInBuffer = 0;
-                _currentlyBufferedByteCount = innerReadCount;
-
-                int remainingCopyCount = alreadyCopied + innerReadCount >= count ? count - alreadyCopied : innerReadCount;
-                Array.Copy(_buffer, 0, buffer, offset + alreadyCopied, remainingCopyCount);
-                _currentIndexInBuffer += remainingCopyCount;
-                _currentlyBufferedByteCount -= remainingCopyCount;
-
-                return alreadyCopied + remainingCopyCount;
-            }
-
-            int CopyToBuffer(byte[] buffer, int offset)
-            {
-                int alreadyCopied = 0;
-                if (_currentlyBufferedByteCount > 0)
-                {
-                    Array.Copy(_buffer, _currentIndexInBuffer, buffer, offset, _currentlyBufferedByteCount);
-                    alreadyCopied = _currentlyBufferedByteCount;
-                    _currentIndexInBuffer = 0;
-                    _currentlyBufferedByteCount = 0;
-                }
-
-                return alreadyCopied;
-            }
-        }
-#endif
-
-        public override long Seek(long offset, SeekOrigin origin)
-        {
-            throw new NotSupportedException();
-        }
-
-        public override void SetLength(long value)
-        {
-            throw new NotSupportedException();
-        }
-
-        public override void Write(byte[] buffer, int offset, int count)
-        {
-            _innerStream.Write(buffer, offset, count);
-        }
-
-        protected override void Dispose(bool disposing)
-        {
-            if (disposing)
-            {
-                _innerStream.Dispose();
-            }
-
-            base.Dispose(disposing);
-        }
-    }
-}
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index cb1177fce58..4b48317081c 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -22,9 +22,6 @@
 #if !CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Debugging;
 #endif
-#if !FEATURE_APM
-using System.Threading.Tasks;
-#endif
 
 #nullable disable
 
@@ -472,25 +469,9 @@ internal static void WriteIntForHandshake(this PipeStream stream, int value)
             stream.Write(bytes, 0, bytes.Length);
         }
 
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-        internal static void ReadEndOfHandshakeSignal(
-            this PipeStream stream,
-            bool isProvider
-#if NETCOREAPP2_1_OR_GREATER
-            , int timeout
-#endif
-            )
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+        internal static void ReadEndOfHandshakeSignal(this PipeStream stream, bool isProvider, int timeout)
         {
-            // Accept only the first byte of the EndOfHandshakeSignal
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-            int valueRead = stream.ReadIntForHandshake(
-                byteToAccept: null
-#if NETCOREAPP2_1_OR_GREATER
-            , timeout
-#endif
-                );
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+            int valueRead = stream.ReadIntForHandshake(byteToAccept: null, timeout);
 
             if (valueRead != EndOfHandshakeSignal)
             {
@@ -506,17 +487,11 @@ bool isProvider
             }
         }
 
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
         /// <summary>
         /// Extension method to read a series of bytes from a stream.
         /// If specified, leading byte matches one in the supplied array if any, returns rejection byte and throws IOException.
         /// </summary>
-        internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAccept
-#if NETCOREAPP2_1_OR_GREATER
-            , int timeout
-#endif
-            )
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+        internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAccept, int timeout)
         {
             byte[] bytes = new byte[4];
 
@@ -586,23 +561,6 @@ internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAcce
         }
 #nullable disable
 
-#if !FEATURE_APM
-        internal static async ValueTask<int> ReadAsync(Stream stream, byte[] buffer, int bytesToRead)
-        {
-            int totalBytesRead = 0;
-            while (totalBytesRead < bytesToRead)
-            {
-                int bytesRead = await stream.ReadAsync(buffer.AsMemory(totalBytesRead, bytesToRead - totalBytesRead), CancellationToken.None);
-                if (bytesRead == 0)
-                {
-                    return totalBytesRead;
-                }
-                totalBytesRead += bytesRead;
-            }
-            return totalBytesRead;
-        }
-#endif
-
         /// <summary>
         /// Given the appropriate information, return the equivalent HandshakeOptions.
         /// </summary>
diff --git a/src/Shared/INodePacketFactory.cs b/src/Shared/INodePacketFactory.cs
index c972e0408b5..b0fd06bbbca 100644
--- a/src/Shared/INodePacketFactory.cs
+++ b/src/Shared/INodePacketFactory.cs
@@ -35,12 +35,11 @@ internal interface INodePacketFactory
         void UnregisterPacketHandler(NodePacketType packetType);
 
         /// <summary>
-        /// Takes a serializer, deserializes the packet and routes it to the appropriate handler.
+        /// Takes a serializer and deserializes the packet.
         /// </summary>
-        /// <param name="nodeId">The node from which the packet was received.</param>
         /// <param name="packetType">The packet type.</param>
         /// <param name="translator">The translator containing the data from which the packet should be reconstructed.</param>
-        void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
+        INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator);
 
         /// <summary>
         /// Routes the specified packet
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 846f7716ec4..5a5d1db3eb5 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -3,25 +3,16 @@
 
 using System;
 using System.Diagnostics.CodeAnalysis;
-#if CLR2COMPATIBILITY
+#if TASKHOST
 using Microsoft.Build.Shared.Concurrent;
 #else
 using System.Collections.Concurrent;
+using System.Threading.Tasks;
 #endif
 using System.IO;
-using System.IO.Pipes;
 using System.Threading;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-#if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY
-using System.Security.AccessControl;
-#endif
-#if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
-using System.Security.Principal;
-#endif
-#if NET451_OR_GREATER || NETCOREAPP
-using System.Threading.Tasks;
-#endif
 
 #nullable disable
 
@@ -35,18 +26,6 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
     {
         #region Private Data
 
-#if NETCOREAPP2_1_OR_GREATER
-        /// <summary>
-        /// The amount of time to wait for the client to connect to the host.
-        /// </summary>
-        private const int ClientConnectTimeout = 60000;
-#endif // NETCOREAPP2_1
-
-        /// <summary>
-        /// The size of the buffers to use for named pipes
-        /// </summary>
-        private const int PipeBufferSize = 131072;
-
         /// <summary>
         /// The current communication status of the node.
         /// </summary>
@@ -55,7 +34,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// <summary>
         /// The pipe client used by the nodes.
         /// </summary>
-        private NamedPipeServerStream _pipeServer;
+        private NodePipeServer _pipeServer;
 
         // The following private data fields are used only when the endpoint is in ASYNCHRONOUS mode.
 
@@ -100,21 +79,6 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// </remarks>
         private ConcurrentQueue<INodePacket> _packetQueue;
 
-        /// <summary>
-        /// Per-node shared read buffer.
-        /// </summary>
-        private BinaryReaderFactory _sharedReadBuffer;
-
-        /// <summary>
-        /// A way to cache a byte array when writing out packets
-        /// </summary>
-        private MemoryStream _packetStream;
-
-        /// <summary>
-        /// A binary writer to help write into <see cref="_packetStream"/>
-        /// </summary>
-        private BinaryWriter _binaryWriter;
-
         #endregion
 
         #region INodeEndpoint Events
@@ -153,6 +117,7 @@ public void Listen(INodePacketFactory factory)
             ErrorUtilities.VerifyThrow(_status == LinkStatus.Inactive, "Link not inactive.  Status is {0}", _status);
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             _packetFactory = factory;
+            _pipeServer.RegisterPacketFactory(factory);
 
             InitializeAsyncPacketThread();
         }
@@ -206,54 +171,9 @@ internal void InternalConstruct(string pipeName = null)
         {
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
-            _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
-
-            _packetStream = new MemoryStream();
-            _binaryWriter = new BinaryWriter(_packetStream);
 
             pipeName ??= NamedPipeUtil.GetPlatformSpecificPipeName();
-
-#if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
-            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
-            PipeSecurity security = new PipeSecurity();
-
-            // Restrict access to just this account.  We set the owner specifically here, and on the
-            // pipe client side they will check the owner against this one - they must have identical
-            // SIDs or the client will reject this server.  This is used to avoid attacks where a
-            // hacked server creates a less restricted pipe in an attempt to lure us into using it and
-            // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
-            PipeAccessRule rule = new PipeAccessRule(identifier, PipeAccessRights.ReadWrite, AccessControlType.Allow);
-            security.AddAccessRule(rule);
-            security.SetOwner(identifier);
-
-            _pipeServer = new NamedPipeServerStream(
-                pipeName,
-                PipeDirection.InOut,
-                1, // Only allow one connection at a time.
-                PipeTransmissionMode.Byte,
-                PipeOptions.Asynchronous | PipeOptions.WriteThrough
-#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                | PipeOptions.CurrentUserOnly
-#endif
-                ,
-                PipeBufferSize, // Default input buffer
-                PipeBufferSize,  // Default output buffer
-                security,
-                HandleInheritability.None);
-#else
-            _pipeServer = new NamedPipeServerStream(
-                pipeName,
-                PipeDirection.InOut,
-                1, // Only allow one connection at a time.
-                PipeTransmissionMode.Byte,
-                PipeOptions.Asynchronous | PipeOptions.WriteThrough
-#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                | PipeOptions.CurrentUserOnly
-#endif
-                ,
-                PipeBufferSize, // Default input buffer
-                PipeBufferSize);  // Default output buffer
-#endif
+            _pipeServer = new NodePipeServer(pipeName, GetHandshake());
         }
 
         #endregion
@@ -295,7 +215,7 @@ private void InternalDisconnect()
             ErrorUtilities.VerifyThrow(_packetPump.ManagedThreadId != Thread.CurrentThread.ManagedThreadId, "Can't join on the same thread.");
             _terminatePacketPump.Set();
             _packetPump.Join();
-#if CLR2COMPATIBILITY
+#if TASKHOST
             _terminatePacketPump.Close();
 #else
             _terminatePacketPump.Dispose();
@@ -345,172 +265,25 @@ private void InitializeAsyncPacketThread()
         /// </summary>
         private void PacketPumpProc()
         {
-            NamedPipeServerStream localPipeServer = _pipeServer;
+            NodePipeServer localPipeServer = _pipeServer;
 
             AutoResetEvent localPacketAvailable = _packetAvailable;
             AutoResetEvent localTerminatePacketPump = _terminatePacketPump;
             ConcurrentQueue<INodePacket> localPacketQueue = _packetQueue;
 
-            DateTime originalWaitStartTime = DateTime.UtcNow;
-            bool gotValidConnection = false;
-            while (!gotValidConnection)
+            ChangeLinkStatus(localPipeServer.WaitForConnection());
+            if (_status != LinkStatus.Active)
             {
-                gotValidConnection = true;
-                DateTime restartWaitTime = DateTime.UtcNow;
-
-                // We only wait to wait the difference between now and the last original start time, in case we have multiple hosts attempting
-                // to attach.  This prevents each attempt from resetting the timer.
-                TimeSpan usedWaitTime = restartWaitTime - originalWaitStartTime;
-                int waitTimeRemaining = Math.Max(0, CommunicationsUtilities.NodeConnectionTimeout - (int)usedWaitTime.TotalMilliseconds);
-
-                try
-                {
-                    // Wait for a connection
-#if FEATURE_APM
-                    IAsyncResult resultForConnection = localPipeServer.BeginWaitForConnection(null, null);
-                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
-                    bool connected = resultForConnection.AsyncWaitHandle.WaitOne(waitTimeRemaining, false);
-#else
-                    Task connectionTask = localPipeServer.WaitForConnectionAsync();
-                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
-                    bool connected = connectionTask.Wait(waitTimeRemaining);
-#endif
-                    if (!connected)
-                    {
-                        CommunicationsUtilities.Trace("Connection timed out waiting a host to contact us.  Exiting comm thread.");
-                        ChangeLinkStatus(LinkStatus.ConnectionFailed);
-                        return;
-                    }
-
-                    CommunicationsUtilities.Trace("Parent started connecting. Reading handshake from parent");
-#if FEATURE_APM
-                    localPipeServer.EndWaitForConnection(resultForConnection);
-#endif
-
-                    // The handshake protocol is a series of int exchanges.  The host sends us a each component, and we
-                    // verify it. Afterwards, the host sends an "End of Handshake" signal, to which we respond in kind.
-                    // Once the handshake is complete, both sides can be assured the other is ready to accept data.
-                    Handshake handshake = GetHandshake();
-                    try
-                    {
-                        int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
-                        for (int i = 0; i < handshakeComponents.Length; i++)
-                        {
-#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-                            int handshakePart = _pipeServer.ReadIntForHandshake(
-                                byteToAccept: i == 0 ? (byte?)CommunicationsUtilities.handshakeVersion : null /* this will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard */
-#if NETCOREAPP2_1_OR_GREATER
-                            , ClientConnectTimeout /* wait a long time for the handshake from this side */
-#endif
-                            );
-#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
-
-                            if (handshakePart != handshakeComponents[i])
-                            {
-                                CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, handshakeComponents[i]);
-                                _pipeServer.WriteIntForHandshake(i + 1);
-                                gotValidConnection = false;
-                                break;
-                            }
-                        }
-
-                        if (gotValidConnection)
-                        {
-                            // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
-#if NETCOREAPP2_1_OR_GREATER
-                            _pipeServer.ReadEndOfHandshakeSignal(false, ClientConnectTimeout); /* wait a long time for the handshake from this side */
-#else
-                            _pipeServer.ReadEndOfHandshakeSignal(false);
-#endif
-                            CommunicationsUtilities.Trace("Successfully connected to parent.");
-                            _pipeServer.WriteEndOfHandshakeSignal();
-
-#if FEATURE_SECURITY_PERMISSIONS
-                            // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
-                            // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
-                            // user we were started by.
-                            WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
-                            WindowsIdentity clientIdentity = null;
-                            localPipeServer.RunAsClient(delegate () { clientIdentity = WindowsIdentity.GetCurrent(true); });
-
-                            if (clientIdentity == null || !String.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
-                            {
-                                CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
-                                gotValidConnection = false;
-                                continue;
-                            }
-#endif
-                        }
-                    }
-                    catch (IOException e)
-                    {
-                        // We will get here when:
-                        // 1. The host (OOP main node) connects to us, it immediately checks for user privileges
-                        //    and if they don't match it disconnects immediately leaving us still trying to read the blank handshake
-                        // 2. The host is too old sending us bits we automatically reject in the handshake
-                        // 3. We expected to read the EndOfHandshake signal, but we received something else
-                        CommunicationsUtilities.Trace("Client connection failed but we will wait for another connection. Exception: {0}", e.Message);
-
-                        gotValidConnection = false;
-                    }
-                    catch (InvalidOperationException)
-                    {
-                        gotValidConnection = false;
-                    }
-
-                    if (!gotValidConnection)
-                    {
-                        if (localPipeServer.IsConnected)
-                        {
-                            localPipeServer.Disconnect();
-                        }
-                        continue;
-                    }
-
-                    ChangeLinkStatus(LinkStatus.Active);
-                }
-                catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
-                {
-                    CommunicationsUtilities.Trace("Client connection failed.  Exiting comm thread. {0}", e);
-                    if (localPipeServer.IsConnected)
-                    {
-                        localPipeServer.Disconnect();
-                    }
-
-                    ExceptionHandling.DumpExceptionToFile(e);
-                    ChangeLinkStatus(LinkStatus.Failed);
-                    return;
-                }
+                return;
             }
 
-            RunReadLoop(
-                new BufferedReadStream(_pipeServer),
-                _pipeServer,
-                localPacketQueue, localPacketAvailable, localTerminatePacketPump);
+            RunReadLoop(localPipeServer, localPacketQueue, localPacketAvailable, localTerminatePacketPump);
 
             CommunicationsUtilities.Trace("Ending read loop");
-
-            try
-            {
-                if (localPipeServer.IsConnected)
-                {
-#if NET // OperatingSystem.IsWindows() is new in .NET 5.0
-                    if (OperatingSystem.IsWindows())
-#endif
-                    {
-                        localPipeServer.WaitForPipeDrain();
-                    }
-
-                    localPipeServer.Disconnect();
-                }
-            }
-            catch (Exception)
-            {
-                // We don't really care if Disconnect somehow fails, but it gives us a chance to do the right thing.
-            }
+            localPipeServer.Disconnect();
         }
 
-        private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream localWritePipe,
+        private void RunReadLoop(NodePipeServer localPipeServer,
             ConcurrentQueue<INodePacket> localPacketQueue, AutoResetEvent localPacketAvailable, AutoResetEvent localTerminatePacketPump)
         {
             // Ordering of the wait handles is important.  The first signalled wait handle in the array
@@ -518,13 +291,11 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
             // terminate event triggered so that we cannot get into a situation where packets are being
             // spammed to the endpoint and it never gets an opportunity to shutdown.
             CommunicationsUtilities.Trace("Entering read loop.");
-            byte[] headerByte = new byte[5];
-#if NET451_OR_GREATER
-            Task<int> readTask = localReadPipe.ReadAsync(headerByte, 0, headerByte.Length, CancellationToken.None);
-#elif NETCOREAPP
-            Task<int> readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length).AsTask();
+#if TASKHOST
+            Func<INodePacket> readPacketFunc = localPipeServer.ReadPacket;
+            IAsyncResult result = readPacketFunc.BeginInvoke(null, null);
 #else
-            IAsyncResult result = localReadPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);
+            Task<INodePacket> readTask = localPipeServer.ReadPacketAsync();
 #endif
 
             // Ordering is important.  We want packetAvailable to supercede terminate otherwise we will not properly wait for all
@@ -548,36 +319,25 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
                 {
                     case 0:
                         {
-                            int bytesRead = 0;
+                            INodePacket packet = null;
+
                             try
                             {
-#if NET451_OR_GREATER || NETCOREAPP
-                                bytesRead = readTask.Result;
+#if TASKHOST
+                                packet = readPacketFunc.EndInvoke(result);
 #else
-                                bytesRead = localReadPipe.EndRead(result);
+                                packet = readTask.GetAwaiter().GetResult();
 #endif
-                            }
-                            catch (Exception e)
-                            {
-                                // Lost communications.  Abort (but allow node reuse)
-                                CommunicationsUtilities.Trace("Exception reading from server.  {0}", e);
-                                ExceptionHandling.DumpExceptionToFile(e);
-                                ChangeLinkStatus(LinkStatus.Inactive);
-                                exitLoop = true;
-                                break;
-                            }
-
-                            if (bytesRead != headerByte.Length)
-                            {
-                                // Incomplete read.  Abort.
-                                if (bytesRead == 0)
+                                if (packet.Type == NodePacketType.NodeShutdown)
                                 {
                                     if (_isClientDisconnecting)
                                     {
-                                        CommunicationsUtilities.Trace("Parent disconnected gracefully.");
+                                        // Lost communications.  Abort (but allow node reuse).
                                         // Do not change link status to failed as this could make node think connection has failed
                                         // and recycle node, while this is perfectly expected and handled race condition
                                         // (both client and node is about to close pipe and client can be faster).
+                                        CommunicationsUtilities.Trace("Parent disconnected gracefully.");
+                                        ChangeLinkStatus(LinkStatus.Inactive);
                                     }
                                     else
                                     {
@@ -587,43 +347,35 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
                                 }
                                 else
                                 {
-                                    CommunicationsUtilities.Trace("Incomplete header read from server.  {0} of {1} bytes read", bytesRead, headerByte.Length);
-                                    ChangeLinkStatus(LinkStatus.Failed);
+                                    _packetFactory.RoutePacket(0, packet);
                                 }
-
-                                exitLoop = true;
-                                break;
-                            }
-
-                            NodePacketType packetType = (NodePacketType)headerByte[0];
-
-                            try
-                            {
-                                _packetFactory.DeserializeAndRoutePacket(0, packetType, BinaryTranslator.GetReadTranslator(localReadPipe, _sharedReadBuffer));
                             }
                             catch (Exception e)
                             {
-                                // Error while deserializing or handling packet.  Abort.
-                                CommunicationsUtilities.Trace("Exception while deserializing packet {0}: {1}", packetType, e);
+                                if (packet == null)
+                                {
+                                    CommunicationsUtilities.Trace("Exception while reading packet from server:  {0}", e);
+                                }
+                                else
+                                {
+                                    CommunicationsUtilities.Trace("Exception while deserializing or handling packet {0}: {1}", packet.Type, e);
+                                }
+
                                 ExceptionHandling.DumpExceptionToFile(e);
                                 ChangeLinkStatus(LinkStatus.Failed);
-                                exitLoop = true;
-                                break;
                             }
 
-#if NET451_OR_GREATER
-                            readTask = localReadPipe.ReadAsync(headerByte, 0, headerByte.Length, CancellationToken.None);
-#elif NETCOREAPP
-                            readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length).AsTask();
-#else
-                            result = localReadPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);
-#endif
-
-#if NET451_OR_GREATER || NETCOREAPP
-                            handles[0] = ((IAsyncResult)readTask).AsyncWaitHandle;
+                            exitLoop = _status != LinkStatus.Active;
+                            if (!exitLoop)
+                            {
+#if TASKHOST
+                                result = readPacketFunc.BeginInvoke(null, null);
+                                handles[0] = result.AsyncWaitHandle;
 #else
-                            handles[0] = result.AsyncWaitHandle;
+                                readTask = localPipeServer.ReadPacketAsync();
+                                handles[0] = ((IAsyncResult)readTask).AsyncWaitHandle;
 #endif
+                            }
                         }
 
                         break;
@@ -633,29 +385,9 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
                         try
                         {
                             // Write out all the queued packets.
-                            INodePacket packet;
-                            while (localPacketQueue.TryDequeue(out packet))
+                            while (localPacketQueue.TryDequeue(out INodePacket packet))
                             {
-                                var packetStream = _packetStream;
-                                packetStream.SetLength(0);
-
-                                ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(packetStream);
-
-                                packetStream.WriteByte((byte)packet.Type);
-
-                                // Pad for packet length
-                                _binaryWriter.Write(0);
-
-                                // Reset the position in the write buffer.
-                                packet.Translate(writeTranslator);
-
-                                int packetStreamLength = (int)packetStream.Position;
-
-                                // Now write in the actual packet length
-                                packetStream.Position = 1;
-                                _binaryWriter.Write(packetStreamLength - 5);
-
-                                localWritePipe.Write(packetStream.GetBuffer(), 0, packetStreamLength);
+                                localPipeServer.WritePacket(packet);
                             }
                         }
                         catch (Exception e)
@@ -685,8 +417,8 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
             while (!exitLoop);
         }
 
-#endregion
+        #endregion
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Shared/NodePacketFactory.cs b/src/Shared/NodePacketFactory.cs
index 214ddfa20f9..51cbee08655 100644
--- a/src/Shared/NodePacketFactory.cs
+++ b/src/Shared/NodePacketFactory.cs
@@ -45,9 +45,9 @@ public void UnregisterPacketHandler(NodePacketType packetType)
         }
 
         /// <summary>
-        /// Creates and routes a packet with data from a binary stream.
+        /// Creates a packet with data from a binary stream.
         /// </summary>
-        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        public INodePacket DeserializePacket(NodePacketType packetType, ITranslator translator)
         {
             // PERF: Not using VerifyThrow to avoid boxing of packetType in the non-error case
             if (!_packetFactories.TryGetValue(packetType, out PacketFactoryRecord record))
@@ -55,7 +55,7 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
                 ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packetType);
             }
 
-            record.DeserializeAndRoutePacket(nodeId, translator);
+            return record.DeserializePacket(translator);
         }
 
         /// <summary>
@@ -63,7 +63,12 @@ public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITr
         /// </summary>
         public void RoutePacket(int nodeId, INodePacket packet)
         {
-            PacketFactoryRecord record = _packetFactories[packet.Type];
+            // PERF: Not using VerifyThrow to avoid boxing of packetType in the non-error case
+            if (!_packetFactories.TryGetValue(packet.Type, out PacketFactoryRecord record))
+            {
+                ErrorUtilities.ThrowInternalError("No packet handler for type {0}", packet.Type);
+            }
+
             record.RoutePacket(nodeId, packet);
         }
 
@@ -94,13 +99,9 @@ public PacketFactoryRecord(INodePacketHandler handler, NodePacketFactoryMethod f
             }
 
             /// <summary>
-            /// Creates a packet from a binary stream and sends it to the registered handler.
+            /// Creates a packet from a binary stream.
             /// </summary>
-            public void DeserializeAndRoutePacket(int nodeId, ITranslator translator)
-            {
-                INodePacket packet = _factoryMethod(translator);
-                RoutePacket(nodeId, packet);
-            }
+            public INodePacket DeserializePacket(ITranslator translator) => _factoryMethod(translator);
 
             /// <summary>
             /// Routes the packet to the correct destination.
diff --git a/src/Shared/NodePipeBase.cs b/src/Shared/NodePipeBase.cs
new file mode 100644
index 00000000000..a9c9692a880
--- /dev/null
+++ b/src/Shared/NodePipeBase.cs
@@ -0,0 +1,272 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.IO.Pipes;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+#if !TASKHOST
+using System.Buffers.Binary;
+using System.Threading.Tasks;
+using Microsoft.Build.Eventing;
+#endif
+
+namespace Microsoft.Build.Internal
+{
+    internal abstract class NodePipeBase : IDisposable
+    {
+        /// <summary>
+        /// A packet header consists of 1 byte (enum) for the packet type + 4 bytes (int32) for the packet length.
+        /// </summary>
+        private const int HeaderLength = 5;
+
+        /// <summary>
+        /// The size of the intermediate in-memory buffers.
+        /// </summary>
+        private const int InitialBufferSize = 131_072;
+
+        /// <summary>
+        /// The maximum number of bytes to write in a single operation.
+        /// </summary>
+        private const int MaxPacketWriteSize = 104_8576;
+
+        /// <summary>
+        /// A reusable buffer for reading the packet header.
+        /// </summary>
+        private readonly byte[] _headerData = new byte[HeaderLength];
+
+        /// <summary>
+        /// A buffer typically big enough to handle a packet body.
+        /// We use this as a convenient way to manage and cache a byte[] that's resized
+        /// automatically to fit our payload.
+        /// </summary>
+        private readonly MemoryStream _readBuffer = new(InitialBufferSize);
+
+        /// <summary>
+        /// A buffer typically big enough to handle a packet body.
+        /// We use this as a convenient way to manage and cache a byte[] that's resized
+        /// automatically to fit our payload.
+        /// </summary>
+        private readonly MemoryStream _writeBuffer = new(InitialBufferSize);
+
+        private readonly ITranslator _readTranslator;
+
+        private readonly ITranslator _writeTranslator;
+
+        /// <summary>
+        /// The packet factory to be used for deserialization, as packet types may have custom factory logic.
+        /// </summary>
+        private INodePacketFactory? _packetFactory;
+
+        protected NodePipeBase(string pipeName, Handshake handshake)
+        {
+            PipeName = pipeName;
+            HandshakeComponents = handshake.RetrieveHandshakeComponents();
+            _readTranslator = BinaryTranslator.GetReadTranslator(_readBuffer, InterningBinaryReader.CreateSharedBuffer());
+            _writeTranslator = BinaryTranslator.GetWriteTranslator(_writeBuffer);
+        }
+
+        protected abstract PipeStream NodeStream { get; }
+
+        protected string PipeName { get; }
+
+        protected int[] HandshakeComponents { get; }
+
+        public void Dispose()
+        {
+            _readBuffer.Dispose();
+            _writeBuffer.Dispose();
+            _readTranslator.Dispose();
+            _writeTranslator.Dispose();
+            NodeStream.Dispose();
+        }
+
+        internal void RegisterPacketFactory(INodePacketFactory packetFactory) => _packetFactory = packetFactory;
+
+        internal void WritePacket(INodePacket packet)
+        {
+            int messageLength = WritePacketToBuffer(packet);
+            byte[] buffer = _writeBuffer.GetBuffer();
+
+            for (int i = 0; i < messageLength; i += MaxPacketWriteSize)
+            {
+                int lengthToWrite = Math.Min(messageLength - i, MaxPacketWriteSize);
+                NodeStream.Write(buffer, i, lengthToWrite);
+            }
+        }
+
+        internal INodePacket ReadPacket()
+        {
+            // Read the header.
+            int headerBytesRead = Read(_headerData, HeaderLength);
+
+            // When an active connection is broken, any pending read will return 0 bytes before the pipe transitions to
+            // the broken state. As this is expected behavior, don't throw an exception if no packet is pending, A node
+            // may disconnect without waiting on the other end to gracefully cancel, and the caller can decide whether
+            // this was intentional.
+            if (headerBytesRead == 0)
+            {
+                return new NodeShutdown(NodeShutdownReason.ConnectionFailed);
+            }
+            else if (headerBytesRead != HeaderLength)
+            {
+                throw new IOException($"Incomplete header read.  {headerBytesRead} of {HeaderLength} bytes read.");
+            }
+
+#if TASKHOST
+            int packetLength = BitConverter.ToInt32(_headerData, 1);
+#else
+            int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerData, 1, 4));
+            MSBuildEventSource.Log.PacketReadSize(packetLength);
+#endif
+
+            // Read the packet. Set the buffer length now to avoid additional resizing during the read.
+            _readBuffer.Position = 0;
+            _readBuffer.SetLength(packetLength);
+            int packetBytesRead = Read(_readBuffer.GetBuffer(), packetLength);
+
+            if (packetBytesRead < packetLength)
+            {
+                throw new IOException($"Incomplete packet read. {packetBytesRead} of {packetLength} bytes read.");
+            }
+
+            return DeserializePacket();
+        }
+
+#if !TASKHOST
+        internal async Task WritePacketAsync(INodePacket packet, CancellationToken cancellationToken = default)
+        {
+            int messageLength = WritePacketToBuffer(packet);
+            byte[] buffer = _writeBuffer.GetBuffer();
+
+            for (int i = 0; i < messageLength; i += MaxPacketWriteSize)
+            {
+                int lengthToWrite = Math.Min(messageLength - i, MaxPacketWriteSize);
+#if NET
+                await NodeStream.WriteAsync(buffer.AsMemory(i, lengthToWrite), cancellationToken).ConfigureAwait(false);
+#else
+                await NodeStream.WriteAsync(buffer, i, lengthToWrite, cancellationToken).ConfigureAwait(false);
+#endif
+            }
+        }
+
+        internal async Task<INodePacket> ReadPacketAsync(CancellationToken cancellationToken = default)
+        {
+            // Read the header.
+            int headerBytesRead = await ReadAsync(_headerData, HeaderLength, cancellationToken).ConfigureAwait(false);
+
+            // When an active connection is broken, any pending read will return 0 bytes before the pipe transitions to
+            // the broken state. As this is expected behavior, don't throw an exception if no packet is pending, A node
+            // may disconnect without waiting on the other end to gracefully cancel, and the caller can decide whether
+            // this was intentional.
+            if (headerBytesRead == 0)
+            {
+                return new NodeShutdown(NodeShutdownReason.ConnectionFailed);
+            }
+            else if (headerBytesRead != HeaderLength)
+            {
+                throw new IOException($"Incomplete header read.  {headerBytesRead} of {HeaderLength} bytes read.");
+            }
+
+            int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerData, 1, 4));
+            MSBuildEventSource.Log.PacketReadSize(packetLength);
+
+            // Read the packet. Set the buffer length now to avoid additional resizing during the read.
+            _readBuffer.Position = 0;
+            _readBuffer.SetLength(packetLength);
+            int packetBytesRead = await ReadAsync(_readBuffer.GetBuffer(), packetLength, cancellationToken).ConfigureAwait(false);
+
+            if (packetBytesRead < packetLength)
+            {
+                throw new IOException($"Incomplete packet read. {packetBytesRead} of {packetLength} bytes read.");
+            }
+
+            return DeserializePacket();
+        }
+#endif
+
+        private int WritePacketToBuffer(INodePacket packet)
+        {
+            // Clear the buffer but keep the underlying capacity to avoid reallocations.
+            _writeBuffer.SetLength(HeaderLength);
+            _writeBuffer.Position = HeaderLength;
+
+            // Serialize and write the packet to the buffer.
+            packet.Translate(_writeTranslator);
+
+            // Write the header to the buffer.
+            _writeBuffer.Position = 0;
+            _writeBuffer.WriteByte((byte)packet.Type);
+            int messageLength = (int)_writeBuffer.Length;
+            _writeTranslator.Writer.Write(messageLength - HeaderLength);
+
+            return messageLength;
+        }
+
+        private int Read(byte[] buffer, int bytesToRead)
+        {
+            int totalBytesRead = 0;
+            while (totalBytesRead < bytesToRead)
+            {
+                int bytesRead = NodeStream.Read(buffer, totalBytesRead, bytesToRead - totalBytesRead);
+
+                // 0 byte read will occur if the pipe disconnects.
+                if (bytesRead == 0)
+                {
+                    break;
+                }
+
+                totalBytesRead += bytesRead;
+            }
+
+            return totalBytesRead;
+        }
+
+#if !TASKHOST
+        private async ValueTask<int> ReadAsync(byte[] buffer, int bytesToRead, CancellationToken cancellationToken)
+        {
+            int totalBytesRead = 0;
+            while (totalBytesRead < bytesToRead)
+            {
+#if NET
+                int bytesRead = await NodeStream.ReadAsync(buffer.AsMemory(totalBytesRead, bytesToRead - totalBytesRead), cancellationToken).ConfigureAwait(false);
+#else
+                int bytesRead = await NodeStream.ReadAsync(buffer, totalBytesRead, bytesToRead - totalBytesRead, cancellationToken).ConfigureAwait(false);
+#endif
+
+                // 0 byte read will occur if the pipe disconnects.
+                if (bytesRead == 0)
+                {
+                    break;
+                }
+
+                totalBytesRead += bytesRead;
+            }
+
+            return totalBytesRead;
+        }
+#endif
+
+        private INodePacket DeserializePacket()
+        {
+            if (_packetFactory == null)
+            {
+                throw new InternalErrorException("No packet factory is registered for deserialization.");
+            }
+
+            NodePacketType packetType = (NodePacketType)_headerData[0];
+            try
+            {
+                return _packetFactory.DeserializePacket(packetType, _readTranslator);
+            }
+            catch (Exception e) when (e is not InternalErrorException)
+            {
+                throw new InternalErrorException($"Exception while deserializing packet {packetType}: {e}");
+            }
+        }
+    }
+}
diff --git a/src/Shared/NodePipeClient.cs b/src/Shared/NodePipeClient.cs
new file mode 100644
index 00000000000..6be1e0e422b
--- /dev/null
+++ b/src/Shared/NodePipeClient.cs
@@ -0,0 +1,90 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.IO.Pipes;
+using System.Security.Principal;
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Internal
+{
+    internal sealed class NodePipeClient : NodePipeBase
+    {
+        /// <summary>
+        /// If true, sets a timeout for the handshake. This is only used on Unix-like socket implementations, because the
+        /// timeout on the PipeStream connection is ignore.
+        /// </summary>
+        private static readonly bool s_useHandhakeTimeout = !NativeMethodsShared.IsWindows;
+
+        private readonly NamedPipeClientStream _pipeClient;
+
+        internal NodePipeClient(string pipeName, Handshake handshake)
+            : base(pipeName, handshake) =>
+#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+            _pipeClient = new(
+                serverName: ".",
+                pipeName,
+                PipeDirection.InOut,
+                PipeOptions.Asynchronous
+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                | PipeOptions.CurrentUserOnly
+#endif
+            );
+#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+
+        protected override PipeStream NodeStream => _pipeClient;
+
+        internal void ConnectToServer(int timeout)
+        {
+            CommunicationsUtilities.Trace("Attempting connect to pipe {0} with timeout {1} ms", PipeName, timeout);
+            _pipeClient.Connect(timeout);
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+            // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has
+            // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to
+            // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can
+            // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up
+            // remote node could set the owner to something else would also let it change owners on other objects, so
+            // this would be a security flaw upstream of us.
+            ValidateRemotePipeOwner();
+#endif
+            PerformHandshake(s_useHandhakeTimeout ? timeout : 0);
+            CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", PipeName);
+        }
+
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+        // This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code
+        //  on non-Windows operating systems
+        private void ValidateRemotePipeOwner()
+        {
+            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
+            PipeSecurity remoteSecurity = _pipeClient.GetAccessControl();
+            IdentityReference remoteOwner = remoteSecurity.GetOwner(typeof(SecurityIdentifier));
+
+            if (remoteOwner != identifier)
+            {
+                CommunicationsUtilities.Trace("The remote pipe owner {0} does not match {1}", remoteOwner.Value, identifier.Value);
+                throw new UnauthorizedAccessException();
+            }
+        }
+#endif
+
+        /// <summary>
+        /// Connect to named pipe stream and ensure validate handshake and security.
+        /// </summary>
+        private void PerformHandshake(int timeout)
+        {
+            for (int i = 0; i < HandshakeComponents.Length; i++)
+            {
+                CommunicationsUtilities.Trace("Writing handshake part {0} ({1}) to pipe {2}", i, HandshakeComponents[i], PipeName);
+                _pipeClient.WriteIntForHandshake(HandshakeComponents[i]);
+            }
+
+            // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
+            _pipeClient.WriteEndOfHandshakeSignal();
+
+            CommunicationsUtilities.Trace("Reading handshake from pipe {0}", PipeName);
+            _pipeClient.ReadEndOfHandshakeSignal(true, timeout);
+        }
+    }
+}
diff --git a/src/Shared/NodePipeServer.cs b/src/Shared/NodePipeServer.cs
new file mode 100644
index 00000000000..91fba144c52
--- /dev/null
+++ b/src/Shared/NodePipeServer.cs
@@ -0,0 +1,220 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.IO.Pipes;
+using System.Security.AccessControl;
+using System.Security.Principal;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+
+#if !TASKHOST
+using System.Threading.Tasks;
+#endif
+
+namespace Microsoft.Build.Internal
+{
+    internal sealed class NodePipeServer : NodePipeBase
+    {
+        /// <summary>
+        /// The size of kernel-level buffers used by the named pipe. If the total size of pending reads or write requests exceed
+        /// this amount (known as the quota), IO will block until either pending operations complete, or the OS increases the quota.
+        /// </summary>
+        private const int PipeBufferSize = 131_072;
+
+        /// <summary>
+        /// A timeout for the handshake. This is only used on Unix-like socket implementations, because the
+        /// timeout on the PipeStream connection is ignore.
+        /// </summary>
+        private static readonly int s_handshakeTimeout = NativeMethodsShared.IsWindows ? 0 : 60_000;
+
+        private readonly NamedPipeServerStream _pipeServer;
+
+        internal NodePipeServer(string pipeName, Handshake handshake, int maxNumberOfServerInstances = 1)
+            : base(pipeName, handshake)
+        {
+            PipeOptions pipeOptions = PipeOptions.Asynchronous;
+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+            pipeOptions |= PipeOptions.CurrentUserOnly;
+#else
+            // Restrict access to just this account.  We set the owner specifically here, and on the
+            // pipe client side they will check the owner against this one - they must have identical
+            // SIDs or the client will reject this server.  This is used to avoid attacks where a
+            // hacked server creates a less restricted pipe in an attempt to lure us into using it and
+            // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
+            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite, AccessControlType.Allow);
+            PipeSecurity security = new();
+            security.AddAccessRule(rule);
+            security.SetOwner(rule.IdentityReference);
+#endif
+
+            _pipeServer = new NamedPipeServerStream(
+                pipeName,
+                PipeDirection.InOut,
+                maxNumberOfServerInstances,
+                PipeTransmissionMode.Byte,
+                pipeOptions,
+                inBufferSize: PipeBufferSize,
+                outBufferSize: PipeBufferSize
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                , security,
+                HandleInheritability.None
+#endif
+#pragma warning disable SA1111 // Closing parenthesis should be on line of last parameter
+                );
+#pragma warning restore SA1111 // Closing parenthesis should be on line of last parameter
+        }
+
+        protected override PipeStream NodeStream => _pipeServer;
+
+        internal LinkStatus WaitForConnection()
+        {
+            DateTime originalWaitStartTime = DateTime.UtcNow;
+            bool gotValidConnection = false;
+
+            while (!gotValidConnection)
+            {
+                gotValidConnection = true;
+                DateTime restartWaitTime = DateTime.UtcNow;
+
+                // We only wait to wait the difference between now and the last original start time, in case we have multiple hosts attempting
+                // to attach.  This prevents each attempt from resetting the timer.
+                TimeSpan usedWaitTime = restartWaitTime - originalWaitStartTime;
+                int waitTimeRemaining = Math.Max(0, CommunicationsUtilities.NodeConnectionTimeout - (int)usedWaitTime.TotalMilliseconds);
+
+                try
+                {
+                    // Wait for a connection
+#if TASKHOST
+                    IAsyncResult resultForConnection = _pipeServer.BeginWaitForConnection(null, null);
+                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
+                    bool connected = resultForConnection.AsyncWaitHandle.WaitOne(waitTimeRemaining, false);
+                    _pipeServer.EndWaitForConnection(resultForConnection);
+#else
+                    Task connectionTask = _pipeServer.WaitForConnectionAsync();
+                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
+                    bool connected = connectionTask.Wait(waitTimeRemaining);
+#endif
+                    if (!connected)
+                    {
+                        CommunicationsUtilities.Trace("Connection timed out waiting a host to contact us.  Exiting comm thread.");
+                        return LinkStatus.ConnectionFailed;
+                    }
+
+                    CommunicationsUtilities.Trace("Parent started connecting. Reading handshake from parent");
+
+                    // The handshake protocol is a series of int exchanges.  The host sends us a each component, and we
+                    // verify it. Afterwards, the host sends an "End of Handshake" signal, to which we respond in kind.
+                    // Once the handshake is complete, both sides can be assured the other is ready to accept data.
+                    try
+                    {
+                        gotValidConnection = ValidateHandshake();
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                        gotValidConnection &= ValidateClientIdentity();
+#endif
+                    }
+                    catch (IOException e)
+                    {
+                        // We will get here when:
+                        // 1. The host (OOP main node) connects to us, it immediately checks for user privileges
+                        //    and if they don't match it disconnects immediately leaving us still trying to read the blank handshake
+                        // 2. The host is too old sending us bits we automatically reject in the handshake
+                        // 3. We expected to read the EndOfHandshake signal, but we received something else
+                        CommunicationsUtilities.Trace("Client connection failed but we will wait for another connection. Exception: {0}", e.Message);
+                        gotValidConnection = false;
+                    }
+                    catch (InvalidOperationException)
+                    {
+                        gotValidConnection = false;
+                    }
+
+                    if (!gotValidConnection && _pipeServer.IsConnected)
+                    {
+                        _pipeServer.Disconnect();
+                    }
+                }
+                catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+                {
+                    CommunicationsUtilities.Trace("Client connection failed.  Exiting comm thread. {0}", e);
+                    if (_pipeServer.IsConnected)
+                    {
+                        _pipeServer.Disconnect();
+                    }
+
+                    ExceptionHandling.DumpExceptionToFile(e);
+                    return LinkStatus.Failed;
+                }
+            }
+
+            return LinkStatus.Active;
+        }
+
+        internal void Disconnect()
+        {
+            try
+            {
+                if (_pipeServer.IsConnected)
+                {
+#if NET // OperatingSystem.IsWindows() is new in .NET 5.0
+                    if (OperatingSystem.IsWindows())
+#endif
+                    {
+                        _pipeServer.WaitForPipeDrain();
+                    }
+
+                    _pipeServer.Disconnect();
+                }
+            }
+            catch (Exception)
+            {
+                // We don't really care if Disconnect somehow fails, but it gives us a chance to do the right thing.
+            }
+        }
+
+        private bool ValidateHandshake()
+        {
+            for (int i = 0; i < HandshakeComponents.Length; i++)
+            {
+                // This will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard.
+                int handshakePart = _pipeServer.ReadIntForHandshake(byteToAccept: i == 0 ? CommunicationsUtilities.handshakeVersion : null, s_handshakeTimeout);
+
+                if (handshakePart != HandshakeComponents[i])
+                {
+                    CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, HandshakeComponents[i]);
+                    _pipeServer.WriteIntForHandshake(i + 1);
+                    return false;
+                }
+            }
+
+            // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
+            _pipeServer.ReadEndOfHandshakeSignal(false, s_handshakeTimeout);
+
+            CommunicationsUtilities.Trace("Successfully connected to parent.");
+            _pipeServer.WriteEndOfHandshakeSignal();
+
+            return true;
+        }
+
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+        private bool ValidateClientIdentity()
+        {
+            // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
+            // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
+            // user we were started by.
+            WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
+            WindowsIdentity? clientIdentity = null;
+            _pipeServer.RunAsClient(() => { clientIdentity = WindowsIdentity.GetCurrent(true); });
+
+            if (clientIdentity == null || !string.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
+            {
+                CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
+                return false;
+            }
+
+            return true;
+        }
+#endif
+
+    }
+}
diff --git a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
index 91b192b37a9..5753a79bada 100644
--- a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
+++ b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
@@ -27,7 +27,7 @@
       "type": "parameter",
       "description": "Overrides the default Microsoft.Build version where check's interfaces are placed",
       "datatype": "text",
-      "defaultValue": "17.14.0",
+      "defaultValue": "17.15.0",
       "replaces": "1.0.0-MicrosoftBuildPackageVersion",
       "displayName": "Microsoft.Build default package version override"
     }
