diff --git a/.editorconfig b/.editorconfig
index 90ed95160d4..7b0f1419bb8 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -401,3 +401,11 @@ dotnet_diagnostic.IDE0270.severity = suggestion
 
 # naming rule violation
 dotnet_diagnostic.IDE1006.severity = suggestion
+
+# Use primary constructor
+dotnet_diagnostic.IDE0290.severity = suggestion
+
+# Collection initialization can be simplified
+dotnet_diagnostic.IDE0300.severity = suggestion
+dotnet_diagnostic.IDE0301.severity = suggestion
+dotnet_diagnostic.IDE0305.severity = suggestion
diff --git a/.exp-insertions.yml b/.exp-insertions.yml
new file mode 100644
index 00000000000..2c8a1c06a1a
--- /dev/null
+++ b/.exp-insertions.yml
@@ -0,0 +1,220 @@
+# Pipeline creates experimental msbuild insertions.
+
+trigger: none # Prevents this pipeline from triggering on check-ins
+pr: none # don't run this on PR as well
+
+parameters:
+  # Dotnet installer channel from which to take the latest dotnet bits.
+  - name: DotnetInstallerChannel
+    displayName: Dotnet installer channel
+    type: string
+    default: 'none'
+  # VS version for which to take the latest Retail MSBuild bits.
+  - name: VSVersionName
+    displayName: VS Version
+    type: string
+    default: 'none'
+  # Branch from the MSBuild Build CI pipeline. Default: main
+  # Top run for the branch would be used to create an experimental insertion.
+  - name: MSBuildBranch
+    displayName: MSBuild Branch
+    type: string
+    default: 'refs/heads/main'
+  # BuildID from the MSBuild Build CI pipeline. Overrides the choice of MSBuildBranch parameter
+  - name: MSBuildBuildID
+    displayName: MSBuild CI Run Override
+    type: string
+    default: 'default'
+
+variables:
+  - name: _MsBuildCiPipelineId
+    value: 9434
+  - name: _MSBuildConfigFilePathRequestURL
+    value: 'https://dev.azure.com/cloudbuild/CloudBuild/_apis/git/repositories/CloudBuildConfig/items?versionDescriptor.version=main&path=config/batmon/Q-Prod-Co3/Coordinator/ToolsReleaseConfig-GeneralPublic.json&api-version=5.0'
+  - name: VSVersion
+    value: ${{parameters.VSVersionName}}
+
+pool:
+  vmImage: windows-latest
+
+jobs:
+- job: CreateExpDotnet
+  displayName: Create Experimental Dotnet
+  condition: ne('${{ parameters.DotnetInstallerChannel }}', 'none')
+  steps:
+  - powershell: |
+      mkdir '$(System.ArtifactsDirectory)/installer'
+
+      $dotnetChannel = '${{parameters.DotnetInstallerChannel}}'
+      $sdks = "dotnet-sdk-win-x64.zip", "dotnet-sdk-linux-x64.tar.gz"
+
+      foreach ($sdk in $sdks)
+      {
+        Write-Host "Downloading dotnet $sdk from channel $dotnetChannel"
+        Invoke-WebRequest `
+          -Uri "https://aka.ms/dotnet/$dotnetChannel/daily/$sdk" `
+          -OutFile "$(System.ArtifactsDirectory)/installer/$sdk"
+      }
+      mkdir '$(Pipeline.Workspace)/artifacts'
+    displayName: Download latest dotnet sdks
+
+  - task: DownloadBuildArtifacts@1
+    inputs:
+      buildType: specific
+      project: DevDiv
+      pipeline: $(_MsBuildCiPipelineId)
+      ${{ if eq(parameters.MSBuildBuildID, 'default') }}:
+        buildVersionToDownload: latestFromBranch
+        branchName: '${{parameters.MSBuildBranch}}'
+      ${{ else }}:
+        buildVersionToDownload: specific
+        buildId: ${{parameters.MSBuildBuildID}}
+      artifactName: bin
+      itemPattern: 'MSBuild.Bootstrap/**'
+      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
+    displayName: Download msbuild artifacts
+
+  - powershell: |
+      $sdk = "dotnet-sdk-win-x64"
+
+      Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.zip"
+      Expand-Archive "$(System.ArtifactsDirectory)/installer/$sdk.zip" -DestinationPath "$(Pipeline.Workspace)/exp-dotnet/$sdk"
+
+      $dotnetDirectory = Get-ChildItem -Directory -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk"
+      $dotnetVersion = $dotnetDirectory.Name
+      Write-Host "Detected dotnet version: $dotnetVersion"
+
+      Write-Host "Updating MSBuild dlls."
+      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
+        -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
+        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
+        -configuration Release `
+        -makeBackup $false
+
+      Write-Host "Compressing dotnet sdk files"
+      Get-ChildItem -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk" | Compress-Archive -DestinationPath "$(Pipeline.Workspace)/artifacts/$sdk.zip"
+
+    displayName: Dogfood msbuild dlls to dotnet sdk win-x64
+
+  - powershell: |
+      $sdk = "dotnet-sdk-linux-x64"
+
+      mkdir "$(Pipeline.Workspace)/exp-dotnet/$sdk"
+
+      Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.tar.gz"
+      tar -xzvf "$(System.ArtifactsDirectory)/installer/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk"
+
+      $dotnetDirectory = Get-ChildItem -Directory -Path $(Pipeline.Workspace)/exp-dotnet/$sdk/sdk
+      $dotnetVersion = $dotnetDirectory.Name
+      Write-Host "Detected dotnet version: $dotnetVersion"
+
+      Write-Host "Updating MSBuild dlls."
+      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
+        -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
+        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
+        -configuration Release `
+        -makeBackup $false
+
+      Write-Host "Compressing dotnet sdk files"
+      tar -czvf "$(Pipeline.Workspace)/artifacts/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk" .
+    displayName: Dogfood msbuild dlls to dotnet sdk linux-x64
+
+  - task: PublishPipelineArtifact@1
+    inputs:
+      targetPath: '$(Pipeline.Workspace)/artifacts'
+      artifactName: ExperimentalDotnet
+      parallel: true
+    condition: always()
+    displayName: Publish crank assests artifacts
+
+
+- job: CreateExpMSBuild
+  displayName: "Create Experimental MSBuild"
+  condition: ne('${{ parameters.VSVersionName }}', 'none')
+  steps:
+  - powershell: |
+      $token = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes("PAT:$env:ACCESSTOKEN"))
+      $headers = @{ Authorization = "Basic $token" };
+      $response = Invoke-RestMethod -Uri "$(_MSBuildConfigFilePathRequestURL)" -Headers $headers -Method Get
+      $MSBuildDropPath = $response.Tools.MSBuild.Locations
+      Write-Host "##vso[task.setvariable variable=MSBuildDropPath]$MSBuildDropPath"
+      Write-Host "MSBuild Drop Path directory: $MSBuildDropPath"
+    displayName: Get Retail MSBuild Drop Path
+    env:
+      ACCESSTOKEN: $(cloudbuild-token)
+
+  - task: NuGetToolInstaller@1
+    displayName: 'Install NuGet.exe'
+
+  - task: NuGetCommand@2
+    displayName: Restore internal tools
+    inputs:
+      command: restore
+      feedsToUse: config
+      restoreSolution: '$(Build.SourcesDirectory)\eng\common\internal\Tools.csproj'
+      nugetConfigPath: '$(Build.SourcesDirectory)\NuGet.config'
+      restoreDirectory: '$(Build.SourcesDirectory)\.packages'
+
+  - powershell: |
+      mkdir "$(Pipeline.Workspace)/artifacts"
+
+      $dropAppDirectory = Get-ChildItem -Directory -Path "$(Build.SourcesDirectory)/.packages/drop.app"
+      $dropAppVersion = $dropAppDirectory.Name
+      Write-Host "Detected drop.exe version: $dropAppVersion"
+
+      $dropExePath = "$(Build.SourcesDirectory)/.packages/drop.app/$dropAppVersion/lib/net45/drop.exe"
+      Write-Host "Detected drop.exe path: $dropExePath"
+
+      Write-Host "Downloading VS msbuild"
+      & "$dropExePath" get --patAuthEnvVar 'cloudbuild-token' -u "$(MSBuildDropPath)\$(VSVersion)" -d "$(System.ArtifactsDirectory)/VSMSBuildDrop"
+      Write-Host "Download of VS msbuild finished"
+
+      Write-Host "Copying VS msbuild to $(Pipeline.Workspace)/VSMSBuild"
+      Copy-Item -Path "$(System.ArtifactsDirectory)/VSMSBuildDrop/*" -Destination "$(Pipeline.Workspace)/VSMSBuild" -Recurse
+      Write-Host "Copy of VS msbuild finished"
+    displayName: Download msbuild vs drop
+    env:
+      cloudbuild-token: $(cloudbuild-token)
+
+  - task: DownloadBuildArtifacts@1
+    inputs:
+      buildType: specific
+      project: DevDiv
+      pipeline: $(_MsBuildCiPipelineId)
+      ${{ if eq(parameters.MSBuildBuildID, 'default') }}:
+        buildVersionToDownload: latestFromBranch
+        branchName: '${{parameters.MSBuildBranch}}'
+      ${{ else }}:
+        buildVersionToDownload: specific
+        buildId: ${{parameters.MSBuildBuildID}}
+      artifactName: bin
+      itemPattern: |
+        MSBuild.Bootstrap/*/net472/**
+        Microsoft.Build.Conversion/*/net472/Microsoft.Build.Conversion.Core.dll
+        Microsoft.Build.Engine/*/net472/Microsoft.Build.Engine.dll
+        MSBuildTaskHost/**/MSBuildTaskHost.exe
+        MSBuildTaskHost/**/MSBuildTaskHost.pdb
+        MSBuild/*/*/net472/MSBuild.exe*
+      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
+    displayName: Download msbuild artifacts
+
+  - powershell: |
+      Write-Host "Updating MSBuild dlls."
+      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
+        -destination "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)/MSBuild/Current/Bin" `
+        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
+        -configuration Release `
+        -makeBackup $false
+
+      ls "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)"
+      Write-Host "Compressing msbuild files"
+      Get-ChildItem -Path "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)" | Compress-Archive -DestinationPath "$(Pipeline.Workspace)/artifacts/MSBuild.zip"
+    displayName: Dogfood msbuild dlls
+
+  - task: PublishPipelineArtifact@1
+    inputs:
+      targetPath: '$(Pipeline.Workspace)/artifacts'
+      artifactName: ExperimentalMSBuild
+      parallel: true
+    condition: always()
+    displayName: Publish crank assests artifacts
diff --git a/.vsconfig b/.vsconfig
index a3598fb5a7f..c2d22f4da9f 100644
--- a/.vsconfig
+++ b/.vsconfig
@@ -1,12 +1,7 @@
 {
   "version": "1.0",
   "components": [
-    "Microsoft.Net.Component.4.8.SDK",
-    "Microsoft.Net.Component.4.7.2.SDK",
-    "Microsoft.Net.Component.4.TargetingPack",
-    "Microsoft.Net.Component.4.7.2.TargetingPack",
     "Microsoft.VisualStudio.Workload.ManagedDesktop",
-    "Microsoft.Net.Component.3.5.DeveloperTools",
-    "Microsoft.VisualStudio.Workload.NetCoreTools"
+    "Microsoft.Net.Component.3.5.DeveloperTools"
   ]
 }
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 343cec26283..2ba5520cff6 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -40,6 +40,8 @@ variables:
     value: true
   - name: Codeql.Enabled
     value: true
+  - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest')) }}:
+    - group: DotNet-MSBuild-SDLValidation-Params
 
 stages:
 - stage: build
@@ -215,6 +217,7 @@ stages:
       inputs:
         DropName: $(VisualStudio.DropName)
         DropFolder: 'artifacts\VSSetup\$(BuildConfiguration)\Insertion'
+        DropRetentionDays: '30' # extended by insertion + VS release
         AccessToken: '$(System.AccessToken)'
         DropServiceUri: 'https://devdiv.artifacts.visualstudio.com'
         VSDropServiceUri: 'https://vsdrop.corp.microsoft.com/file/v1'
@@ -294,3 +297,17 @@ stages:
       enableSymbolValidation: false
       enableSourceLinkValidation: false
       enableNugetValidation: false
+      SDLValidationParameters:
+        enable: true
+        continueOnError: false
+        params: ' -SourceToolsList @("policheck","credscan")
+        -TsaInstanceURL "$(_TsaInstanceURL)"
+        -TsaProjectName "$(_TsaProjectName)"
+        -TsaNotificationEmail "$(_TsaNotificationEmail)"
+        -TsaCodebaseAdmin "$(_TsaCodebaseAdmin)"
+        -TsaBugAreaPath "$(_TsaBugAreaPath)"
+        -TsaIterationPath "$(_TsaIterationPath)"
+        -TsaRepositoryName "dotnet-msbuild"
+        -TsaCodebaseName "dotnet-msbuild"
+        -TsaPublish $True
+        -PoliCheckAdditionalRunConfigParams @("UserExclusionPath < $(Build.SourcesDirectory)\eng\policheck_exclusions.xml")'
diff --git a/NuGet.config b/NuGet.config
index 4e9907ea835..d7187b4d64a 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -8,6 +8,7 @@
     <add key="dotnet6" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json" />
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
+    <add key="BuildXL" value="https://pkgs.dev.azure.com/ms/BuildXL/_packaging/BuildXL/nuget/v3/index.json" />
   </packageSources>
   <disabledPackageSources />
 </configuration>
diff --git a/documentation/specs/proposed/interactive-package-references.md b/documentation/specs/proposed/interactive-package-references.md
new file mode 100644
index 00000000000..b01805575d6
--- /dev/null
+++ b/documentation/specs/proposed/interactive-package-references.md
@@ -0,0 +1,217 @@
+# Packages Sourcing
+
+The feature is meant to simplify the process of fixing, testing and contributing changes in projects published as nugets.
+
+It is inspired by the golang modules design - where a standalone dependency (module) has a pointer to it's source location as a first-class citizen within the ecosystem (go.mod) and the relation between the source codes and runtime dependecy is unambigously guaranteed by the compiler.
+
+# North Star / Longer-term vision
+
+We envision the 'packages sourcing' to be a first-class-citizen within nuget client (and hence [`dotnet restore`](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-restore)). Via denoting specific metadata on `PackageReference` it would be possible to perform specific mode of restore operation for the particular package reference - by pointing to a local sources, or letting the command to figure out and fetch apropriate sources:
+
+```xml
+<Project Sdk="Microsoft.NET.Sdk">
+  <ItemGroup>
+    <PackageReference Include="Newtonsoft.Json" ResolveAsSources="true" />
+    <PackageReference Include="Contoso.CommonPackage" ResolveAsSources="true" SourcesLocation="$(MSBuildProjectDirectory)/../CommonPackage/src/CommonPackage.csproj" />
+  </ItemGroup>
+</Project>
+```
+
+```
+dotnet restore MyProj.csproj  
+```
+
+The command would resolve and fetch remote sources of proper revision (unless explicitly pointed to local sources with active changes), build the dependency and add it to `project.assets.json` indicating the sources expansion.
+
+There would need to be special treatment for some aspect of behavior of `PackageReference` that diverges or are not defined for source code references (`ProjectReference`), listed in https://github.com/dotnet/msbuild/issues/8507.
+
+A special metadata (possibly within the nuget package, optionaly within the source repo) might be needed to ensure the proper infering of the build in more involved scenarios (or to disallow package sourcing for particular package).
+
+One of the goals of the initial iteration is to identify the limitations of automatic infering of the build and turining the `PackageReference` to `ProjectReference`. 
+
+# Scope of initial iteration
+
+The initial proof of concept of the feature is envisioned to be facilitated via [`SourceLink`](https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink) repository metadata, [`PE headers`](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.portableexecutable.peheaders?view=net-7.0) and pdb metadata ([`MetadataReader`](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.metadata.metadatareader)), in-memory or persistent switching between `PackageReference` and `ProjectReference` and possibly verification of proper outputs (for `deterministic build` enabled projects).
+
+## In scope
+* Standalone dotnet tool for initiating the `Package Sourcing` of particular nuget(s) via locating and fetching sources, infering the build and flipping `PackageReference` to `ProjectReference`
+
+## Out of scope
+ * **Patching the package/binary dependencies in a deployable way**. The interaction is ment to be used only on developer machine and not survive beyond repository push, external environment deployment etc.
+ * **Survival of patches accross `PackageReference` updates**.
+ * **Supporting nuget packages that are not `SourceLink` enabled**. As a fallback we might use `SourceLink` stamped symbols, but unless the `SourceLink` information is to be found either within the nuget package or published matching symbols, this feature will not be enabled.
+ * **Custom pre-build prerequisities**. First version of the feature will make several assumptions on common ways to build packages from source repository (attempt to build just the project with `dotnet build`, attempt to locate `*.sln` or `build.<cmd|sh|ps1>` script or existence of reproducible build compiler flags)
+
+# User scenarios
+
+## OSS package reference
+* Alice is referencing FooBar nuget in her project and she is using automated PRs (e.g. dependabot) to consume the latest available version
+* A new version of FooBar nuget is published, automated PR into Alice project is created to update the `PackageReference` and the PR is failing
+* Alice is investigating the issue and suspecting problem in FooBar library. If the package was properly SourceLink-ed and symbols published, Alice can debug into the code and diagnose the issue
+* Alice would like to try to fix the issue, test the fix and contribute back to the OSS. She can achieve this with `Packages Sourcing` feature
+
+## Internal corp package flows
+* Bob is working in Contoso co. Contoso co. has dozens of internal repositories and internal package feed used to publish and consume the artifacts of individual repositories
+* Bob is working on component that is consuming another component - BarBaz - as a nuget package.
+* Bob wants to contribute an improvement to component BarBaz, that would be leveraged by his component. He wants to first test the improvement with his component before contributing back to the BarBaz. He can achieve this with `Packages Sourcing` feature
+
+## (Out of scope) Source as package reference
+* Bob from previous scenario needs to work on couple of components that interact with each other and which reference themselves via `PackageReference`s.
+* To simplify his work, Bob wants to include locations with components source code as reference locations for resolving `PackageReference`s, while he'd expect the build to properly interpret the components sources as packages (provided those can be successfuly build and packed)
+* Alteration of this sceanrio is referencing a reference via git repo link and commit hash (analogously to go modules).
+
+# Design proposal
+
+![control flow proposal](packagessourcing-control-flow.jpg)
+
+ ## Subproblems
+
+ * Opting-in mechanism - to request switch to local sources
+ * Preserving the info about swtich to local sources
+ * Opting-out mechanism - to switch back to regular package reference
+ * Local storage of sources - submodule vs standalone checkout
+ * Indication mechanism informing the user about usage of local sources (especially in case where local patch is applied)
+ * Locating and fetching proper source codes
+ * Infering the proper 'build recipe' for the binary and verifying the result (in case of determinictic build)
+ * Verifying that the locally build package is correct - leveraging deterministic build; signature stripping etc.
+ * Converting `PackageReference` to `ProjectReference`
+ * Allowing to quickly consume local code patches (via edit and continue/ hot reload mechanism)
+
+ Some of those problems might be eliminated by simplifying the workflow and e.g. providing a command that prepares a project and edits the original MSBuild file to replace `PackageReference` with `ProjectReference` - the consuming of code patches and indicating the altered reference to user would not be needed.
+ 
+ ## Possible Implementations
+
+ Following sections discuss possible implementations of individual [subproblems outlined above](#subproblems).
+
+ ### Opting-in
+
+ For simplified and isolated rollout of this feature we propose CLI-only interface (no VS or other tooling integration):
+
+```cmd
+> dotnet tool install Microsoft.Build.PackageSourcing
+> dotnet package-to-sources --project MySolution.sln --packages: FooBar.Baz, Newtonsoft.Json
+
+FooBar.Baz:
+Sources located: github.com/FooBar/Baz@0abcb66
+Local checkout: C:\Users\jankrivanek\.nuget\sources\FooBar\6.5.4\
+Build instructions located: FooBar-package-sourcing.proj
+Build reconstructed: OK
+Reference replaced: OK
+
+Newtonsoft.Json:
+...
+
+Sourced packages are ready to use.
+
+>
+```
+
+This as well solves the question of preserving the info about packages sourcing.
+
+### Opting-out
+
+This can be achieved via adding a metadata to mofdified MSBuild files, storing the info about original `PackageReference`s and then reverting those via another CLI command:
+
+```cmd
+> dotnet package-to-sources --revert --project MySolution.sln --packages: FooBar.Baz, Newtonsoft.Json
+
+Successfuly reverted packages sourcing for: FooBar.Baz, Newtonsoft.Json.
+>
+```
+
+### Local storage of sources
+
+To be decided (nuget cache?, Submodules of the current git context?, sibling folder of current project git root?, the `.vs` folder (for vs-centric solution)?, `%temp%`? ...)
+
+We can take inspiration from VS debugger decompilation features:
+
+![vs decompiled sources](https://learn.microsoft.com/en-us/visualstudio/debugger/media/decompilation-solution-explorer.png?view=vs-2022)
+
+![vs nuget source](https://devblogs.microsoft.com/visualstudio/wp-content/uploads/sites/4/2021/08/word-image-17.png)
+
+ ### Locating proper sources
+ * Most preferable way is via `SourceLink` metadata within the nuget package itself ([documentation](https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink), [reading the metadata](https://learn.microsoft.com/en-us/nuget/reference/nuget-client-sdk#get-package-metadata))
+ * Fallback to `SourceLink` metadata within symbol files ([documentation](https://learn.microsoft.com/en-us/cpp/build/reference/sourcelink?view=msvc-170), [Portable PDB format spec](https://github.com/dotnet/runtime/blob/main/docs/design/specs/PortablePdb-Metadata.md), [reading source locations metadata](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/tests/Metadata/PortablePdb/DocumentNameTests.cs))
+ * We should consider ability to specify/pass-in a custom location of sources - this would facilitate portion of the 'Source as package reference' scenario (possibly something that might be usable for our 'source build' or 'VMR build').
+
+ ### Infering the 'build recipe'
+ This is the most challenging part of the story - as .NET ecosystem currently doesn't enforce custom build pre-requisities standards nor conventions and hence it is not possible to replicate the package build process without possible manual steps. This part will hence be 'best efforts' with sensible communication of issues to user. 
+ 
+ We envision multiple options to achieve this goal (with possibility of fallback/combination of multiple approaches):
+ * Option A: Using Pdb info/ Roslyn to extract information from PE/Pdbs and reconstruct the compilation ([roslyn experimental code](https://github.com/dotnet/roslyn/blob/main/src/Tools/BuildValidator/Program.cs#L268), [NugetPackageExplorer SymbolValidator](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer/blob/main/Core/SymbolValidation/SymbolValidator.cs#L145)). Access to symbol files (whether published as .snupkg on nuget.org or on microsoft or corporate symbols servers) is crucial for this method. As well as usage of particualr compiler toolchain used to generate the inspected package ([sdk 5.0.3 or MSBuild 16.10](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer/commit/a272c8c314257dfa99c6befd2cfeff39b8a6ecbe)). Prototyping task: https://github.com/dotnet/msbuild/issues/8511
+ * Option B: Attempt to run build (`dotnet build`) on `.sln` in repo root or `src` folder, or fallback to discovery of most common build scripts in repo root (`build.<extension>` for few most common script types based on current OS). Prototyping task: https://github.com/dotnet/msbuild/issues/8512
+ * Option C: Sources crawling and finding project by name/assembly name; build; compare results.
+ * Option D: Working backwards from the nuget (finding pack script or msbuild properties indicating nuget creation ...); build; compare results
+ * Option E: Seting up convention for explicit description of build prerequisites and package build. Inspiration for this can be `.proj` files describing external dependencies build recipe in dotnet source build ([sample build descriptions](https://github.com/dotnet/source-build-externals/tree/main/repos)) or [`git dependencies`](https://fsprojects.github.io/Paket/git-dependencies.html) project for Paket
+
+
+**Gotchas:**
+ * The `Option A` above infers the 'compile recipe', but not the 'build recipe' - which means some checked out files would not have their standard expected functionality (they would be completely ignored) - resource files (`.resx`), templates for code generators (`.tt`, `.aspx`, `.xaml`, etc.) and most importantly the project file itself (`.csproj`/`.fsproj`/`.vbproj`/...).
+
+   Possible solutions: 
+    * (short term) Mark such files read-only, add explicit pre-compilation check throwing error if hash of such a file changes 
+    * (long term) For code generators we can extend SourceLink to add info to symbol file what code generator was used and store it on symbols server (or in Executable Image Search Path location)
+    * project files - ??? (though one)
+
+  * The `Option B` might not have acceptable success rate - it is still very appealing option if combined with other approach. 
+
+ * Discrepancies between the `PackageReference` and `ProjectReference` configurability and behavior (different metadata support, different behavior for some of the same metadata, different layout of the the bin outputs yielding some assumptions breaks, nuget support for packaged props/targets, etc.). Probably the biggest problem will be the usage of build features - build.props and build.targets (as those are placed during the project build, but couldn't be identicaly consumed during the same build as for the package reference)
+
+    Possible solutions: 
+      * Those differences needs to be researched/catalogued and categorized first, then we can decide what to consolidate and what will not be explicitly supported. Investigation item: https://github.com/dotnet/msbuild/issues/8507
+      * It might be beneficial to perform analysis of usage prevalence of the individual metadata. Investigation task: https://github.com/dotnet/msbuild/issues/8521
+ 
+ * Running a build script on a local machine is possible security risk - user should be properly warned and informed.
+ * Verifying the binary identity might add unnecesary high cost to the operation at unwanted time - the rebuild is likely needed only after user want to make a change. But the verification might stll be agood idea - especially for cases where we attempt to run a build script (and we might e.g. be running `build.sh` due to being on Unix, while official nuget was published from Windows build).
+ 
+   Possible solution: We might hold on until user makes a change and wants to test run it (we can then compare it with the version that was originaly downloaded - to perform a build verifying the binary identity of the original nuget binary and local reconstructed binary). In the ideal case the experience would be very seamless - user steps into the code during debugging (or via decompilation) and is allowed to perform change - if they perform change they are first asked to confirm that action and to acknowledge this will lead to running the component build on their machine. The current environment might even decide which of the build reconstruction techniques will be fastest based on the change the user made (e.g. single code file vs change to .resx etc.)
+
+ * Building the package on different SDK might lead to slightly different results - this we'll likely need to accept as limitation
+ * Global properties propagate nto the `ProjectReference`, wherease `PackageReference` is already built (example: `Debug` configuration can get propagated into `ProjectReference`, while the consumed `PackageReference` was build in `Release` mode).
+ 
+    Possible solution: Add 'Remove All Global Properties' feature for a project build.
+
+**_Extensive research needed for this subproblem._**
+
+ ### Verifying identity of local package with the feed one
+
+ In case deterministic build was opted-out, this would be very challenging and nearly impossible - so not supported.
+ For signed assemblies we'll need to strip signatures ([`ImageRemoveCertificate`](https://learn.microsoft.com/en-us/windows/win32/api/imagehlp/nf-imagehlp-imageremovecertificate)). Removing signature might nullify checksum bytes in PE header - so binary comparison to the locally built assembly might not match (solution is to temporarily remove the PE header checksum from the local binary as well - to facilitate binary equality).
+
+ ### Converting `PackageReference` to `ProjectReference`
+
+ [To Be Investigated]
+ There might be possible inconsitencies between [`PackageReference`](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) and [`ProjectReference`](https://learn.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items?view=vs-2022#projectreference) items metadata (and even behavior with same metadata - e.g. https://github.com/dotnet/msbuild/issues/4371).
+ So there needs to be some decision of what's supported and what not and what's the behavior for attempt to translate `PackageReference` using untranslatable metadata.
+
+ ### Allowing to quickly consume local code patches
+
+ To be decided.
+ But likely this will be no-op for the initial version - standard usage scenarios for project references will kick in.
+
+ # Security considerations
+
+ [Under construction]
+ * The build verification mode (out of scope) needs proper design of handling of symbols embedded files and pointers to any sources outside of expected repository root. (otherwise intruder with access to the production build can infect not only the binary, but the symbol file as well)
+ * MIM for the symbol server (offering crafted symbol file with pointers to custom sources that can allow execution of intruder code on the developer machine)
+ * Possible licensing considerations - there can be packages with different redistribution requirements for packages and originating sources, but allowing user to switch from package reference to source references we are technically making it easier for the user to miss and fail license agreement.
+
+ # Cross team dependencies considerations
+
+ * **Nuget - possible dependency** - the proposal doesn't evision changes to the nuget client nor server contracts. However it might be beneficial to consolidate behavior of `ProjectReference` and `PackageReference` items and its metadata - coorfination with nuget team would be helpful here.
+ * **Visual Studio, Project System - No dependency in initial version** - the proposal envision exposing functionality via CLI (and API) only, after the whole concept is constructed and alive, we should start reaching out to those teams to consider exposing the functionality via GUI - e.g.:
+ ![vs context menu proposal](sourcing-vs-context.png)
+ * **SDK - No dependency** - the initial version would be delivered as standalone (optional) dotnet tool
+ * **Roslyn - Consultation and engineering** - ideally packing and exporting the [BuildValidator](https://github.com/dotnet/roslyn/tree/main/src/Tools/BuildValidator) and mainly [Rebuild](https://github.com/dotnet/roslyn/tree/main/src/Compilers/Core/Rebuild). MSBuild team should fund this effort
+ * **MSBuild - Likely no dependency** - There migh need to be some support for allowing storing info about link between original PackageReference and injected ProjectReference - however current MSBuild constructs should suffice here. There might be some work needed to bring `PackageReference` and `ProjectReference` functionaly closer together (as outlined [above](#converting-packagereference-to-projectreference))
+
+ There can be possible leverage of the work by other teams:
+ * Nuget - [NugetPackageExplorrer](https://github.com/NuGetPackageExplorer/NuGetPackageExplorer) - as it currently heavily uses custom code to extract information from PE/Pdb metadata.
+ * Source Build / VMR - to validate buildability of 3rd party components and low touch process of enlisting new 3rd party dependencies into source build
+
+ # Links:
+  * https://github.com/NuGetPackageExplorer/NuGetPackageExplorer
+  * https://devblogs.microsoft.com/visualstudio/debugging-external-sources-with-visual-studio/
+  * https://devblogs.microsoft.com/visualstudio/decompilation-of-c-code-made-easy-with-visual-studio/
+  * https://learn.microsoft.com/en-us/visualstudio/debugger/decompilation?view=vs-2022
+  * https://fsprojects.github.io/Paket/git-dependencies.html
diff --git a/documentation/specs/proposed/packagessourcing-control-flow.jpg b/documentation/specs/proposed/packagessourcing-control-flow.jpg
new file mode 100644
index 00000000000..aff34456469
Binary files /dev/null and b/documentation/specs/proposed/packagessourcing-control-flow.jpg differ
diff --git a/documentation/specs/proposed/sourcing-vs-context.png b/documentation/specs/proposed/sourcing-vs-context.png
new file mode 100644
index 00000000000..20a852205d7
Binary files /dev/null and b/documentation/specs/proposed/sourcing-vs-context.png differ
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 402fe6eb556..508fa2dbc8b 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -23,11 +23,15 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ## Current Rotation of Change Waves
 
+### 17.10
+- [AppDomain configuration is serialized without using BinFmt](https://github.com/dotnet/msbuild/pull/9320) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
+
 ### 17.8
 - [[RAR] Don't do I/O on SDK-provided references](https://github.com/dotnet/msbuild/pull/8688)
 - [Delete destination file before copy](https://github.com/dotnet/msbuild/pull/8685)
-- [New serialization approach for transferring build exceptions between processes](https://github.com/dotnet/msbuild/pull/8779)
 - [Moving from SHA1 to SHA256 for Hash task](https://github.com/dotnet/msbuild/pull/8812)
+- [Deprecating custom derived BuildEventArgs](https://github.com/dotnet/msbuild/pull/8917) - feature can be opted out only if [BinaryFormatter](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.binary.binaryformatter) is allowed at runtime by editing `MSBuild.runtimeconfig.json`
+
 
 ### 17.6
 - [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
@@ -68,4 +72,4 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
 - [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
 - [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
-- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
\ No newline at end of file
+- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 02e1e308112..e6fee0282f8 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -229,6 +229,9 @@
     <Copy SourceFiles="@(NuGetSdkResolverManifest)"
           DestinationFolder="$(BootstrapDestination)SdkResolvers\Microsoft.Build.NuGetSdkResolver" />
 
+    <Copy SourceFiles="$(RuntimeIdentifierGraphPath)"
+          DestinationFolder="$(BootstrapDestination)" />
+
     <Copy SourceFiles="@(InstalledSdks)"
           DestinationFiles="@(InstalledSdks -> '$(BootstrapDestination)Sdks\%(RecursiveDir)%(Filename)%(Extension)')" />
 
diff --git a/eng/Packages.props b/eng/Packages.props
index 489ea061c95..ac8df77f629 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -25,7 +25,6 @@
     <PackageVersion Include="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageVersion Include="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
     <PackageVersion Include="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
-    <PackageVersion Include="System.Security.Permissions" Version="$(SystemSecurityPermissionsVersion)" />
     <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
diff --git a/eng/Signing.props b/eng/Signing.props
index 66347f3d9d1..3e8e6dbf5cc 100644
--- a/eng/Signing.props
+++ b/eng/Signing.props
@@ -1,9 +1,11 @@
 <Project>
   <ItemGroup>
     <ItemsToSign Include="$(VisualStudioSetupInsertionPath)Microsoft.Build.UnGAC.exe" />
+
+    <FileSignInfo Include="RuntimeContracts.dll" CertificateName="3PartySHA2" />
   </ItemGroup>
-    
+
   <PropertyGroup>
     <UseDotNetCertificate>true</UseDotNetCertificate>
   </PropertyGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 2ba60794cbf..58266b36960 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,11 +1,16 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ProductDependencies>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23414.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23516.4">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>45f5554ac6813e1e155c47fd80ec146c684f65e8</Sha>
+      <Sha>b4fa7f2e1e65ef49881be2ab2df27624280a8c55</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.CodeDom" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
     <!-- Necessary for source-build due to being a transitive dependency of System.Reflection.MetadataLoadContext.
       This allows the package to be retrieved from previously-source-built artifacts and flow in as dependencies
       of the packages produced by msbuild. -->
@@ -31,40 +36,50 @@
       <Uri>https://github.com/dotnet/runtime</Uri>
       <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
     </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Resources.Extensions" Version="7.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
     <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
       and flow in as dependencies of the packages produced by msbuild. -->
     <Dependency Name="System.Security.Cryptography.Pkcs" Version="7.0.2">
       <Uri>https://github.com/dotnet/runtime</Uri>
       <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
     </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.Xml" Version="7.0.1">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>d099f075e45d2aa6007a22b71b45a08758559f80</Sha>
+    </Dependency>
     <Dependency Name="System.Text.Json" Version="7.0.3">
       <Uri>https://github.com/dotnet/runtime</Uri>
       <Sha>5b20af47d99620150c53eaf5db8636fdf730b126</Sha>
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23419.1">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23463.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>385129cbc980a515ddee2fa56f6b16f3183ed9bc</Sha>
+      <Sha>1d451c32dda2314c721adbf8829e1c0cd4e681ff</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23418.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23426.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
       <Uri>https://github.com/dotnet/xliff-tasks</Uri>
-      <Sha>bb654cd4736e7e8cb99f1c355ce2b8f0a686ba74</Sha>
+      <Sha>194f32828726c3f1f63f79f3dc09b9e99c157b11</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.8.0-preview.1.69">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.8.0-rc.122">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>e873b496daa6839a86f4b820d15945a9aad98e3d</Sha>
+      <Sha>0dd5a1ea536201af94725353e4bc711d7560b246</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.8.0-1.23419.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.8.0-3.23510.8">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>5fcefbef4fa8a28c2ac73c8c03ab37fca30e4570</Sha>
+      <Sha>d49b29ecbf9bd72fe6023ad1b8aad9a8db7e7c3a</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23419.1">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23463.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>385129cbc980a515ddee2fa56f6b16f3183ed9bc</Sha>
+      <Sha>1d451c32dda2314c721adbf8829e1c0cd4e681ff</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 186e24769b9..06bb7b294ce 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.8.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.7.0</PackageValidationBaselineVersion>
+    <VersionPrefix>17.9.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.8.0-preview-23471-08</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -38,7 +38,6 @@
     <SystemReflectionMetadataLoadContextVersion>7.0.0</SystemReflectionMetadataLoadContextVersion>
     <SystemReflectionMetadataVersion>7.0.0</SystemReflectionMetadataVersion>
     <SystemResourcesExtensionsPackageVersion>7.0.0</SystemResourcesExtensionsPackageVersion>
-    <SystemSecurityPermissionsVersion>7.0.0</SystemSecurityPermissionsVersion>
     <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
     <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
   </PropertyGroup>
@@ -48,11 +47,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23419.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23463.1</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.8.0-1.23419.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.8.0-preview.1.69</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.8.0-3.23510.8</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.8.0-rc.122</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.3</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/eng/common/cross/toolchain.cmake b/eng/common/cross/toolchain.cmake
index a88d643c8a7..0998e875e5f 100644
--- a/eng/common/cross/toolchain.cmake
+++ b/eng/common/cross/toolchain.cmake
@@ -207,6 +207,7 @@ elseif(ILLUMOS)
     set(CMAKE_CXX_STANDARD_LIBRARIES "${CMAKE_CXX_STANDARD_LIBRARIES} -lssp")
 elseif(HAIKU)
     set(CMAKE_SYSROOT "${CROSS_ROOTFS}")
+    set(CMAKE_PROGRAM_PATH "${CMAKE_PROGRAM_PATH};${CROSS_ROOTFS}/cross-tools-x86_64/bin")
 
     set(TOOLSET_PREFIX ${TOOLCHAIN}-)
     function(locate_toolchain_exec exec var)
@@ -217,7 +218,6 @@ elseif(HAIKU)
         endif()
 
         find_program(EXEC_LOCATION_${exec}
-            PATHS "${CROSS_ROOTFS}/cross-tools-x86_64/bin"
             NAMES
             "${TOOLSET_PREFIX}${exec}${CLR_CMAKE_COMPILER_FILE_NAME_VERSION}"
             "${TOOLSET_PREFIX}${exec}")
diff --git a/eng/common/loc/P22DotNetHtmlLocalization.lss b/eng/common/loc/P22DotNetHtmlLocalization.lss
index 858a0b237c6..5d892d61939 100644
Binary files a/eng/common/loc/P22DotNetHtmlLocalization.lss and b/eng/common/loc/P22DotNetHtmlLocalization.lss differ
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 4a6756eff0a..3f87fa86718 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -19,13 +19,16 @@
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
+    <PackageVersion Include="Microsoft.BuildXL.Processes" Version="0.1.0-20230929.2" />
+    <PackageVersion Update="Microsoft.BuildXL.Processes" Condition="'$(BuildXLProcessesVersion)' != ''" Version="$(BuildXLProcessesVersion)" />
+
     <PackageVersion Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
     <PackageVersion Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" PrivateAssets="All" />
 
     <PackageVersion Include="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageVersion Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
 
-    <PackageVersion Include="Newtonsoft.Json" Version="13.0.2" />
+    <PackageVersion Include="Newtonsoft.Json" Version="13.0.3" />
     <PackageVersion Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
 
     <PackageVersion Include="PdbGit" Version="3.0.41" />
diff --git a/eng/policheck_exclusions.xml b/eng/policheck_exclusions.xml
new file mode 100644
index 00000000000..841de0e4f01
--- /dev/null
+++ b/eng/policheck_exclusions.xml
@@ -0,0 +1,17 @@
+<PoliCheckExclusions>
+  <!-- All strings must be UPPER CASE -->
+  <!--Each of these exclusions is a folder name -if \[name]\exists in the file path, it will be skipped -->
+  <!--<Exclusion Type="FolderPathFull">ABC|XYZ</Exclusion>-->
+  <!--Each of these exclusions is a folder name -if any folder or file starts with "\[name]", it will be skipped -->
+  <!--<Exclusion Type="FolderPathStart">ABC|XYZ</Exclusion>-->
+  <!--Each of these file types will be completely skipped for the entire scan -->
+  <!--<Exclusion Type="FileType">.ABC|.XYZ</Exclusion>-->
+  <!--The specified file names will be skipped during the scan regardless which folder they are in -->
+  <!--<Exclusion Type="FileName">ABC.TXT|XYZ.CS</Exclusion>-->
+
+  <Exclusion Type="FolderPathFull">.DOTNET</Exclusion>
+  <!-- This file contains entity names that were written out by the XML writer in the VS.NET 2002/2003 project system. Leave them unchanged and skip the file -->
+  <Exclusion Type="FileName">OLDVSPROJECTFILEREADER.CS</Exclusion>
+  <!-- Since only support the locale en-us in our repo, skip the translated files currently. https://devdiv.visualstudio.com/DevDiv/_workitems/edit/1889125  -->
+  <Exclusion Type="FileType">.XLF</Exclusion>
+</PoliCheckExclusions>
diff --git a/global.json b/global.json
index 07f9e33e302..fc9267598cd 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "8.0.100-preview.7.23376.3",
+    "dotnet": "8.0.100-rc.1.23463.5",
     "vs": {
-      "version": "17.6.0"
+      "version": "17.7.0"
     },
-    "xcopy-msbuild": "17.6.0-2"
+    "xcopy-msbuild": "17.7.4"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23419.1"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23463.1"
   }
 }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index 37b65ce9199..95e2726de9f 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -5,7 +5,9 @@ Param(
   [ValidateSet('Debug','Release')]
   [string] $configuration = "Debug",
   [ValidateSet('Core','Desktop', 'Detect', 'Full')]
-  [string] $runtime = "Detect"
+  [string] $runtime = "Detect",
+  [string] $binDirectory = "",
+  [bool] $makeBackup = $true
 )
 
 Set-StrictMode -Version "Latest"
@@ -15,9 +17,9 @@ function Copy-WithBackup ($origin, $destinationSubFolder = "") {
     $directoryPart = [IO.Path]::Combine($destination, $destinationSubFolder, $origin.IntermediaryDirectories)
     $destinationPath = Join-Path -Path $directoryPart (Split-Path $origin.SourceFile -leaf)
 
-    $backupInto = [IO.Path]::Combine($BackupFolder, $destinationSubFolder)
+    if (($makeBackup) -and (Test-Path $destinationPath -PathType Leaf)) {
+        $backupInto = [IO.Path]::Combine($BackupFolder, $destinationSubFolder)
 
-    if (Test-Path $destinationPath -PathType Leaf) {
         # Back up previous copy of the file
         if (!(Test-Path $backupInto)) {
             [system.io.directory]::CreateDirectory($backupInto)
@@ -45,10 +47,15 @@ function FileToCopy([string] $sourceFileRelativeToRepoRoot, [string] $intermedia
 
 # TODO: find most-recently-built MSBuild and make it default $configuration
 
-$BackupFolder = New-Item (Join-Path $destination -ChildPath "Backup-$(Get-Date -Format FileDateTime)") -itemType directory -ErrorAction Stop
-
 Write-Verbose "Copying $configuration MSBuild to $destination"
-Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
+
+if ($makeBackup) {
+    $BackupFolder = New-Item (Join-Path $destination -ChildPath "Backup-$(Get-Date -Format FileDateTime)") -itemType directory -ErrorAction Stop
+    Write-Host "Existing MSBuild assemblies backed up to $BackupFolder"
+}
+else {
+    Write-Host "Existing MSBuild assemblies won't be backed up"
+}
 
 if ($runtime -eq "Detect") {
     if ($destination -like "*dotnet*sdk*") {
@@ -72,7 +79,12 @@ if ($runtime -eq "Desktop") {
     $targetFramework = "net8.0"
 }
 
-$bootstrapBinDirectory = "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework"
+# If bootstrap directory is not defined in parameters, use the default location
+if ($binDirectory -eq "") {
+    $binDirectory = "artifacts\bin" 
+}
+
+$bootstrapBinDirectory = "$binDirectory\MSBuild.Bootstrap\$configuration\$targetFramework"
 
 $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.dll"
@@ -104,8 +116,8 @@ $filesToCopyToBin = @(
 
 if ($runtime -eq "Desktop") {
     $runtimeSpecificFiles = @(
-        FileToCopy "artifacts\bin\Microsoft.Build.Conversion\$configuration\$targetFramework\Microsoft.Build.Conversion.Core.dll"
-        FileToCopy "artifacts\bin\Microsoft.Build.Engine\$configuration\$targetFramework\Microsoft.Build.Engine.dll"
+        FileToCopy "$binDirectory\Microsoft.Build.Conversion\$configuration\$targetFramework\Microsoft.Build.Conversion.Core.dll"
+        FileToCopy "$binDirectory\Microsoft.Build.Engine\$configuration\$targetFramework\Microsoft.Build.Engine.dll"
 
         FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.Data.Entity.targets"
@@ -140,14 +152,14 @@ if ($runtime -eq "Desktop") {
     $x86files = @(
         FileToCopy "$bootstrapBinDirectory\MSBuild.exe"
         FileToCopy "$bootstrapBinDirectory\MSBuild.exe.config"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.exe"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.pdb"
+        FileToCopy "$binDirectory\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.exe"
+        FileToCopy "$binDirectory\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.pdb"
     )
     $amd64files = @(
-        FileToCopy "artifacts\bin\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe"
-        FileToCopy "artifacts\bin\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe.config"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.exe"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.pdb"
+        FileToCopy "$binDirectory\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe"
+        FileToCopy "$binDirectory\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe.config"
+        FileToCopy "$binDirectory\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.exe"
+        FileToCopy "$binDirectory\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.pdb"
     )
 }
 
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index da4e8adc444..3c17cb2aea3 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -57,7 +57,7 @@ public class ProjectItem_Tests : IDisposable
                 ";
 
         protected readonly TestEnvironment _env;
-        private DummyMappedDrive _mappedDrive = null;
+        private Lazy<DummyMappedDrive> _mappedDrive = DummyMappedDriveUtils.GetLazyDummyMappedDrive();
 
         public ProjectItem_Tests()
         {
@@ -67,7 +67,7 @@ public ProjectItem_Tests()
         public void Dispose()
         {
             _env.Dispose();
-            _mappedDrive?.Dispose();
+            _mappedDrive.Value?.Dispose();
         }
 
         /// <summary>
@@ -804,8 +804,7 @@ public void ProjectGetterResultsInDriveEnumerationException(string unevaluatedIn
         [InlineData(@"%DRIVE%:\**\*.cs")]
         public void ProjectGetterResultsInWindowsDriveEnumerationWarning(string unevaluatedInclude)
         {
-            var mappedDrive = GetDummyMappedDrive();
-            unevaluatedInclude = UpdatePathToMappedDrive(unevaluatedInclude, mappedDrive.MappedDriveLetter);
+            unevaluatedInclude = DummyMappedDriveUtils.UpdatePathToMappedDrive(unevaluatedInclude, _mappedDrive.Value.MappedDriveLetter);
             ProjectGetterResultsInDriveEnumerationWarning(unevaluatedInclude);
         }
 
@@ -898,35 +897,12 @@ public void ThrowExceptionUponProjectInstanceCreationFromDriveEnumeratingContent
             @"%DRIVE%:\$(Microsoft_WindowsAzure_EngSys)**")]
         public void LogWindowsWarningUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
         {
-            var mappedDrive = GetDummyMappedDrive();
-            placeHolder = UpdatePathToMappedDrive(placeHolder, mappedDrive.MappedDriveLetter);
-            excludePlaceHolder = UpdatePathToMappedDrive(excludePlaceHolder, mappedDrive.MappedDriveLetter);
+            placeHolder = DummyMappedDriveUtils.UpdatePathToMappedDrive(placeHolder, _mappedDrive.Value.MappedDriveLetter);
+            excludePlaceHolder = DummyMappedDriveUtils.UpdatePathToMappedDrive(excludePlaceHolder, _mappedDrive.Value.MappedDriveLetter);
             content = string.Format(content, placeHolder, excludePlaceHolder);
             CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
         }
 
-        private DummyMappedDrive GetDummyMappedDrive()
-        {
-            if (NativeMethods.IsWindows)
-            {
-                // let's create the mapped drive only once it's needed by any test, then let's reuse;
-                _mappedDrive ??= new DummyMappedDrive();
-            }
-
-            return _mappedDrive;
-        }
-
-        private static string UpdatePathToMappedDrive(string path, char driveLetter)
-        {
-            const string drivePlaceholder = "%DRIVE%";
-            // if this seems to be rooted path - replace with the dummy mount
-            if (!string.IsNullOrEmpty(path) && path.StartsWith(drivePlaceholder))
-            {
-                path = driveLetter + path.Substring(drivePlaceholder.Length);
-            }
-            return path;
-        }
-
         [UnixOnlyTheory]
         [ActiveIssue("https://github.com/dotnet/msbuild/issues/8373")]
         [InlineData(
@@ -968,7 +944,7 @@ private static void CreateProjectInstanceFromFileWithDriveEnumeratingWildcard(Te
         {
             try
             {
-                // Reset state 
+                // Reset state
                 Helpers.ResetStateForDriveEnumeratingWildcardTests(env, throwException ? "1" : "0");
 
                 if (throwException)
@@ -3782,10 +3758,10 @@ public void FileNameMetadataEvaluationShouldNotDependsFromPlatformSpecificSlashe
 
     public class ProjectItemWithOptimizations_Tests : ProjectItem_Tests
     {
-        public ProjectItemWithOptimizations_Tests()
-        {
-            // Make sure we always use the dictionary-based Remove logic.
-            _env.SetEnvironmentVariable("MSBUILDDICTIONARYBASEDITEMREMOVETHRESHOLD", "0");
-        }
+       public ProjectItemWithOptimizations_Tests()
+       {
+           // Make sure we always use the dictionary-based Remove logic.
+           _env.SetEnvironmentVariable("MSBUILDDICTIONARYBASEDITEMREMOVETHRESHOLD", "0");
+       }
     }
 }
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index fbdf4b3742f..44a917968a2 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.NetCore.Extensions;
@@ -24,12 +25,19 @@ namespace Microsoft.Build.UnitTests.OM.Instance
     /// <summary>
     /// Tests for ProjectItemInstance public members
     /// </summary>
-    public class ProjectItemInstance_Tests
+    public class ProjectItemInstance_Tests : IDisposable
     {
         /// <summary>
         /// The number of built-in metadata for items.
         /// </summary>
         public const int BuiltInMetadataCount = 15;
+        private Lazy<DummyMappedDrive> _mappedDrive = DummyMappedDriveUtils.GetLazyDummyMappedDrive();
+
+
+        public void Dispose()
+        {
+            _mappedDrive.Value?.Dispose();
+        }
 
         internal const string TargetItemWithInclude = @"
             <Project>
@@ -999,33 +1007,30 @@ public void ThrowExceptionUponBuildingProjectWithDriveEnumeration(string content
         /// <summary>
         /// Log warning for drive enumerating wildcards that exist in projects on Windows platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
         [WindowsOnlyTheory]
         [InlineData(
             TargetItemWithIncludeAndExclude,
-            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"%DRIVE%:$(Microsoft_WindowsAzure_EngSys)\**\*",
             @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
 
-        [InlineData(
-            TargetItemWithIncludeAndExclude,
-            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb",
-            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*")]
-
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)**",
             null,
             "Microsoft_WindowsAzure_EngSys",
-            @"z:\")]
+            @"%DRIVE%:\")]
 
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
             @"$(Microsoft_WindowsAzure_EngSys)\**\*",
             null,
             "Microsoft_WindowsAzure_EngSys",
-            @"z:")]
+            @"%DRIVE%:")]
         public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
         {
+            include = DummyMappedDriveUtils.UpdatePathToMappedDrive(include, _mappedDrive.Value.MappedDriveLetter);
+            exclude = DummyMappedDriveUtils.UpdatePathToMappedDrive(exclude, _mappedDrive.Value.MappedDriveLetter);
+            propertyValue = DummyMappedDriveUtils.UpdatePathToMappedDrive(propertyValue, _mappedDrive.Value.MappedDriveLetter);
             content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
                 string.Format(content, include, exclude) :
                 string.Format(content, property, propertyValue, include);
@@ -1040,7 +1045,7 @@ public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string cont
         /// <summary>
         /// Log warning for drive enumerating wildcards that exist in projects on Unix platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/8373")]
         [UnixOnlyTheory]
         [InlineData(
             TargetWithDefinedPropertyAndItemWithInclude,
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 57cba86c10c..d2515288da0 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -36,21 +36,11 @@
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>EncodingStringWriter.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\MockLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ErrorUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\FileDelegates.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ResourceUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs" />
+    <Compile Include="..\Shared\UnitTests\MockLogger.cs" />
+    <Compile Include="..\Shared\ErrorUtilities.cs" />
+    <Compile Include="..\Shared\FileDelegates.cs" />
+    <Compile Include="..\Shared\ResourceUtilities.cs" />
     <Compile Include="..\Shared\UnitTests\EngineTestEnvironment.cs">
       <Link>EngineTestEnvironment.cs</Link>
     </Compile>
@@ -61,18 +51,10 @@
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs" />
-    <Compile Include="..\Shared\FileUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\EscapingUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\FileUtilitiesRegex.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ExceptionHandling.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\FileUtilities.cs" />
+    <Compile Include="..\Shared\EscapingUtilities.cs" />
+    <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
+    <Compile Include="..\Shared\ExceptionHandling.cs" />
     <Compile Include="..\Shared\UnitTests\TestData\GlobbingTestData.cs">
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
@@ -81,6 +63,7 @@
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
     <Compile Include="..\UnitTests.Shared\DriveMapping.cs" />
     <Compile Include="..\UnitTests.Shared\DummyMappedDrive.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDriveUtils.cs"/>
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
       <SubType>Designer</SubType>
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
index f454dc1161d..14e2a4cfd41 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -155,9 +155,15 @@ private void TestCustomEventWarning<T>(string envVariableValue, bool isWarningEx
         /// </summary>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index e340aaacdc6..7b1a91dfd04 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -93,9 +93,15 @@ public BuildManager_Tests(ITestOutputHelper output)
         /// </summary>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
 
         /// <summary>
@@ -4108,8 +4114,8 @@ handoff logging completion to the BuildManager.
                     submission1.ExecuteAsync(null, null);
                     submission2.ExecuteAsync(null, null);
 
-                    submission1.WaitHandle.WaitOne(TimeSpan.FromSeconds(10));
-                    submission2.WaitHandle.WaitOne(TimeSpan.FromSeconds(10));
+                    submission1.WaitHandle.WaitOne(TimeSpan.FromSeconds(20));
+                    submission2.WaitHandle.WaitOne(TimeSpan.FromSeconds(20));
 
                     submission1.IsCompleted.ShouldBeTrue();
                     submission2.IsCompleted.ShouldBeTrue();
diff --git a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
new file mode 100644
index 00000000000..dc1d7e8f4b9
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
@@ -0,0 +1,59 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Logging;
+using Microsoft.Build.UnitTests.BackEnd;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Engine.UnitTests.BackEnd
+{
+    public class NodeConfiguration_Tests
+    {
+#if FEATURE_APPDOMAIN
+        /// <summary>
+        /// Test serialization / deserialization of the AppDomainSetup instance. 
+        /// </summary>
+        [Theory]
+        [InlineData(new byte[] { 1, 2, 3 })]
+        [InlineData(null)]
+        public void TestTranslationWithAppDomainSetup(byte[] configBytes)
+        {
+            AppDomainSetup setup = new AppDomainSetup();
+
+            NodeConfiguration config = new NodeConfiguration(
+                nodeId: 1,
+                buildParameters: new BuildParameters(),
+                forwardingLoggers: Array.Empty<LoggerDescription>(),
+                appDomainSetup: setup,
+                loggingNodeConfiguration: new LoggingNodeConfiguration());
+
+            setup.SetConfigurationBytes(configBytes);
+
+            ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
+            INodePacket packet = NodeConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            packet.ShouldBeOfType<NodeConfiguration>();
+            NodeConfiguration deserializedConfig = (NodeConfiguration)packet;
+
+            deserializedConfig.AppDomainSetup.ShouldNotBeNull();
+
+            if (configBytes is null)
+            {
+                deserializedConfig.AppDomainSetup.GetConfigurationBytes().ShouldBeNull();
+            }
+            else
+            {
+                deserializedConfig.AppDomainSetup.GetConfigurationBytes().SequenceEqual(configBytes).ShouldBeTrue();
+            }
+        }
+#endif
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
index 322c61aa579..83d4ae0cf0a 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultOutOfProc_Tests.cs
@@ -77,9 +77,15 @@ public SdkResultOutOfProc_Tests(ITestOutputHelper output)
 
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _projectCollection.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+                _projectCollection.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
             EvaluationContext.TestOnlyHookOnCreate = null;
         }
 
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 1e6b56edd0e..2c662f12a92 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -144,14 +144,24 @@ public void CanceledTasksDoNotLogMSB4181()
                 BuildManager manager = new BuildManager();
                 ProjectCollection collection = new ProjectCollection();
 
+                string sleepCommand = Helpers.GetSleepCommand(TimeSpan.FromSeconds(10));
                 string contents = @"
                     <Project ToolsVersion ='Current'>
                      <Target Name='test'>
-                        <Exec Command='" + Helpers.GetSleepCommand(TimeSpan.FromSeconds(10)) + @"'/>
+                        <Exec Command='" + sleepCommand + @"'/>
                      </Target>
                     </Project>";
 
                 MockLogger logger = new MockLogger(_testOutput);
+                ManualResetEvent waitCommandExecuted = new ManualResetEvent(false);
+                string unescapedSleepCommand = sleepCommand.Replace("&quot;", "\"").Replace("&gt;", ">");
+                logger.AdditionalHandlers.Add((sender, args) =>
+                {
+                    if (unescapedSleepCommand.Equals(args.Message))
+                    {
+                        waitCommandExecuted.Set();
+                    }
+                });
 
                 var project = new Project(XmlReader.Create(new StringReader(contents)), null, MSBuildConstants.CurrentToolsVersion, collection)
                 {
@@ -169,11 +179,14 @@ public void CanceledTasksDoNotLogMSB4181()
                 manager.BeginBuild(_parameters);
                 BuildSubmission asyncResult = manager.PendBuildRequest(data);
                 asyncResult.ExecuteAsync(null, null);
-                Thread.Sleep(500);
+                int timeoutMilliseconds = 2000;
+                bool isCommandExecuted = waitCommandExecuted.WaitOne(timeoutMilliseconds);
                 manager.CancelAllSubmissions();
-                asyncResult.WaitHandle.WaitOne();
+                bool isSubmissionComplated = asyncResult.WaitHandle.WaitOne(timeoutMilliseconds);
                 BuildResult result = asyncResult.BuildResult;
                 manager.EndBuild();
+                isCommandExecuted.ShouldBeTrue($"Waiting for that the sleep command is executed failed in the timeout period {timeoutMilliseconds} ms.");
+                isSubmissionComplated.ShouldBeTrue($"Waiting for that the build submission is completed failed in the timeout period {timeoutMilliseconds} ms.");
 
                 // No errors from cancelling a build.
                 logger.ErrorCount.ShouldBe(0);
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index 0d4a6fc7cba..5ee9b497a9b 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Text;
 using System.Threading;
 
 
@@ -376,6 +377,57 @@ public void TestTranslationWithNullDictionary()
             Assert.Equal(expectedGlobalProperties, deserializedConfig.GlobalProperties);
         }
 
+#if FEATURE_APPDOMAIN
+        /// <summary>
+        /// Test serialization / deserialization of the AppDomainSetup instance. 
+        /// </summary>
+        [Theory]
+        [InlineData(new byte[] { 1, 2, 3 })]
+        [InlineData(null)]
+        public void TestTranslationWithAppDomainSetup(byte[] configBytes)
+        {
+            AppDomainSetup setup = new AppDomainSetup();
+
+            TaskHostConfiguration config = new TaskHostConfiguration(
+                nodeId: 1,
+                startupDirectory: Directory.GetCurrentDirectory(),
+                buildProcessEnvironment: null,
+                culture: Thread.CurrentThread.CurrentCulture,
+                uiCulture: Thread.CurrentThread.CurrentUICulture,
+                appDomainSetup: setup,
+                lineNumberOfTask: 1,
+                columnNumberOfTask: 1,
+                projectFileOfTask: @"c:\my project\myproj.proj",
+                continueOnError: _continueOnErrorDefault,
+                taskName: "TaskName",
+                taskLocation: @"c:\MyTasks\MyTask.dll",
+                isTaskInputLoggingEnabled: false,
+                taskParameters: new Dictionary<string, object>(),
+                globalParameters: new Dictionary<string, string>(),
+                warningsAsErrors: null,
+                warningsNotAsErrors: null,
+                warningsAsMessages: null);
+
+            setup.SetConfigurationBytes(configBytes);
+
+            ((ITranslatable)config).Translate(TranslationHelpers.GetWriteTranslator());
+            INodePacket packet = TaskHostConfiguration.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
+
+            TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
+
+            deserializedConfig.AppDomainSetup.ShouldNotBeNull();
+
+            if (configBytes is null)
+            {
+                deserializedConfig.AppDomainSetup.GetConfigurationBytes().ShouldBeNull();
+            }
+            else
+            {
+                deserializedConfig.AppDomainSetup.GetConfigurationBytes().SequenceEqual(configBytes).ShouldBeTrue();
+            }
+        }
+#endif
+
         /// <summary>
         /// Test serialization / deserialization when the parameter dictionary is empty. 
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
index 5c6bf006b2c..7504cd8bb3d 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Xunit;
@@ -25,21 +26,67 @@ public class TaskHostTaskComplete_Tests
         [Fact]
         public void TestConstructors()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success), null);
-            TaskHostTaskComplete complete2 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure), null);
-            TaskHostTaskComplete complete3 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringInitialization, new ArgumentOutOfRangeException()), null);
-            TaskHostTaskComplete complete4 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringExecution, new ArgumentNullException()), null);
+#if FEATURE_REPORTFILEACCESSES
+            var fileAccessData = new List<FileAccessData>()
+            {
+                new FileAccessData(
+                    ReportedFileOperation.CreateFile,
+                    RequestedAccess.Read,
+                    0,
+                    0,
+                    DesiredAccess.GENERIC_READ,
+                    FlagsAndAttributes.FILE_ATTRIBUTE_NORMAL,
+                    "foo",
+                    null,
+                    true),
+            };
+#endif
+
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Failure),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringInitialization,
+                new ArgumentOutOfRangeException()),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedDuringExecution, new ArgumentNullException()),
+#if FEATURE_REPORTFILEACCESSES
+                fileAccessData,
+#endif
+                null);
 
             IDictionary<string, object> parameters = new Dictionary<string, object>();
-            TaskHostTaskComplete complete5 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             IDictionary<string, object> parameters2 = new Dictionary<string, object>();
             parameters2.Add("Text", "Hello!");
             parameters2.Add("MyBoolValue", true);
             parameters2.Add("MyITaskItem", new TaskItem("ABC"));
             parameters2.Add("ItemArray", new ITaskItem[] { new TaskItem("DEF"), new TaskItem("GHI"), new TaskItem("JKL") });
-
-            TaskHostTaskComplete complete6 = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters2), null);
+            _ = new TaskHostTaskComplete(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters2),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
         }
 
         /// <summary>
@@ -60,7 +107,12 @@ public void TestInvalidConstructors()
         [Fact]
         public void TestTranslationWithNullDictionary()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -78,7 +130,12 @@ public void TestTranslationWithNullDictionary()
         [Fact]
         public void TestTranslationWithEmptyDictionary()
         {
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, new Dictionary<string, object>()), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, new Dictionary<string, object>()),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -99,7 +156,12 @@ public void TestTranslationWithValueTypesInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("Text", "Foo");
             parameters.Add("BoolValue", false);
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -121,7 +183,12 @@ public void TestTranslationWithITaskItemInDictionary()
         {
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemValue", new TaskItem("Foo"));
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -142,7 +209,12 @@ public void TestTranslationWithITaskItemArrayInDictionary()
         {
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemArrayValue", new ITaskItem[] { new TaskItem("Foo"), new TaskItem("Baz") });
-            TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters), null);
+            TaskHostTaskComplete complete = new(
+                new OutOfProcTaskHostTaskResult(TaskCompleteType.Success, parameters),
+#if FEATURE_REPORTFILEACCESSES
+                null,
+#endif
+                null);
 
             ((ITranslatable)complete).Translate(TranslationHelpers.GetWriteTranslator());
             INodePacket packet = TaskHostTaskComplete.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
@@ -168,7 +240,12 @@ private void AssertInvalidConstructorThrows(Type expectedExceptionType, TaskComp
 
             try
             {
-                TaskHostTaskComplete complete = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(taskResult, taskOutputParameters, taskException, taskExceptionMessage, taskExceptionMessageArgs), buildProcessEnvironment);
+                TaskHostTaskComplete complete = new(
+                    new OutOfProcTaskHostTaskResult(taskResult, taskOutputParameters, taskException, taskExceptionMessage, taskExceptionMessageArgs),
+#if FEATURE_REPORTFILEACCESSES
+                    null,
+#endif
+                    buildProcessEnvironment);
             }
             catch (Exception e)
             {
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 57e2bc3fa82..5d0753df46e 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -188,8 +188,13 @@ public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
             }
         }
 
-        [Fact]
-        public void AssemblyLoadsDuringTaskRunLogged()
+        [WindowsFullFrameworkOnlyFact(additionalMessage: "Tests if the AppDomain used to load the task is included in the log text for the event, which is true only on Framework.")]
+        public void AssemblyLoadsDuringTaskRunLoggedWithAppDomain() => AssemblyLoadsDuringTaskRun("AppDomain: [Default]");
+
+        [DotNetOnlyFact(additionalMessage: "Tests if the AssemblyLoadContext used to load the task is included in the log text for the event, which is true only on Core.")]
+        public void AssemblyLoadsDuringTaskRunLoggedWithAssemblyLoadContext() => AssemblyLoadsDuringTaskRun("AssemblyLoadContext: Default");
+
+        private void AssemblyLoadsDuringTaskRun(string additionalEventText)
         {
             using (TestEnvironment env = TestEnvironment.Create())
             {
@@ -201,7 +206,7 @@ public void AssemblyLoadsDuringTaskRunLogged()
                         TaskFactory="RoslynCodeTaskFactory"
                         AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
                         <ParameterGroup />
-                        <Task> 
+                        <Task>
                           <Using Namespace="System"/>
                           <Using Namespace="System.IO"/>
                           <Using Namespace="System.Reflection"/>
@@ -235,17 +240,20 @@ public void AssemblyLoadsDuringTaskRunLogged()
                     "Assembly loaded during TaskRun (InlineCode.HelloWorld): System.Diagnostics.Debug";
                 string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
                 text.ShouldContain(assemblyLoadedEventText);
+                text.ShouldContain(additionalEventText);
                 // events should not be in logger with verbosity normal
                 string text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile2.log"));
                 text2.ShouldNotContain(assemblyLoadedEventText);
-
+                text2.ShouldNotContain(additionalEventText);
                 RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp1:logfile={Path.Combine(logFolder.Path, "logFile3.log")};verbosity=diagnostic -flp2:logfile={Path.Combine(logFolder.Path, "logFile4.log")};verbosity=normal", out success);
                 success.ShouldBeTrue();
                 text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile3.log"));
                 text.ShouldContain(assemblyLoadedEventText);
+                text.ShouldContain(additionalEventText);
                 // events should not be in logger with verbosity normal
                 text2 = File.ReadAllText(Path.Combine(logFolder.Path, "logFile4.log"));
                 text2.ShouldNotContain(assemblyLoadedEventText);
+                text2.ShouldNotContain(additionalEventText);
             }
         }
 
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 9963b2338b5..6e385896a9c 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -263,10 +263,11 @@ public void RoundtripBuildErrorEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
+        public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool withOptionalData)
         {
             var args = new ExtendedBuildErrorEventArgs(
                 "extendedDataType",
@@ -281,10 +282,14 @@ public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
                 "Help",
                 "SenderName",
                 DateTime.Parse("9/1/2021 12:02:07 PM"),
-                useArguments ? new object[] { "argument0" } : null);
+                withOptionalData ? new object[] { "argument0" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
 
-            // For now we don't serialize extended data into binary log
-            Roundtrip<BuildErrorEventArgs>(args,
+            Roundtrip(args,
                 e => e.Code,
                 e => e.ColumnNumber.ToString(),
                 e => e.EndColumnNumber.ToString(),
@@ -294,6 +299,9 @@ public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
                 e => e.Message,
                 e => e.ProjectFile,
                 e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
@@ -332,7 +340,7 @@ public void RoundtripBuildWarningEventArgs(bool useArguments)
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArguments)
+        public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool withOptionalData)
         {
             var args = new ExtendedBuildWarningEventArgs(
                 "extendedDataType",
@@ -347,10 +355,14 @@ public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArgume
                 "Help",
                 "SenderName",
                 DateTime.Parse("9/1/2021 12:02:07 PM"),
-                useArguments ? new object[] { "argument0" } : null);
+                withOptionalData ? new object[] { "argument0" } : null)
+                {
+                    ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                    ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                    BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+                };
 
-            // For now we don't serialize extended data into binary log
-            Roundtrip<BuildWarningEventArgs>(args,
+            Roundtrip(args,
                 e => e.Code,
                 e => e.ColumnNumber.ToString(),
                 e => e.EndColumnNumber.ToString(),
@@ -360,6 +372,9 @@ public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArgume
                 e => e.Message,
                 e => e.ProjectFile,
                 e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
@@ -400,7 +415,7 @@ public void RoundtripBuildMessageEventArgs(bool useArguments)
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
-        public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useArguments)
+        public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool withOptionalData)
         {
             var args = new ExtendedBuildMessageEventArgs(
                 "extendedDataType",
@@ -416,9 +431,14 @@ public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useA
                 "SenderName",
                 MessageImportance.High,
                 DateTime.Parse("12/12/2015 06:11:56 PM"),
-                useArguments ? new object[] { "argument0" } : null);
+                withOptionalData ? new object[] { "argument0" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
 
-            Roundtrip<BuildMessageEventArgs>(args,
+            Roundtrip(args,
                 e => e.Code,
                 e => e.ColumnNumber.ToString(),
                 e => e.EndColumnNumber.ToString(),
@@ -429,6 +449,9 @@ public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useA
                 e => e.Importance.ToString(),
                 e => e.ProjectFile,
                 e => e.Subcategory,
+                e => e.ExtendedType,
+                e => TranslationHelpers.ToString(e.ExtendedMetadata),
+                e => e.ExtendedData,
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
@@ -493,19 +516,21 @@ public void ExtendedCustomBuildEventArgs_SerializedAsMessage(bool withOptionalDa
 
             using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
             var deserialized = buildEventArgsReader.Read();
-            BuildMessageEventArgs desArgs = (BuildMessageEventArgs)deserialized;
-
-            desArgs.ShouldBeOfType(typeof(BuildMessageEventArgs));
+            ExtendedBuildMessageEventArgs desArgs = (ExtendedBuildMessageEventArgs)deserialized;
 
+            desArgs.ShouldBeOfType(typeof(ExtendedBuildMessageEventArgs));
             desArgs.Message.ShouldBe(args.Message);
             desArgs.HelpKeyword.ShouldBe(args.HelpKeyword);
             desArgs.SenderName.ShouldBe(args.SenderName);
             desArgs.Importance.ShouldBe(MessageImportance.Normal);
             desArgs.Timestamp.ShouldBe(args.Timestamp);
+            desArgs.ExtendedType.ShouldBe(args.ExtendedType);
 
             if (withOptionalData)
             {
                 desArgs.BuildEventContext.ShouldBe(args.BuildEventContext);
+                desArgs.ExtendedData.ShouldBe(args.ExtendedData);
+                TranslationHelpers.ToString(desArgs.ExtendedMetadata).ShouldBe(TranslationHelpers.ToString(args.ExtendedMetadata));
             }
             else
             {
diff --git a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
index 4d4e33ff79d..e21015b4c68 100644
--- a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Xunit;
+using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -842,6 +843,43 @@ public void FallbackImportWithFileNotFoundWhenPropertyNotDefined()
                 FileUtilities.DeleteDirectoryNoThrow(extnDir1, true);
             }
         }
+        /// <summary>
+        /// Fall-back search path on a property that is not valid. https://github.com/dotnet/msbuild/issues/8762
+        /// </summary>
+        /// <param name="projectValue">imported project value expression</param>
+        [Theory]
+        [InlineData("")]
+        [InlineData("|")]
+        public void FallbackImportWithInvalidProjectValue(string projectValue)
+        {
+            string mainTargetsFileContent = $"""
+                <Project>
+                    <PropertyGroup>
+                    <VSToolsPath>{projectValue}</VSToolsPath>
+                </PropertyGroup>
+                <Import Project="$(VSToolsPath)"/>
+                </Project>
+                """;
+
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            string mainProjectPath = testEnvironment.CreateTestProjectWithFiles("main.proj", mainTargetsFileContent).ProjectFile;
+            var projectCollection = GetProjectCollection();
+            projectCollection.ResetToolsetsForTests(WriteConfigFileAndGetReader("VSToolsPath", "temp"));
+            var logger = new MockLogger();
+            projectCollection.RegisterLogger(logger);
+            Assert.Throws<InvalidProjectFileException>(() => projectCollection.LoadProject(mainProjectPath));
+
+            if (string.IsNullOrEmpty(projectValue))
+            {
+                logger.AssertLogContains("MSB4102");
+            }
+            else
+            {
+#if NETFRAMEWORK
+                logger.AssertLogContains("MSB4102");
+#endif
+            }
+        }
 
         private void CreateAndBuildProjectForImportFromExtensionsPath(string extnPathPropertyName, Action<Project, MockLogger> action)
         {
diff --git a/src/Build.UnitTests/EvaluationProfiler_Tests.cs b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
index 27438bec72e..078dc9e3520 100644
--- a/src/Build.UnitTests/EvaluationProfiler_Tests.cs
+++ b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
@@ -67,8 +67,14 @@ public EvaluationProfiler_Tests(ITestOutputHelper output)
         /// <nodoc/>
         public void Dispose()
         {
-            _buildManager.Dispose();
-            _env.Dispose();
+            try
+            {
+                _buildManager.Dispose();
+            }
+            finally
+            {
+                _env.Dispose();
+            }
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 92fc5c72239..dda2456a9f9 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -7,7 +7,7 @@
     <AssemblyName>Microsoft.Build.Engine.UnitTests</AssemblyName>
 
     <DefineConstants>$(DefineConstants);MICROSOFT_BUILD_ENGINE_UNITTESTS</DefineConstants>
-    
+
     <!-- Define a constant so we can skip tests that require MSBuildTaskHost -->
     <DefineConstants Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(MonoBuild)' == 'true'">$(DefineConstants);NO_MSBUILDTASKHOST</DefineConstants>
 
@@ -21,16 +21,14 @@
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
-    <PackageReference Include="NuGet.Frameworks" >
+    <PackageReference Include="NuGet.Frameworks">
       <PrivateAssets>all</PrivateAssets>
     </PackageReference>
 
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
-    <ProjectReference Include="..\MSBuildTaskHost\MSBuildTaskHost.csproj"
-                      Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' != 'true'"
-                      Aliases="MSBuildTaskHost" />
+    <ProjectReference Include="..\MSBuildTaskHost\MSBuildTaskHost.csproj" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(MonoBuild)' != 'true'" Aliases="MSBuildTaskHost" />
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
@@ -48,67 +46,38 @@
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=$(LatestDotNetCoreForMSBuild)</SetTargetFramework>
     </ProjectReference>
 
-    <Reference Include="System.IO.Compression"
-               Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' " />
+    <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' " />
   </ItemGroup>
 
   <ItemGroup>
-    <Compile Include="..\Shared\UnitTests\BuildEventArgsExtension.cs">
-      <!-- Extension methods -->
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\EscapingUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\ErrorUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\PrintLineDebugger_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\FileUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\FileMatcher_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\MockEngine.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\MockLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\ResourceUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\UnitTests\BuildEventArgsExtension.cs" />
+    <Compile Include="..\Shared\UnitTests\EscapingUtilities_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\ErrorUtilities_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\PrintLineDebugger_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\FileUtilities_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\FileMatcher_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\MockEngine.cs" />
+    <Compile Include="..\Shared\UnitTests\MockLogger.cs" />
+    <Compile Include="..\Shared\UnitTests\ResourceUtilities_Tests.cs" />
     <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
-    <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\StreamHelpers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
+    <Compile Include="..\UnitTests.Shared\DriveMapping.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDrive.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDriveUtils.cs" />
+    <Compile Include="..\Shared\UnitTests\StreamHelpers.cs" />
     <Compile Include="..\Shared\UnitTests\EngineTestEnvironment.cs">
       <Link>EngineTestEnvironment.cs</Link>
     </Compile>
     <Compile Include="..\Shared\UnitTests\TestEnvironment.cs">
       <Link>TestEnvironment.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\UnitTests\TypeLoader_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\UnitTests\TypeLoader_Dependencies_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\UnitTests\TypeLoader_Tests.cs" />
+    <Compile Include="..\Shared\UnitTests\TypeLoader_Dependencies_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\XmakeAttributes_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
       <Link>XmakeAttributes_Tests.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\UnitTests\XmlUtilities_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\UnitTests\XmlUtilities_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\AssemblyNameEx_Tests.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
       <Link>AssemblyNameEx_Tests.cs</Link>
     </Compile>
     <Compile Include="..\Shared\UnitTests\TaskParameter_Tests.cs">
@@ -144,14 +113,14 @@
     <!-- In TypeLoader, the following logic is used for loading assemblies on .NET Core:
             - if the simple name of the assembly exists in the same folder as msbuild.exe, then that assembly gets loaded, indifferent of the user specified path
             - otherwise, the assembly from the user specified path is loaded, if it exists.
-            
+
           So the custom tasks we are testing can't be in test output folder, because on .NET Core that would affect the loading behavior.  So this
-          target puts them in subfolders of the test output folder instead.    
+          target puts them in subfolders of the test output folder instead.
     -->
 
     <Error Condition="'@(PortableTaskResolvedProjectReferencePath)' == ''" Text="Couldn't find PortableTaskResolvedProjectReferencePath item for PortableTask" />
     <Error Condition="'@(TaskWithDependencyResolvedProjectReferencePath)' == ''" Text="Couldn't find TaskWithDependencyResolvedProjectReferencePath item for TaskWithDependency" />
-    
+
     <PropertyGroup>
       <PortableTaskOutputPath>@(PortableTaskResolvedProjectReferencePath->'%(RootDir)%(Directory)')</PortableTaskOutputPath>
       <TaskWithDependencyOutputPath>@(TaskWithDependencyResolvedProjectReferencePath->'%(RootDir)%(Directory)')</TaskWithDependencyOutputPath>
@@ -163,7 +132,7 @@
       <TaskWithDependencyContentContent Include="$(TaskWithDependencyOutputPath)*.*" />
       <Content Include="@(TaskWithDependencyContentContent)" Link="TaskWithDependency\%(TaskWithDependencyContentContent.Filename)%(TaskWithDependencyContentContent.Extension)" CopyToOutputDirectory="PreserveNewest" />
     </ItemGroup>
-    
+
   </Target>
 
   <ItemDefinitionGroup>
@@ -171,7 +140,7 @@
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
   </ItemDefinitionGroup>
-  
+
   <ItemGroup>
     <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
   </ItemGroup>
diff --git a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
index 40a33b6aacb..84e458f6a54 100644
--- a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
+++ b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
@@ -30,6 +30,10 @@ public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)
         _env = TestEnvironment.Create(output);
         _output = output;
 
+        // Ignore environment variables that may have been set by the environment where the tests are running.
+        _env.SetEnvironmentVariable("MSBUILDLIVELOGGER", null);
+        _env.SetEnvironmentVariable("MSBUILDTERMINALLOGGER", null);
+
         TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);
         TransientTestFile projectFile = _env.CreateFile(logFolder, "myProj.proj", $"""
             <Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Hello">
diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 40a6964c0e5..86a5a8073d2 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -32,3 +32,6 @@
 
 [assembly: ComVisible(false)]
 [assembly: CLSCompliant(true)]
+
+[assembly: Dependency("BuildXL.Utilities.Core", LoadHint.Sometimes)]
+[assembly: Dependency("BuildXL.Processes", LoadHint.Sometimes)]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 59a2c666da1..bc1e535abab 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -13,6 +13,7 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Runtime.CompilerServices;
 using System.Runtime.ExceptionServices;
 using System.Threading;
 using System.Threading.Tasks;
@@ -25,6 +26,7 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Graph;
@@ -116,7 +118,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// Set of active nodes in the system.
         /// </summary>
-        private readonly HashSet<NGen<int>> _activeNodes;
+        private readonly HashSet<int> _activeNodes;
 
         /// <summary>
         /// Event signalled when all nodes have shutdown.
@@ -126,7 +128,7 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// <summary>
         /// Mapping of nodes to the configurations they know about.
         /// </summary>
-        private readonly Dictionary<NGen<int>, HashSet<NGen<int>>> _nodeIdToKnownConfigurations;
+        private readonly Dictionary<int, HashSet<int>> _nodeIdToKnownConfigurations;
 
         /// <summary>
         /// Flag indicating if we are currently shutting down.  When set, we stop processing packets other than NodeShutdown.
@@ -299,9 +301,9 @@ public BuildManager(string hostName)
             _buildSubmissions = new Dictionary<int, BuildSubmission>();
             _graphBuildSubmissions = new Dictionary<int, GraphBuildSubmission>();
             _noActiveSubmissionsEvent = new AutoResetEvent(true);
-            _activeNodes = new HashSet<NGen<int>>();
+            _activeNodes = new HashSet<int>();
             _noNodesActiveEvent = new AutoResetEvent(true);
-            _nodeIdToKnownConfigurations = new Dictionary<NGen<int>, HashSet<NGen<int>>>();
+            _nodeIdToKnownConfigurations = new Dictionary<int, HashSet<int>>();
             _unnamedProjectInstanceToNames = new Dictionary<ProjectInstance, string>();
             _nextUnnamedProjectId = 1;
             _componentFactories = new BuildComponentFactoryCollection(this);
@@ -335,13 +337,13 @@ private enum BuildManagerState
             Idle,
 
             /// <summary>
-            /// This is the state the BuildManager is in after <see cref="BeginBuild(BuildParameters)"/> has been called but before <see cref="EndBuild"/> has been called.
-            /// <see cref="BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.PendBuildRequest(GraphBuildRequestData)"/>, <see cref="BuildManager.BuildRequest(GraphBuildRequestData)"/>, and <see cref="BuildManager.EndBuild"/> may be called in this state.
+            /// This is the state the BuildManager is in after <see cref="BeginBuild(BuildParameters)"/> has been called but before <see cref="EndBuild()"/> has been called.
+            /// <see cref="BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData)"/>, <see cref="BuildManager.PendBuildRequest(GraphBuildRequestData)"/>, <see cref="BuildManager.BuildRequest(GraphBuildRequestData)"/>, and <see cref="BuildManager.EndBuild()"/> may be called in this state.
             /// </summary>
             Building,
 
             /// <summary>
-            /// This is the state the BuildManager is in after <see cref="BuildManager.EndBuild"/> has been called but before all existing submissions have completed.
+            /// This is the state the BuildManager is in after <see cref="BuildManager.EndBuild()"/> has been called but before all existing submissions have completed.
             /// </summary>
             WaitingForBuildToComplete
         }
@@ -558,6 +560,13 @@ public void BeginBuild(BuildParameters parameters)
                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath("msbuild-cache");
                 }
 
+#if FEATURE_REPORTFILEACCESSES
+                if (_buildParameters.ReportFileAccesses)
+                {
+                    EnableDetouredNodeLauncher();
+                }
+#endif
+
                 // Initialize components.
                 _nodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.NodeManager) as INodeManager;
 
@@ -572,9 +581,17 @@ public void BeginBuild(BuildParameters parameters)
 
                 InitializeCaches();
 
+#if FEATURE_REPORTFILEACCESSES
+                var fileAccessManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager) as IFileAccessManager;
+#endif
+
                 _projectCacheService = new ProjectCacheService(
                     this,
                     loggingService,
+#if FEATURE_REPORTFILEACCESSES
+                    fileAccessManager,
+#endif
+                    _configCache,
                     _buildParameters.ProjectCacheDescriptor);
 
                 _taskHostNodeManager = ((IBuildComponentHost)this).GetComponent(BuildComponentType.TaskHostNodeManager) as INodeManager;
@@ -584,7 +601,9 @@ public void BeginBuild(BuildParameters parameters)
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfiguration, BuildRequestConfiguration.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildRequestConfigurationResponse, BuildRequestConfigurationResponse.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.BuildResult, BuildResult.FactoryForDeserialization, this);
+                _nodeManager.RegisterPacketHandler(NodePacketType.FileAccessReport, FileAccessReport.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.NodeShutdown, NodeShutdown.FactoryForDeserialization, this);
+                _nodeManager.RegisterPacketHandler(NodePacketType.ProcessReport, ProcessReport.FactoryForDeserialization, this);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResolveSdkRequest, SdkResolverRequest.FactoryForDeserialization, SdkResolverService as INodePacketHandler);
                 _nodeManager.RegisterPacketHandler(NodePacketType.ResourceRequest, ResourceRequest.FactoryForDeserialization, this);
 
@@ -699,6 +718,29 @@ void InitializeCaches()
             }
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Configure the build to use I/O tracking for nodes.
+        /// </summary>
+        /// <remarks>
+        /// Must be a separate non-inlinable method to avoid loading the BuildXL assembly when not opted in.
+        /// </remarks>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        private void EnableDetouredNodeLauncher()
+        {
+            // Currently BuildXL only supports x64. Once this feature moves out of the experimental phase, this will need to be addressed.
+            ErrorUtilities.VerifyThrowInvalidOperation(NativeMethodsShared.ProcessorArchitecture == NativeMethodsShared.ProcessorArchitectures.X64, "ReportFileAccessesX64Only");
+
+            // To properly report file access, we need to disable the in-proc node which won't be detoured.
+            _buildParameters.DisableInProcNode = true;
+
+            // Node reuse must be disabled as future builds will not be able to listen to events raised by detours.
+            _buildParameters.EnableNodeReuse = false;
+
+            _componentFactories.ReplaceFactory(BuildComponentType.NodeLauncher, DetouredNodeLauncher.CreateComponent);
+        }
+#endif
+
         private static void AttachDebugger()
         {
             if (Debugger.IsAttached)
@@ -1564,6 +1606,16 @@ private void ProcessPacket(int node, INodePacket packet)
                         HandleNodeShutdown(node, shutdownPacket);
                         break;
 
+                    case NodePacketType.FileAccessReport:
+                        FileAccessReport fileAccessReport = ExpectPacketType<FileAccessReport>(packet, NodePacketType.FileAccessReport);
+                        HandleFileAccessReport(node, fileAccessReport);
+                        break;
+
+                    case NodePacketType.ProcessReport:
+                        ProcessReport processReport = ExpectPacketType<ProcessReport>(packet, NodePacketType.ProcessReport);
+                        HandleProcessReport(node, processReport);
+                        break;
+
                     default:
                         ErrorUtilities.ThrowInternalError("Unexpected packet received by BuildManager: {0}", packet.Type);
                         break;
@@ -2342,9 +2394,9 @@ private void HandleConfigurationRequest(int node, BuildRequestConfiguration unre
 
             var response = new BuildRequestConfigurationResponse(unresolvedConfiguration.ConfigurationId, resolvedConfiguration.ConfigurationId, resolvedConfiguration.ResultsNodeId);
 
-            if (!_nodeIdToKnownConfigurations.TryGetValue(node, out HashSet<NGen<int>> configurationsOnNode))
+            if (!_nodeIdToKnownConfigurations.TryGetValue(node, out HashSet<int> configurationsOnNode))
             {
-                configurationsOnNode = new HashSet<NGen<int>>();
+                configurationsOnNode = new HashSet<int>();
                 _nodeIdToKnownConfigurations[node] = configurationsOnNode;
             }
 
@@ -2371,6 +2423,39 @@ private void HandleResult(int node, BuildResult result)
                 configuration.ProjectTargets ??= result.ProjectTargets;
             }
 
+            // Only report results to the project cache services if it's the result for a build submission.
+            // Note that graph builds create a submission for each node in the graph, so each node in the graph will be
+            // handled here. This intentionally mirrors the behavior for cache requests, as it doesn't make sense to
+            // report for projects which aren't going to be requested. Ideally, *any* request could be handled, but that
+            // would require moving the cache service interactions to the Scheduler.
+            if (_buildSubmissions.TryGetValue(result.SubmissionId, out BuildSubmission buildSubmission))
+            {
+                // The result may be associated with the build submission due to it being the submission which
+                // caused the build, but not the actual request which was originally used with the build submission.
+                // ie. it may be a dependency of the "root-level" project which is associated with this submission, which
+                // isn't what we're looking for. Ensure only the actual submission's request is considered.
+                if (buildSubmission.BuildRequest != null
+                    && buildSubmission.BuildRequest.ConfigurationId == configuration.ConfigurationId
+                    && _projectCacheService.ShouldUseCache(configuration))
+                {
+                    BuildEventContext buildEventContext = _projectStartedEvents.TryGetValue(result.SubmissionId, out BuildEventArgs buildEventArgs)
+                        ? buildEventArgs.BuildEventContext
+                        : new BuildEventContext(result.SubmissionId, node, configuration.Project?.EvaluationId ?? BuildEventContext.InvalidEvaluationId, configuration.ConfigurationId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+                    try
+                    {
+                        _projectCacheService.HandleBuildResultAsync(configuration, result, buildEventContext, _executionCancellationTokenSource.Token).Wait();
+                    }
+                    catch (AggregateException ex) when (ex.InnerExceptions.All(inner => inner is OperationCanceledException))
+                    {
+                        // The build is being cancelled. Swallow any exceptions related specifically to cancellation.
+                    }
+                    catch (OperationCanceledException)
+                    {
+                        // The build is being cancelled. Swallow any exceptions related specifically to cancellation.
+                    }
+                }
+            }
+
             IEnumerable<ScheduleResponse> response = _scheduler.ReportResult(node, result);
             PerformSchedulingActions(response);
         }
@@ -2437,6 +2522,36 @@ private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket)
             CheckForActiveNodesAndCleanUpSubmissions();
         }
 
+        /// <summary>
+        /// Report the received <paramref name="fileAccessReport"/> to the file access manager.
+        /// </summary>
+        /// <param name="nodeId">The id of the node from which the <paramref name="fileAccessReport"/> was received.</param>
+        /// <param name="fileAccessReport">The file access report.</param>
+        private void HandleFileAccessReport(int nodeId, FileAccessReport fileAccessReport)
+        {
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportFileAccess(fileAccessReport.FileAccessData, nodeId);
+            }
+#endif
+        }
+
+        /// <summary>
+        /// Report the received <paramref name="processReport"/> to the file access manager.
+        /// </summary>
+        /// <param name="nodeId">The id of the node from which the <paramref name="processReport"/> was received.</param>
+        /// <param name="processReport">The process data report.</param>
+        private void HandleProcessReport(int nodeId, ProcessReport processReport)
+        {
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                ((FileAccessManager)((IBuildComponentHost)this).GetComponent(BuildComponentType.FileAccessManager)).ReportProcess(processReport.ProcessData, nodeId);
+            }
+#endif
+        }
+
         /// <summary>
         /// If there are no more active nodes, cleans up any remaining submissions.
         /// </summary>
@@ -2549,7 +2664,7 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
                             // of which nodes have had configurations specifically assigned to them for building.  However, a node may
                             // have created a configuration based on a build request it needs to wait on.  In this
                             // case we need not send the configuration since it will already have been mapped earlier.
-                            if (!_nodeIdToKnownConfigurations.TryGetValue(response.NodeId, out HashSet<NGen<int>> configurationsOnNode) ||
+                            if (!_nodeIdToKnownConfigurations.TryGetValue(response.NodeId, out HashSet<int> configurationsOnNode) ||
                                !configurationsOnNode.Contains(response.BuildRequest.ConfigurationId))
                             {
                                 IConfigCache configCache = _componentFactories.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 8d7a8268648..582532e5795 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -220,6 +220,8 @@ public class BuildParameters : ITranslatable
 
         private string _outputResultsCacheFile;
 
+        private bool _reportFileAccesses;
+
         /// <summary>
         /// Constructor for those who intend to set all properties themselves.
         /// </summary>
@@ -303,6 +305,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _projectIsolationMode = other.ProjectIsolationMode;
             _inputResultsCacheFiles = other._inputResultsCacheFiles;
             _outputResultsCacheFile = other._outputResultsCacheFile;
+            _reportFileAccesses = other._reportFileAccesses;
             DiscardBuildResults = other.DiscardBuildResults;
             LowPriority = other.LowPriority;
             Question = other.Question;
@@ -801,6 +804,17 @@ public string OutputResultsCacheFile
             set => _outputResultsCacheFile = value;
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Gets or sets a value indicating whether file accesses should be reported to any configured project cache plugins.
+        /// </summary>
+        public bool ReportFileAccesses
+        {
+            get => _reportFileAccesses;
+            set => _reportFileAccesses = value;
+        }
+#endif
+
         /// <summary>
         /// Determines whether MSBuild will save the results of builds after EndBuild to speed up future builds.
         /// </summary>
@@ -885,6 +899,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _interactive);
             translator.Translate(ref _question);
             translator.TranslateEnum(ref _projectIsolationMode, (int)_projectIsolationMode);
+            translator.Translate(ref _reportFileAccesses);
 
             // ProjectRootElementCache is not transmitted.
             // ResetCaches is not transmitted.
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 693912475d0..e0782c3fbf3 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -473,7 +473,7 @@ private bool TryLaunchServer()
                 };
                 NodeLauncher nodeLauncher = new NodeLauncher();
                 CommunicationsUtilities.Trace("Starting Server...");
-                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions));
+                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions), nodeId: 0);
                 CommunicationsUtilities.Trace("Server started with PID: {0}", msbuildProcess?.Id);
             }
             catch (Exception ex)
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index 5ea3ee2bde1..c4d543c87da 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -4,6 +4,7 @@
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -61,6 +62,7 @@ public void RegisterDefaultFactories()
             _componentEntriesByType[BuildComponentType.NodeManager] = new BuildComponentEntry(BuildComponentType.NodeManager, NodeManager.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.TaskHostNodeManager] = new BuildComponentEntry(BuildComponentType.TaskHostNodeManager, TaskHostNodeManager.CreateComponent, CreationPattern.Singleton);
 
+            _componentEntriesByType[BuildComponentType.NodeLauncher] = new BuildComponentEntry(BuildComponentType.NodeLauncher, NodeLauncher.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.InProcNodeProvider] = new BuildComponentEntry(BuildComponentType.InProcNodeProvider, NodeProviderInProc.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.OutOfProcNodeProvider] = new BuildComponentEntry(BuildComponentType.OutOfProcNodeProvider, NodeProviderOutOfProc.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.OutOfProcTaskHostNodeProvider] = new BuildComponentEntry(BuildComponentType.OutOfProcTaskHostNodeProvider, NodeProviderOutOfProcTaskHost.CreateComponent, CreationPattern.Singleton);
@@ -80,6 +82,10 @@ public void RegisterDefaultFactories()
 
             // SDK resolution
             _componentEntriesByType[BuildComponentType.SdkResolverService] = new BuildComponentEntry(BuildComponentType.SdkResolverService, MainNodeSdkResolverService.CreateComponent, CreationPattern.Singleton);
+
+#if FEATURE_REPORTFILEACCESSES
+            _componentEntriesByType[BuildComponentType.FileAccessManager] = new BuildComponentEntry(BuildComponentType.FileAccessManager, FileAccessManager.CreateComponent, CreationPattern.Singleton);
+#endif
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index ef42f9fe895..297ac265e0e 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -1122,7 +1122,7 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
             lock (issuingEntry.GlobalLock)
             {
                 var existingResultsToReport = new List<BuildResult>();
-                var unresolvedConfigurationsAdded = new HashSet<NGen<int>>();
+                var unresolvedConfigurationsAdded = new HashSet<int>();
 
                 foreach (FullyQualifiedBuildRequest request in newRequests)
                 {
diff --git a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
new file mode 100644
index 00000000000..944334e0c9f
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
@@ -0,0 +1,192 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Linq;
+using BuildXL.Processes;
+using BuildXL.Utilities.Core;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.FileAccesses;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+#nullable disable
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class DetouredNodeLauncher : INodeLauncher, IBuildComponent
+    {
+        private readonly List<ISandboxedProcess> _sandboxedProcesses = new();
+
+        private readonly BuildParameters.IBuildParameters _environmentVariables = CreateEnvironmentVariables();
+
+        private IFileAccessManager _fileAccessManager;
+
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));
+            return new DetouredNodeLauncher();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+            _fileAccessManager = (IFileAccessManager)host.GetComponent(BuildComponentType.FileAccessManager);
+        }
+
+        public void ShutdownComponent()
+        {
+            _fileAccessManager = null;
+
+            foreach (ISandboxedProcess sandboxedProcess in _sandboxedProcesses)
+            {
+                sandboxedProcess.Dispose();
+            }
+
+            _sandboxedProcesses.Clear();
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process
+        /// </summary>
+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
+        {
+            // Should always have been set already.
+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
+
+            ErrorUtilities.VerifyThrowInternalNull(_fileAccessManager, nameof(_fileAccessManager));
+
+            if (!FileSystems.Default.FileExists(msbuildLocation))
+            {
+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotFindMSBuildExe", msbuildLocation));
+            }
+
+            // Repeat the executable name as the first token of the command line because the command line
+            // parser logic expects it and will otherwise skip the first argument
+            commandLineArgs = $"\"{msbuildLocation}\" {commandLineArgs}";
+
+            CommunicationsUtilities.Trace("Launching node from {0}", msbuildLocation);
+
+            string exeName = msbuildLocation;
+
+#if RUNTIME_TYPE_NETCORE
+            // Run the child process with the same host as the currently-running process.
+            exeName = CurrentHost.GetCurrentHost();
+#endif
+
+            var eventListener = new DetoursEventListener(_fileAccessManager, nodeId);
+            eventListener.SetMessageHandlingFlags(MessageHandlingFlags.DebugMessageNotify | MessageHandlingFlags.FileAccessNotify | MessageHandlingFlags.ProcessDataNotify | MessageHandlingFlags.ProcessDetoursStatusNotify);
+
+            var info = new SandboxedProcessInfo(
+                fileStorage: null, // Don't write stdout/stderr to files
+                fileName: exeName,
+                disableConHostSharing: false,
+                detoursEventListener: eventListener,
+                createJobObjectForCurrentProcess: false)
+            {
+                SandboxKind = SandboxKind.Default,
+                PipDescription = "MSBuild",
+                PipSemiStableHash = 0,
+                Arguments = commandLineArgs,
+                EnvironmentVariables = _environmentVariables,
+                MaxLengthInMemory = 0, // Don't buffer any output
+            };
+
+            // FileAccessManifest.AddScope is used to define the list of files which the running process is allowed to access and what kinds of file accesses are allowed
+            // Tracker internally uses AbsolutePath.Invalid to represent the root, just like Unix '/' root.
+            // this code allows all types of accesses for all files
+            info.FileAccessManifest.AddScope(
+                AbsolutePath.Invalid,
+                FileAccessPolicy.MaskNothing,
+                FileAccessPolicy.AllowAll | FileAccessPolicy.ReportAccess);
+
+            // Support shared compilation
+            info.FileAccessManifest.ChildProcessesToBreakawayFromSandbox = new string[] { NativeMethodsShared.IsWindows ? "VBCSCompiler.exe" : "VBCSCompiler" };
+            info.FileAccessManifest.MonitorChildProcesses = true;
+            info.FileAccessManifest.IgnoreReparsePoints = true;
+            info.FileAccessManifest.UseExtraThreadToDrainNtClose = false;
+            info.FileAccessManifest.UseLargeNtClosePreallocatedList = true;
+            info.FileAccessManifest.LogProcessData = true;
+
+            // needed for logging process arguments when a new process is invoked; see DetoursEventListener.cs
+            info.FileAccessManifest.ReportProcessArgs = true;
+
+            // By default, BuildXL sets the timestamp of all input files to January 1, 1970
+            // This breaks some tools like Robocopy which will not copy a file to the destination if the file exists at the destination and has a timestamp that is more recent than the source file
+            info.FileAccessManifest.NormalizeReadTimestamps = false;
+
+            // If a process exits but its child processes survive, Tracker waits 30 seconds by default to wait for this process to exit.
+            // This slows down C++ builds in which mspdbsrv.exe doesn't exit when it's parent exits. Set this time to 0.
+            info.NestedProcessTerminationTimeout = TimeSpan.Zero;
+
+            ISandboxedProcess sp = SandboxedProcessFactory.StartAsync(info, forceSandboxing: false).GetAwaiter().GetResult();
+            lock (_sandboxedProcesses)
+            {
+                _sandboxedProcesses.Add(sp);
+            }
+
+            CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", sp.ProcessId, exeName);
+            return Process.GetProcessById(sp.ProcessId);
+        }
+
+        private static BuildParameters.IBuildParameters CreateEnvironmentVariables()
+        {
+            var envVars = new Dictionary<string, string>();
+            foreach (DictionaryEntry baseVar in Environment.GetEnvironmentVariables())
+            {
+                envVars.Add((string)baseVar.Key, (string)baseVar.Value);
+            }
+
+            return BuildParameters.GetFactory().PopulateFromDictionary(envVars);
+        }
+
+        private sealed class DetoursEventListener : IDetoursEventListener
+        {
+            private readonly IFileAccessManager _fileAccessManager;
+            private readonly int _nodeId;
+
+            public DetoursEventListener(IFileAccessManager fileAccessManager, int nodeId)
+            {
+                _fileAccessManager = fileAccessManager;
+                _nodeId = nodeId;
+            }
+
+            public override void HandleDebugMessage(DebugData debugData)
+            {
+            }
+
+            public override void HandleFileAccess(FileAccessData fileAccessData) => _fileAccessManager.ReportFileAccess(
+                new Experimental.FileAccess.FileAccessData(
+                    (Experimental.FileAccess.ReportedFileOperation)fileAccessData.Operation,
+                    (Experimental.FileAccess.RequestedAccess)fileAccessData.RequestedAccess,
+                    fileAccessData.ProcessId,
+                    fileAccessData.Error,
+                    (Experimental.FileAccess.DesiredAccess)fileAccessData.DesiredAccess,
+                    (Experimental.FileAccess.FlagsAndAttributes)fileAccessData.FlagsAndAttributes,
+                    fileAccessData.Path,
+                    fileAccessData.ProcessArgs,
+                    fileAccessData.IsAnAugmentedFileAccess),
+                _nodeId);
+
+            public override void HandleProcessData(ProcessData processData) => _fileAccessManager.ReportProcess(
+                new Experimental.FileAccess.ProcessData(
+                    processData.ProcessName,
+                    processData.ProcessId,
+                    processData.ParentProcessId,
+                    processData.CreationDateTime,
+                    processData.ExitDateTime,
+                    processData.ExitCode),
+                _nodeId);
+
+            public override void HandleProcessDetouringStatus(ProcessDetouringStatusData data)
+            {
+            }
+        }
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/Communications/INodeLauncher.cs b/src/Build/BackEnd/Components/Communications/INodeLauncher.cs
new file mode 100644
index 00000000000..c409c856c0b
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/INodeLauncher.cs
@@ -0,0 +1,12 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal interface INodeLauncher
+    {
+        Process Start(string msbuildLocation, string commandLineArgs, int nodeId);
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index 611c4ca68c9..ddec6d79279 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -16,12 +16,26 @@
 
 namespace Microsoft.Build.BackEnd
 {
-    internal class NodeLauncher
+    internal sealed class NodeLauncher : INodeLauncher, IBuildComponent
     {
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.NodeLauncher, nameof(type));
+            return new NodeLauncher();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+        }
+
+        public void ShutdownComponent()
+        {
+        }
+
         /// <summary>
         /// Creates a new MSBuild process
         /// </summary>
-        public Process Start(string msbuildLocation, string commandLineArgs)
+        public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
         {
             // Disable MSBuild server for a child process.
             // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.
@@ -181,7 +195,7 @@ private Process StartInternal(string msbuildLocation, string commandLineArgs)
             }
         }
 
-        private Process DisableMSBuildServer(Func<Process> func)
+        private static Process DisableMSBuildServer(Func<Process> func)
         {
             string useMSBuildServerEnvVarValue = Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName);
             try
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 58105527c16..273e6990f13 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -332,8 +332,8 @@ bool StartNewNode(int nodeId)
                     }
 #endif
                     // Create the node process
-                    NodeLauncher nodeLauncher = new NodeLauncher();
-                    Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs);
+                    INodeLauncher nodeLauncher = (INodeLauncher)_componentHost.GetComponent(BuildComponentType.NodeLauncher);
+                    Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId);
                     _processesToIgnore.TryAdd(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id), default);
 
                     // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
new file mode 100644
index 00000000000..6943ff208e0
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
@@ -0,0 +1,188 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Collections.Concurrent;
+using System.IO;
+using System.Runtime.Versioning;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class FileAccessManager : IFileAccessManager, IBuildComponent
+    {
+        private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, Action<BuildRequest, ProcessData> ProcessHandler);
+
+        // In order to synchronize between the node communication and the file access reporting, a special file access
+        // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen
+        // and the build result is reported can plugins be notified about project completion.
+        // NOTE! This is currently Windows-specific and will need to change once this feature is opened up to more scenarios.
+        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @":\{MSBuildFileAccessCompletion}\";
+
+        private IScheduler? _scheduler;
+        private IConfigCache? _configCache;
+
+        private object _handlersWriteLock = new object();
+        private Handlers[] _handlers = Array.Empty<Handlers>();
+        private string? _tempDirectory;
+
+        // Keyed on global request id
+        private readonly ConcurrentDictionary<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles = new();
+
+        public static IBuildComponent CreateComponent(BuildComponentType type)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));
+            return new FileAccessManager();
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+            _scheduler = host.GetComponent(BuildComponentType.Scheduler) as IScheduler;
+            _configCache = host.GetComponent(BuildComponentType.ConfigCache) as IConfigCache;
+            _tempDirectory = FileUtilities.EnsureNoTrailingSlash(FileUtilities.TempFileDirectory);
+        }
+
+        public void ShutdownComponent()
+        {
+            _scheduler = null;
+            _configCache = null;
+            _tempDirectory = null;
+            _fileAccessCompletionWaitHandles.Clear();
+        }
+
+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId)
+        {
+            string fileAccessPath = fileAccessData.Path;
+
+            // Intercept and avoid forwarding the file access completion
+            if (fileAccessPath.StartsWith(FileAccessCompletionPrefix, StringComparison.Ordinal))
+            {
+                // Parse out the global request id. Note, this must match what NotifyFileAccessCompletion does.
+                int globalRequestId = int.Parse(fileAccessPath.Substring(FileAccessCompletionPrefix.Length));
+
+                ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());
+                handle.Set();
+            }
+            else if (_tempDirectory != null && fileAccessPath.StartsWith(_tempDirectory))
+            {
+                // Ignore MSBuild's temp directory as these are related to internal MSBuild functionality and not always directly related to the execution of the project itself,
+                // so should not be exposed to handlers. Note that this is not %TEMP% but instead a subdir under %TEMP% which is only expected to be used by MSBuild.
+                return;
+            }
+            else
+            {
+                // Forward the file access to handlers.
+                BuildRequest? buildRequest = GetBuildRequest(nodeId);
+                if (buildRequest != null)
+                {
+                    Handlers[] localHandlers = _handlers;
+                    foreach (Handlers handlers in localHandlers)
+                    {
+                        handlers.FileAccessHander.Invoke(buildRequest, fileAccessData);
+                    }
+                }
+            }
+        }
+
+        public void ReportProcess(ProcessData processData, int nodeId)
+        {
+            BuildRequest? buildRequest = GetBuildRequest(nodeId);
+            if (buildRequest != null)
+            {
+                Handlers[] localHandlers = _handlers;
+                foreach (Handlers handlers in localHandlers)
+                {
+                    handlers.ProcessHandler.Invoke(buildRequest, processData);
+                }
+            }
+        }
+
+        public HandlerRegistration RegisterHandlers(Action<BuildRequest, FileAccessData> fileAccessHandler, Action<BuildRequest, ProcessData> processHandler)
+        {
+            lock (_handlersWriteLock)
+            {
+                Handlers[] newHandlers = new Handlers[_handlers.Length + 1];
+                _handlers.CopyTo(newHandlers, 0);
+
+                Handlers addedHandlers = new(fileAccessHandler, processHandler);
+                newHandlers[_handlers.Length] = addedHandlers;
+
+                _handlers = newHandlers;
+
+                return new HandlerRegistration(() => UnregisterHandlers(addedHandlers));
+            }
+        }
+
+        private void UnregisterHandlers(Handlers handlersToRemove)
+        {
+            lock (_handlersWriteLock)
+            {
+                Handlers[] newHandlers = new Handlers[_handlers.Length - 1];
+                int newHandlersIdx = 0;
+                for (int handlersIdx = 0; handlersIdx < _handlers.Length; handlersIdx++)
+                {
+                    if (_handlers[handlersIdx] != handlersToRemove)
+                    {
+                        newHandlers[newHandlersIdx] = _handlers[handlersIdx];
+                        newHandlersIdx++;
+                    }
+                }
+
+                _handlers = newHandlers;
+            }
+        }
+
+        // The [SupportedOSPlatform] attribute is a safeguard to ensure that the comment on FileAccessCompletionPrefix regarding being Windows-only gets addressed.
+        // [SupportedOSPlatform] doesn't apply to fields, so using it here as a reasonable proxy.
+        [SupportedOSPlatform("windows")]
+        public static void NotifyFileAccessCompletion(int globalRequestId)
+        {
+            // Make a dummy file access to use as a notification that the file accesses should be completed for a project.
+            string filePath = FileAccessCompletionPrefix + globalRequestId.ToString();
+            _ = File.Exists(filePath);
+        }
+
+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken)
+        {
+            ManualResetEventSlim handle = _fileAccessCompletionWaitHandles.GetOrAdd(globalRequestId, static _ => new ManualResetEventSlim());
+            if (!handle.IsSet)
+            {
+                handle.Wait(cancellationToken);
+            }
+
+            // Try to keep the collection clean. A request should not need to be completed twice.
+            _fileAccessCompletionWaitHandles.TryRemove(globalRequestId, out _);
+        }
+
+        private BuildRequest? GetBuildRequest(int nodeId)
+        {
+            ErrorUtilities.VerifyThrow(
+                _scheduler != null && _configCache != null,
+                "Component has not been initialized");
+
+            // Note: If the node isn't executing anything it may be accessing binaries required to run, eg. the MSBuild binaries
+            return _scheduler!.GetExecutingRequestByNode(nodeId);
+        }
+
+        internal readonly struct HandlerRegistration : IDisposable
+        {
+            private readonly Action _unregisterAction;
+
+            public HandlerRegistration(Action unregisterAction)
+            {
+                _unregisterAction = unregisterAction;
+            }
+
+            public void Dispose()
+            {
+                _unregisterAction();
+            }
+        }
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs
new file mode 100644
index 00000000000..72ce0107921
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessReport.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class FileAccessReport : INodePacket
+    {
+        private FileAccessData _fileAccessData;
+
+        internal FileAccessReport(FileAccessData fileAccessData) => _fileAccessData = fileAccessData;
+
+        private FileAccessReport(ITranslator translator) => Translate(translator);
+
+        /// <inheritdoc/>
+        public NodePacketType Type => NodePacketType.FileAccessReport;
+
+        /// <inheritdoc/>
+        public void Translate(ITranslator translator) => translator.Translate(ref _fileAccessData);
+
+        internal FileAccessData FileAccessData => _fileAccessData;
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator) => new FileAccessReport(translator);
+    }
+}
diff --git a/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
new file mode 100644
index 00000000000..dd3b7685053
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/IFileAccessManager.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal interface IFileAccessManager
+    {
+        void ReportFileAccess(FileAccessData fileAccessData, int nodeId);
+
+        void ReportProcess(ProcessData processData, int nodeId);
+
+        // Note: The return type of FileAccessManager.HandlerRegistration is exposed directly instead of IDisposable to avoid boxing.
+        FileAccessManager.HandlerRegistration RegisterHandlers(
+            Action<BuildRequest, FileAccessData> fileAccessHandler,
+            Action<BuildRequest, ProcessData> processHandler);
+
+        void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken);
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
new file mode 100644
index 00000000000..e211f674789
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/OutOfProcNodeFileAccessManager.cs
@@ -0,0 +1,63 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#if FEATURE_REPORTFILEACCESSES
+using System;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.FileAccesses
+{
+    /// <summary>
+    /// Reports file accesses and process data to the in-proc node.
+    /// </summary>
+    internal sealed class OutOfProcNodeFileAccessManager : IFileAccessManager, IBuildComponent
+    {
+        /// <summary>
+        /// The <see cref="Action"/> to report file accesses and process
+        /// data to the in-proc node.
+        /// </summary>
+        private readonly Action<INodePacket> _sendPacket;
+
+        private OutOfProcNodeFileAccessManager(Action<INodePacket> sendPacket) => _sendPacket = sendPacket;
+
+        public static IBuildComponent CreateComponent(BuildComponentType type, Action<INodePacket> sendPacket)
+        {
+            ErrorUtilities.VerifyThrowArgumentOutOfRange(type == BuildComponentType.FileAccessManager, nameof(type));
+            return new OutOfProcNodeFileAccessManager(sendPacket);
+        }
+
+        public void InitializeComponent(IBuildComponentHost host)
+        {
+        }
+
+        public void ShutdownComponent()
+        {
+        }
+
+        /// <summary>
+        /// Reports a file access to the in-proc node.
+        /// </summary>
+        /// <param name="fileAccessData">The file access to report to the in-proc node.</param>
+        /// <param name="nodeId">The id of the reporting out-of-proc node.</param>
+        public void ReportFileAccess(FileAccessData fileAccessData, int nodeId) => _sendPacket(new FileAccessReport(fileAccessData));
+
+        /// <summary>
+        /// Reports process data to the in-proc node.
+        /// </summary>
+        /// <param name="processData">The process data to report to the in-proc node.</param>
+        /// <param name="nodeId">The id of the reporting out-of-proc node.</param>
+        public void ReportProcess(ProcessData processData, int nodeId) => _sendPacket(new ProcessReport(processData));
+
+        public FileAccessManager.HandlerRegistration RegisterHandlers(
+            Action<BuildRequest, FileAccessData> fileAccessHandler,
+            Action<BuildRequest, ProcessData> processHandler) =>
+            throw new NotImplementedException("This method should not be called in OOP nodes.");
+
+        public void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken) =>
+            throw new NotImplementedException("This method should not be called in OOP nodes.");
+    }
+}
+#endif
diff --git a/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs b/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs
new file mode 100644
index 00000000000..f8d891fe532
--- /dev/null
+++ b/src/Build/BackEnd/Components/FileAccesses/ProcessReport.cs
@@ -0,0 +1,27 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Experimental.FileAccess;
+
+namespace Microsoft.Build.FileAccesses
+{
+    internal sealed class ProcessReport : INodePacket
+    {
+        private ProcessData _processData;
+
+        internal ProcessReport(ProcessData processData) => _processData = processData;
+
+        private ProcessReport(ITranslator translator) => Translate(translator);
+
+        /// <inheritdoc/>
+        public NodePacketType Type => NodePacketType.ProcessReport;
+
+        internal ProcessData ProcessData => _processData;
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator) => new ProcessReport(translator);
+
+        /// <inheritdoc/>
+        public void Translate(ITranslator translator) => translator.Translate(ref _processData);
+    }
+}
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index bcbc7eac430..5ae9d947906 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -130,6 +130,18 @@ internal enum BuildComponentType
         /// The SDK resolution service.
         /// </summary>
         SdkResolverService,
+
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// The component which is the sink for file access reports and forwards reports to other components.
+        /// </summary>
+        FileAccessManager,
+#endif
+
+        /// <summary>
+        /// The component which launches new MSBuild nodes.
+        /// </summary>
+        NodeLauncher,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 213b3009be4..2f95ae3f180 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -218,17 +218,17 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         /// <summary>
         /// A list of warnings to treat as errors for an associated <see cref="BuildEventContext"/>.  If an empty set, all warnings are treated as errors.
         /// </summary>
-        private IDictionary<int, ISet<string>> _warningsAsErrorsByProject;
+        private IDictionary<WarningsConfigKey, ISet<string>> _warningsAsErrorsByProject;
 
         /// <summary>
         /// A list of warnings to not to be promoted to errors for an associated <see cref="BuildEventContext"/>.
         /// </summary>
-        private IDictionary<int, ISet<string>> _warningsNotAsErrorsByProject;
+        private IDictionary<WarningsConfigKey, ISet<string>> _warningsNotAsErrorsByProject;
 
         /// <summary>
         /// A list of warnings to treat as messages for an associated <see cref="BuildEventContext"/>.
         /// </summary>
-        private IDictionary<int, ISet<string>> _warningsAsMessagesByProject;
+        private IDictionary<WarningsConfigKey, ISet<string>> _warningsAsMessagesByProject;
 
         /// <summary>
         /// The minimum message importance that must be logged because there is a possibility that a logger consumes it.
@@ -623,9 +623,9 @@ public ICollection<string> GetWarningsAsMessages(BuildEventContext context)
         /// <param name="warningsByProject">A dictionary of all warnings to be treated special by for which projects.</param>
         /// <param name="warnings">Warning codes we already know should be promoted, demoted, or not promoted as relevant.</param>
         /// <returns></returns>
-        private ICollection<string> GetWarningsForProject(BuildEventContext context, IDictionary<int, ISet<string>> warningsByProject, ISet<string> warnings)
+        private ICollection<string> GetWarningsForProject(BuildEventContext context, IDictionary<WarningsConfigKey, ISet<string>> warningsByProject, ISet<string> warnings)
         {
-            int key = GetWarningsAsErrorOrMessageKey(context);
+            WarningsConfigKey key = GetWarningsConfigKey(context);
 
             if (warningsByProject != null && warningsByProject.TryGetValue(key, out ISet<string> newWarnings))
             {
@@ -678,13 +678,13 @@ public void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet<stri
         /// <param name="warningsByProject">Dictionary with what warnings are currently known (by project) that we will add to.</param>
         /// <param name="buildEventContext">Context for the project to be added</param>
         /// <param name="codes">Codes to add</param>
-        private void AddWarningsAsMessagesOrErrors(ref IDictionary<int, ISet<string>> warningsByProject, BuildEventContext buildEventContext, ISet<string> codes)
+        private void AddWarningsAsMessagesOrErrors(ref IDictionary<WarningsConfigKey, ISet<string>> warningsByProject, BuildEventContext buildEventContext, ISet<string> codes)
         {
             lock (_lockObject)
             {
-                int key = GetWarningsAsErrorOrMessageKey(buildEventContext);
+                WarningsConfigKey key = GetWarningsConfigKey(buildEventContext);
 
-                warningsByProject ??= new ConcurrentDictionary<int, ISet<string>>();
+                warningsByProject ??= new ConcurrentDictionary<WarningsConfigKey, ISet<string>>();
 
                 if (!warningsByProject.ContainsKey(key))
                 {
@@ -1294,19 +1294,18 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         #endregion
 
         #region Private Methods
-        private static int GetWarningsAsErrorOrMessageKey(BuildEventContext buildEventContext)
+        private static WarningsConfigKey GetWarningsConfigKey(BuildEventContext buildEventContext)
         {
-            var hash = 17;
-            hash = (hash * 31) + buildEventContext.ProjectInstanceId;
-            hash = (hash * 31) + buildEventContext.ProjectContextId;
-            return hash;
+            return new WarningsConfigKey(buildEventContext.ProjectInstanceId, buildEventContext.ProjectContextId);
         }
 
-        private static int GetWarningsAsErrorOrMessageKey(BuildEventArgs buildEventArgs)
+        private static WarningsConfigKey GetWarningsConfigKey(BuildEventArgs buildEventArgs)
         {
-            return GetWarningsAsErrorOrMessageKey(buildEventArgs.BuildEventContext);
+            return GetWarningsConfigKey(buildEventArgs.BuildEventContext);
         }
 
+        private readonly record struct WarningsConfigKey(int InstanceId, int ContextId);
+
         /// <summary>
         /// Create a logging thread to process the logging queue.
         /// </summary>
@@ -1587,7 +1586,7 @@ private void RouteBuildEvent(object loggingEvent)
 
             if (buildEventArgs is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
             {
-                int key = GetWarningsAsErrorOrMessageKey(projectFinishedEvent);
+                WarningsConfigKey key = GetWarningsConfigKey(projectFinishedEvent);
                 _warningsAsErrorsByProject?.Remove(key);
                 _warningsNotAsErrorsByProject?.Remove(key);
                 _warningsAsMessagesByProject?.Remove(key);
@@ -1859,7 +1858,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
             // This only applies if the user specified <MSBuildWarningsAsMessages /> and there is a valid ProjectInstanceId
             if (_warningsAsMessagesByProject != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectInstanceId != BuildEventContext.InvalidProjectInstanceId)
             {
-                if (_warningsAsMessagesByProject.TryGetValue(GetWarningsAsErrorOrMessageKey(warningEvent), out ISet<string> codesByProject))
+                if (_warningsAsMessagesByProject.TryGetValue(GetWarningsConfigKey(warningEvent), out ISet<string> codesByProject))
                 {
                     return codesByProject?.Contains(warningEvent.Code) == true;
                 }
@@ -1870,7 +1869,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
 
         private bool WarningAsErrorNotOverriden(BuildWarningEventArgs warningEvent)
         {
-            int key = GetWarningsAsErrorOrMessageKey(warningEvent);
+            WarningsConfigKey key = GetWarningsConfigKey(warningEvent);
 
             return WarningsNotAsErrors?.Contains(warningEvent.Code) != true && !(_warningsNotAsErrorsByProject?.TryGetValue(key, out ISet<string> notToError) == true && notToError.Contains(warningEvent.Code));
         }
@@ -1897,7 +1896,7 @@ private bool ShouldTreatWarningAsError(BuildWarningEventArgs warningEvent)
             if (_warningsAsErrorsByProject != null && warningEvent.BuildEventContext != null && warningEvent.BuildEventContext.ProjectInstanceId != BuildEventContext.InvalidProjectInstanceId)
             {
                 // Attempt to get the list of warnings to treat as errors for the current project
-                int key = GetWarningsAsErrorOrMessageKey(warningEvent);
+                WarningsConfigKey key = GetWarningsConfigKey(warningEvent);
                 if (_warningsAsErrorsByProject.TryGetValue(key, out ISet<string> codesByProject))
                 {
                     // We create an empty set if all warnings should be treated as errors so that should be checked first.
diff --git a/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs b/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs
new file mode 100644
index 00000000000..5ff62cfb514
--- /dev/null
+++ b/src/Build/BackEnd/Components/ProjectCache/FileAccessContext.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Experimental.ProjectCache
+{
+    public readonly struct FileAccessContext
+    {
+        public FileAccessContext(
+            string projectFullPath,
+            IReadOnlyDictionary<string, string> globalProperties,
+            IReadOnlyList<string> targets)
+        {
+            ProjectFullPath = projectFullPath;
+            GlobalProperties = globalProperties;
+            Targets = targets;
+        }
+
+        public string ProjectFullPath { get; }
+
+        public IReadOnlyDictionary<string, string> GlobalProperties { get; }
+
+        public IReadOnlyList<string> Targets { get; }
+    }
+}
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
index 2bf479c6055..6c999cfcf53 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs
@@ -1,9 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.FileAccess;
 
 namespace Microsoft.Build.Experimental.ProjectCache
 {
@@ -39,5 +41,32 @@ public abstract Task<CacheResult> GetCacheResultAsync(
         ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
         /// </summary>
         public abstract Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);
+
+        /// <summary>
+        ///     Called for each file access from an MSBuild node or one of its children.
+        /// </summary>
+        [CLSCompliant(false)]
+        public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData)
+        {
+        }
+
+        /// <summary>
+        ///     Called for each new child process created by an MSBuild node or one of its children.
+        /// </summary>
+        [CLSCompliant(false)]
+        public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData)
+        {
+        }
+
+        /// <summary>
+        ///     Called when a build request finishes execution. This provides an opportunity for the plugin to take action on the
+        ///     aggregated file access reports from <see cref="HandleFileAccess(FileAccessContext, FileAccessData)"/>.
+        ///     Errors are checked via <see cref="PluginLoggerBase.HasLoggedErrors" />.
+        /// </summary>
+        public virtual Task HandleProjectFinishedAsync(
+            FileAccessContext fileAccessContext,
+            BuildResult buildResult,
+            PluginLoggerBase logger,
+            CancellationToken cancellationToken) => Task.CompletedTask;
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index e34e70cca44..d684119e4e8 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
@@ -33,17 +34,31 @@ internal sealed class ProjectCacheService : IAsyncDisposable
         private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
 
         private readonly BuildManager _buildManager;
+        private readonly IBuildComponentHost _componentHost;
         private readonly ILoggingService _loggingService;
+#if FEATURE_REPORTFILEACCESSES
+        private readonly IFileAccessManager _fileAccessManager;
+#endif
+        private readonly IConfigCache _configCache;
 
         private readonly ProjectCacheDescriptor? _globalProjectCacheDescriptor;
 
         private readonly ConcurrentDictionary<ProjectCacheDescriptor, Lazy<Task<ProjectCachePlugin>>> _projectCachePlugins = new(ProjectCacheDescriptorEqualityComparer.Instance);
 
+        // Helps to avoid excessive allocation since BuildRequestConfiguration doesn't expose global properties in a way the plugins can consume (PropertyDictionary<ProjectPropertyInstance> vs IReadOnlyDictionary<string, string>).
+        private readonly ConcurrentDictionary<BuildRequestConfiguration, IReadOnlyDictionary<string, string>> _globalPropertiesPerConfiguration = new();
+
         private bool _isVsScenario;
 
         private bool _isDisposed;
 
-        private record struct ProjectCachePlugin(string Name, ProjectCachePluginBase? Instance, ExceptionDispatchInfo? InitializationException = null);
+        private record struct ProjectCachePlugin(
+            string Name,
+            ProjectCachePluginBase? Instance,
+#if FEATURE_REPORTFILEACCESSES
+            FileAccessManager.HandlerRegistration? HandlerRegistration,
+#endif
+            ExceptionDispatchInfo? InitializationException = null);
 
         /// <summary>
         /// An instanatiable version of MSBuildFileSystemBase not overriding any methods,
@@ -61,10 +76,19 @@ private DefaultMSBuildFileSystem()
         public ProjectCacheService(
             BuildManager buildManager,
             ILoggingService loggingService,
+#if FEATURE_REPORTFILEACCESSES
+            IFileAccessManager fileAccessManager,
+#endif
+            IConfigCache configCache,
             ProjectCacheDescriptor? globalProjectCacheDescriptor)
         {
             _buildManager = buildManager;
+            _componentHost = buildManager;
             _loggingService = loggingService;
+#if FEATURE_REPORTFILEACCESSES
+            _fileAccessManager = fileAccessManager;
+#endif
+            _configCache = configCache;
             _globalProjectCacheDescriptor = globalProjectCacheDescriptor;
         }
 
@@ -75,18 +99,24 @@ public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationTok
         {
             EnsureNotDisposed();
 
-            Parallel.ForEach(
-                projectGraph.ProjectNodes,
-                s_parallelOptions,
-                node =>
+            // Performing this in a Task.Run to break away from the main thread and prevent hangs
+            Task.Run(
+                () =>
                 {
-                    foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
-                    {
-                        // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                        _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
-                            .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
-                    }
-                });
+                    Parallel.ForEach(
+                        projectGraph.ProjectNodes,
+                        s_parallelOptions,
+                        node =>
+                        {
+                            foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
+                            {
+                                // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, cancellationToken)
+                                    .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                            }
+                        });
+                },
+                cancellationToken);
         }
 
         public void InitializePluginsForVsScenario(
@@ -104,15 +134,21 @@ public void InitializePluginsForVsScenario(
                 return;
             }
 
-            Parallel.ForEach(
-                projectCacheDescriptors,
-                s_parallelOptions,
-                projectCacheDescriptor =>
+            // Performing this in a Task.Run to break away from the main thread and prevent hangs
+            Task.Run(
+                () =>
                 {
-                    // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                    _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
-                        .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
-                });
+                    Parallel.ForEach(
+                        projectCacheDescriptors,
+                        s_parallelOptions,
+                        projectCacheDescriptor =>
+                        {
+                            // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
+                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, cancellationToken)
+                                .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                        });
+                },
+                cancellationToken);
         }
 
         private Task<ProjectCachePlugin> GetProjectCachePluginAsync(
@@ -187,7 +223,13 @@ private async Task<ProjectCachePlugin> CreateAndInitializePluginAsync(
                 }
                 catch (Exception e)
                 {
-                    return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                    return new ProjectCachePlugin(
+                        pluginTypeName,
+                        Instance: null,
+#if FEATURE_REPORTFILEACCESSES
+                        HandlerRegistration: null,
+#endif
+                        ExceptionDispatchInfo.Capture(e));
                 }
                 finally
                 {
@@ -218,11 +260,43 @@ await pluginInstance.BeginBuildAsync(
                     ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheInitializationFailed");
                 }
 
-                return new ProjectCachePlugin(pluginTypeName, pluginInstance);
+#if FEATURE_REPORTFILEACCESSES
+            FileAccessManager.HandlerRegistration? handlerRegistration = null;
+            if (_componentHost.BuildParameters.ReportFileAccesses)
+            {
+                handlerRegistration = _fileAccessManager.RegisterHandlers(
+                    (buildRequest, fileAccessData) =>
+                    {
+                        // TODO: Filter out projects which do not configure this plugin
+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);
+                        pluginInstance.HandleFileAccess(fileAccessContext, fileAccessData);
+                    },
+                    (buildRequest, processData) =>
+                    {
+                        // TODO: Filter out projects which do not configure this plugin
+                        FileAccessContext fileAccessContext = GetFileAccessContext(buildRequest);
+                        pluginInstance.HandleProcess(fileAccessContext, processData);
+                    });
+            }
+#endif
+
+                return new ProjectCachePlugin(
+                    pluginTypeName,
+                    pluginInstance,
+#if FEATURE_REPORTFILEACCESSES
+                    handlerRegistration,
+#endif
+                    InitializationException: null);
             }
             catch (Exception e)
             {
-                return new ProjectCachePlugin(pluginTypeName, Instance: null, ExceptionDispatchInfo.Capture(e));
+                return new ProjectCachePlugin(
+                    pluginTypeName,
+                    Instance: null,
+#if FEATURE_REPORTFILEACCESSES
+                    HandlerRegistration: null,
+#endif
+                    ExceptionDispatchInfo.Capture(e));
             }
             finally
             {
@@ -230,6 +304,27 @@ await pluginInstance.BeginBuildAsync(
             }
         }
 
+        private FileAccessContext GetFileAccessContext(BuildRequest buildRequest)
+        {
+            BuildRequestConfiguration configuration = _configCache[buildRequest.ConfigurationId];
+            IReadOnlyDictionary<string, string> globalProperties = GetGlobalProperties(configuration);
+            return new FileAccessContext(configuration.ProjectFullPath, globalProperties, buildRequest.Targets);
+        }
+
+        private IReadOnlyDictionary<string, string> GetGlobalProperties(BuildRequestConfiguration configuration)
+            => _globalPropertiesPerConfiguration.GetOrAdd(
+                    configuration,
+                    static configuration =>
+                    {
+                        Dictionary<string, string> globalProperties = new(configuration.GlobalProperties.Count, StringComparer.OrdinalIgnoreCase);
+                        foreach (ProjectPropertyInstance property in configuration.GlobalProperties)
+                        {
+                            globalProperties.Add(property.Name, property.EvaluatedValue);
+                        }
+
+                        return globalProperties;
+                    });
+
         private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType)
         {
             try
@@ -306,6 +401,12 @@ public bool ShouldUseCache(BuildRequestConfiguration buildRequestConfiguration)
                 return false;
             }
 
+            // We need to retrieve the configuration if it's already loaded in order to access the Project property below.
+            if (buildRequestConfiguration.IsCached)
+            {
+                buildRequestConfiguration.RetrieveFromCache();
+            }
+
             // Check if there are any project cache items defined in the project
             return GetProjectCacheDescriptors(buildRequestConfiguration.Project).Any();
         }
@@ -587,6 +688,98 @@ static IReadOnlyCollection<ProjectGraphEntryPoint> GenerateGraphEntryPointsFromS
             }
         }
 
+        public async Task HandleBuildResultAsync(
+            BuildRequestConfiguration requestConfiguration,
+            BuildResult buildResult,
+            BuildEventContext buildEventContext,
+            CancellationToken cancellationToken)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(requestConfiguration.Project, nameof(requestConfiguration.Project));
+
+            if (_projectCachePlugins.IsEmpty)
+            {
+                return;
+            }
+
+            // We need to retrieve the configuration if it's already loaded in order to access the Project property below.
+            if (requestConfiguration.IsCached)
+            {
+                requestConfiguration.RetrieveFromCache();
+            }
+
+            // Filter to plugins which apply to the project, if any
+            List<ProjectCacheDescriptor> projectCacheDescriptors = GetProjectCacheDescriptors(requestConfiguration.Project).ToList();
+            if (projectCacheDescriptors.Count == 0)
+            {
+                return;
+            }
+
+#if FEATURE_REPORTFILEACCESSES
+            if (_componentHost.BuildParameters.ReportFileAccesses)
+            {
+                _fileAccessManager.WaitForFileAccessReportCompletion(buildResult.GlobalRequestId, cancellationToken);
+            }
+#endif
+
+            IReadOnlyDictionary<string, string> globalProperties = GetGlobalProperties(requestConfiguration);
+
+            List<string> targets = buildResult.ResultsByTarget.Keys.ToList();
+            string? targetNames = string.Join(", ", targets);
+
+            FileAccessContext fileAccessContext = new(requestConfiguration.ProjectFullPath, globalProperties, targets);
+
+            var buildEventFileInfo = new BuildEventFileInfo(requestConfiguration.ProjectFullPath);
+            var pluginLogger = new LoggingServiceToPluginLoggerAdapter(
+                _loggingService,
+                buildEventContext,
+                buildEventFileInfo);
+
+            Task[] tasks = new Task[projectCacheDescriptors.Count];
+            int idx = 0;
+            foreach (ProjectCacheDescriptor projectCacheDescriptor in projectCacheDescriptors)
+            {
+                tasks[idx++] = Task.Run(
+                    async () =>
+                    {
+                        if (!_projectCachePlugins.TryGetValue(projectCacheDescriptor, out Lazy<Task<ProjectCachePlugin>>? pluginLazyTask))
+                        {
+                            // The plugin might not be in the collection if it was never initialized, which can happen if there are multiple plugins
+                            // and the first one(s) always handles the cache request so the subsequent one(s) never get lazy initialized.
+                            return;
+                        }
+
+                        ProjectCachePlugin plugin = await pluginLazyTask.Value;
+
+                        // Rethrow any initialization exception.
+                        plugin.InitializationException?.Throw();
+
+                        ErrorUtilities.VerifyThrow(plugin.Instance != null, "Plugin '{0}' instance is null", plugin.Name);
+
+                        MSBuildEventSource.Log.ProjectCacheHandleBuildResultStart(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);
+                        try
+                        {
+                            await plugin.Instance!.HandleProjectFinishedAsync(fileAccessContext, buildResult, pluginLogger, cancellationToken);
+                        }
+                        catch (Exception e) when (e is not ProjectCacheException)
+                        {
+                            HandlePluginException(e, nameof(ProjectCachePluginBase.HandleProjectFinishedAsync));
+                        }
+                        finally
+                        {
+                            MSBuildEventSource.Log.ProjectCacheHandleBuildResultStop(plugin.Name, fileAccessContext.ProjectFullPath, targetNames);
+                        }
+                    },
+                    cancellationToken);
+            }
+
+            await Task.WhenAll(tasks).ConfigureAwait(false);
+
+            if (pluginLogger.HasLoggedErrors)
+            {
+                ProjectCacheException.ThrowForErrorLoggedInsideTheProjectCache("ProjectCacheHandleBuildResultFailed", fileAccessContext.ProjectFullPath);
+            }
+        }
+
         public async ValueTask DisposeAsync()
         {
             if (_isDisposed)
@@ -624,6 +817,13 @@ public async ValueTask DisposeAsync()
                         return;
                     }
 
+#if FEATURE_REPORTFILEACCESSES
+                    if (plugin.HandlerRegistration.HasValue)
+                    {
+                        plugin.HandlerRegistration.Value.Dispose();
+                    }
+#endif
+
                     MSBuildEventSource.Log.ProjectCacheEndBuildStart(plugin.Name);
                     try
                     {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
index 7e03b6cfd3e..14150696614 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/AssemblyLoadsTracker.cs
@@ -7,6 +7,9 @@
 using System.Linq;
 #endif
 using System.Reflection;
+#if FEATURE_ASSEMBLYLOADCONTEXT
+using System.Runtime.Loader;
+#endif
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 
@@ -152,10 +155,15 @@ private void CurrentDomainOnAssemblyLoad(object? sender, AssemblyLoadEventArgs a
             string? assemblyName = args.LoadedAssembly.FullName;
             string assemblyPath = args.LoadedAssembly.IsDynamic ? string.Empty : args.LoadedAssembly.Location;
             Guid mvid = args.LoadedAssembly.ManifestModule.ModuleVersionId;
+#if FEATURE_ASSEMBLYLOADCONTEXT
+            // AssemblyLoadContext.GetLoadContext returns null when the assembly isn't a RuntimeAssembly, which should not be the case here.
+            // Name would only be null if the AssemblyLoadContext didn't supply a name, but MSBuildLoadContext does.
+            string appDomainDescriptor = AssemblyLoadContext.GetLoadContext(args.LoadedAssembly)?.Name ?? "Unknown";
+#else
             string? appDomainDescriptor = _appDomain.IsDefaultAppDomain()
                 ? null
                 : $"{_appDomain.Id}|{_appDomain.FriendlyName}";
-
+#endif
 
             AssemblyLoadBuildEventArgs buildArgs = new(_context, _initiator, assemblyName, assemblyPath, mvid, appDomainDescriptor);
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 939370ab515..569a498e1cd 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -6,22 +6,24 @@
 using System.Collections.Generic;
 using System.Globalization;
 #if FEATURE_APPDOMAIN
-using System.Runtime.Remoting.Lifetime;
 using System.Runtime.Remoting;
+using System.Runtime.Remoting.Lifetime;
 #endif
+using System.Diagnostics;
+using System.Reflection;
 using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd.Components.Caching;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Eventing;
+using Microsoft.Build.Execution;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Execution;
-using System.Diagnostics;
-using Microsoft.Build.Collections;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskLoggingContext = Microsoft.Build.BackEnd.Logging.TaskLoggingContext;
-using System.Threading.Tasks;
-using Microsoft.Build.BackEnd.Components.Caching;
-using System.Reflection;
-using Microsoft.Build.Eventing;
 
 #nullable disable
 
@@ -343,6 +345,14 @@ public BuildEngineResult BuildProjectFilesInParallel(string[] projectFileNames,
         /// </summary>
         public void Yield()
         {
+#if FEATURE_REPORTFILEACCESSES
+            // If file accesses are being reported we should not yield as file access will be attributed to the wrong project.
+            if (_host.BuildParameters.ReportFileAccesses)
+            {
+                return;
+            }
+#endif
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -364,6 +374,14 @@ public void Reacquire()
             // to release explicitly granted cores when reacquiring the node may lead to deadlocks.
             ReleaseAllCores();
 
+#if FEATURE_REPORTFILEACCESSES
+            // If file accesses are being reported yielding is a no-op so reacquire should be too.
+            if (_host.BuildParameters.ReportFileAccesses)
+            {
+                return;
+            }
+#endif
+
             lock (_callbackMonitor)
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
@@ -377,7 +395,7 @@ public void Reacquire()
             }
         }
 
-        #endregion
+#endregion
 
         #region IBuildEngine Members
 
@@ -920,11 +938,26 @@ public override bool LogsMessagesOfImportance(MessageImportance importance)
 
             /// <inheritdoc/>
             public override bool IsTaskInputLoggingEnabled => _taskHost._host.BuildParameters.LogTaskInputs;
+
+#if FEATURE_REPORTFILEACCESSES
+            /// <summary>
+            /// Reports a file access from a task.
+            /// </summary>
+            /// <param name="fileAccessData">The file access to report.</param>
+            public void ReportFileAccess(FileAccessData fileAccessData)
+            {
+                IBuildComponentHost buildComponentHost = _taskHost._host;
+                if (buildComponentHost.BuildParameters.ReportFileAccesses)
+                {
+                    ((IFileAccessManager)buildComponentHost.GetComponent(BuildComponentType.FileAccessManager)).ReportFileAccess(fileAccessData, buildComponentHost.BuildParameters.NodeId);
+                }
+            }
+#endif
         }
 
         public EngineServices EngineServices { get; }
 
-        #endregion
+#endregion
 
         /// <summary>
         /// Called by the internal MSBuild task.
diff --git a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
index d66e50d62c1..84e22a9c67c 100644
--- a/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/IScheduler.cs
@@ -33,6 +33,11 @@ internal interface IScheduler : IBuildComponent
         /// <returns>A positive configuration id if one exists in the plan, 0 otherwise.</returns>
         int GetConfigurationIdFromPlan(string configurationPath);
 
+        /// <summary>
+        /// Retrieves the request executing on a node.
+        /// </summary>
+        BuildRequest GetExecutingRequestByNode(int nodeId);
+
         /// <summary>
         /// Reports to the scheduler that a request is blocked.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 53bf46ec2f3..6208aa883e4 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -283,6 +283,20 @@ public int GetConfigurationIdFromPlan(string configPath)
             return _schedulingPlan.GetConfigIdForPath(configPath);
         }
 
+        /// <summary>
+        /// Retrieves the request executing on a node.
+        /// </summary>
+        public BuildRequest GetExecutingRequestByNode(int nodeId)
+        {
+            if (!_schedulingData.IsNodeWorking(nodeId))
+            {
+                return null;
+            }
+
+            SchedulableRequest request = _schedulingData.GetExecutingRequestByNode(nodeId);
+            return request.BuildRequest;
+        }
+
         /// <summary>
         /// Reports that the specified request has become blocked and cannot proceed.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
index 68a14ae42a9..85943ff9442 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverManifest.cs
@@ -110,7 +110,12 @@ private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, str
                                     string pattern = reader.ReadElementContentAsString();
                                     try
                                     {
-                                        manifest.ResolvableSdkRegex = new Regex(pattern, RegexOptions.Compiled | RegexOptions.CultureInvariant, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));
+                                        RegexOptions regexOptions = RegexOptions.CultureInvariant;
+                                        // For the kind of patterns used here, compiled regexes on .NET Framework tend to run slower than interpreted ones.
+#if RUNTIME_TYPE_NETCORE
+                                        regexOptions |= RegexOptions.Compiled;
+#endif
+                                        manifest.ResolvableSdkRegex = new Regex(pattern, regexOptions, TimeSpan.FromMilliseconds(SdkResolverPatternRegexTimeoutMsc));
                                     }
                                     catch (ArgumentException ex)
                                     {
diff --git a/src/Build/BackEnd/Node/NodeConfiguration.cs b/src/Build/BackEnd/Node/NodeConfiguration.cs
index 0b678346842..2caec69b11d 100644
--- a/src/Build/BackEnd/Node/NodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/NodeConfiguration.cs
@@ -7,6 +7,7 @@
 using System.Diagnostics;
 
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
 #nullable disable
 
@@ -161,7 +162,28 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _buildParameters, BuildParameters.FactoryForDeserialization);
             translator.TranslateArray(ref _forwardingLoggers, LoggerDescription.FactoryForTranslation);
 #if FEATURE_APPDOMAIN
-            translator.TranslateDotNet(ref _appDomainSetup);
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
+            {
+                byte[] appDomainConfigBytes = null;
+
+                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+                if (translator.Mode == TranslationDirection.WriteToStream)
+                {
+                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+                }
+
+                translator.Translate(ref appDomainConfigBytes);
+
+                if (translator.Mode == TranslationDirection.ReadFromStream)
+                {
+                    _appDomainSetup = new AppDomainSetup();
+                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
+                }
+            }
+            else
+            {
+                translator.TranslateDotNet(ref _appDomainSetup);
+            }
 #endif
             translator.Translate(ref _loggingNodeConfiguration);
         }
@@ -173,6 +195,7 @@ internal static INodePacket FactoryForDeserialization(ITranslator translator)
         {
             NodeConfiguration configuration = new NodeConfiguration();
             configuration.Translate(translator);
+
             return configuration;
         }
         #endregion
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 619c476a1f6..7757598b2cd 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -153,11 +154,15 @@ public OutOfProcNode()
 
             // Create a factory for the out-of-proc SDK resolver service which can pass our SendPacket delegate to be used for sending packets to the main node
             OutOfProcNodeSdkResolverServiceFactory sdkResolverServiceFactory = new OutOfProcNodeSdkResolverServiceFactory(SendPacket);
-
             ((IBuildComponentHost)this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);
-
             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
 
+#if FEATURE_REPORTFILEACCESSES
+            ((IBuildComponentHost)this).RegisterFactory(
+                BuildComponentType.FileAccessManager,
+                (componentType) => OutOfProcNodeFileAccessManager.CreateComponent(componentType, SendPacket));
+#endif
+
             if (s_projectRootElementCacheBase == null)
             {
                 s_projectRootElementCacheBase = new ProjectRootElementCache(true /* automatically reload any changes from disk */);
@@ -369,6 +374,13 @@ private void OnRequestComplete(BuildRequest request, BuildResult result)
             {
                 _nodeEndpoint.SendData(result);
             }
+
+#if FEATURE_REPORTFILEACCESSES
+            if (_buildParameters.ReportFileAccesses)
+            {
+                FileAccessManager.NotifyFileAccessCompletion(result.GlobalRequestId);
+            }
+#endif
         }
 
         /// <summary>
@@ -575,7 +587,8 @@ private void SendPacket(INodePacket packet)
 #if RUNTIME_TYPE_NETCORE
                 if (packet is LogMessagePacketBase logMessage
                     && logMessage.EventType == LoggingEventType.CustomEvent 
-                    && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) 
+                    &&
+                    (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
                     && Traits.Instance.EscapeHatches.EnableWarningOnCustomBuildEvent)
                 {
                     BuildEventArgs buildEvent = logMessage.NodeBuildEvent.Value.Value;
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 8380f9cd3b9..fb954982e34 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -32,6 +32,11 @@
 
 #nullable disable
 
+// The BuildXL package causes an indirect dependency on the RuntimeContracts package, which adds an analyzer which forbids the use of System.Diagnostics.Contract.
+// So effectively if your dependencies use RuntimeContracts, it attempts to force itself on your as well.
+// See: https://github.com/SergeyTeplyakov/RuntimeContracts/issues/12
+#pragma warning disable RA001 // Do not use System.Diagnostics.Contract class.
+
 namespace Microsoft.Build.Collections
 {
     /// <summary>
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
index e979313ca70..98d38cdf5e8 100644
--- a/src/Build/CompatibilitySuppressions.xml
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -1,9 +1,61 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
+  <!-- Suppressions for api differences between main and vs17.8 when merging vs17.8 into main -->
   <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.HandleFileAccess(Microsoft.Build.Experimental.ProjectCache.FileAccessContext,Microsoft.Build.Framework.FileAccess.FileAccessData)</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.HandleProcess(Microsoft.Build.Experimental.ProjectCache.FileAccessContext,Microsoft.Build.Framework.FileAccess.ProcessData)</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.HandleFileAccess(Microsoft.Build.Experimental.ProjectCache.FileAccessContext,Microsoft.Build.Framework.FileAccess.FileAccessData)</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.HandleProcess(Microsoft.Build.Experimental.ProjectCache.FileAccessContext,Microsoft.Build.Framework.FileAccess.ProcessData)</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.HandleFileAccess(Microsoft.Build.Experimental.ProjectCache.FileAccessContext,Microsoft.Build.Framework.FileAccess.FileAccessData)</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.HandleProcess(Microsoft.Build.Experimental.ProjectCache.FileAccessContext,Microsoft.Build.Framework.FileAccess.ProcessData)</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.HandleFileAccess(Microsoft.Build.Experimental.ProjectCache.FileAccessContext,Microsoft.Build.Framework.FileAccess.FileAccessData)</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.HandleProcess(Microsoft.Build.Experimental.ProjectCache.FileAccessContext,Microsoft.Build.Framework.FileAccess.ProcessData)</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
 </Suppressions>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index b2540919cf2..a59fdb60e4d 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -1635,5 +1635,5 @@ internal string GetProjectRelativePathByGuid(string projectGuid)
         }
 
         #endregion
-    } // class SolutionParser
+    } // class SolutionFile
 } // namespace Microsoft.Build.Construction
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index f016e922451..5d2bf851cef 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -1548,6 +1548,13 @@ public bool TryUnloadProject(ProjectRootElement projectRootElement)
             }
         }
 
+        /// <summary>
+        /// Logs a BuildFinished event. This is used specifically when a ProjectCollection is created but never actually built, yet a BuildFinished event
+        /// is still desired. As an example, if a Project is just meant to be evaluated, but a binlog is also collected, that binlog should be able to
+        /// say the build succeeded or failed. This provides a mechanism to achieve that.
+        /// </summary>
+        public void LogBuildFinishedEvent(bool success) => _loggingService.LogBuildFinished(success);
+
         /// <summary>
         /// Called by a Project object to load itself into this collection.
         /// If the project was already loaded under a different name, it is unloaded.
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 645f8810cc0..cfc17374cb3 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -1020,11 +1020,11 @@ public ProjectItem CreateItem(string evaluatedIncludeEscaped, string evaluatedIn
             /// <summary>
             /// Applies the supplied metadata to the destination item.
             /// </summary>
-            public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<ProjectItem> destinationItems)
+            public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<ProjectItem> destinationItems)
             {
                 foreach (IItem<ProjectMetadata> item in destinationItems)
                 {
-                    foreach (Pair<ProjectMetadataElement, string> metadatum in metadata)
+                    foreach (KeyValuePair<ProjectMetadataElement, string> metadatum in metadata)
                     {
                         item.SetMetadata(metadatum.Key, metadatum.Value);
                     }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index f5db7b9d74a..3609af082d5 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -92,7 +92,7 @@ internal class Evaluator<P, I, M, D>
         /// Key is the directory of the file importing the usingTask, which is needed
         /// to handle any relative paths in the usingTask.
         /// </summary>
-        private readonly List<Pair<string, ProjectUsingTaskElement>> _usingTaskElements;
+        private readonly List<KeyValuePair<string, ProjectUsingTaskElement>> _usingTaskElements;
 
         /// <summary>
         /// List of ProjectTargetElement's traversing into imports.
@@ -115,7 +115,7 @@ internal class Evaluator<P, I, M, D>
         /// Dictionary of project full paths and a boolean that indicates whether at least one
         /// of their targets has the "Returns" attribute set.
         /// </summary>
-        private readonly Dictionary<ProjectRootElement, NGen<bool>> _projectSupportsReturnsAttribute;
+        private readonly Dictionary<ProjectRootElement, bool> _projectSupportsReturnsAttribute;
 
         /// <summary>
         /// The Project Xml to be evaluated.
@@ -249,11 +249,11 @@ private Evaluator(
             _data = data;
             _itemGroupElements = new List<ProjectItemGroupElement>();
             _itemDefinitionGroupElements = new List<ProjectItemDefinitionGroupElement>();
-            _usingTaskElements = new List<Pair<string, ProjectUsingTaskElement>>();
+            _usingTaskElements = new List<KeyValuePair<string, ProjectUsingTaskElement>>();
             _targetElements = new List<ProjectTargetElement>();
             _importsSeen = new Dictionary<string, ProjectImportElement>(StringComparer.OrdinalIgnoreCase);
             _initialTargetsList = new List<string>();
-            _projectSupportsReturnsAttribute = new Dictionary<ProjectRootElement, NGen<bool>>();
+            _projectSupportsReturnsAttribute = new Dictionary<ProjectRootElement, bool>();
             _projectRootElement = projectRootElement;
             _loadSettings = loadSettings;
             _maxNodeCount = maxNodeCount;
@@ -901,7 +901,7 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
                             break;
                         case ProjectTargetElement target:
                             // Defaults to false
-                            _projectSupportsReturnsAttribute.TryGetValue(currentProjectOrImport, out NGen<bool> projectSupportsReturnsAttribute);
+                            _projectSupportsReturnsAttribute.TryGetValue(currentProjectOrImport, out bool projectSupportsReturnsAttribute);
 
                             _projectSupportsReturnsAttribute[currentProjectOrImport] = projectSupportsReturnsAttribute || (target.Returns != null);
                             _targetElements.Add(target);
@@ -913,7 +913,7 @@ private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport)
                             EvaluateImportGroupElement(currentProjectOrImport.DirectoryPath, importGroup);
                             break;
                         case ProjectUsingTaskElement usingTask:
-                            _usingTaskElements.Add(new Pair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
+                            _usingTaskElements.Add(new KeyValuePair<string, ProjectUsingTaskElement>(currentProjectOrImport.DirectoryPath, usingTask));
                             break;
                         case ProjectChooseElement choose:
                             EvaluateChooseElement(choose);
@@ -2536,7 +2536,16 @@ private void ThrowForImportedProjectWithSearchPathsNotFound(ProjectImportPathMat
                         importElement.Project.Replace(searchPathMatch.MsBuildPropertyFormat, extensionsPathPropValue),
                         ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
 
-                relativeProjectPath = FileUtilities.MakeRelative(extensionsPathPropValue, importExpandedWithDefaultPath);
+                try
+                {
+                    relativeProjectPath = FileUtilities.MakeRelative(extensionsPathPropValue, importExpandedWithDefaultPath);
+                }
+                catch (ArgumentException ex)
+                {
+                    // https://github.com/dotnet/msbuild/issues/8762 .Catch the exceptions when extensionsPathPropValue is null or importExpandedWithDefaultPath is empty. In NET Framework, Path.* function also throws exceptions if the path contains invalid characters.
+                    ProjectErrorUtilities.ThrowInvalidProject(importElement.Location, "InvalidAttributeValueWithException", importExpandedWithDefaultPath, XMakeAttributes.project, XMakeElements.import, ex.Message);
+                    return;
+                }
             }
             else
             {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 6e812c58767..c998910190e 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -616,7 +616,7 @@ internal bool ExpandExpressionCapture(
             ExpanderOptions options,
             bool includeNullEntries,
             out bool isTransformExpression,
-            out List<Pair<string, I>> itemsFromCapture)
+            out List<KeyValuePair<string, I>> itemsFromCapture)
         {
             return ItemExpander.ExpandExpressionCapture(this, expressionCapture, _items, elementLocation, options, includeNullEntries, out isTransformExpression, out itemsFromCapture);
         }
@@ -1055,7 +1055,7 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
                             _metadata is IItemTypeDefinition itemMetadata &&
                             (string.IsNullOrEmpty(itemType) || string.Equals(itemType, itemMetadata.ItemType, StringComparison.Ordinal)))
                         {
-                            _loggingContext.LogComment(MessageImportance.High, new BuildEventFileInfo(_elementLocation),
+                            _loggingContext.LogComment(MessageImportance.Low, new BuildEventFileInfo(_elementLocation),
                                 "ItemReferencingSelfInTarget", itemMetadata.ItemType, metadataName);
                         }
 
@@ -1742,7 +1742,7 @@ private static class ItemExpander
             /// Execute the list of transform functions.
             /// </summary>
             /// <typeparam name="S">class, IItem.</typeparam>
-            internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expander, bool includeNullEntries, Stack<TransformFunction<S>> transformFunctionStack, IEnumerable<Pair<string, S>> itemsOfType)
+            internal static IEnumerable<KeyValuePair<string, S>> Transform<S>(Expander<P, I> expander, bool includeNullEntries, Stack<TransformFunction<S>> transformFunctionStack, IEnumerable<KeyValuePair<string, S>> itemsOfType)
                 where S : class, IItem
             {
                 // If we have transforms on our stack, then we'll execute those first
@@ -1751,7 +1751,7 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
                 {
                     TransformFunction<S> function = transformFunctionStack.Pop();
 
-                    foreach (Pair<string, S> item in Transform(expander, includeNullEntries, transformFunctionStack, function.Execute(expander, includeNullEntries, itemsOfType)))
+                    foreach (KeyValuePair<string, S> item in Transform(expander, includeNullEntries, transformFunctionStack, function.Execute(expander, includeNullEntries, itemsOfType)))
                     {
                         yield return item;
                     }
@@ -1760,7 +1760,7 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
                 {
                     // When we have no more tranforms on the stack, iterate over the items
                     // that we have to return them
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         yield return item;
                     }
@@ -1893,7 +1893,7 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
                     return result;
                 }
 
-                List<Pair<string, S>> itemsFromCapture;
+                List<KeyValuePair<string, S>> itemsFromCapture;
                 brokeEarlyNonEmpty = ExpandExpressionCapture(expander, expressionCapture, items, elementLocation /* including null items */, options, true, out isTransformExpression, out itemsFromCapture);
 
                 if (brokeEarlyNonEmpty)
@@ -1959,7 +1959,7 @@ internal static bool ExpandExpressionCapture<S>(
                 ExpanderOptions options,
                 bool includeNullEntries,
                 out bool isTransformExpression,
-                out List<Pair<string, S>> itemsFromCapture)
+                out List<KeyValuePair<string, S>> itemsFromCapture)
                 where S : class, IItem
             {
                 ErrorUtilities.VerifyThrow(evaluatedItems != null, "Cannot expand items without providing items");
@@ -1980,7 +1980,7 @@ internal static bool ExpandExpressionCapture<S>(
                         if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) ||
                             expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "AnyHaveMetadataValue", StringComparison.OrdinalIgnoreCase)) != true)
                         {
-                            itemsFromCapture = new List<Pair<string, S>>();
+                            itemsFromCapture = new List<KeyValuePair<string, S>>();
                             return false;
                         }
                     }
@@ -1991,7 +1991,7 @@ internal static bool ExpandExpressionCapture<S>(
                     isTransformExpression = true;
                 }
 
-                itemsFromCapture = new List<Pair<string, S>>(itemsOfType.Count);
+                itemsFromCapture = new List<KeyValuePair<string, S>>(itemsOfType.Count);
 
                 if (!isTransformExpression)
                 {
@@ -2003,7 +2003,7 @@ internal static bool ExpandExpressionCapture<S>(
                             return true;
                         }
 
-                        itemsFromCapture.Add(new Pair<string, S>(item.EvaluatedIncludeEscaped, item));
+                        itemsFromCapture.Add(new KeyValuePair<string, S>(item.EvaluatedIncludeEscaped, item));
                     }
                 }
                 else
@@ -2011,7 +2011,7 @@ internal static bool ExpandExpressionCapture<S>(
                     Stack<TransformFunction<S>> transformFunctionStack = PrepareTransformStackFromMatch<S>(elementLocation, expressionCapture);
 
                     // iterate over the tranform chain, creating the final items from its results
-                    foreach (Pair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
+                    foreach (KeyValuePair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
                     {
                         if (!string.IsNullOrEmpty(itemTuple.Key) && (options & ExpanderOptions.BreakOnNotEmpty) != 0)
                         {
@@ -2026,7 +2026,7 @@ internal static bool ExpandExpressionCapture<S>(
                 {
                     var joinedItems = string.Join(expressionCapture.Separator, itemsFromCapture.Select(i => i.Key));
                     itemsFromCapture.Clear();
-                    itemsFromCapture.Add(new Pair<string, S>(joinedItems, null));
+                    itemsFromCapture.Add(new KeyValuePair<string, S>(joinedItems, null));
                 }
 
                 return false; // did not break early
@@ -2144,7 +2144,7 @@ private static bool ExpandExpressionCaptureIntoStringBuilder<S>(
                 ExpanderOptions options)
                 where S : class, IItem
             {
-                List<Pair<string, S>> itemsFromCapture;
+                List<KeyValuePair<string, S>> itemsFromCapture;
                 bool throwaway;
                 var brokeEarlyNonEmpty = ExpandExpressionCapture(expander, capture, evaluatedItems, elementLocation /* including null items */, options, true, out throwaway, out itemsFromCapture);
 
@@ -2205,7 +2205,7 @@ internal static class IntrinsicItemFunctions<S>
                 /// Delegate that represents the signature of all item transformation functions
                 /// This is used to support calling the functions by name.
                 /// </summary>
-                public delegate IEnumerable<Pair<string, S>> ItemTransformFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments);
+                public delegate IEnumerable<KeyValuePair<string, S>> ItemTransformFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments);
 
                 /// <summary>
                 /// Get a delegate to the given item transformation function by supplying the name and the
@@ -2268,7 +2268,7 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation
                 /// Create an enumerator from a base IEnumerable of items into an enumerable
                 /// of transformation result which includes the new itemspec and the base item.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
+                internal static IEnumerable<KeyValuePair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
                 {
                     // iterate over the items, and yield out items in the tuple format
                     foreach (var item in itemsOfType)
@@ -2281,12 +2281,12 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                                     item.EvaluatedIncludeEscaped,
                                     forceEvaluate: true))
                             {
-                                yield return new Pair<string, S>(resultantItem, item);
+                                yield return new KeyValuePair<string, S>(resultantItem, item);
                             }
                         }
                         else
                         {
-                            yield return new Pair<string, S>(item.EvaluatedIncludeEscaped, item);
+                            yield return new KeyValuePair<string, S>(item.EvaluatedIncludeEscaped, item);
                         }
                     }
                 }
@@ -2294,20 +2294,20 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                 /// <summary>
                 /// Intrinsic function that returns the number of items in the list.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
-                    yield return new Pair<string, S>(Convert.ToString(itemsOfType.Count(), CultureInfo.InvariantCulture), null /* no base item */);
+                    yield return new KeyValuePair<string, S>(Convert.ToString(itemsOfType.Count(), CultureInfo.InvariantCulture), null /* no base item */);
                 }
 
                 /// <summary>
                 /// Intrinsic function that returns the specified built-in modifer value of the items in itemsOfType
                 /// Tuple is {current item include, item under transformation}.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         // If the item include has become empty,
                         // this is the end of the pipeline for this item
@@ -2339,11 +2339,11 @@ internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P
                         {
                             // GetItemSpecModifier will have returned us an escaped string
                             // there is nothing more to do than yield it into the pipeline
-                            yield return new Pair<string, S>(result, item.Value);
+                            yield return new KeyValuePair<string, S>(result, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2351,11 +2351,11 @@ internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P
                 /// <summary>
                 /// Intrinsic function that returns the subset of items that actually exist on disk.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Exists(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (String.IsNullOrEmpty(item.Key))
                         {
@@ -2398,13 +2398,13 @@ internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IEl
                 /// <summary>
                 /// Intrinsic function that combines the existing paths of the input items with a given relative path.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Combine(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string relativePath = arguments[0];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (String.IsNullOrEmpty(item.Key))
                         {
@@ -2415,14 +2415,14 @@ internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IE
                         string unescapedPath = EscapingUtilities.UnescapeAll(item.Key);
                         string combinedPath = Path.Combine(unescapedPath, relativePath);
                         string escapedPath = EscapingUtilities.Escape(combinedPath);
-                        yield return new Pair<string, S>(escapedPath, null);
+                        yield return new KeyValuePair<string, S>(escapedPath, null);
                     }
                 }
 
                 /// <summary>
                 /// Intrinsic function that returns all ancestor directories of the given items.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> GetPathsOfAllDirectoriesAbove(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
@@ -2430,7 +2430,7 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
 
                     SortedSet<string> directories = new SortedSet<string>(StringComparer.OrdinalIgnoreCase);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (String.IsNullOrEmpty(item.Key))
                         {
@@ -2490,7 +2490,7 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
                     foreach (string directoryPath in directories)
                     {
                         string escapedDirectoryPath = EscapingUtilities.Escape(directoryPath);
-                        yield return new Pair<string, S>(escapedDirectoryPath, null);
+                        yield return new KeyValuePair<string, S>(escapedDirectoryPath, null);
                     }
                 }
 
@@ -2498,13 +2498,13 @@ internal static IEnumerable<Pair<string, S>> GetPathsOfAllDirectoriesAbove(Expan
                 /// Intrinsic function that returns the DirectoryName of the items in itemsOfType
                 /// UNDONE: This can be removed in favor of a built-in %(DirectoryName) metadata in future.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> DirectoryName(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     Dictionary<string, string> directoryNameTable = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         // If the item include has become empty,
                         // this is the end of the pipeline for this item
@@ -2553,11 +2553,11 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                         if (!String.IsNullOrEmpty(directoryName))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(directoryName, item.Value);
+                            yield return new KeyValuePair<string, S>(directoryName, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2565,13 +2565,13 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                 /// <summary>
                 /// Intrinsic function that returns the contents of the metadata in specified in argument[0].
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (item.Value != null)
                         {
@@ -2598,18 +2598,18 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
                                     foreach (string itemSpec in splits)
                                     {
                                         // return a result through the enumerator
-                                        yield return new Pair<string, S>(itemSpec, item.Value);
+                                        yield return new KeyValuePair<string, S>(itemSpec, item.Value);
                                     }
                                 }
                                 else
                                 {
                                     // return a result through the enumerator
-                                    yield return new Pair<string, S>(metadataValue, item.Value);
+                                    yield return new KeyValuePair<string, S>(metadataValue, item.Value);
                                 }
                             }
                             else if (metadataValue != String.Empty && includeNullEntries)
                             {
-                                yield return new Pair<string, S>(metadataValue, item.Value);
+                                yield return new KeyValuePair<string, S>(metadataValue, item.Value);
                             }
                         }
                     }
@@ -2619,7 +2619,7 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
                 /// Using a case sensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> DistinctWithCase(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     return DistinctWithComparer(expander, elementLocation, includeNullEntries, functionName, itemsOfType, arguments, StringComparer.Ordinal);
                 }
@@ -2628,7 +2628,7 @@ internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> exp
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Distinct(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     return DistinctWithComparer(expander, elementLocation, includeNullEntries, functionName, itemsOfType, arguments, StringComparer.OrdinalIgnoreCase);
                 }
@@ -2637,20 +2637,18 @@ internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, I
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
+                internal static IEnumerable<KeyValuePair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     // This dictionary will ensure that we only return one result per unique itemspec
-                    Dictionary<string, S> seenItems = new Dictionary<string, S>(comparer);
+                    HashSet<string> seenItems = new HashSet<string>(comparer);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
-                        if (item.Key != null && !seenItems.ContainsKey(item.Key))
+                        if (item.Key != null && seenItems.Add(item.Key))
                         {
-                            seenItems[item.Key] = item.Value;
-
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2658,23 +2656,20 @@ internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I>
                 /// <summary>
                 /// Intrinsic function reverses the item list.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> Reverse(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
-                    foreach (Pair<String, S> item in itemsOfType.Reverse())
-                    {
-                        yield return new Pair<string, S>(item.Key, item.Value);
-                    }
+                    return itemsOfType.Reverse();
                 }
 
                 /// <summary>
                 /// Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)').
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         MetadataMatchEvaluator matchEvaluator;
                         string include = null;
@@ -2697,11 +2692,11 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                         // We pass in the existing item so we can copy over its metadata
                         if (!string.IsNullOrEmpty(include))
                         {
-                            yield return new Pair<string, S>(include, item.Value);
+                            yield return new KeyValuePair<string, S>(include, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2710,17 +2705,17 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                 /// Intrinsic function that transforms expressions by invoking methods of System.String on the itemspec
                 /// of the item in the pipeline.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
+                internal static IEnumerable<KeyValuePair<string, S>> ExecuteStringFunction(
                     Expander<P, I> expander,
                     IElementLocation elementLocation,
                     bool includeNullEntries,
                     string functionName,
-                    IEnumerable<Pair<string, S>> itemsOfType,
+                    IEnumerable<KeyValuePair<string, S>> itemsOfType,
                     string[] arguments)
                 {
                     // Transform: expression is like @(Compile->'%(foo)'), so create completely new items,
                     // using the Include from the source items
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         Function<P> function = new Function<P>(
                             typeof(string),
@@ -2740,11 +2735,11 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                         // We pass in the existing item so we can copy over its metadata
                         if (include.Length > 0)
                         {
-                            yield return new Pair<string, S>(include, item.Value);
+                            yield return new KeyValuePair<string, S>(include, item.Value);
                         }
                         else if (includeNullEntries)
                         {
-                            yield return new Pair<string, S>(null, item.Value);
+                            yield return new KeyValuePair<string, S>(null, item.Value);
                         }
                     }
                 }
@@ -2752,15 +2747,15 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                 /// <summary>
                 /// Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments == null || arguments.Length == 0, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (includeNullEntries || item.Key != null)
                         {
-                            yield return new Pair<string, S>(item.Key, null);
+                            yield return new KeyValuePair<string, S>(item.Key, null);
                         }
                     }
                 }
@@ -2769,13 +2764,13 @@ internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expand
                 /// Intrinsic function that returns only those items that have a not-blank value for the metadata specified
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         string metadataValue = null;
 
@@ -2794,7 +2789,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                         if (!string.IsNullOrEmpty(metadataValue))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2803,14 +2798,14 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                 /// Intrinsic function that returns only those items have the given metadata value
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         string metadataValue = null;
 
@@ -2827,7 +2822,7 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                         if (metadataValue != null && String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2836,14 +2831,14 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                 /// Intrinsic function that returns those items don't have the given metadata value
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> WithoutMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         string metadataValue = null;
 
@@ -2860,7 +2855,7 @@ internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I>
                         if (!String.Equals(metadataValue, metadataValueToFind, StringComparison.OrdinalIgnoreCase))
                         {
                             // return a result through the enumerator
-                            yield return new Pair<string, S>(item.Key, item.Value);
+                            yield return item;
                         }
                     }
                 }
@@ -2869,7 +2864,7 @@ internal static IEnumerable<Pair<string, S>> WithoutMetadataValue(Expander<P, I>
                 /// Intrinsic function that returns a boolean to indicate if any of the items have the given metadata value
                 /// Using a case insensitive comparison.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
+                internal static IEnumerable<KeyValuePair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<KeyValuePair<string, S>> itemsOfType, string[] arguments)
                 {
                     ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, arguments == null ? 0 : arguments.Length);
 
@@ -2877,7 +2872,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                     string metadataValueToFind = arguments[1];
                     bool metadataFound = false;
 
-                    foreach (Pair<string, S> item in itemsOfType)
+                    foreach (KeyValuePair<string, S> item in itemsOfType)
                     {
                         if (item.Value != null)
                         {
@@ -2898,7 +2893,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                                 metadataFound = true;
 
                                 // return a result through the enumerator
-                                yield return new Pair<string, S>("true", item.Value);
+                                yield return new KeyValuePair<string, S>("true", item.Value);
 
                                 // break out as soon as we found a match
                                 yield break;
@@ -2909,7 +2904,7 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
                     if (!metadataFound)
                     {
                         // We did not locate an item with the required metadata
-                        yield return new Pair<string, S>("false", null);
+                        yield return new KeyValuePair<string, S>("false", null);
                     }
                 }
             }
@@ -2971,7 +2966,7 @@ public IElementLocation ElementLocation
                 /// <summary>
                 /// Execute this transform function with the arguments contained within this TransformFunction instance.
                 /// </summary>
-                public IEnumerable<Pair<string, S>> Execute(Expander<P, I> expander, bool includeNullEntries, IEnumerable<Pair<string, S>> itemsOfType)
+                public IEnumerable<KeyValuePair<string, S>> Execute(Expander<P, I> expander, bool includeNullEntries, IEnumerable<KeyValuePair<string, S>> itemsOfType)
                 {
                     // Execute via the delegate
                     return _transform(expander, _elementLocation, includeNullEntries, _functionName, itemsOfType, _arguments);
diff --git a/src/Build/Evaluation/IItemFactory.cs b/src/Build/Evaluation/IItemFactory.cs
index 2125968bf6c..986386cd7a0 100644
--- a/src/Build/Evaluation/IItemFactory.cs
+++ b/src/Build/Evaluation/IItemFactory.cs
@@ -68,6 +68,6 @@ ProjectItemElement ItemElement
         /// <summary>
         /// Applies the supplied metadata to the destination items.
         /// </summary>
-        void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<T> destinationItems);
+        void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<T> destinationItems);
     }
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs b/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
index 722d467c342..99c7166189b 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
@@ -75,7 +75,7 @@ public I CreateItem(string include, I baseItem, string definingProject)
                 return _wrappedItemFactory.CreateItem(include, baseItem, definingProject);
             }
 
-            public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<I> destinationItems)
+            public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<I> destinationItems)
             {
                 SetItemElement();
                 _wrappedItemFactory.SetMetadata(metadata, destinationItems);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 43fffb961a6..fe8b1805bab 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -230,7 +230,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                         _expander.Metadata = metadataTable;
 
                         // Also keep a list of everything so we can get the predecessor objects correct.
-                        List<Pair<ProjectMetadataElement, string>> metadataList = new(metadata.Length);
+                        List<KeyValuePair<ProjectMetadataElement, string>> metadataList = new(metadata.Length);
 
                         foreach (var metadataElement in metadata)
                         {
@@ -252,7 +252,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
-                            metadataList.Add(new Pair<ProjectMetadataElement, string>(metadataElement, evaluatedValue));
+                            metadataList.Add(new KeyValuePair<ProjectMetadataElement, string>(metadataElement, evaluatedValue));
                         }
 
                         // Apply those metadata to each item
diff --git a/src/Build/FileAccess/DesiredAccess.cs b/src/Build/FileAccess/DesiredAccess.cs
new file mode 100644
index 00000000000..b9bdea98c0f
--- /dev/null
+++ b/src/Build/FileAccess/DesiredAccess.cs
@@ -0,0 +1,112 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.DesiredAccess.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// The requested access to the file or device.
+    /// </summary>
+    /// <remarks>
+    /// See https://learn.microsoft.com/en-us/windows/win32/fileio/file-access-rights-constants for a full list of values.
+    /// </remarks>
+    [Flags]
+    [CLSCompliant(false)]
+    public enum DesiredAccess : uint
+    {
+        /// <summary>
+        /// For a directory, the right to list the contents of the directory.
+        /// </summary>
+        FILE_LIST_DIRECTORY = 0x00000001,
+
+        /// <summary>
+        /// For a directory, the right to create a file in the directory.
+        /// </summary>
+        FILE_ADD_FILE = 0x00000002,
+
+        /// <summary>
+        /// For a directory, the right to create a subdirectory.
+        /// </summary>
+        FILE_ADD_SUBDIRECTORY = 0x00000004,
+
+        /// <summary>
+        /// The right to read extended file attributes.
+        /// </summary>
+        FILE_READ_EA = 0x00000008,
+
+        /// <summary>
+        /// Right to delete an object.
+        /// </summary>
+        DELETE = 0x00010000,
+
+        /// <summary>
+        /// Right to wait on a handle.
+        /// </summary>
+        SYNCHRONIZE = 0x00100000,
+
+        /// <summary>
+        /// For a file object, the right to append data to the file. (For local files, write operations will not overwrite existing
+        /// data if this flag is specified without <see cref="FILE_WRITE_DATA"/>.) For a directory object, the right to create a subdirectory
+        /// (<see cref="FILE_ADD_SUBDIRECTORY"/>).
+        /// </summary>
+        FILE_APPEND_DATA = 0x00000004,
+
+        /// <summary>
+        /// The right to write extended file attributes.
+        /// </summary>
+        FILE_WRITE_EA = 0x00000010,
+
+        /// <summary>
+        /// For a native code file, the right to execute the file. This access right given to scripts may cause the script to be executable, depending on the script interpreter.
+        /// </summary>
+        FILE_EXECUTE = 0x00000020,
+
+        /// <summary>
+        /// For a directory, the right to delete a directory and all the files it contains, including read-only files.
+        /// </summary>
+        FILE_DELETE_CHILD = 0x00000040,
+
+        /// <summary>
+        /// The right to read file attributes.
+        /// </summary>
+        FILE_READ_ATTRIBUTES = 0x00000080,
+
+        /// <summary>
+        /// The right to write file attributes.
+        /// </summary>
+        FILE_WRITE_ATTRIBUTES = 0x00000100,
+
+        /// <summary>
+        /// For a file object, the right to write data to the file. For a directory object, the right to create a file in the
+        /// directory (<see cref="FILE_ADD_FILE"/>).
+        /// </summary>
+        FILE_WRITE_DATA = 0x00000002,
+
+        /// <summary>
+        /// All possible access rights.
+        /// </summary>
+        GENERIC_ALL = 0x10000000,
+
+        /// <summary>
+        /// Execute access.
+        /// </summary>
+        GENERIC_EXECUTE = 0x20000000,
+
+        /// <summary>
+        /// Write access.
+        /// </summary>
+        GENERIC_WRITE = 0x40000000,
+
+        /// <summary>
+        /// Read access.
+        /// </summary>
+        GENERIC_READ = 0x80000000,
+    }
+}
diff --git a/src/Build/FileAccess/FileAccessData.cs b/src/Build/FileAccess/FileAccessData.cs
new file mode 100644
index 00000000000..64cd45a92d4
--- /dev/null
+++ b/src/Build/FileAccess/FileAccessData.cs
@@ -0,0 +1,125 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /// <summary>
+    /// File access data.
+    /// </summary>
+    [CLSCompliant(false)]
+    public struct FileAccessData
+        : ITranslatable
+    {
+        private ReportedFileOperation _operation;
+        private RequestedAccess _requestedAccess;
+        private uint _processId;
+        private uint _error;
+        private DesiredAccess _desiredAccess;
+        private FlagsAndAttributes _flagsAndAttributes;
+        private string _path;
+        private string? _processArgs;
+        private bool _isAnAugmentedFileAccess;
+
+        public FileAccessData(
+            ReportedFileOperation operation,
+            RequestedAccess requestedAccess,
+            uint processId,
+            uint error,
+            DesiredAccess desiredAccess,
+            FlagsAndAttributes flagsAndAttributes,
+            string path,
+            string? processArgs,
+            bool isAnAugmentedFileAccess)
+        {
+            _operation = operation;
+            _requestedAccess = requestedAccess;
+            _processId = processId;
+            _error = error;
+            _desiredAccess = desiredAccess;
+            _flagsAndAttributes = flagsAndAttributes;
+            _path = path;
+            _processArgs = processArgs;
+            _isAnAugmentedFileAccess = isAnAugmentedFileAccess;
+        }
+
+        /// <summary>The operation that performed the file access.</summary>
+        public ReportedFileOperation Operation
+        {
+            readonly get => _operation;
+            private set => _operation = value;
+        }
+
+        /// <summary>The requested access.</summary>
+        public RequestedAccess RequestedAccess
+        {
+            get => _requestedAccess;
+            private set => _requestedAccess = value;
+        }
+
+        /// <summary>The process id.</summary>
+        public uint ProcessId
+        {
+            readonly get => _processId;
+            private set => _processId = value;
+        }
+
+        /// <summary>The error code of the operation.</summary>
+        public uint Error
+        {
+            readonly get => _error;
+            private set => _error = value;
+        }
+
+        /// <summary>The desired access.</summary>
+        public DesiredAccess DesiredAccess
+        {
+            readonly get => _desiredAccess;
+            private set => _desiredAccess = value;
+        }
+
+        /// <summary>The file flags and attributes.</summary>
+        public FlagsAndAttributes FlagsAndAttributes
+        {
+            readonly get => _flagsAndAttributes;
+            private set => _flagsAndAttributes = value;
+        }
+
+        /// <summary>The path being accessed.</summary>
+        public string Path
+        {
+            readonly get => _path;
+            private set => _path = value;
+        }
+
+        /// <summary>The process arguments.</summary>
+        public string? ProcessArgs
+        {
+            readonly get => _processArgs;
+            private set => _processArgs = value;
+        }
+
+        /// <summary>Whether the file access is augmented.</summary>
+        public bool IsAnAugmentedFileAccess
+        {
+            readonly get => _isAnAugmentedFileAccess;
+            private set => _isAnAugmentedFileAccess = value;
+        }
+
+        void ITranslatable.Translate(ITranslator translator)
+        {
+            translator.TranslateEnum(ref _operation, (int)_operation);
+            translator.TranslateEnum(ref _requestedAccess, (int)_requestedAccess);
+            translator.Translate(ref _processId);
+            translator.Translate(ref _error);
+            translator.TranslateEnum(ref _desiredAccess, (int)_desiredAccess);
+            translator.TranslateEnum(ref _flagsAndAttributes, (int)_flagsAndAttributes);
+            translator.Translate(ref _path);
+            translator.Translate(ref _processArgs);
+            translator.Translate(ref _isAnAugmentedFileAccess);
+        }
+    }
+}
diff --git a/src/Build/FileAccess/FlagsAndAttributes.cs b/src/Build/FileAccess/FlagsAndAttributes.cs
new file mode 100644
index 00000000000..c02ca45a969
--- /dev/null
+++ b/src/Build/FileAccess/FlagsAndAttributes.cs
@@ -0,0 +1,185 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.FlagsAndAttributes.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// The file or device attributes and flags.
+    /// </summary>
+    [Flags]
+    [CLSCompliant(false)]
+    public enum FlagsAndAttributes : uint
+    {
+        /// <summary>
+        /// The file is read only. Applications can read the file but cannot write to or delete it.
+        /// </summary>
+        FILE_ATTRIBUTE_READONLY = 0x00000001,
+
+        /// <summary>
+        /// The file is hidden. Do not include it in an ordinary directory listing.
+        /// </summary>
+        FILE_ATTRIBUTE_HIDDEN = 0x00000002,
+
+        /// <summary>
+        /// The file is part of or used exclusively by an operating system.
+        /// </summary>
+        FILE_ATTRIBUTE_SYSTEM = 0x00000004,
+
+        /// <summary>
+        /// The path is a directory.
+        /// </summary>
+        FILE_ATTRIBUTE_DIRECTORY = 0x00000010,
+
+        /// <summary>
+        /// The file should be archived. Applications use this attribute to mark files for backup or removal.
+        /// </summary>
+        FILE_ATTRIBUTE_ARCHIVE = 0x00000020,
+
+        /// <summary>
+        /// The file does not have other attributes set. This attribute is valid only if used alone.
+        /// </summary>
+        FILE_ATTRIBUTE_NORMAL = 0x00000080,
+
+        /// <summary>
+        /// The file is being used for temporary storage.
+        /// </summary>
+        /// <remarks>
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_ATTRIBUTE_TEMPORARY = 0x00000100,
+
+        /// <summary>
+        /// The data of a file is not immediately available. This attribute indicates that file data is physically moved to offline
+        /// storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should
+        /// not arbitrarily change this attribute.
+        /// </summary>
+        FILE_ATTRIBUTE_OFFLINE = 0x00001000,
+
+        /// <summary>
+        /// The file or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory,
+        /// this means that encryption is the default for newly created files and subdirectories. For more information, see File
+        /// Encryption.
+        /// </summary>
+        /// <remarks>
+        /// This flag has no effect if <see cref="FILE_ATTRIBUTE_SYSTEM"/> is also specified.
+        /// This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
+        /// </remarks>
+        FILE_ATTRIBUTE_ENCRYPED = 0x00004000,
+
+        /// <summary>
+        /// The file data is requested, but it should continue to be located in remote storage. It should not be transported back
+        /// to local storage. This flag is for use by remote storage systems.
+        /// </summary>
+        FILE_FLAG_OPEN_NO_RECALL = 0x00100000,
+
+        /// <summary>
+        /// Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point. When a file is
+        /// opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
+        /// </summary>
+        /// <remarks>
+        /// This flag cannot be used with the CREATE_ALWAYS flag.
+        /// If the file is not a reparse point, then this flag is ignored.
+        /// For more information, see the Remarks section.
+        /// </remarks>
+        FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000,
+
+        /// <summary>
+        /// The file or device is being opened with session awareness. If this flag is not specified, then per-session devices
+        /// (such as a redirected USB device) cannot be opened by processes running in session 0. This flag has no effect for
+        /// callers not in session 0. This flag is supported only on server editions of Windows.
+        /// </summary>
+        /// <remarks>
+        /// Windows Server 2008 R2, Windows Server 2008, and Windows Server 2003: This flag is not supported before Windows Server
+        /// 2012.
+        /// </remarks>
+        FILE_FLAG_SESSION_AWARE = 0x00800000,
+
+        /// <summary>
+        /// Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only in case,
+        /// for file systems that support that naming. Use care when using this option, because files created with this flag may
+        /// not be accessible by applications that are written for MS-DOS or 16-bit Windows.
+        /// </summary>
+        FILE_FLAG_POSIX_SEMANTICS = 0x01000000,
+
+        /// <summary>
+        /// The file is being opened or created for a backup or restore operation. The system ensures that the calling process
+        /// overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more
+        /// information, see Changing Privileges in a Token.
+        /// </summary>
+        /// <remarks>
+        /// You must set this flag to obtain a handle to a directory. A directory handle can be passed to some functions instead of
+        /// a file handle. For more information, see the Remarks section.
+        /// </remarks>
+        FILE_FLAG_BACKUP_SEMANTICS = 0x02000000,
+
+        /// <summary>
+        /// The file is to be deleted immediately after all of its handles are closed, which includes the specified handle and any
+        /// other open or duplicated handles.
+        /// </summary>
+        /// <remarks>
+        /// If there are existing open handles to a file, the call fails unless they were all opened with the FILE_SHARE_DELETE
+        /// share mode.
+        /// Subsequent open requests for the file fail, unless the FILE_SHARE_DELETE share mode is specified.
+        /// </remarks>
+        FILE_FLAG_DELETE_ON_CLOSE = 0x04000000,
+
+        /// <summary>
+        /// Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file caching.
+        /// </summary>
+        /// <remarks>
+        /// This flag should not be used if read-behind (that is, reverse scans) will be used.
+        /// This flag has no effect if the file system does not support cached I/O and <see cref="FILE_FLAG_NO_BUFFERING"/> .
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000,
+
+        /// <summary>
+        /// Access is intended to be random. The system can use this as a hint to optimize file caching.
+        /// </summary>
+        /// <remarks>
+        /// This flag has no effect if the file system does not support cached I/O and <see cref="FILE_FLAG_NO_BUFFERING"/>.
+        /// For more information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_RANDOM_ACCESS = 0x10000000,
+
+        /// <summary>
+        /// The file or device is being opened with no system caching for data reads and writes. This flag does not affect hard
+        /// disk caching or memory mapped files.
+        /// </summary>
+        /// <remarks>
+        /// There are strict requirements for successfully working with files opened with CreateFile using this
+        /// flag; for details, see File Buffering.
+        /// </remarks>
+        FILE_FLAG_NO_BUFFERING = 0x20000000,
+
+        /// <summary>
+        /// The file or device is being opened or created for asynchronous I/O.
+        /// </summary>
+        /// <remarks>
+        /// When subsequent I/O operations are completed on this handle, the event specified in the OVERLAPPED structure will be
+        /// set to the signaled state.
+        /// If this flag is specified, the file can be used for simultaneous read and write operations.
+        /// If this flag is not specified, then I/O operations are serialized, even if the calls to the read and write functions
+        /// specify an OVERLAPPED structure.
+        /// For information about considerations when using a file handle created with this flag, see the Synchronous and
+        /// Asynchronous I/O Handles section of this topic.
+        /// </remarks>
+        FILE_FLAG_OVERLAPPED = 0x40000000,
+
+        /// <summary>
+        /// Write operations will not go through any intermediate cache; they will go directly to disk.
+        /// </summary>
+        /// <remarks>
+        /// For additional information, see the Caching Behavior section of this topic.
+        /// </remarks>
+        FILE_FLAG_WRITE_THROUGH = 0x80000000,
+    }
+}
diff --git a/src/Build/FileAccess/ProcessData.cs b/src/Build/FileAccess/ProcessData.cs
new file mode 100644
index 00000000000..aa274054545
--- /dev/null
+++ b/src/Build/FileAccess/ProcessData.cs
@@ -0,0 +1,85 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /// <summary>
+    /// Process data.
+    /// </summary>
+    [CLSCompliant(false)]
+    public struct ProcessData : ITranslatable
+    {
+        private string _processName;
+        private uint _processId;
+        private uint _parentProcessId;
+        private DateTime _creationDateTime;
+        private DateTime _exitDateTime;
+        private uint _exitCode;
+
+        public ProcessData(string processName, uint processId, uint parentProcessId, DateTime creationDateTime, DateTime exitDateTime, uint exitCode)
+        {
+            _processName = processName;
+            _processId = processId;
+            _parentProcessId = parentProcessId;
+            _creationDateTime = creationDateTime;
+            _exitDateTime = exitDateTime;
+            _exitCode = exitCode;
+        }
+
+        /// <summary>The process name.</summary>
+        public string ProcessName
+        {
+            get => _processName;
+            private set => _processName = value;
+        }
+
+        /// <summary>The process id.</summary>
+        public uint ProcessId
+        {
+            get => _processId;
+            private set => _processId = value;
+        }
+
+        /// <summary>The parent process id.</summary>
+        public uint ParentProcessId
+        {
+            get => _parentProcessId;
+            private set => _parentProcessId = value;
+        }
+
+        /// <summary>The creation date time.</summary>
+        public DateTime CreationDateTime
+        {
+            get => _creationDateTime;
+            private set => _creationDateTime = value;
+        }
+
+        /// <summary>The exit date time.</summary>
+        public DateTime ExitDateTime
+        {
+            get => _exitDateTime;
+            private set => _exitDateTime = value;
+        }
+
+        /// <summary>The exit code.</summary>
+        public uint ExitCode
+        {
+            get => _exitCode;
+            private set => _exitCode = value;
+        }
+
+        void ITranslatable.Translate(ITranslator translator)
+        {
+            translator.Translate(ref _processName);
+            translator.Translate(ref _processId);
+            translator.Translate(ref _parentProcessId);
+            translator.Translate(ref _creationDateTime);
+            translator.Translate(ref _exitDateTime);
+            translator.Translate(ref _exitCode);
+        }
+    }
+}
diff --git a/src/Build/FileAccess/ReportedFileOperation.cs b/src/Build/FileAccess/ReportedFileOperation.cs
new file mode 100644
index 00000000000..c3b846cedde
--- /dev/null
+++ b/src/Build/FileAccess/ReportedFileOperation.cs
@@ -0,0 +1,263 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.ReportedFileOperation.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// Which operation resulted in a reported file access.
+    /// </summary>
+    public enum ReportedFileOperation : byte
+    {
+        /// <summary>
+        /// Unknown operation.
+        /// </summary>
+        Unknown = 0,
+
+        /// <summary>
+        /// CreateFile.
+        /// </summary>
+        CreateFile,
+
+        /// <summary>
+        /// CreateProcess.
+        /// </summary>
+        CreateProcess,
+
+        /// <summary>
+        /// GetFileAttributes.
+        /// </summary>
+        GetFileAttributes,
+
+        /// <summary>
+        /// GetFileAttributesEx.
+        /// </summary>
+        GetFileAttributesEx,
+
+        /// <summary>
+        /// Process forked.
+        /// </summary>
+        Process,
+
+        /// <summary>
+        /// FindFirstFileEx.
+        /// </summary>
+        /// <remarks>
+        /// FindFirstFile also indicates this op, since we implement it in terms of FindFirstFileEx.
+        /// </remarks>
+        FindFirstFileEx,
+
+        /// <summary>
+        /// FindNextFile.
+        /// </summary>
+        FindNextFile,
+
+        /// <summary>
+        /// CreateDirectory.
+        /// </summary>
+        CreateDirectory,
+
+        /// <summary>
+        /// DeleteFile.
+        /// </summary>
+        DeleteFile,
+
+        /// <summary>
+        /// MoveFile (source; read and deleted).
+        /// </summary>
+        MoveFileSource,
+
+        /// <summary>
+        /// MoveFile (destination; written).
+        /// </summary>
+        MoveFileDestination,
+
+        /// <summary>
+        /// SetFileInformationByHandleSource (source; read and deleted).
+        /// </summary>
+        SetFileInformationByHandleSource,
+
+        /// <summary>
+        /// SetFileInformationByHandleDest (destination; written).
+        /// </summary>
+        SetFileInformationByHandleDest,
+
+        /// <summary>
+        /// ZwSetRenameInformationFileSource (source; read and deleted).
+        /// </summary>
+        ZwSetRenameInformationFileSource,
+
+        /// <summary>
+        /// ZwSetRenameInformationFileDest (destination; written).
+        /// </summary>
+        ZwSetRenameInformationFileDest,
+
+        /// <summary>
+        /// ZwSetLinkInformationFileDest.
+        /// </summary>
+        ZwSetLinkInformationFile,
+
+        /// <summary>
+        /// ZwSetDispositionInformationFile (delete-on-close; deleted).
+        /// </summary>
+        ZwSetDispositionInformationFile,
+
+        /// <summary>
+        /// ZwSetModeInformationFile (delete-on-close; deleted).
+        /// </summary>
+        ZwSetModeInformationFile,
+
+        /// <summary>
+        /// ZwSetFileNameInformationFile (source; read and written).
+        /// </summary>
+        ZwSetFileNameInformationFileSource,
+
+        /// <summary>
+        /// ZwSetFileNameInformationFile (destination; written).
+        /// </summary>
+        ZwSetFileNameInformationFileDest,
+
+        /// <summary>
+        /// CopyFile (source; read).
+        /// </summary>
+        CopyFileSource,
+
+        /// <summary>
+        /// CopyFile (destination; written).
+        /// </summary>
+        CopyFileDestination,
+
+        /// <summary>
+        /// CreateHardLink (source; read).
+        /// </summary>
+        CreateHardLinkSource,
+
+        /// <summary>
+        /// CreateHardLink (destination; written).
+        /// </summary>
+        CreateHardLinkDestination,
+
+        /// <summary>
+        /// RemoveDirectory.
+        /// </summary>
+        RemoveDirectory,
+
+        /// <summary>
+        /// RemoveDirectory (source; written).
+        /// </summary>
+        RemoveDirectorySource,
+
+        /// <summary>
+        /// NtQueryDirectoryFile.
+        /// </summary>
+        NtQueryDirectoryFile,
+
+        /// <summary>
+        /// ZwQueryDirectoryFile.
+        /// </summary>
+        ZwQueryDirectoryFile,
+
+        /// <summary>
+        /// NtCreateFile.
+        /// </summary>
+        NtCreateFile,
+
+        /// <summary>
+        /// ZwCreateFile.
+        /// </summary>
+        ZwCreateFile,
+
+        /// <summary>
+        /// ZwOpenFile.
+        /// </summary>
+        ZwOpenFile,
+
+        /// <summary>
+        /// This is a quasi operation. We issue this
+        /// report when Detours is changing file open
+        /// request with Read/Write access to Read access only.
+        /// </summary>
+        ChangedReadWriteToReadAccess,
+
+        /// <summary>
+        /// This is a quasi operation. The sandbox issues this only when FileAccessPolicy.OverrideAllowWriteForExistingFiles is set, representing
+        /// that an allow for write check was performed for a given path for the first time (in the scope of a process, another process in the same process
+        /// tree may also report this for the same path).
+        /// </summary>
+        FirstAllowWriteCheckInProcess,
+
+        /// <summary>
+        /// This operation used to indicate to the engine by the Linux sandbox that a process being executed statically links libc
+        /// and may have missing file observations.
+        /// </summary>
+        StaticallyLinkedProcess,
+
+        /// <summary>
+        /// Access of reparse point target.
+        /// </summary>
+        ReparsePointTarget,
+
+        /// <summary>
+        /// Access of reparse point target, cached by Detours.
+        /// </summary>
+        ReparsePointTargetCached,
+
+        /// <summary>
+        /// Access checks for source of CreateSymbolicLink API.
+        /// </summary>
+        CreateSymbolicLinkSource,
+
+        /// <summary>
+        /// Access check for MoveFileWithgProgress source target.
+        /// </summary>
+        MoveFileWithProgressSource,
+
+        /// <summary>
+        /// Access check for MoveFileWithProgress dest target.
+        /// </summary>
+        MoveFileWithProgressDest,
+
+        /// <summary>
+        /// Multiple operations lumped into one.
+        /// </summary>
+        MultipleOperations,
+
+        /// <summary>
+        /// Process exited.
+        /// </summary>
+        ProcessExit,
+
+        #region Operation Names Reported by BuildXLSandbox (macOS sandbox implementation)
+        MacLookup,
+        MacReadlink,
+        MacVNodeCreate,
+        KAuthMoveSource,
+        KAuthMoveDest,
+        KAuthCreateHardlinkSource,
+        KAuthCreateHardlinkDest,
+        KAuthCopySource,
+        KAuthCopyDest,
+        KAuthDeleteDir,
+        KAuthDeleteFile,
+        KAuthOpenDir,
+        KAuthReadFile,
+        KAuthCreateDir,
+        KAuthWriteFile,
+        KAuthClose,
+        KAuthCloseModified,
+        KAuthGetAttributes,
+        KAuthVNodeExecute,
+        KAuthVNodeWrite,
+        KAuthVNodeRead,
+        KAuthVNodeProbe,
+        MacVNodeWrite,
+        MacVNodeCloneSource,
+        MacVNodeCloneDest,
+        #endregion
+    }
+}
diff --git a/src/Build/FileAccess/RequestedAccess.cs b/src/Build/FileAccess/RequestedAccess.cs
new file mode 100644
index 00000000000..e0e83f176ed
--- /dev/null
+++ b/src/Build/FileAccess/RequestedAccess.cs
@@ -0,0 +1,60 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Experimental.FileAccess
+{
+    /*
+     * Implementation note: This is a copy of BuildXL.Processes.RequestedAccess.
+     * The purpose of the copy is because this is part of the public MSBuild API and it's not desirable to
+     * expose BuildXL types directly.
+     */
+
+    /// <summary>
+    /// Level of access requested by a reported file operation.
+    /// </summary>
+    [Flags]
+    public enum RequestedAccess : byte
+    {
+        /// <summary>
+        /// No access requested.
+        /// </summary>
+        None = 0,
+
+        /// <summary>
+        /// Read access requested.
+        /// </summary>
+        Read = 1,
+
+        /// <summary>
+        /// Write access requested.
+        /// </summary>
+        Write = 2,
+
+        /// <summary>
+        /// Metadata-only probe access requested (e.g. <see cref="ReportedFileOperation.GetFileAttributes"/>).
+        /// </summary>
+        Probe = 4,
+
+        /// <summary>
+        /// Directory enumeration access requested (on the directory itself; immediate children will be enumerated).
+        /// </summary>
+        Enumerate = 8,
+
+        /// <summary>
+        /// Metadata-only probe access requested; probed as part of a directory enumeration (e.g. <see cref="ReportedFileOperation.FindNextFile"/>).
+        /// </summary>
+        EnumerationProbe = 16,
+
+        /// <summary>
+        /// Both read and write access requested.
+        /// </summary>
+        ReadWrite = Read | Write,
+
+        /// <summary>
+        /// All defined access levels requested.
+        /// </summary>
+        All = Read | Write | Probe | Enumerate | EnumerationProbe,
+    }
+}
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 4db93ab3bb0..cf6fc186770 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -2007,7 +2007,7 @@ public ProjectItemInstance CreateItem(string evaluatedInclude, string evaluatedI
                 /// <summary>
                 /// Applies the supplied metadata to the destination item.
                 /// </summary>
-                public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadataList, IEnumerable<ProjectItemInstance> destinationItems)
+                public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadataList, IEnumerable<ProjectItemInstance> destinationItems)
                 {
                     // Set up a single dictionary that can be applied to all the items
                     CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
@@ -2172,7 +2172,7 @@ public TaskItem CreateItem(string includeEscaped, string includeBeforeWildcardEx
                 /// <summary>
                 /// Applies the supplied metadata to the destination item.
                 /// </summary>
-                public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metadata, IEnumerable<TaskItem> destinationItems)
+                public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadata, IEnumerable<TaskItem> destinationItems)
                 {
                     // Not difficult to implement, but we do not expect to go here.
                     ErrorUtilities.ThrowInternalErrorUnreachable();
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 0b874696321..09bbe0eb985 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -9,7 +9,9 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
@@ -433,6 +435,17 @@ private void HandlePacket(INodePacket packet, out bool taskFinished)
         /// </summary>
         private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplete)
         {
+#if FEATURE_REPORTFILEACCESSES
+            if (taskHostTaskComplete.FileAccessData?.Count > 0)
+            {
+                IFileAccessManager fileAccessManager = ((IFileAccessManager)_buildComponentHost.GetComponent(BuildComponentType.FileAccessManager));
+                foreach (FileAccessData fileAccessData in taskHostTaskComplete.FileAccessData)
+                {
+                    fileAccessManager.ReportFileAccess(fileAccessData, _buildComponentHost.BuildParameters.NodeId);
+                }
+            }
+#endif
+
             // If it crashed, or if it failed, it didn't succeed.   
             _taskExecutionSucceeded = taskHostTaskComplete.TaskResult == TaskCompleteType.Success ? true : false;
 
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index b7014cd6ac2..f4143ccaae7 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -272,12 +272,7 @@ internal void WriteLinePretty(int indentLevel, string formattedString)
         /// </summary>
         internal void IsRunningWithCharacterFileType()
         {
-            runningWithCharacterFileType = false;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                runningWithCharacterFileType = ConsoleConfiguration.OutputIsScreen;
-            }
+            runningWithCharacterFileType = NativeMethodsShared.IsWindows && ConsoleConfiguration.OutputIsScreen;
         }
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index 8bdcfbf09d9..a19a06c2d37 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -9,8 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Logging
 {
     /// <summary>
@@ -28,6 +26,11 @@ static BinaryLogReplayEventSource()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
+        /// <summary>
+        /// Raised once <see cref="BuildEventArgsReader"/> is created during replaying
+        /// </summary>
+        public event Action<IBuildEventArgsReaderNotifications>? NotificationsSourceCreated;
+
         /// <summary>
         /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
         /// </summary>
@@ -38,48 +41,67 @@ public void Replay(string sourceFilePath)
         }
 
         /// <summary>
-        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// Creates a <see cref="BinaryReader"/> for the provided binary log file.
+        /// Performs decompression and buffering in the optimal way.
+        /// Caller is responsible for disposing the returned reader.
         /// </summary>
-        /// <param name="sourceFilePath">The full file path of the binary log file</param>
-        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
-        public void Replay(string sourceFilePath, CancellationToken cancellationToken)
+        /// <param name="sourceFilePath"></param>
+        /// <returns>BinaryReader of the given binlog file.</returns>
+        public static BinaryReader OpenReader(string sourceFilePath)
         {
-            using (var stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
+            Stream? stream = null;
+            try
             {
-                var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: true);
+                stream = new FileStream(sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.Read);
+                var gzipStream = new GZipStream(stream, CompressionMode.Decompress, leaveOpen: false);
 
                 // wrapping the GZipStream in a buffered stream significantly improves performance
                 // and the max throughput is reached with a 32K buffer. See details here:
                 // https://github.com/dotnet/runtime/issues/39233#issuecomment-745598847
                 var bufferedStream = new BufferedStream(gzipStream, 32768);
-                var binaryReader = new BinaryReader(bufferedStream);
+                return new BinaryReader(bufferedStream);
+            }
+            catch(Exception)
+            {
+                stream?.Dispose();
+                throw;
+            }
+        }
 
-                int fileFormatVersion = binaryReader.ReadInt32();
+        /// <summary>
+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="sourceFilePath">The full file path of the binary log file</param>
+        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
+        public void Replay(string sourceFilePath, CancellationToken cancellationToken)
+        {
+            using var binaryReader = OpenReader(sourceFilePath);
+            Replay(binaryReader, cancellationToken);
+        }
 
-                // the log file is written using a newer version of file format
-                // that we don't know how to read
-                if (fileFormatVersion > BinaryLogger.FileFormatVersion)
-                {
-                    var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnsupportedLogFileFormat", fileFormatVersion, BinaryLogger.FileFormatVersion);
-                    throw new NotSupportedException(text);
-                }
+        /// <summary>
+        /// Read the provided binary log file and raise corresponding events for each BuildEventArgs
+        /// </summary>
+        /// <param name="binaryReader">The binary log content binary reader - caller is responsible for disposing.</param>
+        /// <param name="cancellationToken">A <see cref="CancellationToken"/> indicating the replay should stop as soon as possible.</param>
+        public void Replay(BinaryReader binaryReader, CancellationToken cancellationToken)
+        {
+            int fileFormatVersion = binaryReader.ReadInt32();
 
-                using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
-                while (true)
-                {
-                    if (cancellationToken.IsCancellationRequested)
-                    {
-                        return;
-                    }
+            // the log file is written using a newer version of file format
+            // that we don't know how to read
+            if (fileFormatVersion > BinaryLogger.FileFormatVersion)
+            {
+                var text = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("UnsupportedLogFileFormat", fileFormatVersion, BinaryLogger.FileFormatVersion);
+                throw new NotSupportedException(text);
+            }
 
-                    BuildEventArgs instance = reader.Read();
-                    if (instance == null)
-                    {
-                        break;
-                    }
+            using var reader = new BuildEventArgsReader(binaryReader, fileFormatVersion);
+            NotificationsSourceCreated?.Invoke(reader);
 
-                    Dispatch(instance);
-                }
+            while (!cancellationToken.IsCancellationRequested && reader.Read() is { } instance)
+            {
+                Dispatch(instance);
             }
         }
     }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index fb8e59007e3..6c4e32345fb 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -61,7 +61,9 @@ public sealed class BinaryLogger : ILogger
         //   - new record kind: ResponseFileUsedEventArgs
         // version 16:
         //   - AssemblyLoadBuildEventArgs
-        internal const int FileFormatVersion = 16;
+        // version 17:
+        //   - Added extended data for types implementing IExtendedBuildEventArgs
+        internal const int FileFormatVersion = 17;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs
index 65468da0972..0f579c2a549 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsFieldFlags.cs
@@ -29,6 +29,7 @@ internal enum BuildEventArgsFieldFlags
         EndLineNumber = 1 << 12,
         EndColumnNumber = 1 << 13,
         Arguments = 1 << 14,
-        Importance = 1 << 15
+        Importance = 1 << 15,
+        Extended = 1 << 16,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs
index f5aba4eb60c..fcc7c4433ff 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsFields.cs
@@ -32,5 +32,6 @@ internal class BuildEventArgsFields
         public int ColumnNumber { get; set; }
         public int EndLineNumber { get; set; }
         public int EndColumnNumber { get; set; }
+        public ExtendedDataFields Extended { get; set; }
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index ddb7520a7fd..55c330ccd27 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -13,14 +13,12 @@
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Logging
 {
     /// <summary>
     /// Deserializes and returns BuildEventArgs-derived objects from a BinaryReader
     /// </summary>
-    public class BuildEventArgsReader : IDisposable
+    public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposable
     {
         private readonly BinaryReader binaryReader;
         private readonly int fileFormatVersion;
@@ -45,13 +43,13 @@ public class BuildEventArgsReader : IDisposable
         /// A "page-file" for storing strings we've read so far. Keeping them in memory would OOM the 32-bit MSBuild
         /// when reading large binlogs. This is a no-op in a 64-bit process.
         /// </summary>
-        private StringStorage stringStorage = new StringStorage();
+        private readonly StringStorage stringStorage = new StringStorage();
 
         // reflection is needed to set these three fields because public constructors don't provide
         // a way to set these from the outside
-        private static FieldInfo buildEventArgsFieldThreadId =
+        private static FieldInfo? buildEventArgsFieldThreadId =
             typeof(BuildEventArgs).GetField("threadId", BindingFlags.Instance | BindingFlags.NonPublic);
-        private static FieldInfo buildEventArgsFieldSenderName =
+        private static FieldInfo? buildEventArgsFieldSenderName =
             typeof(BuildEventArgs).GetField("senderName", BindingFlags.Instance | BindingFlags.NonPublic);
 
         /// <summary>
@@ -67,18 +65,27 @@ public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion)
 
         public void Dispose()
         {
-            if (stringStorage != null)
-            {
-                stringStorage.Dispose();
-                stringStorage = null;
-            }
+            stringStorage.Dispose();
         }
 
+        /// <summary>
+        /// An event that allows the subscriber to be notified when a string is read from the binary log.
+        /// Subscriber may adjust the string by setting <see cref="StringReadEventArgs.StringToBeUsed"/> property.
+        /// The passed event arg can be reused and should not be stored.
+        /// </summary>
+        public event Action<StringReadEventArgs>? StringReadDone;
+
+        /// <summary>
+        /// An event that allows the caller to be notified when a string is encountered in the binary log.
+        /// BinaryReader passed in ctor is at the beginning of the string at this point.
+        /// </summary>
+        public event Action? StringEncountered;
+
         /// <summary>
         /// Raised when the log reader encounters a binary blob embedded in the stream.
         /// The arguments include the blob kind and the byte buffer with the contents.
         /// </summary>
-        internal event Action<BinaryLogRecordKind, byte[]> OnBlobRead;
+        internal event Action<BinaryLogRecordKind, byte[]>? OnBlobRead;
 
         /// <summary>
         /// Reads the next log record from the <see cref="BinaryReader"/>.
@@ -87,7 +94,7 @@ public void Dispose()
         /// The next <see cref="BuildEventArgs"/>.
         /// If there are no more records, returns <see langword="null"/>.
         /// </returns>
-        public BuildEventArgs Read()
+        public BuildEventArgs? Read()
         {
             BinaryLogRecordKind recordKind = (BinaryLogRecordKind)ReadInt32();
 
@@ -114,7 +121,7 @@ public BuildEventArgs Read()
                 recordKind = (BinaryLogRecordKind)ReadInt32();
             }
 
-            BuildEventArgs result = null;
+            BuildEventArgs? result = null;
             switch (recordKind)
             {
                 case BinaryLogRecordKind.EndOfFile:
@@ -191,8 +198,6 @@ public BuildEventArgs Read()
                 case BinaryLogRecordKind.AssemblyLoad:
                     result = ReadAssemblyLoadEventArgs();
                     break;
-                default:
-                    break;
             }
 
             recordNumber += 1;
@@ -242,8 +247,10 @@ private IDictionary<string, string> GetNameValueList(int id)
                 var dictionary = ArrayDictionary<string, string>.Create(list.Length);
                 for (int i = 0; i < list.Length; i++)
                 {
-                    string key = GetStringFromRecord(list[i].keyIndex);
-                    string value = GetStringFromRecord(list[i].valueIndex);
+                    string? key = GetStringFromRecord(list[i].keyIndex);
+                    // passing null forward would require changes to API surface of existing events
+                    // (BuildStartedEventArgs.BuildEnvironment and ProjectStartedEventArgs.GlobalProperties)
+                    string value = GetStringFromRecord(list[i].valueIndex) ?? string.Empty;
                     if (key != null)
                     {
                         dictionary.Add(key, value);
@@ -258,6 +265,7 @@ private IDictionary<string, string> GetNameValueList(int id)
                 $"NameValueList record number {recordNumber} is invalid: index {id} is not within {stringRecords.Count}.");
         }
 
+        private readonly StringReadEventArgs stringReadEventArgs = new StringReadEventArgs(string.Empty);
         private void ReadStringRecord()
         {
             string text = ReadString();
@@ -304,11 +312,11 @@ private BuildEventArgs ReadTargetSkippedEventArgs()
             var targetName = ReadOptionalString();
             var parentTarget = ReadOptionalString();
 
-            string condition = null;
-            string evaluatedCondition = null;
+            string? condition = null;
+            string? evaluatedCondition = null;
             bool originallySucceeded = false;
             TargetSkipReason skipReason = TargetSkipReason.None;
-            BuildEventContext originalBuildEventContext = null;
+            BuildEventContext? originalBuildEventContext = null;
             if (fileFormatVersion >= 13)
             {
                 condition = ReadOptionalString();
@@ -381,7 +389,9 @@ private BuildEventArgs ReadBuildFinishedEventArgs()
         private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadDeduplicatedString();
+            // Null message arg is not expected by the ProjectEvaluationStartedEventArgs
+            // Ensuring the non-null value - to avoid a need for public API change
+            var projectFile = ReadDeduplicatedString() ?? string.Empty;
 
             var e = new ProjectEvaluationStartedEventArgs(
                 ResourceUtilities.GetResourceString("EvaluationStarted"),
@@ -396,7 +406,8 @@ private BuildEventArgs ReadProjectEvaluationStartedEventArgs()
         private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            var projectFile = ReadDeduplicatedString();
+            // Null message arg is not expected
+            var projectFile = ReadDeduplicatedString() ?? string.Empty;
 
             var e = new ProjectEvaluationFinishedEventArgs(
                 ResourceUtilities.GetResourceString("EvaluationFinished"),
@@ -408,7 +419,7 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
 
             if (fileFormatVersion >= 12)
             {
-                IEnumerable globalProperties = null;
+                IEnumerable? globalProperties = null;
                 if (ReadBoolean())
                 {
                     globalProperties = ReadStringDictionary();
@@ -448,7 +459,7 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
         private BuildEventArgs ReadProjectStartedEventArgs()
         {
             var fields = ReadBuildEventArgsFields();
-            BuildEventContext parentContext = null;
+            BuildEventContext? parentContext = null;
             if (ReadBoolean())
             {
                 parentContext = ReadBuildEventContext();
@@ -459,7 +470,7 @@ private BuildEventArgs ReadProjectStartedEventArgs()
             var targetNames = ReadDeduplicatedString();
             var toolsVersion = ReadOptionalString();
 
-            IDictionary<string, string> globalProperties = null;
+            IDictionary<string, string>? globalProperties = null;
 
             if (fileFormatVersion > 6)
             {
@@ -593,21 +604,50 @@ private BuildEventArgs ReadBuildErrorEventArgs()
             var fields = ReadBuildEventArgsFields();
             ReadDiagnosticFields(fields);
 
-            var e = new BuildErrorEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new BuildErrorEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile
+                };
+            }
+            else
+            {
+                e = new ExtendedBuildErrorEventArgs(
+                    fields.Extended.ExtendedType,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended.ExtendedMetadata,
+                    ExtendedData = fields.Extended.ExtendedData,
+                };
+            }
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
+                
             return e;
         }
 
@@ -616,21 +656,50 @@ private BuildEventArgs ReadBuildWarningEventArgs()
             var fields = ReadBuildEventArgsFields();
             ReadDiagnosticFields(fields);
 
-            var e = new BuildWarningEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new BuildWarningEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile
+                };
+            }
+            else
+            {
+                e = new ExtendedBuildWarningEventArgs(
+                    fields.Extended.ExtendedType,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended.ExtendedMetadata,
+                    ExtendedData = fields.Extended.ExtendedData,
+                };
+            }
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
+
             return e;
         }
 
@@ -638,22 +707,53 @@ private BuildEventArgs ReadBuildMessageEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            var e = new BuildMessageEventArgs(
-                fields.Subcategory,
-                fields.Code,
-                fields.File,
-                fields.LineNumber,
-                fields.ColumnNumber,
-                fields.EndLineNumber,
-                fields.EndColumnNumber,
-                fields.Message,
-                fields.HelpKeyword,
-                fields.SenderName,
-                fields.Importance,
-                fields.Timestamp,
-                fields.Arguments);
+            BuildEventArgs e;
+            if (fields.Extended == null)
+            {
+                e = new BuildMessageEventArgs(
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Importance,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                };
+            }
+            else
+            {
+                e = new ExtendedBuildMessageEventArgs(
+                    fields.Extended?.ExtendedType ?? string.Empty,
+                    fields.Subcategory,
+                    fields.Code,
+                    fields.File,
+                    fields.LineNumber,
+                    fields.ColumnNumber,
+                    fields.EndLineNumber,
+                    fields.EndColumnNumber,
+                    fields.Message,
+                    fields.HelpKeyword,
+                    fields.SenderName,
+                    fields.Importance,
+                    fields.Timestamp,
+                    fields.Arguments)
+                {
+                    ProjectFile = fields.ProjectFile,
+                    ExtendedMetadata = fields.Extended?.ExtendedMetadata,
+                    ExtendedData = fields.Extended?.ExtendedData,
+                };
+            }
+
             e.BuildEventContext = fields.BuildEventContext;
-            e.ProjectFile = fields.ProjectFile;
+
             return e;
         }
 
@@ -747,10 +847,10 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            string propertyName = ReadDeduplicatedString();
-            string previousValue = ReadDeduplicatedString();
-            string newValue = ReadDeduplicatedString();
-            string location = ReadDeduplicatedString();
+            string? propertyName = ReadDeduplicatedString();
+            string? previousValue = ReadDeduplicatedString();
+            string? newValue = ReadDeduplicatedString();
+            string? location = ReadDeduplicatedString();
 
             var e = new PropertyReassignmentEventArgs(
                 propertyName,
@@ -769,7 +869,7 @@ private BuildEventArgs ReadPropertyReassignmentEventArgs()
         private BuildEventArgs ReadUninitializedPropertyReadEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
-            string propertyName = ReadDeduplicatedString();
+            string? propertyName = ReadDeduplicatedString();
 
             var e = new UninitializedPropertyReadEventArgs(
                 propertyName,
@@ -786,9 +886,9 @@ private BuildEventArgs ReadPropertyInitialValueSetEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
 
-            string propertyName = ReadDeduplicatedString();
-            string propertyValue = ReadDeduplicatedString();
-            string propertySource = ReadDeduplicatedString();
+            string? propertyName = ReadDeduplicatedString();
+            string? propertyValue = ReadDeduplicatedString();
+            string? propertySource = ReadDeduplicatedString();
 
             var e = new PropertyInitialValueSetEventArgs(
                 propertyName,
@@ -808,11 +908,11 @@ private AssemblyLoadBuildEventArgs ReadAssemblyLoadEventArgs()
             var fields = ReadBuildEventArgsFields(readImportance: false);
 
             AssemblyLoadingContext context = (AssemblyLoadingContext)ReadInt32();
-            string loadingInitiator = ReadDeduplicatedString();
-            string assemblyName = ReadDeduplicatedString();
-            string assemblyPath = ReadDeduplicatedString();
+            string? loadingInitiator = ReadDeduplicatedString();
+            string? assemblyName = ReadDeduplicatedString();
+            string? assemblyPath = ReadDeduplicatedString();
             Guid mvid = ReadGuid();
-            string appDomainName = ReadDeduplicatedString();
+            string? appDomainName = ReadDeduplicatedString();
 
             var e = new AssemblyLoadBuildEventArgs(
                 context,
@@ -844,12 +944,23 @@ private void ReadDiagnosticFields(BuildEventArgsFields fields)
             fields.EndColumnNumber = ReadInt32();
         }
 
+        private ExtendedDataFields? ReadExtendedDataFields()
+        {
+            string extendedType = ReadOptionalString()!;
+            IDictionary<string, string?>? extendedMetadata = ReadStringDictionary()!;
+            string? extendedData = ReadOptionalString();
+
+            return new ExtendedDataFields(extendedType, extendedMetadata, extendedData);
+        }
+
         private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = false)
         {
             BuildEventArgsFieldFlags flags = (BuildEventArgsFieldFlags)ReadInt32();
             var result = new BuildEventArgsFields();
             result.Flags = flags;
 
+            // Base Fields
+
             if ((flags & BuildEventArgsFieldFlags.Message) != 0)
             {
                 result.Message = ReadDeduplicatedString();
@@ -880,6 +991,13 @@ private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = fals
                 result.Timestamp = ReadDateTime();
             }
 
+            if ((flags & BuildEventArgsFieldFlags.Extended) != 0)
+            {
+                result.Extended = ReadExtendedDataFields();
+            }
+
+            // End of BaseFields
+
             if ((flags & BuildEventArgsFieldFlags.Subcategory) != 0)
             {
                 result.Subcategory = ReadDeduplicatedString();
@@ -923,7 +1041,7 @@ private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance = fals
             if ((flags & BuildEventArgsFieldFlags.Arguments) != 0)
             {
                 int count = ReadInt32();
-                object[] arguments = new object[count];
+                object?[] arguments = new object[count];
                 for (int i = 0; i < count; i++)
                 {
                     arguments[i] = ReadDeduplicatedString();
@@ -946,12 +1064,12 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
 
             if ((fields.Flags & BuildEventArgsFieldFlags.ThreadId) != 0)
             {
-                buildEventArgsFieldThreadId.SetValue(buildEventArgs, fields.ThreadId);
+                buildEventArgsFieldThreadId?.SetValue(buildEventArgs, fields.ThreadId);
             }
 
             if ((fields.Flags & BuildEventArgsFieldFlags.SenderName) != 0)
             {
-                buildEventArgsFieldSenderName.SetValue(buildEventArgs, fields.SenderName);
+                buildEventArgsFieldSenderName?.SetValue(buildEventArgs, fields.SenderName);
             }
 
             if ((fields.Flags & BuildEventArgsFieldFlags.Timestamp) != 0)
@@ -960,7 +1078,7 @@ private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields
             }
         }
 
-        private IEnumerable ReadPropertyList()
+        private IEnumerable? ReadPropertyList()
         {
             var properties = ReadStringDictionary();
             if (properties == null || properties.Count == 0)
@@ -1007,7 +1125,7 @@ private BuildEventContext ReadBuildEventContext()
             return result;
         }
 
-        private IDictionary<string, string> ReadStringDictionary()
+        private IDictionary<string, string>? ReadStringDictionary()
         {
             if (fileFormatVersion < 10)
             {
@@ -1024,7 +1142,7 @@ private IDictionary<string, string> ReadStringDictionary()
             return record;
         }
 
-        private IDictionary<string, string> ReadLegacyStringDictionary()
+        private IDictionary<string, string>? ReadLegacyStringDictionary()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -1046,16 +1164,16 @@ private IDictionary<string, string> ReadLegacyStringDictionary()
 
         private ITaskItem ReadTaskItem()
         {
-            string itemSpec = ReadDeduplicatedString();
+            string? itemSpec = ReadDeduplicatedString();
             var metadata = ReadStringDictionary();
 
             var taskItem = new TaskItemData(itemSpec, metadata);
             return taskItem;
         }
 
-        private IEnumerable ReadProjectItems()
+        private IEnumerable? ReadProjectItems()
         {
-            IList<DictionaryEntry> list;
+            IList<DictionaryEntry>? list;
 
             // starting with format version 10 project items are grouped by name
             // so we only have to write the name once, and then the count of items
@@ -1088,7 +1206,7 @@ private IEnumerable ReadProjectItems()
                 list = new List<DictionaryEntry>();
                 for (int i = 0; i < count; i++)
                 {
-                    string itemType = ReadDeduplicatedString();
+                    string itemType = ReadDeduplicatedString()!;
                     var items = ReadTaskItemList();
                     if (items != null)
                     {
@@ -1110,7 +1228,7 @@ private IEnumerable ReadProjectItems()
 
                 while (true)
                 {
-                    string itemType = ReadDeduplicatedString();
+                    string itemType = ReadDeduplicatedString()!;
                     if (string.IsNullOrEmpty(itemType))
                     {
                         break;
@@ -1135,7 +1253,7 @@ private IEnumerable ReadProjectItems()
             return list;
         }
 
-        private IEnumerable ReadTaskItemList()
+        private IEnumerable? ReadTaskItemList()
         {
             int count = ReadInt32();
             if (count == 0)
@@ -1156,10 +1274,18 @@ private IEnumerable ReadTaskItemList()
 
         private string ReadString()
         {
-            return binaryReader.ReadString();
+            this.StringEncountered?.Invoke();
+            string text = binaryReader.ReadString();
+            if (this.StringReadDone != null)
+            {
+                stringReadEventArgs.Reuse(text);
+                StringReadDone(stringReadEventArgs);
+                text = stringReadEventArgs.StringToBeUsed;
+            }
+            return text;
         }
 
-        private string ReadOptionalString()
+        private string? ReadOptionalString()
         {
             if (fileFormatVersion < 10)
             {
@@ -1176,7 +1302,7 @@ private string ReadOptionalString()
             return ReadDeduplicatedString();
         }
 
-        private string ReadDeduplicatedString()
+        private string? ReadDeduplicatedString()
         {
             if (fileFormatVersion < 10)
             {
@@ -1187,7 +1313,7 @@ private string ReadDeduplicatedString()
             return GetStringFromRecord(index);
         }
 
-        private string GetStringFromRecord(int index)
+        private string? GetStringFromRecord(int index)
         {
             if (index == 0)
             {
@@ -1231,9 +1357,9 @@ private bool ReadBoolean()
             return binaryReader.ReadBoolean();
         }
 
-        private unsafe Guid ReadGuid()
+        private Guid ReadGuid()
         {
-            return new Guid(binaryReader.ReadBytes(sizeof(Guid)));
+            return new Guid(binaryReader.ReadBytes(16 /*sizeof(Guid) - to avoid unsafe context, Guid will never change in size */));
         }
 
         private DateTime ReadDateTime()
@@ -1310,11 +1436,11 @@ internal class StringPosition
         /// </summary>
         internal class StringStorage : IDisposable
         {
-            private readonly string filePath;
-            private FileStream stream;
-            private StreamWriter streamWriter;
-            private readonly StreamReader streamReader;
-            private readonly StringBuilder stringBuilder;
+            private readonly string? filePath;
+            private FileStream? stream;
+            private StreamWriter? streamWriter;
+            private readonly StreamReader? streamReader;
+            private readonly StringBuilder? stringBuilder;
 
             public const int StringSizeThreshold = 1024;
 
@@ -1368,9 +1494,9 @@ public object Add(string text)
 
                 var stringPosition = new StringPosition();
 
-                stringPosition.FilePosition = stream.Position;
+                stringPosition.FilePosition = stream!.Position;
 
-                streamWriter.Write(text);
+                streamWriter!.Write(text);
 
                 stringPosition.StringLength = text.Length;
                 return stringPosition;
@@ -1385,16 +1511,16 @@ public string Get(object storedString)
 
                 var position = (StringPosition)storedString;
 
-                stream.Position = position.FilePosition;
-                stringBuilder.Length = position.StringLength;
+                stream!.Position = position.FilePosition;
+                stringBuilder!.Length = position.StringLength;
                 for (int i = 0; i < position.StringLength; i++)
                 {
-                    char ch = (char)streamReader.Read();
+                    char ch = (char)streamReader!.Read();
                     stringBuilder[i] = ch;
                 }
 
                 stream.Position = stream.Length;
-                streamReader.DiscardBufferedData();
+                streamReader!.DiscardBufferedData();
 
                 string result = stringBuilder.ToString();
                 stringBuilder.Clear();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index bc96814843e..0a21182e83c 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -198,12 +198,31 @@ private void WriteCore(BuildEventArgs e)
                 default:
                     // convert all unrecognized objects to message
                     // and just preserve the message
-                    var buildMessageEventArgs = new BuildMessageEventArgs(
-                        e.Message,
-                        e.HelpKeyword,
-                        e.SenderName,
-                        MessageImportance.Normal,
-                        e.Timestamp);
+                    BuildMessageEventArgs buildMessageEventArgs;
+                    if (e is IExtendedBuildEventArgs extendedData)
+                    {
+                        // For Extended events convert to ExtendedBuildMessageEventArgs
+                        buildMessageEventArgs = new ExtendedBuildMessageEventArgs(
+                            extendedData.ExtendedType,
+                            e.Message,
+                            e.HelpKeyword,
+                            e.SenderName,
+                            MessageImportance.Normal,
+                            e.Timestamp)
+                        {
+                            ExtendedData = extendedData.ExtendedData,
+                            ExtendedMetadata = extendedData.ExtendedMetadata,
+                        };
+                    }
+                    else
+                    {
+                        buildMessageEventArgs = new BuildMessageEventArgs(
+                            e.Message,
+                            e.HelpKeyword,
+                            e.SenderName,
+                            MessageImportance.Normal,
+                            e.Timestamp);
+                    }
                     buildMessageEventArgs.BuildEventContext = e.BuildEventContext ?? BuildEventContext.Invalid;
                     Write(buildMessageEventArgs);
                     break;
@@ -610,6 +629,11 @@ private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags)
             {
                 Write(e.Timestamp);
             }
+
+            if ((flags & BuildEventArgsFieldFlags.Extended) != 0)
+            {
+                Write(e as IExtendedBuildEventArgs);
+            }
         }
 
         private void WriteMessageFields(BuildMessageEventArgs e, bool writeMessage = true, bool writeImportance = false)
@@ -775,6 +799,11 @@ private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventAr
                 flags |= BuildEventArgsFieldFlags.Timestamp;
             }
 
+            if (e is IExtendedBuildEventArgs extendedData)
+            {
+                flags |= BuildEventArgsFieldFlags.Extended;
+            }
+
             return flags;
         }
 
@@ -1218,6 +1247,16 @@ private void Write(ProfiledLocation e)
             Write(e.InclusiveTime);
         }
 
+        private void Write(IExtendedBuildEventArgs extendedData)
+        {
+            if (extendedData?.ExtendedType != null)
+            {
+                WriteDeduplicatedString(extendedData.ExtendedType);
+                Write(extendedData.ExtendedMetadata);
+                WriteDeduplicatedString(extendedData.ExtendedData);
+            }
+        }
+
         internal readonly struct HashKey : IEquatable<HashKey>
         {
             private readonly ulong value;
diff --git a/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs b/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs
new file mode 100644
index 00000000000..2a227e9d69c
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/ExtendedDataFields.cs
@@ -0,0 +1,20 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Logging;
+
+internal class ExtendedDataFields
+{
+    public ExtendedDataFields(string extendedType, IDictionary<string, string?>? extendedMetadata, string? extendedData)
+    {
+        ExtendedType = extendedType;
+        ExtendedMetadata = extendedMetadata;
+        ExtendedData = extendedData;
+    }
+
+    public string ExtendedType { get; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; }
+    public string? ExtendedData { get; }
+}
diff --git a/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs b/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs
new file mode 100644
index 00000000000..415bd7c71fd
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/IBuildEventArgsReaderNotifications.cs
@@ -0,0 +1,13 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An interface for notifications from BuildEventArgsReader
+    /// </summary>
+    public interface IBuildEventArgsReaderNotifications : IBuildEventStringsReader
+    {
+        /* For future use */
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs b/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs
new file mode 100644
index 00000000000..e9e7651ee78
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/IBuildEventStringsReader.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An interface for notifications about reading strings from the binary log.
+    /// </summary>
+    public interface IBuildEventStringsReader
+    {
+        /// <summary>
+        /// An event that allows the subscriber to be notified when a string is read from the binary log.
+        /// Subscriber may adjust the string by setting <see cref="StringReadEventArgs.StringToBeUsed"/> property.
+        /// The passed event arg can be reused and should not be stored.
+        /// </summary>
+        public event Action<StringReadEventArgs>? StringReadDone;
+
+        /// <summary>
+        /// An event that allows the caller to be notified when a string is encountered in the binary log.
+        /// BinaryReader passed in ctor is at the beginning of the string at this point.
+        /// </summary>
+        public event Action? StringEncountered;
+    }
+}
diff --git a/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs b/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs
new file mode 100644
index 00000000000..e2a4c83d3cb
--- /dev/null
+++ b/src/Build/Logging/BinaryLogger/StringReadEventArgs.cs
@@ -0,0 +1,35 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.Build.Logging
+{
+    /// <summary>
+    /// An event args for <see cref="IBuildEventStringsReader.StringReadDone"/> callback.
+    /// </summary>
+    public sealed class StringReadEventArgs : EventArgs
+    {
+        /// <summary>
+        /// The original string that was read from the binary log.
+        /// </summary>
+        public string OriginalString { get; private set; }
+
+        /// <summary>
+        /// The adjusted string (or the original string of none subscriber replaced it) that will be used by the reader.
+        /// </summary>
+        public string StringToBeUsed { get; set; }
+
+        public StringReadEventArgs(string str)
+        {
+            OriginalString = str;
+            StringToBeUsed = str;
+        }
+
+        internal void Reuse(string newValue)
+        {
+            OriginalString = newValue;
+            StringToBeUsed = newValue;
+        }
+    }
+}
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index a67d513a099..7f12efba35c 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -219,7 +219,7 @@ private static Dictionary<EvaluationLocation, ProfiledLocation> PruneSmallItems(
 
             // Let's build an index of profiled locations by id, to speed up subsequent queries
             var idTable = aggregatedLocations.ToDictionary(pair => pair.Key.Id,
-                pair => new Pair<EvaluationLocation, ProfiledLocation>(pair.Key, pair.Value));
+                pair => new KeyValuePair<EvaluationLocation, ProfiledLocation>(pair.Key, pair.Value));
 
             // We want to keep all evaluation pass entries plus the big enough regular entries
             foreach (var prunedPair in aggregatedLocations.Where(pair =>
@@ -237,7 +237,7 @@ private static Dictionary<EvaluationLocation, ProfiledLocation> PruneSmallItems(
         /// <summary>
         /// Finds the first ancestor of parentId (which could be itself) that is either an evaluation pass location or a big enough profiled data.
         /// </summary>
-        private static long? FindBigEnoughParentId(IDictionary<long, Pair<EvaluationLocation, ProfiledLocation>> idTable,
+        private static long? FindBigEnoughParentId(IDictionary<long, KeyValuePair<EvaluationLocation, ProfiledLocation>> idTable,
             long? parentId)
         {
             // The parent id is null, which means the item was pointing to an evaluation pass item. So we keep it as is.
diff --git a/src/Build/Logging/SimpleErrorLogger.cs b/src/Build/Logging/SimpleErrorLogger.cs
new file mode 100644
index 00000000000..6414324064b
--- /dev/null
+++ b/src/Build/Logging/SimpleErrorLogger.cs
@@ -0,0 +1,91 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Logging.TerminalLogger;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Logging.SimpleErrorLogger
+{
+    /// <summary>
+    /// This logger ignores all message-level output, writing errors and warnings to
+    /// standard error, colored red and yellow respectively.
+    ///
+    /// It is currently used only when the user requests information about specific
+    /// properties, items, or target results. In that case, we write the desired output
+    /// to standard out, but we do not want it polluted with any other kinds of information.
+    /// Users still might want diagnostic information if something goes wrong, so still
+    /// output that as necessary.
+    /// </summary>
+    public sealed class SimpleErrorLogger : INodeLogger
+    {
+        private readonly bool acceptAnsiColorCodes;
+        private readonly uint? originalConsoleMode;
+        public SimpleErrorLogger()
+        {
+            (acceptAnsiColorCodes, _, originalConsoleMode) = NativeMethods.QueryIsScreenAndTryEnableAnsiColorCodes(NativeMethods.StreamHandleType.StdErr);
+        }
+
+        public bool HasLoggedErrors { get; private set; } = false;
+
+        public LoggerVerbosity Verbosity
+        {
+            get => LoggerVerbosity.Minimal;
+            set { }
+        }
+
+        public string Parameters
+        {
+            get => string.Empty;
+            set { }
+        }
+
+        public void Initialize(IEventSource eventSource, int nodeCount)
+        {
+            eventSource.ErrorRaised += HandleErrorEvent;
+            eventSource.WarningRaised += HandleWarningEvent;
+
+            // This needs to happen so binary loggers can get evaluation properties and items
+            if (eventSource is IEventSource4 eventSource4)
+            {
+                eventSource4.IncludeEvaluationPropertiesAndItems();
+            }
+        }
+
+        private void HandleErrorEvent(object sender, BuildErrorEventArgs e)
+        {
+            HasLoggedErrors = true;
+            LogWithColor(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true),
+                TerminalColor.Red);
+        }
+
+        private void HandleWarningEvent(object sender, BuildWarningEventArgs e)
+        {
+            LogWithColor(EventArgsFormatting.FormatEventMessage(e, showProjectFile: true),
+                TerminalColor.Yellow);
+        }
+
+        private void LogWithColor(string message, TerminalColor color)
+        {
+            if (acceptAnsiColorCodes)
+            {
+                Console.Error.Write(AnsiCodes.Colorize(message, color));
+            }
+            else
+            {
+                Console.Error.Write(message);
+            }
+        }
+
+        public void Initialize(IEventSource eventSource)
+        {
+            Initialize(eventSource, 1);
+        }
+
+        public void Shutdown()
+        {
+            NativeMethods.RestoreConsoleMode(originalConsoleMode, NativeMethods.StreamHandleType.StdErr);
+        }
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index a2d4bcbb1e7..59fdacae941 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -32,12 +32,15 @@
 
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
+    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
+    <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildFromSource)' != 'true'">
@@ -51,7 +54,6 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="System.Reflection.Metadata" />
-    <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
 
@@ -76,20 +78,12 @@
     </Compile>
     <Compile Include="..\Shared\CanonicalError.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\CanonicalError.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
       <Link>IConstrainedEqualityComparer.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\NGen.cs">
-      <Link>SharedUtilities\NGen.cs</Link>
-    </Compile>
-    <Compile Include="..\Shared\Pair.cs">
-      <Link>SharedUtilities\Pair.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\PropertyParser.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\StringExtensions.cs">
       <Link>SharedUtilities\StringExtensions.cs</Link>
@@ -118,25 +112,20 @@
     <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\Shared\PlatformNegotiation.cs">
       <Link>PlatformNegotiation.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\SolutionConfiguration.cs" />
     <Compile Include="..\Shared\TaskLoggingHelper.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelper.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TaskLoggingHelperExtension.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\TaskLoggingHelperExtension.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
     <Compile Include="..\Shared\CommunicationsUtilities.cs" />
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
-    <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs" />
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="BackEnd\BuildManager\BuildManager.cs" />
@@ -152,13 +141,29 @@
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
     <Compile Include="BackEnd\Components\Communications\CurrentHost.cs" />
+    <Compile Include="BackEnd\Components\Communications\DetouredNodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\SerializationContractInitializer.cs" />
     <Compile Include="BackEnd\Components\Communications\ServerNodeEndpointOutOfProc.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\IFileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\FileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\FileAccessReport.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\OutOfProcNodeFileAccessManager.cs" />
+    <Compile Include="BackEnd\Components\FileAccesses\ProcessReport.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\AssemblyLoadsTracker.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
     <Compile Include="Evaluation\IItemTypeDefinition.cs" />
+    <Compile Include="FileAccess\DesiredAccess.cs" />
+    <Compile Include="FileAccess\FileAccessData.cs" />
+    <Compile Include="FileAccess\FlagsAndAttributes.cs" />
+    <Compile Include="FileAccess\ProcessData.cs" />
+    <Compile Include="FileAccess\ReportedFileOperation.cs" />
+    <Compile Include="FileAccess\RequestedAccess.cs" />
+    <Compile Include="Logging\BinaryLogger\ExtendedDataFields.cs" />
+    <Compile Include="Logging\BinaryLogger\IBuildEventArgsReaderNotifications.cs" />
+    <Compile Include="Logging\BinaryLogger\IBuildEventStringsReader.cs" />
+    <Compile Include="Logging\BinaryLogger\StringReadEventArgs.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
@@ -210,14 +215,10 @@
     <Compile Include="BackEnd\Components\Logging\ProjectLoggingContext.cs" />
     <Compile Include="BackEnd\Components\Logging\TargetLoggingContext.cs" />
     <Compile Include="BackEnd\Components\Logging\TaskLoggingContext.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\CallTarget.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\CallTarget.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\IntrinsicTaskFactory.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\ItemGroupLoggingHelper.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\MSBuild.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\MSBuild.cs" />
     <Compile Include="BackEnd\Components\Scheduler\SchedulableRequest.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\FullTracking.cs" />
     <Compile Include="BackEnd\Components\Scheduler\SchedulingData.cs" />
@@ -245,18 +246,10 @@
     <Compile Include="Collections\ConcurrentQueueExtensions.cs" />
     <Compile Include="Collections\ConcurrentStackExtensions.cs" />
     <Compile Include="Collections\LookasideStringInterner.cs" />
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSet.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Collections\RetrievableEntryHashSet\HashSet.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\BitHelper.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashSetDebugView.cs" />
+    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs" />
     <Compile Include="Construction\ImplicitImportLocation.cs" />
     <Compile Include="Construction\ProjectSdkElement.cs" />
     <Compile Include="Definition\ProjectOptions.cs" />
@@ -313,9 +306,7 @@
     <Compile Include="BackEnd\Components\Communications\NodeProviderOutOfProc.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderOutOfProcBase.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderOutOfProcTaskHost.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\BatchingEngine.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\BatchingEngine.cs" />
     <Compile Include="BackEnd\BuildManager\BuildRequestData.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTask.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\IntrinsicTasks\ItemGroupIntrinsicTask.cs" />
@@ -331,18 +322,12 @@
     <Compile Include="BackEnd\Components\RequestBuilder\IRequestBuilderCallback.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\ITargetBuilder.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\ITaskBuilder.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\ItemBucket.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="BackEnd\Components\RequestBuilder\Lookup.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\ItemBucket.cs" />
+    <Compile Include="BackEnd\Components\RequestBuilder\Lookup.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\RequestBuilder.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\TargetBuilder.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\TargetEntry.cs" />
-    <Compile Include="BackEnd\Components\RequestBuilder\TargetUpToDateChecker.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="BackEnd\Components\RequestBuilder\TargetUpToDateChecker.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\TaskBuilder.cs" />
     <Compile Include="BackEnd\Components\RequestBuilder\TaskHost.cs" />
     <Compile Include="BackEnd\Shared\BuildRequest.cs" />
@@ -358,6 +343,7 @@
     <Compile Include="BackEnd\Shared\TargetResult.cs" />
     <Compile Include="BackEnd\Shared\WorkUnitResult.cs" />
     <Compile Include="BackEnd\Components\BuildRequestEngine\IBuildRequestEngine.cs" />
+    <Compile Include="BackEnd\Components\Communications\INodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\INodeManager.cs" />
     <Compile Include="BackEnd\Components\Communications\INodeProvider.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeEndpointInProc.cs" />
@@ -381,9 +367,7 @@
     </Compile>
     <Compile Include="Collections\CopyOnWritePropertyDictionary.cs" />
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
-    <Compile Include="Collections\HashTableUtility.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Collections\HashTableUtility.cs" />
     <Compile Include="Collections\ItemDictionary.cs" />
     <Compile Include="Collections\IImmutable.cs" />
     <Compile Include="Collections\MultiDictionary.cs" />
@@ -421,12 +405,8 @@
     <Compile Include="Construction\ProjectUsingTaskBodyElement.cs" />
     <Compile Include="Construction\Solution\SolutionConfigurationInSolution.cs" />
     <Compile Include="Construction\Solution\ProjectConfigurationInSolution.cs" />
-    <Compile Include="Construction\Solution\ProjectInSolution.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Construction\Solution\SolutionFile.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Construction\Solution\ProjectInSolution.cs" />
+    <Compile Include="Construction\Solution\SolutionFile.cs" />
     <!-- #### DEFINITION MODEL ### -->
     <Compile Include="Definition\BuiltInMetadata.cs" />
     <Compile Include="Definition\ProjectCollection.cs" />
@@ -439,9 +419,7 @@
     <Compile Include="Definition\SubToolset.cs" />
     <Compile Include="Definition\Toolset.cs" />
     <Compile Include="Definition\ToolsetConfigurationReader.cs" />
-    <Compile Include="..\Shared\ToolsetElement.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\ToolsetElement.cs" />
     <Compile Include="Definition\ToolsetPropertyDefinition.cs" />
     <Compile Include="Definition\ToolsetReader.cs" />
     <Compile Include="Definition\ToolsetRegistryReader.cs" />
@@ -452,85 +430,33 @@
     <Compile Include="ElementLocation\XmlDocumentWithLocation.cs" />
     <Compile Include="ElementLocation\XmlElementWithLocation.cs" />
     <Compile Include="ElementLocation\XmlNameTableThreadSafe.cs" />
-    <Compile Include="Errors\InternalLoggerException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Errors\InvalidProjectFileException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Errors\InvalidToolsetDefinitionException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Errors\RegistryException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Errors\InternalLoggerException.cs" />
+    <Compile Include="Errors\InvalidProjectFileException.cs" />
+    <Compile Include="Errors\InvalidToolsetDefinitionException.cs" />
+    <Compile Include="Errors\RegistryException.cs" />
     <!-- #### EVALUATION ### -->
-    <Compile Include="Evaluation\ConditionEvaluator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\AndExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\CharacterUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\EqualExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\FunctionCallExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\GenericExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\GreaterThanExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\GreaterThanOrEqualExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\LessThanExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\LessThanOrEqualExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\MultipleComparisonExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\NotEqualExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\NotExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\NumericComparisonExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\NumericExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\OperandExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\OperatorExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\OrExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\Parser.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\Scanner.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\StringExpressionNode.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Evaluation\Conditionals\Token.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Evaluation\ConditionEvaluator.cs" />
+    <Compile Include="Evaluation\Conditionals\AndExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\CharacterUtilities.cs" />
+    <Compile Include="Evaluation\Conditionals\EqualExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\FunctionCallExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\GenericExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\GreaterThanExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\GreaterThanOrEqualExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\LessThanExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\LessThanOrEqualExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\MultipleComparisonExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\NotEqualExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\NotExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\NumericComparisonExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\NumericExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\OperandExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\OperatorExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\OrExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\Parser.cs" />
+    <Compile Include="Evaluation\Conditionals\Scanner.cs" />
+    <Compile Include="Evaluation\Conditionals\StringExpressionNode.cs" />
+    <Compile Include="Evaluation\Conditionals\Token.cs" />
     <Compile Include="Evaluation\EvaluatorMetadataTable.cs" />
     <Compile Include="Evaluation\IEvaluatorData.cs" />
     <Compile Include="Evaluation\IItem.cs" />
@@ -590,9 +516,7 @@
     <Compile Include="Instance\TaskRegistry.cs" />
     <!-- ######################## -->
     <Compile Include="Evaluation\LazyItemEvaluator.LazyItemOperation.cs" />
-    <Compile Include="Logging\BaseConsoleLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Logging\BaseConsoleLogger.cs" />
     <Compile Include="Logging\BinaryLogger\BinaryLogger.cs" />
     <Compile Include="Logging\BinaryLogger\BinaryLogRecordKind.cs" />
     <Compile Include="Logging\BinaryLogger\BinaryLogReplayEventSource.cs" />
@@ -602,38 +526,19 @@
     <Compile Include="Logging\BinaryLogger\BuildEventArgsReader.cs" />
     <Compile Include="Logging\BinaryLogger\BuildEventArgsWriter.cs" />
     <Compile Include="Logging\BinaryLogger\ProjectImportsCollector.cs" />
-    <Compile Include="Logging\ConsoleLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\DistributedLoggers\DistributedFileLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\DistributedLoggers\ConfigurableForwardingLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\NullCentralLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\LoggerDescription.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Logging\ConsoleLogger.cs" />
+    <Compile Include="Logging\DistributedLoggers\DistributedFileLogger.cs" />
+    <Compile Include="Logging\DistributedLoggers\ConfigurableForwardingLogger.cs" />
+    <Compile Include="Logging\NullCentralLogger.cs" />
+    <Compile Include="Logging\LoggerDescription.cs" />
     <Compile Include="Logging\OptimizedStringIndenter.cs" />
-    <Compile Include="Logging\ParallelLogger\ParallelLoggerHelpers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\ParallelLogger\ParallelConsoleLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Logging\ParallelLogger\ParallelLoggerHelpers.cs" />
+    <Compile Include="Logging\ParallelLogger\ParallelConsoleLogger.cs" />
+    <Compile Include="Logging\SimpleErrorLogger.cs" />
     <Compile Include="Logging\ParallelLogger\ConsoleOutputAligner.cs" />
-    <Compile Include="Logging\FileLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\LogFormatter.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Logging\SerialConsoleLogger.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Logging\FileLogger.cs" />
+    <Compile Include="Logging\LogFormatter.cs" />
+    <Compile Include="Logging\SerialConsoleLogger.cs" />
     <Compile Include="ObjectModelRemoting\DefinitionObjectsLinks\ProjectMetadataLink.cs" />
     <Compile Include="ObjectModelRemoting\DefinitionObjectsLinks\ProjectPropertyLink.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectElementContainerLink.cs" />
@@ -647,120 +552,87 @@
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectTargetElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectTaskElementLink.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskBodyElementLink.cs" />
-    <Compile Include="Resources\AssemblyResources.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Resources\Constants.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Resources\AssemblyResources.cs" />
+    <Compile Include="Resources\Constants.cs" />
     <Compile Include="Resources\MSBuildAssemblyFileVersion.cs" />
     <!-- ######################## -->
     <!-- ######################## -->
     <!-- ######################## -->
-    <Compile Include="Utilities\EngineFileUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Utilities\EngineFileUtilities.cs" />
     <Compile Include="Utilities\FileSpecMatchTester.cs" />
-    <Compile Include="Utilities\RegistryKeyWrapper.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Utilities\Utilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Utilities\RegistryKeyWrapper.cs" />
+    <Compile Include="Utilities\Utilities.cs" />
     <Compile Include="Utilities\SimpleVersion.cs" />
     <Compile Include="Xml\ProjectXmlUtilities.XmlElementChildIterator.cs" />
-    <Compile Include="Xml\ProjectXmlUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Xml\ProjectXmlUtilities.cs" />
     <Compile Include="Xml\XmlReaderExtension.cs" />
     <Compile Include="..\Shared\AssemblyLoadInfo.cs">
       <Link>SharedUtilities\AssemblyLoadInfo.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs">
       <Link>SharedUtilities\ReadOnlyEmptyDictionary.cs</Link>
     </Compile>
     <Compile Include="..\Shared\AssemblyNameExtension.cs">
       <Link>SharedUtilities\AssemblyNameExtension.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\BuildEventFileInfo.cs">
       <Link>SharedUtilities\BuildEventFileInfo.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ConversionUtilities.cs">
       <Link>SharedUtilities\ConversionUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\FileDelegates.cs">
       <Link>SharedUtilities\FileDelegates.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <Link>Errors\ErrorUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\EscapingUtilities.cs">
       <Link>SharedUtilities\EscapingUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\VersionUtilities.cs">
       <Link>SharedUtilities\VersionUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\EventArgsFormatting.cs">
       <Link>SharedUtilities\EventArgsFormatting.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <Link>SharedUtilities\ExceptionHandling.cs</Link>
     </Compile>
     <Compile Include="..\Shared\FileMatcher.cs">
       <Link>SharedUtilities\FileMatcher.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>SharedUtilities\FileUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs" />
-    <Compile Include="..\Shared\Modifiers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\Modifiers.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>SharedUtilities\FileUtilitiesRegex.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\FrameworkLocationHelper.cs">
       <Link>SharedUtilities\FrameworkLocationHelper.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\IElementLocation.cs">
       <Link>SharedUtilities\IElementLocation.cs</Link>
     </Compile>
     <Compile Include="..\Shared\LoadedType.cs">
       <Link>SharedUtilities\LoadedType.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\InprocTrackingNativeMethods.cs">
       <Link>InprocTrackingNativeMethods.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ProjectErrorUtilities.cs">
       <Link>Errors\ProjectErrorUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ProjectFileErrorUtilities.cs">
       <Link>Errors\ProjectFileErrorUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ProjectWriter.cs">
       <Link>SharedUtilities\ProjectWriter.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ResourceUtilities.cs">
       <Link>SharedUtilities\ResourceUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\Tracing.cs" />
     <Compile Include="..\Shared\CoreCLRAssemblyLoader.cs" Condition="'$(TargetFrameworkIdentifier)'!='.NETFramework'" />
@@ -775,15 +647,12 @@
     </Compile>
     <Compile Include="..\Shared\XMakeAttributes.cs">
       <Link>Resources\XMakeAttributes.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\XMakeElements.cs">
       <Link>Resources\XMakeElements.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\XmlUtilities.cs">
       <Link>SharedUtilities\XmlUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="Evaluation\LazyItemEvaluator.EvaluatorData.cs" />
 
diff --git a/src/Build/Microsoft.Build.pkgdef b/src/Build/Microsoft.Build.pkgdef
index 74546cfe4fe..5ade779232c 100644
--- a/src/Build/Microsoft.Build.pkgdef
+++ b/src/Build/Microsoft.Build.pkgdef
@@ -5,3 +5,27 @@
 "culture"="neutral"
 "oldVersion"="0.0.0.0-99.9.9.9"
 "newVersion"="15.1.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{F74A7C60-AC4A-4EC4-A8DB-1FE89FDB53CD}]
+"name"="BuildXL.Processes"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Processes.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{A038F286-A634-460D-9964-75465129EEF2}]
+"name"="BuildXL.Utilities.Core"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Utilities.Core.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
+
+[$RootKey$\RuntimeConfiguration\dependentAssembly\bindingRedirection\{0EE5D593-1F73-4FA2-98D7-B347DFD50186}]
+"name"="BuildXL.Native"
+"codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\BuildXL.Native.dll"
+"publicKeyToken"="6212d9137135ce5d"
+"culture"="neutral"
+"oldVersion"="0.0.0.0-1.0.0.0"
+"newVersion"="1.0.0.0"
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 3a046f4d554..3e949a272e4 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1906,6 +1906,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="ProjectCacheShutdownFailed" xml:space="preserve">
     <value>MSB4268: The project cache failed to shut down properly.</value>
   </data>
+  <data name="ProjectCacheHandleBuildResultFailed" xml:space="preserve">
+    <value>MSB4269: The project cache failed while handling a build result for the following project: {0}.</value>
+  </data>
   <data name="NoProjectCachePluginFoundInAssembly" xml:space="preserve">
     <value>MSB4270: No project cache plugins found in assembly "{0}". Expected one.</value>
   </data>
@@ -1984,6 +1987,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="TaskAssemblyLoaded" xml:space="preserve">
     <value>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AppDomain: {5})</value>
   </data>
+  <data name="TaskAssemblyLoadedWithAssemblyLoadContext" xml:space="preserve">
+    <value>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</value>
+  </data>
   <data name="NodeReused" xml:space="preserve">
     <value>Reusing node {0} (PID: {1}).</value>
   </data>
@@ -1995,6 +2001,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>MSB4277: Cannot copy from object of that type.</value>
     <comment>{StrBegin="MSB4277: "}</comment>
   </data>
+  <data name="ReportFileAccessesX64Only" xml:space="preserve">
+    <value>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</value>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 0fb219fdd76..0bce98faa0e 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: Mezipaměť projektu vyvolala neošetřenou výjimku z metody {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Mezipaměť projektu selhala při zpracování výsledku sestavení pro následující projekt: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Přístup do mezipaměti projektu pro „{0}“ (výchozí cíle).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: Zakázání uzlu inproc způsobí snížení výkonu při používání modulů plug-in mezipaměti projektu, které vysílají žádosti o sestavení proxy serveru.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Přístupy k souborům sestav se v současné době podporují jenom pomocí varianty x64 nástroje MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Selhání překladače sady SDK: {0}</target>
@@ -441,6 +451,11 @@
         <target state="translated">Sestavení načtené během {0}{1}: {2} (umístění: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Úloha {0} uvolnila tento počet jader: {1}. Teď používá celkem tento počet jader: {2}</target>
@@ -1475,7 +1490,7 @@
       </trans-unit>
       <trans-unit id="SolutionVenusProjectSkipped">
         <source>Skipping because the "$(AspNetConfiguration)" configuration is not supported for this web project.  You can use the AspNetConfiguration property to override the configuration used for building web projects, by adding /p:AspNetConfiguration=&lt;value&gt; to the command line. Currently web projects only support Debug and Release configurations.</source>
-        <target state="translated">Vynecháno, protože konfigurace $(AspNetConfiguration) není pro tento webový projekt podporována. Pomocí vlastnosti AspNetConfiguration můžete přepsat konfiguraci používanou k sestavování webových projektů, a to přidáním příkazu /p:AspNetConfiguration=&lt;hodnota&gt; do příkazového řádku. Webové projekty nyní podporují pouze konfigurace Debug a Release.</target>
+        <target state="translated">Vynecháno, protože konfigurace "$(AspNetConfiguration)" není pro tento webový projekt podporována. Pomocí vlastnosti AspNetConfiguration můžete přepsat konfiguraci používanou k sestavování webových projektů, a to přidáním příkazu /p:AspNetConfiguration=&lt;hodnota&gt; do příkazového řádku. Webové projekty nyní podporují pouze konfigurace Debug a Release.</target>
         <note>
     UE: This is not an error, so doesn't need an error code.
     LOCALIZATION: Do NOT localize "AspNetConfiguration", "Debug", "Release".
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 34f2984b55a..4616d75dcbe 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: Der Projektcache hat über die Methode {0} eine unbehandelte Ausnahme ausgelöst.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Fehler beim Verarbeiten eines Buildergebnisses für das folgende Projekt im Projektcache: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Projektcachetreffer für „{0}“ (Standardziele).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: Das Deaktivieren des In-Process-Knotens führt zu Leistungseinbußen bei der Verwendung von Projektcache-Plug-Ins, die Proxybuildanforderungen ausgeben.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Das Melden von Dateizugriffen wird derzeit nur mit der x64-Variante von MSBuild unterstützt.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Fehler bei SDK-Resolver: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">Assembly während {0}{1} geladen: {2} (Speicherort: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Die Aufgabe "{0}" hat {1} Kerne freigegeben und belegt jetzt insgesamt {2} Kerne.</target>
@@ -467,7 +482,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Dies ist eine nicht behandelte Ausnahme in MSBuild. RUFEN SIE EIN VORHANDENES PROBLEM AUF, ODER ERSTELLEN SIE EIN NEUES UNTER https://aka.ms/msbuild/unhandled
+        <target state="translated">Dies ist ein Ausnahmefehler in MSBuild. STIMMEN SIE EINEM VORHANDENEN ISSUE ZU, ODER ERSTELLEN SIE EIN NEUES ISSUE UNTER https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ad3fa5bce70..671bdf72929 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: la caché del proyecto inició una excepción no controlada desde el método {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: error en la caché del proyecto al controlar un resultado de compilación para el siguiente proyecto: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Acierto de caché de proyecto para "{0}" (destinos predeterminados).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: Al deshabilitar el nodo InProc, se degrada el rendimiento cuando use los complementos de caché de proyectos que emiten solicitudes de compilación de proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Los accesos a archivos de informes solo se admiten actualmente con el tipo x64 de MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Error del solucionador del SDK: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">Ensamblado cargado durante {0}{1}: {2} (ubicación: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tarea "{0}" liberó {1} núcleos y ahora retiene un total de {2} núcleos.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 62958ed7308..e7a631f6c8d 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: le cache de projet a levé une exception non gérée à partir de la méthode {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: le cache du projet a échoué lors de la gestion d’un résultat de build pour le projet suivant : {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Le cache de projet a été atteint pour « {0} » (cibles par défaut).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: la désactivation du nœud inproc entraîne une détérioration des performances lors de l’utilisation de plug-ins de cache de projet qui émettent des requêtes de build proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Les accès aux fichiers de création de rapports sont uniquement pris en charge à l’aide de la saveur x64 de MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Échec du Programme de Résolution SDK : «{0}»</target>
@@ -441,6 +451,11 @@
         <target state="translated">Assembly chargé pendant {0}{1}: {2} (emplacement : {3}, MVID : {4}, AppDomain : {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">La tâche "{0}" a libéré {1} cœur. Elle détient désormais {2} cœurs au total.</target>
@@ -467,7 +482,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Il s’agit d’une exception non gérée dans MSBuild –– VOTEZ POUR UN PROBLÈME EXISTANT OU ENTREZ UN NOUVEAU FICHIER À https://aka.ms/msbuild/unhandled.
+        <target state="translated">Il s’agit d’une exception non prise en charge dans MSBuild –– VOTEZ POUR UN PROBLÈME EXISTANT OU CRÉEZ-EN UN SUR https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index b78569055ff..2055daa2c3d 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: la cache del progetto ha generato un'eccezione non gestita dal metodo {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: errore della cache del progetto durante la gestione di un risultato di compilazione per il progetto seguente: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Riscontro nella cache del progetto per "{0}" (destinazioni predefinite).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: la disabilitazione del nodo InProc porta a una riduzione del livello delle prestazioni quando si usano plug-in della cache del progetto che emettono richieste di compilazione proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Gli accessi ai file di report sono attualmente supportati solo con la versione x64 di MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: errore sistema di risoluzione SDK: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">Assembly caricato durante {0}{1}: {2} (percorso: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">L'attività "{0}" ha rilasciato {1} core e ora contiene {2} core in totale.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 6b1cdb3452c..be831821dd6 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: プロジェクト キャッシュが {0} メソッドで処理されていない例外が返されました。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: 次のプロジェクトのビルド結果を処理中にプロジェクト キャッシュが失敗しました: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" のプロジェクト キャッシュ ヒット (既定のターゲット)。</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: プロキシ・ビルド要求を出すプロジェクト キャッシュ プラグインを使用する場合、InProc ノードを無効にするとパフォーマンスが低下します。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">ファイル アクセスのレポートは、現在、MSBuild の x64 フレーバーを使用してのみサポートされています。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK リゾルバー エラー: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">{0}{1} 中にアセンブリが読み込まれました: {2} (場所: {3}、MVID: {4}、AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">タスク "{0}" では、{1} 個のコアを解放したため、現在合計 {2} 個のコアを保持しています。</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 76064b46602..3cd4e210794 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: 프로젝트 캐시는 {0} 메서드에서 처리되지 않은 예외를 발생시켰습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: {0} 프로젝트에 대한 빌드 결과를 처리하는 동안 프로젝트 캐시가 실패했습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}"(기본 대상)에 대한 프로젝트 캐시 적중입니다.</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: 프록시 빌드 요청을 내보내는 프로젝트 캐시 플러그 인을 사용할 때 inproc 노드를 사용하지 않도록 설정하면 성능이 저하됩니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">파일 액세스 보고는 현재 x64 버전의 MSBuild를 사용하는 경우에만 지원됩니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK 해결 프로그램 오류: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">{0}{1} 동안 로드된 어셈블리: {2}(위치: {3}%1, MVID: {4}%2, AppDomain: {5}%2).</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" 작업에서 코어 {1}개를 해제했고 지금 총 {2}개의 코어를 보유하고 있습니다.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index a4ea3f9b1d4..7b2c611a924 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: pamięć podręczna projektu zgłosiła nieobsługiwany wyjątek z metody {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: pamięć podręczna projektu nie powiodła się podczas obsługi wyniku kompilacji dla następującego projektu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Trafienie pamięci podręcznej projektu dla „{0}” (domyślne elementy docelowe).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: wyłączenie węzła InProc prowadzi do obniżenia wydajności, gdy używane są wtyczki pamięci podręcznej projektu, które emitują żądania kompilowania serwera proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Raportowanie dostępu do plików jest obecnie obsługiwane tylko przy użyciu wersji x64 programu MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: niepowodzenia programu do rozpoznawania zestawu SDK: „{0}”</target>
@@ -441,6 +451,11 @@
         <target state="translated">Załadowano zestaw podczas {0}{1}: {2} (lokalizacja: {3}, MVID: {4}, domena aplikacji: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Zadanie „{0}” zwolniło rdzenie ({1}) i teraz jego łączna liczba rdzeni to {2}.</target>
@@ -467,7 +482,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Jest to nieobsługiwany wyjątek w aplikacji MSBuild -- ZAGŁOSUJ NA ISTNIEJĄCY PROBLEM LUB ZAGŁOSUJ NA NOWY NA https://aka.ms/msbuild/unhandled.
+        <target state="translated">Jest to nieobsługiwany wyjątek na platformie MSBuild -- ZAGŁOSUJ NA ISTNIEJĄCY PROBLEM LUB ZAREJESTRUJ NOWY W WITRYNIE https://aka.ms/msbuild/unhandled.
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 6ca0dd891e9..ea04d333e5d 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: O cache do projeto lançou uma exceção sem tratamento do método {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: O cache do projeto falhou ao manipular um resultado de construção para o seguinte projeto: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Acerto de cache do projeto para "{0}" (destinos padrão).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: desativar o nó inproc leva à degradação do desempenho ao usar plug-ins de cache de projeto que emitem solicitações de construção de proxy.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Atualmente, o relatório de acessos a arquivos só tem suporte usando o tipo x64 do MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: Falha no Resolvedor do SDK: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">Montagem carregada durante {0}{1}: {2} (localização: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">A tarefa "{0}" liberou {1} núcleos e agora contém {2} núcleos no total.</target>
@@ -467,7 +482,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Esta é uma exceção não tratada no MSBuild -- POR FAVOR, APOIE UM PROBLEMA EXISTENTE OU ARQUIVE UM NOVO EM https://aka.ms/msbuild/unhandled
+        <target state="translated">Essa é uma exceção não tratada no MSBuild -- POR FAVOR, ATUALIZE UMA QUESTÃO EXISTENTE OU ENCAMINHE UMA NOVA EM https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index d54d3bca5a4..3faef9b03aa 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: в кэше проектов возникло необработанное исключение из метода {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: сбой кэша проекта при обработке результата сборки для следующего проекта: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">Попадание в кэше проекта для "{0}" (целевые объекты по умолчанию).</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: Отключение внутрипроцессного узла приводит к замедлению при использовании плагинов кэша проекта, которые создают запросы на сборку прокси-сервера.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Доступ к файлам отчетов сейчас поддерживается только при использовании 64-разрядного варианта приложения MSBuild.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: сбой сопоставителя SDK: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">Сборка загружена во время {0}{1}: {2} (расположение: {3}, MVID: {4}, домен приложения: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">Задача "{0}" освободила указанное число ядер ({1}). Теперь общее число ядер, которыми располагает задача, равно {2}.</target>
@@ -467,7 +482,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Это необработанное исключение в MSBuild. Проголосуйте за существующую проблему или сообщите о новой по адресу https://aka.ms/msbuild/unhandled
+        <target state="translated">Это необработанное исключение в MSBuild. ПРОГОЛОСУЙТЕ ЗА СУЩЕСТВУЮЩУЮ ПРОБЛЕМУ ИЛИ СООБЩИТЕ О НОВУЙ НА https://aka.ms/msbuild/unhandled
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 2d211d40f45..e6317e377a8 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: Proje önbelleği {0} yönteminden yakalanamayan özel durum oluşturdu.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: Proje önbelleği şu proje için bir derleme sonucu işlenirken başarısız oldu: {0}.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" (varsayılan hedefler) için proje önbelleği isabeti.</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: InProc düğümünün devre dışı bırakılması, ara sunucu oluşturma istekleri gönderen proje önbelleği eklentileri kullanılırken performans düşüşüne yol açar.</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">Raporlama dosyası erişimleri şu anda yalnızca MSBuild x64 varyantı kullanıldığında destekleniyor.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK Çözümleyici Hatası: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">Derleme {0}{1} sırasında yüklendi: {2} (konum: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">"{0}" görevi {1} çekirdeği serbest bıraktı. Şu anda toplam {2} çekirdek tutuyor.</target>
@@ -467,7 +482,7 @@
       <trans-unit id="UnhandledMSBuildError">
         <source>This is an unhandled exception in MSBuild -- PLEASE UPVOTE AN EXISTING ISSUE OR FILE A NEW ONE AT https://aka.ms/msbuild/unhandled
     {0}</source>
-        <target state="translated">Bu, MSBuild'de işlenmeyen bir istisnadır -- LÜTFEN MEVCUT BİR SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESİNDE YENİ BİR SORUN DOSYALAYIN
+        <target state="translated">Bu, MSBuild'de işlenmeyen bir istisnadır -- LÜTFEN MEVCUT BİR SORUNU OYLAYIN VEYA https://aka.ms/msbuild/unhandled ADRESİNDE YENİ BİR SORUN OLUŞTURUN
     {0}</target>
         <note />
       </trans-unit>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 1d2c6843628..b4952f0e205 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: 项目缓存从 {0} 方法引发了未经处理的异常。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: 处理以下项目的生成结果时，项目缓存失败: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">项目缓存命中 "{0}" (默认目标)。</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: 使用发出代理构建请求的项目缓存插件时，禁用 inproc 节点会导致性能下降。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">当前仅支持使用 x64 风格的 MSBuild 来报告文件访问情况。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK 解析程序失败: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">程序集加载期间 {0}{1}: {2} (位置: {3}, MVID: {4}, AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">任务“{0}”发布了 {1} 个核心，现总共包含 {2} 个核心。</target>
@@ -2396,7 +2411,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</source>
       </trans-unit>
       <trans-unit id="InvalidSdkFormat">
         <source>MSB4229: The value "{0}" is not valid for an Sdk specification. The attribute should be a semicolon-delimited list of Sdk-name/minimum-version pairs, separated by a forward slash.</source>
-        <target state="translated">MSB4229: 值“{0}”对 Sdk 规范无效。此属性应该是以分号分隔的Sdk-name/minimum-version 对（用正斜杠分隔）的列表。</target>
+        <target state="translated">MSB4229: 值“{0}”对 Sdk 规范无效。此属性应该是以分号分隔的Sdk-name/minimum-version 对 (用正斜杠分隔) 的列表。</target>
         <note>{StrBegin="MSB4229: "}</note>
       </trans-unit>
       <trans-unit id="TaskInstantiationFailureNotSupported">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index c073146888d..5111576884b 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -264,6 +264,11 @@
         <target state="translated">MSB4273: 專案快取從 {0} 方法擲回未處理的例外狀況。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ProjectCacheHandleBuildResultFailed">
+        <source>MSB4269: The project cache failed while handling a build result for the following project: {0}.</source>
+        <target state="translated">MSB4269: 處理下列專案的組建結果時，專案快取失敗: {0}。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectCacheHitWithDefaultTargets">
         <source>Project cache hit for "{0}" (default targets).</source>
         <target state="translated">"{0}" 的專案快取命中 (預設目標)。</target>
@@ -370,6 +375,11 @@
         <target state="translated">MSB4274: 停用 inproc 節點會在使用可發出 proxy 組建要求的專案快取外掛程式時，導致效能降低。</target>
         <note />
       </trans-unit>
+      <trans-unit id="ReportFileAccessesX64Only">
+        <source>Reporting file accesses is only currently supported using the x64 flavor of MSBuild.</source>
+        <target state="translated">目前只支援使用 MSBuild 的 x64 變體來報告檔案存取。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SDKResolverCriticalFailure">
         <source>MSB4242: SDK Resolver Failure: "{0}"</source>
         <target state="translated">MSB4242: SDK 解析程式失敗: "{0}"</target>
@@ -441,6 +451,11 @@
         <target state="translated">組件在 {0}{1} 期間載入: {2} (位置: {3}，MVID: {4}，AppDomain: {5})</target>
         <note />
       </trans-unit>
+      <trans-unit id="TaskAssemblyLoadedWithAssemblyLoadContext">
+        <source>Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</source>
+        <target state="new">Assembly loaded during {0}{1}: {2} (location: {3}, MVID: {4}, AssemblyLoadContext: {5})</target>
+        <note />
+      </trans-unit>
       <trans-unit id="TaskReleasedCores">
         <source>Task "{0}" released {1} cores and now holds {2} cores total.</source>
         <target state="translated">工作 "{0}" 已發行 {1} 個核心，現在共保留 {2} 個核心。</target>
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index d136a2607c9..0352fbf056b 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -117,4 +117,9 @@
     <FeatureMSIORedist>true</FeatureMSIORedist>
   </PropertyGroup>
 
+  <PropertyGroup Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">
+    <DefineConstants>$(DefineConstants);FEATURE_REPORTFILEACCESSES</DefineConstants>
+    <FeatureReportFileAccesses>true</FeatureReportFileAccesses>
+  </PropertyGroup>
+
 </Project>
diff --git a/src/Framework/AssemblyLoadBuildEventArgs.cs b/src/Framework/AssemblyLoadBuildEventArgs.cs
index 4c6c8292cbc..767772f5fc8 100644
--- a/src/Framework/AssemblyLoadBuildEventArgs.cs
+++ b/src/Framework/AssemblyLoadBuildEventArgs.cs
@@ -20,7 +20,7 @@ public AssemblyLoadBuildEventArgs(
             AssemblyLoadingContext loadingContext,
             string? loadingInitiator,
             string? assemblyName,
-            string assemblyPath,
+            string? assemblyPath,
             Guid mvid,
             string? customAppDomainDescriptor,
             MessageImportance importance = MessageImportance.Low)
@@ -39,7 +39,8 @@ public AssemblyLoadBuildEventArgs(
         public string? AssemblyName { get; private set; }
         public string? AssemblyPath { get; private set; }
         public Guid MVID { get; private set; }
-        // Null string indicates that load occurred on Default AppDomain (for both Core and Framework).
+        // Null string indicates that load occurred on Default AppDomain (for Framework).
+        // For Core, string won't be null.
         public string? AppDomainDescriptor { get; private set; }
 
         internal override void WriteToStream(BinaryWriter writer)
@@ -77,7 +78,12 @@ public override string Message
                 if (RawMessage == null)
                 {
                     string? loadingInitiator = LoadingInitiator == null ? null : $" ({LoadingInitiator})";
-                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword("TaskAssemblyLoaded", LoadingContext.ToString(), loadingInitiator, AssemblyName, AssemblyPath, MVID.ToString(), AppDomainDescriptor ?? DefaultAppDomainDescriptor);
+#if FEATURE_ASSEMBLYLOADCONTEXT
+                    string resourceName = "TaskAssemblyLoadedWithAssemblyLoadContext";
+#else
+                    string resourceName = "TaskAssemblyLoaded";
+#endif
+                    RawMessage = FormatResourceStringIgnoreCodeAndKeyword(resourceName, LoadingContext.ToString(), loadingInitiator, AssemblyName, AssemblyPath, MVID.ToString(), AppDomainDescriptor ?? DefaultAppDomainDescriptor);
                 }
 
                 return RawMessage;
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 995cfebfbc7..550f487f8ab 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -172,6 +172,9 @@ public void Translate(ref int value)
                 value = _reader.ReadInt32();
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref uint unsignedInteger) => unsignedInteger = _reader.ReadUInt32();
+
             /// <summary>
             /// Translates an <see langword="int"/> array.
             /// </summary>
@@ -420,7 +423,6 @@ public void Translate(ref BuildEventContext value)
                     _reader.ReadInt32(),
                     _reader.ReadInt32());
             }
-
 #endif
 
             /// <summary>
@@ -501,12 +503,6 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                {
-                    TranslateDotNet<Exception>(ref value);
-                    return;
-                }
-
                 if (!TranslateNullable(value))
                 {
                     return;
@@ -884,6 +880,9 @@ public void Translate(ref int value)
                 _writer.Write(value);
             }
 
+            /// <inheritdoc/>
+            public void Translate(ref uint unsignedInteger) => _writer.Write(unsignedInteger);
+
             /// <summary>
             /// Translates an <see langword="int"/> array.
             /// </summary>
@@ -1108,7 +1107,6 @@ public void Translate(ref BuildEventContext value)
                 _writer.Write(value.TargetId);
                 _writer.Write(value.TaskId);
             }
-
 #endif 
 
             /// <summary>
@@ -1155,12 +1153,6 @@ public void TranslateDotNet<T>(ref T value)
 
             public void TranslateException(ref Exception value)
             {
-                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
-                {
-                    TranslateDotNet<Exception>(ref value);
-                    return;
-                }
-
                 if (!TranslateNullable(value))
                 {
                     return;
diff --git a/src/Framework/BuildStartedEventArgs.cs b/src/Framework/BuildStartedEventArgs.cs
index d4c2882c4f9..09073ee9540 100644
--- a/src/Framework/BuildStartedEventArgs.cs
+++ b/src/Framework/BuildStartedEventArgs.cs
@@ -53,7 +53,7 @@ public BuildStartedEventArgs(
         public BuildStartedEventArgs(
             string? message,
             string? helpKeyword,
-            IDictionary<string, string> environmentOfBuild)
+            IDictionary<string, string>? environmentOfBuild)
             : this(message, helpKeyword, DateTime.UtcNow)
         {
             environmentOnBuildStart = environmentOfBuild;
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 00507237987..1f925324acf 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -27,7 +27,8 @@ internal class ChangeWaves
         internal static readonly Version Wave17_4 = new Version(17, 4);
         internal static readonly Version Wave17_6 = new Version(17, 6);
         internal static readonly Version Wave17_8 = new Version(17, 8);
-        internal static readonly Version[] AllWaves = { Wave17_4, Wave17_6, Wave17_8 };
+        internal static readonly Version Wave17_10 = new Version(17, 10);
+        internal static readonly Version[] AllWaves = { Wave17_4, Wave17_6, Wave17_8, Wave17_10 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/CompatibilitySuppressions.xml b/src/Framework/CompatibilitySuppressions.xml
index 1c5e56d19a3..aedfd3e3845 100644
--- a/src/Framework/CompatibilitySuppressions.xml
+++ b/src/Framework/CompatibilitySuppressions.xml
@@ -1,6 +1,287 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- Suppressions for api differences between main and vs17.8 when merging vs17.8 into main -->
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.DesiredAccess</Target>
+    <Left>lib/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FileAccessData</Target>
+    <Left>lib/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FlagsAndAttributes</Target>
+    <Left>lib/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ProcessData</Target>
+    <Left>lib/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ReportedFileOperation</Target>
+    <Left>lib/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.RequestedAccess</Target>
+    <Left>lib/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.DesiredAccess</Target>
+    <Left>lib/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FileAccessData</Target>
+    <Left>lib/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FlagsAndAttributes</Target>
+    <Left>lib/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ProcessData</Target>
+    <Left>lib/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ReportedFileOperation</Target>
+    <Left>lib/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.RequestedAccess</Target>
+    <Left>lib/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.DesiredAccess</Target>
+    <Left>ref/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FileAccessData</Target>
+    <Left>ref/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FlagsAndAttributes</Target>
+    <Left>ref/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ProcessData</Target>
+    <Left>ref/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ReportedFileOperation</Target>
+    <Left>ref/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.RequestedAccess</Target>
+    <Left>ref/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.DesiredAccess</Target>
+    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FileAccessData</Target>
+    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FlagsAndAttributes</Target>
+    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ProcessData</Target>
+    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ReportedFileOperation</Target>
+    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.RequestedAccess</Target>
+    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.DesiredAccess</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FileAccessData</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.FlagsAndAttributes</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ProcessData</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.ReportedFileOperation</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Framework.FileAccess.RequestedAccess</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>F:Microsoft.Build.Framework.EngineServices.Version2</Target>
+    <Left>lib/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Framework.EngineServices.ReportFileAccess(Microsoft.Build.Framework.FileAccess.FileAccessData)</Target>
+    <Left>lib/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>F:Microsoft.Build.Framework.EngineServices.Version2</Target>
+    <Left>lib/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Framework.EngineServices.ReportFileAccess(Microsoft.Build.Framework.FileAccess.FileAccessData)</Target>
+    <Left>lib/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>F:Microsoft.Build.Framework.EngineServices.Version2</Target>
+    <Left>ref/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Framework.EngineServices.ReportFileAccess(Microsoft.Build.Framework.FileAccess.FileAccessData)</Target>
+    <Left>ref/net472/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>F:Microsoft.Build.Framework.EngineServices.Version2</Target>
+    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Framework.EngineServices.ReportFileAccess(Microsoft.Build.Framework.FileAccess.FileAccessData)</Target>
+    <Left>ref/net8.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>F:Microsoft.Build.Framework.EngineServices.Version2</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0002</DiagnosticId>
+    <Target>M:Microsoft.Build.Framework.EngineServices.ReportFileAccess(Microsoft.Build.Framework.FileAccess.FileAccessData)</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Framework.dll</Left>
+    <Right>ref/netstandard2.0/Microsoft.Build.Framework.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
        (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
@@ -54,9 +335,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-  <!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Framework/CustomBuildEventArgs.cs b/src/Framework/CustomBuildEventArgs.cs
index 3310b398844..9cd1892a7aa 100644
--- a/src/Framework/CustomBuildEventArgs.cs
+++ b/src/Framework/CustomBuildEventArgs.cs
@@ -10,12 +10,10 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Arguments for custom build events.
     /// </summary>
-    // WARNING: marking a type [Serializable] without implementing
-    // ISerializable imposes a serialization contract -- it is a
-    // promise to never change the type's fields i.e. the type is
-    // immutable; adding new fields in the next version of the type
-    // without following certain special FX guidelines, can break both
-    // forward and backward compatibility
+    /// <remarks>
+    /// In MSBuild 17.8 and later, this type is deprecated; instead use <see cref="ExtendedCustomBuildEventArgs"/>.
+    /// For more information, see <see href="https://learn.microsoft.com/dotnet/core/compatibility/sdk/8.0/custombuildeventargs"/>
+    /// </remarks>
     [Serializable]
     public abstract class CustomBuildEventArgs : LazyFormattedBuildEventArgs
     {
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
index 271bc7d33c7..491604c7827 100644
--- a/src/Framework/EngineServices.cs
+++ b/src/Framework/EngineServices.cs
@@ -21,10 +21,13 @@ public abstract class EngineServices
         public const int Version1 = 1;
 
         /// <summary>
-        /// An explicit version of this class. Must be incremented whenever new members are added. Derived classes should override
-        /// the property to return the version actually being implemented.
+        /// Gets an explicit version of this class.
         /// </summary>
-        public virtual int Version => Version1; // Not updated since we have not shipped 17.0 yet. This comment is meant to bypass RequiredVersionBumps check in build.ps1 for PR #470646. If the changes in the file are cosmetic, change PR# in this comment to silence the build error on CI build.
+        /// <remarks>
+        /// Must be incremented whenever new members are added. Derived classes should override
+        /// the property to return the version actually being implemented.
+        /// </remarks>
+        public virtual int Version => Version1;
 
         /// <summary>
         /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
diff --git a/src/Framework/ExtendedBuildErrorEventArgs.cs b/src/Framework/ExtendedBuildErrorEventArgs.cs
index 85d10939236..e5830592b6c 100644
--- a/src/Framework/ExtendedBuildErrorEventArgs.cs
+++ b/src/Framework/ExtendedBuildErrorEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedBuildErrorEventArgs : BuildErrorEventArgs, IExtended
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedBuildMessageEventArgs.cs b/src/Framework/ExtendedBuildMessageEventArgs.cs
index 53ec510c8da..6330a502050 100644
--- a/src/Framework/ExtendedBuildMessageEventArgs.cs
+++ b/src/Framework/ExtendedBuildMessageEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedBuildMessageEventArgs : BuildMessageEventArgs, IExte
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedBuildWarningEventArgs.cs b/src/Framework/ExtendedBuildWarningEventArgs.cs
index 9481d2bfbdc..88eaf08af0d 100644
--- a/src/Framework/ExtendedBuildWarningEventArgs.cs
+++ b/src/Framework/ExtendedBuildWarningEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedBuildWarningEventArgs : BuildWarningEventArgs, IExte
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/ExtendedCustomBuildEventArgs.cs b/src/Framework/ExtendedCustomBuildEventArgs.cs
index 0669c025843..8a20c512923 100644
--- a/src/Framework/ExtendedCustomBuildEventArgs.cs
+++ b/src/Framework/ExtendedCustomBuildEventArgs.cs
@@ -18,7 +18,7 @@ public sealed class ExtendedCustomBuildEventArgs : CustomBuildEventArgs, IExtend
     public string ExtendedType { get; set; }
 
     /// <inheritdoc />
-    public Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    public IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <inheritdoc />
     public string? ExtendedData { get; set; }
diff --git a/src/Framework/IExtendedBuildEventArgs.cs b/src/Framework/IExtendedBuildEventArgs.cs
index 0c73ddb914f..83b4c3ba555 100644
--- a/src/Framework/IExtendedBuildEventArgs.cs
+++ b/src/Framework/IExtendedBuildEventArgs.cs
@@ -22,7 +22,7 @@ public interface IExtendedBuildEventArgs
     ///   - data which needed in custom code to properly routing this message without interpreting/deserializing <see cref="ExtendedData"/>.
     ///   - simple extended data can be transferred in form of dictionary key-value per one extended property.
     /// </summary>
-    Dictionary<string, string?>? ExtendedMetadata { get; set; }
+    IDictionary<string, string?>? ExtendedMetadata { get; set; }
 
     /// <summary>
     /// Transparent data as string.
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index 930cc45f6b2..8d267351591 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -134,6 +134,12 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref int value);
 
+        /// <summary>
+        /// Translates an unsigned integer.
+        /// </summary>
+        /// <param name="unsignedInteger">The unsigned integer to translate.</param>
+        void Translate(ref uint unsignedInteger);
+
         /// <summary>
         /// Translates an <see langword="int"/> array.
         /// </summary>
@@ -233,8 +239,7 @@ BinaryWriter Writer
         /// </remarks>
         /// <param name="value">The context to be translated.</param>
         void Translate(ref BuildEventContext value);
-
-#endif 
+#endif
 
         /// <summary>
         /// Translates an enumeration.
diff --git a/src/MSBuild/TerminalLogger/AnsiCodes.cs b/src/Framework/Logging/AnsiCodes.cs
similarity index 100%
rename from src/MSBuild/TerminalLogger/AnsiCodes.cs
rename to src/Framework/Logging/AnsiCodes.cs
diff --git a/src/MSBuild/TerminalLogger/TerminalColor.cs b/src/Framework/Logging/TerminalColor.cs
similarity index 85%
rename from src/MSBuild/TerminalLogger/TerminalColor.cs
rename to src/Framework/Logging/TerminalColor.cs
index 683b4d683b8..55b63e915ac 100644
--- a/src/MSBuild/TerminalLogger/TerminalColor.cs
+++ b/src/Framework/Logging/TerminalColor.cs
@@ -4,7 +4,7 @@
 namespace Microsoft.Build.Logging.TerminalLogger;
 
 /// <summary>
-/// Enumerates the text colors supported by <see cref="ITerminal"/>.
+/// Enumerates the text colors supported by VT100 terminal.
 /// </summary>
 internal enum TerminalColor
 {
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 29e9e67abfb..a5dbe84a3ee 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -661,6 +661,18 @@ public void MSBuildServerBuildStop(string commandLine, int countOfConsoleMessage
         {
             WriteEvent(90, commandLine, countOfConsoleMessages, sumSizeOfConsoleMessages, clientExitType, serverExitType);
         }
+
+        [Event(91, Keywords = Keywords.All)]
+        public void ProjectCacheHandleBuildResultStart(string pluginTypeName, string projectPath, string targets)
+        {
+            WriteEvent(91, pluginTypeName, projectPath, targets);
+        }
+
+        [Event(92, Keywords = Keywords.All)]
+        public void ProjectCacheHandleBuildResultStop(string pluginTypeName, string projectPath, string targets)
+        {
+            WriteEvent(92, pluginTypeName, projectPath, targets);
+        }
         #endregion
     }
 }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 724e1a38496..c0da0474e6c 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -15,10 +15,6 @@
     <PackageReference Include="Microsoft.CodeAnalysis.Collections" PrivateAssets="all" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <PackageReference Include="System.Security.Permissions" />
-  </ItemGroup>
-
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <!-- Promote CompilerServices.Unsafe from the old version we get from System.Memory on net472. -->
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index c71d9f49ff6..d30a8ec85f5 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -35,6 +35,7 @@ internal static class NativeMethods
     internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
     internal const uint FILE_TYPE_CHAR = 0x0002;
     internal const Int32 STD_OUTPUT_HANDLE = -11;
+    internal const Int32 STD_ERROR_HANDLE = -12;
     internal const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;
     internal const uint RPC_S_CALLPENDING = 0x80010115;
     internal const uint E_ABORT = (uint)0x80004004;
@@ -76,6 +77,12 @@ internal static class NativeMethods
 
     #region Enums
 
+    internal enum StreamHandleType
+    {
+        StdOut = STD_OUTPUT_HANDLE,
+        StdErr = STD_ERROR_HANDLE,
+    };
+
     private enum PROCESSINFOCLASS : int
     {
         ProcessBasicInformation = 0,
@@ -1300,7 +1307,7 @@ internal static int GetParentProcessId(int processId)
                 // using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
                 // and could be again when FileUtilities moves to Framework
 
-                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, FileAccess.Read);
+                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, System.IO.FileAccess.Read);
                 using StreamReader r = new(fileStream);
 
                 line = r.ReadLine();
@@ -1481,11 +1488,11 @@ internal static void VerifyThrowWin32Result(int result)
     }
 
 #if !CLR2COMPATIBILITY
-    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes()
+    internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalConsoleMode) QueryIsScreenAndTryEnableAnsiColorCodes(StreamHandleType handleType = StreamHandleType.StdOut)
     {
         if (Console.IsOutputRedirected)
         {
-            // There's no ANSI terminal support is console output is redirected.
+            // There's no ANSI terminal support if console output is redirected.
             return (acceptAnsiColorCodes: false, outputIsScreen: false, originalConsoleMode: null);
         }
 
@@ -1496,8 +1503,8 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         {
             try
             {
-                IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
-                if (GetConsoleMode(stdOut, out uint consoleMode))
+                IntPtr outputStream = GetStdHandle((int)handleType);
+                if (GetConsoleMode(outputStream, out uint consoleMode))
                 {
                     if ((consoleMode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING)
                     {
@@ -1508,7 +1515,7 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
                     {
                         originalConsoleMode = consoleMode;
                         consoleMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
-                        if (SetConsoleMode(stdOut, consoleMode) && GetConsoleMode(stdOut, out consoleMode))
+                        if (SetConsoleMode(outputStream, consoleMode) && GetConsoleMode(outputStream, out consoleMode))
                         {
                             // We only know if vt100 is supported if the previous call actually set the new flag, older
                             // systems ignore the setting.
@@ -1516,7 +1523,7 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
                         }
                     }
 
-                    uint fileType = GetFileType(stdOut);
+                    uint fileType = GetFileType(outputStream);
                     // The std out is a char type (LPT or Console).
                     outputIsScreen = fileType == FILE_TYPE_CHAR;
                     acceptAnsiColorCodes &= outputIsScreen;
@@ -1537,11 +1544,11 @@ internal static (bool acceptAnsiColorCodes, bool outputIsScreen, uint? originalC
         return (acceptAnsiColorCodes, outputIsScreen, originalConsoleMode);
     }
 
-    internal static void RestoreConsoleMode(uint? originalConsoleMode)
+    internal static void RestoreConsoleMode(uint? originalConsoleMode, StreamHandleType handleType = StreamHandleType.StdOut)
     {
         if (IsWindows && originalConsoleMode is not null)
         {
-            IntPtr stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
+            IntPtr stdOut = GetStdHandle((int)handleType);
             _ = SetConsoleMode(stdOut, originalConsoleMode.Value);
         }
     }
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 539fae2b5e1..eba6c9ac5ab 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -76,11 +76,11 @@ public ProjectStartedEventArgs(
             int projectId,
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
-            BuildEventContext parentBuildEventContext)
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
+            BuildEventContext? parentBuildEventContext)
             : this(projectId, message, helpKeyword, projectFile, targetNames, properties, items, parentBuildEventContext, DateTime.UtcNow)
         {
         }
@@ -103,13 +103,13 @@ public ProjectStartedEventArgs(
             int projectId,
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
-            BuildEventContext parentBuildEventContext,
-            IDictionary<string, string> globalProperties,
-            string toolsVersion)
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
+            BuildEventContext? parentBuildEventContext,
+            IDictionary<string, string>? globalProperties,
+            string? toolsVersion)
             : this(projectId, message, helpKeyword, projectFile, targetNames, properties, items, parentBuildEventContext)
         {
             this.GlobalProperties = globalProperties;
@@ -130,10 +130,10 @@ public ProjectStartedEventArgs(
         public ProjectStartedEventArgs(
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
             DateTime eventTimestamp)
             : base(message, helpKeyword, "MSBuild", eventTimestamp)
         {
@@ -160,11 +160,11 @@ public ProjectStartedEventArgs(
             int projectId,
             string message,
             string helpKeyword,
-            string projectFile,
-            string targetNames,
-            IEnumerable properties,
-            IEnumerable items,
-            BuildEventContext parentBuildEventContext,
+            string? projectFile,
+            string? targetNames,
+            IEnumerable? properties,
+            IEnumerable? items,
+            BuildEventContext? parentBuildEventContext,
             DateTime eventTimestamp)
             : this(message, helpKeyword, projectFile, targetNames, properties, items, eventTimestamp)
         {
diff --git a/src/Framework/ResponseFileUsedEventArgs.cs b/src/Framework/ResponseFileUsedEventArgs.cs
index bc027518a67..7e9f132a262 100644
--- a/src/Framework/ResponseFileUsedEventArgs.cs
+++ b/src/Framework/ResponseFileUsedEventArgs.cs
@@ -17,7 +17,7 @@ public ResponseFileUsedEventArgs()
         /// <summary>
         /// Initialize a new instance of the ResponseFileUsedEventArgs class.
         /// </summary>
-        public ResponseFileUsedEventArgs(string responseFilePath) : base()
+        public ResponseFileUsedEventArgs(string? responseFilePath) : base()
         {
             ResponseFilePath = responseFilePath;
         }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 9be74ea1bc8..04b2fc90237 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -188,6 +188,11 @@ internal class EscapeHatches
         /// </summary>
         public readonly bool AlwaysDoImmutableFilesUpToDateCheck = Environment.GetEnvironmentVariable("MSBUILDDONOTCACHEMODIFICATIONTIME") == "1";
 
+        /// <summary>
+        /// When copying over an existing file, copy directly into the existing file rather than deleting and recreating.
+        /// </summary>
+        public readonly bool CopyWithoutDelete = Environment.GetEnvironmentVariable("MSBUILDCOPYWITHOUTDELETE") == "1";
+
         /// <summary>
         /// Emit events for project imports.
         /// </summary>
@@ -395,6 +400,27 @@ public bool EnableWarningOnCustomBuildEvent
             }
         }
 
+        private bool? _isBinaryFormatterSerializationAllowed;
+        public bool IsBinaryFormatterSerializationAllowed
+        {
+            get
+            {
+                if (!_isBinaryFormatterSerializationAllowed.HasValue)
+                {
+#if RUNTIME_TYPE_NETCORE
+                    AppContext.TryGetSwitch("System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization",
+                        out bool enabled);
+                    _isBinaryFormatterSerializationAllowed = enabled;
+#else
+                    _isBinaryFormatterSerializationAllowed = true;
+#endif
+                }
+
+                return _isBinaryFormatterSerializationAllowed.Value;
+            }
+        }
+
+
         private static bool? ParseNullableBoolFromEnvironmentVariable(string environmentVariable)
         {
             var value = Environment.GetEnvironmentVariable(environmentVariable);
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 4e1dddaf992..a3f744978d0 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
+using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
@@ -499,6 +500,60 @@ public void PreprocessSwitchIdentificationTests(string preprocess)
             unquoteParameters.ShouldBeTrue();
         }
 
+        [Fact]
+        public void GetPropertySwitchIdentificationTest()
+        {
+            CommandLineSwitches.IsParameterizedSwitch(
+                "getProperty",
+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
+                out string duplicateSwitchErrorMessage,
+                out bool multipleParametersAllowed,
+                out string missingParametersErrorMessage,
+                out _,
+                out _);
+
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetProperty);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();
+        }
+
+        [Fact]
+        public void GetItemSwitchIdentificationTest()
+        {
+            CommandLineSwitches.IsParameterizedSwitch(
+                "getItem",
+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
+                out string duplicateSwitchErrorMessage,
+                out bool multipleParametersAllowed,
+                out string missingParametersErrorMessage,
+                out _,
+                out _);
+
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetItem);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();
+        }
+
+        [Fact]
+        public void GetTargetResultSwitchIdentificationTest()
+        {
+            CommandLineSwitches.IsParameterizedSwitch(
+                "getTargetResult",
+                out CommandLineSwitches.ParameterizedSwitch parameterizedSwitch,
+                out string duplicateSwitchErrorMessage,
+                out bool multipleParametersAllowed,
+                out string missingParametersErrorMessage,
+                out _,
+                out _);
+
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GetTargetResult);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNullOrEmpty();
+        }
+
         [Theory]
         [InlineData("targets")]
         [InlineData("tArGeTs")]
@@ -1042,6 +1097,7 @@ public void InvalidToolsVersionErrors()
                     filename = FileUtilities.GetTemporaryFileName();
                     ProjectRootElement project = ProjectRootElement.Create();
                     project.Save(filename);
+                    BuildResult buildResult = null;
                     MSBuildApp.BuildProject(
                                         filename,
                                         null,
@@ -1073,6 +1129,11 @@ public void InvalidToolsVersionErrors()
                                         question: false,
                                         inputResultsCaches: null,
                                         outputResultsCache: null,
+                                        saveProjectResult: false,
+                                        ref buildResult,
+#if FEATURE_REPORTFILEACCESSES
+                                        reportFileAccesses: false,
+#endif
                                         commandLine: null);
                 }
                 finally
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index 80584359edd..ed9f0458fba 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -6,17 +6,20 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
+using System.Text;
 using System.Text.RegularExpressions;
 using System.Threading;
 using System.Threading.Tasks;
-
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Logging;
 using Microsoft.Build.Logging.TerminalLogger;
-
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
 using VerifyTests;
 using VerifyXunit;
 using Xunit;
-
 using static VerifyXunit.Verifier;
 
 namespace Microsoft.Build.UnitTests
@@ -236,10 +239,10 @@ public Task PrintBuildSummary_Failed()
         [Fact]
         public Task PrintBuildSummary_FailedWithErrors()
         {
-           InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
-           {
-               ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
-           });
+            InvokeLoggerCallbacksForSimpleProject(succeeded: false, () =>
+            {
+                ErrorRaised?.Invoke(_eventSender, MakeErrorEventArgs("Error!"));
+            });
 
             return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
         }
@@ -285,5 +288,68 @@ public async Task DisplayNodesOverwritesWithNewTargetFramework()
 
             await Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
         }
+
+        [Fact]
+        public void TestTerminalLoggerTogetherWithOtherLoggers()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            { 
+                string contents = @"
+<Project>
+    <ItemGroup>
+        <Compile Include=""MyItem1.cs"" />
+        <Compile Include=""MyItem2.cs"" />
+    </ItemGroup>
+    <PropertyGroup>
+        <MyProp1>MyProperty1</MyProp1>
+    </PropertyGroup>
+    <Target Name = ""Build"">
+        <Message Text = ""Build target is executing."" Importance = ""High"" />
+    </Target>
+</Project>";
+                TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
+                TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
+
+                BinaryLogger loggerWithTL = new();
+                string logFileWithTL = env.ExpectFile(".binlog").Path;
+                loggerWithTL.Parameters = logFileWithTL;
+
+                BinaryLogger loggerWithoutTL = new();
+                string logFileWithoutTL = env.ExpectFile(".binlog").Path;
+                loggerWithoutTL.Parameters = logFileWithoutTL;
+
+                // Execute MSBuild with binary, file and terminal loggers
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} /m /bl:{logFileWithTL} -flp:logfile={Path.Combine(logFolder.Path, "logFileWithTL.log")};verbosity=diagnostic -tl:on", out bool success);
+                success.ShouldBeTrue();
+
+                // Execute MSBuild with binary and file loggers
+                RunnerUtilities.ExecMSBuild($"{projectFile.Path} /m /bl:{logFileWithoutTL} -flp:logfile={Path.Combine(logFolder.Path, "logFileWithoutTL.log")};verbosity=diagnostic", out success);
+                success.ShouldBeTrue();
+
+                // Read the binary log and replay into mockLogger
+                var mockLogFromPlaybackWithTL = new MockLogger();
+                var binaryLogReaderWithTL = new BinaryLogReplayEventSource();
+                mockLogFromPlaybackWithTL.Initialize(binaryLogReaderWithTL);
+
+                var mockLogFromPlaybackWithoutTL = new MockLogger();
+                var binaryLogReaderWithoutTL = new BinaryLogReplayEventSource();
+                mockLogFromPlaybackWithoutTL.Initialize(binaryLogReaderWithoutTL);
+
+                binaryLogReaderWithTL.Replay(logFileWithTL);
+                binaryLogReaderWithoutTL.Replay(logFileWithoutTL);
+
+                // Check that amount of events, warnings, errors is equal in both cases. Presence of other loggers should not change behavior
+                mockLogFromPlaybackWithoutTL.Errors.Count.ShouldBe(mockLogFromPlaybackWithTL.Errors.Count);
+                mockLogFromPlaybackWithoutTL.Warnings.Count.ShouldBe(mockLogFromPlaybackWithTL.Warnings.Count);
+                mockLogFromPlaybackWithoutTL.AllBuildEvents.Count.ShouldBe(mockLogFromPlaybackWithTL.AllBuildEvents.Count);
+
+                // Check presence of some items and properties and that they have at least 1 item and property
+                mockLogFromPlaybackWithoutTL.EvaluationFinishedEvents.ShouldContain(x => (x.Items != null) && x.Items.GetEnumerator().MoveNext());
+                mockLogFromPlaybackWithTL.EvaluationFinishedEvents.ShouldContain(x => (x.Items != null) && x.Items.GetEnumerator().MoveNext());
+
+                mockLogFromPlaybackWithoutTL.EvaluationFinishedEvents.ShouldContain(x => (x.Properties != null) && x.Properties.GetEnumerator().MoveNext());
+                mockLogFromPlaybackWithTL.EvaluationFinishedEvents.ShouldContain(x => (x.Properties != null) && x.Properties.GetEnumerator().MoveNext());
+            }
+        }
     }
 }
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index dd838ef172f..479b94879f1 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -566,6 +566,7 @@ public void InvalidVerbosity()
                 MSBuildApp.ProcessVerbositySwitch("loquacious");
             });
         }
+
         [Fact]
         public void ValidMaxCPUCountSwitch()
         {
@@ -617,6 +618,85 @@ public void InvalidMaxCPUCountSwitch4()
             });
         }
 
+        [Theory]
+        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, true, false)]
+        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, true, false)]
+        [InlineData("-getItem:MyItem", false, "", true, false, false, true, false)]
+        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, true, false)]
+        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, true, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, true, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, true, false)]
+        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, true, false)]
+        [InlineData("-getProperty:Foo;Bar", true, "EvalValue", false, false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -t:Build", true, "TargetValue", false, false, false, false, false)]
+        [InlineData("-getItem:MyItem", false, "", true, false, false, false, false)]
+        [InlineData("-getItem:MyItem -t:Build", false, "", true, true, false, false, false)]
+        [InlineData("-getItem:WrongItem -t:Build", false, "", false, false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem -t:Build", true, "TargetValue", true, true, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getItem:MyItem", true, "EvalValue", true, false, false, false, false)]
+        [InlineData("-getProperty:Foo;Bar -getTargetResult:MyTarget", true, "TargetValue", false, false, true, false, false)]
+        [InlineData("-getTargetResult:Restore", false, "", false, false, false, false, true)]
+        public void ExecuteAppWithGetPropertyItemAndTargetResult(
+            string extraSwitch,
+            bool fooPresent,
+            string fooResult,
+            bool itemIncludesAlwaysThere,
+            bool itemIncludesTargetItem,
+            bool targetResultPresent,
+            bool isGraphBuild,
+            bool restoreOnly)
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            TransientTestFile project = env.CreateFile("testProject.csproj", @"
+<Project>
+
+  <PropertyGroup>
+    <Foo>EvalValue</Foo>
+    <Baz>InnocuousValue</Baz>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <MyItem Include=""itemAlwaysThere"" Metadatum=""metadatumValue"" />
+  </ItemGroup>
+
+  <Target Name=""MyTarget"" BeforeTargets=""Build"">
+    <PropertyGroup>
+      <Foo>TargetValue</Foo>
+    </PropertyGroup>
+    <ItemGroup>
+      <MyItem Include=""targetItem"" Metadato=""OtherMetadatum"" />
+    </ItemGroup>
+  </Target>
+
+  <Target Name=""Build"">
+
+  </Target>
+
+  <Target Name=""Restore"">
+
+  </Target>
+
+</Project>
+");
+            string graph = isGraphBuild ? "--graph" : "";
+            string results = RunnerUtilities.ExecMSBuild($" {project.Path} {extraSwitch} {graph}", out bool success);
+            success.ShouldBeTrue(results);
+            if (fooPresent)
+            {
+                results.ShouldContain($"\"Foo\": \"{fooResult}\"");
+                results.ShouldContain("\"Bar\": \"\"");
+            }
+
+            results.ShouldNotContain("InnocuousValue");
+
+            results.Contains("itemAlwaysThere").ShouldBe(itemIncludesAlwaysThere);
+            results.Contains("targetItem").ShouldBe(itemIncludesTargetItem);
+
+            results.Contains("MyTarget").ShouldBe(targetResultPresent);
+            results.Contains("\"Result\": \"Success\"").ShouldBe(targetResultPresent || restoreOnly);
+            results.ShouldNotContain(ResourceUtilities.GetResourceString("BuildFailedWithPropertiesItemsOrTargetResultsRequested"));
+        }
+
         /// <summary>
         /// Regression test for bug where the MSBuild.exe command-line app
         /// would sometimes set the UI culture to just "en" which is considered a "neutral" UI
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index f7275f81502..847da8ba276 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -106,9 +106,15 @@ internal enum ParameterizedSwitch
             GraphBuild,
             InputResultsCaches,
             OutputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+            ReportFileAccesses,
+#endif
             LowPriority,
             Question,
             DetailedSummary,
+            GetProperty,
+            GetItem,
+            GetTargetResult,
             NumberOfParameterizedSwitches,
         }
 
@@ -265,9 +271,15 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "graphbuild", "graph" },               ParameterizedSwitch.GraphBuild,                 null,                           true,           null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "inputResultsCaches", "irc" },         ParameterizedSwitch.InputResultsCaches,         null,                           true,           null,                                  true,   true),
             new ParameterizedSwitchInfo(  new string[] { "outputResultsCache", "orc" },         ParameterizedSwitch.OutputResultsCache,         "DuplicateOutputResultsCache",  false,          null,                                  true,   true),
+#if FEATURE_REPORTFILEACCESSES
+            new ParameterizedSwitchInfo(  new string[] { "reportfileaccesses" },                ParameterizedSwitch.ReportFileAccesses,         null,                           false,          null,                                  true,   false),
+#endif
             new ParameterizedSwitchInfo(  new string[] { "lowpriority", "low" },                ParameterizedSwitch.LowPriority,                null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "question", "q" },                     ParameterizedSwitch.Question,                   null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "detailedsummary", "ds" },             ParameterizedSwitch.DetailedSummary,            null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getProperty" },                       ParameterizedSwitch.GetProperty,                null,                           true,           "MissingGetPropertyError",             true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getItem" },                           ParameterizedSwitch.GetItem,                    null,                           true,           "MissingGetItemError",             true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "getTargetResult" },                   ParameterizedSwitch.GetTargetResult,            null,                           true,           "MissingGetTargetResultError",             true,   false),
         };
 
         /// <summary>
diff --git a/src/MSBuild/JsonOutputFormatter.cs b/src/MSBuild/JsonOutputFormatter.cs
new file mode 100644
index 00000000000..095f0761386
--- /dev/null
+++ b/src/MSBuild/JsonOutputFormatter.cs
@@ -0,0 +1,163 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Text.Json;
+using System.Text.Json.Nodes;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.CommandLine
+{
+    /// <summary>
+    /// This class is intended to take in names of properties, items, and/or target results and some means of computing
+    /// those data, then format them in a json object and provide a convenient means to stringify them.
+    /// </summary>
+    internal sealed class JsonOutputFormatter
+    {
+        private static readonly JsonSerializerOptions s_options = new() { AllowTrailingCommas = false, WriteIndented = true };
+        private readonly JsonNode _topLevelNode = new JsonObject();
+
+        public override string ToString()
+        {
+            return _topLevelNode.ToJsonString(s_options);
+        }
+
+        internal void AddPropertiesInJsonFormat(string[] propertyNames, Func<string, string> getProperty)
+        {
+            if (propertyNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["Properties"] is null, "Should not add multiple lists of properties to the json format.");
+
+            JsonNode propertiesNode = new JsonObject();
+            foreach (string property in propertyNames)
+            {
+                propertiesNode[property] = getProperty(property);
+            }
+
+            _topLevelNode["Properties"] = propertiesNode;
+        }
+
+        internal void AddItemInstancesInJsonFormat(string[] itemNames, ProjectInstance project)
+        {
+            if (itemNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["Items"] is null, "Should not add multiple lists of items to the json format.");
+
+            JsonNode itemsNode = new JsonObject();
+            foreach (string itemName in itemNames)
+            {
+                JsonArray itemArray = new();
+                foreach (ProjectItemInstance item in project.GetItems(itemName))
+                {
+                    JsonObject jsonItem = new();
+                    jsonItem["Identity"] = item.GetMetadataValue("Identity");
+                    foreach (string metadatumName in item.MetadataNames)
+                    {
+                        if (metadatumName.Equals("Identity"))
+                        {
+                            continue;
+                        }
+
+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);
+                    }
+
+                    itemArray.Add(jsonItem);
+                }
+
+                itemsNode[itemName] = itemArray;
+            }
+
+            _topLevelNode["Items"] = itemsNode;
+        }
+
+        internal void AddItemsInJsonFormat(string[] itemNames, Project project)
+        {
+            if (itemNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["Items"] is null, "Should not add multiple lists of items to the json format.");
+
+            JsonObject itemsNode = new();
+            foreach (string itemName in itemNames)
+            {
+                JsonArray itemArray = new();
+                foreach (ProjectItem item in project.GetItems(itemName))
+                {
+                    JsonObject jsonItem = new();
+                    jsonItem["Identity"] = item.GetMetadataValue("Identity");
+                    foreach (ProjectMetadata metadatum in item.Metadata)
+                    {
+                        jsonItem[metadatum.Name] = metadatum.EvaluatedValue;
+                    }
+
+                    foreach (string metadatumName in FileUtilities.ItemSpecModifiers.All)
+                    {
+                        if (metadatumName.Equals("Identity"))
+                        {
+                            continue;
+                        }
+
+                        jsonItem[metadatumName] = item.GetMetadataValue(metadatumName);
+                    }
+
+                    itemArray.Add(jsonItem);
+                }
+
+                itemsNode[itemName] = itemArray;
+            }
+
+            _topLevelNode["Items"] = itemsNode;
+        }
+
+        internal void AddTargetResultsInJsonFormat(string[] targetNames, BuildResult result)
+        {
+            if (targetNames.Length == 0)
+            {
+                return;
+            }
+
+            ErrorUtilities.VerifyThrow(_topLevelNode["TargetResults"] is null, "Should not add multiple lists of target results to the json format.");
+
+            JsonObject targetResultsNode = new();
+            foreach (string targetName in targetNames)
+            {
+                TargetResult targetResult = result.ResultsByTarget[targetName];
+                JsonObject targetResults = new();
+                targetResults["Result"] = targetResult.ResultCode.ToString();
+                JsonArray outputArray = new();
+                foreach (ITaskItem item in targetResult.Items)
+                {
+                    JsonObject jsonItem = new();
+                    jsonItem["Identity"] = item.GetMetadata("Identity");
+                    foreach (string metadatumName in item.MetadataNames)
+                    {
+                        if (metadatumName.Equals("Identity"))
+                        {
+                            continue;
+                        }
+
+                        jsonItem[metadatumName] = item.GetMetadata(metadatumName);
+                    }
+
+                    outputArray.Add(jsonItem);
+                }
+
+                targetResults["Items"] = outputArray;
+                targetResultsNode[targetName] = targetResults;
+            }
+
+            _topLevelNode["TargetResults"] = targetResultsNode;
+        }
+    }
+}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 7d2a9b9e875..72b71371e3b 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -18,6 +18,7 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
@@ -71,41 +72,26 @@
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="..\Shared\FileDelegates.cs">
       <Link>FileDelegates.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>FileUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Build\Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>FileUtilitiesRegex.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
       <Link>IConstrainedEqualityComparer.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\QuotingUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\QuotingUtilities.cs" />
     <Compile Include="..\Shared\RegisteredTaskObjectCacheBase.cs">
       <Link>RegisteredTaskObjectCacheBase.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\ResourceUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\EscapingUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ErrorUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\Modifiers.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\XMakeElements.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\ResourceUtilities.cs" />
+    <Compile Include="..\Shared\EscapingUtilities.cs" />
+    <Compile Include="..\Shared\ErrorUtilities.cs" />
+    <Compile Include="..\Shared\Modifiers.cs" />
+    <Compile Include="..\Shared\XMakeElements.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
@@ -114,15 +100,11 @@
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\ExceptionHandling.cs" />
-    <Compile Include="..\Shared\EventArgsFormatting.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\EventArgsFormatting.cs" />
     <Compile Include="..\Shared\TempFileUtilities.cs">
       <Link>TempFileUtilities.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\XMakeAttributes.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\XMakeAttributes.cs" />
     <Compile Include="..\Shared\INodeEndpoint.cs" />
     <Compile Include="..\Shared\NodeEndpointOutOfProcBase.cs" />
     <Compile Include="..\Shared\INodePacket.cs" />
@@ -140,58 +122,35 @@
     <Compile Include="..\Shared\TaskLoader.cs" />
     <Compile Include="..\Shared\MSBuildLoadContext.cs" Condition="'$(TargetFrameworkIdentifier)'!='.NETFramework'" />
     <Compile Include="..\Shared\TypeLoader.cs" />
-    <Compile Include="..\Shared\LoadedType.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyLoadInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\LoadedType.cs" />
+    <Compile Include="..\Shared\AssemblyLoadInfo.cs" />
     <Compile Include="..\Shared\NodeBuildComplete.cs" />
     <Compile Include="..\Shared\NodeShutdown.cs" />
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\TaskParameterTypeVerifier.cs" />
-    <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\AssemblyNameExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\TaskEngineAssemblyResolver.cs" />
+    <Compile Include="..\Shared\AssemblyNameExtension.cs" />
     <Compile Include="..\Shared\ThreadPoolExtensions.cs" />
     <Compile Include="..\Shared\StringExtensions.cs" />
-    <Compile Include="AssemblyInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyResources.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyInfo.cs" />
+    <Compile Include="AssemblyResources.cs" />
     <Compile Include="AutomaticEncodingRestorer.cs" />
-    <Compile Include="CommandLineSwitches.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CommandLineSwitchException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="CommandLineSwitches.cs" />
+    <Compile Include="CommandLineSwitchException.cs" />
     <Compile Include="..\Shared\CoreCLRAssemblyLoader.cs" Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'" />
-    <Compile Include="DistributedLoggerRecord.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="DistributedLoggerRecord.cs" />
     <Compile Include="TerminalLogger\*.cs" />
-    <Compile Include="InitializationException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="InitializationException.cs" />
     <Compile Include="MSBuildClientApp.cs" />
     <Compile Include="NodeEndpointOutOfProcTaskHost.cs" />
     <Compile Include="LogMessagePacket.cs" />
-    <Compile Include="ProjectSchemaValidationHandler.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ProjectSchemaValidationHandler.cs" />
     <Compile Include="OutOfProcTaskHostNode.cs" />
     <Compile Include="OutOfProcTaskAppDomainWrapperBase.cs" />
     <Compile Include="OutOfProcTaskAppDomainWrapper.cs" />
     <Compile Include="PerformanceLogEventListener.cs" />
-    <Compile Include="XMake.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="JsonOutputFormatter.cs" />
+    <Compile Include="XMake.cs" />
     <!-- This is to enable CodeMarkers in MSBuild.exe -->
     <!-- Win32 RC Files -->
     <RCResourceFile Include="native.rc" />
@@ -217,6 +176,7 @@
     </None>
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 1a0c3871a2d..dc6cfcdf7e6 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -5,14 +5,16 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.IO;
 using System.Globalization;
-using System.Threading;
+using System.IO;
 using System.Reflection;
-
+using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Experimental.FileAccess;
+#endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 #if FEATURE_APPDOMAIN
@@ -165,6 +167,13 @@ internal class OutOfProcTaskHostNode :
         private RegisteredTaskObjectCacheBase _registeredTaskObjectCache;
 #endif
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// The file accesses reported by the most recently completed task.
+        /// </summary>
+        private List<FileAccessData> _fileAccessData = new List<FileAccessData>();
+#endif
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -531,11 +540,22 @@ public override bool IsTaskInputLoggingEnabled
                     return _taskHost._currentConfiguration.IsTaskInputLoggingEnabled;
                 }
             }
+
+#if FEATURE_REPORTFILEACCESSES
+            /// <summary>
+            /// Reports a file access from a task.
+            /// </summary>
+            /// <param name="fileAccessData">The file access to report.</param>
+            public void ReportFileAccess(FileAccessData fileAccessData)
+            {
+                _taskHost._fileAccessData.Add(fileAccessData);
+            }
+#endif
         }
 
         public EngineServices EngineServices { get; }
 
-        #endregion
+#endregion
 
 #endif
 
@@ -936,8 +956,11 @@ private void RunTask(object state)
                     lock (_taskCompleteLock)
                     {
                         _taskCompletePacket = new TaskHostTaskComplete(
-                                                        taskResult,
-                                                        currentEnvironment);
+                            taskResult,
+#if FEATURE_REPORTFILEACCESSES
+                            _fileAccessData,
+#endif
+                            currentEnvironment);
                     }
 
 #if FEATURE_APPDOMAIN
@@ -956,11 +979,20 @@ private void RunTask(object state)
                     lock (_taskCompleteLock)
                     {
                         // Create a minimal taskCompletePacket to carry the exception so that the TaskHostTask does not hang while waiting
-                        _taskCompletePacket = new TaskHostTaskComplete(new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedAfterExecution, e), null);
+                        _taskCompletePacket = new TaskHostTaskComplete(
+                            new OutOfProcTaskHostTaskResult(TaskCompleteType.CrashedAfterExecution, e),
+#if FEATURE_REPORTFILEACCESSES
+                            _fileAccessData,
+#endif
+                            null);
                     }
                 }
                 finally
                 {
+#if FEATURE_REPORTFILEACCESSES
+                    _fileAccessData = new List<FileAccessData>();
+#endif
+
                     // Call CleanupTask to unload any domains and other necessary cleanup in the taskWrapper
                     _taskWrapper.CleanupTask();
 
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 2c935aff7b2..a753a09c5b6 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -865,6 +865,18 @@
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </comment>
   </data>
+  <data name="HelpMessage_42_ReportFileAccessesSwitch" Visibility="Public">
+    <value>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </value>
+    <comment>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </comment>
+  </data>
   <data name="InvalidConfigurationFile" Visibility="Public">
     <value>MSBUILD : Configuration error MSB1043: The application could not start. {0}</value>
     <comment>
@@ -1033,6 +1045,37 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
+  <data name="MissingGetPropertyError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="MissingGetItemError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="MissingGetTargetResultError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
+  <data name="SolutionBuildInvalidForCommandLineEvaluation" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <data name="MissingToolsVersionError" UESanitized="false" Visibility="Public">
     <value>MSBUILD : error MSB1039: Specify the version of the toolset.</value>
     <comment>
@@ -1305,6 +1348,15 @@
     <value>MSBUILD : error MSB1049: The {0} parameter must be specified</value>
     <comment>{StrBegin="MSBUILD : error MSB1049: "}</comment>
   </data>
+  <data name="InvalidReportFileAccessesValue" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <!-- #################################################################################################-->
   <!-- ######################################## Shared strings #########################################-->
   <!-- ###### These belong in Strings.shared.resx, but have been copied here for performance ###########-->
@@ -1505,6 +1557,9 @@
       {4}: duration in seconds with 1 decimal point
     </comment>
   </data>
+  <data name="BuildFailedWithPropertiesItemsOrTargetResultsRequested" xml:space="preserve">
+    <value>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</value>
+  </data>
   <data name="TerminalLoggerNotUsedDisabled" xml:space="preserve">
     <value>Terminal Logger was not used because build is run in context of a process (e.g. 'dotnet test') that requests direct access to stdout stream.</value>
   </data>
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index e6a476b3e62..2a30dcd283d 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Sestavení se nezdařilo. Nelze získat výsledky vlastností, položek a cíle. Viz podrobnosti ve stderr výše.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Sestavení {0} za {1}s</target>
@@ -92,6 +97,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Způsobí, že MSBuild bude hlásit přístupy k souborům ve všech konfigurovaných
+                     modulech plug-in pro mezipaměť projektu.
+
+                     Tento příznak je experimentální a nemusí fungovat podle očekávání.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -112,6 +135,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Hodnota přístupů k souborům sestavy není platná. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -535,20 +568,17 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;protok_nást&gt;   Použít daný protokolovací nástroj k protokolování
-                     událostí nástroje MSBuild. Chcete-li zadat více protokolovacích.
-                     nástrojů, musíte je zadat jednotlivě.
-                     Syntaxe hodnoty &lt;protok_nást&gt;:
-                        [&lt;třída_protok_nást&gt;,]&lt;sestavení_protok_nást&gt;
-                        [;&lt;param_protok_nást&gt;]
-                     Syntaxe hodnoty &lt;třída_protok_nást&gt;:
-                        [&lt;část/úpl_obor_názvů&gt;.]&lt;náz_tř_protok_nást&gt;
-                     Syntaxe hodnoty &lt;sestavení_protok_nást&gt;:
-                        {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
+        <target state="translated">  -logger:&lt;logger&gt;   Použít daný protokolovací nástroj k protokolování událostí nástroje MSBuild. Pokud chcete zadat 
+                     více protokolovacích nástrojů, musíte je zadat jednotlivě.
+                     Syntaxe hodnoty &lt;logger&gt; je:
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                     Syntaxe hodnoty &lt;logger class&gt; je:
+                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
+                     Syntaxe hodnoty &lt;logger assembly&gt; je:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
-                     Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se 
-                     protokolovacímu nástroji přesně v tom tvaru, v jakém
-                     byly zadány. (Krátký tvar: -l)
+                     Parametry &lt;logger parameters&gt; jsou volitelné a předávají se
+                     protokolovacímu nástroji přesně v tom tvaru, v jakém byly zadány. (Krátký tvar: -l)
                      Příklady:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
@@ -817,23 +847,20 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
-        <target state="translated">  -distributedlogger:&lt;centr_protok_nást&gt;*&lt;předáv_protok_nást&gt;                     
-                     Použít zadaný protokolovací nástroj pro protokolování událostí
-                     z nástroje MSBuild; ke každému uzlu připojit jinou instanci 
-                     protokolovacího nástroje. Chcete-li zadat více 
-                     protokolovacích nástrojů, uveďte je jednotlivě. 
+        <target state="translated">  -distributedLogger:&lt;central logger&gt;*&lt;forwarding logger&gt;
+                     Použít zadaný protokolovací nástroj pro protokolování událostí z nástroje MSBuild; ke každému uzlu připojit
+                     jinou instanci protokolovacího nástroje. Pokud chcete zadat více
+                     protokolovacích nástrojů, uveďte je jednotlivě.
                      (Krátký tvar: -dl)
-                     Syntaxe hodnoty &lt;protok_nást&gt;:
-                        [&lt;třída_protok_nást&gt;,]&lt;sestav_protok_nást&gt;
-                        [;&lt;param_protok_nást&gt;]
-                     Syntaxe hodnoty &lt;třída_protok_nást&gt;:
-                        [&lt;část/úpl_obor_názvů&gt;.]&lt;náz_tř_protok_nást&gt;
-                     Syntaxe hodnoty &lt;sestav_protok_nást&gt;:
-                        {&lt;název_sestavení&gt;[,&lt;strong name&gt;] | &lt;soubor_sestavení&gt;}
+                     Syntaxe hodnoty &lt;logger&gt; je:
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
+                     Syntaxe hodnoty &lt;logger class&gt; je:
+                       [&lt;partial or full namespace&gt;.]&lt;logger class name&gt;
+                     Syntaxe hodnoty &lt;logger assembly&gt; je:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Parametry protokolovacího nástroje určují, jak MSBuild vytvoří protokolovací nástroj.
                      Parametry &lt;param_protok_nást&gt; jsou volitelné a předávají se
-                     protokolovacímu nástroji přesně v zadaném tvaru.
-                     (Krátký tvar: -l)
+                     protokolovacímu nástroji přesně v zadaném tvaru. (Krátký tvar: -l)
                      Příklady:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
@@ -1021,7 +1048,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                                              Verbosity=diagnostic;Encoding=UTF-8
 
                        -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1294,6 +1321,33 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <target state="translated">Protokoly MSBuild a informace o ladění budou dostupné v „{0}“</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: Je nutné zadat název položky pro přepínač getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: Je nutné zadat název vlastnosti pro přepínač getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: Je nutné zadat cílový název pro přepínač getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Zadejte protokolovací nástroj.</target>
@@ -1349,7 +1403,7 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: Pokud používáte přepínač -terminalLoggerParameters, zadejte jeden nebo více parametrů pro terminálový protokolovací nástroj.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1571,6 +1625,14 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Při vytváření souborů řešení nebo souborů filtrů řešení nelze získat přístup k vlastnostem nebo položkám. Tato funkce je k dispozici jen při sestavování jednotlivých projektů.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index a46ccf6d8e7..f2f536f5ff9 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Fehler beim Buildvorgang. Eigenschaften, Elemente und Zielergebnisse können nicht abgerufen werden. Details finden Sie oben in stderr.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Erstellen von {0} in {1}s</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Führt dazu, dass MSBuild Dateizugriffe auf ein beliebiges konfiguriertes
+                     Projektcache-Plug-In meldet.
+
+                     Dieses Flag ist experimentell und funktioniert möglicherweise nicht wie vorgesehen.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Der Wert für den Zugriff auf die Berichtsdatei ist ungültig. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -201,7 +234,7 @@
                      value that comes from a response file.
     </source>
         <target state="translated">  -interactive[:True|False]
-                     Weist darauf hin, dass für Aktionen im Build eine 
+                     Weist darauf hin, dass für Aktionen im Build eine
                      Interaktion mit dem Benutzer zugelassen ist. Verwenden Sie dieses Argument
                      in einem automatisierten Szenario, in dem keine Interaktivität
                      erwartet wird.
@@ -370,7 +403,7 @@ Dies ist ein restriktiverer Modus von MSBuild, da er erfordert,
     </source>
         <target state="translated">  -warnNotAsError[:code[;code2]]
                      Liste der Warnungscodes, die nicht als Fehler behandelt werden.
-                     Semikolon oder Komma zum Trennen 
+                     Semikolon oder Komma zum Trennen
                      mehrerer Warnungscodes verwenden. Hat keine Auswirkungen, wenn der Switch -warnaserror
                      nicht festgelegt ist.
 
@@ -438,8 +471,8 @@ Dies ist ein restriktiverer Modus von MSBuild, da er erfordert,
                      Antwortdateien anzugeben, geben Sie jede Antwortdatei
                      gesondert an.
 
-                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch 
-                     in den folgenden Speicherorten verwendet: 
+                     Alle Antwortdateien mit dem Name "msbuild.rsp" werden automatisch
+                     in den folgenden Speicherorten verwendet:
                      (1) Verzeichnis von "msbuild.exe"
                      (2) Verzeichnis des ersten erstellten Projekts oder Projektmappe
 </target>
@@ -530,16 +563,16 @@ Dies ist ein restriktiverer Modus von MSBuild, da er erfordert,
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben, 
+        <target state="translated">  -logger:&lt;Protokollierung&gt;   Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert. Um mehrere Protokollierungen anzugeben,
                      wird jede Protokollierung gesondert angegeben.
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax für die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollständiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
-                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
+                        {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -634,7 +667,7 @@ Hinweis: Ausführlichkeit der Dateiprotokollierungen
                         WarningsOnly: Zeigt nur Warnungen an.
                         NoItemAndPropertyList: Zeigt keine Liste der Elemente
                             und Eigenschaften am Anfang jeder Projekterstellung an.
-                        ShowCommandLine: Zeigt TaskCommandLineEvent-Meldungen an. 
+                        ShowCommandLine: Zeigt TaskCommandLineEvent-Meldungen an.
                         ShowTimestamp: Zeigt den Timestamp als Präfix einer
                             Meldung an.
                         ShowEventId: Zeigt die eventId für gestartete
@@ -810,18 +843,18 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
                        -dl:MyLogger,C:\My.dll*ForwardingLogger,C:\Logger.dll
 </source>
         <target state="translated">  -distributedlogger:&lt;Zentrale Protokollierung&gt;*&lt;Weiterleitende Protokollierung&gt;
-                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere 
-                     Protokollierungsinstanz angefügt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung 
+                     Mithilfe dieser Protokollierung werden Ereignisse von MSBuild protokolliert, wobei an jeden Knoten eine andere
+                     Protokollierungsinstanz angefügt wird. Um mehrere Protokollierungen anzugeben, wird jede Protokollierung
                      gesondert angegeben.
                      (Kurzform -dl)
                      Die Syntax für die &lt;Protokollierung&gt; lautet:
-                       [&lt;Klasse&gt;,]&lt;Assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
+                       [&lt;Klasse&gt;,]&lt;assembly&gt;[,&lt;Optionen&gt;][;&lt;Parameter&gt;]
                      Die Syntax für die &lt;Protokollierungsklasse&gt; lautet:
                         [&lt;Teilweiser oder vollständiger Namespace&gt;.]&lt;Name der Protokollierungsklasse&gt;
                      Die Syntax für die &lt;Protokollierungsassembly&gt; lautet:
-                       {&lt;Assemblyname&gt;[,&lt;strong name&gt;] | &lt;Assemblydatei&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Die Protokollierungsoptionen geben an, wie MSBuild die Protokollierung erstellt.
-                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau 
+                     Die &lt;Protokollierungsparameter&gt; sind optional und werden genau
                      so an die Protokollierung übergeben, wie sie eingegeben wurden. (Kurzform: -l)
                      Beispiele:
                        -dl:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -846,8 +879,8 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreprojectextensions:&lt;Erweiterungen&gt;
-                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende 
-                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma, 
+                     Liste der zu ignorierenden Erweiterungen, wenn die zu erstellende
+                     Projektdatei ermittelt wird. Verwenden Sie ein Semikolon oder ein Komma,
                      um mehrere Erweiterungen voneinander zu trennen.
                      (Kurzform: -ignore)
                      Beispiel:
@@ -873,8 +906,8 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
    </source>
         <target state="translated">  -toolsversion:&lt;Version&gt;
                      Die Version des MSBuild-Toolsets (Aufgaben, Ziele usw.),
-                     die während des Erstellens zu verwenden ist. Diese Version überschreibt die 
-                     von einzelnen Projekten angegebenen Versionen. (Kurzform: 
+                     die während des Erstellens zu verwenden ist. Diese Version überschreibt die
+                     von einzelnen Projekten angegebenen Versionen. (Kurzform:
                      -tv)
                      Beispiel:
                        -toolsversion:3.5
@@ -933,14 +966,14 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">  -distributedFileLogger
                      Protokolliert die Erstellungsausgabe in mehrere Dateien, eine Protokolldatei
                      pro MSBuild-Knoten. Der anfängliche Speicherort für diese Dateien ist
-                     das aktuelle Verzeichnis. Standardmäßig werden die Dateien 
+                     das aktuelle Verzeichnis. Standardmäßig werden die Dateien
                      "MSBuild&lt;Knoten-ID&gt;.log" benannt. Der Speicherort der Datei und
-                     andere Parameter für fileLogger können durch das Hinzufügen 
+                     andere Parameter für fileLogger können durch das Hinzufügen
                      des Schalters "-fileLoggerParameters" angegeben werden.
 
                      Wenn mithilfe des fileLoggerParameters-Parameters ein Protokolldateiname festgelegt wurde,
-                     verwendet die verteilte Protokollierung den Dateinamen als 
-                     Vorlage und fügt die Knoten-ID an diesen Dateinamen an, 
+                     verwendet die verteilte Protokollierung den Dateinamen als
+                     Vorlage und fügt die Knoten-ID an diesen Dateinamen an,
                      um für jeden Knoten eine Protokolldatei zu erstellen.
     </target>
         <note>
@@ -984,31 +1017,31 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;Parameter&gt;
                      Gibt zusätzliche Parameter für Dateiprotokollierungen an.
-                     Dieser Schalter bedeutet, dass der entsprechende 
+                     Dieser Schalter bedeutet, dass der entsprechende
                      Schalter "-fileLogger[n]" ebenfalls vorhanden ist.
                      "n" (optional) kann eine Zahl von 1–9 sein.
-                     "-fileLoggerParameters" wird auch von verteilten 
+                     "-fileLoggerParameters" wird auch von verteilten
                      Dateiprotokollierungen verwendet (siehe Beschreibung zu "-distributedFileLogger").
                      (Kurzform: -flp[n])
                      Es sind dieselben Parameter wie für die Konsolenprotokollierung
                      verfügbar. Einige zusätzliche Parameter:
-                        LogFile: Pfad der Protokolldatei, in die das 
+                        LogFile: Pfad der Protokolldatei, in die das
                             Buildprotokoll geschrieben wird.
-                        Append: Gibt an, ob das Buildprotokoll erweitert oder 
+                        Append: Gibt an, ob das Buildprotokoll erweitert oder
                             oder überschrieben wird. Mit diesem Schalter
                             wird das Buildprotokoll an die Protokolldatei angefügt;
-                            Ohne diesen Schalter wird der Inhalt 
-                            der vorhandenen Protokolldatei überschrieben. 
+                            Ohne diesen Schalter wird der Inhalt
+                            der vorhandenen Protokolldatei überschrieben.
                             Standardmäßig wird die Protokolldatei nicht erweitert.
-                        Encoding: Gibt die Codierung der Datei an, 
+                        Encoding: Gibt die Codierung der Datei an,
                             z. B. UTF-8, Unicode oder ASCII.
                      Die Standardeinstellung für "verbosity" ist "Detailed".
                      Beispiele:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1034,7 +1067,7 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">  -nodeReuse:&lt;Parameter&gt;
                      Aktiviert oder deaktiviert die Wiederverwendung von MSBuild-Knoten.
                      Die Parameter lauten:
-                     True: Knoten bleiben nach dem Abschluss der Erstellung 
+                     True: Knoten bleiben nach dem Abschluss der Erstellung
                      erhalten und werden bei folgenden Erstellungen wiederverwendet (Standardeinstellung).
                      False: Knoten bleiben nach dem Abschluss der Erstellung nicht erhalten.
                      (Kurzform: -nr)
@@ -1281,6 +1314,33 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <target state="translated">MSBuild-Protokolle und Debuginformationen befinden sich auf "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: Es muss ein Elementname für den getItem-Switch angegeben werden.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: Für den getProperty-Switch muss ein Eigenschaftenname angegeben werden.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: Für den GetTargetResult-Switch muss ein Zielname angegeben werden.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Geben Sie eine Protokollierung an.</target>
@@ -1336,7 +1396,7 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: Geben Sie mindestens einen Parameter für die Terminalprotokollierung an, wenn Sie den Schalter "-terminalLoggerParameters" verwenden.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1558,6 +1618,14 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Beim Erstellen von Projektmappendateien oder Projektmappenfilterdateien kann nicht auf Eigenschaften oder Elemente zugegriffen werden. Dieses Feature ist nur beim Erstellen einzelner Projekte verfügbar.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1994,4 +2062,4 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       </trans-unit>
     </body>
   </file>
-</xliff>
\ No newline at end of file
+</xliff>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 9f96cd34cec..b710a127b24 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Error de compilación. No se pueden obtener los resultados de propiedades, elementos y destinos. Vea los detalles en stderr anterior.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Compilación {0} en {1}s</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|Falso]
+                     Hace que MSBuild informe de los accesos a los archivos a cualquier
+                     complemento de caché de proyectos.
+
+                     Esta marca es experimental y puede que no funcione según lo previsto.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: el valor de acceso al archivo de informe no es válido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -531,18 +564,14 @@
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
         <target state="translated">  -logger:&lt;registrador&gt;   Use este registrador para registrar eventos
-                     de MSBuild. Para especificar varios registradores, especifique
-                     cada uno de ellos por separado.
+                     de MSBuild. Para especificar varios registradores, especifique cada uno de ellos por separado.
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;parámetros&gt;]
+                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;parámetros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de
-                       clase del registrador&gt;
-                     La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
-                       de ensamblado&gt;}
-                     Las opciones del registrador especifican cómo crea MSBuild
-                     el registrador.
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de clase del registrador&gt;
+                       La sintaxis de &lt;ensamblado del registrador&gt; es:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     Las opciones del registrador especifican cómo crea MSBuild el registrador.
                      Los &lt;parámetros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
@@ -641,7 +670,7 @@
                         ShowCommandLine: muestra los mensajes de TaskCommandLineEvent
                         ShowTimestamp: muestra la marca de tiempo como un prefijo en los
                             mensajes.
-                        ShowEventId: muestra el identificador de evento para los eventos iniciados, los eventos 
+                        ShowEventId: muestra el identificador de evento para los eventos iniciados, los eventos
                             finalizados y los mensajes.
                         ForceNoAlign: no alinea el texto al tamaño del
                             búfer de la consola
@@ -819,15 +848,12 @@
                      Para especificar varios registradores, especifique cada uno
                      de ellos por separado. (Forma corta: -dl)
                      La sintaxis de &lt;registrador&gt; es:
-                       [&lt;clase&gt;,]&lt;ensamblado&gt;[,&lt;opciones&gt;][;&lt;parámetros&gt;]
+                       [&lt;clase&gt;,]&lt;assembly&gt;[,&lt;opciones&gt;][;&lt;parámetros&gt;]
                      La sintaxis de &lt;clase del registrador&gt; es:
-                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre
-                       de la clase del registrador&gt;
+                       [&lt;espacio de nombres parcial o completo&gt;.]&lt;nombre de la clase del registrador&gt;
                      La sintaxis de &lt;ensamblado del registrador&gt; es:
-                       {&lt;nombre del ensamblado&gt;[,&lt;strong name&gt;] | &lt;archivo
-                      de ensamblado&gt;}
-                     Las opciones del registrador especifican cómo crea MSBuild
-                     el registrador.
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
+                     Las opciones del registrador especifican cómo crea MSBuild el registrador.
                      Los &lt;parámetros del registrador&gt; son opcionales y se pasan
                      al registrador tal como se escriben. (Forma corta: -l)
                      Ejemplos:
@@ -853,8 +879,8 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;extensiones&gt;
-                     Lista de extensiones que se omiten al determinar el 
-                     archivo del proyecto que se va a compilar. Use el carácter de 
+                     Lista de extensiones que se omiten al determinar el
+                     archivo del proyecto que se va a compilar. Use el carácter de
                      punto y coma o coma para separar varias extensiones.
                     (Forma corta: -ignore)
                      Ejemplo:
@@ -1005,9 +1031,9 @@
                             sobrescribirá el archivo de registro. Si se establece el
                             modificador, se adjunta el registro de compilación al archivo de registro;
                             Si no se especifica el modificador, se sobrescribe
-                            el contenido del archivo de registro existente. 
+                            el contenido del archivo de registro existente.
                             El valor predeterminado es adjuntar el archivo de registro.
-                        Encoding: especifica la codificación del archivo, 
+                        Encoding: especifica la codificación del archivo,
                             por ejemplo, UTF-8, Unicode o ASCII
                      El nivel de detalle predeterminado es Detailed.
                      Ejemplos:
@@ -1288,6 +1314,33 @@
         <target state="translated">Los registros de MSBuild y la información de depuración estarán en "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: debe proporcionar un nombre de elemento para el modificador getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: debe proporcionar un nombre de propiedad para el modificador getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: debe proporcionar un nombre de destino para el modificador getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especifique un registrador.</target>
@@ -1343,7 +1396,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: Especifique uno o más parámetros para el registrador de terminales si utiliza la opción -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1565,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: no se puede tener acceso a propiedades o elementos al compilar archivos de solución o archivos de filtro de soluciones. Esta característica solo está disponible al compilar proyectos individuales.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1999,4 +2060,4 @@
       </trans-unit>
     </body>
   </file>
-</xliff>
\ No newline at end of file
+</xliff>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 4f47f42754b..6bb0f127899 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Échec de la génération. Impossible d’obtenir les propriétés, les éléments et les résultats cibles. Consultez les détails dans stderr ci-dessus.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Générer {0} dans {1}s</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Entraîne le signalement par MSBuild des accès par fichiers aux plug-ins
+                     de cache de projet configurés.
+
+                     Cet indicateur est expérimental et peut ne pas fonctionner comme prévu.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: la valeur d’accès au fichier de rapport n’est pas valide. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -537,7 +570,7 @@ Cet indicateur est expérimental et peut ne pas fonctionner comme prévu.
                      Syntaxe de &lt;classe de journalisation&gt; :
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt; :
-                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Les options de journalisation spécifient la façon dont MSBuild crée le journaliseur.
                      Les &lt;paramètres de journalisation&gt; sont facultatifs. Ils sont passés
                      au journaliseur tels que vous les avez tapés. (Forme abrégée : -l)
@@ -819,7 +852,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
                      Syntaxe de &lt;classe de journalisation&gt; :
                        [&lt;espace de noms partiels ou complets&gt;.]&lt;nom de la classe de journalisation&gt;
                      Syntaxe de &lt;assembly de journalisation&gt; :
-                       {&lt;nom d'assembly&gt;[,&lt;strong name&gt;] | &lt;fichier d'assembly&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Les options de journalisation spécifient la façon dont MSBuild crée le journaliseur.
                      Les &lt;paramètres de journalisation&gt; sont facultatifs. Ils sont passés
                      au journaliseur tels que vous les avez tapés. (Forme abrégée : -l)
@@ -1281,6 +1314,33 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <target state="translated">Les journaux MSBuild et les informations de débogage seront au "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: Doit fournir un nom d'élément pour le commutateur getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: Doit fournir un nom de propriété pour le commutateur getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: Doit fournir un nom de cible pour le commutateur getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Spécifiez un journal.</target>
@@ -1336,7 +1396,7 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: spécifiez un ou plusieurs paramètres pour l’enregistreur d’événements de terminal si vous utilisez le commutateur -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1558,6 +1618,14 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Impossible d'accéder aux propriétés ou aux éléments lors de la création de fichiers de solution ou de fichiers de filtre de solution. Cette fonctionnalité est disponible uniquement lors de la génération de projets individuels.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1967,7 +2035,7 @@ fois plus petit que le journal
         <target state="translated">  -profileEvaluation:&lt;fichier&gt;
          Profile l'évaluation MSBuild et écrit le résultat
          dans le fichier spécifié. Si l'extension du fichier spécifié
-         est '.md', le résultat est généré au format Markdown. 
+         est '.md', le résultat est généré au format Markdown.
          Sinon, un fichier de valeurs séparées par des tabulations est généré.
     </target>
         <note />
@@ -2012,4 +2080,4 @@ fois plus petit que le journal
       </trans-unit>
     </body>
   </file>
-</xliff>
\ No newline at end of file
+</xliff>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index bc3680ba361..cb4c28286b0 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Compilazione non riuscita. Non è possibile ottenere proprietà, elementi e risultati di destinazione. Vedere i dettagli in stderr sopra.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Compilazione {0} in {1}s</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Fa in modo che MSBuild segnali gli accessi ai file a qualsiasi
+                     plug-in della cache del progetto.
+
+                     Questo flag è sperimentale e potrebbe non funzionare come previsto.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,11 +134,21 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: il valore degli accessi al file di report non è valido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
         <source>MSBuild version {0} for {1}</source>
-        <target state="translated">Versione di MSBuild Ł{0} per {1}</target>
+        <target state="translated">Versione di MSBuild {0} per {1}</target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
       <trans-unit id="CurrentDirectory">
@@ -446,7 +479,7 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                      separatamente.
 
                      Qualsiasi file di risposta denominato "msbuild.rsp" viene usato
-                     automaticamente dai percorsi seguenti: 
+                     automaticamente dai percorsi seguenti:
                      (1) la directory di msbuild.exe
                      (2) la directory della prima compilazione di soluzione o progetto
 </target>
@@ -543,8 +576,8 @@ Questo flag è sperimentale e potrebbe non funzionare come previsto.
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; è la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;assembly logger&gt; è la seguente:
-                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
+                     La sintassi di &lt;logger assembly&gt; è la seguente:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger così come vengono digitati. Forma breve: -l.
@@ -825,8 +858,8 @@ Nota: livello di dettaglio dei logger di file
                        [&lt;classe&gt;,]&lt;assembly&gt;[,&lt;opzioni&gt;][;&lt;parametri&gt;]
                      La sintassi di &lt;classe logger&gt; è la seguente:
                        [&lt;spazio dei nomi parziale o completo&gt;.]&lt;nome classe logger&gt;
-                     La sintassi di &lt;assembly logger&gt; è la seguente:
-                       {&lt;nome assembly&gt;[,&lt;strong name&gt;] | &lt;file di assembly&gt;}
+                     La sintassi di &lt;logger assembly&gt; è la seguente:
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Le opzioni di logger consentono di specificare in che modo MSBuild crea il logger.
                      I &lt;parametri logger&gt; sono facoltativi e vengono passati al
                      logger così come vengono digitati. Forma breve: -l
@@ -945,9 +978,8 @@ Nota: livello di dettaglio dei logger di file
                      è la directory corrente. Per impostazione predefinita, ai
                      file viene assegnato il nome "MSBuild&lt;idnodo&gt;.log". Il
                      percorso dei file e altri parametri di fileLogger possono
-                     essere specificati aggiungendo l'opzione
+                     essere specificati aggiungendo l'opzione "-fileLoggerParameters".
 
-                     "-fileLoggerParameters".
                      Se il nome di un file di log viene impostato con l'opzione
                      fileLoggerParameters, il logger distribuito userà il nome
                      file come modello e aggiungerà l'ID del nodo per creare un
@@ -1292,6 +1324,33 @@ Nota: livello di dettaglio dei logger di file
         <target state="translated">I log e le informazioni di debug di MSBuild sono contenuti in "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: è necessario specificare un nome elemento per l'opzione getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: è necessario specificare un nome proprietà per l'opzione getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: è necessario specificare un nome destinazione per l'opzione getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: specificare un logger.</target>
@@ -1347,7 +1406,7 @@ Nota: livello di dettaglio dei logger di file
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: specificare uno o più parametri per il logger del terminale se si usa l'opzione -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1569,6 +1628,14 @@ Nota: livello di dettaglio dei logger di file
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: non è possibile accedere a proprietà o elementi durante la compilazione di file di soluzione o file di filtro della soluzione. Questa funzionalità è disponibile solo durante la compilazione di singoli progetti.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1982,16 +2049,15 @@ Esegue la profilatura della valutazione di MSBuild e scrive
                        -restoreProperty:IsRestore=true;MyProperty=value
     </source>
         <target state="translated">  -restoreProperty:&lt;n&gt;=&lt;v&gt;
-                      Imposta queste proprietà a livello di progetto o ne esegue
-                      l'override solo durante il ripristino e non usa le
-                      proprietà specificate con l'argomento -property.
-                      &lt;v&gt; rappresenta il nome della proprietà e &lt;v&gt; il
-                      valore della proprietà. Usare il punto e virgola o la
-                      virgola per delimitare più proprietà o specificare ogni
-                      proprietà separatamente.
-                      Forma breve: -rp.
-                      Esempio:
-                        -restoreProperty:IsRestore=true;MyProperty=value
+                     Imposta queste proprietà a livello di progetto o ne esegue
+                     l'override solo durante il ripristino e non usa le
+                     proprietà specificate con l'argomento -property.
+                     &lt;v&gt; rappresenta il nome della proprietà e &lt;v&gt; il
+                     valore della proprietà. Usare il punto e virgola o la
+                     virgola per delimitare più proprietà o specificare ogni proprietà separatamente.
+                     (Forma breve: -rp)
+                     Esempio:
+                       -restoreProperty:IsRestore=true;MyProperty=value
     </target>
         <note>
       LOCALIZATION: "-restoreProperty" and "-rp" should not be localized.
@@ -2010,4 +2076,4 @@ Esegue la profilatura della valutazione di MSBuild e scrive
       </trans-unit>
     </body>
   </file>
-</xliff>
\ No newline at end of file
+</xliff>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 4570b627fd2..b8c931148c9 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">ビルドに失敗しました。プロパティ、項目、ターゲットの結果を取得できません。上の stderr で詳細を参照してください。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">{1} 秒後に {0} をビルド</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild が、構成されているプロジェクト キャッシュ プラグインへの
+                     ファイル アクセスを報告するようにします。
+
+                     このフラグは実験的なものであり、意図したとおりに動作しない可能性があります。
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -105,12 +128,22 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="translated">MSBUILD : error MSB1065: ターミナル ロガーの値が無効です。'auto'、'true'、または 'false' のいずれかである必要があります。 {0}</target>
+        <target state="translated">MSBUILD : error MSB1065: ターミナル ロガーの値が無効です。'auto'、'true'、または 'false' のいずれかである必要があります。{0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: レポート ファイルのアクセス値が無効です。 {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -308,7 +341,7 @@
     </source>
         <target state="translated">  -targets[:file]
                      使用可能なターゲットの一覧を、実際のビルド処理を
-                     実行せずに出力します。既定では、出力はコンソール 
+                     実行せずに出力します。既定では、出力はコンソール
                      ウィンドウに書き込まれます。出力ファイルへのパスを
                      指定した場合は、代わりにそのファイルが使用されます。
                      (短い形式:-ts)
@@ -568,7 +601,7 @@
         <target state="translated">  -verbosity:&lt;level&gt; この量の情報をイベント ログに表示します。
                      利用可能な詳細レベル: q[uiet], m[inimal]、
                      n[ormal], d[etailed]、および diag[nostic]。(短縮形: -v)
-                     例: 
+                     例:
                        -verbosity:quiet
 
                      注意: ファイル ロガーの詳細度は
@@ -624,7 +657,7 @@
 </source>
         <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
                      コンソール ロガーへのパラメーターです。(短縮形: -clp)
-                     利用可能なパラメーター: 
+                     利用可能なパラメーター:
                         PerformanceSummary--タスク、ターゲット、プロジェクトにかかった時間を
                             表示します。
                         Summary--最後にエラーと警告の概要を表示します。
@@ -1281,6 +1314,33 @@
         <target state="translated">MSBuild のログとデバッグ情報は、"{0}" にあります。</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: getItem スイッチに項目名を指定する必要があります。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: getProperty スイッチにプロパティ名を指定する必要があります。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult スイッチにターゲット名を指定する必要があります。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Logger を指定してください。</target>
@@ -1336,7 +1396,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters スイッチを使用する場合は、このスイッチにターミナル ロガーのパラメーターを 1 つ以上指定してください</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1558,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: ソリューション ファイルまたはソリューション フィルター ファイルを作成するときにプロパティや項目にアクセスすることはできません。この機能は、個々のプロジェクトをビルドする場合にのみ使用できます。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1906,7 +1974,7 @@
                      (Short form: -r)
     </source>
         <target state="translated">  -restore[:True|False]
-                     他のターゲットをビルドする前に Restore 
+                     他のターゲットをビルドする前に Restore
                      という名前のターゲットを実行し、これらのターゲットのビルドが
                      最新の復元ビルド ロジックを使用するようにします。
                      これは、パッケージ ツリーでパッケージをビルド
@@ -1994,4 +2062,4 @@
       </trans-unit>
     </body>
   </file>
-</xliff>
\ No newline at end of file
+</xliff>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index fe84ab098dc..b94bd228977 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">빌드하지 못했습니다. 속성, 항목 및 대상 결과를 가져올 수 없습니다. 위의 stderr에서 세부 정보를 참조하세요.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">{0} 빌드({1}초)</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild에서 모든 구성된 프로젝트 캐시 플러그 인에 대한
+                     파일 액세스를 보고하도록 합니다.
+
+                     이 플래그는 실험적이며 예상대로 작동하지 않을 수 있습니다.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: 보고서 파일 액세스 값이 잘못되었습니다. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -533,11 +566,11 @@
         <target state="translated">  -logger:&lt;로거&gt;   이 로거를 사용하여 MSBuild의 이벤트를 기록합니다. 여러
                      로거를 지정하려면 각 로거를 개별적으로 지정합니다.
                      &lt;로거&gt; 구문은 다음과 같습니다.
-                       [&lt;클래스&gt;,]&lt;어셈블리&gt;[,&lt;옵션&gt;][;&lt;매개 변수&gt;]
+                       [&lt;클래스&gt;,]&lt;assembly&gt;[,&lt;옵션&gt;][;&lt;매개 변수&gt;]
                      &lt;로거 클래스&gt; 구문은 다음과 같습니다.
                        [&lt;부분 또는 전체 네임스페이스&gt;.]&lt;로거 클래스 이름&gt;
                      &lt;로거 어셈블리&gt; 구문은 다음과 같습니다.
-                       {&lt;어셈블리 이름&gt;[,&lt;strong name&gt;] | &lt;어셈블리 파일&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      로거 옵션은 MSBuild가 로거를 만드는 방법을 지정합니다.
                      &lt;로거 매개 변수&gt;는 선택 사항이고 입력한 대로 정확히
                      로거에 전달됩니다. (약식: -l)
@@ -815,11 +848,11 @@
                      로거를 지정하려면 각 로거를 개별적으로 지정합니다.
                      (약식 -dl)
                      &lt;로거&gt; 구문은 다음과 같습니다.
-                       [&lt;클래스&gt;,]&lt;어셈블리&gt;[,&lt;옵션&gt;][;&lt;매개 변수&gt;]
+                       [&lt;클래스&gt;,]&lt;assembly&gt;[,&lt;옵션&gt;][;&lt;매개 변수&gt;]
                      &lt;로거 클래스&gt; 구문은 다음과 같습니다.
                        [&lt;부분 또는 전체 네임스페이스&gt;.]&lt;로거 클래스 이름&gt;
                      &lt;로거 어셈블리&gt; 구문은 다음과 같습니다.
-                       {&lt;어셈블리 이름&gt;[,&lt;strong name&gt;] | &lt;어셈블리 파일&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      로거 옵션은 MSBuild가 로거를 만드는 방법을 지정합니다.
                       &lt;로거 매개 변수&gt;는 선택 사항이고
                      입력한 대로 정확히 로거에 전달됩니다. (약식: -l)
@@ -1281,6 +1314,33 @@
         <target state="translated">MSBuild 로그 및 디버그 정보는 "{0}"에 있습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: getItem 스위치의 항목 이름을 제공해야 합니다.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: getProperty 스위치의 속성 이름을 제공해야 합니다.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult 스위치의 대상 이름을 제공해야 합니다.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 로거를 지정하십시오.</target>
@@ -1336,7 +1396,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: -terminalLoggerParameters 스위치를 사용하는 경우 터미널 로거에 대해 하나 이상의 매개 변수를 지정하세요.</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1558,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: 솔루션 파일 또는 솔루션 필터 파일을 빌드할 때 속성 또는 항목에 액세스할 수 없습니다. 이 기능은 개별 프로젝트를 빌드할 때만 사용할 수 있습니다.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 843e4c18183..655080e5bdb 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Kompilacja nie powiodła się. Nie można uzyskać wyników właściwości, elementów i celu. Zobacz szczegóły w sekcji stderr powyżej.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Kompiluj {0} w {1}s</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Powoduje, że platforma MSBuild zgłasza dostępy do wszystkich skonfigurowanych
+                     wtyczek pamięci podręcznej projektu.
+
+                     Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: wartość dostępów do pliku raportu jest nieprawidłowa. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -207,7 +240,7 @@
                      interakcyjność nie jest oczekiwana.
                      Podanie parametru -interactive jest równoznaczne
                      z podaniem parametru -interactive:true. Użyj tego
-                     parametru, aby przesłonić wartość pochodzącą z pliku 
+                     parametru, aby przesłonić wartość pochodzącą z pliku
                      odpowiedzi.
     </target>
         <note>
@@ -242,7 +275,7 @@
                      Po ustawieniu na wartość „MessageUponIsolationViolation” (lub jej skróconą
                      formę „Message”), serializowane są tylko wyniki z celów najwyższego poziomu
                      , jeśli przełącznik -outputResultsCache jest
-                     dostarczony. Ma to na celu zmniejszenie szans na to, że cel 
+                     dostarczony. Ma to na celu zmniejszenie szans na to, że cel
                      naruszy izolację w projekcie zależnym przy użyciu
                      nieprawidłowego stanu z powodu jego zależności od buforowanego celu
                      którego efekty uboczne nie byłyby brane pod uwagę.
@@ -276,7 +309,7 @@
                      This flag is experimental and may not work as intended.
     </source>
         <target state="translated">  -graphBuild[:True|False]
-                     Powoduje, że program MSBuild tworzy i kompiluje graf                 
+                     Powoduje, że program MSBuild tworzy i kompiluje graf
                      projektu.
 
                      Tworzenie grafu obejmuje identyfikowanie odwołań do
@@ -444,7 +477,7 @@
                      osobno.
 
                      Wszelkie pliki odpowiedzi o nazwie „msbuild.rsp” będą automatycznie
-                     wykorzystywane z następujących lokalizacji: 
+                     wykorzystywane z następujących lokalizacji:
                      (1) katalog programu msbuild.exe
                      (2) katalog pierwszej kompilacji projektu lub rozwiązania
 </target>
@@ -535,17 +568,14 @@
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
                        -logger:XMLLogger,C:\Loggers\MyLogger.dll;OutputAsHTML
 </source>
-        <target state="translated">  -logger:&lt;rejestrator&gt;  Umożliwia użycie podanego rejestratora do rejestrowania
-                         zdarzeń pochodzących z programu MSBuild. Aby określić
-                     wiele rejestratorów, określ każdy z nich osobno.
+        <target state="translated">  -logger:&lt;rejestrator&gt;  Umożliwia użycie podanego rejestratora do rejestrowania zdarzeń pochodzących
+                     z programu MSBuild. Aby określić wiele rejestratorów, określ każdy z nich osobno.
                      Składnia elementu &lt;rejestrator&gt;:
-                        [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;
-                        [;&lt;parametry rejestratora&gt;]
+                      [&lt;klasa rejestratora&gt;,]&lt;assembly&gt; [;&lt;parametry rejestratora&gt;]
                      Składnia elementu &lt;klasa rejestratora&gt;:
-                        [&lt;częściowa lub pełna przestrzeń nazw&gt;.]
-                        &lt;nazwa klasy rejestratora&gt;
+                       [&lt;częściowa lub pełna przestrzeń nazw&gt;.] &lt;nazwa klasy rejestratora&gt;
                      Składnia elementu &lt;zestaw rejestratora&gt;:
-                        {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Wartości &lt;parametry rejestratora&gt; są opcjonalne i są
                      przekazywane do rejestratora dokładnie tak, jak zostały
                      wpisane. (Krótka wersja: -l)
@@ -766,7 +796,7 @@
                      to False, this sets it to True. (short form: -irc)
    </source>
         <target state="translated">  -inputResultsCaches:&lt;cacheFile&gt;...
-                     Rozdzielona średnikami lista wejściowych plików pamięci podręcznej, z których MSBuild 
+                     Rozdzielona średnikami lista wejściowych plików pamięci podręcznej, z których MSBuild
                      odczyta wyniki kompilacji. Jeśli jest ustawione -isolateProjects
                      na wartość Fałsz, ta opcja ustawia ją na wartość Prawda. (skrócona forma: -irc)
    </target>
@@ -824,11 +854,11 @@
                      wiele rejestratorów, określ każdy z nich osobno.
                      (Krótka wersja: -dl)
                      Składnia elementu &lt;rejestrator&gt;:
-                       [&lt;klasa rejestratora&gt;,]&lt;zestaw rejestratora&gt;[;&lt;parametry rejestratora&gt;]
+                       [&lt;klasa rejestratora&gt;,]&lt;assembly&gt;[;&lt;parametry rejestratora&gt;]
                      Składnia elementu &lt;klasa rejestratora&gt;:
                        [&lt;częściowa lub pełna przestrzeń nazw&gt;.]&lt;nazwa klasy rejestratora&gt;
                      Składnia elementu &lt;zestaw rejestratora&gt;:
-                       {&lt;nazwa zestawu&gt;[,&lt;strong name&gt;] | &lt;plik zestawu&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Wartości &lt;parametry rejestratora&gt; są opcjonalne i są
                      przekazywane do rejestratora dokładnie tak, jak zostały
                      wpisane. (Krótka wersja: -l)
@@ -940,13 +970,11 @@
                      create a log file for each node.
     </source>
         <target state="translated">  -distributedFileLogger
-                     Rejestruje dane wyjściowe kompilacji w wielu plikach
-                     dziennika, po jednym pliku na węzeł programu MSBuild.
-                     Początkową lokalizacją tych plików jest bieżący katalog.
-                     Domyślnie pliki mają nazwę
+                     Rejestruje dane wyjściowe kompilacji w wielu plikach dziennika,po jednym pliku
+                     na węzeł programu MSBuild. Początkową lokalizacją tych plików
+                     jest bieżący katalog. Domyślnie pliki mają nazwę
                      „MSBuild&lt;identyfikator węzła&gt;.log”. Lokalizację plików
                      i inne parametry rejestratora plików można określić
-
                      przez dodanie przełącznika „-fileLoggerParameters”.
 
                      Jeśli nazwa pliku zostanie ustawiona za pomocą przełącznika
@@ -1004,7 +1032,7 @@
                      Dostępne są parametry takie same, jak podane dla rejestratora
                      konsoli. Dostępne są również dodatkowe parametry:
                        LogFile — ścieżka do pliku dziennika, w którym będzie
-                                 zapisywany dziennik kompilacji. 
+                                 zapisywany dziennik kompilacji.
                        Append — określa, czy plik dziennika kompilacji zostanie
                                 dołączony do pliku dziennika, czy go zastąpi.
                                 Ustawienie tego przełącznika powoduje dołączenie dziennika kompilacji
@@ -1018,8 +1046,8 @@
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1292,6 +1320,33 @@
         <target state="translated">Dzienniki i informacje debugowania programu MSBuild będą znajdować się w lokalizacji „{0}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: Musi podać nazwę elementu dla przełącznika getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: Musi podać nazwę właściwości dla przełącznika getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: Musi podać nazwę celu dla przełącznika getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: określ rejestrator.</target>
@@ -1347,7 +1402,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: W przypadku korzystania z przełącznika -terminalLoggerParameters określ co najmniej jeden parametr dla rejestratora terminalu</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1569,6 +1624,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Nie można uzyskać dostępu do właściwości lub elementów podczas tworzenia plików rozwiązań lub plików filtrów rozwiązań. Ta funkcja jest dostępna tylko podczas tworzenia pojedynczych projektów.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1918,10 +1981,10 @@ dzienników                     tekstowych i wykorzystać w innych narzędziach
     </source>
         <target state="translated">  -restore[:True|False]
                      Uruchamia element docelowy o nazwie Restore przed skompilowaniem
-                     innych elementów docelowych i zapewnia, że kompilacja tych 
-                     elementów docelowych korzysta z najnowszej logiki przywróconej 
-                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga 
-                     przywrócenia pakietów przed ich skompilowaniem. Podanie parametru 
+                     innych elementów docelowych i zapewnia, że kompilacja tych
+                     elementów docelowych korzysta z najnowszej logiki przywróconej
+                     kompilacji. Jest to przydatne, gdy drzewo projektu wymaga
+                     przywrócenia pakietów przed ich skompilowaniem. Podanie parametru
                      -restore jest równoznaczne z podaniem parametru -restore:True.
                      Za pomocą tego parametru można przesłonić wartość pochodzącą
                      z pliku odpowiedzi.
@@ -2005,4 +2068,4 @@ dzienników                     tekstowych i wykorzystać w innych narzędziach
       </trans-unit>
     </body>
   </file>
-</xliff>
\ No newline at end of file
+</xliff>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 01b3db027b5..ef5b892c990 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Falha na compilação. Não foi possível obter os resultados de Propriedades, Itens e Destino. Veja os detalhes no stderr acima.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Construir {0} em {1}s</target>
@@ -91,6 +96,25 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Faz com que o MSBuild relate acessos a arquivos a qualquer
+ configurado
+                     plug-ins de cache do projeto.
+
+                     Este sinalizador é experimental e pode não funcionar conforme o esperado.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,6 +135,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: o valor de acesso ao arquivo de relatório não é válido. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -718,10 +752,10 @@ arquivo de resposta.
                      MSBuild will use up to the number of processors on the
                      computer. (Short form: -m[:n])
       </source>
-        <target state="translated">  -maxCpuCount[:n] Especifica o número máximo de processos simultâneos a serem 
+        <target state="translated">  -maxCpuCount[:n] Especifica o número máximo de processos simultâneos a serem
                      compilados. Se a opção não for usada, o valor padrão
                      usado será 1. Se a opção for usada sem um valor, o
-                     MSBuild usará o número de processadores do 
+                     MSBuild usará o número de processadores do
                      computador. (Forma abreviada: -m[:n])
       </target>
         <note>
@@ -739,7 +773,7 @@ arquivo de resposta.
         <target state="translated">Exemplos:
 
         MSBuild MyApp.sln -t:Rebuild -p:Configuration=Release
-        MSBuild MyApp.csproj -t:Clean 
+        MSBuild MyApp.csproj -t:Clean
                              -p:Configuration=Debug;TargetFrameworkVersion=v3.5
     </target>
         <note>
@@ -900,12 +934,12 @@ arquivo de resposta.
                      10 file loggers to be attached. (Short form: -fl[n])
     </source>
         <target state="translated">  -fileLogger[n] Registra a saída do build em um arquivo. Por padrão,
-                     o arquivo está no diretório atual e tem o nome 
+                     o arquivo está no diretório atual e tem o nome
                      "msbuild[n].log". Os eventos de todos os nós são combinados em
                      um único log. A localização do arquivo e outros
-                     parâmetros do fileLogger pode ser especificada por meio 
+                     parâmetros do fileLogger pode ser especificada por meio
                      do acréscimo da opção "-fileLoggerParameters[n]".
-                     "n", se presente, pode ser um dígito de 1 a 9, permitindo que até 
+                     "n", se presente, pode ser um dígito de 1 a 9, permitindo que até
                      10 agentes de arquivo sejam anexados. (Forma abreviada: -fl[n])
     </target>
         <note>
@@ -1058,14 +1092,14 @@ arquivo de resposta.
                      Example:
                        -pp:out.txt
     </source>
-        <target state="translated">  -preprocess[:arquivo] 
+        <target state="translated">  -preprocess[:arquivo]
                      Cria um arquivo de projeto único e agregado
                      embutindo todos os arquivos que poderiam ser importados durante um
                      build, com seus limites marcados. Isso pode ser
                      útil para descobrir quais arquivos são importados,
                      de qual localização e como contribuirão para
                      o build. Por padrão, a saída é gravada na
-                     janela do console. Se o caminho de um arquivo de saída 
+                     janela do console. Se o caminho de um arquivo de saída
                      for fornecido, ele será usado.
                      (Forma abreviada: -pp)
                      Exemplo:
@@ -1282,6 +1316,33 @@ arquivo de resposta.
         <target state="translated">Os logs e as informações de depuração do MSBuild estarão no "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: É preciso fornecer um nome de item para a chave getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: É preciso fornecer um nome de propriedade para a chave getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: É preciso fornecer um nome de destino para a chave getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especificar um agente de log.</target>
@@ -1337,7 +1398,7 @@ arquivo de resposta.
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: Especifique um ou mais parâmetros para o agente de terminal se estiver usando a opção -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1559,6 +1620,14 @@ arquivo de resposta.
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Não foi possível acessar propriedades ou itens ao compilar arquivos de solução ou arquivos de filtro de solução. Esse recurso só está disponível para a compilação de projetos individuais.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
@@ -1753,7 +1822,7 @@ arquivo de resposta.
                        -warnAsError:MSB4130
 
                      Quando um aviso for tratado como um erro, o destino continuará
-                     a ser executado como se ele fosse um aviso, mas o 
+                     a ser executado como se ele fosse um aviso, mas o
                      build geral falhará.
     </target>
         <note>
@@ -1995,4 +2064,4 @@ arquivo de resposta.
       </trans-unit>
     </body>
   </file>
-</xliff>
\ No newline at end of file
+</xliff>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 26c3dcc2dd1..3bb7dcc1c0a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Сборка не удалась. Не удается получить свойства, элементы и целевые результаты. См. подробности в stderr выше.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">Сборка {0} через {1} с</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     Включение отчетов MSBuild о доступе к файлам для всех настроенных
+                     подключаемых модулей кэша проекта.
+
+                     Этот флаг является экспериментальным и может работать неправильно.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -105,12 +128,22 @@
       </trans-unit>
       <trans-unit id="InvalidTerminalLoggerValue">
         <source>MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</source>
-        <target state="new">MSBUILD : error MSB1065: Terminal logger value is not valid. It should be one of 'auto', 'true', or 'false'. {0}</target>
+        <target state="translated">MSBUILD : error MSB1065: Недопустимое значение средства ведения журнала терминала. Это должно быть одно из следующих значений: "auto", "ИСТИНА" или "ЛОЖЬ". {0}</target>
         <note>
       {StrBegin="MSBUILD : error MSB1065: "}
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: переданное значение отчета о доступе к файлам является недопустимым. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1280,6 +1313,33 @@
         <target state="translated">Журналы MSBuild и отладочные сведения будут доступны по адресу "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: необходимо указать имя элемента для переключателя getItem.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: необходимо указать имя свойства для переключателя getProperty.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: необходимо указать целевое имя для переключателя getTargetResult.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: укажите журнал.</target>
@@ -1335,7 +1395,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: укажите один или несколько параметров для регистратора терминала при использовании переключателя -terminalLoggerParameters</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1557,6 +1617,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: не удается получить доступ к свойствам или элементам при создании файлов решений или файлов фильтров решений. Эта функция доступна только при создании отдельных проектов.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 669b02a92b8..75d73f551ca 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">Derleme başarısız oldu. Özellikler, Öğeler ve Hedef sonuçları alınamıyor. Yukarıda stderr'de ayrıntılara bakın.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">"{1}" sn'de {0} oluşturun</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     MSBuild’in yapılandırılmış proje önbelleği eklentilerine dosya
+                     erişimlerini bildirmesine neden olur.
+
+                     Bu bayrak deneme amaçlıdır ve istendiği gibi çalışmayabilir.
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: Dosya erişimleri değerinin geçerli olmadığını bildirir. {0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -533,13 +566,13 @@
         <target state="translated">  -logger:&lt;günlükçü&gt;   MSBuild'deki olayları günlüğe almak için bu günlükçüyü kullanın. Birden fazla
                      günlükçü belirtmek için her günlükçüyü ayrı ayrı belirtin.
                      &lt;günlükçü&gt; söz dizimi şöyledir:
-                       [&lt;sınıf&gt;,]&lt;derleme&gt;[,&lt;seçenekler&gt;][;&lt;parametreler&gt;]
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
                      &lt;günlükçü sınıfı &gt; söz dizimi şöyledir:
                        [&lt;kısmi veya tam ad alanı &gt;.]&lt;günlükçü sınıfı adı&gt;
                      &lt;günlükçü derlemesi&gt; söz dizimi şöyledir:
-                       {&lt;derleme adı&gt;[,&lt;strong name&gt;] | &lt;derleme dosyası&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Günlükçü seçenekleri, MSBuild'in günlükçüyü oluşturma biçimini belirtir.
-                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak 
+                     &lt;günlükçü parametreleri &gt; isteğe bağlıdır ve tam olarak
                      yazdığınız şekliyle günlükçüye geçirilir. (Kısa biçim: -l)
                      Örnekler:
                        -logger:XMLLogger,MyLogger,Version=1.0.2,Culture=neutral
@@ -815,11 +848,11 @@
                      günlükçü belirtmek için her günlükçüyü ayrı ayrı belirtin.
                      (Kısa biçim -dl)
                      &lt;günlükçü&gt; söz dizimi şöyledir:
-                       [&lt;sınıf&gt;,]&lt;derleme&gt;[,&lt;seçenekler&gt;][;&lt;parametreler&gt;]
+                       [&lt;sınıf&gt;,]&lt;assembly&gt;[,&lt;seçenekler&gt;][;&lt;parametreler&gt;]
                      &lt;günlükçü sınıfı&gt; söz dizimi şöyledir:
                        [&lt;kısmi veya tam ad alanı&gt;.]&lt;günlükçü sınıfı adı&gt;
                      &lt;günlükçü derlemesi&gt; söz dizimi şöyledir:
-                       {&lt;derleme adı&gt;[,&lt;strong name&gt;] | &lt;derleme dosyası&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      Günlükçü seçenekleri, MSBuild'in günlükçüyü oluşturma biçimini belirtir.
                      &lt;günlükçü parametreleri&gt; isteğe bağlıdır ve tam olarak
                      yazdığınız şekliyle günlükçüye geçirilir. (Kısa biçim: -l)
@@ -846,10 +879,9 @@
                        -ignoreProjectExtensions:.sln
     </source>
         <target state="translated">  -ignoreProjectExtensions:&lt;uzantılar&gt;
-                     Hangi proje dosyasının oluşturulacağı belirlenirken 
-                     yoksayılacak uzantıların listesi. Birden çok uzantıyı 
-                     birbirinden ayırmak için noktalı virgül veya 
-                     virgül kullanın.
+                     Hangi proje dosyasının oluşturulacağı belirlenirken
+                     yoksayılacak uzantıların listesi. Birden çok uzantıyı
+                     birbirinden ayırmak için noktalı virgül veya virgül kullanın.
                      (Kısa biçim: -ignore)
                      Örnek:
                        -ignoreProjectExtensions:.sln
@@ -939,7 +971,6 @@
                      Dosyaların konumu ve fileLogger'ın diğer parametreleri 
                      "/fileLoggerParameters" anahtarının eklenmesi yoluyla
                      belirtilebilir.
-
                      Günlük dosyası adı fileLoggerParameters anahtarı
                      aracılığıyla ayarlanırsa dağıtılmış günlükçü fileName 
                      değerini şablon olarak kullanıp her düğümün günlük dosyasını
@@ -986,32 +1017,31 @@
     </source>
         <target state="translated">  -fileLoggerParameters[n]:&lt;parametreler&gt;
                      Dosya günlükçüleri için ek parametreler sağlar.
-                     Bu anahtarın olması karşılık gelen -fileLogger[n] 
+                     Bu anahtarın olması karşılık gelen -fileLogger[n]
                      anahtarının olduğu anlamına gelir.
                      "n" varsa, 1-9 arasında bir rakam olabilir.
-                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters 
-                     bunlar tarafından da kullanılır; -distributedFileLogger 
-                     açıklamasına bakın.
+                     Dağıtılmış dosya günlükçüleri varsa -fileLoggerParameters
+                     bunlar tarafından da kullanılır; -distributedFileLogger açıklamasına bakın.
                      (Kısa biçim: -flp[n])
-                     Konsol günlükçüsü için listelenenlerle aynı parametreler 
+                     Konsol günlükçüsü için listelenenlerle aynı parametreler
                      kullanılabilir. Kullanılabilecek bazı ek parametreler:
-                        LogFile--Oluşturma günlüğünün yazılacağı günlük 
+                        LogFile--Oluşturma günlüğünün yazılacağı günlük
                             dosyasının yolu.
-                        Append--Derleme günlüğünün gün dosyasının sonuna mı 
-                            ekleneceğini yoksa üzerine mi yazılacağını 
-                            belirler. Anahtar ayarlandığında oluşturma günlüğü 
-                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında 
-                            varolan günlük dosyasının üzerine yazılır. 
+                        Append--Derleme günlüğünün gün dosyasının sonuna mı
+                            ekleneceğini yoksa üzerine mi yazılacağını
+                            belirler. Anahtar ayarlandığında oluşturma günlüğü
+                            dosyanın sonuna eklenir. Anahtar ayarlanmadığında
+                            varolan günlük dosyasının üzerine yazılır.
                             Varsayılan: günlük dosyasının sonuna eklenmez.
-                        Encoding--Dosyanın kodlamasını belirtir; örneğin, 
+                        Encoding--Dosyanın kodlamasını belirtir; örneğin,
                             UTF-8, Unicode veya ASCII
                      Varsayılan ayrıntı düzeyi ayarı Detailed'dır.
                      Örnekler:
                        -fileLoggerParameters:LogFile=MyLog.log;Append;
                                            Verbosity=diagnostic;Encoding=UTF-8
 
-                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum 
-                       -flp1:warningsonly;logfile=msbuild.wrn 
+                       -flp:Summary;Verbosity=minimal;LogFile=msbuild.sum
+                       -flp1:warningsonly;logfile=msbuild.wrn
                        -flp2:errorsonly;logfile=msbuild.err
     </target>
         <note>
@@ -1035,8 +1065,7 @@
                        -nr:true
     </source>
         <target state="translated">  -nodeReuse:&lt;parametreler&gt;
-                     MSBuild düğümlerinin yeniden kullanımını etkinleştirir
-                     veya devre dışı bırakır.
+                     MSBuild düğümlerinin yeniden kullanımını etkinleştirir veya devre dışı bırakır.
                      Parametreler:
                      True --Derleme tamamlandıktan sonra düğümler kalır ve
                             izleyen derlemelerde yeniden kullanılır (varsayılan)
@@ -1285,6 +1314,33 @@
         <target state="translated">MSBuild günlükleri ve hata ayıklama bilgileri "{0}" yolunda olacak</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: getItem anahtarı için bir öğe adı sağlanması gerekiyor.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: getProperty anahtarı için bir özellik adı belirtilmelidir.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: getTargetResult anahtarı için bir hedef adı sağlanması gerekiyor.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Günlükçü belirtin.</target>
@@ -1340,7 +1396,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: terminalLoggerParameters anahtarı kullanılıyorsa terminal günlükçüsü için bir veya birden çok parametre belirtin</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1562,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: Çözüm dosyaları veya çözüm filtresi dosyaları oluşturulurken özelliklere veya öğelere erişilemiyor. Bu özellik yalnızca tek tek projeler oluşturulurken kullanılabilir.</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 924411e326d..db252831300 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">生成失败。无法获取属性、项目和目标结果。在上面的 stderr 中查看详细信息。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">在 {1} 中生成 {0}</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     导致 MSBuild 报告对任何已配置
+                     项目缓存插件的文件访问。
+
+                     此标志是实验性的，可能无法按预期工作。
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: 报表文件访问值无效。{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -1281,6 +1314,33 @@
         <target state="translated">MSBuild 日志和调试信息将位于"{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: 必须为 getItem 开关提供项名称。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: 必须为 getProperty 开关提供属性名称。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: 必须为 getTargetResult 开关提供目标名称。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 请指定记录器。</target>
@@ -1336,7 +1396,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: 为终端记录器指定一个或多个参数 (如果使用 -terminalLoggerParameters 开关)</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1558,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: 生成解决方案文件或解决方案筛选器文件时无法访问属性或项。此功能仅在生成单个项目时可用。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 16866b4f8bc..37b67b89bd3 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="BuildFailedWithPropertiesItemsOrTargetResultsRequested">
+        <source>Build failed. Properties, Items, and Target results cannot be obtained. See details in stderr above.</source>
+        <target state="translated">建置失敗。無法取得屬性、項目及目標結果。請參閱上述 stderr 中的詳細資料。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildFinished">
         <source>Build {0} in {1}s</source>
         <target state="translated">在 {1} 秒內建置 {0}</target>
@@ -91,6 +96,24 @@
       LOCALIZATION: "MSBuild" should not be localized.
       LOCALIZATION: "-question" and "-q" should not be localized.
       LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
+    </note>
+      </trans-unit>
+      <trans-unit id="HelpMessage_42_ReportFileAccessesSwitch">
+        <source>  -reportFileAccesses[:True|False]
+                     Causes MSBuild to report file accesses to any configured
+                     project cache plugins.
+
+                     This flag is experimental and may not work as intended.
+    </source>
+        <target state="translated">  -reportFileAccesses[:True|False]
+                     導致 MSBuild 報告任何已設定之專案快取外掛程式的
+                     檔案存取。
+
+                     此旗標為實驗性質，可能無法如預期般運作。
+    </target>
+        <note>
+      LOCALIZATION: "-reportFileAccesses" should not be localized.
+      LOCALIZATION: None of the lines should be longer than a standard width console window, eg 80 chars.
     </note>
       </trans-unit>
       <trans-unit id="InvalidLowPriorityValue">
@@ -111,6 +134,16 @@
       UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
       This error is shown when a user specifies a value for the lowPriority parameter that is not equivalent to Boolean.TrueString or Boolean.FalseString.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="InvalidReportFileAccessesValue">
+        <source>MSBUILD : error MSB1063: Report file accesses value is not valid. {0}</source>
+        <target state="translated">MSBUILD : error MSB1063: 報告檔案存取值無效。{0}</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}
+      UE: This message does not need in-line parameters because the exception takes care of displaying the invalid arg.
+      This error is shown when a user specifies a value that is not equivalent to Boolean.TrueString or Boolean.FalseString.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MSBuildVersionMessage">
@@ -533,11 +566,11 @@
         <target state="translated">  -logger:&lt;記錄器&gt;   使用此記錄器可記錄 MSBuild 的事件。
                      若要指定多個記錄器，請各別指定每個記錄器。
                      &lt;記錄器&gt; 語法為:
-                       [&lt;類別&gt;,]&lt;組件&gt;[,&lt;選項&gt;][;&lt;參數&gt;]
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
                      &lt;記錄器類別&gt; 語法為:
                        [&lt;一部分或完整的命名空間&gt;.]&lt;記錄器類別名稱&gt;
                      &lt;記錄器組件&gt; 語法為:
-                       {&lt;組件名稱&gt;[,&lt;strong name&gt;] | &lt;組件檔案&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      記錄器選項會指定 MSBuild 建立記錄器的方式。
                      &lt;記錄器參數&gt; 是選擇性參數，其會依您輸入的內容，
                      完全一樣地傳遞到記錄器。(簡短形式: -l)
@@ -815,11 +848,11 @@
                      若要指定多個記錄器，請各別指定每個記錄器。
                      (簡短形式 -dl)
                      &lt;記錄器&gt; 語法為:
-                       [&lt;類別&gt;,]&lt;組件&gt;[,&lt;選項&gt;][;&lt;參數&gt;]
+                       [&lt;class&gt;,]&lt;assembly&gt;[,&lt;options&gt;][;&lt;parameters&gt;]
                      &lt;記錄器類別&gt; 語法為:
                        [&lt;一部分或完整的命名空間&gt;.]&lt;記錄器類別名稱&gt;
                      &lt;記錄器組件&gt; 語法為:
-                       {&lt;組件名稱&gt;[,&lt;strong name&gt;] | &lt;組件檔案&gt;}
+                       {&lt;assembly name&gt;[,&lt;strong name&gt;] | &lt;assembly file&gt;}
                      記錄器選項會指定 MSBuild 建立記錄器的方式。
                      &lt;記錄器參數&gt; 是選擇性參數，其會依您輸入的內容，
                      完全一樣地傳遞到記錄器。(簡短形式: -l)
@@ -1281,6 +1314,33 @@
         <target state="translated">MSBuild 記錄和偵錯工具資訊將位於 "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MissingGetItemError">
+        <source>MSBUILD : error MSB1014: Must provide an item name for the getItem switch.</source>
+        <target state="translated">MSBUILD : error MSB1014: 必須提供 getItem 切換的項目名稱。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1014: "}UE: This happens if the user does something like "msbuild.exe -getItem". The user must pass in an actual item name
+      following the switch, as in "msbuild.exe -getItem:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetPropertyError">
+        <source>MSBUILD : error MSB1010: Must provide a property name for the getProperty switch.</source>
+        <target state="translated">MSBUILD : error MSB1010: 必須提供 getProperty 切換的屬性名稱。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1010: "}UE: This happens if the user does something like "msbuild.exe -getProperty". The user must pass in an actual property name
+      following the switch, as in "msbuild.exe -getProperty:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingGetTargetResultError">
+        <source>MSBUILD : error MSB1017: Must provide a target name for the getTargetResult switch.</source>
+        <target state="translated">MSBUILD : error MSB1017: 必須提供 getTargetResult 切換的目標名稱。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1017: "}UE: This happens if the user does something like "msbuild.exe -getTargetResult". The user must pass in an actual target name
+      following the switch, as in "msbuild.exe -getTargetResult:blah".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 指定記錄器。</target>
@@ -1336,7 +1396,7 @@
       </trans-unit>
       <trans-unit id="MissingTerminalLoggerParameterError">
         <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
-        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <target state="translated">MSBUILD : error MSB1066: 如果使用 -terminalLoggerParameters 參數，請為終端機記錄器指定一或多個參數</target>
         <note>
       {StrBegin="MSBUILD : error MSB1066: "}
       UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
@@ -1558,6 +1618,14 @@
         <note>{StrBegin="MSBUILD : error MSB1026: "}UE: This error is printed if the default schema does not exist or in the extremely unlikely event
     that an explicit schema file was passed and existed when the command line parameters were checked but was deleted from disk before this check was made.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="SolutionBuildInvalidForCommandLineEvaluation">
+        <source>MSBUILD : error MSB1063: Cannot access properties or items when building solution files or solution filter files. This feature is only available when building individual projects.</source>
+        <target state="translated">MSBUILD : error MSB1063: 建置方案檔案或方案篩選檔案時，無法存取屬性或項目。此功能僅於建置個別專案時可用。</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1063: "}UE: This happens if the user passes in a solution file when trying to access individual properties or items. The user must pass in a project file.
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SwitchErrorWithArguments">
         <source>{0}
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index 59062e62140..0d5d5cd2b09 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -9,7 +9,6 @@
 using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using System.Runtime.InteropServices;
 #if NETFRAMEWORK
 using Microsoft.IO;
 #else
@@ -216,6 +215,11 @@ public void Initialize(IEventSource eventSource)
         eventSource.MessageRaised += MessageRaised;
         eventSource.WarningRaised += WarningRaised;
         eventSource.ErrorRaised += ErrorRaised;
+
+        if (eventSource is IEventSource4 eventSource4)
+        {
+            eventSource4.IncludeEvaluationPropertiesAndItems();
+        }
     }
 
     /// <inheritdoc/>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index f9abb1c670f..4bd327aa7de 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -17,28 +17,30 @@
 using System.Text;
 using System.Text.RegularExpressions;
 using System.Threading;
-
+using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Graph;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
-
-using FileLogger = Microsoft.Build.Logging.FileLogger;
+using Microsoft.Build.Utilities;
+using static Microsoft.Build.CommandLine.MSBuildApp;
+using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
-using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
+using FileLogger = Microsoft.Build.Logging.FileLogger;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
-using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
+using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
+using SimpleErrorLogger = Microsoft.Build.Logging.SimpleErrorLogger.SimpleErrorLogger;
 using TerminalLogger = Microsoft.Build.Logging.TerminalLogger.TerminalLogger;
-using Microsoft.Build.Shared.Debugging;
-using Microsoft.Build.Experimental;
-using Microsoft.Build.Framework.Telemetry;
-using Microsoft.Build.Internal;
 
 #nullable disable
 
@@ -707,6 +709,13 @@ public static ExitType Execute(
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
                 bool question = false;
+                string[] getProperty = Array.Empty<string>();
+                string[] getItem = Array.Empty<string>();
+                string[] getTargetResult = Array.Empty<string>();
+                BuildResult result = null;
+#if FEATURE_REPORTFILEACCESSES
+                bool reportFileAccesses = false;
+#endif
 
                 GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out _);
                 bool buildCanBeInvoked = ProcessCommandLineSwitches(
@@ -741,8 +750,14 @@ public static ExitType Execute(
                                             ref graphBuildOptions,
                                             ref inputResultsCaches,
                                             ref outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+                                            ref reportFileAccesses,
+#endif
                                             ref lowPriority,
                                             ref question,
+                                            ref getProperty,
+                                            ref getItem,
+                                            ref getTargetResult,
                                             recursing: false,
 #if FEATURE_GET_COMMANDLINE
                                             commandLine);
@@ -776,12 +791,31 @@ public static ExitType Execute(
 
                     DateTime t1 = DateTime.Now;
 
+                    bool outputPropertiesItemsOrTargetResults = getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0;
+
                     // If the primary file passed to MSBuild is a .binlog file, play it back into passed loggers
                     // as if a build is happening
                     if (FileUtilities.IsBinaryLogFilename(projectFile))
                     {
                         ReplayBinaryLog(projectFile, loggers, distributedLoggerRecords, cpuCount);
                     }
+                    else if (outputPropertiesItemsOrTargetResults && FileUtilities.IsSolutionFilename(projectFile))
+                    {
+                        exitType = ExitType.BuildError;
+                        CommandLineSwitchException.Throw("SolutionBuildInvalidForCommandLineEvaluation",
+                            getProperty.Length > 0 ? "getProperty" :
+                            getItem.Length > 0 ? "getItem" :
+                            "getTargetResult");
+                    }
+                    else if ((getProperty.Length > 0 || getItem.Length > 0) && (targets is null || targets.Length == 0))
+                    {
+                        using (ProjectCollection collection = new(globalProperties, loggers, ToolsetDefinitionLocations.Default))
+                        {
+                            Project project = collection.LoadProject(projectFile, globalProperties, toolsVersion);
+                            exitType = OutputPropertiesAfterEvaluation(getProperty, getItem, project);
+                            collection.LogBuildFinishedEvent(exitType == ExitType.Success);
+                        }
+                    }
                     else // regular build
                     {
                         // if everything checks out, and sufficient information is available to start building
@@ -816,6 +850,11 @@ public static ExitType Execute(
                                     question,
                                     inputResultsCaches,
                                     outputResultsCache,
+                                    saveProjectResult: outputPropertiesItemsOrTargetResults,
+                                    ref result,
+#if FEATURE_REPORTFILEACCESSES
+                                    reportFileAccesses,
+#endif
                                     commandLine))
                         {
                             exitType = ExitType.BuildError;
@@ -828,6 +867,11 @@ public static ExitType Execute(
 
                     string timerOutputFilename = Environment.GetEnvironmentVariable("MSBUILDTIMEROUTPUTS");
 
+                    if (outputPropertiesItemsOrTargetResults && targets?.Length > 0 && result is not null)
+                    {
+                        exitType = OutputBuildInformationInJson(result, getProperty, getItem, getTargetResult, loggers, exitType);
+                    }
+
                     if (!string.IsNullOrEmpty(timerOutputFilename))
                     {
                         AppendOutputFile(timerOutputFilename, (long)elapsedTime.TotalMilliseconds);
@@ -985,6 +1029,64 @@ public static ExitType Execute(
             return exitType;
         }
 
+        private static ExitType OutputPropertiesAfterEvaluation(string[] getProperty, string[] getItem, Project project)
+        {
+            try
+            {
+                // Special case if the user requests exactly one property: skip json formatting
+                if (getProperty.Length == 1 && getItem.Length == 0)
+                {
+                    Console.WriteLine(project.GetPropertyValue(getProperty[0]));
+                }
+                else
+                {
+                    JsonOutputFormatter jsonOutputFormatter = new();
+                    jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => project.GetPropertyValue(property));
+                    jsonOutputFormatter.AddItemsInJsonFormat(getItem, project);
+                    Console.WriteLine(jsonOutputFormatter.ToString());
+                }
+
+                return ExitType.Success;
+            }
+            catch (InvalidProjectFileException e)
+            {
+                Console.Error.WriteLine(e.Message);
+                return ExitType.BuildError;
+            }
+        }
+
+        private static ExitType OutputBuildInformationInJson(BuildResult result, string[] getProperty, string[] getItem, string[] getTargetResult, ILogger[] loggers, ExitType exitType)
+        {
+            ProjectInstance builtProject = result.ProjectStateAfterBuild;
+
+            ILogger logger = loggers.FirstOrDefault(l => l is SimpleErrorLogger);
+            if (logger is not null)
+            {
+                exitType = exitType == ExitType.Success && (logger as SimpleErrorLogger).HasLoggedErrors ? ExitType.BuildError : exitType;
+            }
+
+            if (builtProject is null)
+            {
+                // Build failed; do not proceed
+                Console.Error.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildFailedWithPropertiesItemsOrTargetResultsRequested"));
+            }
+            // Special case if the user requests exactly one property: skip the json formatting
+            else if (getProperty.Length == 1 && getItem.Length == 0 && getTargetResult.Length == 0)
+            {
+                Console.WriteLine(builtProject.GetPropertyValue(getProperty[0]));
+            }
+            else
+            {
+                JsonOutputFormatter jsonOutputFormatter = new();
+                jsonOutputFormatter.AddPropertiesInJsonFormat(getProperty, property => builtProject.GetPropertyValue(property));
+                jsonOutputFormatter.AddItemInstancesInJsonFormat(getItem, builtProject);
+                jsonOutputFormatter.AddTargetResultsInJsonFormat(getTargetResult, result);
+                Console.WriteLine(jsonOutputFormatter.ToString());
+            }
+
+            return exitType;
+        }
+
         /// <summary>
         /// Handler for when CTRL-C or CTRL-BREAK is called.
         /// CTRL-BREAK means "die immediately"
@@ -1137,6 +1239,11 @@ internal static bool BuildProject(
             bool question,
             string[] inputResultsCaches,
             string outputResultsCache,
+            bool saveProjectResult,
+            ref BuildResult result,
+#if FEATURE_REPORTFILEACCESSES
+            bool reportFileAccesses,
+#endif
 #if FEATURE_GET_COMMANDLINE
             string commandLine)
 #else
@@ -1148,7 +1255,7 @@ internal static bool BuildProject(
                 InitializationException.Throw(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectUpgradeNeededToVcxProj", projectFile), null);
             }
 
-            bool success = false;
+            bool success = true;
 
             ProjectCollection projectCollection = null;
             bool onlyLogCriticalEvents = false;
@@ -1264,11 +1371,12 @@ internal static bool BuildProject(
 
                 if (isPreprocess)
                 {
+                    success = false;
+
                     // TODO: Support /preprocess for solution files. https://github.com/dotnet/msbuild/issues/7697
                     if (isSolution)
                     {
                         Console.WriteLine(ResourceUtilities.GetResourceString("UnsupportedSwitchForSolutionFiles"), CommandLineSwitches.ParameterizedSwitch.Preprocess);
-                        success = false;
                     }
                     else
                     {
@@ -1282,13 +1390,14 @@ internal static bool BuildProject(
                     }
                 }
 
-                if (isTargets)
+                if (isTargets && success)
                 {
+                    success = false;
+
                     // TODO: Support /targets for solution files. https://github.com/dotnet/msbuild/issues/7697
                     if (isSolution)
                     {
                         Console.WriteLine(ResourceUtilities.GetResourceString("UnsupportedSwitchForSolutionFiles"), CommandLineSwitches.ParameterizedSwitch.Targets);
-                        success = false;
                     }
                     else
                     {
@@ -1298,6 +1407,7 @@ internal static bool BuildProject(
 
                 if (!isPreprocess && !isTargets)
                 {
+                    success = false;
                     BuildParameters parameters = new BuildParameters(projectCollection);
 
                     // By default we log synchronously to the console for compatibility with previous versions,
@@ -1328,6 +1438,9 @@ internal static bool BuildProject(
                     parameters.InputResultsCacheFiles = inputResultsCaches;
                     parameters.OutputResultsCacheFile = outputResultsCache;
                     parameters.Question = question;
+#if FEATURE_REPORTFILEACCESSES
+                    parameters.ReportFileAccesses = reportFileAccesses;
+#endif
 
                     // Propagate the profiler flag into the project load settings so the evaluator
                     // can pick it up
@@ -1359,7 +1472,8 @@ internal static bool BuildProject(
 
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
 
-                    BuildResultCode? result = null;
+                    result = null;
+                    GraphBuildResult graphResult = null;
 
                     if (!Traits.Instance.EscapeHatches.DoNotSendDeferredMessagesToBuildManager)
                     {
@@ -1403,21 +1517,30 @@ internal static bool BuildProject(
                             BuildRequestData buildRequest = null;
                             if (!restoreOnly)
                             {
+                                // By default, the project state is thrown out after a build. The ProvideProjectStateAfterBuild flag adds the project state after build
+                                // to the BuildResult passed back at the end of the build. This can then be used to find the value of properties, items, etc. after the
+                                // build is complete.
+                                BuildRequestDataFlags flags = BuildRequestDataFlags.None;
+                                if (saveProjectResult)
+                                {
+                                    flags |= BuildRequestDataFlags.ProvideProjectStateAfterBuild;
+                                }
+
                                 if (graphBuildOptions != null)
                                 {
-                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, BuildRequestDataFlags.None, graphBuildOptions);
+                                    graphBuildRequest = new GraphBuildRequestData(new[] { new ProjectGraphEntryPoint(projectFile, globalProperties) }, targets, null, flags, graphBuildOptions);
                                 }
                                 else
                                 {
-                                    buildRequest = new BuildRequestData(projectFile, globalProperties, toolsVersion, targets, null);
+                                    buildRequest = new BuildRequestData(projectFile, globalProperties, toolsVersion, targets, null, flags);
                                 }
                             }
 
                             if (enableRestore || restoreOnly)
                             {
-                                (result, exception) = ExecuteRestore(projectFile, toolsVersion, buildManager, restoreProperties.Count > 0 ? restoreProperties : globalProperties);
+                                result = ExecuteRestore(projectFile, toolsVersion, buildManager, restoreProperties.Count > 0 ? restoreProperties : globalProperties, saveProjectResult: saveProjectResult);
 
-                                if (result != BuildResultCode.Success)
+                                if (result.OverallResult != BuildResultCode.Success)
                                 {
                                     return false;
                                 }
@@ -1427,17 +1550,38 @@ internal static bool BuildProject(
                             {
                                 if (graphBuildOptions != null)
                                 {
-                                    (result, exception) = ExecuteGraphBuild(buildManager, graphBuildRequest);
+                                    graphResult = ExecuteGraphBuild(buildManager, graphBuildRequest);
+
+                                    if (saveProjectResult)
+                                    {
+                                        ProjectGraphEntryPoint entryPoint = graphBuildRequest.ProjectGraphEntryPoints.Single();
+                                        if (!entryPoint.GlobalProperties.ContainsKey(PropertyNames.IsGraphBuild))
+                                        {
+                                            entryPoint.GlobalProperties[PropertyNames.IsGraphBuild] = "true";
+                                        }
+
+                                        result = graphResult.ResultsByNode.Single(
+                                            nodeResultKvp =>
+                                            nodeResultKvp.Key.ProjectInstance.FullPath.Equals(entryPoint.ProjectFile) &&
+                                            nodeResultKvp.Key.ProjectInstance.GlobalProperties.Count == entryPoint.GlobalProperties.Count &&
+                                            nodeResultKvp.Key.ProjectInstance.GlobalProperties.All(propertyKvp => entryPoint.GlobalProperties.TryGetValue(propertyKvp.Key, out string entryValue) &&
+                                                                                                                                        entryValue.Equals(propertyKvp.Value)))
+                                            .Value;
+                                    }
+                                    else
+                                    {
+                                        success = graphResult.OverallResult == BuildResultCode.Success;
+                                    }
                                 }
                                 else
                                 {
-                                    (result, exception) = ExecuteBuild(buildManager, buildRequest);
+                                    result = ExecuteBuild(buildManager, buildRequest);
                                 }
                             }
 
-                            if (result != null && exception == null)
+                            if (result != null && result.Exception == null)
                             {
-                                success = result == BuildResultCode.Success;
+                                success = result.OverallResult == BuildResultCode.Success;
                             }
                         }
                         finally
@@ -1580,7 +1724,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
             return messages;
         }
 
-        private static (BuildResultCode result, Exception exception) ExecuteBuild(BuildManager buildManager, BuildRequestData request)
+        private static BuildResult ExecuteBuild(BuildManager buildManager, BuildRequestData request)
         {
             BuildSubmission submission;
             lock (s_buildLock)
@@ -1596,11 +1740,10 @@ private static (BuildResultCode result, Exception exception) ExecuteBuild(BuildM
                 }
             }
 
-            var result = submission.Execute();
-            return (result.OverallResult, result.Exception);
+            return submission.Execute();
         }
 
-        private static (BuildResultCode result, Exception exception) ExecuteGraphBuild(BuildManager buildManager, GraphBuildRequestData request)
+        private static GraphBuildResult ExecuteGraphBuild(BuildManager buildManager, GraphBuildRequestData request)
         {
             GraphBuildSubmission submission;
             lock (s_buildLock)
@@ -1616,11 +1759,10 @@ private static (BuildResultCode result, Exception exception) ExecuteGraphBuild(B
                 }
             }
 
-            GraphBuildResult result = submission.Execute();
-            return (result.OverallResult, result.Exception);
+            return submission.Execute();
         }
 
-        private static (BuildResultCode result, Exception exception) ExecuteRestore(string projectFile, string toolsVersion, BuildManager buildManager, Dictionary<string, string> globalProperties)
+        private static BuildResult ExecuteRestore(string projectFile, string toolsVersion, BuildManager buildManager, Dictionary<string, string> globalProperties, bool saveProjectResult = false)
         {
             // Make a copy of the global properties
             Dictionary<string, string> restoreGlobalProperties = new Dictionary<string, string>(globalProperties);
@@ -1637,13 +1779,19 @@ private static (BuildResultCode result, Exception exception) ExecuteRestore(stri
             //     make available an import that doesn't exist yet and the <Import /> might be missing a condition.
             //  - BuildRequestDataFlags.FailOnUnresolvedSdk to still fail in the case when an MSBuild project SDK can't be resolved since this is fatal and should
             //     fail the build.
+            BuildRequestDataFlags flags = BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports | BuildRequestDataFlags.FailOnUnresolvedSdk;
+            if (saveProjectResult)
+            {
+                flags |= BuildRequestDataFlags.ProvideProjectStateAfterBuild;
+            }
+
             BuildRequestData restoreRequest = new BuildRequestData(
                 projectFile,
                 restoreGlobalProperties,
                 toolsVersion,
                 targetsToBuild: new[] { MSBuildConstants.RestoreTargetName },
                 hostServices: null,
-                flags: BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports | BuildRequestDataFlags.FailOnUnresolvedSdk);
+                flags: flags);
 
             return ExecuteBuild(buildManager, restoreRequest);
         }
@@ -2259,8 +2407,14 @@ private static bool ProcessCommandLineSwitches(
             ref GraphBuildOptions graphBuild,
             ref string[] inputResultsCaches,
             ref string outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+            ref bool reportFileAccesses,
+#endif
             ref bool lowPriority,
             ref bool question,
+            ref string[] getProperty,
+            ref string[] getItem,
+            ref string[] getTargetResult,
             bool recursing,
             string commandLine)
         {
@@ -2285,9 +2439,15 @@ private static bool ProcessCommandLineSwitches(
             }
 #endif
 
+            bool shouldShowLogo = !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoLogo] &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Preprocess) &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GetProperty) &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GetItem) &&
+                                  !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.GetTargetResult);
+
             // show copyright message if nologo switch is not set
             // NOTE: we heed the nologo switch even if there are switch errors
-            if (!recursing && !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoLogo] && !commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Preprocess))
+            if (!recursing && shouldShowLogo)
             {
                 DisplayVersionMessage();
             }
@@ -2313,6 +2473,13 @@ private static bool ProcessCommandLineSwitches(
             // leave priority where it was.
             catch (Win32Exception) { }
 
+#if FEATURE_REPORTFILEACCESSES
+            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.ReportFileAccesses))
+            {
+                reportFileAccesses = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ReportFileAccesses], defaultValue: true, resourceName: "");
+            }
+#endif
+
             // if help switch is set (regardless of switch errors), show the help message and ignore the other switches
             if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Help])
             {
@@ -2375,8 +2542,14 @@ private static bool ProcessCommandLineSwitches(
                                                            ref graphBuild,
                                                            ref inputResultsCaches,
                                                            ref outputResultsCache,
+#if FEATURE_REPORTFILEACCESSES
+                                                           ref reportFileAccesses,
+#endif
                                                            ref lowPriority,
                                                            ref question,
+                                                           ref getProperty,
+                                                           ref getItem,
+                                                           ref getTargetResult,
                                                            recursing: true,
                                                            commandLine);
                     }
@@ -2384,6 +2557,17 @@ private static bool ProcessCommandLineSwitches(
                     // figure out which targets we are building
                     targets = ProcessTargetSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Target]);
 
+                    // If we are looking for the value of a specific property or item post-evaluation or a target post-build, figure that out now
+                    getProperty = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetProperty] ?? Array.Empty<string>();
+                    getItem = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetItem] ?? Array.Empty<string>();
+                    getTargetResult = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GetTargetResult] ?? Array.Empty<string>();
+                    if (getProperty.Length > 0 || getItem.Length > 0 || getTargetResult.Length > 0)
+                    {
+                        commandLineSwitches.SetParameterizedSwitch(CommandLineSwitches.ParameterizedSwitch.Verbosity, "q", "q", true, true, true);
+                    }
+
+                    targets = targets.Union(getTargetResult, MSBuildNameIgnoreCaseComparer.Default).ToArray();
+
                     // figure out which ToolsVersion has been set on the command line
                     toolsVersion = ProcessToolsVersionSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ToolsVersion]);
 
@@ -2464,6 +2648,7 @@ private static bool ProcessCommandLineSwitches(
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ProfileEvaluation],
                         groupedFileLoggerParameters,
+                        getProperty.Length + getItem.Length + getTargetResult.Length > 0,
                         out distributedLoggerRecords,
                         out verbosity,
                         out originalVerbosity,
@@ -3474,6 +3659,7 @@ private static ILogger[] ProcessLoggingSwitches(
             string[] binaryLoggerParameters,
             string[] profileEvaluationParameters,
             string[][] groupedFileLoggerParameters,
+            bool useSimpleErrorLogger,
             out List<DistributedLoggerRecord> distributedLoggerRecords,
             out LoggerVerbosity verbosity,
             out LoggerVerbosity originalVerbosity,
@@ -3496,13 +3682,21 @@ private static ILogger[] ProcessLoggingSwitches(
             var outVerbosity = verbosity;
             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref outVerbosity);
 
-            ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);
+            // When returning the result of evaluation from the command line, do not use custom loggers.
+            if (!useSimpleErrorLogger)
+            {
+                ProcessLoggerSwitch(loggerSwitchParameters, loggers, verbosity);
+            }
 
             // Add any loggers which have been specified on the commandline
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
-            // Choose default console logger
-            if (terminalloggerOptIn)
+            // Otherwise choose default console logger: None, TerminalLogger, or the older ConsoleLogger
+            if (useSimpleErrorLogger)
+            {
+                loggers.Add(new SimpleErrorLogger());
+            }
+            else if (terminalloggerOptIn)
             {
                 ProcessTerminalLogger(noConsoleLogger, aggregatedTerminalLoggerParameters, distributedLoggerRecords, cpuCount, loggers);
             }
@@ -4269,6 +4463,9 @@ private static void ShowHelpMessage()
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_InputCachesFiles"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_OutputCacheFile"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_36_GraphBuildSwitch"));
+#if FEATURE_REPORTFILEACCESSES
+            Console.WriteLine(AssemblyResources.GetString("HelpMessage_42_ReportFileAccessesSwitch"));
+#endif
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_39_LowPrioritySwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_41_QuestionSwitch"));
             Console.WriteLine(AssemblyResources.GetString("HelpMessage_7_ResponseFile"));
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 91009eec184..1feab29307d 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -54,6 +54,18 @@
         </dependentAssembly>
 
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Native" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Native.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Processes" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Processes.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="BuildXL.Utilities.Core" publicKeyToken="6212d9137135ce5d" culture="neutral" />
+          <codeBase version="1.0.0.0" href="..\BuildXL.Utilities.Core.dll"/>
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
@@ -69,6 +81,10 @@
           <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
           <codeBase version="1.0.0.0" href="..\Microsoft.NET.StringTools.net35.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="RuntimeContracts" publicKeyToken="3d487639874b2199" culture="neutral" />
+          <codeBase version="0.5.0.0" href="..\RuntimeContracts.dll" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
@@ -121,6 +137,11 @@
           <bindingRedirect oldVersion="0.0.0.0-7.0.0.3" newVersion="7.0.0.3" />
           <codeBase version="7.0.0.3" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
+          <codeBase version="7.0.0.0" href="..\System.Threading.Channels.dll"/>
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-7.0.0.0" newVersion="7.0.0.0" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 463795025c0..aa4ce2eac58 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -14,6 +14,7 @@
          This is important for the MSBuild.VSSetup project, which "references" both the x86 and x64
          versions of this project -->
     <RuntimeIdentifiers Condition="'$(DotNetBuildFromSource)' != 'true'">win7-x86;win7-x64</RuntimeIdentifiers>
+    <UseRidGraph>true</UseRidGraph>
 
     <EnableDefaultItems>false</EnableDefaultItems>
     <DefineConstants>$(DefineConstants);CLR2COMPATIBILITY;TASKHOST;NO_FRAMEWORK_IVT</DefineConstants>
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 3780b51c588..06d5e138401 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -36,13 +36,18 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe vs.file.ngenArchitecture=x86 vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe.config
-  file source=$(TaskHostBinPath)MSBuildTaskHost.exe 
+  file source=$(TaskHostBinPath)MSBuildTaskHost.exe
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
+  file source=$(X86BinPath)BuildXL.Native.dll
+  file source=$(X86BinPath)BuildXL.Processes.dll
+  file source=$(X86BinPath)BuildXL.Utilities.Core.dll
+  file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Threading.Channels.dll
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -313,6 +318,13 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
   file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll
   file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll
 
+folder InstallDir:\MSBuild\Current\Bin\x86
+  file source=$(X86BinPath)x86\DetoursServices.dll
+
+folder InstallDir:\MSBuild\Current\Bin\x64
+  file source=$(X86BinPath)x64\DetoursServices.dll
+  file source=$(X86BinPath)x64\BuildXLNatives.dll
+
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
   file source=$(SourceDir)Framework\Microsoft.Build.Framework.pkgdef
diff --git a/src/Package/Microsoft.Build.UnGAC/exe.swr b/src/Package/Microsoft.Build.UnGAC/exe.swr
index 9a717021a50..03ae220174d 100644
--- a/src/Package/Microsoft.Build.UnGAC/exe.swr
+++ b/src/Package/Microsoft.Build.UnGAC/exe.swr
@@ -17,3 +17,8 @@ vs.installSize
 
 vs.payloads
     vs.payload source=$(BinDir)Microsoft.Build.UnGAC.exe
+
+vs.returnCodes
+  vs.returnCode type=success
+    exitCode=259
+    details="Suppress return-code 259 since this is a best-effort ."
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index 994c24341bd..822af5c1a96 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
@@ -108,7 +109,7 @@ public static void ReadExtendedBuildEventData(this BinaryReader reader, IExtende
             bool haveMetadata = reader.ReadBoolean();
             if (haveMetadata)
             {
-                data.ExtendedMetadata = new();
+                data.ExtendedMetadata = new Dictionary<string, string?>();
 
                 int count = reader.Read7BitEncodedInt();
                 for (int i = 0; i < count; i++)
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index a7ef74e8737..eca284ecb64 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -167,7 +167,9 @@ internal static bool IsIoRelatedException(Exception e)
         internal static bool IsXmlException(Exception e)
         {
             return e is XmlException
-                || e is XmlSyntaxException
+#if FEATURE_SECURITY_PERMISSIONS
+                || e is System.Security.XmlSyntaxException
+#endif
                 || e is XmlSchemaException
                 || e is UriFormatException; // XmlTextReader for example uses this under the covers
         }
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index cb89889c3ac..52d335944af 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -190,6 +190,16 @@ internal enum NodePacketType : byte
         /// </summary>
         ResourceResponse,
 
+        /// <summary>
+        /// Message sent from a node reporting a file access.
+        /// </summary>
+        FileAccessReport,
+
+        /// <summary>
+        /// Message sent from a node reporting process data.
+        /// </summary>
+        ProcessReport,
+
         /// <summary>
         /// Command in form of MSBuild command line for server node - MSBuild Server.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
diff --git a/src/Shared/NGen.cs b/src/Shared/NGen.cs
deleted file mode 100644
index f37252e7049..00000000000
--- a/src/Shared/NGen.cs
+++ /dev/null
@@ -1,50 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-#nullable disable
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// To avoid CA908 warnings (types that in ngen images that will JIT)
-    /// wrap each problematic value type in the collection in 
-    /// one of these objects.
-    /// </summary>
-    /// <comment>
-    /// This trick is based on advice from 
-    /// http://sharepoint/sites/codeanalysis/Wiki%20Pages/Rule%20-%20Avoid%20Types%20That%20Require%20JIT%20Compilation%20In%20Precompiled%20Assemblies.aspx.
-    /// It works because although this is a value type, it is not defined in mscorlib.
-    /// </comment>
-    /// <typeparam name="T">Wrapped type</typeparam>
-    internal struct NGen<T> where T : struct
-    {
-        /// <summary>
-        /// Wrapped value
-        /// </summary>
-        private T _value;
-
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        public NGen(T value)
-        {
-            _value = value;
-        }
-
-        /// <summary>
-        /// Exposes the value
-        /// </summary>
-        public static implicit operator T(NGen<T> value)
-        {
-            return value._value;
-        }
-
-        /// <summary>
-        /// Consumes the value
-        /// </summary>
-        public static implicit operator NGen<T>(T value)
-        {
-            return new NGen<T>(value);
-        }
-    }
-}
diff --git a/src/Shared/Pair.cs b/src/Shared/Pair.cs
deleted file mode 100644
index ef5073b4835..00000000000
--- a/src/Shared/Pair.cs
+++ /dev/null
@@ -1,60 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Diagnostics.CodeAnalysis;
-
-#nullable disable
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// This struct is functionally identical to KeyValuePair, but avoids
-    /// CA908 warnings (types that in ngen images that will JIT).
-    /// Instead of generic collections of KeyValuePair, use Pair.
-    /// </summary>
-    /// <comment>
-    /// This trick is based on advice from 
-    /// http://sharepoint/sites/codeanalysis/Wiki%20Pages/Rule%20-%20Avoid%20Types%20That%20Require%20JIT%20Compilation%20In%20Precompiled%20Assemblies.aspx.
-    /// It works because although this is a value type, it is not defined in mscorlib.
-    /// </comment>
-    /// <typeparam name="TKey">Key</typeparam>
-    /// <typeparam name="TValue">Value</typeparam>
-    [SuppressMessage("Microsoft.Performance", "CA1815:OverrideEqualsAndOperatorEqualsOnValueTypes", Justification = "Not possible as Equals cannot be implemented on the struct members")]
-    internal struct Pair<TKey, TValue>
-    {
-        /// <summary>
-        /// Key
-        /// </summary>
-        private TKey _key;
-
-        /// <summary>
-        /// Value
-        /// </summary>
-        private TValue _value;
-
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        public Pair(TKey key, TValue value)
-        {
-            _key = key;
-            _value = value;
-        }
-
-        /// <summary>
-        /// Key
-        /// </summary>
-        internal readonly TKey Key
-        {
-            get { return _key; }
-        }
-
-        /// <summary>
-        /// Value
-        /// </summary>
-        internal readonly TValue Value
-        {
-            get { return _value; }
-        }
-    }
-}
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 822495b0179..d60ce982546 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -5,7 +5,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
-
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -417,7 +417,28 @@ public void Translate(ITranslator translator)
             translator.TranslateCulture(ref _culture);
             translator.TranslateCulture(ref _uiCulture);
 #if FEATURE_APPDOMAIN
-            translator.TranslateDotNet(ref _appDomainSetup);
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10) || !Traits.Instance.EscapeHatches.IsBinaryFormatterSerializationAllowed)
+            {
+                byte[] appDomainConfigBytes = null;
+
+                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+                if (translator.Mode == TranslationDirection.WriteToStream)
+                {
+                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+                }
+
+                translator.Translate(ref appDomainConfigBytes);
+
+                if (translator.Mode == TranslationDirection.ReadFromStream)
+                {
+                    _appDomainSetup = new AppDomainSetup();
+                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
+                }
+            }
+            else
+            {
+                translator.TranslateDotNet(ref _appDomainSetup);
+            }
 #endif
             translator.Translate(ref _lineNumberOfTask);
             translator.Translate(ref _columnNumberOfTask);
@@ -458,6 +479,7 @@ internal static INodePacket FactoryForDeserialization(ITranslator translator)
         {
             TaskHostConfiguration configuration = new TaskHostConfiguration();
             configuration.Translate(translator);
+
             return configuration;
         }
     }
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index faad07dd31e..6e5a9029b6e 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -1,9 +1,12 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Experimental.FileAccess;
+#endif
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -49,6 +52,10 @@ internal enum TaskCompleteType
     /// </summary>
     internal class TaskHostTaskComplete : INodePacket
     {
+#if FEATURE_REPORTFILEACCESSES
+        private List<FileAccessData> _fileAccessData;
+#endif
+
         /// <summary>
         /// Result of the task's execution. 
         /// </summary>
@@ -82,12 +89,21 @@ internal class TaskHostTaskComplete : INodePacket
         /// </summary>
         private Dictionary<string, string> _buildProcessEnvironment = null;
 
+
+#pragma warning disable CS1572 // XML comment has a param tag, but there is no parameter by that name. Justification: xmldoc doesn't seem to interact well with #ifdef of params.
         /// <summary>
-        /// Constructor
+        /// Initializes a new instance of the <see cref="TaskHostTaskComplete"/> class.
         /// </summary>
-        /// <param name="result">Result of the task's execution.</param>
+        /// <param name="result">The result of the task's execution.</param>
+        /// <param name="fileAccessData">The file accesses reported by the task.</param>
         /// <param name="buildProcessEnvironment">The build process environment as it was at the end of the task's execution.</param>
-        public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<string, string> buildProcessEnvironment)
+#pragma warning restore CS1572 // XML comment has a param tag, but there is no parameter by that name
+        public TaskHostTaskComplete(
+            OutOfProcTaskHostTaskResult result,
+#if FEATURE_REPORTFILEACCESSES
+            List<FileAccessData> fileAccessData,
+#endif
+            IDictionary<string, string> buildProcessEnvironment)
         {
             ErrorUtilities.VerifyThrowInternalNull(result, nameof(result));
 
@@ -95,6 +111,9 @@ public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, IDictionary<stri
             _taskException = result.TaskException;
             _taskExceptionMessage = result.ExceptionMessage;
             _taskExceptionMessageArgs = result.ExceptionMessageArgs;
+#if FEATURE_REPORTFILEACCESSES
+            _fileAccessData = fileAccessData;
+#endif
 
             if (result.FinalParameterValues != null)
             {
@@ -201,6 +220,17 @@ public NodePacketType Type
             get { return NodePacketType.TaskHostTaskComplete; }
         }
 
+#if FEATURE_REPORTFILEACCESSES
+        /// <summary>
+        /// Gets the file accesses reported by the task.
+        /// </summary>
+        public List<FileAccessData> FileAccessData
+        {
+            [DebuggerStepThrough]
+            get => _fileAccessData;
+        }
+#endif
+
         /// <summary>
         /// Translates the packet to/from binary form.
         /// </summary>
@@ -213,6 +243,13 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _taskExceptionMessageArgs);
             translator.TranslateDictionary(ref _taskOutputParameters, StringComparer.OrdinalIgnoreCase, TaskParameter.FactoryForDeserialization);
             translator.TranslateDictionary(ref _buildProcessEnvironment, StringComparer.OrdinalIgnoreCase);
+#if FEATURE_REPORTFILEACCESSES
+            translator.Translate(ref _fileAccessData,
+                (ITranslator translator, ref FileAccessData data) => ((ITranslatable)data).Translate(translator));
+#else
+            bool hasFileAccessData = false;
+            translator.Translate(ref hasFileAccessData);
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index c73af5ba444..190f0dddf2b 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -20,6 +20,8 @@ internal static partial class FileUtilities
         // Lower order bits correspond to the same for "group" or "other" users.
         private const int userRWX = 0x100 | 0x80 | 0x40;
         private static string tempFileDirectory = null;
+        private const string msbuildTempFolderPrefix = "MSBuildTemp";
+
         internal static string TempFileDirectory
         {
             get
@@ -36,7 +38,12 @@ internal static void ClearTempFileDirectory()
         // For all native calls, directly check their return values to prevent bad actors from getting in between checking if a directory exists and returning it.
         private static string CreateFolderUnderTemp()
         {
-            string basePath = Path.Combine(Path.GetTempPath(), $"MSBuildTemp{Environment.UserName}");
+            // On windows Username with Unicode chars can give issues, so we dont append username to the temp folder name.
+            string msbuildTempFolder = NativeMethodsShared.IsWindows ?
+                msbuildTempFolderPrefix :
+                msbuildTempFolderPrefix + Environment.UserName;
+
+            string basePath = Path.Combine(Path.GetTempPath(), msbuildTempFolder);
 
             if (NativeMethodsShared.IsLinux && NativeMethodsShared.mkdir(basePath, userRWX) != 0)
             {
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index d26f7127305..a71f01f150d 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -141,7 +141,6 @@ internal static void List<T>(IEnumerable<T> items)
         /// Dump all the named counters, if any
         /// </summary>
         [Conditional("DEBUG")]
-        [SuppressMessage("Microsoft.MSInternal", "CA908:AvoidTypesThatRequireJitCompilationInPrecompiledAssemblies", Justification = "Debug only")]
         internal static void Dump()
         {
             if (s_counts.Count > 0)
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 26e8d9bd848..5e5c6aca707 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -22,6 +23,7 @@ namespace Microsoft.Build.UnitTests
     public class FileMatcherTest : IDisposable
     {
         private readonly TestEnvironment _env;
+        private Lazy<DummyMappedDrive> _mappedDrive = DummyMappedDriveUtils.GetLazyDummyMappedDrive();
 
         public FileMatcherTest(ITestOutputHelper output)
         {
@@ -31,6 +33,7 @@ public FileMatcherTest(ITestOutputHelper output)
         public void Dispose()
         {
             _env.Dispose();
+            _mappedDrive.Value?.Dispose();
         }
 
         [Theory]
@@ -1377,18 +1380,19 @@ private void DriveEnumeratingWildcardFailsAndReturns(string directoryPart, strin
             }
         }
 
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
         [WindowsOnlyTheory]
-        [InlineData(@"z:\**")]
-        [InlineData(@"z:\\**")]
-        [InlineData(@"z:\\\\\\\\**")]
-        [InlineData(@"z:\**\*.cs")]
+        [InlineData(@"%DRIVE%:\**")]
+        [InlineData(@"%DRIVE%:\\**")]
+        [InlineData(@"%DRIVE%:\\\\\\\\**")]
+        [InlineData(@"%DRIVE%:\**\*.cs")]
         public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWildcard)
         {
             using (var env = TestEnvironment.Create())
             {
                 try
                 {
+                    driveEnumeratingWildcard = DummyMappedDriveUtils.UpdatePathToMappedDrive(driveEnumeratingWildcard, _mappedDrive.Value.MappedDriveLetter);
+
                     // Set env var to log on drive enumerating wildcard detection
                     Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
 
diff --git a/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs b/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
index d1387eeb0b4..191642f2806 100644
--- a/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Dependencies_Tests.cs
@@ -33,6 +33,7 @@ public void LoadAssemblyAndDependency_InsideProjectFolder()
                 string dllPath = Path.Combine(dir.Path, TaskDllFileName);
 
                 CheckIfCorrectAssemblyLoaded(output, dllPath);
+                CheckIfCorrectAssemblyLoadedMessageLogged(output);
             }
         }
 
@@ -51,6 +52,7 @@ public void LoadAssemblyAndDependency_OutsideProjectFolder()
                 successfulExit.ShouldBeTrue(output);
 
                 CheckIfCorrectAssemblyLoaded(output, newTaskDllPath);
+                CheckIfCorrectAssemblyLoadedMessageLogged(output);
             }
         }
 
@@ -107,5 +109,19 @@ private void CheckIfCorrectAssemblyLoaded(string scriptOutput, string expectedAs
                 scriptOutput.ShouldNotContain(successfulMessage, Case.Insensitive);
             }
         }
+
+        private void CheckIfCorrectAssemblyLoadedMessageLogged(string scriptOutput)
+        {
+            var assemblyLoadedTaskRun = "Assembly loaded during TaskRun";
+
+#if FEATURE_ASSEMBLYLOADCONTEXT
+            var message = "AssemblyLoadContext: MSBuild plugin";
+#else
+            var message = "AppDomain: [Default]";
+#endif
+
+            scriptOutput.ShouldContain(assemblyLoadedTaskRun);
+            scriptOutput.ShouldContain(message);
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 9caae9580dd..43d8b0b2016 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3563,7 +3563,7 @@ public void ConflictBetweenCopyLocalDependenciesRegress444809()
             ResourceManager resources = new ResourceManager("Microsoft.Build.Tasks.Strings", Assembly.GetExecutingAssembly());
 
             // Unresolved primary reference with itemspec "A, Version=20.0.0.0, Culture=Neutral, PublicKeyToken=null".
-            engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_ADllPath);
+            engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.UnifiedReferenceDependsOn", "A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_ADllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_V2_ADllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.PrimarySourceItemsForReference", s_regress444809_CDllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.PrimarySourceItemsForReference", s_regress444809_BDllPath);
@@ -3609,7 +3609,7 @@ public void ConflictBetweenCopyLocalDependenciesRegress444809UnResolvedPrimaryRe
             bool result = Execute(t);
 
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=20.0.0.0, Culture=Neutral, PublicKeyToken=null", String.Empty);
-            engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.ReferenceDependsOn", "A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_V2_ADllPath);
+            engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.UnifiedReferenceDependsOn", "A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null", s_regress444809_V2_ADllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.UnResolvedPrimaryItemSpec", "A, Version=20.0.0.0, Culture=Neutral, PublicKeyToken=null");
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.PrimarySourceItemsForReference", s_regress444809_DDllPath);
             engine.AssertLogContainsMessageFromResource(resourceDelegate, "ResolveAssemblyReference.PrimarySourceItemsForReference", s_regress444809_BDllPath);
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 69f481a1cf7..de09dcbc85e 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using System.Collections.Generic;
 using System.IO;
 using Microsoft.Build.Definition;
@@ -9,6 +10,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
+using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
@@ -19,7 +21,7 @@
 
 namespace Microsoft.Build.UnitTests
 {
-    public sealed class CreateItem_Tests
+    public sealed class CreateItem_Tests : IDisposable
     {
         internal const string CreateItemWithInclude = @"
             <Project>
@@ -32,6 +34,12 @@ public sealed class CreateItem_Tests
             ";
 
         private readonly ITestOutputHelper _testOutput;
+        private Lazy<DummyMappedDrive> _mappedDrive = DummyMappedDriveUtils.GetLazyDummyMappedDrive();
+
+        public void Dispose()
+        {
+            _mappedDrive.Value?.Dispose();
+        }
 
         public CreateItem_Tests(ITestOutputHelper output)
         {
@@ -146,7 +154,7 @@ public void CaseDoesntMatter()
         }
 
         /// <summary>
-        /// Using the CreateItem task to expand wildcards, and then try accessing the RecursiveDir 
+        /// Using the CreateItem task to expand wildcards, and then try accessing the RecursiveDir
         /// metadata to force batching.
         /// </summary>
         [Fact]
@@ -313,20 +321,20 @@ public void WildcardDriveEnumerationTaskItemLogsError(string itemSpec)
         /// <summary>
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Windows platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
         [WindowsOnlyTheory]
-        [InlineData(@"z:\**")]
-        [InlineData(@"z:\**\*.log")]
-        [InlineData(@"z:\\\\**\*.log")]
+        [InlineData(@"%DRIVE%:\**")]
+        [InlineData(@"%DRIVE%:\**\*.log")]
+        [InlineData(@"%DRIVE%:\\\\**\*.log")]
         public void LogWindowsWarningUponCreateItemExecution(string itemSpec)
         {
+            itemSpec = DummyMappedDriveUtils.UpdatePathToMappedDrive(itemSpec, _mappedDrive.Value.MappedDriveLetter);
             VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(itemSpec);
         }
 
         /// <summary>
         /// Logs warning when encountering wildcard drive enumeration during task item creation on Unix platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/8373")]
         [UnixOnlyTheory]
         [InlineData(@"\**")]
         [InlineData(@"\**\*.log")]
@@ -391,21 +399,21 @@ public void ThrowExceptionUponItemCreationWithDriveEnumeration(string content, s
         /// <summary>
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Windows platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
         [WindowsOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
-            @"z:\**")]
+            @"%DRIVE%:\**")]
 
         [InlineData(
             CreateItemWithInclude,
-            @"z:\**\*.txt")]
+            @"%DRIVE%:\**\*.txt")]
 
         [InlineData(
             CreateItemWithInclude,
-            @"z:$(empty)\**\*.cs")]
+            @"%DRIVE%:$(empty)\**\*.cs")]
         public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content, string include)
         {
+            include = DummyMappedDriveUtils.UpdatePathToMappedDrive(include, _mappedDrive.Value.MappedDriveLetter);
             content = string.Format(content, include);
             Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
                 content,
@@ -418,7 +426,7 @@ public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content
         /// <summary>
         /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Unix platform.
         /// </summary>
-        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/8373")]
         [UnixOnlyTheory]
         [InlineData(
             CreateItemWithInclude,
diff --git a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
index f80107870cf..30545d61a74 100644
--- a/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
+++ b/src/Tasks.UnitTests/GenerateBindingRedirects_Tests.cs
@@ -291,7 +291,8 @@ public void AppConfigFileNotSavedWhenIdentical()
             redirectResults2.TargetAppConfigContent.ShouldContain("<assemblyIdentity name=\"System\" publicKeyToken=\"b77a5c561934e089\" culture=\"neutral\" />");
             redirectResults2.TargetAppConfigContent.ShouldContain("newVersion=\"40.0.0.0\"");
 
-            File.GetLastWriteTime(outputAppConfigFile).ShouldBeGreaterThan(oldTimestamp);
+            File.GetCreationTime(outputAppConfigFile).ShouldBe(oldTimestamp, TimeSpan.FromSeconds(5));
+            File.GetLastWriteTime(outputAppConfigFile).ShouldBe(oldTimestamp, TimeSpan.FromSeconds(5));
         }
 
         private BindingRedirectsExecutionResult GenerateBindingRedirects(string appConfigFile, string targetAppConfigFile,
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index a69b7fa2ea3..30c76c3b851 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -58,6 +58,9 @@
     <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\UnitTests.Shared\EnvironmentProvider.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
+    <Compile Include="..\UnitTests.Shared\DriveMapping.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDrive.cs" />
+    <Compile Include="..\UnitTests.Shared\DummyMappedDriveUtils.cs" />
     <Compile Include="..\Shared\UnitTests\LongPathSupportDisabledFactAttribute.cs">
       <Link>Shared\LongPathSupportDisabledFactAttribute.cs</Link>
     </Compile>
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index c12a1c5c9e0..5e8d8a62784 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
+using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
@@ -338,7 +339,7 @@ public void ForceOutOfDate()
             /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
             Before:
             Utilities.AssertLogContainsResource(t, "GenerateResource.OutputDoesntExist", t.OutputResources[0].ItemSpec);
-            
+
             Utilities.AssertStateFileWasWritten(t);
             After:
             Utilities.AssertLogContainsResource(t, "GenerateResource.OutputDoesntExist", t.OutputResources[0].ItemSpec);
@@ -1771,7 +1772,7 @@ public void FailedResXReader()
                 /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
                 Before:
                 Assert.False(success);
-                
+
                 Utilities.AssertStateFileWasWritten(t);
                 After:
                 Assert.False(success);
@@ -1850,7 +1851,7 @@ public void FailedResXReaderWithAllOutputResourcesSpecified()
                 /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
                 Before:
                 Assert.False(success);
-                
+
                 Utilities.AssertStateFileWasWritten(t);
                 After:
                 Assert.False(success);
@@ -2370,7 +2371,7 @@ public void OutputFilesPartialInputs()
                 /* Unmerged change from project 'Microsoft.Build.Tasks.UnitTests (net7.0)'
                 Before:
                 Assert.Equal(t.FilesWritten[2].ItemSpec, Path.ChangeExtension(t.Sources[3].ItemSpec, ".resources"));
-                
+
                 Utilities.AssertStateFileWasWritten(t);
                 After:
                 Assert.Equal(t.FilesWritten[2].ItemSpec, Path.ChangeExtension(t.Sources[3].ItemSpec, ".resources"));
@@ -3706,6 +3707,20 @@ GenerateResource ExecuteTask()
                 Utilities.FileUpdated(resourcesFile, initialWriteTime).ShouldBeFalse();
             }
         }
+
+        /// <summary>
+        /// https://github.com/dotnet/msbuild/issues/9199
+        /// </summary>
+        [Fact]
+        public void NotValidSources()
+        {
+            GenerateResource t = new GenerateResource { BuildEngine = new MockEngine(_output) };
+            t.Sources = new ITaskItem[] { new TaskItem("non-existent") };
+            t.OutputResources = new ITaskItem[] { new TaskItem("out") };
+            Assert.False(t.Execute());
+            ((MockEngine)t.BuildEngine).AssertLogContains("MSB3552");
+            Assert.Equal(1, ((MockEngine)t.BuildEngine).Errors);
+        }
     }
 }
 
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 5f9f39e9220..1a80a617a7c 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -1068,6 +1068,48 @@ public override bool Execute()
             }
         }
 
+#if !FEATURE_RUN_EXE_IN_TESTS
+        [Fact]
+        public void RoslynCodeTaskFactory_UsingAPI()
+        {
+            string text = $@"
+<Project>
+
+  <UsingTask
+    TaskName=""Custom1""
+    TaskFactory=""RoslynCodeTaskFactory""
+    AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"" >
+    <ParameterGroup>
+      <SayHi ParameterType=""System.String"" Required=""true"" />
+    </ParameterGroup>
+    <Task>
+      <Code Type=""Fragment"" Language=""cs"">
+        <![CDATA[
+        string sayHi = ""Hello "" + SayHi;
+        Log.LogMessage(sayHi);
+        ]]>
+      </Code>
+    </Task>
+  </UsingTask>
+
+    <Target Name=""Build"">
+        <Custom1 SayHi=""World"" />
+    </Target>
+
+</Project>";
+
+            using var env = TestEnvironment.Create();
+            RunnerUtilities.ApplyDotnetHostPathEnvironmentVariable(env);
+            var dotnetPath = Environment.GetEnvironmentVariable("DOTNET_HOST_PATH");
+
+            var project = env.CreateTestProjectWithFiles("p1.proj", text);
+            var logger = project.BuildProjectExpectSuccess();
+            var logLines = logger.AllBuildEvents.Select(a => a.Message);
+            var log = string.Join("\n", logLines);
+            logLines.Where(l => l.Contains(dotnetPath)).Count().ShouldBe(1, log);
+        }
+#endif
+
         private void TryLoadTaskBodyAndExpectFailure(string taskBody, string expectedErrorMessage)
         {
             if (expectedErrorMessage == null)
diff --git a/src/Tasks.UnitTests/XmlPeek_Tests.cs b/src/Tasks.UnitTests/XmlPeek_Tests.cs
index 0367f6c78bc..d7435d0a714 100644
--- a/src/Tasks.UnitTests/XmlPeek_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPeek_Tests.cs
@@ -3,8 +3,13 @@
 
 using System;
 using System.IO;
+
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+
+using Shouldly;
+
 using Xunit;
 
 #nullable disable
@@ -316,6 +321,17 @@ public void PeekWithoutUsingTask()
             logger.AssertLogDoesntContain("MSB4036");
         }
 
+        [Fact]
+        public void PeekWithNoParameters()
+        {
+            MockLogger log = new();
+            Project project = ObjectModelHelpers.CreateInMemoryProject(@"<Project><Target Name=""Test""><XmlPeek /></Target></Project>", log);
+
+            project.Build().ShouldBeFalse();
+            log.AssertLogContains("MSB4044");
+            log.AssertLogContains("\"Query\"");
+        }
+
         private void Prepare(string xmlFile, out string xmlInputPath)
         {
             string dir = Path.Combine(Path.GetTempPath(), DateTime.Now.Ticks.ToString());
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index d78bbcad622..f0978f95c48 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -6,9 +6,13 @@
 using System.IO;
 using System.Linq;
 using System.Xml;
+
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+
 using Shouldly;
+
 using Xunit;
 
 #nullable disable
@@ -135,37 +139,55 @@ public void PokeAttributeWithCondition()
         }
 
         [Fact]
-        public void PokeMissingParams()
+        public void PokeWithNoParameters()
         {
-            MockEngine engine = new MockEngine(true);
-            string xmlInputPath;
-            Prepare(_xmlFileNoNs, out xmlInputPath);
+            MockLogger log = new();
+            Project project = ObjectModelHelpers.CreateInMemoryProject(@"<Project><Target Name=""Test""><XmlPoke /></Target></Project>", log);
 
-            for (int i = 0; i < 4; i++)
-            {
-                XmlPoke p = new XmlPoke();
-                p.BuildEngine = engine;
+            project.Build().ShouldBeFalse();
+            log.AssertLogContains("MSB4044");
+        }
 
-                if ((i & 1) == 1)
-                {
-                    p.XmlInputPath = new TaskItem(xmlInputPath);
-                }
+        [Fact]
+        public void PokeWithMissingRequiredQuery()
+        {
+            const string projectContent = @"<Project><Target Name=""Test""><XmlPoke XmlInputPath=""nonesuch"" /></Target></Project>";
 
-                if ((i & 2) == 2)
-                {
-                    p.Query = "//variable/@Name";
-                }
+            MockLogger log = new();
+            Project project = ObjectModelHelpers.CreateInMemoryProject(projectContent, log);
 
-                // "Expecting argumentnullexception for the first 3 tests"
-                if (i < 3)
-                {
-                    Should.Throw<ArgumentNullException>(() => p.Execute());
-                }
-                else
-                {
-                    Should.NotThrow(() => p.Execute());
-                }
-            }
+            project.Build().ShouldBeFalse();
+            log.AssertLogContains("MSB4044");
+            log.AssertLogContains("\"Query\"");
+        }
+
+        [Fact]
+        public void PokeWithMissingRequiredXmlInputPath()
+        {
+            const string projectContent = @"<Project><Target Name=""Test""><XmlPoke Query=""nonesuch"" /></Target></Project>";
+
+            MockLogger log = new();
+            Project project = ObjectModelHelpers.CreateInMemoryProject(projectContent, log);
+
+            project.Build().ShouldBeFalse();
+            log.AssertLogContains("MSB4044");
+            log.AssertLogContains("\"XmlInputPath\"");
+        }
+
+        [Fact]
+        public void PokeWithRequiredParameters()
+        {
+            MockEngine engine = new(true);
+            Prepare(_xmlFileNoNs, out string xmlInputPath);
+
+            XmlPoke task = new()
+            {
+                BuildEngine = engine,
+                XmlInputPath = new TaskItem(xmlInputPath),
+                Query = "//variable/@Name",
+            };
+
+            task.Execute().ShouldBeTrue();
         }
 
         [Fact]
diff --git a/src/Tasks/Al.cs b/src/Tasks/Al.cs
index 7d9ad8fa1a8..0b587df5b74 100644
--- a/src/Tasks/Al.cs
+++ b/src/Tasks/Al.cs
@@ -1,21 +1,26 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// This class defines the "AL" XMake task, which enables using al.exe to link
     /// modules and resource files into assemblies.
     /// </summary>
-    public class AL : ToolTaskExtension
+    public class AL : ToolTaskExtension, IALTaskContract
     {
         #region Properties
         /*
@@ -387,6 +392,130 @@ public override bool Execute()
             return base.Execute();
         }
 
+        #endregion
+    }
+
+#else
+
+    /// <summary>
+    /// Stub AL task for .NET Core.
+    /// </summary>
+    public sealed class AL : TaskRequiresFramework, IALTaskContract
+    {
+        public AL()
+            : base(nameof(AL))
+        {
+        }
+
+        #region Properties
+
+        public string AlgorithmId { get; set; }
+
+        public string BaseAddress { get; set; }
+
+        public string CompanyName { get; set; }
+
+        public string Configuration { get; set; }
+
+        public string Copyright { get; set; }
+
+        public string Culture { get; set; }
+
+        public bool DelaySign { get; set; }
+
+        public string Description { get; set; }
+
+        public string EvidenceFile { get; set; }
+
+        public string FileVersion { get; set; }
+
+        public string Flags { get; set; }
+
+        public bool GenerateFullPaths { get; set; }
+
+        public string KeyFile { get; set; }
+
+        public string KeyContainer { get; set; }
+
+        public string MainEntryPoint { get; set; }
+
+        [Output]
+        public ITaskItem OutputAssembly { get; set; }
+
+        public string Platform { get; set; }
+
+        public bool Prefer32Bit { get; set; }
+
+        public string ProductName { get; set; }
+
+        public string ProductVersion { get; set; }
+
+        public string[] ResponseFiles { get; set; }
+
+        public string TargetType { get; set; }
+
+        public string TemplateFile { get; set; }
+
+        public string Title { get; set; }
+
+        public string Trademark { get; set; }
+
+        public string Version { get; set; }
+
+        public string Win32Icon { get; set; }
+
+        public string Win32Resource { get; set; }
+
+        public ITaskItem[] SourceModules { get; set; }
+
+        public ITaskItem[] EmbedResources { get; set; }
+
+        public ITaskItem[] LinkResources { get; set; }
+
+        public string SdkToolsPath { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IALTaskContract
+    {
+        #region Properties
+
+        string AlgorithmId { get; set; }
+        string BaseAddress { get; set; }
+        string CompanyName { get; set; }
+        string Configuration { get; set; }
+        string Copyright { get; set; }
+        string Culture { get; set; }
+        bool DelaySign { get; set; }
+        string Description { get; set; }
+        string EvidenceFile { get; set; }
+        string FileVersion { get; set; }
+        string Flags { get; set; }
+        bool GenerateFullPaths { get; set; }
+        string KeyFile { get; set; }
+        string KeyContainer { get; set; }
+        string MainEntryPoint { get; set; }
+        ITaskItem OutputAssembly { get; set; }
+        string Platform { get; set; }
+        bool Prefer32Bit { get; set; }
+        string ProductName { get; set; }
+        string ProductVersion { get; set; }
+        string[] ResponseFiles { get; set; }
+        string TargetType { get; set; }
+        string TemplateFile { get; set; }
+        string Title { get; set; }
+        string Trademark { get; set; }
+        string Version { get; set; }
+        string Win32Icon { get; set; }
+        string Win32Resource { get; set; }
+        ITaskItem[] SourceModules { get; set; }
+        ITaskItem[] EmbedResources { get; set; }
+        ITaskItem[] LinkResources { get; set; }
+        string SdkToolsPath { get; set; }
+
         #endregion
     }
 }
diff --git a/src/Tasks/AspNetCompiler.cs b/src/Tasks/AspNetCompiler.cs
index 1e1d3b4b2be..3570cc44010 100644
--- a/src/Tasks/AspNetCompiler.cs
+++ b/src/Tasks/AspNetCompiler.cs
@@ -1,16 +1,20 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using Microsoft.Build.Utilities;
+#endif
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// The AspNetCompiler task, which is a wrapper around aspnet_compiler.exe
     /// </summary>
-    public class AspNetCompiler : ToolTaskExtension
+    public class AspNetCompiler : ToolTaskExtension, IAspNetCompilerTaskContract
     {
         /*
             C:\WINDOWS\Microsoft.NET\Framework\v2.0.x86dbg>aspnet_compiler /?
@@ -338,4 +342,70 @@ protected override bool ValidateParameters()
             return true;
         }
     }
+
+#else
+
+    public sealed class AspNetCompiler : TaskRequiresFramework, IAspNetCompilerTaskContract
+    {
+        public AspNetCompiler()
+            : base(nameof(AspNetCompiler))
+        {
+        }
+
+        #region Properties
+
+        public bool AllowPartiallyTrustedCallers { get; set; }
+
+        public bool DelaySign { get; set; }
+
+        public bool FixedNames { get; set; }
+
+        public string KeyContainer { get; set; }
+
+        public string KeyFile { get; set; }
+
+        public string MetabasePath { get; set; }
+
+        public string PhysicalPath { get; set; }
+
+        public string TargetPath { get; set; }
+
+        public string VirtualPath { get; set; }
+
+        public bool Updateable { get; set; }
+
+        public bool Force { get; set; }
+
+        public bool Debug { get; set; }
+
+        public bool Clean { get; set; }
+
+        public string TargetFrameworkMoniker { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IAspNetCompilerTaskContract
+    {
+        #region Properties
+
+        bool AllowPartiallyTrustedCallers { get; set; }
+        bool DelaySign { get; set; }
+        bool FixedNames { get; set; }
+        string KeyContainer { get; set; }
+        string KeyFile { get; set; }
+        string MetabasePath { get; set; }
+        string PhysicalPath { get; set; }
+        string TargetPath { get; set; }
+        string VirtualPath { get; set; }
+        bool Updateable { get; set; }
+        bool Force { get; set; }
+        bool Debug { get; set; }
+        bool Clean { get; set; }
+        string TargetFrameworkMoniker { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 19aab4b83e6..c108bb142f0 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -139,13 +139,6 @@ public override bool Execute()
                     doc.Save(stream);
                 }
             }
-            else if (outputExists)
-            {
-                // if the file exists and the content is up to date, then touch the output file.
-                var now = DateTime.Now;
-                File.SetLastAccessTime(OutputAppConfigFile.ItemSpec, now);
-                File.SetLastWriteTime(OutputAppConfigFile.ItemSpec, now);
-            }
 
             return !Log.HasLoggedErrors;
         }
@@ -171,7 +164,7 @@ private static bool IsMatch(AssemblyName suggestedRedirect, string name, string
             var cultureString = suggestedRedirect.CultureName;
             if (String.IsNullOrEmpty(cultureString))
             {
-                // We use "neutral" for "Invariant Language (Invariant Country)" in assembly names.
+                // We use "neutral" for "Invariant Language (Invariant Country/Region)" in assembly names.
                 cultureString = "neutral";
             }
 
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 45d87afb04c..381fa520766 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1123,7 +1123,7 @@ quiet at the engine level.
                             LogReferenceDependenciesAndSourceItemsToStringBuilder(conflictCandidate.ConflictVictorName.FullName, victor, logDependencies);
 
                             // Log the reference which lost the conflict and the dependencies and source items which caused it.
-                            LogReferenceDependenciesAndSourceItemsToStringBuilder(fusionName, conflictCandidate, logDependencies.AppendLine());
+                            LogReferenceDependenciesAndSourceItemsToStringBuilder(fusionName, conflictCandidate, logDependencies.AppendLine(), referenceIsUnified: true);
 
                             string output = StringBuilderCache.GetStringAndRelease(logConflict);
                             string details = string.Empty;
@@ -1207,7 +1207,7 @@ quiet at the engine level.
 
                                         assemblyIdentityAttributes.Add(new XAttribute("name", idealRemappingPartialAssemblyName.Name));
 
-                                        // We use "neutral" for "Invariant Language (Invariant Country)" in assembly names.
+                                        // We use "neutral" for "Invariant Language (Invariant Country/Region)" in assembly names.
                                         var cultureString = idealRemappingPartialAssemblyName.CultureName;
                                         assemblyIdentityAttributes.Add(new XAttribute("culture", String.IsNullOrEmpty(idealRemappingPartialAssemblyName.CultureName) ? "neutral" : idealRemappingPartialAssemblyName.CultureName));
 
@@ -1320,11 +1320,14 @@ internal static string ByteArrayToString(byte[] a)
         /// <summary>
         /// Log the source items and dependencies which lead to a given item.
         /// </summary>
-        private void LogReferenceDependenciesAndSourceItemsToStringBuilder(string fusionName, Reference conflictCandidate, StringBuilder log)
+        private void LogReferenceDependenciesAndSourceItemsToStringBuilder(string fusionName, Reference conflictCandidate, StringBuilder log, bool referenceIsUnified = false)
         {
             ErrorUtilities.VerifyThrowInternalNull(conflictCandidate, nameof(conflictCandidate));
             log.Append(Strings.FourSpaces);
-            log.Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("ResolveAssemblyReference.ReferenceDependsOn", fusionName, conflictCandidate.FullPath));
+
+            string resource = referenceIsUnified ? "ResolveAssemblyReference.UnifiedReferenceDependsOn" : "ResolveAssemblyReference.ReferenceDependsOn";
+
+            log.Append(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(resource, fusionName, conflictCandidate.FullPath));
 
             if (conflictCandidate.IsPrimary)
             {
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index 2480c599bce..2ff7b10261f 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -139,7 +139,7 @@ public override bool Execute()
                             dependentUpon,
                             // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
                             // https://github.com/dotnet/msbuild/issues/3064
-                            AssignedFiles[i].GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase));
+                            ConversionUtilities.ValidBooleanFalse(AssignedFiles[i].GetMetadata("WithCulture")));
 
                     if (!string.IsNullOrEmpty(info.culture))
                     {
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
index 498513b70bc..9647c21c161 100644
--- a/src/Tasks/CompatibilitySuppressions.xml
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -1,24 +1,75 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <Suppression>
-<!-- For ease of logging the "not supported on Core" message, this task is a
-         TaskExtension on netstandard/netcore. Since the type is sealed there,
+<!-- For ease of logging the "not supported on Core" message, these tasks are a
+         TaskRequiresFramework on netstandard/netcore. Since the type is sealed there,
          that shouldn't cause any implementation problems since no one can derive
          from it and try to call TaskExtension.Log. -->
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.AL</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.AspNetCompiler</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.GenerateBootstrapper</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.GenerateTrustInfo</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.GetFrameworkSdkPath</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.RegisterAssembly</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
     <DiagnosticId>CP0007</DiagnosticId>
     <Target>T:Microsoft.Build.Tasks.ResolveComReference</Target>
     <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
     <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
-
-  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
   <Suppression>
-    <DiagnosticId>CP1002</DiagnosticId>
-    <Target>System.Security.Cryptography, Version=7.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
-    <Left>ref/net7.0/Microsoft.Build.Tasks.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.ResolveNativeReference</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.UnregisterAssembly</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.UpdateManifest</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.WinMDExp</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
 
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
@@ -74,9 +125,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 68d7f27ddba..606677f3305 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -211,11 +211,11 @@ internal static void RefreshInternalEnvironmentValues()
         /// If MSBUILDALWAYSRETRY is set, also log useful diagnostic information -- as 
         /// a warning, so it's easily visible. 
         /// </summary>
-        private void LogDiagnostic(string message, params object[] messageArgs)
+        private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, params object[] messageArgs)
         {
             if (s_alwaysRetryCopy)
             {
-                Log.LogWarning(message, messageArgs);
+                Log.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
             }
         }
 
@@ -285,7 +285,10 @@ private void LogDiagnostic(string message, params object[] messageArgs)
                 MakeFileWriteable(destinationFileState, true);
             }
 
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) && destinationFileState.FileExists && !destinationFileState.IsReadOnly)
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8) &&
+                Traits.Instance.EscapeHatches.CopyWithoutDelete != true &&
+                destinationFileState.FileExists &&
+                !destinationFileState.IsReadOnly)
             {
                 FileUtilities.DeleteNoThrow(destinationFileState.Name);
             }
@@ -823,7 +826,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                         case IOException: // Not clear why we can get one and not the other
                             int code = Marshal.GetHRForException(e);
 
-                            LogDiagnostic("Got {0} copying {1} to {2} and HR is {3}", e.ToString(), sourceFileState.Name, destinationFileState.Name, code);
+                            LogAlwaysRetryDiagnosticFromResources("Copy.IOException", e.ToString(), sourceFileState.Name, destinationFileState.Name, code);
                             if (code == NativeMethods.ERROR_ACCESS_DENIED)
                             {
                                 // ERROR_ACCESS_DENIED can either mean there's an ACL preventing us, or the file has the readonly bit set.
@@ -839,7 +842,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
                                 }
                                 else
                                 {
-                                    LogDiagnostic("Retrying on ERROR_ACCESS_DENIED because MSBUILDALWAYSRETRY = 1");
+                                    LogAlwaysRetryDiagnosticFromResources("Copy.RetryingOnAccessDenied");
                                 }
                             }
                             else if (code == NativeMethods.ERROR_INVALID_FILENAME)
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index e2be751c69d..f45169c4d12 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -44,7 +44,7 @@ protected override string CreateManifestName(
                 culture = item.GetMetadata("Culture");
                 // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
                 // https://github.com/dotnet/msbuild/issues/3064
-                treatAsCultureNeutral = item.GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase);
+                treatAsCultureNeutral = ConversionUtilities.ValidBooleanFalse(item.GetMetadata("WithCulture"));
             }
 
             /*
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 11ccf11e3a6..9b02e0109bc 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -1,9 +1,10 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.IO;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 #nullable disable
@@ -42,7 +43,7 @@ protected override string CreateManifestName(
                 culture = item.GetMetadata("Culture");
                 // If 'WithCulture' is explicitly set to false, treat as 'culture-neutral' and keep the original name of the resource.
                 // https://github.com/dotnet/msbuild/issues/3064
-                treatAsCultureNeutral = item.GetMetadata("WithCulture").Equals("false", StringComparison.OrdinalIgnoreCase);
+                treatAsCultureNeutral = ConversionUtilities.ValidBooleanFalse(item.GetMetadata("WithCulture"));
             }
 
             /*
diff --git a/src/Tasks/GenerateBootstrapper.cs b/src/Tasks/GenerateBootstrapper.cs
index 7eb63e1e8e0..241ca0a4610 100644
--- a/src/Tasks/GenerateBootstrapper.cs
+++ b/src/Tasks/GenerateBootstrapper.cs
@@ -1,20 +1,25 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.Deployment.Bootstrapper;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Generates a bootstrapper for ClickOnce deployment projects.
     /// </summary>
-    public sealed class GenerateBootstrapper : TaskExtension
+    public sealed class GenerateBootstrapper : TaskExtension, IGenerateBootstrapperTaskContract
     {
         public string ApplicationName { get; set; }
 
@@ -174,4 +179,81 @@ private ComponentsLocation ConvertStringToComponentsLocation(string parameterVal
             }
         }
     }
+
+#else
+
+    public sealed class GenerateBootstrapper : TaskRequiresFramework, IGenerateBootstrapperTaskContract
+    {
+        public GenerateBootstrapper()
+            : base(nameof(GenerateBootstrapper))
+        {
+        }
+
+        #region Properties
+
+        public string ApplicationName { get; set; }
+
+        public string ApplicationFile { get; set; }
+
+        public bool ApplicationRequiresElevation { get; set; }
+
+        public string ApplicationUrl { get; set; }
+
+        public ITaskItem[] BootstrapperItems { get; set; }
+
+        public string ComponentsLocation { get; set; }
+
+        public string ComponentsUrl { get; set; }
+
+        public bool CopyComponents { get; set; }
+
+        public string Culture { get; set; }
+
+        public string FallbackCulture { get; set; }
+
+        public string OutputPath { get; set; }
+
+        public string Path { get; set; }
+
+        public string SupportUrl { get; set; }
+
+        public string VisualStudioVersion { get; set; }
+
+        public bool Validate { get; set; }
+
+        [Output]
+        public string BootstrapperKeyFile { get; set; }
+
+        [Output]
+        public string[] BootstrapperComponentFiles { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IGenerateBootstrapperTaskContract
+    {
+        #region Properties
+
+        string ApplicationName { get; set; }
+        string ApplicationFile { get; set; }
+        bool ApplicationRequiresElevation { get; set; }
+        string ApplicationUrl { get; set; }
+        ITaskItem[] BootstrapperItems { get; set; }
+        string ComponentsLocation { get; set; }
+        string ComponentsUrl { get; set; }
+        bool CopyComponents { get; set; }
+        string Culture { get; set; }
+        string FallbackCulture { get; set; }
+        string OutputPath { get; set; }
+        string Path { get; set; }
+        string SupportUrl { get; set; }
+        string VisualStudioVersion { get; set; }
+        bool Validate { get; set; }
+        string BootstrapperKeyFile { get; set; }
+        string[] BootstrapperComponentFiles { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index b3367436499..572a19ea3bb 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -714,14 +714,22 @@ public override bool Execute()
 
                 GetResourcesToProcess(out inputsToProcess, out outputsToProcess, out cachedOutputFiles);
 
-                if (inputsToProcess.Count == 0 && !Log.HasLoggedErrors)
+                if (inputsToProcess.Count == 0)
                 {
-                    if (cachedOutputFiles.Count > 0)
+                    if (!Log.HasLoggedErrors)
                     {
-                        OutputResources = cachedOutputFiles.ToArray();
-                    }
+                        if (cachedOutputFiles.Count > 0)
+                        {
+                            OutputResources = cachedOutputFiles.ToArray();
+                        }
 
-                    Log.LogMessageFromResources("GenerateResource.NothingOutOfDate");
+                        Log.LogMessageFromResources("GenerateResource.NothingOutOfDate");
+                    }
+                    else
+                    {
+                        // No valid sources found--failures should have been logged in GetResourcesToProcess
+                        return false;
+                    }
                 }
                 else if (FailIfNotIncremental)
                 {
diff --git a/src/Tasks/GenerateTrustInfo.cs b/src/Tasks/GenerateTrustInfo.cs
index e6a6a1d43cc..7d76056879b 100644
--- a/src/Tasks/GenerateTrustInfo.cs
+++ b/src/Tasks/GenerateTrustInfo.cs
@@ -1,21 +1,27 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// This task generates the application trust from the base manifest
     /// and the TargetZone and ExcludedPermissions properties.
     /// </summary>
-    public sealed class GenerateTrustInfo : TaskExtension
+    public sealed class GenerateTrustInfo : TaskExtension, IGenerateTrustInfoTaskContract
     {
         private const string Custom = "Custom";
 
@@ -98,4 +104,47 @@ public override bool Execute()
             return true;
         }
     }
+
+#else
+
+    public sealed class GenerateTrustInfo : TaskRequiresFramework, IGenerateTrustInfoTaskContract
+    {
+        public GenerateTrustInfo()
+            : base(nameof(GenerateTrustInfo))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem BaseManifest { get; set; }
+
+        public string ExcludedPermissions { get; set; }
+
+        public string TargetFrameworkMoniker { get; set; }
+
+        public string TargetZone { get; set; }
+
+        public ITaskItem[] ApplicationDependencies { get; set; }
+
+        [Output]
+        public ITaskItem TrustInfoFile { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IGenerateTrustInfoTaskContract
+    {
+        #region Properties
+
+        ITaskItem BaseManifest { get; set; }
+        string ExcludedPermissions { get; set; }
+        string TargetFrameworkMoniker { get; set; }
+        string TargetZone { get; set; }
+        ITaskItem[] ApplicationDependencies { get; set; }
+        ITaskItem TrustInfoFile { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/GetFrameworkSDKPath.cs b/src/Tasks/GetFrameworkSDKPath.cs
index 5d10aaf2817..fb90e032392 100644
--- a/src/Tasks/GetFrameworkSDKPath.cs
+++ b/src/Tasks/GetFrameworkSDKPath.cs
@@ -1,19 +1,25 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Returns paths to the frameworks SDK.
     /// </summary>
-    public class GetFrameworkSdkPath : TaskExtension
+    public class GetFrameworkSdkPath : TaskExtension, IGetFrameworkSdkPathTaskContract
     {
         #region Properties
 
@@ -311,4 +317,61 @@ public override bool Execute()
 
         #endregion
     }
+#else
+
+    public sealed class GetFrameworkSdkPath : TaskRequiresFramework, IGetFrameworkSdkPathTaskContract
+    {
+        public GetFrameworkSdkPath()
+            : base(nameof(GetFrameworkSdkPath))
+        {
+        }
+
+        #region Properties
+
+        [Output]
+        public string Path { get; set; }
+
+        [Output]
+        public string FrameworkSdkVersion20Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion35Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion40Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion45Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion451Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion46Path { get; }
+
+        [Output]
+        public string FrameworkSdkVersion461Path { get; }
+
+        #endregion
+    }
+
+#endif
+
+#pragma warning disable SA1201 // Elements should appear in the correct order
+    internal interface IGetFrameworkSdkPathTaskContract
+    {
+        #region Properties
+
+        string Path { get; set; }
+        string FrameworkSdkVersion20Path { get; }
+        string FrameworkSdkVersion35Path { get; }
+        string FrameworkSdkVersion40Path { get; }
+        string FrameworkSdkVersion45Path { get; }
+        string FrameworkSdkVersion451Path { get; }
+        string FrameworkSdkVersion46Path { get; }
+        string FrameworkSdkVersion461Path { get; }
+
+        #endregion
+    }
+#pragma warning restore SA1201 // Elements should appear in the correct order
 }
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 228d7f70fe4..8f16267ee8d 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -640,7 +640,7 @@ private void ValidateReferencesForClickOnceApplication()
         {
             int t1 = Environment.TickCount;
             bool isPartialTrust = !TrustInfo.IsFullTrust;
-            var targetPathList = new Dictionary<string, NGen<bool>>();
+            var targetPathList = new Dictionary<string, bool>();
 
             foreach (AssemblyReference assembly in AssemblyReferences)
             {
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index 629fcb877e0..28d4f6131df 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -611,7 +611,7 @@ private void ValidateReferences()
                 return;
             }
 
-            var identityList = new Dictionary<string, NGen<bool>>();
+            var identityList = new Dictionary<string, bool>();
             foreach (AssemblyReference assembly in AssemblyReferences)
             {
                 if (assembly.AssemblyIdentity != null)
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 72ea1091d20..bc452fcfe7d 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -61,40 +61,30 @@
     </Compile>
     <Compile Include="..\Shared\CanonicalError.cs">
       <Link>CanonicalError.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="AssemblyDependency\AssemblyMetadata.cs" />
     <Compile Include="CombineTargetFrameworkInfoProperties.cs" />
     <Compile Include="CombineXmlElements.cs" />
-    <Compile Include="ConvertToAbsolutePath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ConvertToAbsolutePath.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\ExtensionFoldersRegistryKey.cs">
       <Link>ExtensionFoldersRegistryKey.cs</Link>
     </Compile>
     <Compile Include="..\Shared\FileDelegates.cs">
       <Link>FileDelegates.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\NGen.cs">
-      <Link>NGen.cs</Link>
     </Compile>
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs" />
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>PropertyParser.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs">
       <Link>ReadOnlyEmptyCollection.cs</Link>
     </Compile>
     <Compile Include="..\Shared\RegistryDelegates.cs">
       <Link>RegistryDelegates.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\RegistryHelper.cs">
       <Link>RegistryHelper.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\StrongNameHelpers.cs">
       <Link>StrongNameHelpers.cs</Link>
@@ -104,34 +94,26 @@
     </Compile>
     <Compile Include="..\Shared\TaskLoggingHelperExtension.cs">
       <Link>TaskLoggingHelperExtension.cs</Link>
-      <ExcludeFromStyleCop>True</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\TempFileUtilities.cs" />
     <Compile Include="..\Shared\MetadataConversionUtilities.cs">
       <Link>MetadataConversionUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\LanguageParser\StreamMappedString.cs">
       <Link>StreamMappedString.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\ExceptionHandling.cs">
       <Link>ExceptionHandling.cs</Link>
     </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>FileUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\EscapingUtilities.cs">
       <Link>EscapingUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\FileMatcher.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\FileMatcher.cs" />
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Modifiers.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
@@ -139,370 +121,149 @@
     <Compile Include="..\Shared\Tracing.cs" />
     <Compile Include="..\Shared\VersionUtilities.cs">
       <Link>VersionUtilities.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
     <Compile Include="..\Shared\VisualStudioConstants.cs">
       <Link>VisualStudioConstants.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\AssemblyNameExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ErrorUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ConversionUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\FileUtilitiesRegex.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\ResourceUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\token.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\tokenChar.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\tokenCharReader.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\tokenEnumerator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\CSharptokenCharReader.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\CSharptokenEnumerator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\CSharptokenizer.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\VisualBasictokenCharReader.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\VisualBasictokenEnumerator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="..\Shared\AssemblyNameExtension.cs" />
+    <Compile Include="..\Shared\ErrorUtilities.cs" />
+    <Compile Include="..\Shared\ConversionUtilities.cs" />
+    <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
+    <Compile Include="..\Shared\ResourceUtilities.cs" />
+    <Compile Include="..\Shared\LanguageParser\token.cs" />
+    <Compile Include="..\Shared\LanguageParser\tokenChar.cs" />
+    <Compile Include="..\Shared\LanguageParser\tokenCharReader.cs" />
+    <Compile Include="..\Shared\LanguageParser\tokenEnumerator.cs" />
+    <Compile Include="..\Shared\LanguageParser\CSharptokenCharReader.cs" />
+    <Compile Include="..\Shared\LanguageParser\CSharptokenEnumerator.cs" />
+    <Compile Include="..\Shared\LanguageParser\CSharptokenizer.cs" />
+    <Compile Include="..\Shared\LanguageParser\VisualBasictokenCharReader.cs" />
+    <Compile Include="..\Shared\LanguageParser\VisualBasictokenEnumerator.cs" />
+    <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs" />
     <Compile Include="..\Shared\PlatformNegotiation.cs">
       <Link>PlatformNegotiation.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\XMakeAttributes.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="..\Shared\XMakeElements.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AppConfig\*.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyFoldersExResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\XMakeAttributes.cs" />
+    <Compile Include="..\Shared\XMakeElements.cs" />
+    <Compile Include="AppConfig\*.cs" />
+    <Compile Include="AssemblyDependency\AssemblyFoldersExResolver.cs" />
     <Compile Include="AssemblyDependency\AssemblyFoldersFromConfig\AssemblyFoldersFromConfigCache.cs" />
     <Compile Include="AssemblyDependency\AssemblyFoldersFromConfig\AssemblyFoldersFromConfigResolver.cs" />
-    <Compile Include="AssemblyDependency\AssemblyFoldersResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyInformation.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyNameReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyNameReferenceAscendingVersionComparer.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyResolution.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\AssemblyResolutionConstants.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\BadImageReferenceException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\CandidateAssemblyFilesResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ConflictLossReason.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\CopyLocalState.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\DependencyResolutionException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\DirectoryResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\DisposableBase.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\FrameworkPathResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyDependency\AssemblyFoldersResolver.cs" />
+    <Compile Include="AssemblyDependency\AssemblyInformation.cs" />
+    <Compile Include="AssemblyDependency\AssemblyNameReference.cs" />
+    <Compile Include="AssemblyDependency\AssemblyNameReferenceAscendingVersionComparer.cs" />
+    <Compile Include="AssemblyDependency\AssemblyResolution.cs" />
+    <Compile Include="AssemblyDependency\AssemblyResolutionConstants.cs" />
+    <Compile Include="AssemblyDependency\BadImageReferenceException.cs" />
+    <Compile Include="AssemblyDependency\CandidateAssemblyFilesResolver.cs" />
+    <Compile Include="AssemblyDependency\ConflictLossReason.cs" />
+    <Compile Include="AssemblyDependency\CopyLocalState.cs" />
+    <Compile Include="AssemblyDependency\DependencyResolutionException.cs" />
+    <Compile Include="AssemblyDependency\DirectoryResolver.cs" />
+    <Compile Include="AssemblyDependency\DisposableBase.cs" />
+    <Compile Include="AssemblyDependency\FrameworkPathResolver.cs" />
     <Compile Include="AssemblyDependency\GenerateBindingRedirects.cs" />
-    <Compile Include="AssemblyDependency\HintPathResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\InstalledAssemblies.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\InvalidReferenceAssemblyNameException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\NoMatchReason.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\RawFilenameResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\Reference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ReferenceResolutionException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ReferenceTable.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ResolutionSearchLocation.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\Resolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\ResolveAssemblyReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\TaskItemSpecFilenameComparer.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\UnificationReason.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\UnificationVersion.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\UnifiedAssemblyName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyDependency\HintPathResolver.cs" />
+    <Compile Include="AssemblyDependency\InstalledAssemblies.cs" />
+    <Compile Include="AssemblyDependency\InvalidReferenceAssemblyNameException.cs" />
+    <Compile Include="AssemblyDependency\NoMatchReason.cs" />
+    <Compile Include="AssemblyDependency\RawFilenameResolver.cs" />
+    <Compile Include="AssemblyDependency\Reference.cs" />
+    <Compile Include="AssemblyDependency\ReferenceResolutionException.cs" />
+    <Compile Include="AssemblyDependency\ReferenceTable.cs" />
+    <Compile Include="AssemblyDependency\ResolutionSearchLocation.cs" />
+    <Compile Include="AssemblyDependency\Resolver.cs" />
+    <Compile Include="AssemblyDependency\ResolveAssemblyReference.cs" />
+    <Compile Include="AssemblyDependency\TaskItemSpecFilenameComparer.cs" />
+    <Compile Include="AssemblyDependency\UnificationReason.cs" />
+    <Compile Include="AssemblyDependency\UnificationVersion.cs" />
+    <Compile Include="AssemblyDependency\UnifiedAssemblyName.cs" />
     <Compile Include="AssemblyDependency\WarnOrErrorOnTargetArchitectureMismatchBehavior.cs" />
-    <Compile Include="AssemblyFolder.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyFolder.cs" />
+    <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyRemapping.cs" />
-    <Compile Include="AssemblyResources.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssemblyResources.cs" />
     <Compile Include="AssignLinkMetadata.cs" />
-    <Compile Include="AssignProjectConfiguration.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssignTargetPath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="BootstrapperUtil\*.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CallTarget.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CombinePath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CommandLineBuilderExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AssignProjectConfiguration.cs" />
+    <Compile Include="AssignTargetPath.cs" />
+    <Compile Include="BootstrapperUtil\*.cs" />
+    <Compile Include="CallTarget.cs" />
+    <Compile Include="CombinePath.cs" />
+    <Compile Include="CommandLineBuilderExtension.cs" />
     <Compile Include="ResourceHandling\*.cs" />
     <Compile Include="GetCompatiblePlatform.cs" />
     <Compile Include="SetRidAgnosticValueForProjects.cs" />
-    <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
     <Compile Include="FileIO\GetFileHash.cs" />
     <Compile Include="FileIO\HashEncoding.cs" />
     <Compile Include="FileIO\VerifyFileHash.cs" />
     <Compile Include="FileState.cs" />
-    <Compile Include="Copy.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateCSharpManifestResourceName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateVisualBasicManifestResourceName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateItem.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateManifestResourceName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CreateProperty.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="CSharpParserUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Delegate.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Delete.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Error.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Exec.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FindAppConfigFile.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="Copy.cs" />
+    <Compile Include="CreateCSharpManifestResourceName.cs" />
+    <Compile Include="CreateVisualBasicManifestResourceName.cs" />
+    <Compile Include="CreateItem.cs" />
+    <Compile Include="CreateManifestResourceName.cs" />
+    <Compile Include="CreateProperty.cs" />
+    <Compile Include="CSharpParserUtilities.cs" />
+    <Compile Include="Delegate.cs" />
+    <Compile Include="Delete.cs" />
+    <Compile Include="Error.cs" />
+    <Compile Include="Exec.cs" />
+    <Compile Include="FindAppConfigFile.cs" />
     <Compile Include="FindInvalidProjectReferences.cs" />
-    <Compile Include="GetFrameworkPath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="GetFrameworkPath.cs" />
     <Compile Include="GetReferenceAssemblyPaths.cs" />
     <Compile Include="Hash.cs" />
     <Compile Include="InstalledSDKResolver.cs" />
     <Compile Include="Interop.cs" />
     <Compile Include="ErrorFromResources.cs" />
-    <Compile Include="ExtractedClassName.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FileIO\ReadLinesFromFile.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FileIO\WriteLinesToFile.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FindInList.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="FormatVersion.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateApplicationManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateLauncher.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateResource.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GetAssemblyIdentity.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ExtractedClassName.cs" />
+    <Compile Include="FileIO\ReadLinesFromFile.cs" />
+    <Compile Include="FileIO\WriteLinesToFile.cs" />
+    <Compile Include="FindInList.cs" />
+    <Compile Include="FormatUrl.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="FormatVersion.cs" />
+    <Compile Include="GenerateApplicationManifest.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GenerateDeploymentManifest.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GenerateLauncher.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GenerateManifestBase.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GenerateResource.cs" />
+    <Compile Include="GetAssemblyIdentity.cs" />
     <Compile Include="GetInstalledSDKLocations.cs" />
     <Compile Include="GetSDKReferenceFiles.cs" />
-    <Compile Include="IAnalyzerHostObject.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ICscHostObject.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ICscHostObject2.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ICscHostObject3.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ICscHostObject4.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject2.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject3.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject4.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObject5.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IVbcHostObjectFreeThreaded.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="InvalidParameterValueException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ListOperators\FindUnderPath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ListOperators\RemoveDuplicates.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="IAnalyzerHostObject.cs" />
+    <Compile Include="ICscHostObject.cs" />
+    <Compile Include="ICscHostObject2.cs" />
+    <Compile Include="ICscHostObject3.cs" />
+    <Compile Include="ICscHostObject4.cs" />
+    <Compile Include="IVbcHostObject.cs" />
+    <Compile Include="IVbcHostObject2.cs" />
+    <Compile Include="IVbcHostObject3.cs" />
+    <Compile Include="IVbcHostObject4.cs" />
+    <Compile Include="IVbcHostObject5.cs" />
+    <Compile Include="IVbcHostObjectFreeThreaded.cs" />
+    <Compile Include="InvalidParameterValueException.cs" />
+    <Compile Include="LC.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="ListOperators\FindUnderPath.cs" />
+    <Compile Include="ListOperators\RemoveDuplicates.cs" />
     <Compile Include="LockCheck.cs" />
-    <Compile Include="MakeDir.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ManifestUtil\*.cs" Exclude="ManifestUtil\CngLightup.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Message.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="MakeDir.cs" />
+    <Compile Include="ManifestUtil\*.cs" Exclude="ManifestUtil\CngLightup.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="Message.cs" />
     <Compile Include="Move.cs" />
-    <Compile Include="MSBuild.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="NativeMethods.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ParserState.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="RedistList.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="RemoveDir.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="MSBuild.cs" />
+    <Compile Include="NativeMethods.cs" />
+    <Compile Include="ParserState.cs" />
+    <Compile Include="RedistList.cs" />
+    <Compile Include="RemoveDir.cs" />
     <Compile Include="ResGenDependencies.cs" />
     <Compile Include="ResolveCodeAnalysisRuleSet.cs" />
-    <Compile Include="ResolveKeySource.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ResolveManifestFiles.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ResolveNonMSBuildProjectOutput.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ResolveProjectBase.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ResolveKeySource.cs" />
+    <Compile Include="ResolveManifestFiles.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="ResolveNonMSBuildProjectOutput.cs" />
+    <Compile Include="ResolveProjectBase.cs" />
     <Compile Include="ResolveSDKReference.cs" />
     <Compile Include="RequiresFramework35SP1Assembly.cs" />
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactory.cs" />
@@ -510,32 +271,18 @@
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactoryCompilers.cs" />
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactoryTaskInfo.cs" />
     <Compile Include="SdkToolsPathUtility.cs" />
-    <Compile Include="SGen.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="SignFile.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="SGen.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="SignFile.cs" Condition="'$(MonoBuild)' != 'true'" />
     <Compile Include="System.Design.cs" />
     <Compile Include="system.design\stronglytypedresourcebuilder.cs" />
-    <Compile Include="TaskExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="TaskExtension.cs" />
     <Compile Include="TaskTranslatorHelpers.cs" />
     <Compile Include="Telemetry.cs" />
-    <Compile Include="ToolTaskExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Touch.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ToolTaskExtension.cs" />
+    <Compile Include="Touch.cs" />
     <Compile Include="Unzip.cs" />
-    <Compile Include="VisualBasicParserUtilities.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="Warning.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="VisualBasicParserUtilities.cs" />
+    <Compile Include="Warning.cs" />
     <Compile Include="XslTransformation.cs" />
     <Compile Include="AssignCulture.cs" />
     <Compile Include="Culture.cs" />
@@ -550,115 +297,56 @@
     <Compile Include="DependencyFile.cs" />
     <Compile Include="ZipDirectory.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <Compile Include="TaskRequiresFramework.cs" />
+    <!-- Tasks with NET/NETSTANDARD stubs -->
+    <Compile Include="Al.cs" />
+    <Compile Include="AspNetCompiler.cs" />
+    <Compile Include="GenerateBootstrapper.cs" />
+    <Compile Include="GenerateTrustInfo.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="GetFrameworkSDKPath.cs" />
+    <Compile Include="RegisterAssembly.cs" />
+    <Compile Include="ResolveComReference.cs" />
+    <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="UnregisterAssembly.cs" />
+    <Compile Include="UpdateManifest.cs" Condition="'$(MonoBuild)' != 'true'" />
+    <Compile Include="WinMDExp.cs" />
+  </ItemGroup>
   <ItemGroup Condition="$(TargetFrameworkIdentifier) == '.NETFramework'">
-    <Compile Include="Al.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AppDomainIsolatedTaskExtension.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AspNetCompiler.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\GacResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyDependency\GlobalAssemblyCache.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AssemblyRegistrationCache.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AppDomainIsolatedTaskExtension.cs" />
+    <Compile Include="AssemblyDependency\GacResolver.cs" />
+    <Compile Include="AssemblyDependency\GlobalAssemblyCache.cs" />
+    <Compile Include="AssemblyRegistrationCache.cs" />
     <Compile Include="AxImp.cs" />
-    <Compile Include="AxReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="AxTlbBaseReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="AxReference.cs" />
+    <Compile Include="AxTlbBaseReference.cs" />
     <Compile Include="AxTlbBaseTask.cs" />
-    <Compile Include="ComDependencyWalker.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceItemAttributes.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceResolutionException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceTypes.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ComReferenceWrapperInfo.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateBootstrapper.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GenerateTrustInfo.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="GetFrameworkSDKPath.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="IComReferenceResolver.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ManifestUtil\CngLightup.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ComDependencyWalker.cs" />
+    <Compile Include="ComReference.cs" />
+    <Compile Include="ComReferenceInfo.cs" />
+    <Compile Include="ComReferenceItemAttributes.cs" />
+    <Compile Include="ComReferenceResolutionException.cs" />
+    <Compile Include="ComReferenceTypes.cs" />
+    <Compile Include="ComReferenceWrapperInfo.cs" />
+    <Compile Include="IComReferenceResolver.cs" />
+    <Compile Include="ManifestUtil\CngLightup.cs" />
     <Compile Include="RCWForCurrentContext.cs" />
-    <Compile Include="PiaReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="RegisterAssembly.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="PiaReference.cs" />
     <Compile Include="ResGen.cs" />
-    <Compile Include="ResolveComReferenceCache.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="StrongNameException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="StrongNameUtils.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="ResolveComReferenceCache.cs" />
+    <Compile Include="StrongNameException.cs" />
+    <Compile Include="StrongNameUtils.cs" />
     <Compile Include="TlbImp.cs" />
-    <Compile Include="TlbReference.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="UnregisterAssembly.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="UpdateManifest.cs" Condition="'$(MonoBuild)' != 'true'">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
-    <Compile Include="WinMDExp.cs" />
+    <Compile Include="TlbReference.cs" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
     <Compile Include="XamlTaskFactory\CommandLineGenerator.cs" />
     <Compile Include="XamlTaskFactory\CommandLineToolSwitch.cs" />
-    <Compile Include="XamlTaskFactory\RelationsParser.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="XamlTaskFactory\RelationsParser.cs" />
     <Compile Include="XamlTaskFactory\Property.cs" />
-    <Compile Include="XamlTaskFactory\TaskGenerator.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="XamlTaskFactory\TaskGenerator.cs" />
     <Compile Include="XamlTaskFactory\TaskParser.cs" />
-    <Compile Include="XamlTaskFactory\XamlDataDrivenToolTask.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
+    <Compile Include="XamlTaskFactory\XamlDataDrivenToolTask.cs" />
   </ItemGroup>
   <ItemGroup Condition="$(TargetFrameworkIdentifier) == '.NETFramework'">
     <!-- Shim targets only work when the destination targets are installed. -->
@@ -820,7 +508,6 @@
       <GenerateResource>true</GenerateResource>
       <FullClassName>Microsoft.Build.Tasks.SR</FullClassName>
       <LogicalName>System.Design.resources</LogicalName>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </TextStringResource>
     <!-- Files to copy -->
     <DataFile Include="Microsoft.Common.targets">
@@ -974,11 +661,9 @@
   </ItemGroup>
 
   <!-- Mimics AddRefAssemblies from MSBuild.csproj -->
-  <Target Name="AddRefAssemblies"
-          DependsOnTargets="ResolveAssemblyReferences"
-          BeforeTargets="AssignTargetPaths">
+  <Target Name="AddRefAssemblies" DependsOnTargets="ResolveAssemblyReferences" BeforeTargets="AssignTargetPaths">
     <ItemGroup>
-      <Content Include="@(NetstandardRefAssemblies)" CopyToOutputDirectory="PreserveNewest" Link="ref\%(Filename)%(Extension)"/>
+      <Content Include="@(NetstandardRefAssemblies)" CopyToOutputDirectory="PreserveNewest" Link="ref\%(Filename)%(Extension)" />
     </ItemGroup>
   </Target>
 
@@ -1008,7 +693,6 @@
     <PackageReference Include="System.CodeDom" />
     <PackageReference Include="System.Security.Cryptography.Pkcs" />
     <PackageReference Include="System.Security.Cryptography.Xml" />
-    <PackageReference Include="System.Security.Permissions" />
 
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\netcore\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index ad309e55ee2..bcf0e99af18 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1511,6 +1511,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
     -->
   <Target Name="AfterResolveReferences"/>
+  
+  <!--
+    ============================================================
+                                        IgnoreJavaScriptOutputAssembly
+
+    esproj are JavaScript or TypeScript Projects that never produce an assembly.
+    Set ReferenceOutputAssembly to false in any reference to an esproj.
+    ============================================================
+    -->
+  <Target Name="IgnoreJavaScriptOutputAssembly"
+    BeforeTargets="AssignProjectConfiguration"
+    Condition="$([MSBuild]::AreFeaturesEnabled('17.8'))">
+      <ItemGroup>
+        <ProjectReference Condition="'%(ProjectReference.Extension)' == '.esproj' and '%(ProjectReference.ReferenceOutputAssembly)' == ''">
+          <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+        </ProjectReference>
+      </ItemGroup>
+  </Target>
 
   <!--
     ============================================================
@@ -4356,14 +4374,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
-  <PropertyGroup>
-    <DeploymentComputeClickOnceManifestInfoDependsOn>
-      CleanPublishFolder;
-      _DeploymentGenerateTrustInfo
-      $(DeploymentComputeClickOnceManifestInfoDependsOn)
-    </DeploymentComputeClickOnceManifestInfoDependsOn>
-  </PropertyGroup>
-
   <!--
     ============================================================
                                         _DeploymentComputeClickOnceManifestInfo
@@ -4422,7 +4432,29 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_ClickOnceRuntimeCopyLocalItems Include="@(NativeCopyLocalItems)"
                                       Condition="'%(NativeCopyLocalItems.CopyLocal)' == 'true'" />
       <_ClickOnceRuntimeCopyLocalItems Remove="@(_DeploymentReferencePaths)" />
-      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems)"/>
+
+      <!--
+        For .NET>=5, we need to check if we need to publish any content items from transitive project references. For such items to be published, they
+        either have the .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection.
+        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
+      -->
+      <_ClickOnceTransitiveContentItemsTemp Include="@(_TransitiveItemsToCopyToOutputDirectory->'%(TargetPath)')" Condition="'$(PublishProtocol)' == 'ClickOnce'" >
+        <SavedIdentity>%(Identity)</SavedIdentity>
+      </_ClickOnceTransitiveContentItemsTemp>
+      <_ClickOnceTransitiveContentItems Include="@(_ClickOnceTransitiveContentItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
+
+      <!--
+        For .NET>=5, we need to check if we need to publish any copylocal items from None group. For such items to be published, they either 
+        have .exe/.dll extension or their publish status has been overriden in VS so they will show up in the PublishFiles collection. 
+        The PublishProtocol property is available only in .NET>=5 so we will used that to exclude .NET FX 4.X case.
+      -->
+      <!-- Include items from None group for publishing -->
+      <_ClickOnceNoneItemsTemp Include="@(_NoneWithTargetPath->'%(TargetPath)')" Condition="'$(PublishProtocol)'=='Clickonce' And ('%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' or '%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest')">
+        <SavedIdentity>%(Identity)</SavedIdentity>
+      </_ClickOnceNoneItemsTemp>
+      <_ClickOnceNoneItems Include="@(_ClickOnceNoneItemsTemp->'%(SavedIdentity)')" Condition="'%(Identity)'=='@(PublishFile)' Or '%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" />
+
+      <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems);@(_ClickOnceNoneItems);@(_ClickOnceTransitiveContentItems)"/>
     </ItemGroup>
 
     <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
@@ -4978,7 +5010,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Target
     Name="_GetCopyToOutputDirectoryItemsFromTransitiveProjectReferences"
     DependsOnTargets="_PopulateCommonStateForGetCopyToOutputDirectoryItems;_AddOutputPathToGlobalPropertiesToRemove"
-    Returns="@(_TransitiveItemsToCopyToOutputDirectory)">
+    Returns="@(_CopyToOutputDirectoryTransitiveItems)">
 
     <!-- Get items from child projects first. -->
     <MSBuild
@@ -4997,8 +5029,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Target outputs must be full paths because they will be consumed by a different project. -->
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
-      <_TransitiveItemsToCopyToOutputDirectory   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
+      <_CopyToOutputDirectoryTransitiveItems   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
+      <_CopyToOutputDirectoryTransitiveItems   KeepDuplicates=" '$(_GCTODIKeepDuplicates)' != 'false' " KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_AllChildProjectItemsWithTargetPath->'%(FullPath)')" Condition="'%(_AllChildProjectItemsWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
     </ItemGroup>
 
     <!-- Remove items which we will never again use - they just sit around taking up memory otherwise -->
@@ -5008,13 +5040,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <!-- Copy paste _GetCopyToOutputDirectoryItemsFromThisProject but keep the items that came from other projects via ProjectReference's OutputItemType metadata -->
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(ContentWithTargetPath->'%(FullPath)')" Condition="'%(ContentWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(ContentWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
     </ItemGroup>
 
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='Always' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(EmbeddedResource->'%(FullPath)')" Condition="'%(EmbeddedResource.CopyToOutputDirectory)'=='PreserveNewest' AND '%(EmbeddedResource.MSBuildSourceProjectFile)'!=''"/>
     </ItemGroup>
 
     <ItemGroup>
@@ -5026,13 +5058,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     </AssignTargetPath>
 
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='Always'"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_CompileItemsToCopyWithTargetPath)" Condition="'%(_CompileItemsToCopyWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest'"/>
     </ItemGroup>
 
     <ItemGroup>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
-      <_TransitiveItemsToCopyToOutputDirectory       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='Always' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
+      <_CopyToOutputDirectoryTransitiveItems       KeepMetadata="$(_GCTODIKeepMetadata)" Include="@(_NoneWithTargetPath->'%(FullPath)')" Condition="'%(_NoneWithTargetPath.CopyToOutputDirectory)'=='PreserveNewest' AND '%(_NoneWithTargetPath.MSBuildSourceProjectFile)'!=''"/>
     </ItemGroup>
 
   </Target>
@@ -5108,7 +5140,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <!-- Empty intermediate items to release memory -->
       <_TransitiveItemsToCopyToOutputDirectoryAlways               Remove="@(_TransitiveItemsToCopyToOutputDirectoryAlways)"/>
       <_TransitiveItemsToCopyToOutputDirectoryPreserveNewest       Remove="@(_TransitiveItemsToCopyToOutputDirectoryPreserveNewest)"/>
-      <_TransitiveItemsToCopyToOutputDirectory                     Remove="@(_TransitiveItemsToCopyToOutputDirectory)"/>
 
       <_ThisProjectItemsToCopyToOutputDirectoryAlways              Remove="@(_ThisProjectItemsToCopyToOutputDirectoryAlways)"/>
       <_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest      Remove="@(_ThisProjectItemsToCopyToOutputDirectoryPreserveNewest)"/>
@@ -5787,6 +5818,15 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ***********************************************************************************************
     -->
 
+  <PropertyGroup>
+    <DeploymentComputeClickOnceManifestInfoDependsOn>
+      CleanPublishFolder;
+      $(_RecursiveTargetForContentCopying);
+      _DeploymentGenerateTrustInfo
+      $(DeploymentComputeClickOnceManifestInfoDependsOn)
+    </DeploymentComputeClickOnceManifestInfoDependsOn>
+  </PropertyGroup>
+
   <!--
     ============================================================
                                         Publish
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index beab1878e60..f8e09491af3 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -63,7 +63,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.MSBuild"                               AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(DisableOutOfProcTaskHost)' != ''" />
   <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
   <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
@@ -84,7 +84,7 @@
   <UsingTask TaskName="Microsoft.Build.Tasks.Telemetry"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
   <UsingTask TaskName="Microsoft.Build.Tasks.Touch"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
 
-  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(DisableOutOfProcTaskHost)' != ''" />
+  <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildRuntimeType)' == 'Core' or '$(DisableOutOfProcTaskHost)' != ''" />
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
   <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="'$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index f439aa4939b..dd5c9123649 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -48,7 +48,7 @@ internal sealed class RedistList
         /// When we check to see if an assembly is in this redist list we want to cache it so that if we ask again we do not
         /// have to re-scan bits of the redist list and do the assemblynameExtension comparisons.
         /// </summary>
-        private readonly ConcurrentDictionary<AssemblyNameExtension, NGen<bool>> _assemblyNameInRedist = new ConcurrentDictionary<AssemblyNameExtension, NGen<bool>>(AssemblyNameComparer.GenericComparer);
+        private readonly ConcurrentDictionary<AssemblyNameExtension, bool> _assemblyNameInRedist = new ConcurrentDictionary<AssemblyNameExtension, bool>(AssemblyNameComparer.GenericComparer);
 
         /// <summary>
         /// AssemblyName to unified assemblyName. We make this kind of call a lot and also will ask for the same name multiple times.
@@ -431,7 +431,7 @@ public bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName)
         {
             ErrorUtilities.VerifyThrowArgumentNull(assemblyName, nameof(assemblyName));
 
-            if (!_assemblyNameInRedist.TryGetValue(assemblyName, out NGen<bool> isAssemblyNameInRedist))
+            if (!_assemblyNameInRedist.TryGetValue(assemblyName, out bool isAssemblyNameInRedist))
             {
                 string simpleName = GetSimpleName(assemblyName.Name);
                 if (_simpleNameMap.TryGetValue(simpleName, out int index))
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 0fb8e616bb3..542e2a8f08b 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if FEATURE_APPDOMAIN
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
 
 using System;
 using System.Diagnostics;
@@ -11,20 +11,25 @@
 using System.Runtime.InteropServices.ComTypes;
 using System.Security;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
+#endif
+
+using Microsoft.Build.Framework;
+
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
+
     /// <summary>
     /// Registers a managed assembly for COM interop (equivalent of regasm.exe functionality, but this code doesn't actually call the exe).
     /// </summary>
     /// <comment>ITypeLibExporterNotifySink is necessary for the ITypeLibConverter.ConvertAssemblyToTypeLib call.</comment>
-    public class RegisterAssembly : AppDomainIsolatedTaskExtension, ITypeLibExporterNotifySink
+    public class RegisterAssembly : AppDomainIsolatedTaskExtension, ITypeLibExporterNotifySink, IRegisterAssemblyTaskContract
     {
         #region Properties
 
@@ -360,5 +365,41 @@ private bool ExportTypeLib(Assembly asm, string typeLibFileName)
 
         #endregion
     }
-}
+
+#elif !NETFRAMEWORK
+
+    public sealed class RegisterAssembly : TaskRequiresFramework, IRegisterAssemblyTaskContract
+    {
+        public RegisterAssembly()
+            : base(nameof(RegisterAssembly))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] Assemblies { get; set; }
+
+        [Output]
+        public ITaskItem[] TypeLibFiles { get; set; }
+
+        public bool CreateCodeBase { get; set; }
+
+        public ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+
 #endif
+
+    internal interface IRegisterAssemblyTaskContract
+    {
+        #region Properties
+
+        ITaskItem[] Assemblies { get; set; }
+        ITaskItem[] TypeLibFiles { get; set; }
+        bool CreateCodeBase { get; set; }
+        ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+}
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 0a3eb949eef..a9fcee543f6 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -139,8 +139,13 @@ internal interface IResolveComReferenceTaskContract
     /// <summary>
     /// Main class for the COM reference resolution task for .NET Core
     /// </summary>
-    public sealed partial class ResolveComReference : Microsoft.Build.Tasks.TaskExtension, IResolveComReferenceTaskContract
+    public sealed partial class ResolveComReference : TaskRequiresFramework, IResolveComReferenceTaskContract
     {
+        public ResolveComReference()
+            : base(nameof(ResolveComReference))
+        {
+        }
+
 #pragma warning disable format // region formatting is different in net7.0 and net472, and cannot be fixed for both
         #region Properties
 
@@ -183,20 +188,6 @@ public sealed partial class ResolveComReference : Microsoft.Build.Tasks.TaskExte
         public string TargetFrameworkVersion { get; set; } = String.Empty;
 
         #endregion
-
-        #region ITask members
-
-        /// <summary>
-        /// Task entry point.
-        /// </summary>
-        /// <returns></returns>
-        public override bool Execute()
-        {
-            Log.LogErrorWithCodeFromResources("TaskRequiresFrameworkFailure", nameof(ResolveComReference));
-            return false;
-        }
-
-        #endregion
 #pragma warning restore format 
     }
 
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 66a5ac3c70b..484401442be 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -1,6 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
 using System.IO;
 using System.Collections;
@@ -9,20 +10,25 @@
 using System.Diagnostics;
 #endif
 using System.Linq;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Utilities;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Main class for the native reference resolution task.
     /// </summary>
-    public class ResolveNativeReference : TaskExtension
+    public class ResolveNativeReference : TaskExtension, IResolveNativeReferenceTaskConract
     {
         #region Constructors
 
@@ -340,4 +346,58 @@ internal bool ExtractFromManifest(
         }
         #endregion
     }
+
+#else
+
+    public sealed class ResolveNativeReference : TaskRequiresFramework, IResolveNativeReferenceTaskConract
+    {
+        public ResolveNativeReference()
+            : base(nameof(ResolveNativeReference))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] NativeReferences { get; set; }
+
+        public string[] AdditionalSearchPaths { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainingReferenceFiles { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedPrerequisiteAssemblies { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedComComponents { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedTypeLibraries { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedLooseTlbFiles { get; set; }
+
+        [Output]
+        public ITaskItem[] ContainedLooseEtcFiles { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IResolveNativeReferenceTaskConract
+    {
+        #region Properties
+
+        ITaskItem[] NativeReferences { get; set; }
+        string[] AdditionalSearchPaths { get; set; }
+        ITaskItem[] ContainingReferenceFiles { get; set; }
+        ITaskItem[] ContainedPrerequisiteAssemblies { get; set; }
+        ITaskItem[] ContainedComComponents { get; set; }
+        ITaskItem[] ContainedTypeLibraries { get; set; }
+        ITaskItem[] ContainedLooseTlbFiles { get; set; }
+        ITaskItem[] ContainedLooseEtcFiles { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 8b337bb2db5..3ba788b9c76 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -1692,6 +1692,10 @@
     <value>References which depend on "{0}" [{1}].</value>
     <comment> This will look like references which depend on "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</comment>
   </data>
+  <data name="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+    <value>References which depend on or have been unified to "{0}" [{1}].</value>
+    <comment> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</comment>
+  </data>
   <data name="ResolveAssemblyReference.UnResolvedPrimaryItemSpec">
     <value>Unresolved primary reference with an item include of "{0}".</value>
     <comment> This messages is for a reference which could not be resolved, however we have its item spec and will display that. {0} will be somethign like  System or A, Version=xxx</comment>
@@ -2781,6 +2785,14 @@
     <value>MSB3893: Could not use a link to copy "{0}" to "{1}".</value>
     <comment>{StrBegin="MSB3893: "} LOCALIZATION: {0} and {1} are paths.</comment>
   </data>
+  <data name="Copy.IOException">
+    <value>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</value>
+    <comment>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</comment>
+  </data>
+  <data name="Copy.RetryingOnAccessDenied">
+    <value>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</value>
+    <comment>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</comment>
+  </data>
 
   <!--
         MSB3901 - MSB3910   Task: Telemetry
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index e911bfc64fe..162dd1ea684 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Vytváří se pevný odkaz pro kopírování {0} do {1}.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Při kopírování „{1}“ do „{2}“ došlo k výjimce {0} a HR je {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Nedá se použít odkaz pro kopírování {0} do {1}.</target>
@@ -221,6 +226,11 @@
         <target state="translated">Nepovedlo se použít pevný odkaz ke zkopírování „{0}“ do „{1}“. Místo toho se soubor kopíruje pomocí symbolického odkazu. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Opakování na ERROR_ACCESS_DENIED, protože proměnná prostředí MSBUILDALWAYSRETRY = 1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Zdrojový soubor {0} je ve skutečnosti adresář.  Úloha kopírování nepodporuje kopírování adresářů.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">Byla nalezena neplatná PE hlavička. Implementační soubor nebude použit.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Reference, které jsou závislé na nebo byly sjednoceny s „{0}“ [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Neznámá architektura procesoru. V implementačním souboru {0} pro {1} je uvedena hodnota ImageFileMachine 0x{2}. Pokud chcete tento implementační soubor použít, zkontrolujte, zda je vlastnost ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch ve vašem projektu nastavena na hodnotu Warning nebo None.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 1db9a0ed02b..58d7ba7e5dc 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Es wird ein fester Link erstellt, um "{0}" in "{1}" zu kopieren.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Erhalt von {0} Kopieren von "{1}" zu "{2}" und HR ist {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Es konnte kein Link verwendet werden, um "{0}" in "{1}" zu kopieren.</target>
@@ -221,6 +226,11 @@
         <target state="translated">Es konnte kein fester Link verwendet werden, um "{0}" in "{1}" zu kopieren. Stattdessen wird die Datei mit einer symbolischen Verknüpfung kopiert. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Wiederholung bei ERROR_ACCESS_DENIED, da Umgebungsvariable MSBUILDALWAYSRETRY=1 festgelegt ist</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Die Quelldatei "{0}" ist keine Datei, sondern ein Verzeichnis.  Mit der Copy-Aufgabe können keine Verzeichnisse kopiert werden.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">Ungültige PE-Kopfzeile gefunden. Die Implementierungsdatei wird nicht verwendet.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Verweise, die von „{0}“ [{1}] abhängen oder damit vereint wurden.</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Unbekannte Prozessorarchitektur. Die Implementierungsdatei "{0}" für "{1}" wies den ImageFileMachine-Wert "0x{2}" auf. Stellen Sie bei der Verwendung dieser Implementierungsdatei sicher, dass die "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch"-Eigenschaft im Projekt auf "Warning" oder "None" festgelegt ist.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 6bf3797e34f..7715a0c317b 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -118,7 +118,7 @@
       </trans-unit>
       <trans-unit id="AxTlbBaseTask.StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3654: Delay signing requires that at least a public key be specified.  Please either supply a public key using the KeyFile or KeyContainer properties, or disable delay signing.</source>
-        <target state="translated">MSB3654: La firma retardada requiere que se especifique al menos una clave pública.  Proporcione una clave pública mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retardada.</target>
+        <target state="translated">MSB3654: La firma retrasada requiere que se especifique al menos una clave pública.  Proporcione una clave pública mediante las propiedades KeyFile o KeyContainer, o deshabilite la firma retrasada.</target>
         <note>{StrBegin="MSB3654: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
@@ -191,6 +191,11 @@
         <target state="translated">Creando un vínculo físico para copiar "{0}" en "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Se obtuvo {0} al copiar "{1}" en "{2}" y HR es {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: No se puede usar un vínculo para copiar "{0}" en "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">No se puede usar un vínculo físico para copiar "{0}" en "{1}". Se va a copiar el archivo en un vínculo simbólico su lugar. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Reintentando el ERROR_ACCESS_DENIED porque la variable de entorno MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: El archivo de origen "{0}" es un directorio.  La tarea "Copy" no permite copiar directorios.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">Se encontró un encabezado PE no válido. No se usará el archivo de implementación.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Referencias que dependen o se han unificado para "{0}" [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Arquitectura de procesador desconocida. El archivo de implementación "{0}" para "{1}" tenía un valor ImageFileMachine de "0x{2}". Si desea usar este archivo de implementación, asegúrese de que la propiedad "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" del proyecto esté establecida en "Warning" o "None".</target>
@@ -2287,7 +2302,7 @@
       </trans-unit>
       <trans-unit id="ResolveComReference.LoadingDelaySignedAssemblyWithStrongNameVerificationEnabled">
         <source>MSB3295: Failed to load an assembly. Please make sure you have disabled strong name verification for your public key if you want to generate delay signed wrappers. {0}</source>
-        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Asegúrese de que deshabilitó la comprobación de nombres seguros para su clave pública si desea generar contenedores de firma retardada. {0}</target>
+        <target state="translated">MSB3295: No se pudo cargar un ensamblado. Asegúrese de que deshabilitó la comprobación de nombres seguros para su clave pública si desea generar contenedores de firma con retraso. {0}</target>
         <note>{StrBegin="MSB3295: "}</note>
       </trans-unit>
       <trans-unit id="ResolveComReference.MissingOrUnknownComReferenceAttribute">
@@ -2496,7 +2511,7 @@
       </trans-unit>
       <trans-unit id="StrongNameUtils.NoPublicKeySpecified">
         <source>MSB3353: Public key necessary for delay signing was not specified.</source>
-        <target state="translated">MSB3353: No se especificó la clave pública necesaria para la firma retardada.</target>
+        <target state="translated">MSB3353: No se especificó la clave pública necesaria para la firma con retraso.</target>
         <note>{StrBegin="MSB3353: "}</note>
       </trans-unit>
       <trans-unit id="TaskRequiresFrameworkFailure">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 1c092fd0a8c..d309c31905c 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Création d'un lien physique pour copier "{0}" vers "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Nous avons copié {0} «{1}» vers «{2}» et les ressources humaines sont {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: impossible d'utiliser un lien pour copier "{0}" vers "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">Impossible d’utiliser un lien physique pour copier «{0}» vers «{1}». Copie du fichier avec un lien symbolique à la place. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Nouvelle tentative sur ERROR_ACCESS_DENIED, car la variable d'environnement MSBUILDALWAYSRETRY = 1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Le fichier source "{0}" est en fait un répertoire.  La tâche "Copy" ne prend pas en charge la copie des répertoires.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">En-tête PE non valide détecté. Le fichier d'implémentation ne sera pas utilisé.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Références qui dépendent ou ont été unifiées à «{0}» [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Architecture de processeur inconnue. Le fichier d'implémentation "{0}" pour "{1}" utilise la valeur "0x{2}" pour ImageFileMachine. Si vous voulez utiliser ce fichier d'implémentation, assurez-vous que la propriété "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" de votre projet est définie à la valeur "Warning" ou "None".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index fc2c0670f0a..49d2bb9524a 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -123,12 +123,12 @@
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullAndEmptyRootElementName">
         <source>MSB3991: '{0}' is not set or empty. When {1} is false, make sure to set a non-empty value for '{0}'.</source>
-        <target state="translated">MSB3991: '{0}' non è impostato o è vuoto. Quando {1} è false, assicurarsi di impostare un valore non vuoto per '{0}'.</target>
+        <target state="translated">MSB3991: “{0}” non è impostato o è vuoto. Quando {1} è false, assicurarsi di impostare un valore non vuoto per "{0}".</target>
         <note>{StrBegin="MSB3991: "}</note>
       </trans-unit>
       <trans-unit id="CombineTargetFrameworkInfoProperties.NotNullRootElementName">
         <source>MSB3992: '{0}' is not set. When {1} is true, make sure to set a value for '{0}'.</source>
-        <target state="translated">MSB3992: '{0}' non è impostato. Quando {1} è true, assicurarsi di impostare un valore per '{0}'.</target>
+        <target state="translated">MSB3992: "{0}" non impostato. Quando {1} è true, assicurarsi di impostare un valore per "{0}".</target>
         <note>{StrBegin="MSB3992: "}</note>
       </trans-unit>
       <trans-unit id="Compiler.FatalArguments">
@@ -191,6 +191,11 @@
         <target state="translated">Creazione del collegamento reale per copiare "{0}" in "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Ottenuto {0} copiando "{1}" in "{2}" e HR è {3}"</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: non è stato possibile usare un collegamento per copiare "{0}" in "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">Impossibile utilizzare un collegamento reale per copiare "{0}" in "{1}". Verrà invece copiato il file con collegamento simbolico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Nuovo tentativo in ERROR_ACCESS_DENIED perché la variabile d'ambiente MSBUILDALWAYSRETRY = 1".</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: il file di origine "{0}" è in realtà una directory. L'attività "Copia" non supporta la copia di directory.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">È stata trovata un'intestazione PE non valida. Il file di implementazione non verrà usato.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Riferimenti che dipendono da o sono stati unificati per "{0}" [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: architettura del processore sconosciuta. Il file di implementazione "{0}" per "{1}" ha un valore ImageFileMachine pari a "0x{2}". Per usare questo file di implementazione, verificare che la proprietà "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" del progetto sia impostata su "Avviso" o "Nessuno".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 605cfdf73f4..c9cd6028fc9 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -191,6 +191,11 @@
         <target state="translated">ハード リンクを作成して "{0}" を "{1}" にコピーしています。</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: "{1}" を "{2}" にコピー中に {0}が発生しました。HR は {3} です</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: リンクを使用して "{0}" を "{1}" にコピーできませんでした。</target>
@@ -221,6 +226,11 @@
         <target state="translated">ハード リンクを使用して "{0}" を "{1}" にコピーできませんでした。代わりにシンボリック リンクを使用してファイルをコピーしています。 {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: 環境変数 MSBUILDALWAYSRETRY = 1 のため、ERROR_ACCESS_DENIED で再試行しています</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: ソース ファイル "{0}" はディレクトリです。"Copy" タスクはディレクトリのコピーをサポートしません。</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">無効な PE ヘッダーが見つかりました。実装ファイルは使用されません。</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">"{0}" [{1}] に依存しているか、統合されている参照。</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: 不明なプロセッサ アーキテクチャです。"{1}" の実装ファイル "{0}" の ImageFileMachine 値は "0x{2}" でした。この実装ファイルを使用する場合は、プロジェクトの "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" プロパティに "警告" または "なし" を設定してください。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 39b15815f32..0ca9222197f 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -191,6 +191,11 @@
         <target state="translated">"{0}"을(를) "{1}"(으)로 복사하기 위해 하드 링크를 만듭니다.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: {0}을(를) “{1}”(으)로 복사하는 “{2}”이(가) 있고 HR은 {3}입니다.</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: 링크를 사용하여 "{0}"을(를) "{1}"에 복사할 수 없습니다.</target>
@@ -221,6 +226,11 @@
         <target state="translated">하드 링크를 사용하여 "{0}(를) "{1}"에 복사할 수 없습니다. 대신 바로 가기 링크로 파일을 복사합니다. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: 환경 변수 MSBUILDALWAYSRETRY=1이므로 ERROR_ACCESS_DENIED에서 다시 시도합니다.</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 소스 파일 "{0}"은(는) 실제로 디렉터리입니다.  "Copy" 작업으로는 디렉터리를 복사할 수 없습니다.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">잘못된 PE 헤더를 찾았습니다. 구현 파일이 사용되지 않습니다.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">"{0}" [{1}]에 종속되거나 통합된 참조입니다.</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: 알 수 없는 프로세서 아키텍처입니다. "{1}"에 대한 구현 파일 "{0}"의 ImageFileMachine 값이 "0x{2}"입니다. 이 구현 파일을 사용하려면 프로젝트의 "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" 속성을 "Warning" 또는 "None"으로 지정하세요.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 56153414787..a21fc7cd781 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Tworzenie twardego łącza w celu skopiowania „{0}” do „{1}”.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: „Mam {0} kopiowane z „{1}” do „{2}”, a HR to {3}”</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Nie można użyć linku w celu skopiowania ścieżki „{0}” do ścieżki „{1}”.</target>
@@ -221,6 +226,11 @@
         <target state="translated">Nie można użyć twardego linku do skopiowania „{0}” do „{1}”. Zamiast tego kopiuje plik za pomocą linku symbolicznego. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: ponowienie próby w przypadku ERROR_ACCESS_DENIED, ponieważ zmienną środowiskową jest MSBUILDALWAYSRETRY = 1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Plik źródłowy „{0}” jest w rzeczywistości katalogiem.  Zadanie „Copy” nie obsługuje kopiowania katalogów.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">Znaleziono nieprawidłowy nagłówek PE. Plik implementacji nie zostanie użyty.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Odwołania, które są zależne lub zostały ujednolicone dla „{0}” [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Nieznana architektura procesora. Plik implementacji {0} dla „{1}” ma wartość ImageFileMachine równą „0x{2}”. Jeśli chcesz użyć tego pliku implementacji, upewnij się, że dla właściwości „ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch” w projekcie jest ustawiona wartość „Warning” lub „None”.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index db84fa88b8a..2cbac98a44a 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Criando link físico para copiar "{0}" em "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Recebi {0} copiando "{1}" para {2} e o RH é {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: Não foi possível usar um link para copiar "{0}" para "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">Não foi possível usar um link físico para copiar "{0}" para "{1}". Em vez disso, copiando o arquivo com link simbólico. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Tentando novamente em ERROR_ACCESS_DENIED porque a variável de ambiente MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: O arquivo de origem "{0}" é, na verdade, um diretório.  A tarefa "Copy" não dá suporte à cópia de diretórios.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">Cabeçalho PE inválido encontrado. O arquivo de implementação não será usado.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Referências que dependem de ou foram unificadas para "{0}" [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Arquitetura de processador desconhecida. O arquivo de implementação "{0}" para "{1}" tinha um valor de ImageFileMachine igual a "0x{2}". Se desejar usar esse arquivo de implementação, certifique-se de que a propriedade "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" em seu projeto esteja definida como "Aviso" ou "Nenhum".</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index d090d29ef62..9f27ce3a87d 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -191,6 +191,11 @@
         <target state="translated">Создание жесткой связи для копирования "{0}" в "{1}".</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: Выполнено копирование {0} "{1}" в "{2}" и HR — {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: не удалось использовать связь для копирования "{0}" в "{1}".</target>
@@ -221,6 +226,11 @@
         <target state="translated">Не удалось использовать жесткую связь для копирования "{0}" в "{1}". Выполняется копирование файла с символьной ссылкой. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: Повторная попытка ERROR_ACCESS_DENIED, поскольку переменная среды MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: исходный файл "{0}" в действительности является каталогом.  Задача Copy не поддерживает копирование каталогов.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">Обнаружен недопустимый PE-заголовок. Файл реализации не будет использован.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">Зависимые или унифицированные ссылки для "{0}" [{1}].</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: неизвестная архитектура процессора. Файл реализации "{0}" для "{1}" содержит перечисление ImageFileMachine со значением "0x{2}". Чтобы использовать этот файл реализации, необходимо задать для свойства ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch в проекте значение Warning или None.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index c5979af8059..0b59127f2b0 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -191,6 +191,11 @@
         <target state="translated">"{0}" yolunu "{1}" yoluna kopyalamak için sabit bağlantı oluşturuluyor.</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: {0} için {1} yolu {2} yoluna kopyalandı ve HR: {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: "{0}" dosyasını "{1}" yoluna kopyalama bağlantısı kullanılamadı.</target>
@@ -221,6 +226,11 @@
         <target state="translated">"{0}" yolunu "{1}" yoluna kopyalamak için sabit bağlantı kullanılamadı. Dosya bunun yerine sembolik bağlantı ile kopyalanıyor. {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: MSBUILDALWAYSRETRY ortam değişkeni = 1 olduğundan ERROR_ACCESS_DENIED üzerinde yeniden deneniyor</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: "{0}" kaynak dosyası aslında bir dizindir.  "Kopyala" görevi, dizinleri kopyalamayı desteklemez.</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">Geçersiz PE üst bilgisi bulundu. Uygulama dosyası kullanılmayacak.</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">"{0}" [{1}] öğesine bağlı veya öğesi biçiminde birleştirilen başvurular.</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: Bilinmeyen işlemci mimarisi. "{1}" için "{0}" uygulama dosyasında ImageFileMachine değeri olarak "0x{2}" vardı. Bu uygulama dosyasını kullanmak istiyorsanız, projenizdeki "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" özelliğinin "Warning" veya "None" olarak ayarlandığından emin olun.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 8b146319e98..8272b18a8a5 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -191,6 +191,11 @@
         <target state="translated">创建硬链接以将“{0}”复制到“{1}”。</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: 将 "{1}" 复制到 "{2}" 时出现 {0}，HR 为 {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: 无法使用链接将“{0}”复制到“{1}”。</target>
@@ -221,6 +226,11 @@
         <target state="translated">无法使用硬链接将“{0}”复制到“{1}”。改为使用符号链接复制文件。 {2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: 重试 ERROR_ACCESS_DENIED，因为环境变量 MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 源文件“{0}”实际上是一个目录。“Copy”任务不支持复制目录。</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">找到的 PE 头无效。将不会使用实现文件。</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">依赖于或已统一到“{0}”[{1}] 的引用。</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: 未知的处理器架构。“{1}”的实现文件“{0}”的 ImageFileMachine 值为“0x{2}”。如果您想要使用此实现文件，请确保项目中的“ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch”属性设置为“警告”或“无”。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index c03fdbd6641..ef2d07887fa 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -191,6 +191,11 @@
         <target state="translated">正在建立永久連結將 "{0}" 複製到 "{1}"。</target>
         <note>LOCALIZATION: {0} and {1} are paths.</note>
       </trans-unit>
+      <trans-unit id="Copy.IOException">
+        <source>MSB3894: Got {0} copying "{1}" to "{2}" and HR is {3}</source>
+        <target state="translated">MSB3894: 擁有 {0} 將 "{1}" 複製至 "{2}"，且 HR 為 {3}</target>
+        <note>{StrBegin="MSB3894: "} LOCALIZATION: {0} is exception.ToString(), {1} and {2} are paths, {3} is a number")</note>
+      </trans-unit>
       <trans-unit id="Copy.LinkFailed">
         <source>MSB3893: Could not use a link to copy "{0}" to "{1}".</source>
         <target state="translated">MSB3893: 無法使用連結將 "{0}" 複製到 "{1}"。</target>
@@ -221,6 +226,11 @@
         <target state="translated">無法使用永久連結將 "{0}" 複製到 "{1}"。請改為使用符號連結複製檔案。{2}</target>
         <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
       </trans-unit>
+      <trans-unit id="Copy.RetryingOnAccessDenied">
+        <source>MSB3895: Retrying on ERROR_ACCESS_DENIED because environment variable MSBUILDALWAYSRETRY=1</source>
+        <target state="translated">MSB3895: 正在 ERROR_ACCESS_DENIED 上重試，因為環境變數 MSBUILDALWAYSRETRY=1</target>
+        <note>{StrBegin="MSB3895: "} LOCALIZATION: Do NOT translate MSBUILDALWAYSRETRY)</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 來源檔案 "{0}" 其實是目錄。"Copy" 工作不支援複製目錄。</target>
@@ -1930,6 +1940,11 @@
         <target state="translated">發現無效的 PE 標頭。將不使用實作檔。</target>
         <note>This message can be used as the {1} in MSB3272</note>
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.UnifiedReferenceDependsOn">
+        <source>References which depend on or have been unified to "{0}" [{1}].</source>
+        <target state="translated">依賴或已整合至 "{0}" [{1}] 的參考。</target>
+        <note> This will look like references which depend on or have been unified to "A, Version=2.0.0.0 PublicKey=4a4fded9gisujf" [a.dll].</note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.UnknownProcessorArchitecture">
         <source>MSB3273: Unknown processor architecture. The implementation file "{0}" for "{1}" had an ImageFileMachine value of "0x{2}". If you wish to use this implementation file make sure the "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" property in your project is set to "Warning" or "None".</source>
         <target state="translated">MSB3273: 未知的處理器架構。"{1}" 的實作檔 "{0}" 中 ImageFileMachine 值為 "0x{2}"。如果要使用這個實作檔，請確定專案中的 "ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" 屬性設為 "Warning" 或 "None"。</target>
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
index f65af92cfed..2d97134b43c 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
@@ -4,6 +4,7 @@
 using System;
 using System.IO;
 using System.Linq;
+using System.Runtime.InteropServices;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 
@@ -14,7 +15,7 @@ namespace Microsoft.Build.Tasks
     internal abstract class RoslynCodeTaskFactoryCompilerBase : ToolTaskExtension
     {
 #if RUNTIME_TYPE_NETCORE
-        private static readonly string DotnetCliPath = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;
+        private readonly string _dotnetCliPath;
 #endif
 
         private readonly Lazy<string> _executablePath;
@@ -43,6 +44,26 @@ protected RoslynCodeTaskFactoryCompilerBase()
             }, isThreadSafe: true);
 
             StandardOutputImportance = MessageImportance.Low.ToString("G");
+
+#if RUNTIME_TYPE_NETCORE
+            // Tools and MSBuild Tasks within the SDK that invoke binaries via the dotnet host are expected
+            // to honor the environment variable DOTNET_HOST_PATH to ensure a consistent experience.
+            _dotnetCliPath = Environment.GetEnvironmentVariable("DOTNET_HOST_PATH");
+            if (string.IsNullOrEmpty(_dotnetCliPath))
+            {
+                // Fallback to get dotnet path from current process which might be dotnet executable.
+                _dotnetCliPath = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;
+            }
+
+            // If dotnet path is not found, rely on dotnet via the system's PATH
+            bool runningOnWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
+            string exeSuffix = runningOnWindows ? ".exe" : string.Empty;
+            var dotnetFileName = $"dotnet{exeSuffix}";
+            if (!_dotnetCliPath.EndsWith(dotnetFileName, StringComparison.OrdinalIgnoreCase))
+            {
+                _dotnetCliPath = "dotnet";
+            }
+#endif
         }
 
         public bool? Deterministic { get; set; }
@@ -99,7 +120,7 @@ protected override string GenerateFullPathToTool()
             }
 
 #if RUNTIME_TYPE_NETCORE
-            return DotnetCliPath;
+            return _dotnetCliPath;
 #else
             return _executablePath.Value;
 #endif
diff --git a/src/Tasks/TaskRequiresFramework.cs b/src/Tasks/TaskRequiresFramework.cs
new file mode 100644
index 00000000000..e681eb903b5
--- /dev/null
+++ b/src/Tasks/TaskRequiresFramework.cs
@@ -0,0 +1,30 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+
+using System;
+
+namespace Microsoft.Build.Tasks
+{
+#if NETFRAMEWORK
+    [Obsolete("The class should not be used in .Net Framework.", true)]
+#endif
+    public abstract class TaskRequiresFramework : TaskExtension
+    {
+        internal TaskRequiresFramework(string taskName) => TaskName = taskName;
+
+        private string TaskName { get; set; }
+
+#if !NETFRAMEWORK
+        /// <summary>
+        /// Task entry point.
+        /// </summary>
+        /// <returns></returns>
+        public override bool Execute()
+        {
+            Log.LogErrorWithCodeFromResources("TaskRequiresFrameworkFailure", TaskName);
+            return false;
+        }
+#endif
+    }
+}
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 4c297df27fd..6721625deb5 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if FEATURE_APPDOMAIN
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
 
 using System;
 #if DEBUG
@@ -14,19 +14,23 @@
 using System.Threading;
 using System.Runtime.InteropServices.ComTypes;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
+#endif
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK && FEATURE_APPDOMAIN
+
     /// <summary>
     /// Registers a managed assembly for COM interop (equivalent of regasm.exe functionality, but this code
     /// doesn't actually call the exe).
     /// </summary>
-    public class UnregisterAssembly : AppDomainIsolatedTaskExtension
+    public class UnregisterAssembly : AppDomainIsolatedTaskExtension, IUnregisterAssemblyTaskContract
     {
         #region Properties
 
@@ -289,5 +293,37 @@ private bool Unregister(string assemblyPath, string typeLibPath)
         private const string unregisteringLockName = "MSBUILD_V_3_5_UNREGISTER_LOCK";
         #endregion
     }
-}
+
+#elif !NETFRAMEWORK
+
+    public sealed class UnregisterAssembly : TaskRequiresFramework, IUnregisterAssemblyTaskContract
+    {
+        public UnregisterAssembly()
+            : base(nameof(UnregisterAssembly))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] Assemblies { get; set; }
+
+        public ITaskItem[] TypeLibFiles { get; set; }
+
+        public ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+
 #endif
+
+    public interface IUnregisterAssemblyTaskContract
+    {
+        #region Properties
+
+        ITaskItem[] Assemblies { get; set; }
+        ITaskItem[] TypeLibFiles { get; set; }
+        ITaskItem AssemblyListFile { get; set; }
+
+        #endregion
+    }
+}
diff --git a/src/Tasks/UpdateManifest.cs b/src/Tasks/UpdateManifest.cs
index 0e9e78bef9c..109f7ee732c 100644
--- a/src/Tasks/UpdateManifest.cs
+++ b/src/Tasks/UpdateManifest.cs
@@ -2,17 +2,22 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Build.Framework;
+
+#if NETFRAMEWORK
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Microsoft.Build.Utilities;
+#endif
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Updates selected properties in a manifest and resigns.
     /// </summary>
-    public class UpdateManifest : Task
+    public class UpdateManifest : Task, IUpdateManifestTaskContract
     {
         [Required]
         public string ApplicationPath { get; set; }
@@ -35,4 +40,44 @@ public override bool Execute()
             return true;
         }
     }
+
+#else
+
+    public sealed class UpdateManifest : TaskRequiresFramework, IUpdateManifestTaskContract
+    {
+        public UpdateManifest()
+            : base(nameof(UpdateManifest))
+        {
+        }
+
+        #region Properties
+
+        public string ApplicationPath { get; set; }
+
+        public string TargetFrameworkVersion { get; set; }
+
+        public ITaskItem ApplicationManifest { get; set; }
+
+        public ITaskItem InputManifest { get; set; }
+
+        [Output]
+        public ITaskItem OutputManifest { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IUpdateManifestTaskContract
+    {
+        #region Properties
+
+        string ApplicationPath { get; set; }
+        string TargetFrameworkVersion { get; set; }
+        ITaskItem ApplicationManifest { get; set; }
+        ITaskItem InputManifest { get; set; }
+        ITaskItem OutputManifest { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/WinMDExp.cs b/src/Tasks/WinMDExp.cs
index 28e2662c997..280b5dcb55c 100644
--- a/src/Tasks/WinMDExp.cs
+++ b/src/Tasks/WinMDExp.cs
@@ -1,21 +1,28 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if NETFRAMEWORK
 using System;
-using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Text;
-using Microsoft.Build.Framework;
+
 using Microsoft.Build.Shared;
+#endif
+
+using System.Diagnostics.CodeAnalysis;
+
+using Microsoft.Build.Framework;
 
 #nullable disable
 
 namespace Microsoft.Build.Tasks
 {
+#if NETFRAMEWORK
+
     /// <summary>
     /// Exports a managed assembly to a windows runtime metadata.
     /// </summary>
-    public class WinMDExp : ToolTaskExtension
+    public class WinMDExp : ToolTaskExtension, IWinMDExpTaskContract
     {
         #region Properties
 
@@ -274,4 +281,66 @@ protected override bool SkipTaskExecution()
         }
         #endregion
     }
+
+#else
+
+    public sealed class WinMDExp : TaskRequiresFramework, IWinMDExpTaskContract
+    {
+        public WinMDExp()
+            : base(nameof(WinMDExp))
+        {
+        }
+
+        #region Properties
+
+        public ITaskItem[] References { get; set; }
+
+        public string DisabledWarnings { get; set; }
+
+        public string InputDocumentationFile { get; set; }
+
+        public string OutputDocumentationFile { get; set; }
+
+        public string InputPDBFile { get; set; }
+
+        public string OutputPDBFile { get; set; }
+
+        public string WinMDModule { get; set; }
+
+        [Output]
+        public string OutputWindowsMetadataFile { get; set; }
+
+        public string SdkToolsPath { get; set; }
+
+        [SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "UTF", Justification = "Not worth breaking customers because of case correction")]
+        public bool UTF8Output { get; set; }
+
+        public bool TreatWarningsAsErrors { get; set; }
+
+        public string AssemblyUnificationPolicy { get; set; }
+
+        #endregion
+    }
+
+#endif
+
+    internal interface IWinMDExpTaskContract
+    {
+        #region Properties
+
+        ITaskItem[] References { get; set; }
+        string DisabledWarnings { get; set; }
+        string InputDocumentationFile { get; set; }
+        string OutputDocumentationFile { get; set; }
+        string InputPDBFile { get; set; }
+        string OutputPDBFile { get; set; }
+        string WinMDModule { get; set; }
+        string OutputWindowsMetadataFile { get; set; }
+        string SdkToolsPath { get; set; }
+        bool UTF8Output { get; set; }
+        bool TreatWarningsAsErrors { get; set; }
+        string AssemblyUnificationPolicy { get; set; }
+
+        #endregion
+    }
 }
diff --git a/src/Tasks/XmlPeek.cs b/src/Tasks/XmlPeek.cs
index 9d8c7326a4f..5f9513f5c0c 100644
--- a/src/Tasks/XmlPeek.cs
+++ b/src/Tasks/XmlPeek.cs
@@ -21,19 +21,11 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class XmlPeek : TaskExtension
     {
-        #region Members
+        #region Properties
 
         /// <summary>
         /// The XPath Query.
         /// </summary>
-        private string _query;
-
-        #endregion
-
-        #region Properties
-        /// <summary>
-        /// The XML input as a file path.
-        /// </summary>
         public ITaskItem XmlInputPath { get; set; }
 
         /// <summary>
@@ -44,16 +36,8 @@ public class XmlPeek : TaskExtension
         /// <summary>
         /// The XPath Query.
         /// </summary>
-        public string Query
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(_query, "Query");
-                return _query;
-            }
-
-            set => _query = value;
-        }
+        [Required]
+        public string Query { get; set; }
 
         /// <summary>
         /// The results returned by this task.
@@ -71,6 +55,7 @@ public string Query
         /// if DTD is present. This was a pre-v15 behavior. By default, a DTD clause if any is ignored.
         /// </summary>
         public bool ProhibitDtd { get; set; }
+
         #endregion
 
         /// <summary>
@@ -80,8 +65,6 @@ public string Query
         public override bool Execute()
         {
             XmlInput xmlinput;
-            ErrorUtilities.VerifyThrowArgumentNull(_query, nameof(Query));
-
             try
             {
                 xmlinput = new XmlInput(XmlInputPath, XmlContent);
@@ -99,7 +82,6 @@ public override bool Execute()
                 using (XmlReader xr = xmlinput.CreateReader(ProhibitDtd))
                 {
                     xpathdoc = new XPathDocument(xr);
-                    xr.Dispose();
                 }
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
@@ -117,11 +99,11 @@ public override bool Execute()
             try
             {
                 // Create the expression from query
-                expr = nav.Compile(_query);
+                expr = nav.Compile(Query);
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                Log.LogErrorWithCodeFromResources("XmlPeekPoke.XPathError", _query, e.Message);
+                Log.LogErrorWithCodeFromResources("XmlPeekPoke.XPathError", Query, e.Message);
                 return false;
             }
 
@@ -230,7 +212,7 @@ private static void LoadNamespaces(ref XmlNamespaceManager namespaceManager, str
         /// <summary>
         /// This class prepares XML input from XMLInputPath and XMLContent parameters
         /// </summary>
-        internal class XmlInput
+        private sealed class XmlInput
         {
             /// <summary>
             /// This either contains the raw Xml or the path to Xml file.
@@ -238,7 +220,7 @@ internal class XmlInput
             private readonly string _data;
 
             /// <summary>
-            /// Filestream used to read XML.
+            /// FileStream used to read XML.
             /// </summary>
             private FileStream _fs;
 
@@ -254,7 +236,8 @@ public XmlInput(ITaskItem xmlInputPath, string xmlContent)
                 {
                     throw new ArgumentException(ResourceUtilities.GetResourceString("XmlPeek.XmlInput.TooMany"));
                 }
-                else if (xmlInputPath == null && xmlContent == null)
+
+                if (xmlInputPath == null && xmlContent == null)
                 {
                     throw new ArgumentException(ResourceUtilities.GetResourceString("XmlPeek.XmlInput.TooFew"));
                 }
@@ -274,7 +257,7 @@ public XmlInput(ITaskItem xmlInputPath, string xmlContent)
             /// <summary>
             /// Possible accepted types of XML input.
             /// </summary>
-            public enum XmlModes
+            private enum XmlModes
             {
                 /// <summary>
                 /// If the mode is a XML file.
@@ -290,7 +273,7 @@ public enum XmlModes
             /// <summary>
             /// Returns the current mode of the XmlInput
             /// </summary>
-            public XmlModes XmlMode { get; }
+            private XmlModes XmlMode { get; }
 
             /// <summary>
             /// Creates correct reader based on the input type.
diff --git a/src/Tasks/XmlPoke.cs b/src/Tasks/XmlPoke.cs
index a60147e0cc8..501d0bc9428 100644
--- a/src/Tasks/XmlPoke.cs
+++ b/src/Tasks/XmlPoke.cs
@@ -20,51 +20,23 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     public class XmlPoke : TaskExtension
     {
-        #region Members
-        /// <summary>
-        /// The XML input as file paths.
-        /// </summary>
-        private ITaskItem _xmlInputPath;
-
-        /// <summary>
-        /// The XPath Query.
-        /// </summary>
-        private string _query;
-
-        #endregion
-
         #region Properties
+
         /// <summary>
         /// The XML input as file path.
         /// </summary>
-        public ITaskItem XmlInputPath
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(_xmlInputPath, nameof(XmlInputPath));
-                return _xmlInputPath;
-            }
-
-            set => _xmlInputPath = value;
-        }
+        [Required]
+        public ITaskItem XmlInputPath { get; set; }
 
         /// <summary>
         /// The XPath Query.
         /// </summary>
-        public string Query
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(_query, nameof(Query));
-                return _query;
-            }
-
-            set => _query = value;
-        }
+        [Required]
+        public string Query { get; set; }
 
         /// <summary>
         /// The value to be inserted into the specified location.
-        /// </summary>        
+        /// </summary>
         public ITaskItem Value { get; set; }
 
         /// <summary>
@@ -77,15 +49,13 @@ public string Query
         /// <summary>
         /// Executes the XMLPoke task.
         /// </summary>
-        /// <returns>true if transformation succeeds.</returns>
+        /// <returns>true if task execution succeeds.</returns>
         public override bool Execute()
         {
-            ErrorUtilities.VerifyThrowArgumentNull(_query, "Query");
-            ErrorUtilities.VerifyThrowArgumentNull(_xmlInputPath, "XmlInputPath");
             if (Value == null)
             {
                 // When Value is null, it means Value is not set or empty. Here we treat them all as empty.
-                Value = new TaskItem(String.Empty);
+                Value = new TaskItem(string.Empty);
             }
 
             // Load the XPath Document
@@ -93,7 +63,7 @@ public override bool Execute()
 
             try
             {
-                using (FileStream fs = new FileStream(_xmlInputPath.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
+                using (FileStream fs = new FileStream(XmlInputPath.ItemSpec, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                 {
                     XmlReaderSettings xrs = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
                     using (XmlReader sr = XmlReader.Create(fs, xrs))
@@ -104,7 +74,7 @@ public override bool Execute()
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                Log.LogErrorWithCodeFromResources("XmlPeekPoke.InputFileError", _xmlInputPath.ItemSpec, e.Message);
+                Log.LogErrorWithCodeFromResources("XmlPeekPoke.InputFileError", XmlInputPath.ItemSpec, e.Message);
                 return false;
             }
 
@@ -114,11 +84,11 @@ public override bool Execute()
             try
             {
                 // Create the expression from query
-                expr = nav.Compile(_query);
+                expr = nav.Compile(Query);
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
-                Log.LogErrorWithCodeFromResources("XmlPeekPoke.XPathError", _query, e.Message);
+                Log.LogErrorWithCodeFromResources("XmlPeekPoke.XPathError", Query, e.Message);
                 return false;
             }
 
@@ -169,12 +139,12 @@ public override bool Execute()
             if (count > 0)
             {
 #if RUNTIME_TYPE_NETCORE
-                using (Stream stream = File.Create(_xmlInputPath.ItemSpec))
+                using (Stream stream = File.Create(XmlInputPath.ItemSpec))
                 {
                     xmlDoc.Save(stream);
                 }
 #else
-                xmlDoc.Save(_xmlInputPath.ItemSpec);
+                xmlDoc.Save(XmlInputPath.ItemSpec);
 #endif
             }
 
diff --git a/src/UnitTests.Shared/DummyMappedDriveUtils.cs b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
new file mode 100644
index 00000000000..c2c28c8f0e5
--- /dev/null
+++ b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
@@ -0,0 +1,28 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable enable
+using System;
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests.Shared;
+
+namespace Microsoft.Build.UnitTests.Shared;
+
+internal static class DummyMappedDriveUtils
+{
+    public static string UpdatePathToMappedDrive(string path, char driveLetter)
+    {
+        const string drivePlaceholder = "%DRIVE%";
+        // if this seems to be rooted path - replace with the dummy mount
+        if (!string.IsNullOrEmpty(path) && path.StartsWith(drivePlaceholder))
+        {
+            path = driveLetter + path.Substring(drivePlaceholder.Length);
+        }
+        return path;
+    }
+
+    public static Lazy<DummyMappedDrive?> GetLazyDummyMappedDrive() => new Lazy<DummyMappedDrive?>(() =>
+        {
+            return NativeMethods.IsWindows ? new DummyMappedDrive() : default;
+        });
+}
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 48dfd777c71..c1e96f7a6cb 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -15,6 +15,12 @@ public static class RunnerUtilities
         public static string PathToCurrentlyRunningMsBuildExe => BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
 #if !FEATURE_RUN_EXE_IN_TESTS
         private static readonly string s_dotnetExePath = EnvironmentProvider.GetDotnetExePath();
+
+        public static void ApplyDotnetHostPathEnvironmentVariable(TestEnvironment testEnvironment)
+        {
+            // Built msbuild.dll executed by dotnet.exe needs this environment variable for msbuild tasks such as RoslynCodeTaskFactory.
+            testEnvironment.SetEnvironmentVariable("DOTNET_HOST_PATH", s_dotnetExePath);
+        }
 #endif
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index b40b91cd8fa..308a4915321 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -827,6 +827,34 @@ protected override string GenerateCommandLineCommands()
         }
 
         /// <summary>
+        /// Verifies the validation of the <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+        /// </summary>
+        /// <param name="timeout">New value for <see cref="ToolTask.TaskProcessTerminationTimeout" />.</param>
+        /// <param name="isInvalidValid">Is a task expected to be valid or not.</param>
+        [Theory]
+        [InlineData(int.MaxValue, false)]
+        [InlineData(97, false)]
+        [InlineData(0, false)]
+        [InlineData(-1, false)]
+        [InlineData(-2, true)]
+        [InlineData(-101, true)]
+        [InlineData(int.MinValue, true)]
+        public void SetsTerminationTimeoutCorrectly(int timeout, bool isInvalidValid)
+        {
+            using var env = TestEnvironment.Create(_output);
+
+            // Task under test:
+            var task = new ToolTaskSetsTerminationTimeout
+            {
+                BuildEngine = new MockEngine()
+            };
+
+            task.TerminationTimeout = timeout;
+            task.ValidateParameters().ShouldBe(!isInvalidValid);
+            task.TerminationTimeout.ShouldBe(timeout);
+        }
+		
+		/// <summary>
         /// Verifies that a ToolTask instance can return correct results when executed multiple times with timeout.
         /// </summary>
         /// <param name="repeats">Specifies the number of repeats for external command execution.</param>
@@ -960,5 +988,50 @@ public override bool Execute()
                 return base.Execute();
             }
         }
+
+        /// <summary>
+        /// A simple implementation of <see cref="ToolTask"/> to excercise <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+        /// </summary>
+        private sealed class ToolTaskSetsTerminationTimeout : ToolTask
+        {
+            public ToolTaskSetsTerminationTimeout()
+                : base()
+            {
+                base.TaskResources = AssemblyResources.PrimaryResources;
+            }
+
+            /// <summary>
+            /// Gets or sets <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+            /// </summary>
+            /// <remarks>
+            /// This is just a proxy property to access <see cref="ToolTask.TaskProcessTerminationTimeout" />.
+            /// </remarks>
+            public int TerminationTimeout
+            {
+                get => TaskProcessTerminationTimeout;
+                set => TaskProcessTerminationTimeout = value;
+            }
+
+            /// <summary>
+            /// Gets the tool name (dummy).
+            /// </summary>
+            protected override string ToolName => string.Empty;
+
+            /// <summary>
+            /// Gets the full path to tool (dummy).
+            /// </summary>
+            protected override string GenerateFullPathToTool() => string.Empty;
+
+            /// <summary>
+            /// Does nothing.
+            /// </summary>
+            /// <returns>
+            /// Always returns true.
+            /// </returns>
+            /// <remarks>
+            /// This dummy tool task is not meant to run anything.
+            /// </remarks>
+            public override bool Execute() => true;
+        }
     }
 }
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
index bb15e1e6c3e..2545a39b99a 100644
--- a/src/Utilities/CompatibilitySuppressions.xml
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -1,14 +1,6 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- We don't have the net7 reference assemblies handy to pass in to compare against the net8 ones -->
-  <Suppression>
-    <DiagnosticId>CP1002</DiagnosticId>
-    <Target>System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</Target>
-    <Left>ref/net7.0/Microsoft.Build.Utilities.Core.dll</Left>
-    <Right>ref/netstandard2.0/Microsoft.Build.Utilities.Core.dll</Right>
-    <IsBaselineSuppression>true</IsBaselineSuppression>
-  </Suppression>
   <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
        This is intentional, because you can only use MSBuild in the context of a .NET SDK
        (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
@@ -62,9 +54,4 @@
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>Xamarin.XboxOne,Version=v0.0</Target>
   </Suppression>
-<!-- For updating target framework from net 7.0 to net 8.0 in MSBuild 17.8 suppress baseline package validation error PKV006 on net 7.0 -->
-  <Suppression>
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>net7.0</Target>
-  </Suppression>
 </Suppressions>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index b9296ffc4e4..5b9a22eba36 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -32,7 +32,6 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
-    <PackageReference Include="System.Security.Permissions" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
   
diff --git a/src/Utilities/Resources/Strings.resx b/src/Utilities/Resources/Strings.resx
index 639f489139e..1bbcf8ce260 100644
--- a/src/Utilities/Resources/Strings.resx
+++ b/src/Utilities/Resources/Strings.resx
@@ -290,6 +290,9 @@
     <value>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</value>
     <comment>{StrBegin="MSB6012: "}</comment>
   </data>
+  <data name="ToolTask.InvalidTerminationTimeout" xml:space="preserve">
+    <value>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</value>
+  </data>
   <!--
         The Utilities message bucket is: MSB6001 - MSB6200
 
diff --git a/src/Utilities/Resources/xlf/Strings.cs.xlf b/src/Utilities/Resources/xlf/Strings.cs.xlf
index f03d0670d1d..472924ca574 100644
--- a/src/Utilities/Resources/xlf/Strings.cs.xlf
+++ b/src/Utilities/Resources/xlf/Strings.cs.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Nepodařilo se spustit spustitelný soubor zadané úlohy {0}. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Zadaný časový limit ukončení ({0}) je neplatný – očekává se hodnota větší nebo rovna -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Úlohu nelze přeskočit, protože není aktuální.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.de.xlf b/src/Utilities/Resources/xlf/Strings.de.xlf
index 7b1b9bbd81a..ae6c7f1d318 100644
--- a/src/Utilities/Resources/xlf/Strings.de.xlf
+++ b/src/Utilities/Resources/xlf/Strings.de.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Die angegebene ausführbare Datei der Aufgabe "{0}" konnte nicht ausgeführt werden. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Das angegebene Beendigungstimeout ({0}) ist ungültig. Es wird ein Wert größer oder gleich -1 erwartet.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Die Aufgabe kann nicht übersprungen werden, da sie nicht auf dem neuesten Stand ist.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.es.xlf b/src/Utilities/Resources/xlf/Strings.es.xlf
index 4e1d526942f..fb3fb6346d2 100644
--- a/src/Utilities/Resources/xlf/Strings.es.xlf
+++ b/src/Utilities/Resources/xlf/Strings.es.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: No se pudo ejecutar la tarea ejecutable especificada "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">El tiempo de espera de finalización especificado ({0}) no es válido; se espera un valor mayor o igual que -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">No se puede omitir la tarea porque no está actualizada.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index 16e18463161..b5081267c27 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Impossible d'exécuter la tâche exécutable spécifiée "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Le délai d’arrêt spécifié ({0}) n’est pas valide . La valeur attendue est supérieure ou égale à -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Nous n’avons pas pu ignorer la tâche, car elle n’est pas à jour.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.it.xlf b/src/Utilities/Resources/xlf/Strings.it.xlf
index 051435b8f45..a6f2388b69c 100644
--- a/src/Utilities/Resources/xlf/Strings.it.xlf
+++ b/src/Utilities/Resources/xlf/Strings.it.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: non è stato possibile eseguire il file eseguibile "{0}" dell'attività. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Il timeout di terminazione specificato ({0}) non è valido - è previsto un valore maggiore o uguale a -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Non è possibile ignorare l'attività perché non è aggiornata.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ja.xlf b/src/Utilities/Resources/xlf/Strings.ja.xlf
index f47ade5a30c..82696e9d9f3 100644
--- a/src/Utilities/Resources/xlf/Strings.ja.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ja.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: 指定されたタスク実行可能ファイル "{0}" を実行できませんでした。{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">指定された終了タイムアウト ({0}) は無効です。-1 以上の値を指定してください。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">タスクは最新ではないため、スキップできません。</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ko.xlf b/src/Utilities/Resources/xlf/Strings.ko.xlf
index 6e90f79aa10..2de87f94e2b 100644
--- a/src/Utilities/Resources/xlf/Strings.ko.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ko.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: 지정한 작업 실행 파일 "{0}"을(를) 실행할 수 없습니다. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">지정한 종료 시간 제한({0})이 잘못되었습니다. -1보다 크거나 같은 값이 필요합니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">작업이 최신 상태가 아니므로 건너뛸 수 없습니다.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pl.xlf b/src/Utilities/Resources/xlf/Strings.pl.xlf
index 0a40f6100e8..0be09edd704 100644
--- a/src/Utilities/Resources/xlf/Strings.pl.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pl.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Nie można uruchomić określonego pliku wykonywalnego zadania „{0}”. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Określony limit czasu zakończenia ({0}) jest nieprawidłowy — oczekiwano wartości większej lub równej -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Nie można pominąć zadania, ponieważ nie jest ono aktualne.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
index 4dac2b52e26..031011afb81 100644
--- a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Não foi possível executar a tarefa executável "{0}" especificada. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">O tempo limite de encerramento especificado ({0}) é inválido - esperando valor maior ou igual a -1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Não foi possível ignorar a tarefa porque ela não está atualizada.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ru.xlf b/src/Utilities/Resources/xlf/Strings.ru.xlf
index ff9b0e8c2fa..af05a69213a 100644
--- a/src/Utilities/Resources/xlf/Strings.ru.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ru.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Не удалось запустить указанный исполняемый файл задачи "{0}". {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Указано недопустимое время ожидания завершения ({0}) — ожидается значение больше или равно –1.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Невозможно пропустить задачу, поскольку она не обновлена.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.tr.xlf b/src/Utilities/Resources/xlf/Strings.tr.xlf
index badcc02495d..a2d9744fdbc 100644
--- a/src/Utilities/Resources/xlf/Strings.tr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.tr.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: Belirtilen "{0}" görev yürütülebilir dosyası çalıştırılamadı. {1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">Belirtilen sonlandırma zaman aşımı ({0}) geçersiz; -1'den büyük veya buna eşit bir değer bekleniyor.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">Güncel olmadığı için görev atlanamıyor.</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
index 3455e66d0d1..ae68e2fdab0 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: 指定的任务可执行文件“{0}”未能运行。{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">指定的终止超时({0})无效 - 值应大于或等于 -1。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">无法跳过任务，因为它不是最新的。</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index bf830c02ea3..347b5ed842b 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -57,6 +57,11 @@
         <target state="translated">MSB6003: 無法執行指定的工作可執行檔 "{0}"。{1}</target>
         <note>{StrBegin="MSB6003: "}</note>
       </trans-unit>
+      <trans-unit id="ToolTask.InvalidTerminationTimeout">
+        <source>Specified termination timeout ({0}) is invalid - expecting value greater or equal to -1.</source>
+        <target state="translated">指定的終止逾時 ({0}) 無效 - 必須是大於或等於 -1 的值。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ToolTask.NotUpToDate">
         <source>Unable to skip task because it is not up-to-date.</source>
         <target state="translated">無法略過工作，因為它不是最新的。</target>
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index daee4074552..3a8ff43f237 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -345,7 +345,16 @@ protected virtual void ProcessStarted() { }
         /// Implemented in the derived class
         /// </summary>
         /// <returns>true, if successful</returns>
-        protected internal virtual bool ValidateParameters() => true; // Default is no validation (ie. parameters are always valid, hence the true return value). This is useful for tools that don't need validation.
+        protected internal virtual bool ValidateParameters()
+        {
+            if (TaskProcessTerminationTimeout < -1 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+            {
+                Log.LogWarningWithCodeFromResources("ToolTask.InvalidTerminationTimeout", TaskProcessTerminationTimeout);
+                return false;
+            }
+
+            return true;
+        }
 
         /// <summary>
         /// Returns true if task execution is not necessary. Executed after ValidateParameters
@@ -945,7 +954,7 @@ private void KillToolProcessOnTimeout(Process proc, bool isBeingCancelled)
                     LogShared.LogWarningWithCodeFromResources("Shared.KillingProcessByCancellation", processName);
                 }
 
-                int timeout = 5000;
+                int timeout = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && TaskProcessTerminationTimeout >= -1 ? TaskProcessTerminationTimeout : 5000;
                 string timeoutFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDTOOLTASKCANCELPROCESSWAITTIMEOUT");
                 if (timeoutFromEnvironment != null)
                 {
