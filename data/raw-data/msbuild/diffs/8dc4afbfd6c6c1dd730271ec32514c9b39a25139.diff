diff --git a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
index bb0c19a4415..bd3b9855abf 100644
--- a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
@@ -2,10 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Logging;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index dbae5b67cd1..7af19e40294 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -173,7 +173,7 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
                 {
                     // If we're able to connect to such a process, send a packet requesting its termination
                     CommunicationsUtilities.Trace("Shutting down node with pid = {0}", nodeProcess.Id);
-                    NodeContext nodeContext = new NodeContext(0, nodeProcess, nodeStream, factory, terminateNode);
+                    NodeContext nodeContext = new NodeContext(0, nodeProcess, nodeStream, factory, terminateNode, (HandshakeOptions)NodeProviderOutOfProc.GetHandshake(nodeReuse, false).GetHandshakeOptions);
                     nodeContext.SendData(new NodeBuildComplete(false /* no node reuse */));
                     nodeStream.Dispose();
                 }
@@ -293,7 +293,7 @@ bool TryReuseAnyFromPossibleRunningNodes(int nodeId)
                             BuildEventContext = new BuildEventContext(nodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId)
                         });
 
-                        CreateNodeContext(nodeId, nodeToReuse, nodeStream);
+                        CreateNodeContext(nodeId, nodeToReuse, nodeStream, (HandshakeOptions)hostHandshake.GetHandshakeOptions);
                         return true;
                     }
                 }
@@ -349,7 +349,7 @@ bool StartNewNode(int nodeId)
                         // Connection successful, use this node.
                         CommunicationsUtilities.Trace("Successfully connected to created node {0} which is PID {1}", nodeId, msbuildProcess.Id);
 
-                        CreateNodeContext(nodeId, msbuildProcess, nodeStream);
+                        CreateNodeContext(nodeId, msbuildProcess, nodeStream, (HandshakeOptions)hostHandshake.GetHandshakeOptions);
                         return true;
                     }
 
@@ -378,9 +378,9 @@ bool StartNewNode(int nodeId)
                 return false;
             }
 
-            void CreateNodeContext(int nodeId, Process nodeToReuse, Stream nodeStream)
+            void CreateNodeContext(int nodeId, Process nodeToReuse, Stream nodeStream, HandshakeOptions handshake)
             {
-                NodeContext nodeContext = new(nodeId, nodeToReuse, nodeStream, factory, terminateNode);
+                NodeContext nodeContext = new(nodeId, nodeToReuse, nodeStream, factory, terminateNode, handshake);
                 nodeContexts.Enqueue(nodeContext);
                 createNode(nodeContext);
             }
@@ -602,12 +602,21 @@ private enum ExitPacketState
             /// </summary>
             private BinaryReaderFactory _binaryReaderFactory;
 
+            /// <summary>
+            /// Handshake options.
+            /// </summary>
+            private HandshakeOptions _handshakeOptions;
+
             /// <summary>
             /// Constructor.
             /// </summary>
-            public NodeContext(int nodeId, Process process,
+            public NodeContext(
+                int nodeId,
+                Process process,
                 Stream nodePipe,
-                INodePacketFactory factory, NodeContextTerminateDelegate terminateDelegate)
+                INodePacketFactory factory,
+                NodeContextTerminateDelegate terminateDelegate,
+                HandshakeOptions handshakeOptions)
             {
                 _nodeId = nodeId;
                 _process = process;
@@ -619,6 +628,7 @@ public NodeContext(int nodeId, Process process,
                 _writeBufferMemoryStream = new MemoryStream();
                 _terminateDelegate = terminateDelegate;
                 _binaryReaderFactory = InterningBinaryReader.CreateSharedBuffer();
+                _handshakeOptions = handshakeOptions;
             }
 
             /// <summary>
@@ -766,7 +776,7 @@ private void SendDataCore(INodePacket packet)
 
 #if !TASKHOST
 
-                    if (packet is ITranslatable2 jsonTranslatable)
+                    if ((_handshakeOptions & HandshakeOptions.NET) == HandshakeOptions.NET && packet is ITranslatable2 jsonTranslatable)
                     {
                         var writeTranslator = JsonTranslator.GetWriteTranslator(writeStream);
                         jsonTranslatable.Translate(writeTranslator);
diff --git a/src/Framework/IJsonTranslator.cs b/src/Framework/IJsonTranslator.cs
index 172f840390c..8b36c16f302 100644
--- a/src/Framework/IJsonTranslator.cs
+++ b/src/Framework/IJsonTranslator.cs
@@ -19,19 +19,7 @@ internal interface IJsonTranslator : ITranslatorBase, IDisposable
         /// </summary>
         TranslationDirection Mode { get; }
 
-        void TranslateToJson<T>(T model, JsonSerializerOptions jsonSerializerOptions = null);
-
-        T TranslateFromJson<T>(JsonSerializerOptions jsonSerializerOptions = null);
-
-        // Additional methods for specific type handling if needed
-        void TranslateCulture(string propertyName, ref CultureInfo culture);
-
-        void TranslateDictionary<TKey, TValue>(
-            JsonSerializerOptions jsonSerializerOptions,
-            string propertyName,
-            ref Dictionary<TKey, TValue> dictionary,
-            IEqualityComparer<TKey> comparer,
-            Func<TValue> valueFactory = null);
+        void Translate<T>(ref T model, JsonSerializerOptions jsonSerializerOptions = null);
     }
 }
 #endif
diff --git a/src/Framework/JsonTranslator.cs b/src/Framework/JsonTranslator.cs
index c3917306791..649ca2516d4 100644
--- a/src/Framework/JsonTranslator.cs
+++ b/src/Framework/JsonTranslator.cs
@@ -40,6 +40,7 @@ public JsonReadTranslator(Stream stream, int packetLength)
                 {
                     throw new IOException($"Expected to read {packetLength} bytes but got {bytesRead}");
                 }
+
                 _document = JsonDocument.Parse(buffer);
             }
 
@@ -47,39 +48,7 @@ public JsonReadTranslator(Stream stream, int packetLength)
 
             public ProtocolType Protocol => ProtocolType.Json;
 
-            public void TranslateCulture(string propertyName, ref CultureInfo culture)
-            {
-                if (_document.RootElement.TryGetProperty(propertyName, out JsonElement element))
-                {
-                    string cultureName = element.GetString();
-                    culture = !string.IsNullOrEmpty(cultureName)
-                        ? CultureInfo.GetCultureInfo(cultureName)
-                        : null;
-                }
-            }
-
-            public void TranslateDictionary<TKey, TValue>(
-                JsonSerializerOptions jsonSerializerOptions,
-                string propertyName,
-                ref Dictionary<TKey, TValue> dictionary,
-                IEqualityComparer<TKey> comparer,
-                Func<TValue> valueFactory = null)
-            {
-                if (!_document.RootElement.TryGetProperty(propertyName, out JsonElement element))
-                {
-                    dictionary = null;
-                    return;
-                }
-
-                dictionary = JsonSerializer.Deserialize<Dictionary<TKey, TValue>>(element.GetRawText(), jsonSerializerOptions);
-            }
-
-            public T TranslateFromJson<T>(JsonSerializerOptions jsonSerializerOptions = null) => JsonSerializer.Deserialize<T>(_document.RootElement.GetRawText(), jsonSerializerOptions);
-
-            public void TranslateToJson<T>(T model, JsonSerializerOptions jsonSerializerOptions = null)
-            {
-                throw new InvalidOperationException("Cannot write to a read-only translator");
-            }
+            public void Translate<T>(ref T model, JsonSerializerOptions jsonSerializerOptions = null) => model = JsonSerializer.Deserialize<T>(_document.RootElement.GetRawText(), jsonSerializerOptions);
 
             public void Dispose()
             {
@@ -99,172 +68,130 @@ private class JsonWriteTranslator : IJsonTranslator
 
             public JsonWriteTranslator(Stream stream)
             {
-                Debugger.Launch();
                 _stream = stream;
-                _writer = new Utf8JsonWriter(_stream, new JsonWriterOptions
-                {
-                    Indented = true
-                });
+                _writer = new Utf8JsonWriter(_stream);
             }
 
             public TranslationDirection Mode => TranslationDirection.WriteToStream;
 
             public ProtocolType Protocol => ProtocolType.Json;
 
-            public void TranslateCulture(string propertyName, ref CultureInfo culture)
+            public void Translate<T>(ref T model, JsonSerializerOptions jsonSerializerOptions = null) => JsonSerializer.Serialize(_writer, model, jsonSerializerOptions);
+
+            public void Dispose()
             {
-                _writer.WritePropertyName(propertyName);
-                if (culture != null)
-                {
-                    _writer.WriteStringValue(culture.Name);
-                }
-                else
+                if (!_disposed)
                 {
-                    _writer.WriteNullValue();
+                    _writer?.Dispose();
+                    _stream?.Dispose();
+                    _disposed = true;
                 }
             }
+        }
+    }
 
-            public void TranslateDictionary<TKey, TValue>(
-                JsonSerializerOptions jsonSerializerOptions,
-                string propertyName,
-                ref Dictionary<TKey, TValue> dictionary,
-                IEqualityComparer<TKey> comparer,
-                Func<TValue> valueFactory = null)
+    internal static class JsonTranslatorExtensions
+    {
+        internal static object GetNumberValue(JsonElement valueElement) =>
+            (valueElement.TryGetInt32(out int intValue), valueElement.TryGetInt64(out long longValue)) switch
             {
-                _writer.WritePropertyName(propertyName);
+                (true, _) => intValue,
+                (false, true) => longValue,
+                _ => valueElement.GetDouble()
+            };
 
-                if (dictionary == null)
-                {
-                    _writer.WriteNullValue();
-                    return;
-                }
-
-                _writer.WriteStartObject();
-
-                foreach (var kvp in dictionary)
-                {
-                    _writer.WritePropertyName(kvp.Key.ToString());
-
-                    JsonSerializer.Serialize(_writer, kvp.Value, typeof(TValue), jsonSerializerOptions);
-                }
-
-                _writer.WriteEndObject();
+        internal static void WriteValue(Utf8JsonWriter writer, object value, JsonSerializerOptions jsonSerializerOptions)
+        {
+            switch (value)
+            {
+                case null:
+                    writer.WriteNullValue();
+                    break;
+                case string str:
+                    writer.WriteStringValue(str);
+                    break;
+                case int i:
+                    writer.WriteNumberValue(i);
+                    break;
+                case long l:
+                    writer.WriteNumberValue(l);
+                    break;
+                case double d:
+                    writer.WriteNumberValue(d);
+                    break;
+                case float f:
+                    writer.WriteNumberValue(f);
+                    break;
+                case decimal dec:
+                    writer.WriteNumberValue(dec);
+                    break;
+                case bool b:
+                    writer.WriteBooleanValue(b);
+                    break;
+                case DateTime dt:
+                    writer.WriteStringValue(dt);
+                    break;
+                case ITaskItem taskItem:
+                    WriteTaskItem(writer, taskItem);
+                    break;
+                case ITaskItem[] taskItems:
+                    WriteTaskItemArray(writer, taskItems);
+                    break;
+                case IEnumerable enumerable:
+                    WriteEnumerable(writer, enumerable, jsonSerializerOptions);
+                    break;
+                default:
+                    JsonSerializer.Serialize(writer, value, value.GetType(), jsonSerializerOptions);
+                    break;
             }
+        }
 
+        private static void WriteTaskItemArray(Utf8JsonWriter writer, ITaskItem[] taskItems)
+        {
+            writer.WriteStartArray();
 
-            private void WriteValue(object value, JsonSerializerOptions jsonSerializerOptions)
+            foreach (var item in taskItems)
             {
-                switch (value)
-                {
-                    case null:
-                        _writer.WriteNullValue();
-                        break;
-                    case string str:
-                        _writer.WriteStringValue(str);
-                        break;
-                    case int i:
-                        _writer.WriteNumberValue(i);
-                        break;
-                    case long l:
-                        _writer.WriteNumberValue(l);
-                        break;
-                    case double d:
-                        _writer.WriteNumberValue(d);
-                        break;
-                    case float f:
-                        _writer.WriteNumberValue(f);
-                        break;
-                    case decimal dec:
-                        _writer.WriteNumberValue(dec);
-                        break;
-                    case bool b:
-                        _writer.WriteBooleanValue(b);
-                        break;
-                    case DateTime dt:
-                        _writer.WriteStringValue(dt);
-                        break;
-                    case ITaskItem taskItem:
-                        WriteTaskItem(taskItem);
-                        break;
-                    case ITaskItem[] taskItems:
-                        WriteTaskItemArray(taskItems);
-                        break;
-                    case IEnumerable enumerable:
-                        WriteEnumerable(enumerable, jsonSerializerOptions);
-                        break;
-                    default:
-                        JsonSerializer.Serialize(_writer, value, value.GetType(), jsonSerializerOptions);
-                        break;
-                }
+                WriteTaskItem(writer, item);
             }
 
-            private void WriteTaskItem(ITaskItem taskItem)
-            {
-                _writer.WriteStartObject();
-
-                _writer.WritePropertyName("itemSpec");
-                _writer.WriteStringValue(taskItem.ItemSpec);
-
-                if (taskItem.MetadataCount > 0)
-                {
-                    _writer.WritePropertyName("metadata");
-                    _writer.WriteStartObject();
-
-                    foreach (string name in taskItem.MetadataNames)
-                    {
-                        _writer.WritePropertyName(name);
-                        _writer.WriteStringValue(taskItem.GetMetadata(name));
-                    }
+            writer.WriteEndArray();
+        }
 
-                    _writer.WriteEndObject();
-                }
+        private static void WriteEnumerable(Utf8JsonWriter writer, IEnumerable enumerable, JsonSerializerOptions jsonSerializerOptions)
+        {
+            writer.WriteStartArray();
 
-                _writer.WriteEndObject();
+            foreach (var item in enumerable)
+            {
+                WriteValue(writer, item, jsonSerializerOptions);
             }
 
-            private void WriteTaskItemArray(ITaskItem[] taskItems)
-            {
-                _writer.WriteStartArray();
+            writer.WriteEndArray();
+        }
 
-                foreach (var item in taskItems)
-                {
-                    WriteTaskItem(item);
-                }
+        private static void WriteTaskItem(Utf8JsonWriter writer, ITaskItem taskItem)
+        {
+            writer.WriteStartObject();
 
-                _writer.WriteEndArray();
-            }
+            writer.WritePropertyName("itemSpec");
+            writer.WriteStringValue(taskItem.ItemSpec);
 
-            private void WriteEnumerable(IEnumerable enumerable, JsonSerializerOptions jsonSerializerOptions)
+            if (taskItem.MetadataCount > 0)
             {
-                _writer.WriteStartArray();
+                writer.WritePropertyName("metadata");
+                writer.WriteStartObject();
 
-                foreach (var item in enumerable)
+                foreach (string name in taskItem.MetadataNames)
                 {
-                    WriteValue(item, jsonSerializerOptions);
+                    writer.WritePropertyName(name);
+                    writer.WriteStringValue(taskItem.GetMetadata(name));
                 }
 
-                _writer.WriteEndArray();
-            }
-
-            public T TranslateFromJson<T>(JsonSerializerOptions jsonSerializerOptions = null)
-            {
-                throw new InvalidOperationException("Cannot read from a write-only translator");
+                writer.WriteEndObject();
             }
 
-            public void TranslateToJson<T>(T model, JsonSerializerOptions jsonSerializerOptions = null)
-            {
-                JsonSerializer.Serialize(_writer, model, jsonSerializerOptions);
-            }
-
-            public void Dispose()
-            {
-                if (!_disposed)
-                {
-                    _writer?.Dispose();
-                    _stream?.Dispose();
-                    _disposed = true;
-                }
-            }
+            writer.WriteEndObject();
         }
     }
 }
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index ed584aa0726..49e1350aca4 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -133,7 +133,7 @@ protected internal Handshake(HandshakeOptions nodeType)
 
         public virtual KeyValuePair<string, int>[] RetrieveHandshakeComponents() =>
         [
-            new KeyValuePair<string, int>(nameof(salt), CommunicationsUtilities.AvoidEndOfHandshakeSignal(options)),
+            new KeyValuePair<string, int>(nameof(options), CommunicationsUtilities.AvoidEndOfHandshakeSignal(options)),
             new KeyValuePair<string, int>(nameof(salt), CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt)),
             new KeyValuePair<string, int>(nameof(fileVersionMajor), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor)),
             new KeyValuePair<string, int>(nameof(fileVersionMinor), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor)),
@@ -145,6 +145,8 @@ public virtual KeyValuePair<string, int>[] RetrieveHandshakeComponents() =>
         public virtual string GetKey() => $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}".ToString(CultureInfo.InvariantCulture);
 
         public virtual byte? ExpectedVersionInFirstByte => CommunicationsUtilities.handshakeVersion;
+
+        public int GetHandshakeOptions => options;
     }
 
     internal sealed class ServerNodeHandshake : Handshake
@@ -163,7 +165,7 @@ internal ServerNodeHandshake(HandshakeOptions nodeType)
 
         public override KeyValuePair<string, int>[] RetrieveHandshakeComponents() =>
         [
-            new KeyValuePair<string, int>(nameof(salt), CommunicationsUtilities.AvoidEndOfHandshakeSignal(options)),
+            new KeyValuePair<string, int>(nameof(options), CommunicationsUtilities.AvoidEndOfHandshakeSignal(options)),
             new KeyValuePair<string, int>(nameof(salt), CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt)),
             new KeyValuePair<string, int>(nameof(fileVersionMajor), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor)),
             new KeyValuePair<string, int>(nameof(fileVersionMinor), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor)),
@@ -500,6 +502,7 @@ bool isProvider
                 {
                     CommunicationsUtilities.Trace("Expected end of handshake signal but received {0}. Probably the host is a different MSBuild build.", valueRead);
                 }
+
                 throw new InvalidOperationException();
             }
         }
diff --git a/src/Shared/NodeBuildComplete.cs b/src/Shared/NodeBuildComplete.cs
index 06bab065317..785bd042b4e 100644
--- a/src/Shared/NodeBuildComplete.cs
+++ b/src/Shared/NodeBuildComplete.cs
@@ -77,7 +77,7 @@ public void Translate(ITranslator translator)
         /// </summary>
         internal static NodeBuildComplete FactoryForDeserialization(ITranslatorBase translator)
         {
-            NodeBuildComplete packet = new NodeBuildComplete();
+            NodeBuildComplete packet = new();
 
             if (translator.Protocol == ProtocolType.Binary)
             {
@@ -88,8 +88,7 @@ internal static NodeBuildComplete FactoryForDeserialization(ITranslatorBase tran
             {
                 packet.Translate((IJsonTranslator)translator);
             }
-#endif
-       
+#endif     
             return packet;
         }
 
@@ -99,16 +98,17 @@ public void Translate(IJsonTranslator translator)
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
                 var model = new NodeBuildCompleteModel(_prepareForReuse);
-                translator.TranslateToJson(model);
+                translator.Translate(ref model);
             }
-            else // ReadFromStream
+            else
             {
-                var model = translator.TranslateFromJson<NodeBuildCompleteModel>();
-                _prepareForReuse = model.prepareForReuse;
+                NodeBuildCompleteModel model = null;
+                translator.Translate(ref model);
+                _prepareForReuse = model.PrepareForReuse;
             }
         }
 
-        internal record NodeBuildCompleteModel(bool prepareForReuse);
+        internal record NodeBuildCompleteModel(bool PrepareForReuse);
 
 #endif
 
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 2a363529d9e..3af03b5ab98 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -413,7 +413,7 @@ private void PacketPumpProc()
                             );
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
 
-                            // TODO ???
+                            // TODO better way to define net host ???
                             if (handshakeComponents[i].Key == "fileVersionMajor" && handshakeComponents[i].Value == NetTaskHostHandshakeVersion)
                             {
                                 isNetHost = true;
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index e96d2080ee1..a3c7b635280 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
@@ -13,8 +12,8 @@
 using System.Text.Json.Nodes;
 #endif
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using System.Linq;
 
 #nullable disable
 
@@ -429,6 +428,23 @@ public void Translate(ITranslator translator)
             translator.TranslateDictionary(ref _buildProcessEnvironment, StringComparer.OrdinalIgnoreCase);
             translator.TranslateCulture(ref _culture);
             translator.TranslateCulture(ref _uiCulture);
+#if FEATURE_APPDOMAIN
+            byte[] appDomainConfigBytes = null;
+
+            // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+            }
+
+            translator.Translate(ref appDomainConfigBytes);
+
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                _appDomainSetup = new AppDomainSetup();
+                _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
+            }
+#endif
             translator.Translate(ref _lineNumberOfTask);
             translator.Translate(ref _columnNumberOfTask);
             translator.Translate(ref _projectFileOfTask);
@@ -466,59 +482,53 @@ public void Translate(IJsonTranslator translator)
         {
             if (translator.Mode == TranslationDirection.WriteToStream)
             {
-                var model = new
-                {
-                    nodeId = _nodeId,
-                    startupDirectory = _startupDirectory,
-                    buildProcessEnvironment = _buildProcessEnvironment,
-                    culture = _culture?.Name,
-                    uiCulture = _uiCulture?.Name,
-                    lineNumberOfTask = _lineNumberOfTask,
-                    columnNumberOfTask = _columnNumberOfTask,
-                    projectFileOfTask = _projectFileOfTask,
-                    continueOnError = _continueOnError,
-                    taskName = _taskName,
-                    taskLocation = _taskLocation,
-                    isTaskInputLoggingEnabled = _isTaskInputLoggingEnabled,
-                    taskParameters = _taskParameters,
-                    globalParameters = _globalParameters,
-                    warningsAsErrors = _warningsAsErrors,
-                    warningsNotAsErrors = _warningsNotAsErrors,
-                    warningsAsMessages = _warningsAsMessages
-                };
-
-                translator.TranslateToJson(model, _jsonSerializerOptions);
+                var model = new TaskHostConfigurationModel(
+                        _nodeId,
+                        _startupDirectory,
+                        _buildProcessEnvironment,
+                        _culture?.Name,
+                        _uiCulture?.Name,
+                        _lineNumberOfTask,
+                        _columnNumberOfTask,
+                        _projectFileOfTask,
+                        _continueOnError,
+                        _taskName,
+                        _taskLocation,
+                        _isTaskInputLoggingEnabled,
+                        _taskParameters,
+                        _globalParameters,
+                        _warningsAsErrors?.ToArray(),
+                        _warningsNotAsErrors?.ToArray(),
+                        _warningsAsMessages?.ToArray());
+
+                translator.Translate(ref model, s_jsonSerializerOptions);
             }
-            else // ReadFromStream
+            else
             {
-                var model = translator.TranslateFromJson<TaskHostConfigurationModel>(_jsonSerializerOptions);
-
-                _nodeId = model.nodeId;
-                _startupDirectory = model.startupDirectory;
-                _buildProcessEnvironment = model.buildProcessEnvironment;
-                _culture = !string.IsNullOrEmpty(model.culture) ? CultureInfo.GetCultureInfo(model.culture) : null;
-                _uiCulture = !string.IsNullOrEmpty(model.uiCulture) ? CultureInfo.GetCultureInfo(model.uiCulture) : null;
-                _lineNumberOfTask = model.lineNumberOfTask;
-                _columnNumberOfTask = model.columnNumberOfTask;
-                _projectFileOfTask = model.projectFileOfTask;
-                _continueOnError = model.continueOnError;
-                _taskName = model.taskName;
-                _taskLocation = model.taskLocation;
-                _isTaskInputLoggingEnabled = model.isTaskInputLoggingEnabled;
-                _taskParameters = model.taskParameters;
-                _globalParameters = model.globalParameters;
-                _warningsAsErrors = model.warningsAsErrors != null
-                    ? new HashSet<string>(model.warningsAsErrors, StringComparer.OrdinalIgnoreCase)
-                    : null;
-                _warningsNotAsErrors = model.warningsNotAsErrors != null
-                    ? new HashSet<string>(model.warningsNotAsErrors, StringComparer.OrdinalIgnoreCase)
-                    : null;
-                _warningsAsMessages = model.warningsAsMessages != null
-                    ? new HashSet<string>(model.warningsAsMessages, StringComparer.OrdinalIgnoreCase)
-                    : null;
+                TaskHostConfigurationModel model = null;
+                translator.Translate(ref model, s_jsonSerializerOptions);
+
+                _nodeId = model.NodeId;
+                _startupDirectory = model.StartupDirectory;
+                _buildProcessEnvironment = model.BuildProcessEnvironment;
+                _culture = !string.IsNullOrEmpty(model.Culture) ? CultureInfo.GetCultureInfo(model.Culture) : null;
+                _uiCulture = !string.IsNullOrEmpty(model.UiCulture) ? CultureInfo.GetCultureInfo(model.UiCulture) : null;
+                _lineNumberOfTask = model.LineNumberOfTask;
+                _columnNumberOfTask = model.ColumnNumberOfTask;
+                _projectFileOfTask = model.ProjectFileOfTask;
+                _continueOnError = model.ContinueOnError;
+                _taskName = model.TaskName;
+                _taskLocation = model.TaskLocation;
+                _isTaskInputLoggingEnabled = model.IsTaskInputLoggingEnabled;
+                _taskParameters = model.TaskParameters;
+                _globalParameters = model.GlobalParameters;
+                _warningsAsErrors = model.WarningsAsErrors != null ? new HashSet<string>(model.WarningsAsErrors, StringComparer.OrdinalIgnoreCase) : null;
+                _warningsNotAsErrors = model.WarningsNotAsErrors != null ? new HashSet<string>(model.WarningsNotAsErrors, StringComparer.OrdinalIgnoreCase) : null;
+                _warningsAsMessages = model.WarningsAsMessages != null ? new HashSet<string>(model.WarningsAsMessages, StringComparer.OrdinalIgnoreCase) : null;
             }
         }
 #endif
+
         /// <summary>
         /// Factory for deserialization.
         /// </summary>
@@ -540,36 +550,34 @@ internal static INodePacket FactoryForDeserialization(ITranslatorBase translator
 
 #if !TASKHOST
 
-        public static JsonSerializerOptions _jsonSerializerOptions = new JsonSerializerOptions
+        private static readonly JsonSerializerOptions s_jsonSerializerOptions = new()
         {
             PropertyNameCaseInsensitive = true,
             Converters =
                 {
                     new JsonStringEnumConverter(),
-                    new CustomTaskParameterConverter()
+                    new CustomTaskParameterConverter(),
                 },
         };
 
-        private class TaskHostConfigurationModel
-        {
-            public int nodeId { get; set; }
-            public string startupDirectory { get; set; }
-            public Dictionary<string, string> buildProcessEnvironment { get; set; }
-            public string culture { get; set; }
-            public string uiCulture { get; set; }
-            public int lineNumberOfTask { get; set; }
-            public int columnNumberOfTask { get; set; }
-            public string projectFileOfTask { get; set; }
-            public bool continueOnError { get; set; }
-            public string taskName { get; set; }
-            public string taskLocation { get; set; }
-            public bool isTaskInputLoggingEnabled { get; set; }
-            public Dictionary<string, TaskParameter> taskParameters { get; set; }
-            public Dictionary<string, string> globalParameters { get; set; }
-            public string[] warningsAsErrors { get; set; }
-            public string[] warningsNotAsErrors { get; set; }
-            public string[] warningsAsMessages { get; set; }
-        }
+        private record TaskHostConfigurationModel(
+            int NodeId,
+            string StartupDirectory,
+            Dictionary<string, string> BuildProcessEnvironment,
+            string Culture,
+            string UiCulture,
+            int LineNumberOfTask,
+            int ColumnNumberOfTask,
+            string ProjectFileOfTask,
+            bool ContinueOnError,
+            string TaskName,
+            string TaskLocation,
+            bool IsTaskInputLoggingEnabled,
+            Dictionary<string, TaskParameter> TaskParameters,
+            Dictionary<string, string> GlobalParameters,
+            string[] WarningsAsErrors,
+            string[] WarningsNotAsErrors,
+            string[] WarningsAsMessages);
 
         private class CustomTaskParameterConverter : JsonConverter<TaskParameter>
         {
@@ -583,45 +591,22 @@ public override TaskParameter Read(ref Utf8JsonReader reader, Type typeToConvert
                 using JsonDocument doc = JsonDocument.ParseValue(ref reader);
                 var element = doc.RootElement;
 
-                if (element.TryGetProperty("value", out JsonElement valueElement))
+                if (!element.TryGetProperty("value", out JsonElement valueElement))
                 {
-                    object value = null;
-
-                    switch (valueElement.ValueKind)
-                    {
-                        case JsonValueKind.String:
-                            value = valueElement.GetString();
-                            break;
-                        case JsonValueKind.Number:
-                            if (valueElement.TryGetInt32(out int intValue))
-                            {
-                                value = intValue;
-                            }
-                            else if (valueElement.TryGetInt64(out long longValue))
-                            {
-                                value = longValue;
-                            }
-                            else
-                            {
-                                value = valueElement.GetDouble();
-                            }
-                            break;
-                        case JsonValueKind.True:
-                        case JsonValueKind.False:
-                            value = valueElement.GetBoolean();
-                            break;
-                        case JsonValueKind.Array:
-                            value = JsonSerializer.Deserialize<object[]>(valueElement.GetRawText(), options);
-                            break;
-                        case JsonValueKind.Object:
-                            value = JsonSerializer.Deserialize<Dictionary<string, object>>(valueElement.GetRawText(), options);
-                            break;
-                    }
-
-                    return new TaskParameter(value);
+                    throw new JsonException("Invalid TaskParameter format");
                 }
 
-                throw new JsonException("Invalid TaskParameter format");
+                object value = valueElement.ValueKind switch
+                {
+                    JsonValueKind.String => valueElement.GetString(),
+                    JsonValueKind.Number => JsonTranslatorExtensions.GetNumberValue(valueElement),
+                    JsonValueKind.True or JsonValueKind.False => valueElement.GetBoolean(),
+                    JsonValueKind.Array => JsonSerializer.Deserialize<object[]>(valueElement.GetRawText(), options),
+                    JsonValueKind.Object => JsonSerializer.Deserialize<Dictionary<string, object>>(valueElement.GetRawText(), options),
+                    _ => null
+                };
+
+                return new TaskParameter(value);
             }
 
             public override void Write(Utf8JsonWriter writer, TaskParameter value, JsonSerializerOptions options)
@@ -642,103 +627,11 @@ public override void Write(Utf8JsonWriter writer, TaskParameter value, JsonSeria
                 }
                 else
                 {
-                    switch (wrappedValue)
-                    {
-                        case string strValue:
-                            writer.WriteStringValue(strValue);
-                            break;
-                        case int intValue:
-                            writer.WriteNumberValue(intValue);
-                            break;
-                        case long longValue:
-                            writer.WriteNumberValue(longValue);
-                            break;
-                        case double doubleValue:
-                            writer.WriteNumberValue(doubleValue);
-                            break;
-                        case float floatValue:
-                            writer.WriteNumberValue(floatValue);
-                            break;
-                        case decimal decimalValue:
-                            writer.WriteNumberValue(decimalValue);
-                            break;
-                        case bool boolValue:
-                            writer.WriteBooleanValue(boolValue);
-                            break;
-                        case DateTime dateValue:
-                            writer.WriteStringValue(dateValue);
-                            break;
-                        case ITaskItem taskItem:
-                            WriteTaskItem(writer, taskItem);
-                            break;
-                        case ITaskItem[] taskItems:
-                            WriteTaskItemArray(writer, taskItems);
-                            break;
-                        case IEnumerable enumerable:
-                            WriteEnumerable(writer, enumerable, options);
-                            break;
-                        default:
-                            JsonSerializer.Serialize(writer, wrappedValue, wrappedValue.GetType(), options);
-                            break;
-                    }
+                    JsonTranslatorExtensions.WriteValue(writer, wrappedValue, s_jsonSerializerOptions);
                 }
 
                 writer.WriteEndObject();
             }
-
-            private static void WriteTaskItem(Utf8JsonWriter writer, ITaskItem taskItem)
-            {
-                writer.WriteStartObject();
-                writer.WritePropertyName("itemSpec");
-                writer.WriteStringValue(taskItem.ItemSpec);
-
-                if (taskItem.MetadataCount > 0)
-                {
-                    writer.WritePropertyName("metadata");
-                    writer.WriteStartObject();
-
-                    foreach (string name in taskItem.MetadataNames)
-                    {
-                        writer.WritePropertyName(name);
-                        writer.WriteStringValue(taskItem.GetMetadata(name));
-                    }
-
-                    writer.WriteEndObject();
-                }
-
-                writer.WriteEndObject();
-            }
-
-            private static void WriteTaskItemArray(Utf8JsonWriter writer, ITaskItem[] taskItems)
-            {
-                writer.WriteStartArray();
-
-                foreach (var item in taskItems)
-                {
-                    WriteTaskItem(writer, item);
-                }
-
-                writer.WriteEndArray();
-            }
-
-            private static void WriteEnumerable(Utf8JsonWriter writer, IEnumerable enumerable, JsonSerializerOptions options)
-            {
-                writer.WriteStartArray();
-
-                foreach (var item in enumerable)
-                {
-                    if (item == null)
-                    {
-                        writer.WriteNullValue();
-                    }
-                    else
-                    {
-                        JsonSerializer.Serialize(writer, item, item.GetType(), options);
-                    }
-                }
-
-                writer.WriteEndArray();
-            }
         }
 #endif
     }
