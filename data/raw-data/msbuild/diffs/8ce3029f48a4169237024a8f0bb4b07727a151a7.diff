diff --git a/.opt-prof.yml b/.opt-prof.yml
index 35a5a5382d8..47c168210ca 100644
--- a/.opt-prof.yml
+++ b/.opt-prof.yml
@@ -34,6 +34,15 @@ resources:
     name: DartLab.OptProf
     ref: refs/heads/main
 
+parameters:
+  # Whether or not to delete the test machines after the run completes
+  - name: testMachineCleanUpStrategy
+    type: string
+    default: delete
+    values:
+    - delete
+    - stop
+
 stages:
 - template: \templates\stages\visual-studio\single-runsettings.yml@DartLabOptProfTemplates
   parameters:
@@ -45,6 +54,7 @@ stages:
     displayName: OptProf Profiling Workflow
     optOptimizationInputsDropName: $(OptimizationInputsDropName)
     testLabPoolName: VS-Platform # The test lab pool to run your tests in
+    testMachineCleanUpStrategy: ${{parameters.testMachineCleanUpStrategy}}
     testMachineImageName: Windows-10-Enterprise-20H2
     visualStudioSigning: Test
     variables:
@@ -68,7 +78,7 @@ stages:
           $vsBranch = $bootstrapperInfoJson[0].VSBranch
           Write-Host "VSBootstrapperBranch: $vsBranch"
           Set-AzurePipelinesVariable 'VSBootstrapperBranch' $vsBranch
-        }        
+        }
         catch {
           Write-Host $_
           Write-Error "Failed to set VSBootstrapperBranch pipeline variable"
@@ -81,4 +91,4 @@ stages:
         filePath: $(DartLab.Path)\Scripts\VisualStudio\Bootstrapper\Get-BootstrapperURL.ps1
         arguments: -BootstrapperInfoJsonURI '$(Pipeline.Workspace)\ComponentBuildUnderTest\MicroBuildOutputs\BootstrapperInfo.json' -VSBranch '$(VSBootstrapperBranch)' -OutVariableName 'VisualStudio.InstallationUnderTest.BootstrapperURL'
     preDeployAndRunTestsStepList:
-    - download: ComponentBuildUnderTest
\ No newline at end of file
+    - download: ComponentBuildUnderTest
diff --git a/.vsconfig b/.vsconfig
index e31519321f2..a3598fb5a7f 100644
--- a/.vsconfig
+++ b/.vsconfig
@@ -5,7 +5,6 @@
     "Microsoft.Net.Component.4.7.2.SDK",
     "Microsoft.Net.Component.4.TargetingPack",
     "Microsoft.Net.Component.4.7.2.TargetingPack",
-    "Microsoft.Net.Core.Component.SDK.2.1",
     "Microsoft.VisualStudio.Workload.ManagedDesktop",
     "Microsoft.Net.Component.3.5.DeveloperTools",
     "Microsoft.VisualStudio.Workload.NetCoreTools"
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 4573c77f6b9..8ff78b900be 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -233,4 +233,4 @@ jobs:
   parameters:
     platform:
       name: 'Managed'
-      container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7-3e800f1-20190501005343'
+      container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7'
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 910c17f8051..fe3485b6f5c 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -23,12 +23,9 @@ variables:
   - name: SourceBranch
     value: $(IbcSourceBranchName)
   # If we're not on a vs* branch, use main as our optprof collection branch
-  # NOTE: the code is temporarily fixed. For the branches that should use opt-prof from the main branch we should use the latest working Opt-Prof 20220901.6-001 collected from main 20220901.6.
   - ${{ if not(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs')) }}:
-    - name: OptProfDrop
-      value: 'OptimizationData/DotNet-msbuild-Trusted/main/20220901.6/1387996/1'
     - name: SourceBranch
-      value: ''
+      value: main
   # if OptProfDropName is set as a parameter, set OptProfDrop to the parameter and unset SourceBranch
   - ${{ if ne(parameters.OptProfDropName, 'default') }}:
     - name: OptProfDrop
@@ -39,13 +36,15 @@ variables:
     value: .NETCore
   - name: _DotNetValidationArtifactsCategory
     value: .NETCoreValidation
+  - name: Codeql.Enabled
+    value: true
 
 stages:
 - stage: build
   displayName: Build
 
   jobs:
-  - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/vs17.4') }}: # should track next-release's active dev branch
+  - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}: # should track next-release's active dev branch
     - template: /eng/common/templates/job/onelocbuild.yml
       parameters:
         LclSource: lclFilesfromPackage
@@ -70,7 +69,7 @@ stages:
     - name: VisualStudio.MajorVersion
       value: 17
     - name: VisualStudio.ChannelName
-      value: 'int.d17.4'
+      value: 'int.main'
     - name: VisualStudio.DropName
       value: Products/$(System.TeamProject)/$(Build.Repository.Name)/$(Build.SourceBranchName)/$(Build.BuildNumber)
 
@@ -252,7 +251,7 @@ stages:
     parameters:
       platform:
         name: 'Managed'
-        container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7-3e800f1-20190501005343'
+        container: 'mcr.microsoft.com/dotnet-buildtools/prereqs:centos-7'
 
   - template: /eng/common/templates/job/publish-build-assets.yml
     parameters:
diff --git a/MSBuild.sln b/MSBuild.sln
index 75b985cb7be..01e91980f6a 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -6,6 +6,7 @@ MinimumVisualStudioVersion = 17.0.31903.59
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
 	ProjectSection(SolutionItems) = preProject
 		NuGet.Config = NuGet.Config
+		testenvironments.json = testenvironments.json
 		src\Shared\UnitTests\xunit.runner.json = src\Shared\UnitTests\xunit.runner.json
 	EndProjectSection
 EndProject
diff --git a/README.md b/README.md
index 343c9d9c866..28ed1ca7fcf 100644
--- a/README.md
+++ b/README.md
@@ -6,34 +6,6 @@ For more information on MSBuild, see the [MSBuild documentation](https://docs.mi
 
 The [changelog](documentation/Changelog.md) has detailed information about changes made in different releases.
 
-### Build Status
-
-The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 17.4 and a corresponding version of the .NET Core SDK.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=main)
-
-We have forked for MSBuild 17.3 in the branch [`vs17.3`](https://github.com/Microsoft/msbuild/tree/vs17.3). Changes to that branch need special approval.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.3)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.3)
-
-17.2 builds from the branch [`vs17.2`](https://github.com/Microsoft/msbuild/tree/vs17.2). Only high-priority bugfixes will be considered for servicing 17.2.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.2)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.2)
-
-17.0 builds from the branch [`vs17.0`](https://github.com/Microsoft/msbuild/tree/vs17.0). Only high-priority bugfixes will be considered for servicing 17.0.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.0)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.0)
-
-16.11 builds from the branch [`vs16.11`](https://github.com/Microsoft/msbuild/tree/vs16.11). Only high-priority bugfixes will be considered for servicing 16.11.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.11)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.11)
-
-MSBuild 16.9 builds from the branch [`vs16.9`](https://github.com/dotnet/msbuild/tree/vs16.9). Only very-high-priority bugfixes will be considered for servicing 16.9.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.9)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.9)
-
-MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/dotnet/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
-
 ## Building
 
 ### Building MSBuild with Visual Studio 2022 on Windows
@@ -45,14 +17,12 @@ To get started on **Visual Studio 2022**:
 1. [Install Visual Studio 2022](https://www.visualstudio.com/vs/).  Select the following Workloads:
   - .NET desktop development
   - .NET Core cross-platform development
-2. Open a `Developer Command Prompt for VS 2022` prompt.
-3. Clone the source code: `git clone https://github.com/dotnet/msbuild`
+2. Ensure [long path support](https://learn.microsoft.com/windows/win32/fileio/maximum-file-path-limitation?tabs=registry#enable-long-paths-in-windows-10-version-1607-and-later) is enabled at the Windows level.
+3. Open a `Developer Command Prompt for VS 2022` prompt.
+4. Clone the source code: `git clone https://github.com/dotnet/msbuild`
   - You may have to [download Git](https://git-scm.com/downloads) first.
-4. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
-5. Open `MSBuild.sln` or `MSBuild.Dev.slnf` in Visual Studio 2022.
-
-Note: To create a usable MSBuild with your changes, run `.\build.cmd /p:CreateBootstrap=true`.
-To build release, add `-c Release`: `.\build.cmd -c Release /p:CreateBootstrap=true`.
+5. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
+6. Open `MSBuild.sln` or `MSBuild.Dev.slnf` in Visual Studio 2022.
 
 This newly-built MSBuild will be located at `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe`. It may not work for all scenarios, including C++ builds.
 
@@ -73,7 +43,7 @@ Before you contribute, please read through the contributing and developer guides
    - [Full Framework](documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md)
    - [Mono](documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md)
 
-* See our [up for grabs issues](https://github.com/Microsoft/msbuild/issues?q=is%3Aopen+is%3Aissue+label%3Aup-for-grabs) for a list of issues we think are great to onboard new developers.
+* See our [help wanted issues](https://github.com/dotnet/msbuild/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22) for a list of issues we think are great to onboard new developers.
    - **Note:** Please leave a comment asking to be assigned the issue if you want to work on it.
 * See our [label documentation](documentation/wiki/Labels.md) for descriptions of labels we use throughout the repo.
 
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index 9dc2f404fa2..f2e6b6e4753 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -138,13 +138,12 @@ In addition to the above task and target, `.vcxproj` and `.nativeproj` projects
 This means most projects will see an evaluation with no global properties defined, unless set by the user.
 
 ### How To Opt In
-First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:
+First, set the property `EnableDynamicPlatformResolution` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:
 
 ```xml
 <Project>
   <PropertyGroup>
     <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
-    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
   </PropertyGroup>
 </Project>
 ```
diff --git a/documentation/fancylogger/Opt-In-Mechanism.md b/documentation/fancylogger/Opt-In-Mechanism.md
new file mode 100644
index 00000000000..d0df44b69dd
--- /dev/null
+++ b/documentation/fancylogger/Opt-In-Mechanism.md
@@ -0,0 +1,21 @@
+# When should we use FancyLogger
+
+The FancyLogger presents the user with the build's most relevant information at the time, automatically hiding all the information that is no longer relevant (as to prevent huge log outputs). However, many users might find this not very useful (or even counterproductive) such as those using a terminal without proper ANSI support or when redirecting the output to a file. For that reason, the users must be able to turn this feature on/off at will.
+
+# Proposal
+Using the `/fancylogger` or `/flg` command line switches, users are able to opt-in and use the FancyLogger, EXCEPT when:
+- The terminal does not support ANSI codes or color
+    - [ ] Detect if terminal does not support ANSI codes or color
+ - Output is redirected to a file or pipe
+    - [x] Detect if terminal output is redirected
+
+For early development stages, an environment variable `$MSBUILDFANCYLOGGER` should be enabled to prevent accidental access to an unfinished feature. 
+
+In cases where the FancyLogger should not be enabled, the default ConsoleLogger should be used instead.
+
+# Considerations
+## Should FancyLogger be used with other loggers (eg, BinaryLogger, FileLogger, custom loggers)?
+FancyLogger should only replace the current ConsoleLogger for the aforementioned cases. Additionally, other loggers can be used in conjunction. 
+
+## Should output be ignored with the `/noconsolelogger` flag enabled?
+FancyLogger serves as a replacement for ConsoleLogger, so it should behave similarly. When attaching the `/noconsolelogger` flag, it should not output anything.
\ No newline at end of file
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index caaf9d52580..550ec068398 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -9,7 +9,7 @@ Goals:
  * structure (preserves the exact build event args that can later be replayed to reconstruct the exact events and information as if a real build was running). File logs erase structure and are harder to parse (especially for multicore /m builds). Build analyzer tools are conceivable that could benefit from the structure in a binary log. An API is available to load and query binary logs.
  * optionally collect the project files (and all imported targets files) used during the build. This can help analyzing the logs and even view preprocessed source for all projects (with all imported projects inlined).
 
-See http://msbuildlog.com for more information.
+See https://msbuildlog.com/ for more information.
 
 # Creating a binary log during a build
 
@@ -62,7 +62,7 @@ Once you have the `StructuredLogger.dll` on disk you can pass it to MSBuild like
 # Using MSBuild Structured Log Viewer
 
 You can use the MSBuild Structured Log Viewer tool to view `.binlog` files:
-http://msbuildlog.com
+https://msbuildlog.com/
 
 # Collecting binary logs from Visual Studio builds
 
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
index 7df20c12b5f..6410b01cb11 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
@@ -6,17 +6,21 @@ MSBuild can be successfully built on Windows, OS X 10.13, Ubuntu 14.04, and Ubun
 
 `build.cmd -msbuildEngine dotnet`
 
+## Tests
+
+Follow [Running Unit Tests](Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#running-unit-tests) section of the developer guide chapter for .NET Framework
+
 # Unix
 
 ## The easy way
 
-Install the latest .NET Core SDK from http://dot.net/core. That will ensure all prerequisites for our build are met.
+Install the latest .NET SDK from https://dotnet.microsoft.com/download. That will ensure all prerequisites for our build are met.
 
 ## Manually installing required packages for OSX & Ubuntu
 
-[.NET Core prerequisites](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md).
+[.NET Core prerequisites](https://github.com/dotnet/core/blob/main/Documentation/prereqs.md).
 
-* *OpenSSL*: MSBuild uses the .Net CLI during its build process. The CLI requires a recent OpenSSL library available in `/usr/lib`. This can be downloaded using [brew](http://brew.sh/) on OS X (`brew install openssl`) and apt-get (`apt-get install openssl`) on Ubuntu, or [building from source](https://wiki.openssl.org/index.php/Compilation_and_Installation#Mac). If you use a different package manager and see an error that says `Unable to load DLL 'System.Security.Cryptography.Native'`, `dotnet` may be looking in the wrong place for the library.
+* *OpenSSL*: MSBuild uses the .Net CLI during its build process. The CLI requires a recent OpenSSL library available in `/usr/lib`. This can be downloaded using [brew](https://brew.sh/) on OS X (`brew install openssl`) and apt-get (`apt-get install openssl`) on Ubuntu, or [building from source](https://wiki.openssl.org/index.php/Compilation_and_Installation#Mac). If you use a different package manager and see an error that says `Unable to load DLL 'System.Security.Cryptography.Native'`, `dotnet` may be looking in the wrong place for the library.
 
 ## Build
 
@@ -28,21 +32,21 @@ If you encounter errors, see [Something's wrong in my build](Something's-wrong-i
 
 `./build.sh --test`
 
-## Getting .Net Core MSBuild binaries without building the code
+# Getting .Net Core MSBuild binaries without building the code
 
 The best way to get .NET Core MSBuild is by installing the [.NET Core SDK](https://github.com/dotnet/core-sdk), which redistributes us. This will get you the latest released version of MSBuild for .NET Core. After installing it, you can use MSBuild through `dotnet build` or by manual invocation of the `MSBuild.dll` in the dotnet distribution.
 
-## Debugging
+# Debugging
 
-### Wait in Main
+## Wait in Main
 
 Set the environment variable `MSBUILDDEBUGONSTART` to `2`, then attach a debugger to the process manually after it starts.
 
-### Using the repository binaries to perform builds
+## Using the repository binaries to perform builds
 
-To build projects using the MSBuild binaries from the repository, you first need to do a build (command: `build.cmd /p:CreateBootstrap=true`) which produces a bootstrap directory mimicking a Visual Studio (full framework flavor) or dotnet CLI (.net core flavor) installation.
+To build projects using the MSBuild binaries from the repository, you first need to do a build (command: `build.cmd`) which produces a bootstrap directory mimicking a Visual Studio (full framework flavor) or dotnet CLI (.net core flavor) installation.
 
-Now, just point `dotnet ./artifacts/bin/bootstrap/netcoreapp2.1/MSBuild/MSBuild.dll` at a project file.
+Now, just point `dotnet ./artifacts/bin/bootstrap/<TARGET_FRAMEWORK>/MSBuild/MSBuild.dll` at a project file. (Change <TARGET_FRAMEWORK> to current target framework, for example net7.0, net8.0) 
 
 Alternatively, if you want to test the msbuild binaries in a more realistic environment, you can overwrite the dotnet CLI msbuild binaries (found under a path like `~/dotnet/sdk/3.0.100-alpha1-009428/`) with the just-built MSBuild . You might have to kill existing `dotnet` processes before doing this. You can use [`Deploy-MSBuild.ps1 -runtime Core`](../Deploy-MSBuild.md#.NET-(Core)-SDK) to do the copy. Then, (using the previous dotnet example directory) just point `~/dotnet/dotnet build` at a project file.
 
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
index 20c962598de..a71155be41e 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
@@ -4,7 +4,7 @@ These instructions refer to working with the `master` branch.
 
 ## Required Software
 
-**Latest Microsoft Visual Studio 2022**: You can download the Visual Studio Community edition from [https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx](https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx).
+**Latest Microsoft Visual Studio 2022**: You can download the Visual Studio Community edition from [visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/).
 
 All command lines should be executed from a Visual Studio developer command prompt.
 
@@ -25,22 +25,45 @@ To run the unit tests from Visual Studio:
 
 To build MSBuild and run all unit tests from the command line, use `.\build.cmd -test`.
 
+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:
+* Enable [Development Mode](https://learn.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development) on your machine.
+* Or run those tests elevated
+
 To mimic our CI job use `eng\CIBuild.cmd`. Be aware that this command may delete your local NuGet cache.
 
 The CI does two builds. In the second build, it uses the binaries from the first build to build the repository again.
 
+### Unit testing inside virtualized environment 
+
+In case you develop on Windows OS, but need to run/debug tests on other platforms - unit tests can be run and debugged on a local virtualized environment supported by [Visual Studio Remote Testing](https://learn.microsoft.com/en-us/visualstudio/test/remote-testing?view=vs-2022).
+Initial configurations have been added for `WSL` and net 7.0 linux docker via [`testenvironments.json`](../../testenvironments.json).
+Upon opening the Tests Explorer the advanced environments are available in the GUI: 
+
+![TestExplorrerEnvironments](TestExplorerEnvironments.png)
+
+This readme will not discuss definitive list of details for proper setup of the environments instead we defer reader to the following information sources and warn about particular gotchas:
+
+ * WSL runs
+   * Install [WSL](https://learn.microsoft.com/en-us/windows/wsl/about).
+   * Install the [distribution](https://aka.ms/wslstore) of your choice.
+   * [Install .NET Runtime](https://learn.microsoft.com/en-us/dotnet/core/install/linux-ubuntu)
+ * Docker runs
+   * Install [Docker Desktop](https://www.docker.com/products/docker-desktop/)
+   * First run of docker scenario might need elevation ([Test project does not reference any .NET NuGet adapter](https://developercommunity.visualstudio.com/t/test-project-does-not-reference-any-net-nuget-adap/1311698) error)  
+ * Third party test runners might not support this feature. Use [Visual Studio Test Explorer](https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer).
+
 ## Contributing
 
-Please see [Contributing Code](https://github.com/dotnet/msbuild/blob/master/documentation/wiki/Contributing-Code.md) for details on contributing changes back to the code. Please read this carefully and engage with us early to ensure work is not wasted.
+Please see [Contributing Code](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Contributing-Code.md) for details on contributing changes back to the code. Please read this carefully and engage with us early to ensure work is not wasted.
 
 ## Walkthroughs
 
 ### Using the repository binaries to perform builds
 
 To build projects using the MSBuild binaries from the repository, you first need to do a build which produces
-a "bootstrap" directory. The "bootstrap" directory mimics a Visual Studio installation by aquiring additional
+a "bootstrap" directory. The "bootstrap" directory mimics a Visual Studio installation by acquiring additional
 dependencies (Roslyn compilers, NuGet, etc.) from packages or from your local machine (e.g. props/targets
-from Visual Studio). To produce a bootstrap build, run `.\build.cmd /p:CreateBootstrap=true` from the root of your enlistment.
+from Visual Studio). This will happen by default when running `.\build.cmd`. The bootstrap can be disabled by running `.\build.cmd /p:CreateBootstrap=false`.
 
 Now, just point `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe` at a project file.
 
@@ -49,7 +72,7 @@ Now, just point `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe`
 Sometimes it's useful to patch your copy of Visual Studio in order to test or debug your local MSBuild changes from Visual Studio. You can use the [Deploy-MSBuild script](../Deploy-MSBuild.md) for copying your locally built MSBuild binaries over the MSBuild binaries shipping with Visual Studio. Example usage:
 ```
 # bootstrap build
-.\build.cmd /p:CreateBootstrap=true
+.\build.cmd
 
 # copy the bootstrap build output over the MSBuild binaries in Visual Studio
 .\scripts\Deploy-MSBuild.ps1 -destination "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin"
@@ -74,4 +97,4 @@ Like with breakpoints, you can filter which processes emit the logs by setting `
 
 ##### Dumping specific logs:
 - scheduler state: set `MSBUILDDEBUGSCHEDULER` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
-- node communication: set `MSBUILDDEBUGCOMM` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
\ No newline at end of file
+- node communication: set `MSBUILDDEBUGCOMM` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
index 859cf202824..c78f554b272 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
@@ -6,7 +6,7 @@ Mono maintains a fork of msbuild (for now) at `https://github.com/mono/msbuild/`
 
 **Required packages for OSX & Ubuntu**
 
-MSBuild requires a stable version of [Mono](http://www.mono-project.com/download/) to build itself.
+MSBuild requires a stable version of [Mono](https://www.mono-project.com/download/stable/) to build itself.
 
 ## Build process ##
 
@@ -23,9 +23,9 @@ If you encounter errors, see [Something's wrong in my build](Something's-wrong-i
 `./install-mono-prefix.sh </your/mono/prefix>`
 
 ## Getting Mono MSBuild binaries without building the code ##
-The best way to get Mono MSBuild for OSX/macOS is to get the official [Mono package](http://www.mono-project.com/download/#download-mac). After installing it, you can run `msbuild`.
+The best way to get Mono MSBuild for OSX/macOS is to get the official [Mono package](https://www.mono-project.com/download/stable/#download-mac). After installing it, you can run `msbuild`.
 <br/>
-For Linux, you can install mono and msbuild from [here](http://www.mono-project.com/download/#download-lin).
+For Linux, you can install mono and msbuild from [here](https://www.mono-project.com/download/stable/#download-lin).
 
 ## Debugging
 
diff --git a/documentation/wiki/ChangeWaves-Dev.md b/documentation/wiki/ChangeWaves-Dev.md
index bb4f143ac4c..de8d8e11725 100644
--- a/documentation/wiki/ChangeWaves-Dev.md
+++ b/documentation/wiki/ChangeWaves-Dev.md
@@ -51,7 +51,7 @@ Surround your feature with the following:
 
 If you need to condition a Task or Target, use the built in `AreFeaturesEnabled` function.
 ```xml
-<Target Name="SomeRiskyChange" Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))"">
+<Target Name="SomeRiskyChange" Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">
 <!-- Where '17.4' is the change wave assigned to your feature. -->
 ```
 
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index ef4b61564e3..5d3feeccf3a 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -23,6 +23,11 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 
 ## Current Rotation of Change Waves
 
+### 17.6
+- [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
+- [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
+- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
+
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
 - [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
@@ -30,19 +35,6 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
 - [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
 
-### 17.0
-- [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
-- [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
-- [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
-- [Reference assemblies are now no longer placed in the `bin` directory by default](https://github.com/dotnet/msbuild/pull/6560) (reverted [here](https://github.com/dotnet/msbuild/pull/6718) and brought back [here](https://github.com/dotnet/msbuild/pull/7075))
-- [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
-- [Fix deadlock in BuildManager vs LoggingService](https://github.com/dotnet/msbuild/pull/6837)
-- [Optimize diag level for file logger and console logger](https://github.com/dotnet/msbuild/pull/7026)
-- [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
-- [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
-- [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
-- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
-
 ## Change Waves No Longer In Rotation
 ### 16.8
 - [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
@@ -55,3 +47,16 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
 - [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
 - [Optimize glob evaluation](https://github.com/dotnet/msbuild/pull/6151)
+
+### 17.0
+- [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
+- [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
+- [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
+- [Reference assemblies are now no longer placed in the `bin` directory by default](https://github.com/dotnet/msbuild/pull/6560) (reverted [here](https://github.com/dotnet/msbuild/pull/6718) and brought back [here](https://github.com/dotnet/msbuild/pull/7075))
+- [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
+- [Fix deadlock in BuildManager vs LoggingService](https://github.com/dotnet/msbuild/pull/6837)
+- [Optimize diag level for file logger and console logger](https://github.com/dotnet/msbuild/pull/7026)
+- [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
+- [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
+- [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
+- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
\ No newline at end of file
diff --git a/documentation/wiki/Contributing-Code.md b/documentation/wiki/Contributing-Code.md
index 71db1a4961d..690cf797972 100644
--- a/documentation/wiki/Contributing-Code.md
+++ b/documentation/wiki/Contributing-Code.md
@@ -7,7 +7,7 @@ Because our focus right now is on maintaining backwards compatibility, the team
 - Only contributions referencing an approved Issue will be accepted.
 - Pull requests that do not merge easily with the tip of the master branch will be declined. The author will be asked to merge with tip and submit a new pull request.
 - Submissions must meet functional and performance expectations, including scenarios for which the team doesn't yet have open source tests. This means you may be asked to fix and resubmit your pull request against a new open test case if it fails one of these tests.
-- Submissions must follow the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md)
+- Submissions must follow the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
 
 When you are ready to proceed with making a change, get set up to [build](Home.md "See 'Building Testing and Debugging'") the code and familiarize yourself with our workflow and our coding conventions. These two blogs posts on contributing code to open source projects are good too: [Open Source Contribution Etiquette by Miguel de Icaza](https://tirania.org/blog/archive/2010/Dec-31.html) and [Don’t “Push” Your Pull Requests by Ilya Grigorik](https://www.igvita.com/2011/12/19/dont-push-your-pull-requests/).
 
@@ -33,4 +33,4 @@ Please follow these guidelines when creating new issues in the issue tracker:
 - Subscribe to notifications for the created issue in case there are any follow up questions.
 
 ### Coding Conventions
-- Use the coding style outlined in the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md)
+- Use the coding style outlined in the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
diff --git a/documentation/wiki/Contributing-Tasks.md b/documentation/wiki/Contributing-Tasks.md
index 23327755575..c77aaa7cd02 100644
--- a/documentation/wiki/Contributing-Tasks.md
+++ b/documentation/wiki/Contributing-Tasks.md
@@ -13,15 +13,15 @@ The following requirements are in place for contributed tasks:
 3. The task must have unit tests in place to prevent regressions.
 
 ## Developing a new Task
-Review the existing documentation on [Task Writing](https://docs.microsoft.com/en-us/visualstudio/msbuild/task-writing) to learn about the fundamentals.  You can also looking at existing tasks in the [Microsoft.Build.Tasks.Core assembly](https://github.com/dotnet/msbuild/tree/master/src/Tasks) for a great starting point.
+Review the existing documentation on [Task Writing](https://learn.microsoft.com/visualstudio/msbuild/task-writing) to learn about the fundamentals.  You can also looking at existing tasks in the [Microsoft.Build.Tasks.Core assembly](https://github.com/dotnet/msbuild/tree/main/src/Tasks) for a great starting point.
 
 Tasks are generally simple and should not require much effort to develop.  If you find a task becoming very complicated, consider breaking it up into smaller tasks which can be run together in a target.
 
 ## Developing unit tests
-Contributed tasks must have unit tests in place to prove they work and to prevent regressions caused by other code changes.  There are a lot of examples in the [Microsoft.Build.Tasks.UnitTests](https://github.com/dotnet/msbuild/tree/master/src/Tasks.UnitTests) project.  Please provide a reasonable amount of test coverage so ensure the quality of the product.
+Contributed tasks must have unit tests in place to prove they work and to prevent regressions caused by other code changes.  There are a lot of examples in the [Microsoft.Build.Tasks.UnitTests](https://github.com/dotnet/msbuild/tree/main/src/Tasks.UnitTests) project.  Please provide a reasonable amount of test coverage so ensure the quality of the product.
 
 ## Documentation
-You can document the new task in the [visualstudio-docs](https://github.com/MicrosoftDocs/visualstudio-docs/tree/master/docs/msbuild) repository.  This helps users discover the new functionality.  The easiest way is to copy the documentation page for an existing task as a template.
+You can document the new task in the [visualstudio-docs](https://github.com/MicrosoftDocs/visualstudio-docs/tree/main/docs/msbuild) repository.  This helps users discover the new functionality.  The easiest way is to copy the documentation page for an existing task as a template.
 
 ## Ship schedule
 MSBuild ships regularly with Visual Studio.  It also is updated in Preview releases.  Once your contribution is merged, expect it to be available in the next release.
diff --git a/documentation/wiki/Labels.md b/documentation/wiki/Labels.md
index 7f65e10ad9b..0ede6a53483 100644
--- a/documentation/wiki/Labels.md
+++ b/documentation/wiki/Labels.md
@@ -9,4 +9,4 @@ Here's a brief explanation on the labels most often used by the MSBuild team exc
 | `initial-investigation` | A member of the team does a "first pass" investigation. | `needs-triage` is applied and team member and unassigns themselves after the initial investigation is complete. |
 | `stale` | An issue marked with `needs-more-info` is inactive for 7 days. | The issue will be closed after 30 days of inactivity while the `stale` label is applied. |
 | `For consideration` | An issue should get higher prioritization when planning the next set of features. | |
-| `up-for-grabs` | Anyone can take ownership over this issue. | If a contributor wants to take the issue on, they should ask that it be assigned to them BEFORE doing development work.  |
+| `help wanted` | Anyone can take ownership over this issue. | If a contributor wants to take the issue on, they should ask that it be assigned to them BEFORE doing development work.  |
diff --git a/documentation/wiki/Localization.md b/documentation/wiki/Localization.md
index 4bf09bf0123..919d9f4a883 100644
--- a/documentation/wiki/Localization.md
+++ b/documentation/wiki/Localization.md
@@ -6,7 +6,7 @@
 - `Strings.shared.resx` is a shared resource and gets embedded into all msbuild dlls
 - each neutral resource has a directory named `xlf` besides it which contains its localized strings in .xlf format
 - there is one language per xlf
-- the logical name for a resource is: `<Assembly Name>.<Neutral Resx File Name>.resources`. In the ResourceManager this appears as `<Assembly Name>.<Neutral Resx File Name>` (without the trailing `.resources`). For example, the `Microsoft.Build` assembly uses the `Microsoft.Build.Strings.resources` [logical resource name](https://github.com/dotnet/msbuild/blob/master/src/XMakeBuildEngine/Microsoft.Build.csproj#L659) (the resource file is `Strings.resx`), and its corresponding [ResourceManager](https://github.com/dotnet/msbuild/blob/master/src/XMakeBuildEngine/Resources/AssemblyResources.cs#L116) uses `Microsoft.Build.Strings`.
+- the logical name for a resource is: `<Assembly Name>.<Neutral Resx File Name>.resources`. In the ResourceManager this appears as `<Assembly Name>.<Neutral Resx File Name>` (without the trailing `.resources`). For example, the `Microsoft.Build` assembly uses the `Microsoft.Build.Strings.resources` [logical resource name](https://github.com/dotnet/msbuild/blob/cc3db358d34ad4cd1ec0c67e17582d7ca2a15040/src/Build/Microsoft.Build.csproj#L792) (the resource file is `Strings.resx`), and its corresponding [ResourceManager](https://github.com/dotnet/msbuild/blob/518c041f4511a6bc23eb40703b69a94ea46c65fd/src/Build/Resources/AssemblyResources.cs#L118) uses `Microsoft.Build.Strings`.
 
 ## How to edit a resource
 
diff --git a/documentation/wiki/MSBuild-Resources.md b/documentation/wiki/MSBuild-Resources.md
index 4e3f64c3dc2..506e407258d 100644
--- a/documentation/wiki/MSBuild-Resources.md
+++ b/documentation/wiki/MSBuild-Resources.md
@@ -1,21 +1,21 @@
 # General Resources
- * [MSBuild Concepts](https://msdn.microsoft.com/en-us/library/dd637714.aspx)
- * [MSBuild Reserved and Well-Known Properties](https://msdn.microsoft.com/en-us/library/ms164309.aspx)
+ * [MSBuild Concepts](https://learn.microsoft.com/visualstudio/msbuild/msbuild-concepts)
+ * [MSBuild Reserved and Well-Known Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-reserved-and-well-known-properties)
  * [MSBuild Tips & Tricks](MSBuild-Tips-&-Tricks.md)
  * [Target Maps](Target-Maps.md)
 
 # MSBuild Source Code
  * [https://github.com/dotnet/msbuild](https://github.com/dotnet/msbuild)
  * [https://source.dot.net](https://source.dot.net)
- * Use [http://referencesource.microsoft.com](http://referencesource.microsoft.com) or [http://source.roslyn.io](http://source.roslyn.io) to browse Microsoft MSBuild targets. Examples:
-   * search for "[_FindDependencies MSBuildProperty](http://referencesource.microsoft.com/#q=_FindDependencies%20MSBuildProperty)"
-   * find targets [http://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences](http://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences)
+ * Use [referencesource.microsoft.com](https://referencesource.microsoft.com) or [sourceroslyn.io/](https://sourceroslyn.io/) to browse Microsoft MSBuild targets. Examples:
+   * search for "[_FindDependencies MSBuildProperty](https://referencesource.microsoft.com/#q=_FindDependencies%20MSBuildProperty)"
+   * find targets [referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences](https://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences)
 
 # Tools
 **Note:** These are third party tools
- * [MSBuildStructuredLog](http://msbuildlog.com/)
+ * [MSBuildStructuredLog](https://msbuildlog.com/)
    * A log viewer that displays a structured representation of executed targets, tasks, property and item values.
- * [MSBuildExtensionPack](http://www.msbuildextensionpack.com)
+ * [MSBuildExtensionPack](https://github.com/mikefourie-zz/MSBuildExtensionPack) (also via [NuGet](https://www.nuget.org/packages/MSBuild.Extension.Pack))
    * Provides a large collection of MSBuild Tasks, MSBuild Loggers and MSBuild TaskFactories.
  * [MSBuilder](https://github.com/MobileEssentials/MSBuilder)
    * Reusable blocks of MSBuild helpers; MSBuilder's goal is to provide fine-grained nuget packages that can be installed when only a certain MSBuild extension (task, property, target) is needed.
@@ -34,13 +34,13 @@
    * Lets you build Visual Studio solutions and projects as well as any MSBuild file through a context menu without opening Visual Studio.
 
 # Books
- * [Inside the Microsoft Build Engine: Using MSBuild and Team Foundation Build (2nd Edition) by Sayed Hashimi, William Bartholomew](http://www.amazon.com/Inside-Microsoft-Build-Engine-Foundation/dp/0735645248)
- * [MSBuild Trickery: 99 Ways to Bend the Build Engine to Your Will, by Brian Kretzler](http://www.amazon.com/MSBuild-Trickery-Ways-Build-Engine/dp/061550907X)
+ * [Inside the Microsoft Build Engine: Using MSBuild and Team Foundation Build (2nd Edition) by Sayed Hashimi, William Bartholomew](https://www.amazon.com/Inside-Microsoft-Build-Engine-Foundation/dp/0735645248)
+ * [MSBuild Trickery: 99 Ways to Bend the Build Engine to Your Will, by Brian Kretzler](https://www.amazon.com/MSBuild-Trickery-Ways-Build-Engine/dp/061550907X)
 
 # Blogs
- * [https://blogs.msdn.microsoft.com/msbuild](https://blogs.msdn.microsoft.com/msbuild)
- * [Sayed Hashimi's blog http://sedodream.com](http://sedodream.com)
+ * [MSBuild Team Blog](https://learn.microsoft.com/archive/blogs/msbuild/) (archive)
+ * [Sayed Hashimi's blog at sedodream.com](http://sedodream.com)
  * [Mike Fourie's blog https://mikefourie.wordpress.com](https://mikefourie.wordpress.com)
 
 # MSBuild Assemblies
-![MSBuild Assemblies](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/MSBuildAssemblies.png)
+![MSBuild Assemblies](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/MSBuildAssemblies.png)
diff --git a/documentation/wiki/MSBuild-Tips-&-Tricks.md b/documentation/wiki/MSBuild-Tips-&-Tricks.md
index a66255a037e..3a833348b66 100644
--- a/documentation/wiki/MSBuild-Tips-&-Tricks.md
+++ b/documentation/wiki/MSBuild-Tips-&-Tricks.md
@@ -1,5 +1,5 @@
 # MSBuild Command-Line Switches
-See the [MSBuild Command-Line Reference](https://docs.microsoft.com/visualstudio/msbuild/msbuild-command-line-reference) for more information on switches.
+See the [MSBuild Command-Line Reference](https://learn.microsoft.com/visualstudio/msbuild/msbuild-command-line-reference) for more information on switches.
  * `MSBuild.exe -pp:<FILE>`
    * MSBuild preprocessor. Pass /pp to the command line to create a single huge XML project file with all project imports inlined in the correct order. This is useful to investigate the ordering of imports and property and target overrides during evaluation.
    * Example usage: `msbuild MyProject.csproj /pp:inlined.xml`
@@ -13,14 +13,17 @@ See the [MSBuild Command-Line Reference](https://docs.microsoft.com/visualstudio
    * Passes parameters to the file logger. If you want to attach multiple file loggers, you do so by specifying additional parameters in the switches /flp1, /flp2, /flp3, and so on.
 
 # Environment Variables
+
+ * `MSBuildDebugEngine=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
+  * Set this to cause any MSBuild invocation launched within this environment to emit binary logs and additional debugging information to `<DIRECTORY>`. Useful when debugging build or evaluation issues when you can't directly influence the MSBuild invocation, such as in Visual Studio.
  * `MSBUILDTARGETOUTPUTLOGGING=1`
-   * Set this to enable [printing all target outputs to the log](https://blogs.msdn.microsoft.com/msbuild/2010/03/31/displaying-target-output-items-using-the-console-logger).
+   * Set this to enable [printing all target outputs to the log](https://learn.microsoft.com/archive/blogs/msbuild/displaying-target-output-items-using-the-console-logger).
  * `MSBUILDLOGTASKINPUTS=1`
    * Log task inputs (not needed if there are any diagnostic loggers already).
  * `MSBUILDEMITSOLUTION=1`
    * Save the generated .proj file for the .sln that is used to build the solution.
  * `MSBUILDENABLEALLPROPERTYFUNCTIONS=1`
-   * Enable [additional property functions](https://blogs.msdn.microsoft.com/visualstudio/2010/04/02/msbuild-property-functions).
+   * Enable [additional property functions](https://devblogs.microsoft.com/visualstudio/msbuild-property-functions/).
  * `MSBUILDLOGVERBOSERARSEARCHRESULTS=1`
    * In ResolveAssemblyReference task, log verbose search results.
  * `MSBUILDLOGCODETASKFACTORYOUTPUT=1`
@@ -33,7 +36,7 @@ See the [MSBuild Command-Line Reference](https://docs.microsoft.com/visualstudio
    * Launch debugger on build start.
    * Setting the value of 2 allows for manually attaching a debugger to a process ID.
  * `MSBUILDDEBUGSCHEDULER=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
-   * Dumps scheduler state at specified directory
+   * Dumps scheduler state at specified directory (`MSBUILDDEBUGSCHEDULER` is implied by `MSBuildDebugEngine`).
 
 # TreatAsLocalProperty
 If MSBuild.exe is passed properties on the command line, such as `/p:Platform=AnyCPU` then this value overrides whatever assignments you have to that property inside property groups. For instance, `<Platform>x86</Platform>` will be ignored. To make sure your local assignment to properties overrides whatever they pass on the command line, add the following at the top of your MSBuild project file:
@@ -45,7 +48,7 @@ If MSBuild.exe is passed properties on the command line, such as `/p:Platform=An
 This will make sure that your local assignments to the `Platform` property are respected. You can specify multiple properties in `TreatAsLocalProperty` separated by semicolon.
 
 # Visual Studio Background Builds
-Set the `TRACEDESIGNTIME=true` environment variable to output design-time build logs to TEMP: read more here: https://blogs.msdn.microsoft.com/jeremykuhne/2016/06/06/vs-background-builds
+Set the `TRACEDESIGNTIME=true` environment variable to output design-time build logs to TEMP: read more here: https://learn.microsoft.com/archive/blogs/jeremykuhne/vs-background-builds
 
 # Visual Studio Design-time (IntelliSense) builds
 
@@ -56,7 +59,7 @@ Use this command-line to approximate what the design-time build does:
 ```
 
 # Extend all builds (at system-wide level)
-See https://www.simple-talk.com/dotnet/.net-tools/extending-msbuild, "Extending all builds" section. Also read about [MSBuildUserExtensionsPath](http://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,33), [CustomBeforeMicrosoftCommonProps](http://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,68), [CustomBeforeMicrosoftCommonTargets](http://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.targets,71), and CustomAfterMicrosoftCommonProps/CustomAfterMicrosoftCommonTargets.
+See https://www.simple-talk.com/dotnet/.net-tools/extending-msbuild, "Extending all builds" section. Also read about [MSBuildUserExtensionsPath](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,33), [CustomBeforeMicrosoftCommonProps](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,68), [CustomBeforeMicrosoftCommonTargets](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.targets,71), and CustomAfterMicrosoftCommonProps/CustomAfterMicrosoftCommonTargets.
 
 Example:
 Create this file (Custom.props) in `C:\Users\username\AppData\Local\Microsoft\MSBuild\Current\Microsoft.Common.targets\ImportAfter`:
diff --git a/documentation/wiki/Microsoft.Build.Framework.md b/documentation/wiki/Microsoft.Build.Framework.md
index c72abbf4578..658d8d6c57f 100644
--- a/documentation/wiki/Microsoft.Build.Framework.md
+++ b/documentation/wiki/Microsoft.Build.Framework.md
@@ -1,7 +1,7 @@
 ### Microsoft.Build.Framework
 It you have looked carefully, you might notice some odd behavior around this assembly (Microsoft.Build.Framework). We released the source here, but in some cases if you use our `BuildAndCopy.cmd` script, you will reference the one on your machine instead of the one you just built! Here's why.
 
-Microsoft.Build.Framework contains the types and interfaces for extensibility in MSBuild. If you've ever written a custom Task, you might recognize them as ITask, ITaskItem, etc. After you build your Task, let's say targeting `Microsoft.Build.Framework, Version=12.0.0.0, PublicKeyToken=b03f5f7f11d50a3a` (Visual Studio 2013), anyone with MSBuild 12.0 or later can use your Task. In later versions of MSBuild, say version 14.0, we will use a [binding redirect](https://msdn.microsoft.com/en-us/library/eftw1fys(v=vs.110).aspx) to point you to the newer version of Microsoft.Build.Framework. Assuming we did our jobs right with compatibility, your Task should run without ever knowing the difference. The crucial point of detail here is that the public key token for the Framework assembly **did not change** between version. If it does, binding redirection is not allowed.
+Microsoft.Build.Framework contains the types and interfaces for extensibility in MSBuild. If you've ever written a custom Task, you might recognize them as ITask, ITaskItem, etc. After you build your Task, let's say targeting `Microsoft.Build.Framework, Version=12.0.0.0, PublicKeyToken=b03f5f7f11d50a3a` (Visual Studio 2013), anyone with MSBuild 12.0 or later can use your Task. In later versions of MSBuild, say version 14.0, we will use a [binding redirect](https://learn.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/bindingredirect-element) to point you to the newer version of Microsoft.Build.Framework. Assuming we did our jobs right with compatibility, your Task should run without ever knowing the difference. The crucial point of detail here is that the public key token for the Framework assembly **did not change** between version. If it does, binding redirection is not allowed.
 
 ## Option 1 - Project Reference
 By default this is enabled. This means that all MSBuild code will reference Microsoft.Build.Framework as a project reference and therefore will not have the same public key token as the retail version.
@@ -25,7 +25,7 @@ This will set the property for you and create a drop of MSBuild and dependencies
 
 ## Option 3 - Test or Delay Signing
 For the advanced user, another option here is to delay sign this version of MSBuild with our public key. Since that part of the key is public, it's very easy to extract (using `Sn.exe`) and delay sign. You can get more information on that here:
- * [Delay Signing](https://blogs.msdn.microsoft.com/shawnfa/2004/03/17/delay-signing/)
- * [Test Key Signing](http://blogs.msdn.com/b/shawnfa/archive/2005/10/24/484170.aspx)
+ * [Delay Signing](https://learn.microsoft.com/archive/blogs/shawnfa/delay-signing)
+ * [Test Key Signing](https://web.archive.org/web/20101005012428/http://blogs.msdn.com/b/shawnfa/archive/2005/10/24/484170.aspx)
 
 Delay signing is the easiest, but it modifies your system to allow it to load and trust an assembly (Microsoft.Build.Framework) even when it's not signed at all, from any source. The Test Key Signing allows for a much more secure approach (as long as you keep your private key private), but is more complicated to setup. We are providing this as a reference, but please only try this if you: really want to customize Microsoft.Build.Framework and use existing custom Tasks, you feel comfortable with the security implications, and you acknowledge this is all at your own risk.
\ No newline at end of file
diff --git a/documentation/wiki/Rebuilding-when-nothing-changed.md b/documentation/wiki/Rebuilding-when-nothing-changed.md
index 9355b3a21bb..5f9fc83bd52 100644
--- a/documentation/wiki/Rebuilding-when-nothing-changed.md
+++ b/documentation/wiki/Rebuilding-when-nothing-changed.md
@@ -4,11 +4,11 @@ There is a class of problems with build where when you build twice, it still reb
 
 There are multiple tools to investigate and fix broken incrementality. Start with the blog posts below.
 
- * [https://blogs.msdn.microsoft.com/kirillosenkov/2014/08/04/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed/](https://blogs.msdn.microsoft.com/kirillosenkov/2014/08/04/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed/)
- * [https://blogs.msdn.microsoft.com/kirillosenkov/2015/05/12/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs/](https://blogs.msdn.microsoft.com/kirillosenkov/2015/05/12/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs/)
- * [http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/](http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/)
- * [MSDN: How to build incrementally](https://msdn.microsoft.com/en-us/library/ms171483.aspx)
- * [https://docs.microsoft.com/en-us/visualstudio/msbuild/incremental-builds?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/msbuild/incremental-builds?view=vs-2019)
+ * [How to investigate Rebuilding in Visual Studio when nothing has changed](https://learn.microsoft.com/archive/blogs/kirillosenkov/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed)
+ * [MSBuild: unnecessary rebuilds because of generated AssemblyAttributes.cs](https://learn.microsoft.com/archive/blogs/kirillosenkov/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs)
+ * [When Visual Studio keeps rebuilding Projects that have not changed](https://web.archive.org/web/20120321204616/http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/)
+ * [How to build incrementally](https://learn.microsoft.com/visualstudio/msbuild/how-to-build-incrementally)
+ * [Incremental builds](https://learn.microsoft.com/visualstudio/msbuild/incremental-builds)
 
 Strings to search for in the build logs:
  * `Building target "CoreCompile" completely`
@@ -16,4 +16,4 @@ Strings to search for in the build logs:
  * `out-of-date`
  * `missing`
 
-Consider using http://msbuildlog.com to help with searching through the build log.
\ No newline at end of file
+Consider using https://msbuildlog.com to help with searching through the build log.
\ No newline at end of file
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
index 27241f5dbd5..1dff452245f 100644
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ b/documentation/wiki/ResolveAssemblyReference.md
@@ -13,7 +13,7 @@ https://github.com/dotnet/msbuild/blob/a936b97e30679dcea4d99c362efa6f732c9d3587/
 This is where the RAR task is invoked in the targets file.
 
 The source code for RAR is at:
-https://github.com/dotnet/msbuild/blob/master/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+https://github.com/dotnet/msbuild/blob/main/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
 
 ## Inputs
 RAR is very detailed about logging its inputs:
diff --git a/documentation/wiki/Target-Maps.md b/documentation/wiki/Target-Maps.md
index 9f721c90075..722b28119c6 100644
--- a/documentation/wiki/Target-Maps.md
+++ b/documentation/wiki/Target-Maps.md
@@ -1,4 +1,4 @@
-[Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/BuildTargets.png)
-![Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/BuildTargets.png)
-[Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/CompileTargets.png)
-![Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/CompileTargets.png)
\ No newline at end of file
+[Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/BuildTargets.png)
+![Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/BuildTargets.png)
+[Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/CompileTargets.png)
+![Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/CompileTargets.png)
\ No newline at end of file
diff --git a/documentation/wiki/TestExplorerEnvironments.png b/documentation/wiki/TestExplorerEnvironments.png
new file mode 100644
index 00000000000..36a852dda07
Binary files /dev/null and b/documentation/wiki/TestExplorerEnvironments.png differ
diff --git a/documentation/wiki/UnGAC.md b/documentation/wiki/UnGAC.md
index e0d45d729ee..a5b796f3edd 100644
--- a/documentation/wiki/UnGAC.md
+++ b/documentation/wiki/UnGAC.md
@@ -2,7 +2,7 @@
 
 ## What is the GAC?
 
-See the [public documentation](https://docs.microsoft.com/dotnet/framework/app-domains/gac). The GAC is a folder where different installations of VS on the same machine look for assemblies that are commonly used. If an assembly is in the GAC, it will be prioritized over any other assembly.
+See the [public documentation](https://learn.microsoft.com/dotnet/framework/app-domains/gac). The GAC is a folder where different installations of VS on the same machine look for assemblies that are commonly used. If an assembly is in the GAC, it will be prioritized over any other assembly.
 
 The only MSBuild assemblies you may see in the GAC are version 4.8. There is no reason any modern (15.1+) MSBuild assembly should be in the GAC today.
 
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 7b23330685f..5a6b132e78e 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -36,6 +36,7 @@
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGet.'))' == 'True'" />
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Newtonsoft.Json'))' == 'True'" />
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGetSdkResolver'))' == 'True'" />
+        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Microsoft.Extensions.'))' == 'True'" />
 
         <!-- NuGet.targets will be in the ResolvedRuntimeTargets ItemGroup -->
         <_NuGetRuntimeDependencies Include="%(RuntimeTargetsCopyLocalItems.Identity)" Condition="'@(RuntimeTargetsCopyLocalItems->Contains('NuGet.'))' == 'True'" />
@@ -56,6 +57,7 @@
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGet.'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Newtonsoft.Json'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGetSdkResolver'))' == 'True'" />
+        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Extensions.'))' == 'True'" />
     </ItemGroup>
   </Target>
 
@@ -102,6 +104,7 @@
       <FreshlyBuiltBinariesx64 Include="$(X64BinPath)**\*.dll.config" />
 
       <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.Tasks.Core.dll" />
+      <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.dll" />
       <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.exe" />
       <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.tlb" />
       <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.pdb" />
diff --git a/eng/Packages.props b/eng/Packages.props
index 47af99de0a9..bce1a6ee70a 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -18,8 +18,8 @@
     <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
     <PackageReference Update="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
-    <PackageReference Update="System.Net.Http" Version="$(SystemNetHttpVersion)" />
     <PackageReference Update="System.Memory" Version="$(SystemMemoryVersion)" />
+    <PackageReference Update="System.Net.Http" Version="$(SystemNetHttpVersion)" />
     <PackageReference Update="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
     <PackageReference Update="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
diff --git a/eng/SourceBuild.props b/eng/SourceBuild.props
index d0989ae9c8b..0bc1c2b8324 100644
--- a/eng/SourceBuild.props
+++ b/eng/SourceBuild.props
@@ -8,6 +8,8 @@
   <Target Name="ConfigureInnerBuildArgs" BeforeTargets="GetSourceBuildCommandConfiguration">
     <PropertyGroup>
       <InnerBuildArgs>$(InnerBuildArgs) /p:Projects="$(InnerSourceBuildRepoRoot)\MSBuild.SourceBuild.slnf"</InnerBuildArgs>
+      <!-- Disable package validation as source build filters out target frameworks. -->
+      <InnerBuildArgs>$(InnerBuildArgs) /p:EnablePackageValidation=false</InnerBuildArgs>
     </PropertyGroup>
   </Target>
 
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 18d77c37cc3..4a6847306a2 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22531.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22601.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>ebe7fe2c2bd5143690e7150552562c9e44e3b0b5</Sha>
+      <Sha>4255f0e27aa7ca1065962df22b65e4f2b0cd9a4c</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.4.0-preview.3.74">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-preview.3.126">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>d22c6743bf6237c39b98d5d680e06e6c33e97f1c</Sha>
+      <Sha>31f2a1cb6fe3dababe67cdb84e9d6ddb9e3ace04</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.4.0-2.22458.3">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.5.0-2.22608.26">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>85f9dbfea5955ec9cdad3417dba40034da74fb93</Sha>
+      <Sha>716366a3830293571eaaad9b1b2b3929b5216f42</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22531.5">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22601.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>6812704fe5a1baead5da5c1c8bf723752ab728b5</Sha>
+      <Sha>4255f0e27aa7ca1065962df22b65e4f2b0cd9a4c</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 0d75b66612a..b0929ecc980 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,7 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.4.1</VersionPrefix><DotNetFinalVersionKind>release</DotNetFinalVersionKind>
+    <VersionPrefix>17.5.0</VersionPrefix><DotNetFinalVersionKind>release</DotNetFinalVersionKind>
+    <PackageValidationBaselineVersion>17.4.0</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -27,6 +28,11 @@
   <PropertyGroup>
     <SystemCollectionsImmutableVersion>6.0.0</SystemCollectionsImmutableVersion>
     <SystemConfigurationConfigurationManagerVersion>6.0.0</SystemConfigurationConfigurationManagerVersion>
+    <!--
+        Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
+        When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+
+        and follow the guidelines written here (internal-link): https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/1796/How-to-add-a-Known-Issue
+    -->
     <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
     <SystemNetHttpVersion>4.3.4</SystemNetHttpVersion>
     <SystemReflectionMetadataLoadContextVersion>6.0.0</SystemReflectionMetadataLoadContextVersion>
@@ -42,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22531.5</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22601.5</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.4.0-2.22458.3</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.4.0-preview.3.74</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.5.0-2.22608.26</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.5.0-preview.3.126</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>6.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/eng/common/cross/toolchain.cmake b/eng/common/cross/toolchain.cmake
index ec8971eb019..51f30e53dd4 100644
--- a/eng/common/cross/toolchain.cmake
+++ b/eng/common/cross/toolchain.cmake
@@ -1,5 +1,12 @@
 set(CROSS_ROOTFS $ENV{ROOTFS_DIR})
 
+# reset platform variables (e.g. cmake 3.25 sets LINUX=1)
+unset(LINUX)
+unset(FREEBSD)
+unset(ILLUMOS)
+unset(ANDROID)
+unset(TIZEN)
+
 set(TARGET_ARCH_NAME $ENV{TARGET_BUILD_ARCH})
 if(EXISTS ${CROSS_ROOTFS}/bin/freebsd-version)
   set(CMAKE_SYSTEM_NAME FreeBSD)
diff --git a/eng/common/dotnet-install.sh b/eng/common/dotnet-install.sh
index fdfeea66e7d..b09ea669f9c 100755
--- a/eng/common/dotnet-install.sh
+++ b/eng/common/dotnet-install.sh
@@ -52,7 +52,7 @@ done
 # Use uname to determine what the CPU is, see https://en.wikipedia.org/wiki/Uname#Examples
 cpuname=$(uname -m)
 case $cpuname in
-  aarch64)
+  arm64|aarch64)
     buildarch=arm64
     ;;
   amd64|x86_64)
@@ -61,7 +61,7 @@ case $cpuname in
   armv*l)
     buildarch=arm
     ;;
-  i686)
+  i[3-6]86)
     buildarch=x86
     ;;
   *)
diff --git a/eng/common/templates/steps/source-build.yml b/eng/common/templates/steps/source-build.yml
index abb1b2bcda4..b5b3e5aeb3b 100644
--- a/eng/common/templates/steps/source-build.yml
+++ b/eng/common/templates/steps/source-build.yml
@@ -63,6 +63,11 @@ steps:
       targetRidArgs='/p:TargetRid=${{ parameters.platform.targetRID }}'
     fi
 
+    runtimeOsArgs=
+    if [ '${{ parameters.platform.runtimeOS }}' != '' ]; then
+      runtimeOsArgs='/p:RuntimeOS=${{ parameters.platform.runtimeOS }}'
+    fi
+
     publishArgs=
     if [ '${{ parameters.platform.skipPublishValidation }}' != 'true' ]; then
       publishArgs='--publish'
@@ -75,6 +80,7 @@ steps:
       $internalRuntimeDownloadArgs \
       $internalRestoreArgs \
       $targetRidArgs \
+      $runtimeOsArgs \
       /p:SourceBuildNonPortable=${{ parameters.platform.nonPortable }} \
       /p:ArcadeBuildFromSource=true
   displayName: Build
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index dabc0805ea8..dc823e73741 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -16,9 +16,6 @@
     <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
-    <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Version="3.3.3" />
-    <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Condition="'$(MicrosoftCodeAnalysisPublicApiAnalyzersVersion)' != ''" Version="$(MicrosoftCodeAnalysisPublicApiAnalyzersVersion)" />
-
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Condition="'$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)' != ''" Version="$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)" />
 
@@ -28,7 +25,7 @@
     <PackageReference Update="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageReference Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
 
-    <PackageReference Update="Newtonsoft.Json" Version="13.0.1" />
+    <PackageReference Update="Newtonsoft.Json" Version="13.0.2" />
     <PackageReference Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
 
     <PackageReference Update="PdbGit" Version="3.0.41" />
@@ -49,7 +46,7 @@
     <PackageReference Update="System.Security.Cryptography.Pkcs" Version="6.0.1" />
     <PackageReference Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
 
-    <PackageReference Update="System.Security.Cryptography.Xml" Version="6.0.0" />
+    <PackageReference Update="System.Security.Cryptography.Xml" Version="6.0.1" />
     <PackageReference Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
 
     <PackageReference Update="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
diff --git a/global.json b/global.json
index 1213572f5f7..e0b0ecc5d5d 100644
--- a/global.json
+++ b/global.json
@@ -3,14 +3,14 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "7.0.100-rc.1.22431.12",
+    "dotnet": "7.0.101",
     "vs": {
-      "version": "17.2.1"
+      "version": "17.4.1"
     },
-    "xcopy-msbuild": "17.2.1"
+    "xcopy-msbuild": "17.4.1"
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22531.5"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22601.5"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index c6cd195c9d0..bc6e78a22fd 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -787,7 +787,7 @@ public void AddItemWithRemoveToItemGroupOutsideTarget()
 
         public delegate void AddMetadata(ProjectItemElement element);
 
-        public static IEnumerable<object[]> InsertMetadataElemenetAfterSiblingsTestData
+        public static IEnumerable<object[]> InsertMetadataElementAfterSiblingsTestData
         {
             get
             {
@@ -892,7 +892,7 @@ public static IEnumerable<object[]> InsertMetadataElemenetAfterSiblingsTestData
         }
 
         [Theory]
-        [MemberData(nameof(InsertMetadataElemenetAfterSiblingsTestData))]
+        [MemberData(nameof(InsertMetadataElementAfterSiblingsTestData))]
         public void InsertMetadataElementAfterSiblings(AddMetadata addMetadata, int position, string expectedItem)
         {
             Action<ProjectItemElement, ProjectMetadataElement, ProjectMetadataElement> act = (i, c, r) => { i.InsertAfterChild(c, r); };
@@ -900,7 +900,7 @@ public void InsertMetadataElementAfterSiblings(AddMetadata addMetadata, int posi
             AssertMetadataConstruction(addMetadata, position, expectedItem, act);
         }
 
-        public static IEnumerable<object[]> InsertMetadataElemenetBeforeSiblingsTestData
+        public static IEnumerable<object[]> InsertMetadataElementBeforeSiblingsTestData
         {
             get
             {
@@ -934,7 +934,7 @@ public static IEnumerable<object[]> InsertMetadataElemenetBeforeSiblingsTestData
         }
 
         [Theory]
-        [MemberData(nameof(InsertMetadataElemenetBeforeSiblingsTestData))]
+        [MemberData(nameof(InsertMetadataElementBeforeSiblingsTestData))]
         public void InsertMetadataElementBeforeSiblings(AddMetadata addMetadata, int position, string expectedItem)
         {
             Action<ProjectItemElement, ProjectMetadataElement, ProjectMetadataElement> act = (i, c, r) => { i.InsertBeforeChild(c, r); };
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index ba0defea01b..7cbbae8a85a 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -21,6 +21,7 @@
 using ProjectCollection = Microsoft.Build.Evaluation.ProjectCollection;
 using Shouldly;
 using Xunit;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -1853,6 +1854,10 @@ public void ReloadCanOverwriteUnsavedChanges()
         public void ReloadDoesNotLeakCachedXmlDocuments()
         {
             using var env = TestEnvironment.Create();
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
             var testFiles = env.CreateTestProjectWithFiles("", new[] { "build.proj" });
             var projectFile = testFiles.CreatedFiles.First();
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
index eb7d71c2634..585c10071f7 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
@@ -5,9 +5,13 @@
 using System.IO;
 using System.Xml;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Shouldly;
+using Xunit;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-using Xunit;
 
 #nullable disable
 
@@ -339,6 +343,49 @@ public void SetReturns()
             Assert.True(project.HasUnsavedChanges);
         }
 
+        /// <summary>
+        /// Parse invalid property under target
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ReadInvalidPropertyUnderTarget(bool enableNewBehavior)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                if (!enableNewBehavior)
+                {
+                    env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                }
+
+                string projectFile = @"
+                    <Project>
+                        <Target Name='t'>
+                            <test>m</test>
+                        </Target>
+                    </Project>";
+                TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+                ProjectCollection collection = new ProjectCollection();
+                var error = Assert.Throws<InvalidProjectFileException>(() =>
+                {
+                    collection.LoadProject(file.Path).Build().ShouldBeTrue();
+                });
+
+                error.ErrorCode.ShouldMatch("MSB4067");
+                var expectedString = "<PropertyGroup>";
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+                {
+                    error.Message.ShouldMatch(expectedString);
+                }
+                else
+                {
+                    error.Message.ShouldNotMatch(expectedString);
+                }
+            }
+        }
+
         /// <summary>
         /// Helper to get an empty ProjectTargetElement with various attributes and two tasks
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 297eb963b55..a233c0b6477 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -2959,7 +2959,7 @@ public void GetItemProvenanceByItemType()
             };
 
             AssertProvenanceResult(expected, project, "1.foo", "B");
-            AssertProvenanceResult(new ProvenanceResultTupleList(), project, "1.foo", "NotExistant");
+            AssertProvenanceResult(new ProvenanceResultTupleList(), project, "1.foo", "NotExistent");
         }
 
         public static IEnumerable<Object[]> GetItemProvenanceByProjectItemTestData
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 12fbe5d15d9..dc3d33b9784 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -424,7 +424,7 @@ public void TestCache()
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         [Trait("Category", "mono-osx-failing")]
-        public void TestCache2()
+        public void WorksCorrectlyWithCurlyBraces()
         {
             string projectBody = ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
@@ -471,7 +471,8 @@ public void TestCache2()
 
             try
             {
-                string problematicTmpPath = @"C:\Users\}\blabla\temp";
+                // Check if } do not cause it to crash due to usage of String.Format or such on code path
+                string problematicTmpPath = Path.Combine(originalTmp,  "}", "blabla", "temp");
                 Environment.SetEnvironmentVariable("TMP", problematicTmpPath);
                 Environment.SetEnvironmentVariable("TEMP", problematicTmpPath);
 
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index a22156f33f0..4370f5a3dff 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -457,7 +457,7 @@ public void ItemKeepMetadata()
 
 
         [Fact]
-        public void ItemKeepMetadataNotExistant()
+        public void ItemKeepMetadataNotExistent()
         {
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
@@ -468,7 +468,7 @@ public void ItemKeepMetadataNotExistant()
                       <m2>m2</m2>
                       <m3>m3</m3>
                     </i1>
-                    <i2 Include='@(i1)' KeepMetadata='NONEXISTANT' />
+                    <i2 Include='@(i1)' KeepMetadata='NONEXISTENT' />
                 </ItemGroup>
             </Target>
             </Project>");
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index 0226f87e7a7..c802415a697 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -700,6 +700,78 @@ public void VariousPropertiesToMSBuildTask()
             }
         }
 
+
+        /// <summary>
+        /// Include and Exclude items outside and inside targets should result in same behavior on
+        ///  platform specific paths.
+        /// </summary>
+        [Fact]
+        public void ItemsIncludeExcludePathsCombinations()
+        {
+            string projectFile = null;
+
+            try
+            {
+                projectFile = ObjectModelHelpers.CreateTempFileOnDisk(@"
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                      <ItemGroup>
+                        <iout1 Include='a/b.foo' Exclude='a\b.foo' />
+                        <iout2 Include='a\b.foo' Exclude='a/b.foo' />
+                        <iout3 Include='a/b.foo' Exclude='a/b.foo' />
+                        <iout4 Include='a\b.foo' Exclude='a\b.foo' />
+                        <iout5 Include='a/b.foo' Exclude='a\c.foo' />
+                        <iout6 Include='a\b.foo' Exclude='a\c.foo' />
+                      </ItemGroup>
+                      <Target Name='a'>
+                        <ItemGroup>
+                          <iin1 Include='a/b.foo' Exclude='a\b.foo' />
+                          <iin2 Include='a\b.foo' Exclude='a/b.foo' />
+                          <iin3 Include='a/b.foo' Exclude='a/b.foo' />
+                          <iin4 Include='a\b.foo' Exclude='a\b.foo' />
+                          <iin5 Include='a/b.foo' Exclude='a\c.foo' />
+                          <iin6 Include='a\b.foo' Exclude='a\c.foo' />
+                        </ItemGroup>
+                        <Message Text='iout1=[@(iout1)]' Importance='High' />
+                        <Message Text='iout2=[@(iout2)]' Importance='High' />
+                        <Message Text='iout3=[@(iout3)]' Importance='High' />
+                        <Message Text='iout4=[@(iout4)]' Importance='High' />
+                        <Message Text='iout5=[@(iout5)]' Importance='High' />
+                        <Message Text='iout6=[@(iout6)]' Importance='High' />
+
+                        <Message Text='iin1=[@(iin1)]' Importance='High' />
+                        <Message Text='iin2=[@(iin2)]' Importance='High' />
+                        <Message Text='iin3=[@(iin3)]' Importance='High' />
+                        <Message Text='iin4=[@(iin4)]' Importance='High' />
+                        <Message Text='iin5=[@(iin5)]' Importance='High' />
+                        <Message Text='iin6=[@(iin6)]' Importance='High' />
+                      </Target>
+                    </Project>
+                ");
+
+                MockLogger logger = new MockLogger(_testOutput);
+                ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile, logger);
+
+                Console.WriteLine(logger.FullLog);
+
+                logger.AssertLogContains("iout1=[]");
+                logger.AssertLogContains("iout2=[]");
+                logger.AssertLogContains("iout3=[]");
+                logger.AssertLogContains("iout4=[]");
+                logger.AssertLogContains("iout5=[a/b.foo]");
+                logger.AssertLogContains($"iout6=[a{Path.DirectorySeparatorChar}b.foo]");
+                logger.AssertLogContains("iin1=[]");
+                logger.AssertLogContains("iin2=[]");
+                logger.AssertLogContains("iin3=[]");
+                logger.AssertLogContains("iin4=[]");
+                logger.AssertLogContains("iin5=[a/b.foo]");
+                logger.AssertLogContains($"iin6=[a{Path.DirectorySeparatorChar}b.foo]");
+            }
+            finally
+            {
+                File.Delete(projectFile);
+            }
+        }
+
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index bed66bdaaf2..681e0d155c4 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -633,6 +633,11 @@ public ICollection<string> GetWarningsAsMessages(BuildEventContext context)
             throw new NotImplementedException();
         }
 
+        public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
+        {
+            throw new NotImplementedException();
+        }
+
         #endregion
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs b/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs
index b963f89756d..b1c4ccd843f 100644
--- a/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs
+++ b/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs
@@ -21,7 +21,7 @@ public void ClearCaches()
         {
         }
 
-        public Build.BackEnd.SdkResolution.SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public Build.BackEnd.SdkResolution.SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             return null;
         }
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index 164bbd71800..bc8849c9dfe 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -583,6 +583,7 @@ public void ErrorWhenTaskFailsWithoutLoggingErrorEscapeHatch(string failureRespo
             else
             {
                 logger.ErrorCount.ShouldBe(0);
+                logger.AssertLogContains( String.Format(MockLogger.GetString("TaskReturnedFalseButDidNotLogError"), "FailingTask") );
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 87d3efd618d..e63f9733bec 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -48,7 +48,7 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
 
             SdkReference sdk = new SdkReference("notfound", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeFalse();
             result.ShouldNotBeNull();
@@ -61,7 +61,15 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver2 running");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
-            _logger.Errors.Select(i => i.Message).ShouldBe(new [] { "ERROR4", "ERROR1", "ERROR2" });
+
+            // First error is a generic "we failed" message.
+            _logger.Errors[0].Message.ShouldBe(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("FailedToResolveSDK", "notfound", string.Join($"{Environment.NewLine}  ", new[] {
+                "ERROR4",
+                ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", "MockResolverReturnsNull"),
+                "ERROR1",
+                "ERROR2",
+                "notfound"
+            })));
             _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING4", "WARNING2" });
         }
 
@@ -83,7 +91,7 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
                             ))
                 });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("path");
 
@@ -99,7 +107,7 @@ public void AssertResolverThrows()
             SdkReference sdk = new SdkReference("1sdkName", "version1", "minimumVersion");
 
             // When an SDK resolver throws, the expander will catch it and stop the build.
-            SdkResolverException e = Should.Throw<SdkResolverException>(() => SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false));
+            SdkResolverException e = Should.Throw<SdkResolverException>(() => SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true));
             e.Resolver.Name.ShouldBe("MockSdkResolverThrows");
             e.Sdk.Name.ShouldBe("1sdkName");
         }
@@ -114,7 +122,7 @@ public void AssertSecondResolverWithPatternCanResolve()
 
             SdkReference sdk = new SdkReference("2sdkName", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("resolverpathwithresolvablesdkpattern2");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
@@ -131,7 +139,7 @@ public void AssertFirstResolverCanResolve()
 
             SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("resolverpath1");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
@@ -152,7 +160,7 @@ public void AssertFirstResolverWithPatternCantResolveChangeWave17_4()
 
                 SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
 
-                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
                 result.Path.ShouldBe("resolverpath1");
                 _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
@@ -170,7 +178,7 @@ public void AssertFirstResolverWithPatternCanResolve()
 
             SdkReference sdk = new SdkReference("11sdkName", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("resolverpathwithresolvablesdkpattern1");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern1 running");
@@ -186,7 +194,7 @@ public void AssertFirstResolverErrorsSupressedWhenResolved()
             // be logged because MockSdkResolver2 will succeed.
             SdkReference sdk = new SdkReference("2sdkName", "version2", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("resolverpath2");
 
@@ -209,10 +217,10 @@ public void AssertResolverHasStatePreserved()
             SdkReference sdk = new SdkReference("othersdk", "1.0", "minimumVersion");
 
             // First call should not know state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true).Path.ShouldBe("resolverpath");
 
             // Second call should have received state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe(MockSdkResolverWithState.Expected);
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true).Path.ShouldBe(MockSdkResolverWithState.Expected);
         }
 
         [Fact]
@@ -225,10 +233,10 @@ public void AssertResolverStateNotPreserved()
             SdkReference sdk = new SdkReference("othersdk", "1.0", "minimumVersion");
 
             // First call should not know state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true).Path.ShouldBe("resolverpath");
 
             // Second call should have received state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true).Path.ShouldBe("resolverpath");
         }
 
         [Theory]
@@ -269,13 +277,13 @@ public void CachingWrapperShouldWarnWhenMultipleVersionsAreReferenced()
                     resolver
                 });
 
-            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
             resolver.ResolvedCalls.Count.ShouldBe(1);
             result.Path.ShouldBe("path");
             result.Version.ShouldBe("1.0.0");
             _logger.WarningCount.ShouldBe(0);
 
-            result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, new SdkReference("foo", "2.0.0", null), _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, new SdkReference("foo", "2.0.0", null), _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
             resolver.ResolvedCalls.Count.ShouldBe(1);
             result.Path.ShouldBe("path");
             result.Version.ShouldBe("1.0.0");
@@ -351,7 +359,7 @@ public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeTrue();
             result.Path.ShouldBeNull();
@@ -388,7 +396,7 @@ public void SdkResultCanReturnPropertiesAndItems()
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeTrue();
             result.Path.ShouldBe(expectedPath);
@@ -435,7 +443,7 @@ public void SdkResultCanReturnMultiplePaths(bool includePropertiesAndItems)
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeTrue();
 
@@ -481,7 +489,7 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeTrue();
 
@@ -529,7 +537,7 @@ public void CachingWrapperShouldOnlyResolveOnce()
             Parallel.For(
                 0,
                 10,
-                _ => service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false));
+                _ => service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true));
 
             var result = resolver.ResolvedCalls.ShouldHaveSingleItem();
 
@@ -567,7 +575,8 @@ public void InteractiveIsSetForResolverContext()
                 "projectPath",
                 // Pass along interactive and expect it to be received in the SdkResolverContext
                 interactive: true,
-                false);
+                isRunningInVisualStudio: false,
+                failOnUnresolvedSdk: true);
 
             interactive.ShouldBeTrue();
         }
@@ -597,7 +606,8 @@ public void IsRunningInVisualStudioIsSetForResolverContext()
                 "projectPath",
                 false,
                 // Pass along isRunningInVisualStudio and expect it to be received in the SdkResolverContext
-                isRunningInVisualStudio: true);
+                isRunningInVisualStudio: true,
+                failOnUnresolvedSdk: true);
 
             isRunningInVisualStudio.ShouldBeTrue();
         }
@@ -776,7 +786,7 @@ public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverCont
             {
                 if (sdkReference.Name.Equals("notfound"))
                 {
-                    return null;
+                    return factory.IndicateFailure(new string[] { "notfound" });
                 }
                 if (resolverContext.State != null)
                 {
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 94dd2b13b05..c08997ed64c 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -71,7 +71,7 @@ public void TasksAreDiscoveredWhenTaskConditionTrue()
             string projectFileContents = ObjectModelHelpers.CleanupFileContents(
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                       <Target Name='t'>
-                         <NonExistantTask Condition=""'1'=='1'""/>
+                         <NonExistentTask Condition=""'1'=='1'""/>
                          <Message Text='Made it'/>
                       </Target>
                       </Project>");
@@ -97,7 +97,7 @@ public void TasksNotDiscoveredWhenTaskConditionFalse()
             string projectFileContents = ObjectModelHelpers.CleanupFileContents(
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                       <Target Name='t'>
-                         <NonExistantTask Condition=""'1'=='2'""/>
+                         <NonExistentTask Condition=""'1'=='2'""/>
                          <Message Text='Made it'/>
                       </Target>
                       </Project>");
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index ed7e39fdcca..a858d3fb9a4 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -163,10 +163,10 @@ public void ValidateNoParameters_MissingRequired()
         /// Validate that setting a non-existent parameter fails, but does not throw an exception.
         /// </summary>
         [Fact]
-        public void ValidateNonExistantParameter()
+        public void ValidateNonExistentParameter()
         {
             var parameters = new Dictionary<string, (string, ElementLocation)>(StringComparer.OrdinalIgnoreCase);
-            parameters["NonExistantParam"] = ("foo", ElementLocation.Create("foo.proj"));
+            parameters["NonExistentParam"] = ("foo", ElementLocation.Create("foo.proj"));
             Assert.False(_host.SetTaskParameters(parameters));
         }
 
@@ -205,7 +205,7 @@ public void TestSetBoolParamEmptyAttribute()
         [Fact]
         public void TestSetBoolParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("BoolParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("BoolParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -214,7 +214,7 @@ public void TestSetBoolParamEmptyProperty()
         [Fact]
         public void TestSetBoolParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("BoolParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("BoolParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -254,7 +254,7 @@ public void TestSetBoolArrayParamEmptyAttribute()
         [Fact]
         public void TestSetBoolArrayParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("BoolArrayParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("BoolArrayParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -263,7 +263,7 @@ public void TestSetBoolArrayParamEmptyProperty()
         [Fact]
         public void TestSetBoolArrayParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("BoolArrayParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("BoolArrayParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -303,7 +303,7 @@ public void TestSetIntParamEmptyAttribute()
         [Fact]
         public void TestSetIntParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("IntParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("IntParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -312,7 +312,7 @@ public void TestSetIntParamEmptyProperty()
         [Fact]
         public void TestSetIntParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("IntParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("IntParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -357,7 +357,7 @@ public void TestSetIntArrayParamEmptyAttribute()
         [Fact]
         public void TestSetIntArrayParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("IntArrayParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("IntArrayParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -366,7 +366,7 @@ public void TestSetIntArrayParamEmptyProperty()
         [Fact]
         public void TestSetIntArrayParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("IntArrayParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("IntArrayParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -406,7 +406,7 @@ public void TestSetStringParamEmptyAttribute()
         [Fact]
         public void TestSetStringParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("StringParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("StringParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -415,7 +415,7 @@ public void TestSetStringParamEmptyProperty()
         [Fact]
         public void TestSetStringParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("StringParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("StringParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -455,7 +455,7 @@ public void TestSetStringArrayParamEmptyAttribute()
         [Fact]
         public void TestSetStringArrayParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("StringArrayParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("StringArrayParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -464,7 +464,7 @@ public void TestSetStringArrayParamEmptyProperty()
         [Fact]
         public void TestSetStringArrayParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("StringArrayParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("StringArrayParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -516,7 +516,7 @@ public void TestSetItemParamEmptyAttribute()
         [Fact]
         public void TestSetItemParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("ItemParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("ItemParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -525,7 +525,7 @@ public void TestSetItemParamEmptyProperty()
         [Fact]
         public void TestSetItemParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("ItemParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("ItemParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -583,7 +583,7 @@ public void TestSetItemArrayParamEmptyAttribute()
         [Fact]
         public void TestSetItemArrayParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("ItemArrayParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("ItemArrayParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -592,7 +592,7 @@ public void TestSetItemArrayParamEmptyProperty()
         [Fact]
         public void TestSetItemArrayParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("ItemArrayParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("ItemArrayParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -942,7 +942,7 @@ public void TestNonexistantOutput()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
             {
-                Assert.False(_host.GatherTaskOutputs("NonExistantOutput", ElementLocation.Create(".", 1, 1), true, "output"));
+                Assert.False(_host.GatherTaskOutputs("NonExistentOutput", ElementLocation.Create(".", 1, 1), true, "output"));
             }
            );
         }
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 3ff983ec264..addc0b8858e 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -207,6 +207,62 @@ public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
         }
 
+        [Fact]
+        public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
+        {
+            string testFileName = "foobar.txt";
+            string symlinkName = "symlink1.txt";
+            string symlinkLvl2Name = "symlink2.txt";
+            TransientTestFolder testFolder = _env.DefaultTestDirectory.CreateDirectory("TestDir");
+            TransientTestFolder testFolder2 = _env.DefaultTestDirectory.CreateDirectory("TestDir2");
+            TransientTestFile testFile = testFolder.CreateFile(testFileName, string.Join(Environment.NewLine, new[] { "123", "456" }));
+            string symlinkPath = Path.Combine(testFolder2.Path, symlinkName);
+            string symlinkLvl2Path = Path.Combine(testFolder2.Path, symlinkLvl2Name);
+
+            string errorMessage = string.Empty;
+            Assert.True(NativeMethodsShared.MakeSymbolicLink(symlinkPath, testFile.Path, ref errorMessage), errorMessage);
+            Assert.True(NativeMethodsShared.MakeSymbolicLink(symlinkLvl2Path, symlinkPath, ref errorMessage), errorMessage);
+
+            using var buildManager = new BuildManager();
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={_logFile}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+            var testProjectFmt = @"
+<Project>
+    <Target Name=""Build"" Inputs=""{0}"" Outputs=""testtaskoutputfile.txt"">
+        <ReadLinesFromFile
+            File=""{0}"" >
+            <Output
+                TaskParameter=""Lines""
+                ItemName=""ItemsFromFile""/>
+        </ReadLinesFromFile>
+        <WriteLinesToFile File=""testtaskoutputfile.txt"" Lines=""@(ItemsFromFile);abc;def;ghi""/>
+        <CreateItem Include=""testtaskoutputfile.txt"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
+        <CreateItem Include=""{0}"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
+        <CreateItem Include=""{1}"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
+    </Target>
+</Project>";
+            var testProject = string.Format(testProjectFmt, symlinkPath, symlinkLvl2Path);
+            ObjectModelHelpers.BuildProjectExpectSuccess(testProject, binaryLogger);
+            var projectImportsZipPath = Path.ChangeExtension(_logFile, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name));
+        }
+
         [Fact]
         public void BinaryLoggerShouldNotThrowWhenMetadataCannotBeExpanded()
         {
@@ -274,6 +330,46 @@ public void MessagesCanBeLoggedWhenProjectsAreCached()
                 .OverallResult.ShouldBe(BuildResultCode.Success);
         }
 
+        /// <summary>
+        /// Regression test for https://github.com/dotnet/msbuild/issues/7828
+        /// </summary>
+        /// <remarks>
+        /// This test verifies,
+        /// 1. When binary log and verbosity=diagnostic are both set, the equivalent command line is printed.
+        /// 2. When binary log and non-diag verbosity are set, the equivalent command line is NOT printed.
+        /// </remarks>
+        [Fact]
+        public void SuppressCommandOutputForNonDiagVerbosity()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                var contents = @"
+                    <Project>
+                        <Target Name='Target2'>
+                            <Exec Command='echo a'/>
+                        </Target>
+                    </Project>";
+                BinaryLogger logger = new();
+                logger.Parameters = _logFile;
+                TransientTestFolder testFolder = env.CreateFolder(createFolder: true);
+
+                TransientTestFile projectFile1 = env.CreateFile(testFolder, "testProject01.proj", contents);
+                string consoleOutput1 = RunnerUtilities.ExecMSBuild($"{projectFile1.Path} -bl:{logger.Parameters} -verbosity:diag -nologo", out bool success1);
+                success1.ShouldBeTrue();
+                var expected1 = $"-nologo -bl:{logger.Parameters} -verbosity:diag {projectFile1.Path}";
+                consoleOutput1.ShouldContain(expected1);
+
+                foreach (var verbosity in new string[] { "q", "m", "n", "d" })
+                {
+                    TransientTestFile projectFile2 = env.CreateFile(testFolder, $"testProject_{verbosity}.proj", contents);
+                    string consoleOutput2 = RunnerUtilities.ExecMSBuild($"{projectFile2.Path} -bl:{logger.Parameters} -verbosity:{verbosity} -nologo", out bool success2);
+                    success2.ShouldBeTrue();
+                    var expected2 = $"-nologo -bl:{logger.Parameters} -verbosity:{verbosity} {projectFile2.Path}";
+                    consoleOutput2.ShouldNotContain(expected2);
+                }
+            }
+        }
+
         public void Dispose()
         {
             _env.Dispose();
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index dd5d0c8a1fc..177526e3650 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -305,6 +305,14 @@ public void RoundtripBuildMessageEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Fact]
+        public void RoundtripResponseFileUsedEventArgs()
+        {
+            var args = new ResponseFileUsedEventArgs("MSBuild.rsp"); 
+            Roundtrip(args,
+                e => e.ResponseFilePath);
+        }
+         
         [Fact]
         public void RoundtripCriticalBuildMessageEventArgs()
         {
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 51d649107b5..92781d593a1 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -50,6 +50,69 @@ public void Dispose()
             GC.Collect();
         }
 
+        [Theory]
+        [MemberData(nameof(ImportLoadingScenarioTestData))]
+        public void VerifyLoadingImportScenarios(string importParameter, bool shouldSucceed)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder existentDirectory = env.CreateFolder(createFolder: true);
+                TransientTestFile realFile = env.CreateFile(existentDirectory, "realFile.csproj", @"<Project> </Project>");
+                TransientTestFile projectFile = env.CreateFile("project.proj", @$"
+<Project>
+  <Import {importParameter.Replace("realFolder", existentDirectory.Path)} />
+
+  <Target Name=""MyTarget"">
+    <Message Text=""Target working!"" />
+  </Target>
+</Project>
+");
+                bool result = false;
+                try
+                {
+                    Project project = new(projectFile.Path);
+                    MockLogger logger = new();
+                    result = project.Build(logger);
+                }
+                catch (InvalidProjectFileException) { }
+                result.ShouldBe(shouldSucceed);
+            }
+        }
+
+        // Some of these are also tested elsewhere, but this consolidates related tests in one spot.
+        public static IEnumerable<object[]> ImportLoadingScenarioTestData
+        {
+            get
+            {
+                // This first section tests our behavior if a folder does not exist. Conditions and whether there are wildcards should affect whether it fails if it fails to find a file.
+                yield return new object[] { $@"Project=""{Path.Combine("nonexistentDirectory", "projectThatDoesNotExist.csproj")}"" Condition=""Exists('{Path.Combine("nonexistentDirectory", "projectThatDoesNotExist.csproj")}')""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("nonexistentDirectory", "projectThatDoesNotExist.csproj")}"" Condition=""'true'""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("nonexistentDirectory", "projectThatDoesNotExist.csproj")}""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("nonexistentDirectory", "*.*proj")}""", true };
+
+                // This section tests if the folder does exist, but the project does not.
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "projectThatDoesNotExist.csproj")}"" Condition=""Exists('{Path.Combine("realFolder", "projectThatDoesNotExist.csproj")}')""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "projectThatDoesNotExist.csproj")}"" Condition=""'true'""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "projectThatDoesNotExist.csproj")}""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "*.*proj")}""", true };
+
+                // This tests if the folder and the file exist.
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "realFile.csproj")}"" Condition=""Exists('{Path.Combine("realFolder", "realFile.csproj")}')""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "realFile.csproj")}"" Condition=""'true'""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "realFile.csproj")}""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "*.*proj")}""", true };
+
+                // If we fail to find a particular import along one project path, we have a few properties that can be expanded in different ways, including VSToolsPath. In other words,
+                // if the property isn't defined to somewhere that exists, we may still find it in a fallback path. Error behavior in this case is more complicated, as the file may
+                // exist along one search path but not another, in which case we should not error.
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "projectThatDoesNotExist.csproj")}"" Condition=""Exists('{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "projectThatDoesNotExist.csproj")}')""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "projectThatDoesNotExist.csproj")}"" Condition=""'true'""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "projectThatDoesNotExist.csproj")}""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "*.*proj")}""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "*.*proj")}""", true };
+            }
+        }
+
         /// <summary>
         /// Verify Exist condition used in Import or ImportGroup elements will succeed when in-memory project is available inside projectCollection.
         /// </summary>
@@ -1618,7 +1681,7 @@ public void ItemPredecessorToItemViaTransform()
                           <h Include='h1'>
                             <m>1</m>
                           </h>
-                          <i Include=""@(h->'%(identity))"">
+                          <i Include=""@(h->'%(identity)')"">
                             <m>2;%(m)</m>
                           </i>
                         </ItemGroup>
@@ -1628,8 +1691,8 @@ public void ItemPredecessorToItemViaTransform()
 
             ProjectMetadata metadatum = project.GetItems("i").ElementAt(0).GetMetadata("m");
 
-            Assert.Equal("2;", metadatum.EvaluatedValue);
-            Assert.Null(metadatum.Predecessor);
+            Assert.Equal("2;1", metadatum.EvaluatedValue);
+            Assert.Equal("1", metadatum.Predecessor.EvaluatedValue);
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
index df80473fc4e..21b48075b58 100644
--- a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
@@ -276,7 +276,7 @@ public void ImportFromExtensionsPathWithWildCardNothingFound()
                     <Target Name='FromExtn'>
                         <Message Text='Running FromExtn'/>
                     </Target>
-                    <Import Project='$(MSBuildExtensionsPath)\non-existant\*.proj'/>
+                    <Import Project='$(MSBuildExtensionsPath)\non-existent\*.proj'/>
                 </Project>
                 ";
 
diff --git a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
index ab9bfe05035..397e67fbecc 100644
--- a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
@@ -6,6 +6,7 @@
 using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
 
@@ -27,7 +28,13 @@ public class ProjectStringCache_Tests
         [Trait("Category", "netcore-linux-failing")]
         public void ContentIsSameAcrossInstances()
         {
-            string content = ObjectModelHelpers.CleanupFileContents(@"
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                string content = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                         <ItemGroup>
                            Item group content
@@ -35,38 +42,39 @@ Item group content
                     </Project>
                     ");
 
-            string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFile();
 
-            try
-            {
-                File.WriteAllText(path, content);
+                try
+                {
+                    File.WriteAllText(path, content);
 
-                ProjectStringCache cache = new ProjectStringCache();
-                XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                document1.StringCache = cache;
-                document1.Load(path);
+                    ProjectStringCache cache = new ProjectStringCache();
+                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
+                    document1.StringCache = cache;
+                    document1.Load(path);
 
-                XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                document2.StringCache = cache;
-                document2.Load(path);
+                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
+                    document2.StringCache = cache;
+                    document2.Load(path);
 
-                XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
 
-                Assert.Equal(1, nodes1.Count);
-                Assert.Equal(1, nodes2.Count);
+                    Assert.Equal(1, nodes1.Count);
+                    Assert.Equal(1, nodes2.Count);
 
-                XmlNode node1 = nodes1[0].FirstChild;
-                XmlNode node2 = nodes2[0].FirstChild;
+                    XmlNode node1 = nodes1[0].FirstChild;
+                    XmlNode node2 = nodes2[0].FirstChild;
 
-                Assert.NotNull(node1);
-                Assert.NotNull(node2);
-                Assert.NotSame(node1, node2);
-                Assert.Same(node1.Value, node2.Value);
-            }
-            finally
-            {
-                File.Delete(path);
+                    Assert.NotNull(node1);
+                    Assert.NotNull(node2);
+                    Assert.NotSame(node1, node2);
+                    Assert.Same(node1.Value, node2.Value);
+                }
+                finally
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -78,7 +86,13 @@ Item group content
         [Trait("Category", "netcore-linux-failing")]
         public void ContentCanBeModified()
         {
-            string content = ObjectModelHelpers.CleanupFileContents(@"
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                string content = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                         <ItemGroup attr1='attr1value'>
                            Item group content
@@ -86,57 +100,58 @@ Item group content
                     </Project>
                     ");
 
-            string path = FileUtilities.GetTemporaryFile();
-
-            try
-            {
-                File.WriteAllText(path, content);
-                ProjectStringCache cache = new ProjectStringCache();
-                XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
-                document1.StringCache = cache;
-                document1.Load(path);
-
-                XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
-                document2.StringCache = cache;
-                document2.Load(path);
-
-                string outerXml1 = document1.OuterXml;
-                string outerXml2 = document2.OuterXml;
-                Assert.Equal(outerXml1, outerXml2);
-
-                XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
-                XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
-
-                Assert.Equal(1, nodes1.Count);
-                Assert.Equal(1, nodes2.Count);
-
-                XmlNode node1 = nodes1[0];
-                XmlNode node2 = nodes2[0];
-                Assert.NotNull(node1);
-                Assert.NotNull(node2);
-                Assert.NotSame(node1, node2);
-                Assert.Single(node1.Attributes);
-                Assert.Single(node2.Attributes);
-                Assert.Same(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                node2.Attributes[0].Value = "attr1value";
-                Assert.Equal(node1.Attributes[0].Value, node2.Attributes[0].Value);
-                Assert.NotSame(node1.Attributes[0].Value, node2.Attributes[0].Value);
-
-                node1 = nodes1[0].FirstChild;
-                node2 = nodes2[0].FirstChild;
-                Assert.NotSame(node1, node2);
-                Assert.Same(node1.Value, node2.Value);
-
-                XmlText newText = document2.CreateTextNode("New Value");
-                XmlNode parent = node2.ParentNode;
-                parent.ReplaceChild(newText, node2);
-
-                Assert.NotEqual(outerXml1, document2.OuterXml);
-            }
-            finally
-            {
-                File.Delete(path);
+                string path = FileUtilities.GetTemporaryFile();
+
+                try
+                {
+                    File.WriteAllText(path, content);
+                    ProjectStringCache cache = new ProjectStringCache();
+                    XmlDocumentWithLocation document1 = new XmlDocumentWithLocation();
+                    document1.StringCache = cache;
+                    document1.Load(path);
+
+                    XmlDocumentWithLocation document2 = new XmlDocumentWithLocation();
+                    document2.StringCache = cache;
+                    document2.Load(path);
+
+                    string outerXml1 = document1.OuterXml;
+                    string outerXml2 = document2.OuterXml;
+                    Assert.Equal(outerXml1, outerXml2);
+
+                    XmlNodeList nodes1 = document1.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes2 = document2.GetElementsByTagName("ItemGroup");
+
+                    Assert.Equal(1, nodes1.Count);
+                    Assert.Equal(1, nodes2.Count);
+
+                    XmlNode node1 = nodes1[0];
+                    XmlNode node2 = nodes2[0];
+                    Assert.NotNull(node1);
+                    Assert.NotNull(node2);
+                    Assert.NotSame(node1, node2);
+                    Assert.Single(node1.Attributes);
+                    Assert.Single(node2.Attributes);
+                    Assert.Same(node1.Attributes[0].Value, node2.Attributes[0].Value);
+
+                    node2.Attributes[0].Value = "attr1value";
+                    Assert.Equal(node1.Attributes[0].Value, node2.Attributes[0].Value);
+                    Assert.NotSame(node1.Attributes[0].Value, node2.Attributes[0].Value);
+
+                    node1 = nodes1[0].FirstChild;
+                    node2 = nodes2[0].FirstChild;
+                    Assert.NotSame(node1, node2);
+                    Assert.Same(node1.Value, node2.Value);
+
+                    XmlText newText = document2.CreateTextNode("New Value");
+                    XmlNode parent = node2.ParentNode;
+                    parent.ReplaceChild(newText, node2);
+
+                    Assert.NotEqual(outerXml1, document2.OuterXml);
+                }
+                finally
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -149,74 +164,81 @@ Item group content
         [Trait("Category", "netcore-linux-failing")]
         public void RemovingFilesRemovesEntries()
         {
-            string content = ObjectModelHelpers.CleanupFileContents(@"
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                string content = ObjectModelHelpers.CleanupFileContents(@"
                     <Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
                         <ItemGroup>Content</ItemGroup>
                     </Project>
                     ");
 
-            string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFile();
 
-            try
-            {
-                File.WriteAllText(path, content);
+                try
+                {
+                    File.WriteAllText(path, content);
 
-                ProjectStringCache cache = new ProjectStringCache();
-                ProjectCollection collection = new ProjectCollection();
-                int entryCount;
+                    ProjectStringCache cache = new ProjectStringCache();
+                    ProjectCollection collection = new ProjectCollection();
+                    int entryCount;
 
-                ProjectRootElement pre1 = ProjectRootElement.Create(collection);
-                pre1.XmlDocument.StringCache = cache;
-                pre1.FullPath = path;
-                pre1.XmlDocument.Load(path);
+                    ProjectRootElement pre1 = ProjectRootElement.Create(collection);
+                    pre1.XmlDocument.StringCache = cache;
+                    pre1.FullPath = path;
+                    pre1.XmlDocument.Load(path);
 
-                entryCount = cache.Count;
-                Assert.True(entryCount > 0);
+                    entryCount = cache.Count;
+                    Assert.True(entryCount > 0);
 
-                ProjectRootElement pre2 = ProjectRootElement.Create(collection);
-                pre2.XmlDocument.StringCache = cache;
-                pre2.FullPath = path;
-                pre2.XmlDocument.Load(path);
+                    ProjectRootElement pre2 = ProjectRootElement.Create(collection);
+                    pre2.XmlDocument.StringCache = cache;
+                    pre2.FullPath = path;
+                    pre2.XmlDocument.Load(path);
 
-                // Entry count should not have changed
-                Assert.Equal(entryCount, cache.Count);
+                    // Entry count should not have changed
+                    Assert.Equal(entryCount, cache.Count);
 
-                string itemGroupContent = cache.Get("Content");
-                Assert.NotNull(itemGroupContent);
+                    string itemGroupContent = cache.Get("Content");
+                    Assert.NotNull(itemGroupContent);
 
-                XmlNodeList nodes1 = pre1.XmlDocument.GetElementsByTagName("ItemGroup");
-                XmlNodeList nodes2 = pre2.XmlDocument.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes1 = pre1.XmlDocument.GetElementsByTagName("ItemGroup");
+                    XmlNodeList nodes2 = pre2.XmlDocument.GetElementsByTagName("ItemGroup");
 
-                Assert.Equal(1, nodes1.Count);
-                Assert.Equal(1, nodes2.Count);
+                    Assert.Equal(1, nodes1.Count);
+                    Assert.Equal(1, nodes2.Count);
 
-                XmlNode node1 = nodes1[0];
-                XmlNode node2 = nodes2[0];
-                Assert.NotNull(node1);
-                Assert.NotNull(node2);
-                Assert.NotSame(node1, node2);
-                Assert.Same(node1.Value, node2.Value);
+                    XmlNode node1 = nodes1[0];
+                    XmlNode node2 = nodes2[0];
+                    Assert.NotNull(node1);
+                    Assert.NotNull(node2);
+                    Assert.NotSame(node1, node2);
+                    Assert.Same(node1.Value, node2.Value);
 
-                // Now remove one document
-                collection.UnloadProject(pre1);
+                    // Now remove one document
+                    collection.UnloadProject(pre1);
 
-                // We should still be able to get Content
-                itemGroupContent = cache.Get("Content");
-                Assert.NotNull(itemGroupContent);
+                    // We should still be able to get Content
+                    itemGroupContent = cache.Get("Content");
+                    Assert.NotNull(itemGroupContent);
 
-                // Now remove the second document
-                collection.UnloadProject(pre2);
+                    // Now remove the second document
+                    collection.UnloadProject(pre2);
 
-                // Now we should not be able to get Content
-                itemGroupContent = cache.Get("Content");
-                Assert.Null(itemGroupContent);
+                    // Now we should not be able to get Content
+                    itemGroupContent = cache.Get("Content");
+                    Assert.Null(itemGroupContent);
 
-                // And there should be no entries
-                Assert.Equal(0, cache.Count);
-            }
-            finally
-            {
-                File.Delete(path);
+                    // And there should be no entries
+                    Assert.Equal(0, cache.Count);
+                }
+                finally
+                {
+                    File.Delete(path);
+                }
             }
         }
 
@@ -227,32 +249,39 @@ public void RemovingFilesRemovesEntries()
         [Fact]
         public void AddReturnsSameInstanceForSameDocument()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                ProjectStringCache cache = new ProjectStringCache();
 
-            XmlDocument document = new XmlDocument();
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            string return1 = cache.Add(stringToAdd, document);
+                string stringToAdd = "Test1";
+                string return1 = cache.Add(stringToAdd, document);
 
-            // Content of string should be the same.
-            Assert.Equal(1, cache.Count);
-            Assert.Equal(stringToAdd, return1);
+                // Content of string should be the same.
+                Assert.Equal(1, cache.Count);
+                Assert.Equal(stringToAdd, return1);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('1');
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('1');
 
-            string return2 = cache.Add(builder.ToString(), document);
+                string return2 = cache.Add(builder.ToString(), document);
 
-            // Content of string should be the same.            
-            Assert.Equal(builder.ToString(), return2);
+                // Content of string should be the same.            
+                Assert.Equal(builder.ToString(), return2);
 
-            // Returned references should be the same
-            Assert.Same(return1, return2);
+                // Returned references should be the same
+                Assert.Same(return1, return2);
 
-            // Should not have added any new string instances to the cache.
-            Assert.Equal(1, cache.Count);
+                // Should not have added any new string instances to the cache.
+                Assert.Equal(1, cache.Count);
+            }
         }
 
         /// <summary>
@@ -262,32 +291,39 @@ public void AddReturnsSameInstanceForSameDocument()
         [Fact]
         public void AddReturnsSameInstanceForDifferentDocument()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                ProjectStringCache cache = new ProjectStringCache();
 
-            XmlDocument document = new XmlDocument();
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            string return1 = cache.Add(stringToAdd, document);
+                string stringToAdd = "Test1";
+                string return1 = cache.Add(stringToAdd, document);
 
-            // Content of string should be the same.
-            Assert.Equal(stringToAdd, return1);
+                // Content of string should be the same.
+                Assert.Equal(stringToAdd, return1);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('1');
-            XmlDocument document2 = new XmlDocument();
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('1');
+                XmlDocument document2 = new XmlDocument();
 
-            string return2 = cache.Add(builder.ToString(), document2);
+                string return2 = cache.Add(builder.ToString(), document2);
 
-            // Content of string should be the same.
-            Assert.Equal(builder.ToString(), return2);
+                // Content of string should be the same.
+                Assert.Equal(builder.ToString(), return2);
 
-            // Returned references should be the same
-            Assert.Same(return1, return2);
+                // Returned references should be the same
+                Assert.Same(return1, return2);
 
-            // Should not have added any new string instances to the cache.
-            Assert.Equal(1, cache.Count);
+                // Should not have added any new string instances to the cache.
+                Assert.Equal(1, cache.Count);
+            }
         }
 
         /// <summary>
@@ -302,28 +338,35 @@ public void AddReturnsSameInstanceForDifferentDocument()
         [Fact]
         public void RemoveLastInstanceDeallocatesEntry()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            XmlDocument document = new XmlDocument();
+                ProjectStringCache cache = new ProjectStringCache();
+
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            string return1 = cache.Add(stringToAdd, document);
+                string stringToAdd = "Test1";
+                string return1 = cache.Add(stringToAdd, document);
 
-            cache.Clear(document);
+                cache.Clear(document);
 
-            // Should be no instances left.
-            Assert.Equal(0, cache.Count);
+                // Should be no instances left.
+                Assert.Equal(0, cache.Count);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('1');
-            XmlDocument document2 = new XmlDocument();
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('1');
+                XmlDocument document2 = new XmlDocument();
 
-            string return2 = cache.Add(builder.ToString(), document2);
+                string return2 = cache.Add(builder.ToString(), document2);
 
-            // Returned references should NOT be the same
-            Assert.NotSame(return1, return2);
+                // Returned references should NOT be the same
+                Assert.NotSame(return1, return2);
+            }
         }
 
         /// <summary>
@@ -334,36 +377,43 @@ public void RemoveLastInstanceDeallocatesEntry()
         [Fact]
         public void RemoveOneInstance()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            XmlDocument document = new XmlDocument();
+                ProjectStringCache cache = new ProjectStringCache();
+
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            string return1 = cache.Add(stringToAdd, document);
-            Assert.Equal(1, cache.Count);
+                string stringToAdd = "Test1";
+                string return1 = cache.Add(stringToAdd, document);
+                Assert.Equal(1, cache.Count);
 
-            XmlDocument document2 = new XmlDocument();
-            cache.Add(stringToAdd, document2);
-            Assert.Equal(1, cache.Count);
+                XmlDocument document2 = new XmlDocument();
+                cache.Add(stringToAdd, document2);
+                Assert.Equal(1, cache.Count);
 
-            cache.Clear(document2);
+                cache.Clear(document2);
 
-            // Since there is still one document referencing the string, it should remain.
-            Assert.Equal(1, cache.Count);
+                // Since there is still one document referencing the string, it should remain.
+                Assert.Equal(1, cache.Count);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('1');
-            XmlDocument document3 = new XmlDocument();
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('1');
+                XmlDocument document3 = new XmlDocument();
 
-            string return3 = cache.Add(builder.ToString(), document3);
+                string return3 = cache.Add(builder.ToString(), document3);
 
-            // Returned references should be the same
-            Assert.Same(return1, return3);
+                // Returned references should be the same
+                Assert.Same(return1, return3);
 
-            // Still should only be one cached instance.
-            Assert.Equal(1, cache.Count);
+                // Still should only be one cached instance.
+                Assert.Equal(1, cache.Count);
+            }
         }
 
         /// <summary>
@@ -372,31 +422,38 @@ public void RemoveOneInstance()
         [Fact]
         public void DifferentStringsSameDocument()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+
+                ProjectStringCache cache = new ProjectStringCache();
 
-            XmlDocument document = new XmlDocument();
+                XmlDocument document = new XmlDocument();
 
-            string stringToAdd = "Test1";
-            cache.Add(stringToAdd, document);
-            Assert.Equal(1, cache.Count);
+                string stringToAdd = "Test1";
+                cache.Add(stringToAdd, document);
+                Assert.Equal(1, cache.Count);
 
-            stringToAdd = "Test2";
-            string return2 = cache.Add(stringToAdd, document);
+                stringToAdd = "Test2";
+                string return2 = cache.Add(stringToAdd, document);
 
-            // The second string gets its own instance.
-            Assert.Equal(2, cache.Count);
+                // The second string gets its own instance.
+                Assert.Equal(2, cache.Count);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('2');
-            string return3 = cache.Add(builder.ToString(), document);
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('2');
+                string return3 = cache.Add(builder.ToString(), document);
 
-            // The new string should be the same as the other one already in the collection.
-            Assert.Same(return2, return3);
+                // The new string should be the same as the other one already in the collection.
+                Assert.Same(return2, return3);
 
-            // No new instances for string with the same content.
-            Assert.Equal(2, cache.Count);
+                // No new instances for string with the same content.
+                Assert.Equal(2, cache.Count);
+            }
         }
 
         /// <summary>
@@ -405,33 +462,40 @@ public void DifferentStringsSameDocument()
         [Fact]
         public void DifferentStringsDifferentDocuments()
         {
-            ProjectStringCache cache = new ProjectStringCache();
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            XmlDocument document = new XmlDocument();
+                ProjectStringCache cache = new ProjectStringCache();
 
-            string stringToAdd = "Test1";
-            cache.Add(stringToAdd, document);
-            Assert.Equal(1, cache.Count);
+                XmlDocument document = new XmlDocument();
 
-            stringToAdd = "Test2";
-            XmlDocument document2 = new XmlDocument();
-            string return2 = cache.Add(stringToAdd, document2);
+                string stringToAdd = "Test1";
+                cache.Add(stringToAdd, document);
+                Assert.Equal(1, cache.Count);
 
-            // The second string gets its own instance.
-            Assert.Equal(2, cache.Count);
+                stringToAdd = "Test2";
+                XmlDocument document2 = new XmlDocument();
+                string return2 = cache.Add(stringToAdd, document2);
 
-            // Build a new string guaranteed not to be optimized by the compiler into the same instance.
-            StringBuilder builder = new StringBuilder();
-            builder.Append("Test");
-            builder.Append('2');
-            XmlDocument document3 = new XmlDocument();
-            string return3 = cache.Add(builder.ToString(), document3);
+                // The second string gets its own instance.
+                Assert.Equal(2, cache.Count);
 
-            // The new string should be the same as the other one already in the collection.
-            Assert.Same(return2, return3);
+                // Build a new string guaranteed not to be optimized by the compiler into the same instance.
+                StringBuilder builder = new StringBuilder();
+                builder.Append("Test");
+                builder.Append('2');
+                XmlDocument document3 = new XmlDocument();
+                string return3 = cache.Add(builder.ToString(), document3);
 
-            // No new instances for string with the same content.
-            Assert.Equal(2, cache.Count);
+                // The new string should be the same as the other one already in the collection.
+                Assert.Same(return2, return3);
+
+                // No new instances for string with the same content.
+                Assert.Equal(2, cache.Count);
+            }
         }
     }
 }
diff --git a/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs b/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
index 55f05760f31..3bb784def3e 100644
--- a/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
@@ -213,9 +213,9 @@ public static void Equals_Other_ReturnsExpected(object version1Object, object ve
 
         public static IEnumerable<object[]> Parse_Valid_TestData()
         {
-            foreach (var prefix in new[] { "", "v",  "V"})
+            foreach (var prefix in new[] { "", "v", "V", " ", "\t", "\tv" })
             {
-                foreach (var suffix in new[] { "", "-pre", "-pre+metadata", "+metadata"})
+                foreach (var suffix in new[] { "", "-pre", "-pre+metadata", "+metadata", " ", "\n", "-pre \r\n" })
                 {
                     yield return new object[] { $"{prefix}1{suffix}", new SimpleVersion(1) };
                     yield return new object[] { $"{prefix}1.2{suffix}", new SimpleVersion(1, 2) };
@@ -257,7 +257,7 @@ public static IEnumerable<object[]> Parse_Invalid_TestData()
             yield return new object[] { "1.2.2147483648.4", typeof(FormatException) }; // Input contains a value > int.MaxValue
             yield return new object[] { "1.2.3.2147483648", typeof(FormatException) }; // Input contains a value > int.MaxValue
 
-            // System.Version allows whitespace around components, but we don't
+            // System.Version allows whitespace around components, but we only allow it at the beginning and end of the string.
             yield return new object[] { "2  .3.    4.  \t\r\n15  ", typeof(FormatException) };
             yield return new object[] { "   2  .3.    4.  \t\r\n15  ", typeof(FormatException) };
 
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 7c278ef5d8e..2a17d2e97d0 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -775,28 +775,6 @@ public void GetTargetListsNullEntryTargets()
             }
         }
 
-        [Fact]
-        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()
-        {
-            using (var env = TestEnvironment.Create())
-            {
-                var root1 = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: new Dictionary<string, string[]> {{"A", new[] {"B"}}}, defaultTargets: "A").Path;
-                var root2 = CreateProjectFile(env: env, projectNumber: 2, projectReferences: new[] {3}, projectReferenceTargets: new Dictionary<string, string[]> {{"B", new[] {"C"}}, {"X", new[] {"Y"}}}, defaultTargets: "X").Path;
-                CreateProjectFile(env: env, projectNumber: 3);
-
-
-                var projectGraph = new ProjectGraph(new []{root1, root2});
-                projectGraph.ProjectNodes.Count.ShouldBe(3);
-
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);
-
-                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "B" });
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { "C" });
-            }
-        }
-
         [Fact]
         public void GetTargetsListReturnsEmptyTargetsForNodeIfNoTargetsPropagatedToIt()
         {
@@ -1299,6 +1277,19 @@ public void GetTargetsListProjectReferenceTargetsOrDefaultComplexPropagation()
             }
         }
 
+        [Fact]
+        public void ReferencedMultitargetingEntryPointNodeTargetListContainsDefaultTarget()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                TransientTestFile entryProject1 = CreateProjectFile(env, 1, projectReferences: new[] { 2 }, defaultTargets: "A", extraContent: ProjectReferenceTargetsWithMultitargeting);
+                TransientTestFile entryProject2 = CreateProjectFile(env, 2, defaultTargets: "A", extraContent: OuterBuildSpecificationWithProjectReferenceTargets);
+                var graph = new ProjectGraph(new HashSet<string> { entryProject1.Path, entryProject2.Path });
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(null);
+                targetLists[key: GetOuterBuild(graph, 2)].ShouldBe(expected: OuterBuildTargets.Prepend("A"));
+            }
+        }
+
         public static IEnumerable<object[]> Graphs
         {
             get
diff --git a/src/Build.UnitTests/Parser_Tests.cs b/src/Build.UnitTests/Parser_Tests.cs
index bc7efd3b6ef..28691332f75 100644
--- a/src/Build.UnitTests/Parser_Tests.cs
+++ b/src/Build.UnitTests/Parser_Tests.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-
+using System.Linq;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
 using Xunit;
@@ -215,16 +215,16 @@ public void ItemFuncParseTest()
             Console.WriteLine("ItemFuncParseTest()");
 
             Parser p = new Parser();
-            GenericExpressionNode tree = p.Parse("@(item->foo('ab'))", 
+            GenericExpressionNode tree = p.Parse("@(item->foo('ab'))",
                 ParserOptions.AllowProperties | ParserOptions.AllowItemLists, _elementLocation);
             Assert.IsType<StringExpressionNode>(tree);
             Assert.Equal("@(item->foo('ab'))", tree.GetUnexpandedValue(null));
 
-            tree = p.Parse("!@(item->foo())", 
+            tree = p.Parse("!@(item->foo())",
                 ParserOptions.AllowProperties | ParserOptions.AllowItemLists, _elementLocation);
             Assert.IsType<NotExpressionNode>(tree);
 
-            tree = p.Parse("(@(item->foo('ab')) and @(item->foo('bc')))", 
+            tree = p.Parse("(@(item->foo('ab')) and @(item->foo('bc')))",
                 ParserOptions.AllowProperties | ParserOptions.AllowItemLists, _elementLocation);
             Assert.IsType<AndExpressionNode>(tree);
         }
@@ -527,5 +527,73 @@ public void VerifyNoWarningForOrder()
             // Make sure the log contains the correct strings.
             Assert.DoesNotContain("MSB4130:", ml.FullLog); // "No need to warn for this expression - ($(a) == 1 or $(b) == 2) and $(c) == 3."
         }
+
+        // see https://github.com/dotnet/msbuild/issues/5436
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void SupportItemDefinationGroupInWhenOtherwise(bool context)
+        {
+            var projectContent = $@"
+                <Project ToolsVersion= `msbuilddefaulttoolsversion` xmlns= `msbuildnamespace`>
+                    <Choose>
+                        <When Condition= `{context}`>
+                            <PropertyGroup>
+                                <Foo>bar</Foo>
+                            </PropertyGroup>
+                            <ItemGroup>
+                                <A Include= `$(Foo)`>
+                                    <n>n1</n>
+                                </A>
+                            </ItemGroup>
+                            <ItemDefinitionGroup>
+                                <A>
+                                    <m>m1</m>
+                                    <n>n2</n>
+                                </A>
+                            </ItemDefinitionGroup>
+                        </When>
+                        <Otherwise>
+                            <PropertyGroup>
+                                <Foo>bar</Foo>
+                            </PropertyGroup>
+                            <ItemGroup>
+                                <A Include= `$(Foo)`>
+                                    <n>n1</n>
+                                </A>
+                            </ItemGroup>
+                            <ItemDefinitionGroup>
+                                <A>
+                                    <m>m2</m>
+                                    <n>n2</n>
+                                </A>
+                            </ItemDefinitionGroup>
+                        </Otherwise>
+                    </Choose>
+                </Project>
+                ".Cleanup();
+
+
+            var project = ObjectModelHelpers.CreateInMemoryProject(projectContent);
+
+            var projectItem = project.GetItems("A").FirstOrDefault();
+            Assert.Equal("bar", projectItem.EvaluatedInclude);
+
+            var metadatam = projectItem.GetMetadata("m");
+            if (context)
+            {
+                // Go to when 
+                Assert.Equal("m1", metadatam.EvaluatedValue);
+            }
+            else
+            {
+                // Go to Otherwise
+                Assert.Equal("m2", metadatam.EvaluatedValue);
+            }
+
+            var metadatan = projectItem.GetMetadata("n");
+            Assert.Equal("n1", metadatan.EvaluatedValue);
+            Assert.Equal("n2", metadatan.Predecessor.EvaluatedValue);
+        }
     }
 }
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 56126bfbffa..405f2716d21 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -1035,7 +1035,7 @@ public void MultiplePlugins()
 ");
             var mockCache = new InstanceMockCache();
 
-            var buildParameters =  new BuildParameters
+            var buildParameters = new BuildParameters
             {
                 ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache),
             };
@@ -1047,7 +1047,7 @@ public void MultiplePlugins()
                 logger = buildSession.Logger;
                 graphResult = buildSession.BuildGraph(graph);
             }
-            
+
             graphResult.ShouldHaveSucceeded();
         }
 
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index a188f318b64..12a3d83376e 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -251,6 +251,9 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private DateTime _instantiationTimeUtc;
 
+        /// <summary>
+        /// Messages to be logged
+        /// </summary>
         private IEnumerable<DeferredBuildMessage> _deferredBuildMessages;
 
         private ProjectCacheService _projectCacheService;
@@ -394,10 +397,20 @@ public readonly struct DeferredBuildMessage
 
             public string Text { get; }
 
+            public string FilePath { get; }
+
             public DeferredBuildMessage(string text, MessageImportance importance)
             {
                 Importance = importance;
                 Text = text;
+                FilePath = null;
+            }
+
+            public DeferredBuildMessage(string text, MessageImportance importance, string filePath)
+            {
+                Importance = importance;
+                Text = text;
+                FilePath = filePath;
             }
         }
 
@@ -527,6 +540,7 @@ public void BeginBuild(BuildParameters parameters)
 
                 var loggingService = InitializeLoggingService();
 
+                // Log deferred messages and response files
                 LogDeferredMessages(loggingService, _deferredBuildMessages);
 
                 InitializeCaches();
@@ -912,10 +926,7 @@ public void EndBuild()
                 // but the top level exception handler there should catch everything and have forwarded it to the
                 // OnThreadException method in this class already.
                 _workQueue.Complete();
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-                {
-                    _workQueue.Completion.Wait();
-                }
+                _workQueue.Completion.Wait();
 
                 Task projectCacheDispose = _projectCacheService.DisposeAsync().AsTask();
 
@@ -965,10 +976,10 @@ public void EndBuild()
 
                 if (e is AggregateException ae && ae.InnerExceptions.Count == 1)
                 {
-                    e = ae.InnerExceptions.First();
+                    ExceptionDispatchInfo.Capture(ae.InnerExceptions[0]).Throw();
                 }
 
-                throw e;
+                throw;
             }
             finally
             {
@@ -1854,8 +1865,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
 
             if (submission.BuildRequestData.GraphBuildOptions.Build)
             {
-                // Kick off project cache initialization frontloading
-                Task.Run(() => _projectCacheService.InitializePluginsForGraph(projectGraph, _executionCancellationTokenSource.Token));
+                _projectCacheService.InitializePluginsForGraph(projectGraph, _executionCancellationTokenSource.Token);
 
                 var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
@@ -2746,14 +2756,7 @@ private void OnThreadException(Exception e)
         /// </summary>
         private void OnLoggingThreadException(Exception e)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                _workQueue.Post(() => OnThreadException(e));
-            }
-            else
-            {
-                OnThreadException(e);
-            }
+            _workQueue.Post(() => OnThreadException(e));
         }
 
         /// <summary>
@@ -2761,16 +2764,7 @@ private void OnLoggingThreadException(Exception e)
         /// </summary>
         private void OnProjectFinished(object sender, ProjectFinishedEventArgs e)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                _workQueue.Post(() => OnProjectFinishedBody(e));
-            }
-            else
-            {
-                OnProjectFinishedBody(e);
-            }
-
-            void OnProjectFinishedBody(ProjectFinishedEventArgs e)
+            _workQueue.Post(() =>
             {
                 lock (_syncLock)
                 {
@@ -2787,7 +2781,7 @@ void OnProjectFinishedBody(ProjectFinishedEventArgs e)
                         }
                     }
                 }
-            }
+            });
         }
 
         /// <summary>
@@ -2795,16 +2789,7 @@ void OnProjectFinishedBody(ProjectFinishedEventArgs e)
         /// </summary>
         private void OnProjectStarted(object sender, ProjectStartedEventArgs e)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                _workQueue.Post(() => OnProjectStartedBody(e));
-            }
-            else
-            {
-                OnProjectStartedBody(e);
-            }
-
-            void OnProjectStartedBody(ProjectStartedEventArgs e)
+            _workQueue.Post(() =>
             {
                 lock (_syncLock)
                 {
@@ -2813,7 +2798,7 @@ void OnProjectStartedBody(ProjectStartedEventArgs e)
                         _projectStartedEvents[e.BuildEventContext.SubmissionId] = e;
                     }
                 }
-            }
+            });
         }
 
         /// <summary>
@@ -2895,6 +2880,12 @@ private static void LogDeferredMessages(ILoggingService loggingService, IEnumera
             foreach (var message in deferredBuildMessages)
             {
                 loggingService.LogCommentFromText(BuildEventContext.Invalid, message.Importance, message.Text);
+
+                // If message includes a file path, include that file
+                if (message.FilePath is not null)
+                {
+                    loggingService.LogIncludeFile(BuildEventContext.Invalid, message.FilePath);
+                }
             }
         }
 
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index fca7476b2d5..5bc3111c107 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -630,8 +630,16 @@ public bool ShutdownInProcNodeOnBuildFinish
 
         /// <summary>
         /// Gets the startup directory.
+        /// It is current directory from which MSBuild command line was recently invoked.
+        /// It is communicated to working nodes as part of NodeConfiguration deserialization once the node manager acquires a particular node.
+        /// This deserialization assign this value to static backing field making it accessible from rest of build thread.
+        /// In MSBuild server node, this value is set once <see cref="ServerNodeBuildCommand"></see> is received.
         /// </summary>
-        internal static string StartupDirectory => s_startupDirectory;
+        internal static string StartupDirectory
+        {
+            get { return s_startupDirectory; }
+            set { s_startupDirectory = value; }
+        }
 
         /// <summary>
         /// Indicates whether the build plan is enabled or not.
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
index 523cb72e62d..262b3eedd79 100644
--- a/src/Build/BackEnd/Client/MSBuildClient.cs
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -8,7 +8,6 @@
 using System.Globalization;
 using System.IO;
 using System.IO.Pipes;
-using System.Linq;
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Client;
@@ -165,33 +164,46 @@ public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
 #endif
 
             CommunicationsUtilities.Trace("Executing build with command line '{0}'", descriptiveCommandLine);
-            bool serverIsAlreadyRunning = ServerIsRunning();
-            if (KnownTelemetry.BuildTelemetry != null)
-            {
-                KnownTelemetry.BuildTelemetry.InitialServerState = serverIsAlreadyRunning ? "hot" : "cold";
-            }
-            if (!serverIsAlreadyRunning)
+
+            try
             {
-                CommunicationsUtilities.Trace("Server was not running. Starting server now.");
-                if (!TryLaunchServer())
+                bool serverIsAlreadyRunning = ServerIsRunning();
+                if (KnownTelemetry.BuildTelemetry != null)
+                {
+                    KnownTelemetry.BuildTelemetry.InitialServerState = serverIsAlreadyRunning ? "hot" : "cold";
+                }
+                if (!serverIsAlreadyRunning)
                 {
-                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;
+                    CommunicationsUtilities.Trace("Server was not running. Starting server now.");
+                    if (!TryLaunchServer())
+                    {
+                        _exitResult.MSBuildClientExitType = (_exitResult.MSBuildClientExitType == MSBuildClientExitType.Success) ? MSBuildClientExitType.LaunchError : _exitResult.MSBuildClientExitType;
+                        return _exitResult;
+                    }
+                }
+
+                // Check that server is not busy.
+                bool serverWasBusy = ServerWasBusy();
+                if (serverWasBusy)
+                {
+                    CommunicationsUtilities.Trace("Server is busy, falling back to former behavior.");
+                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;
                     return _exitResult;
                 }
-            }
 
-            // Check that server is not busy.
-            bool serverWasBusy = ServerWasBusy();
-            if (serverWasBusy)
-            {
-                CommunicationsUtilities.Trace("Server is busy, falling back to former behavior.");
-                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;
-                return _exitResult;
+                // Connect to server.
+                if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))
+                {
+                    return _exitResult;
+                }
             }
-
-            // Connect to server.
-            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))
+            catch (IOException ex) when (ex is not PathTooLongException)
             {
+                // For unknown root cause, Mutex.TryOpenExisting can sometimes throw 'Connection timed out' exception preventing to obtain the build server state through it (Running or not, Busy or not).
+                // See: https://github.com/dotnet/msbuild/issues/7993
+                CommunicationsUtilities.Trace("Failed to obtain the current build server state: {0}", ex);
+                CommunicationsUtilities.Trace("HResult: {0}.", ex.HResult);
+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.UnknownServerState;
                 return _exitResult;
             }
 
@@ -364,8 +376,7 @@ private void ConfigureAndQueryConsoleProperties()
                     if (NativeMethodsShared.GetConsoleMode(stdOut, out uint consoleMode))
                     {
                         bool success;
-                        if ((consoleMode & NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING) == NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING &&
-                            (consoleMode & NativeMethodsShared.DISABLE_NEWLINE_AUTO_RETURN) == NativeMethodsShared.DISABLE_NEWLINE_AUTO_RETURN)
+                        if ((consoleMode & NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING) == NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING)
                         {
                             // Console is already in required state
                             success = true;
@@ -373,7 +384,7 @@ private void ConfigureAndQueryConsoleProperties()
                         else
                         {
                             _originalConsoleMode = consoleMode;
-                            consoleMode |= NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING | NativeMethodsShared.DISABLE_NEWLINE_AUTO_RETURN;
+                            consoleMode |= NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING;
                             success = NativeMethodsShared.SetConsoleMode(stdOut, consoleMode);
                         }
 
@@ -465,10 +476,12 @@ private bool TrySendPacket(Func<INodePacket> packetResolver)
         private bool TryLaunchServer()
         {
             string serverLaunchMutexName = $@"Global\msbuild-server-launch-{_handshake.ComputeHash()}";
+
             try
             {
                 // For unknown root cause, opening mutex can sometimes throw 'Connection timed out' exception. See: https://github.com/dotnet/msbuild/issues/7993
                 using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);
+
                 if (!mutexCreatedNew)
                 {
                     // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.
@@ -476,12 +489,21 @@ private bool TryLaunchServer()
                     _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;
                     return false;
                 }
+            }
+            catch (IOException ex) when (ex is not PathTooLongException)
+            {
+                CommunicationsUtilities.Trace("Failed to obtain the current build server state: {0}",  ex);
+                CommunicationsUtilities.Trace("HResult: {0}.", ex.HResult);
+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.UnknownServerState;
+                return false;
+            }
 
+            try
+            {
                 string[] msBuildServerOptions = new string[] {
                     "/nologo",
                     "/nodemode:8"
                 };
-
                 NodeLauncher nodeLauncher = new NodeLauncher();
                 CommunicationsUtilities.Trace("Starting Server...");
                 Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions));
diff --git a/src/Build/BackEnd/Client/MSBuildClientExitType.cs b/src/Build/BackEnd/Client/MSBuildClientExitType.cs
index e9916bd5414..9ac0d49652a 100644
--- a/src/Build/BackEnd/Client/MSBuildClientExitType.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientExitType.cs
@@ -24,6 +24,14 @@ public enum MSBuildClientExitType
         /// The build stopped unexpectedly, for example,
         /// because a named pipe between the server and the client was unexpectedly closed.
         /// </summary>
-        Unexpected
+        Unexpected,
+        /// <summary>
+        /// The client is not able to identify the server state.
+        /// </summary>
+        /// <remarks>
+        /// This may happen when mutex that is regulating the server state throws.
+        /// See: https://github.com/dotnet/msbuild/issues/7993.
+        /// </remarks>
+        UnknownServerState
     }
 }
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index d635c661da9..6618dc945c8 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -120,9 +120,7 @@ internal class BuildRequestEngine : IBuildRequestEngine, IBuildComponent
         internal BuildRequestEngine()
         {
             _debugDumpState = Traits.Instance.DebugScheduler;
-            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? DebugUtils.DebugPath
-                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            _debugDumpPath = DebugUtils.DebugPath;
             _debugForceCaching = Environment.GetEnvironmentVariable("MSBUILDDEBUGFORCECACHING") == "1";
 
             if (String.IsNullOrEmpty(_debugDumpPath))
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index c261563d0e7..d5ceccb6dfc 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -605,6 +605,15 @@ BuildEventContext LogProjectStarted(
         /// <param name="properties">The list of properties associated with the event.</param>
         void LogTelemetry(BuildEventContext buildEventContext, string eventName, IDictionary<string, string> properties);
         #endregion
+
+        #region Log response files
+        /// <summary>
+        /// Helper method to create an event for including files. Typically response files
+        /// </summary>
+        /// <param name="buildEventContext">Event context information which describes where is the event getting logged</param>
+        /// <param name="filePath">Full path to the response file</param>
+        void LogIncludeFile(BuildEventContext buildEventContext, string filePath);
+        #endregion
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index a81fd673b27..c8018767633 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -269,5 +269,15 @@ internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
             LoggingService.LogFatalBuildError(BuildEventContext, exception, file);
             _hasLoggedErrors = true;
         }
+
+        /// <summary>
+        /// Logs a file to be included in the binary logger
+        /// </summary>
+        /// <param name="filePath">Path to response file</param>
+        internal void LogIncludeFile(string filePath)
+        { 
+            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            _loggingService.LogIncludeFile(BuildEventContext, filePath);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 5a4d694f427..e9c1cde6045 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -815,5 +815,22 @@ public void LogTelemetry(BuildEventContext buildEventContext, string eventName,
         }
 
         #endregion
+
+        #region log response files
+        /// <summary>
+        /// Logs a file to include in the binlogs
+        /// </summary>
+        /// <param name="buildEventContext">Event context information which describes who is logging the event</param>
+        /// <param name="filePath">Full path to response file</param>
+        public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
+        {
+            ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext was null");
+            ErrorUtilities.VerifyThrow(filePath != null, "response file path was null");
+            ResponseFileUsedEventArgs responseFileUsedEvent = new ResponseFileUsedEventArgs(filePath);
+            responseFileUsedEvent.BuildEventContext = buildEventContext;
+            ProcessLoggingEvent(responseFileUsedEvent);
+        }
+
+        #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
index 3423453f19c..48a847b60ce 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheResult.cs
@@ -127,13 +127,8 @@ private static WorkUnitResult CreateWorkUnitResult(BuildResultCode resultCode)
 
         private static ProjectItemInstance.TaskItem CreateTaskItem(ITaskItem2 taskItemInterface)
         {
-            var taskItem = new ProjectItemInstance.TaskItem(taskItemInterface.EvaluatedIncludeEscaped, null);
-
-            foreach (string metadataName in taskItemInterface.MetadataNames)
-            {
-                taskItem.SetMetadata(metadataName, taskItemInterface.GetMetadataValueEscaped(metadataName));
-            }
-
+            var taskItem = new ProjectItemInstance.TaskItem(taskItemInterface.EvaluatedIncludeEscaped, definingFileEscaped: null);
+            taskItemInterface.CopyMetadataTo(taskItem);
             return taskItem;
         }
     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 32b7c6b1b1a..446ef6e4c85 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -472,7 +472,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
 
                 foreach (string excludeSplitFile in excludeSplitFiles)
                 {
-                    excludesUnescapedForComparison.Add(excludeSplitFile);
+                    excludesUnescapedForComparison.Add(excludeSplitFile.NormalizeForPathComparison());
                 }
             }
 
@@ -480,7 +480,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
 
             for (int i = 0; i < items.Count; i++)
             {
-                if (!excludesUnescapedForComparison.Contains(((IItem)items[i]).EvaluatedInclude))
+                if (!excludesUnescapedForComparison.Contains(((IItem)items[i]).EvaluatedInclude.NormalizeForPathComparison()))
                 {
                     remainingItems.Add(items[i]);
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 4835778b4c1..8679287cd8a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -961,11 +961,15 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     && !taskResult // and it returned false
                     && !taskLoggingContext.HasLoggedErrors // and it didn't log any errors
                     && (be is TaskHost th ? th.BuildRequestsSucceeded : false)
-                    && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true) // and it's not allowed to fail unless it logs an error
                     && !(_cancellationToken.CanBeCanceled && _cancellationToken.IsCancellationRequested)) // and it wasn't cancelled
                 {
                     // Then decide how to log MSB4181
-                    if (_continueOnError == ContinueOnError.WarnAndContinue)
+                    if (be is IBuildEngine7 be7 && be7.AllowFailureWithoutError)
+                    {
+                        // If it's allowed to fail without error, log as a message
+                        taskLoggingContext.LogComment(MessageImportance.Normal, "TaskReturnedFalseButDidNotLogError", _taskNode.Name);
+                    }
+                    else if (_continueOnError == ContinueOnError.WarnAndContinue)
                     {
                         taskLoggingContext.LogWarning(null,
                             new BuildEventFileInfo(_targetChildInstance.Location),
@@ -1037,7 +1041,7 @@ private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
 
             var projectReferenceItems = _buildRequestEntry.RequestConfiguration.Project.GetItems(ItemTypeNames.ProjectReference);
 
-            var declaredProjects = new HashSet<string>(projectReferenceItems.Count);
+            var declaredProjects = new HashSet<string>(projectReferenceItems.Count + 1, FileUtilities.PathComparer);
 
             foreach (var projectReferenceItem in projectReferenceItems)
             {
@@ -1045,7 +1049,7 @@ private List<string> GetUndeclaredProjects(MSBuild msbuildTask)
             }
 
             // allow a project to msbuild itself
-            declaredProjects.Add(_taskExecutionHost.ProjectInstance.FullPath);
+            declaredProjects.Add(FileUtilities.NormalizePath(_taskExecutionHost.ProjectInstance.FullPath));
 
             List<string> undeclaredProjects = null;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 2b55265cd9a..4ee0c78cae4 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -123,9 +123,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
             _continueOnError = false;
             _activeProxy = true;
             _callbackMonitor = new object();
-            _disableInprocNode = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? Traits.Instance.InProcNodeDisabled || host.BuildParameters.DisableInProcNode
-                : Traits.Instance.InProcNodeDisabled;
+            _disableInprocNode = Traits.Instance.InProcNodeDisabled || host.BuildParameters.DisableInProcNode;
             EngineServices = new EngineServicesImpl(this);
         }
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index f166c13d9fa..de7bd580e4a 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -144,9 +144,7 @@ internal class Scheduler : IScheduler
         /// Flag used for debugging by forcing all scheduling to go out-of-proc.
         /// </summary>
         internal bool ForceAffinityOutOfProc
-            => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? Traits.Instance.InProcNodeDisabled || _componentHost.BuildParameters.DisableInProcNode
-                : Traits.Instance.InProcNodeDisabled;
+            => Traits.Instance.InProcNodeDisabled || _componentHost.BuildParameters.DisableInProcNode;
 
         /// <summary>
         /// The path into which debug files will be written.
@@ -183,9 +181,7 @@ public Scheduler()
         {
             // Be careful moving these to Traits, changing the timing of reading environment variables has a breaking potential.
             _debugDumpState = Traits.Instance.DebugScheduler;
-            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? DebugUtils.DebugPath
-                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            _debugDumpPath = DebugUtils.DebugPath;
             _schedulingUnlimitedVariable = Environment.GetEnvironmentVariable("MSBUILDSCHEDULINGUNLIMITED");
             _nodeLimitOffset = 0;
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 4ec872e6718..0a048df26d4 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -36,7 +36,7 @@ public override void ClearCaches()
             _cache.Clear();
         }
 
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             SdkResult result;
 
@@ -46,7 +46,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
 
             if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
             {
-                result = base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                result = base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
             }
             else
             {
@@ -65,7 +65,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                     {
                         wasResultCached = false;
 
-                        return base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                        return base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
                     }));
 
                 // Get the lazy value which will block all waiting threads until the SDK is resolved at least once while subsequent calls get cached results.
diff --git a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
index ef3e569dd06..0777e2ee6f3 100644
--- a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
@@ -31,12 +31,11 @@ internal class DefaultSdkResolver : SdkResolverBase
 
         public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase context, SdkResultFactoryBase factory)
         {
-            var sdkPath = Path.Combine(BuildEnvironmentHelper.Instance.MSBuildSDKsPath, sdk.Name, "Sdk");
+            string sdkPath = Path.Combine(BuildEnvironmentHelper.Instance.MSBuildSDKsPath, sdk.Name, "Sdk");
 
-            // Note: On failure MSBuild will log a generic message, no need to indicate a failure reason here.
             return FileUtilities.DirectoryExistsNoThrow(sdkPath)
                 ? factory.IndicateSuccess(sdkPath, string.Empty)
-                : factory.IndicateFailure(null);
+                : factory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DefaultSDKResolverError", sdk.Name, sdkPath) }, null);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs b/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs
index 46edc4f4a4d..84da3c1f818 100644
--- a/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs
@@ -49,7 +49,7 @@ public virtual void InitializeComponent(IBuildComponentHost host)
         public abstract void PacketReceived(int node, INodePacket packet);
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public abstract SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio);
+        public abstract SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
 
         /// <inheritdoc cref="IBuildComponent.ShutdownComponent"/>
         public virtual void ShutdownComponent()
diff --git a/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs
index f2f4544ccd1..9a33b60ccbc 100644
--- a/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs
@@ -42,7 +42,8 @@ internal interface ISdkResolverService
         /// <param name="projectPath">The full path to the project file that is resolving the SDK.</param>
         /// <param name="interactive">Indicates whether or not the resolver is allowed to be interactive.</param>
         /// <param name="isRunningInVisualStudio">Indicates whether or not the resolver is running in Visual Studio.</param>
+        /// <param name="failOnUnresolvedSdk">Whether to throw an exception should the SDK fail to be resolved.</param>
         /// <returns>An <see cref="SdkResult"/> containing information about the resolved SDK. If no resolver was able to resolve it, then <see cref="Framework.SdkResult.Success"/> == false. </returns>
-        SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio);
+        SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 6e1e26c4258..8dc3f79b60a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -4,6 +4,7 @@
 using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System;
@@ -72,9 +73,10 @@ public override void PacketReceived(int node, INodePacket packet)
             try
             {
                 ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
+                bool failOnUnresolvedSdk = !Host.BuildParameters.ProjectLoadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) || Host.BuildParameters.ProjectLoadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk);
 
                 // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
-                response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);
+                response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio, failOnUnresolvedSdk);
             }
             catch (Exception e)
             {
@@ -94,14 +96,14 @@ public override void PacketReceived(int node, INodePacket packet)
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));
             ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));
             ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));
             ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));
 
-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 9db962d2a21..0b9e5ceecb8 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -64,7 +64,7 @@ public override void PacketReceived(int node, INodePacket packet)
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             bool wasResultCached = true;
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index c38afed1d3b..7ccb8008ceb 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.Eventing;
 using System.Linq;
 using System.Text.RegularExpressions;
+using System.Diagnostics;
 
 #nullable disable
 
@@ -110,15 +111,28 @@ public virtual void ClearCaches()
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
             {
-                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
             }
             else
             {
-                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                SdkResult result = ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings);
+
+                // Warnings are already logged on success.
+                if (!result.Success)
+                {
+                    if (failOnUnresolvedSdk)
+                    {
+                        loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
+                    }
+
+                    LogWarnings(loggingContext, sdkReferenceLocation, warnings);
+                }
+
+                return result;
             }
         }
 
@@ -128,7 +142,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
         /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.
         /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.
         /// </remarks>
-        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)
             {
@@ -154,6 +168,8 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
 
             List<SdkResolver> resolvers;
             SdkResult sdkResult;
+            List<string> errors = new List<string>(0);
+            List<string> warnings = new List<string>(0);
             if (matchingResolversManifests.Count != 0)
             {
                 // First pass.
@@ -169,10 +185,15 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
                     projectPath,
                     interactive,
                     isRunningInVisualStudio,
-                    out sdkResult))
+                    out sdkResult,
+                    out IEnumerable<string> firstErrors,
+                    out IEnumerable<string> firstWarnings))
                 {
                     return sdkResult;
                 }
+
+                errors.AddRange(firstErrors);
+                warnings.AddRange(firstWarnings);
             }
 
             // Second pass: fallback to general resolvers. 
@@ -191,11 +212,23 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
                 projectPath,
                 interactive,
                 isRunningInVisualStudio,
-                out sdkResult))
+                out sdkResult,
+                out IEnumerable<string> moreErrors,
+                out IEnumerable<string> moreWarnings))
             {
                 return sdkResult;
             }
 
+            errors.AddRange(moreErrors);
+            warnings.AddRange(moreWarnings);
+
+            if (failOnUnresolvedSdk)
+            {
+                loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
+            }
+
+            LogWarnings(loggingContext, sdkReferenceLocation, warnings);
+
             // No resolvers resolved the sdk.
             return new SdkResult(sdk, null, null);
         }
@@ -228,7 +261,7 @@ private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManif
             return resolvers;
         }
 
-        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings)
         {
             // Lazy initialize all SDK resolvers
             if (_resolversList == null)
@@ -246,14 +279,30 @@ private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk
                 projectPath,
                 interactive,
                 isRunningInVisualStudio,
-                out SdkResult sdkResult);
+                out SdkResult sdkResult,
+                out errors,
+                out warnings);
 
             return sdkResult;
         }
 
-        private bool TryResolveSdkUsingSpecifiedResolvers(IList<SdkResolver> resolvers, int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out SdkResult sdkResult)
+        private bool TryResolveSdkUsingSpecifiedResolvers(
+            IList<SdkResolver> resolvers,
+            int submissionId,
+            SdkReference sdk,
+            LoggingContext loggingContext,
+            ElementLocation sdkReferenceLocation,
+            string solutionPath,
+            string projectPath,
+            bool interactive,
+            bool isRunningInVisualStudio,
+            out SdkResult sdkResult,
+            out IEnumerable<string> errors,
+            out IEnumerable<string> warnings)
         {
             List<SdkResult> results = new List<SdkResult>();
+            errors = null;
+            warnings = null;
 
             // Loop through resolvers which have already been sorted by priority, returning the first result that was successful
             SdkLogger buildEngineLogger = new SdkLogger(loggingContext);
@@ -294,14 +343,11 @@ private bool TryResolveSdkUsingSpecifiedResolvers(IList<SdkResolver> resolvers,
 
                 SetResolverState(submissionId, sdkResolver, context.State);
 
-                if (result == null)
-                {
-                    continue;
-                }
+                result ??= (SdkResult)resultFactory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", sdkResolver.Name) }, Array.Empty<string>());
 
                 if (result.Success)
                 {
-                    LogWarnings(loggingContext, sdkReferenceLocation, result);
+                    LogWarnings(loggingContext, sdkReferenceLocation, result.Warnings);
 
                     if (!IsReferenceSameVersion(sdk, result.Version))
                     {
@@ -319,18 +365,8 @@ private bool TryResolveSdkUsingSpecifiedResolvers(IList<SdkResolver> resolvers,
                 results.Add(result);
             }
 
-            foreach (SdkResult result in results)
-            {
-                LogWarnings(loggingContext, sdkReferenceLocation, result);
-
-                if (result.Errors != null)
-                {
-                    foreach (string error in result.Errors)
-                    {
-                        loggingContext.LogErrorFromText(subcategoryResourceName: null, errorCode: null, helpKeyword: null, file: new BuildEventFileInfo(sdkReferenceLocation), message: error);
-                    }
-                }
-            }
+            warnings = results.SelectMany(r => r.Warnings ?? Array.Empty<string>());
+            errors = results.SelectMany(r => r.Errors ?? Array.Empty<string>());
 
             sdkResult = new SdkResult(sdk, null, null);
             return false;
@@ -372,14 +408,14 @@ internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<
             }
         }
 
-        private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, SdkResult result)
+        private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, IEnumerable<string> warnings)
         {
-            if (result.Warnings == null)
+            if (warnings == null)
             {
                 return;
             }
 
-            foreach (string warning in result.Warnings)
+            foreach (string warning in warnings)
             {
                 loggingContext.LogWarningFromText(null, null, null, new BuildEventFileInfo(location), warning);
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 2901298ed0a..18297977aaa 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -361,6 +361,10 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)
             Thread.CurrentThread.CurrentCulture = command.Culture;
             Thread.CurrentThread.CurrentUICulture = command.UICulture;
 
+            // Reconfigure static BuildParameters.StartupDirectory to have this value
+            // same as startup directory of msbuild entry client or dotnet CLI.
+            BuildParameters.StartupDirectory = command.StartupDirectory;
+
             // Configure console configuration so Loggers can change their behavior based on Target (client) Console properties.
             ConsoleConfiguration.Provider = command.ConsoleConfiguration;
 
diff --git a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
index 8f951bbcab3..a58dceeaaa8 100644
--- a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
+++ b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
@@ -36,8 +36,8 @@ public ConfigurationMetadata(BuildRequestConfiguration configuration)
         public ConfigurationMetadata(Project project)
         {
             ErrorUtilities.VerifyThrowArgumentNull(project, nameof(project));
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(project.GlobalProperties.Count);
-            foreach (KeyValuePair<string, string> entry in project.GlobalProperties)
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(project.GlobalPropertiesCount);
+            foreach (KeyValuePair<string, string> entry in project.GlobalPropertiesEnumerable)
             {
                 _globalProperties[entry.Key] = ProjectPropertyInstance.Create(entry.Key, entry.Value);
             }
diff --git a/src/Build/Construction/ProjectItemDefinitionGroupElement.cs b/src/Build/Construction/ProjectItemDefinitionGroupElement.cs
index 29627027867..f55a6a0b1f5 100644
--- a/src/Build/Construction/ProjectItemDefinitionGroupElement.cs
+++ b/src/Build/Construction/ProjectItemDefinitionGroupElement.cs
@@ -30,7 +30,7 @@ internal ProjectItemDefinitionGroupElement(ProjectItemDefinitionGroupElementLink
         /// <summary>
         /// Initialize a parented ProjectItemDefinitionGroupElement
         /// </summary>
-        internal ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectRootElement parent, ProjectRootElement containingProject)
+        internal ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject)
             : base(xmlElement, parent, containingProject)
         {
             ErrorUtilities.VerifyThrowArgumentNull(parent, nameof(parent));
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 294b523e07e..0ba22cdf4e7 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -56,7 +56,7 @@ public class Project : ILinkableObject
         /// <summary>
         /// * and ? are invalid file name characters, but they occur in globs as wild cards.
         /// </summary>
-        private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c!= '/' && c != '\\' && c != ':').ToArray();
+        private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c != '/' && c != '\\' && c != ':').ToArray();
 
         /// <summary>
         /// Context to log messages and events in.
@@ -600,6 +600,21 @@ private enum BuildEnabledSetting
         /// </remarks>
         public IDictionary<string, string> GlobalProperties => implementation.GlobalProperties;
 
+        /// <summary>
+        /// Indicates whether the global properties dictionary contains the specified key.
+        /// </summary>
+        internal bool GlobalPropertiesContains(string key) => implementation.GlobalPropertiesContains(key);
+
+        /// <summary>
+        /// Indicates how many elements are in the global properties dictionary.
+        /// </summary>
+        internal int GlobalPropertiesCount => implementation.GlobalPropertiesCount();
+
+        /// <summary>
+        /// Enumerates the values in the global properties dictionary.
+        /// </summary>
+        internal IEnumerable<KeyValuePair<string, string>> GlobalPropertiesEnumerable => implementation.GlobalPropertiesEnumerable();
+
         /// <summary>
         /// Item types in this project.
         /// This is an ordered collection.
@@ -2087,6 +2102,37 @@ public override bool IsDirty
                 }
             }
 
+            /// <summary>
+            /// See <see cref="ProjectLink.GlobalPropertiesContains(string)"/>.
+            /// </summary>
+            /// <param name="key">The key to check for its value.</param>
+            /// <returns>Whether the key is in the global properties dictionary.</returns>
+            public override bool GlobalPropertiesContains(string key)
+            {
+                return _data.GlobalPropertiesDictionary.Contains(key);
+            }
+
+            /// <summary>
+            /// See <see cref="ProjectLink.GlobalPropertiesCount()"/>.
+            /// </summary>
+            /// <returns>The number of properties in the global properties dictionary</returns>
+            public override int GlobalPropertiesCount()
+            {
+                return _data.GlobalPropertiesDictionary.Count;
+            }
+
+            /// <summary>
+            /// See <see cref="ProjectLink.GlobalPropertiesEnumerable()"/>.
+            /// </summary>
+            /// <returns>An IEnumerable of the keys and values of the global properties dictionary</returns>
+            public override IEnumerable<KeyValuePair<string, string>> GlobalPropertiesEnumerable()
+            {
+                foreach (ProjectPropertyInstance property in _data.GlobalPropertiesDictionary)
+                {
+                    yield return new KeyValuePair<string, string>(property.Name, ((IProperty)property).EvaluatedValueEscaped);
+                }
+            }
+
             /// <summary>
             /// Read only dictionary of the global properties used in the evaluation
             /// of this project.
@@ -2736,12 +2782,13 @@ private List<ProvenanceResult> GetItemProvenance(string itemToMatch, IEnumerable
                     return new List<ProvenanceResult>();
                 }
 
-                return
-                    projectItemElements
+                return projectItemElements
                     .AsParallel()
-                    .AsOrdered()
-                    .Select(i => ComputeProvenanceResult(itemToMatch, i))
-                    .Where(r => r != null)
+                    .Select((item, index) => (Result: ComputeProvenanceResult(itemToMatch, item), Index: index))
+                    .Where(pair => pair.Result != null)
+                    .AsSequential()
+                    .OrderBy(pair => pair.Index)
+                    .Select(pair => pair.Result)
                     .ToList();
             }
 
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 240fbd0d77f..838e95574fc 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -2592,12 +2592,12 @@ private static bool HasEquivalentGlobalPropertiesAndToolsVersion(Project project
                     return false;
                 }
 
-                if (project.GlobalProperties.Count != globalProperties.Count)
+                if (project.GlobalPropertiesCount != globalProperties.Count)
                 {
                     return false;
                 }
 
-                foreach (KeyValuePair<string, string> leftProperty in project.GlobalProperties)
+                foreach (KeyValuePair<string, string> leftProperty in project.GlobalPropertiesEnumerable)
                 {
                     if (!globalProperties.TryGetValue(leftProperty.Key, out var rightValue))
                     {
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 058217689f8..e03454a5f7d 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -596,7 +596,7 @@ public override bool IsGlobalProperty
             {
                 [DebuggerStepThrough]
                 get
-                { return _project.GlobalProperties.ContainsKey(Name); }
+                { return _project.GlobalPropertiesContains(Name); }
             }
 
             /// <summary>
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 8d8f3251768..caae6ee03a0 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -262,14 +262,7 @@ private Dictionary<string, ProjectImportPathMatch> ComputeDistinctListOfSearchPa
         /// </summary>
         private static Configuration ReadApplicationConfiguration()
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                return s_configurationCache.Value;
-            }
-            else
-            {
-                return ReadOpenMappedExeConfiguration();
-            }
+            return s_configurationCache.Value;
         }
 
         private static Configuration ReadOpenMappedExeConfiguration()
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index ddb164cb778..f2393bfcbc1 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -439,10 +439,15 @@ bool accumulateProperties
                     Toolset toolset = ReadToolset(toolsVersion, globalProperties, initialPropertiesClone, accumulateProperties);
 
                     // Register toolset paths into list of immutable directories
-                    //   example: C:\Windows\Microsoft.NET\Framework\v4.0.30319\
-                    FileClassifier.Shared.RegisterImmutableDirectory(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath32")?.EvaluatedValue?.Trim());
-                    // example:  C:\Windows\Microsoft.NET\Framework64\v4.0.30319\
-                    FileClassifier.Shared.RegisterImmutableDirectory(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath64")?.EvaluatedValue?.Trim());
+                    // example: C:\Windows\Microsoft.NET\Framework
+                    string frameworksPathPrefix32 = existingRootOrNull(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath32")?.EvaluatedValue?.Trim());
+                    FileClassifier.Shared.RegisterImmutableDirectory(frameworksPathPrefix32);
+                    // example: C:\Windows\Microsoft.NET\Framework64
+                    string frameworksPathPrefix64 = existingRootOrNull(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPath64")?.EvaluatedValue?.Trim());
+                    FileClassifier.Shared.RegisterImmutableDirectory(frameworksPathPrefix64);
+                    // example: C:\Windows\Microsoft.NET\FrameworkArm64
+                    string frameworksPathPrefixArm64 = existingRootOrNull(initialPropertiesClone.GetProperty("MSBuildFrameworkToolsPathArm64")?.EvaluatedValue?.Trim());
+                    FileClassifier.Shared.RegisterImmutableDirectory(frameworksPathPrefixArm64);
 
                     if (toolset != null)
                     {
@@ -450,6 +455,28 @@ bool accumulateProperties
                     }
                 }
             }
+
+            string existingRootOrNull(string path)
+            {
+                if (!string.IsNullOrEmpty(path))
+                {
+                    try
+                    {
+                        path = Directory.GetParent(FileUtilities.EnsureNoTrailingSlash(path))?.FullName;
+
+                        if (!Directory.Exists(path))
+                        {
+                            path = null;
+                        }
+                    }
+                    catch
+                    {
+                        path = null;
+                    }
+                }
+
+                return path;
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 37e520b9b21..59dba0b96ad 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1542,6 +1542,9 @@ private bool EvaluateWhenOrOtherwiseChildren(IEnumerable<ProjectElement> childre
                         case ProjectChooseElement choose:
                             EvaluateChooseElement(choose);
                             break;
+                        case ProjectItemDefinitionGroupElement itemDefinition:
+                            _itemDefinitionGroupElements.Add(itemDefinition);
+                            break;
                         default:
                             ErrorUtilities.ThrowInternalError("Unexpected child type");
                             break;
@@ -1635,6 +1638,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
             // paths will be returned (union of all files that match).
             var allProjects = new List<ProjectRootElement>();
             bool containsWildcards = FileMatcher.HasWildcards(importElement.Project);
+            bool missingDirectoryDespiteTrueCondition = false;
 
             // Try every extension search path, till we get a Hit:
             // 1. 1 or more project files loaded
@@ -1648,15 +1652,19 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
 
                 string extensionPathExpanded = _data.ExpandString(extensionPath);
 
-                if (!_fallbackSearchPathsCache.DirectoryExists(extensionPathExpanded))
+                var newExpandedCondition = importElement.Condition.Replace(extensionPropertyRefAsString, extensionPathExpanded, StringComparison.OrdinalIgnoreCase);
+                if (!EvaluateConditionCollectingConditionedProperties(importElement, newExpandedCondition, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties,
+                            _projectRootElementCache))
                 {
                     continue;
                 }
 
-                var newExpandedCondition = importElement.Condition.Replace(extensionPropertyRefAsString, extensionPathExpanded, StringComparison.OrdinalIgnoreCase);
-                if (!EvaluateConditionCollectingConditionedProperties(importElement, newExpandedCondition, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties,
-                            _projectRootElementCache))
+                // If the whole fallback folder doesn't exist, short-circuit and don't
+                // bother constructing an exact file path.
+                if (!_fallbackSearchPathsCache.DirectoryExists(extensionPathExpanded))
                 {
+                    // Set to log an error only if the change wave is enabled.
+                    missingDirectoryDespiteTrueCondition = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && !containsWildcards;
                     continue;
                 }
 
@@ -1709,7 +1717,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
             // atleastOneExactFilePathWasLookedAtAndNotFound would be false, eg, if the expression
             // was a wildcard and it resolved to zero files!
             if (allProjects.Count == 0 &&
-                atleastOneExactFilePathWasLookedAtAndNotFound &&
+                (atleastOneExactFilePathWasLookedAtAndNotFound || missingDirectoryDespiteTrueCondition) &&
                 (_loadSettings & ProjectLoadSettings.IgnoreMissingImports) == 0)
             {
                 ThrowForImportedProjectWithSearchPathsNotFound(fallbackSearchPathMatch, importElement);
@@ -1839,7 +1847,8 @@ static string EvaluateProperty(string value, IElementLocation location,
                 // Combine SDK path with the "project" relative path
                 try
                 {
-                    sdkResult = _sdkResolverService.ResolveSdk(_submissionId, sdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive, _isRunningInVisualStudio);
+                    sdkResult = _sdkResolverService.ResolveSdk(_submissionId, sdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive, _isRunningInVisualStudio,
+                        failOnUnresolvedSdk: !_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) || _loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk));
                 }
                 catch (SdkResolverException e)
                 {
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 3b8c3f99a6f..fd9f087f7a9 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Shared;
 using System;
 using System.Collections.Generic;
+using System.Xml;
 
 using Expander = Microsoft.Build.Evaluation.Expander<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>;
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
@@ -181,7 +182,7 @@ private void Parse()
                         break;
 
                     case XMakeElements.itemDefinitionGroup:
-                        _project.AppendParentedChildNoChecks(ParseProjectItemDefinitionGroupElement(childElement));
+                        _project.AppendParentedChildNoChecks(ParseProjectItemDefinitionGroupElement(childElement, _project));
                         break;
 
                     case XMakeElements.choose:
@@ -634,6 +635,14 @@ private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation el
                         if (onError != null)
                         {
                             ProjectErrorUtilities.ThrowInvalidProject(onError.Location, "NodeMustBeLastUnderElement", XMakeElements.onError, XMakeElements.target, childElement.Name);
+                        }                       
+                        if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+                        {
+                            if (childElement.ChildNodes.Count == 1 && childElement.FirstChild.NodeType == XmlNodeType.Text)
+                            {
+                                // If the element has inner text and no other child elements except text, then this should be a property and throw invalid child element of <Target>
+                                ProjectErrorUtilities.ThrowInvalidProject(childElement.Location, "PropertyOutsidePropertyGroupInTarget", childElement.Name, childElement.ParentNode.Name);
+                            }
                         }
 
                         child = ParseProjectTaskElement(childElement, target);
@@ -709,11 +718,11 @@ private ProjectOutputElement ParseProjectOutputElement(XmlElementWithLocation el
         /// <summary>
         /// Parse a ProjectItemDefinitionGroupElement
         /// </summary>
-        private ProjectItemDefinitionGroupElement ParseProjectItemDefinitionGroupElement(XmlElementWithLocation element)
+        private ProjectItemDefinitionGroupElement ParseProjectItemDefinitionGroupElement(XmlElementWithLocation element, ProjectElementContainer parent)
         {
             ProjectXmlUtilities.VerifyThrowProjectAttributes(element, ValidAttributesOnlyConditionAndLabel);
 
-            ProjectItemDefinitionGroupElement itemDefinitionGroup = new ProjectItemDefinitionGroupElement(element, _project, _project);
+            ProjectItemDefinitionGroupElement itemDefinitionGroup = new ProjectItemDefinitionGroupElement(element, parent, _project);
 
             foreach (XmlElementWithLocation childElement in ProjectXmlUtilities.GetVerifyThrowProjectChildElements(element))
             {
@@ -865,6 +874,10 @@ private void ParseWhenOtherwiseChildren(XmlElementWithLocation element, ProjectE
                         child = ParseProjectChooseElement(childElement, parent, nestingDepth);
                         break;
 
+                    case XMakeElements.itemDefinitionGroup:
+                        child = ParseProjectItemDefinitionGroupElement(childElement, parent);
+                        break;
+
                     default:
                         ProjectXmlUtilities.ThrowProjectInvalidChildElement(childElement.Name, element.Name, element.Location);
                         break;
diff --git a/src/Build/Evaluation/ProjectStringCache.cs b/src/Build/Evaluation/ProjectStringCache.cs
index ee61fc8fd4d..92d0f42062e 100644
--- a/src/Build/Evaluation/ProjectStringCache.cs
+++ b/src/Build/Evaluation/ProjectStringCache.cs
@@ -8,6 +8,7 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -84,6 +85,13 @@ internal int DocumentCount
         /// </summary>
         public string Add(string key, XmlDocument document)
         {
+            // Remove string interning in ChangeWave 17.6
+            // Note: When ready to remove the ChangeWaves under 17.6, please delete this entire class and all references to it. (See the PR https://github.com/dotnet/msbuild/pull/7952).
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+            {
+                return key;
+            }
+
             if (key.Length == 0)
             {
                 return String.Empty;
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index ce624d60323..d9843d908e9 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -212,16 +212,10 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                         RegexOptions regexOptions = FileMatcher.DefaultRegexOptions;
                         // compile the regex since it's expected to be used multiple times
                         // For the kind of regexes used here, compilation on .NET Framework tends to be expensive and not worth the small
-                        // run-time boost so it's enabled only on .NET Core by default.
+                        // run-time boost so it's enabled only on .NET Core.
 #if RUNTIME_TYPE_NETCORE
-                        bool compileRegex = true;
-#else
-                        bool compileRegex = !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);
+                        regexOptions |= RegexOptions.Compiled;
 #endif
-                        if (compileRegex)
-                        {
-                            regexOptions |= RegexOptions.Compiled;
-                        }
                         Regex newRegex = new Regex(matchFileExpression, regexOptions);
                         lock (s_regexCache)
                         {
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index e8a6624faf2..b64b17cee58 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -588,9 +588,8 @@ private static IReadOnlyCollection<ProjectGraphNode> TopologicalSort(
         ///     This method uses the ProjectReferenceTargets items to determine the targets to run per node. The results can then
         ///     be used to start building each project individually, assuming a given project is built after its references.
         /// </remarks>
-        /// <param name="entryProjectTargets">
-        ///     The target list for the <see cref="GraphRoots" />. May be null or empty, in which case the entry projects' default
-        ///     targets will be used.
+        /// <param name="entryProjectTargets">The target list for the entry project. May be null or empty, in which case the entry
+        /// projects' default targets will be used.
         /// </param>
         /// <returns>
         ///     A dictionary containing the target list for each node. If a node's target list is empty, then no targets were
@@ -606,8 +605,7 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();
             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();
 
-            // Initial state for the graph roots
-            foreach (var entryPointNode in GraphRoots)
+            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
             {
                 var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0
                     ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 3a253dbc5a8..de9f9d01451 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -352,8 +352,8 @@ public ProjectInstance(Project project, ProjectInstanceSettings settings)
 
             this.CreateEvaluatedIncludeSnapshotIfRequested(keepEvaluationCache, project.Items, projectItemToInstanceMap);
 
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(project.GlobalProperties.Count);
-            foreach (var property in project.GlobalProperties)
+            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(project.GlobalPropertiesCount);
+            foreach (var property in project.GlobalPropertiesEnumerable)
             {
                 _globalProperties.Set(ProjectPropertyInstance.Create(property.Key, property.Value));
             }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 5ea0941cde1..46c583f3472 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -29,6 +29,7 @@ internal enum BinaryLogRecordKind
         PropertyInitialValueSet,
         NameValueList,
         String,
-        TaskParameter
+        TaskParameter,
+        ResponseFileUsed, 
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 7fbddddf7ee..e7aac941dd4 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -53,7 +53,9 @@ public sealed class BinaryLogger : ILogger
         //   - TargetSkippedEventArgs: added OriginallySucceeded, Condition, EvaluatedCondition
         // version 14:
         //   - TargetSkippedEventArgs: added SkipReason, OriginalBuildEventContext
-        internal const int FileFormatVersion = 14;
+        // version 15:
+        //   - new record kind: ResponseFileUsedEventArgs
+        internal const int FileFormatVersion = 15;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -270,6 +272,10 @@ private void CollectImports(BuildEventArgs e)
             {
                 projectImportsCollector.AddFileFromMemory(metaprojectArgs.ProjectFile, metaprojectArgs.metaprojectXml);
             }
+            else if (e is ResponseFileUsedEventArgs responseFileArgs && responseFileArgs.ResponseFilePath != null)
+            {
+                projectImportsCollector.AddFile(responseFileArgs.ResponseFilePath);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 64a26269a78..a93e2074044 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -176,6 +176,9 @@ public BuildEventArgs Read()
                 case BinaryLogRecordKind.EnvironmentVariableRead:
                     result = ReadEnvironmentVariableReadEventArgs();
                     break;
+                case BinaryLogRecordKind.ResponseFileUsed:
+                    result = ReadResponseFileUsedEventArgs();
+                    break;
                 case BinaryLogRecordKind.PropertyReassignment:
                     result = ReadPropertyReassignmentEventArgs();
                     break;
@@ -727,6 +730,16 @@ private BuildEventArgs ReadEnvironmentVariableReadEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadResponseFileUsedEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var responseFilePath = ReadDeduplicatedString();
+            var e = new ResponseFileUsedEventArgs(responseFilePath);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         private BuildEventArgs ReadPropertyReassignmentEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 46f8eb085de..79dac4ce124 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -428,6 +428,7 @@ private void Write(BuildMessageEventArgs e)
         {
             switch (e)
             {
+                case ResponseFileUsedEventArgs responseFileUsed: Write(responseFileUsed); break;
                 case TaskParameterEventArgs taskParameter: Write(taskParameter); break;
                 case ProjectImportedEventArgs projectImported: Write(projectImported); break;
                 case TargetSkippedEventArgs targetSkipped: Write(targetSkipped); break;
@@ -506,7 +507,12 @@ private void Write(EnvironmentVariableReadEventArgs e)
             WriteMessageFields(e, writeImportance: true);
             WriteDeduplicatedString(e.EnvironmentVariableName);
         }
-
+        private void Write(ResponseFileUsedEventArgs e)
+        {
+            Write(BinaryLogRecordKind.ResponseFileUsed);
+            WriteMessageFields(e);
+            WriteDeduplicatedString(e.ResponseFilePath);
+        }
         private void Write(TaskCommandLineEventArgs e)
         {
             Write(BinaryLogRecordKind.TaskCommandLine);
diff --git a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
index e56f4750920..4e6973c3ed4 100644
--- a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
+++ b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
@@ -130,8 +130,7 @@ private void AddFileCore(string filePath)
                 return;
             }
 
-            var fileInfo = new FileInfo(filePath);
-            if (!fileInfo.Exists || fileInfo.Length == 0)
+            if (!NativeMethodsShared.ExistAndHasContent(filePath))
             {
                 _processedFiles.Add(filePath);
                 return;
@@ -145,11 +144,9 @@ private void AddFileCore(string filePath)
                 return;
             }
 
-            using (Stream entryStream = OpenArchiveEntry(filePath))
-            using (FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete))
-            {
-                content.CopyTo(entryStream);
-            }
+            using Stream entryStream = OpenArchiveEntry(filePath);
+            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);
+            content.CopyTo(entryStream);
         }
 
         /// <remarks>
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 3d184b648f1..62d277bbdb2 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1364,50 +1364,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
             lock (_lockObject)
             {
                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;
-
-                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-                {
-                    // The string may contain new lines, treat each new line as a different string to format and send to the console
-                    string[] nonNullMessages = SplitStringOnNewLines(message);
-                    for (int i = 0; i < nonNullMessages.Length; i++)
-                    {
-                        string nonNullMessage = nonNullMessages[i];
-                        // Take into account the new line char which will be added to the end or each reformatted string
-                        int bufferWidthMinusNewLine = _bufferWidth - 1;
-
-                        // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. 
-                        // If there is not enough room just print the message out and let the console do the formatting
-                        bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;
-                        bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;
-                        if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)
-                        {
-                            // Our message may have embedded tab characters, so expand those to their space
-                            // equivalent so that wrapping works as expected.
-                            nonNullMessage = nonNullMessage.Replace("\t", consoleTab);
-
-                            // If the message and the prefix are too large for one line in the console, split the string to fit
-                            int index = 0;
-                            int messageLength = nonNullMessage.Length;
-                            // Loop until all the string has been sent to the console
-                            while (index < messageLength)
-                            {
-                                // Calculate how many chars will fit on the console buffer
-                                int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
-                                WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);
-                                index += amountToCopy;
-                            }
-                        }
-                        else
-                        {
-                            // there is not enough room just print the message out and let the console do the formatting
-                            WriteBasedOnPrefix(nonNullMessage, prefixAlreadyWritten, adjustedPrefixWidth);
-                        }
-                    }
-                }
-                else
-                {
-                    WriteHandler(_consoleOutputAligner.AlignConsoleOutput(message, prefixAlreadyWritten, adjustedPrefixWidth));
-                }
+                WriteHandler(_consoleOutputAligner.AlignConsoleOutput(message, prefixAlreadyWritten, adjustedPrefixWidth));
             }
         }
 
@@ -1793,7 +1750,6 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
         private bool _forceNoAlign;
         private bool _showEventId;
         // According to the documentation for ENABLE_PROCESSED_OUTPUT tab width for the console is 8 characters
-        private const string consoleTab = "        ";
         #endregion
 
         #region Per-build Members
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 7ec2ec46738..6e13af19356 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -20,6 +20,7 @@
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which is used to create, edit, and evaluate MSBuild projects.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">full</ApplyNgenOptimization>
+    <EnablePackageValidation>true</EnablePackageValidation>
 
     <!-- Do not generate a warning that our 'stable' package should not have a prerelease dependency. -->
     <NoWarn>$(NoWarn);NU5104</NoWarn>
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectLink.cs
index 68e3609784b..03f7a8795a5 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectLink.cs
@@ -259,5 +259,27 @@ public abstract class ProjectLink
         /// Called by the local project collection to indicate to this project that it is no longer loaded.
         /// </summary>
         public abstract void Unload();
+
+        /// <summary>
+        /// Indicates whether a specified key is in the global properties dictionary. This provides a default implementation
+        /// to avoid a breaking change, but it is often overriden for performance.
+        /// </summary>
+        /// <param name="key">The key to check for in the dictionary</param>
+        /// <returns>True if the key is in the global properties; false otherwise</returns>
+        public virtual bool GlobalPropertiesContains(string key) => GlobalProperties.ContainsKey(key);
+
+        /// <summary>
+        /// Indicates how many properties are in the global properties dictionary. This provides a default implementation to
+        /// avoid a breaking change, but it is often overriden for performance.
+        /// </summary>
+        /// <returns>The number of properties in the global properties dictionary</returns>
+        public virtual int GlobalPropertiesCount() => GlobalProperties.Count;
+
+        /// <summary>
+        /// Allows enumeration over the keys and values in the global properties dictionary. This provides a default
+        /// implementation to avoid a breaking change, but it can be overriden for performance.
+        /// </summary>
+        /// <returns>An enumerable of the keys and values in the global properties dictionary</returns>
+        public virtual IEnumerable<KeyValuePair<string, string>> GlobalPropertiesEnumerable() => GlobalProperties;
     }
 }
diff --git a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index b006f76520c..00000000000
--- a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,1836 +0,0 @@
-abstract Microsoft.Build.Construction.ElementLocation.Column.get -> int
-abstract Microsoft.Build.Construction.ElementLocation.File.get -> string
-abstract Microsoft.Build.Construction.ElementLocation.Line.get -> int
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsEnvironmentProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsGlobalProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsImported.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsReservedProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.Name.get -> string
-abstract Microsoft.Build.Evaluation.ProjectProperty.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.get -> string
-abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.set -> void
-abstract Microsoft.Build.Evaluation.ProjectProperty.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Condition.get -> string
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Condition.get -> string
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.get -> bool
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.set -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogError(string error) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = null) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogWarning(string warning) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult>
-abstract Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.GetLoadedProjects(string filePath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElement child) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.Count.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.LastChild.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Attributes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ElementName.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(string attributeName) -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(string attributeName, bool nullIfNotExists) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.OuterElement.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PureText.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.GetSubElement(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.SetSubElement(string name, string value) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadataValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ItemType.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ChangeItemType(string newType) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ChangeItemType(string newItemType) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.DirectMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.EvaluatedInclude.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadataValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.HasMetadata(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.MetadataCollection.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.RemoveMetadata(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Rename(string name) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ExpandString(string unexpandedValue) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetPropertyValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsDirty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.LastEvaluationId.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.MarkDirty() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveGlobalProperty(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SaveLogicalProject(System.IO.TextWriter writer) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetGlobalProperty(string name, string escapedValue) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SubToolsetVersion.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ToolsVersion.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Unload() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ChangeName(string newName) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.EvaluatedValueEscaped.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Parent.get -> object
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ChangeName(string newName) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.EvaluatedIncludeEscaped.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsEnvironmentProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsGlobalProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsImported.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsReservedProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.DirectoryPath.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Encoding.get -> System.Text.Encoding
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.HasUnsavedChanges.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.LastWriteTimeWhenRead.get -> System.DateTime
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.MarkDirty(string reason, string param) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.PreserveFormatting.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.RawXml.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.IO.TextWriter writer) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.Text.Encoding saveEncoding) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.TimeLastChanged.get -> System.DateTime
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Version.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Returns.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.GetParameter(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveAllParameters() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveParameter(string name) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.SetParameter(string name, string unevaluatedValue) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.set -> void
-const Microsoft.Build.Evaluation.MatchOnMetadataConstants.MatchOnMetadataOptionsDefaultValue = Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Resolver.get -> Microsoft.Build.Framework.SdkResolver
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Sdk.get -> Microsoft.Build.Framework.SdkReference
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.SdkResolverException(string resourceName, Microsoft.Build.Framework.SdkResolver resolver, Microsoft.Build.Framework.SdkReference sdk, System.Exception innerException, params string[] args) -> void
-Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ElementLocation.ElementLocation() -> void
-Microsoft.Build.Construction.ElementLocation.LocationString.get -> string
-Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.Bottom = 2 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.None = 0 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.Top = 1 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.Construction.ProjectChooseElement.OtherwiseElement.get -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectChooseElement.WhenElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectWhenElement>
-Microsoft.Build.Construction.ProjectConfigurationInSolution
-Microsoft.Build.Construction.ProjectConfigurationInSolution.ConfigurationName.get -> string
-Microsoft.Build.Construction.ProjectConfigurationInSolution.FullName.get -> string
-Microsoft.Build.Construction.ProjectConfigurationInSolution.IncludeInBuild.get -> bool
-Microsoft.Build.Construction.ProjectConfigurationInSolution.PlatformName.get -> string
-Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.AllParents.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElementContainer>
-Microsoft.Build.Construction.ProjectElement.Clone() -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectElement.ElementName.get -> string
-Microsoft.Build.Construction.ProjectElement.Label.get -> string
-Microsoft.Build.Construction.ProjectElement.Label.set -> void
-Microsoft.Build.Construction.ProjectElement.LabelLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectElement.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectElement.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.OuterElement.get -> string
-Microsoft.Build.Construction.ProjectElement.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
-Microsoft.Build.Construction.ProjectElement.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer
-Microsoft.Build.Construction.ProjectElementContainer.AllChildren.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectElementContainer.Children.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.ChildrenReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.Count.get -> int
-Microsoft.Build.Construction.ProjectElementContainer.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-Microsoft.Build.Construction.ProjectElementContainer.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-Microsoft.Build.Construction.ProjectElementContainer.LastChild.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer.PrependChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectElementContainer.RemoveAllChildren() -> void
-Microsoft.Build.Construction.ProjectElementContainer.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.Construction.ProjectExtensionsElement.Content.get -> string
-Microsoft.Build.Construction.ProjectExtensionsElement.Content.set -> void
-Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].get -> string
-Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].set -> void
-Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.get -> string
-Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.set -> void
-Microsoft.Build.Construction.ProjectImportElement.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectImportElement.Project.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Project.set -> void
-Microsoft.Build.Construction.ProjectImportElement.ProjectLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectImportElement.Sdk.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Sdk.set -> void
-Microsoft.Build.Construction.ProjectImportElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectImportElement.Version.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Version.set -> void
-Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectImportGroupElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectImportGroupElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
-Microsoft.Build.Construction.ProjectInSolution
-Microsoft.Build.Construction.ProjectInSolution.AbsolutePath.get -> string
-Microsoft.Build.Construction.ProjectInSolution.Dependencies.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Construction.ProjectInSolution.ParentProjectGuid.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectConfigurations.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution>
-Microsoft.Build.Construction.ProjectInSolution.ProjectGuid.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectName.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectType.get -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.ProjectInSolution.ProjectType.set -> void
-Microsoft.Build.Construction.ProjectInSolution.RelativePath.get -> string
-Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectItemDefinitionElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
-Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemElement.Exclude.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Exclude.set -> void
-Microsoft.Build.Construction.ProjectItemElement.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.HasMetadata.get -> bool
-Microsoft.Build.Construction.ProjectItemElement.Include.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Include.set -> void
-Microsoft.Build.Construction.ProjectItemElement.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectItemElement.ItemType.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.get -> string
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.get -> string
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.set -> void
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
-Microsoft.Build.Construction.ProjectItemElement.Remove.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Remove.set -> void
-Microsoft.Build.Construction.ProjectItemElement.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.Update.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Update.set -> void
-Microsoft.Build.Construction.ProjectItemElement.UpdateLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemGroupElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.get -> bool
-Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.set -> void
-Microsoft.Build.Construction.ProjectMetadataElement.Name.get -> string
-Microsoft.Build.Construction.ProjectMetadataElement.Name.set -> void
-Microsoft.Build.Construction.ProjectMetadataElement.Value.get -> string
-Microsoft.Build.Construction.ProjectMetadataElement.Value.set -> void
-Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.get -> string
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.set -> void
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectOtherwiseElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectOtherwiseElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectOtherwiseElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectOutputElement.IsOutputItem.get -> bool
-Microsoft.Build.Construction.ProjectOutputElement.IsOutputProperty.get -> bool
-Microsoft.Build.Construction.ProjectOutputElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.ItemType.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOutputElement.PropertyName.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.PropertyName.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectPropertyElement.Name.get -> string
-Microsoft.Build.Construction.ProjectPropertyElement.Name.set -> void
-Microsoft.Build.Construction.ProjectPropertyElement.Value.get -> string
-Microsoft.Build.Construction.ProjectPropertyElement.Value.set -> void
-Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectPropertyGroupElement.AddProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectPropertyGroupElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectPropertyGroupElement.PropertiesReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectPropertyGroupElement.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectRootElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectRootElement.AddImportGroup() -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemDefinitionGroup() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddProperty(string name, string value) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddTarget(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectRootElement.AddUsingTask(string name, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectRootElement.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.Construction.ProjectRootElement.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectRootElement.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectRootElement.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.Construction.ProjectRootElement.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.Construction.ProjectRootElement.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectRootElement.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.Construction.ProjectRootElement.DeepClone() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.get -> string
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.set -> void
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.DirectoryPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Encoding.get -> System.Text.Encoding
-Microsoft.Build.Construction.ProjectRootElement.EscapedFullPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.FullPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.FullPath.set -> void
-Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges.get -> bool
-Microsoft.Build.Construction.ProjectRootElement.ImportGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ImportGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
-Microsoft.Build.Construction.ProjectRootElement.InitialTargets.get -> string
-Microsoft.Build.Construction.ProjectRootElement.InitialTargets.set -> void
-Microsoft.Build.Construction.ProjectRootElement.InitialTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead.get -> System.DateTime
-Microsoft.Build.Construction.ProjectRootElement.PreserveFormatting.get -> bool
-Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectRootElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.PropertyGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.RawXml.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save() -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(string path) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(string path, System.Text.Encoding encoding) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(System.IO.TextWriter writer) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(System.Text.Encoding saveEncoding) -> void
-Microsoft.Build.Construction.ProjectRootElement.Sdk.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Sdk.set -> void
-Microsoft.Build.Construction.ProjectRootElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.Targets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTargetElement>
-Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged.get -> System.DateTime
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.get -> string
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.set -> void
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.get -> string
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.set -> void
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalPropertyLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.UsingTasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement>
-Microsoft.Build.Construction.ProjectRootElement.Version.get -> int
-Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.set -> void
-Microsoft.Build.Construction.ProjectSdkElement.Name.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.Name.set -> void
-Microsoft.Build.Construction.ProjectSdkElement.Version.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.Version.set -> void
-Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectTargetElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectTargetElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectTargetElement.AddTask(string taskName) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Inputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Inputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Name.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Name.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.NameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.OnErrors.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOnErrorElement>
-Microsoft.Build.Construction.ProjectTargetElement.Outputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Outputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectTargetElement.Returns.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Returns.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTaskElement>
-Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.GetParameter(string name) -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.Name.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.Outputs.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOutputElement>
-Microsoft.Build.Construction.ProjectTaskElement.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
-Microsoft.Build.Construction.ProjectTaskElement.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Construction.ProjectTaskElement.RemoveAllParameters() -> void
-Microsoft.Build.Construction.ProjectTaskElement.RemoveParameter(string name) -> void
-Microsoft.Build.Construction.ProjectTaskElement.SetParameter(string name, string unevaluatedValue) -> void
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.EvaluateLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.AddParameterGroup() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.AddUsingTaskBody(string evaluate, string taskBody) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.ArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.RuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskBody.get -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactoryLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.OutputLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.RequiredLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.Construction.ProjectWhenElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectWhenElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectWhenElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.SolutionConfigurationInSolution
-Microsoft.Build.Construction.SolutionConfigurationInSolution.ConfigurationName.get -> string
-Microsoft.Build.Construction.SolutionConfigurationInSolution.FullName.get -> string
-Microsoft.Build.Construction.SolutionConfigurationInSolution.PlatformName.get -> string
-Microsoft.Build.Construction.SolutionFile
-Microsoft.Build.Construction.SolutionFile.GetDefaultConfigurationName() -> string
-Microsoft.Build.Construction.SolutionFile.GetDefaultPlatformName() -> string
-Microsoft.Build.Construction.SolutionFile.ProjectsByGuid.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectInSolution>
-Microsoft.Build.Construction.SolutionFile.ProjectsInOrder.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.ProjectInSolution>
-Microsoft.Build.Construction.SolutionFile.SolutionConfigurations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.SolutionConfigurationInSolution>
-Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.EtpSubProject = 5 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.KnownToBeMSBuildFormat = 1 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.SharedProject = 6 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.SolutionFolder = 2 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.Unknown = 0 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.WebDeploymentProject = 4 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.WebProject = 3 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.Parameters.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskParameterElement>
-Microsoft.Build.Definition.ProjectOptions
-Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.get -> Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.set -> void
-Microsoft.Build.Definition.ProjectOptions.EvaluationContext.get -> Microsoft.Build.Evaluation.Context.EvaluationContext
-Microsoft.Build.Definition.ProjectOptions.EvaluationContext.set -> void
-Microsoft.Build.Definition.ProjectOptions.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Definition.ProjectOptions.GlobalProperties.set -> void
-Microsoft.Build.Definition.ProjectOptions.LoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Definition.ProjectOptions.LoadSettings.set -> void
-Microsoft.Build.Definition.ProjectOptions.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Definition.ProjectOptions.ProjectCollection.set -> void
-Microsoft.Build.Definition.ProjectOptions.ProjectOptions() -> void
-Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.get -> string
-Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.set -> void
-Microsoft.Build.Definition.ProjectOptions.ToolsVersion.get -> string
-Microsoft.Build.Definition.ProjectOptions.ToolsVersion.set -> void
-Microsoft.Build.Evaluation.Context.EvaluationContext
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Isolated = 1 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Shared = 0 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.GlobResult
-Microsoft.Build.Evaluation.GlobResult.Excludes.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.GlobResult(Microsoft.Build.Construction.ProjectItemElement itemElement, System.Collections.Generic.IEnumerable<string> includeGlobStrings, Microsoft.Build.Globbing.IMSBuildGlob globWithGaps, System.Collections.Generic.IEnumerable<string> excludeFragmentStrings, System.Collections.Generic.IEnumerable<string> removeFragmentStrings) -> void
-Microsoft.Build.Evaluation.GlobResult.IncludeGlobs.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.set -> void
-Microsoft.Build.Evaluation.GlobResult.Removes.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.Removes.set -> void
-Microsoft.Build.Evaluation.MatchOnMetadataConstants
-Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseInsensitive = 1 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive = 0 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.PathLike = 2 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeAllOptions = -1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeToolsVersion = 2 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlDeclaration = 1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlNamespace = 4 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.None = 0 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Exclude = 1 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Include = 0 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Remove = 3 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Update = 2 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.Project.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-Microsoft.Build.Evaluation.Project.Build() -> bool
-Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger logger) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
-Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-Microsoft.Build.Evaluation.Project.CreateProjectInstance() -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.DirectoryPath.get -> string
-Microsoft.Build.Evaluation.Project.DisableMarkDirty.get -> bool
-Microsoft.Build.Evaluation.Project.DisableMarkDirty.set -> void
-Microsoft.Build.Evaluation.Project.EvaluationCounter.get -> int
-Microsoft.Build.Evaluation.Project.ExpandString(string unexpandedValue) -> string
-Microsoft.Build.Evaluation.Project.FullPath.get -> string
-Microsoft.Build.Evaluation.Project.FullPath.set -> void
-Microsoft.Build.Evaluation.Project.GetAllGlobs() -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Evaluation.Project.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.Project.GetPropertyValue(string name) -> string
-Microsoft.Build.Evaluation.Project.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Evaluation.Project.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-Microsoft.Build.Evaluation.Project.IsBuildEnabled.get -> bool
-Microsoft.Build.Evaluation.Project.IsBuildEnabled.set -> void
-Microsoft.Build.Evaluation.Project.IsDirty.get -> bool
-Microsoft.Build.Evaluation.Project.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
-Microsoft.Build.Evaluation.Project.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Evaluation.Project.LastEvaluationId.get -> int
-Microsoft.Build.Evaluation.Project.MarkDirty() -> void
-Microsoft.Build.Evaluation.Project.Project() -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Evaluation.Project.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.Project.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary() -> void
-Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
-Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(string name) -> bool
-Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
-Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
-Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
-Microsoft.Build.Evaluation.Project.Save() -> void
-Microsoft.Build.Evaluation.Project.Save(string path) -> void
-Microsoft.Build.Evaluation.Project.Save(string path, System.Text.Encoding encoding) -> void
-Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter writer) -> void
-Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding encoding) -> void
-Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter writer) -> void
-Microsoft.Build.Evaluation.Project.SetGlobalProperty(string name, string escapedValue) -> bool
-Microsoft.Build.Evaluation.Project.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.Project.SkipEvaluation.get -> bool
-Microsoft.Build.Evaluation.Project.SkipEvaluation.set -> void
-Microsoft.Build.Evaluation.Project.SubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Project.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.get -> bool
-Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.set -> void
-Microsoft.Build.Evaluation.Project.ToolsVersion.get -> string
-Microsoft.Build.Evaluation.Project.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectChangedEventArgs
-Microsoft.Build.Evaluation.ProjectChangedEventArgs.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Evaluation.ProjectCollection.AddToolset(Microsoft.Build.Evaluation.Toolset toolset) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ContainsToolset(string toolsVersion) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.Count.get -> int
-Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.get -> string
-Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.Dispose() -> void
-Microsoft.Build.Evaluation.ProjectCollection.GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject) -> string
-Microsoft.Build.Evaluation.ProjectCollection.GetGlobalProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Evaluation.ProjectCollection.GetLoadedProjects(string fullPath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-Microsoft.Build.Evaluation.ProjectCollection.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Evaluation.ProjectCollection.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Evaluation.ProjectCollection.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Evaluation.ProjectCollection.HostServices.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.LoadedProjects.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.Loggers.get -> System.Collections.Generic.ICollection<Microsoft.Build.Framework.ILogger>
-Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAdded -> Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectRootElement.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection() -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.RegisterForwardingLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger(Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RegisterLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RemoveAllToolsets() -> void
-Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty(string name) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.RemoveToolset(string toolsVersion) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty(string name, string value) -> void
-Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.ToolsetLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ProjectCollection.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
-Microsoft.Build.Evaluation.ProjectCollection.TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.UnloadAllProjects() -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Evaluation.Project project) -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnregisterAllLoggers() -> void
-Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs
-Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs.Changed.get -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.DefaultToolsVersion = 0 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.DisableMarkDirty = 7 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.GlobalProperties = 3 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.HostServices = 6 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.IsBuildEnabled = 4 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.Loggers = 2 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.OnlyLogCriticalEvents = 5 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.SkipEvaluation = 8 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.Toolsets = 1 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectItem
-Microsoft.Build.Evaluation.ProjectItem.DirectMetadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude.get -> string
-Microsoft.Build.Evaluation.ProjectItem.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(string name) -> string
-Microsoft.Build.Evaluation.ProjectItem.HasMetadata(string name) -> bool
-Microsoft.Build.Evaluation.ProjectItem.IsImported.get -> bool
-Microsoft.Build.Evaluation.ProjectItem.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectItem.ItemType.set -> void
-Microsoft.Build.Evaluation.ProjectItem.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItem.MetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItem.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(string name) -> bool
-Microsoft.Build.Evaluation.ProjectItem.Rename(string name) -> void
-Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.get -> string
-Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.set -> void
-Microsoft.Build.Evaluation.ProjectItem.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.ProjectItemDefinition
-Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadataValue(string name) -> string
-Microsoft.Build.Evaluation.ProjectItemDefinition.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectItemDefinition.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItemDefinition.MetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItemDefinition.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectItemDefinition.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.Default = 0 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.DoNotEvaluateElementsWithFalseCondition = 32 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.FailOnUnresolvedSdk = 256 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreEmptyImports = 16 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports = 64 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports = 1 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.ProfileEvaluation = 128 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RecordDuplicateButNotCircularImports = 2 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements = 8 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RejectCircularImports = 4 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectMetadata.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.IsImported.get -> bool
-Microsoft.Build.Evaluation.ProjectMetadata.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.ProjectMetadata.Name.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectMetadata.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.set -> void
-Microsoft.Build.Evaluation.ProjectMetadata.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.ProjectProperty.EvaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectProperty.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.ProjectXml.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.Reason.get -> string
-Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Glob = 2 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Inconclusive = 4 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.StringLiteral = 1 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Undefined = 0 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.ProvenanceResult
-Microsoft.Build.Evaluation.ProvenanceResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.ProvenanceResult.Occurrences.get -> int
-Microsoft.Build.Evaluation.ProvenanceResult.Operation.get -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.ProvenanceResult.Provenance.get -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.ProvenanceResult.ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElement, Microsoft.Build.Evaluation.Operation operation, Microsoft.Build.Evaluation.Provenance provenance, int occurrences) -> void
-Microsoft.Build.Evaluation.ResolvedImport
-Microsoft.Build.Evaluation.ResolvedImport.ImportedProject.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ResolvedImport.ImportingElement.get -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Evaluation.ResolvedImport.IsImported.get -> bool
-Microsoft.Build.Evaluation.ResolvedImport.ResolvedImport() -> void
-Microsoft.Build.Evaluation.ResolvedImport.SdkResult.get -> Microsoft.Build.Framework.SdkResult
-Microsoft.Build.Evaluation.SubToolset
-Microsoft.Build.Evaluation.SubToolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Evaluation.SubToolset.SubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Evaluation.Toolset.DefaultSubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion() -> string
-Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion(System.Collections.Generic.IDictionary<string, string> overrideGlobalProperties, int solutionVersion) -> string
-Microsoft.Build.Evaluation.Toolset.GetProperty(string propertyName, string subToolsetVersion) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Evaluation.Toolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Evaluation.Toolset.SubToolsets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset>
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> subToolsets, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.ToolsPath.get -> string
-Microsoft.Build.Evaluation.Toolset.ToolsVersion.get -> string
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile = 1 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Default = Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile | Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Local = 4 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.None = 0 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry = 2 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Exceptions.BuildAbortedException
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException() -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.CircularDependencyException
-Microsoft.Build.Exceptions.CircularDependencyException.CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Exceptions.InternalLoggerException
-Microsoft.Build.Exceptions.InternalLoggerException.BuildEventArgs.get -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Exceptions.InternalLoggerException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InternalLoggerException.HelpKeyword.get -> string
-Microsoft.Build.Exceptions.InternalLoggerException.InitializationException.get -> bool
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException() -> void
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message) -> void
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException
-Microsoft.Build.Exceptions.InvalidProjectFileException.BaseMessage.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.ColumnNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.EndColumnNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.EndLineNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorSubcategory.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.HasBeenLogged.get -> bool
-Microsoft.Build.Exceptions.InvalidProjectFileException.HelpKeyword.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException() -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.LineNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.ProjectFile.get -> string
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException() -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) -> void
-Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) -> void
-Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Execution.BuildManager.BuildManager() -> void
-Microsoft.Build.Execution.BuildManager.BuildManager(string hostName) -> void
-Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Execution.BuildManager.CancelAllSubmissions() -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage() -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Importance.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Text.get -> string
-Microsoft.Build.Execution.BuildManager.Dispose() -> void
-Microsoft.Build.Execution.BuildManager.EndBuild() -> void
-Microsoft.Build.Execution.BuildManager.GetProjectInstanceForBuild(Microsoft.Build.Evaluation.Project project) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildSubmission
-Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildSubmission
-Microsoft.Build.Execution.BuildManager.ResetCaches() -> void
-Microsoft.Build.Execution.BuildManager.ShutdownAllNodes() -> void
-Microsoft.Build.Execution.BuildManager.~BuildManager() -> void
-Microsoft.Build.Execution.BuildParameters
-Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.get -> bool
-Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.set -> void
-Microsoft.Build.Execution.BuildParameters.BuildParameters() -> void
-Microsoft.Build.Execution.BuildParameters.BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.BuildParameters.BuildProcessEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Threading.ThreadPriority
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.Clone() -> Microsoft.Build.Execution.BuildParameters
-Microsoft.Build.Execution.BuildParameters.Culture.get -> System.Globalization.CultureInfo
-Microsoft.Build.Execution.BuildParameters.Culture.set -> void
-Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.get -> string
-Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.set -> void
-Microsoft.Build.Execution.BuildParameters.DetailedSummary.get -> bool
-Microsoft.Build.Execution.BuildParameters.DetailedSummary.set -> void
-Microsoft.Build.Execution.BuildParameters.DisableInProcNode.get -> bool
-Microsoft.Build.Execution.BuildParameters.DisableInProcNode.set -> void
-Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.get -> bool
-Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.set -> void
-Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.get -> bool
-Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.set -> void
-Microsoft.Build.Execution.BuildParameters.EnvironmentProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord>
-Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.set -> void
-Microsoft.Build.Execution.BuildParameters.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Execution.BuildParameters.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.GlobalProperties.set -> void
-Microsoft.Build.Execution.BuildParameters.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.BuildParameters.HostServices.set -> void
-Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.get -> string[]
-Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.set -> void
-Microsoft.Build.Execution.BuildParameters.Interactive.get -> bool
-Microsoft.Build.Execution.BuildParameters.Interactive.set -> void
-Microsoft.Build.Execution.BuildParameters.IsolateProjects.get -> bool
-Microsoft.Build.Execution.BuildParameters.IsolateProjects.set -> void
-Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.get -> bool
-Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.set -> void
-Microsoft.Build.Execution.BuildParameters.Loggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger>
-Microsoft.Build.Execution.BuildParameters.Loggers.set -> void
-Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.get -> bool
-Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.set -> void
-Microsoft.Build.Execution.BuildParameters.LogTaskInputs.get -> bool
-Microsoft.Build.Execution.BuildParameters.LogTaskInputs.set -> void
-Microsoft.Build.Execution.BuildParameters.LowPriority.get -> bool
-Microsoft.Build.Execution.BuildParameters.LowPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.MaxNodeCount.get -> int
-Microsoft.Build.Execution.BuildParameters.MaxNodeCount.set -> void
-Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.get -> int
-Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.set -> void
-Microsoft.Build.Execution.BuildParameters.NodeExeLocation.get -> string
-Microsoft.Build.Execution.BuildParameters.NodeExeLocation.set -> void
-Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.get -> string
-Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.set -> void
-Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.set -> void
-Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.set -> void
-Microsoft.Build.Execution.BuildParameters.ResetCaches.get -> bool
-Microsoft.Build.Execution.BuildParameters.ResetCaches.set -> void
-Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.get -> bool
-Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.set -> void
-Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.get -> bool
-Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.set -> void
-Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.set -> void
-Microsoft.Build.Execution.BuildParameters.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
-Microsoft.Build.Execution.BuildParameters.UICulture.get -> System.Globalization.CultureInfo
-Microsoft.Build.Execution.BuildParameters.UICulture.set -> void
-Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.get -> bool
-Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
-Microsoft.Build.Execution.BuildRequestData
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
-Microsoft.Build.Execution.BuildRequestData.ExplicitlySpecifiedToolsVersion.get -> string
-Microsoft.Build.Execution.BuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestData.GlobalProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Execution.BuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.BuildRequestData.ProjectFullPath.get -> string
-Microsoft.Build.Execution.BuildRequestData.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildRequestData.PropertiesToTransfer.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Execution.BuildRequestData.RequestedProjectState.get -> Microsoft.Build.Execution.RequestedProjectState
-Microsoft.Build.Execution.BuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild = 8 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.FailOnUnresolvedSdk = 128 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState = 4 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports = 64 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.None = 0 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild = 2 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild = 32 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance = 1 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets = 16 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildResult.AddResultsForTarget(string target, Microsoft.Build.Execution.TargetResult result) -> void
-Microsoft.Build.Execution.BuildResult.BuildResult() -> void
-Microsoft.Build.Execution.BuildResult.CircularDependency.get -> bool
-Microsoft.Build.Execution.BuildResult.ConfigurationId.get -> int
-Microsoft.Build.Execution.BuildResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.BuildResult.GlobalRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.HasResultsForTarget(string target) -> bool
-Microsoft.Build.Execution.BuildResult.MergeResults(Microsoft.Build.Execution.BuildResult results) -> void
-Microsoft.Build.Execution.BuildResult.NodeRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResult.ParentGlobalRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.set -> void
-Microsoft.Build.Execution.BuildResult.ResultsByTarget.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>
-Microsoft.Build.Execution.BuildResult.SubmissionId.get -> int
-Microsoft.Build.Execution.BuildResult.this[string target].get -> Microsoft.Build.Execution.ITargetResult
-Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResultCode.Failure = 1 -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResultCode.Success = 0 -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildSubmission
-Microsoft.Build.Execution.BuildSubmission.AsyncContext.get -> object
-Microsoft.Build.Execution.BuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Execution.BuildSubmission.BuildResult.get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildSubmission.BuildResult.set -> void
-Microsoft.Build.Execution.BuildSubmission.Execute() -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback callback, object context) -> void
-Microsoft.Build.Execution.BuildSubmission.IsCompleted.get -> bool
-Microsoft.Build.Execution.BuildSubmission.SubmissionId.get -> int
-Microsoft.Build.Execution.BuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
-Microsoft.Build.Execution.BuildSubmissionCompleteCallback
-Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.HostServices.GetHostObject(string projectFile, string targetName, string taskName) -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Execution.HostServices.GetNodeAffinity(string projectFile) -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.HostServices.HostServices() -> void
-Microsoft.Build.Execution.HostServices.OnRenameProject(string oldFullPath, string newFullPath) -> void
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) -> void
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
-Microsoft.Build.Execution.HostServices.SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) -> void
-Microsoft.Build.Execution.HostServices.UnregisterProject(string projectFullPath) -> void
-Microsoft.Build.Execution.ITargetResult
-Microsoft.Build.Execution.ITargetResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.ITargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Execution.ITargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.Any = 2 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.InProc = 0 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.OutOfProc = 1 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.BuildComplete = 0 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.BuildCompleteReuse = 1 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.ConnectionFailed = 2 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.Error = 3 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode
-Microsoft.Build.Execution.OutOfProcNode.OutOfProcNode() -> void
-Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude) -> Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectInstance.Build() -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.DeepCopy() -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.DeepCopy(bool isImmutable) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.DefaultTargets.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.ProjectInstance.Directory.get -> string
-Microsoft.Build.Execution.ProjectInstance.EvaluateCondition(string condition) -> bool
-Microsoft.Build.Execution.ProjectInstance.EvaluatedItemElements.get -> System.Collections.Generic.List<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Execution.ProjectInstance.EvaluationId.get -> int
-Microsoft.Build.Execution.ProjectInstance.EvaluationId.set -> void
-Microsoft.Build.Execution.ProjectInstance.ExpandString(string unexpandedValue) -> string
-Microsoft.Build.Execution.ProjectInstance.FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.FullPath.get -> string
-Microsoft.Build.Execution.ProjectInstance.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.GetProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectInstance.GetPropertyValue(string name) -> string
-Microsoft.Build.Execution.ProjectInstance.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.ProjectInstance.ImportPaths.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Execution.ProjectInstance.ImportPathsIncludingDuplicates.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Execution.ProjectInstance.InitialTargets.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.ProjectInstance.IsImmutable.get -> bool
-Microsoft.Build.Execution.ProjectInstance.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance>
-Microsoft.Build.Execution.ProjectInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.ProjectInstance.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Execution.ProjectInstance.RemoveItem(Microsoft.Build.Execution.ProjectItemInstance item) -> bool
-Microsoft.Build.Execution.ProjectInstance.RemoveProperty(string name) -> bool
-Microsoft.Build.Execution.ProjectInstance.SetProperty(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectInstance.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-Microsoft.Build.Execution.ProjectInstance.ToolsVersion.get -> string
-Microsoft.Build.Execution.ProjectInstance.ToProjectRootElement() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.get -> bool
-Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.set -> void
-Microsoft.Build.Execution.ProjectInstance.UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectState) -> void
-Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.Immutable = 1 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.ImmutableWithFastItemLookup = 3 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.None = 0 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectItemDefinitionInstance
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectMetadataInstance>
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataNames.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Execution.ProjectItemGroupTaskInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance>
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Exclude.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Include.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicates.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptions.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance>
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Remove.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Value.get -> string
-Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectItemInstance.DirectMetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.get -> string
-Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.set -> void
-Microsoft.Build.Execution.ProjectItemInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemInstance.GetMetadataValue(string name) -> string
-Microsoft.Build.Execution.ProjectItemInstance.HasMetadata(string name) -> bool
-Microsoft.Build.Execution.ProjectItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemInstance.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectMetadataInstance>
-Microsoft.Build.Execution.ProjectItemInstance.MetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemInstance.MetadataNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.ProjectItemInstance.Project.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectItemInstance.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadataDictionary) -> void
-Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectMetadataInstance.DeepClone() -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectMetadataInstance.EvaluatedValue.get -> string
-Microsoft.Build.Execution.ProjectMetadataInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectOnErrorInstance
-Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargets.get -> string
-Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance
-Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance>
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Value.get -> string
-Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.get -> string
-Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.set -> void
-Microsoft.Build.Execution.ProjectPropertyInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance
-Microsoft.Build.Execution.ProjectTargetInstance.AfterTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Children.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTargetInstanceChild>
-Microsoft.Build.Execution.ProjectTargetInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.FullPath.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.Inputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.OnErrorChildren.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectOnErrorInstance>
-Microsoft.Build.Execution.ProjectTargetInstance.Outputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Returns.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectTaskInstance>
-Microsoft.Build.Execution.ProjectTargetInstanceChild
-Microsoft.Build.Execution.ProjectTargetInstanceChild.FullPath.get -> string
-Microsoft.Build.Execution.ProjectTargetInstanceChild.ProjectTargetInstanceChild() -> void
-Microsoft.Build.Execution.ProjectTaskInstance
-Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnError.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitecture.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntime.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.Outputs.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTaskInstanceChild>
-Microsoft.Build.Execution.ProjectTaskInstance.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.ProjectTaskInstanceChild
-Microsoft.Build.Execution.ProjectTaskInstanceChild.ProjectTaskInstanceChild() -> void
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameter.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyName.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameter.get -> string
-Microsoft.Build.Execution.RequestedProjectState
-Microsoft.Build.Execution.RequestedProjectState.ItemFilters.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-Microsoft.Build.Execution.RequestedProjectState.ItemFilters.set -> void
-Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.set -> void
-Microsoft.Build.Execution.RequestedProjectState.RequestedProjectState() -> void
-Microsoft.Build.Execution.TargetResult
-Microsoft.Build.Execution.TargetResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.TargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Execution.TargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Failure = 2 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Skipped = 0 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Success = 1 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Experimental.ProjectCache.CacheContext
-Microsoft.Build.Experimental.ProjectCache.CacheContext.CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) -> void
-Microsoft.Build.Experimental.ProjectCache.CacheContext.FileSystem.get -> Microsoft.Build.FileSystem.MSBuildFileSystemBase
-Microsoft.Build.Experimental.ProjectCache.CacheContext.Graph.get -> Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Experimental.ProjectCache.CacheContext.GraphEntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.CacheContext.MSBuildExePath.get -> string
-Microsoft.Build.Experimental.ProjectCache.CacheContext.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.CacheResult
-Microsoft.Build.Experimental.ProjectCache.CacheResult.BuildResult.get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Experimental.ProjectCache.CacheResult.ProxyTargets.get -> Microsoft.Build.Experimental.ProjectCache.ProxyTargets
-Microsoft.Build.Experimental.ProjectCache.CacheResult.ResultType.get -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheHit = 1 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheMiss = 2 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheNotApplicable = 3 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.None = 0 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase() -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult() -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
-Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
-Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.ProjectCachePluginBase() -> void
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) -> void
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargetToRealTargetMap.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.FileSystem.FindPredicate
-Microsoft.Build.FileSystem.FindTransform<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache
-Microsoft.Build.FileSystem.IDirectoryCache.DirectoryExists(string path) -> bool
-Microsoft.Build.FileSystem.IDirectoryCache.EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache.EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache.FileExists(string path) -> bool
-Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
-Microsoft.Build.FileSystem.MSBuildFileSystemBase
-Microsoft.Build.FileSystem.MSBuildFileSystemBase.MSBuildFileSystemBase() -> void
-Microsoft.Build.Globbing.CompositeGlob
-Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) -> void
-Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> void
-Microsoft.Build.Globbing.CompositeGlob.Globs.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob>
-Microsoft.Build.Globbing.CompositeGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions
-Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.IMSBuildGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlob.FilenamePart.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.FixedDirectoryPart.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.IsLegal.get -> bool
-Microsoft.Build.Globbing.MSBuildGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(string stringToMatch) -> Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FilenamePartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FixedDirectoryPartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.IsMatch.get -> bool
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.MatchInfoResult() -> void
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.WildcardDirectoryPartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.WildcardDirectoryPart.get -> string
-Microsoft.Build.Globbing.MSBuildGlobWithGaps
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.Gaps.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MainGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, params Microsoft.Build.Globbing.IMSBuildGlob[] gaps) -> void
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> gaps) -> void
-Microsoft.Build.Graph.GraphBuildOptions
-Microsoft.Build.Graph.GraphBuildOptions.Build.get -> bool
-Microsoft.Build.Graph.GraphBuildOptions.Build.init -> void
-Microsoft.Build.Graph.GraphBuildRequestData
-Microsoft.Build.Graph.GraphBuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildOptions.get -> Microsoft.Build.Graph.GraphBuildOptions
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraphEntryPoints.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Graph.GraphBuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildResult.CircularDependency.get -> bool
-Microsoft.Build.Graph.GraphBuildResult.Exception.get -> System.Exception
-Microsoft.Build.Graph.GraphBuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Graph.GraphBuildResult.ResultsByNode.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, Microsoft.Build.Execution.BuildResult>
-Microsoft.Build.Graph.GraphBuildResult.SubmissionId.get -> int
-Microsoft.Build.Graph.GraphBuildResult.this[Microsoft.Build.Graph.ProjectGraphNode node].get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Graph.GraphBuildSubmission
-Microsoft.Build.Graph.GraphBuildSubmission.AsyncContext.get -> object
-Microsoft.Build.Graph.GraphBuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Graph.GraphBuildSubmission.BuildResult.get -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildSubmission.Execute() -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildSubmission.ExecuteAsync(Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback callback, object context) -> void
-Microsoft.Build.Graph.GraphBuildSubmission.IsCompleted.get -> bool
-Microsoft.Build.Graph.GraphBuildSubmission.SubmissionId.get -> int
-Microsoft.Build.Graph.GraphBuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
-Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback
-Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Graph.ProjectGraph.ConstructionMetrics.get -> Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
-Microsoft.Build.Graph.ProjectGraph.EntryPointNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>>
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.ConstructionTime.get -> System.TimeSpan
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.EdgeCount.get -> int
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics() -> void
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) -> void
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.NodeCount.get -> int
-Microsoft.Build.Graph.ProjectGraph.GraphRoots.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, int degreeOfParallelism, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc
-Microsoft.Build.Graph.ProjectGraph.ProjectNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.ProjectNodesTopologicallySorted.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraphEntryPoint
-Microsoft.Build.Graph.ProjectGraphEntryPoint.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectFile.get -> string
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint() -> void
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile) -> void
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraphNode
-Microsoft.Build.Graph.ProjectGraphNode.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Graph.ProjectGraphNode.ProjectReferences.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraphNode.ReferencingProjects.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Logging.BinaryLogger
-Microsoft.Build.Logging.BinaryLogger.BinaryLogger() -> void
-Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.get -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.set -> void
-Microsoft.Build.Logging.BinaryLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.BinaryLogger.Parameters.get -> string
-Microsoft.Build.Logging.BinaryLogger.Parameters.set -> void
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.Embed = 1 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.None = 0 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.ZipFile = 2 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.Shutdown() -> void
-Microsoft.Build.Logging.BinaryLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.BinaryLogger.Verbosity.set -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource
-Microsoft.Build.Logging.BinaryLogReplayEventSource.BinaryLogReplayEventSource() -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath) -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Logging.BuildEventArgsReader
-Microsoft.Build.Logging.BuildEventArgsReader.BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) -> void
-Microsoft.Build.Logging.BuildEventArgsReader.Dispose() -> void
-Microsoft.Build.Logging.BuildEventArgsReader.Read() -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Logging.ColorResetter
-Microsoft.Build.Logging.ColorSetter
-Microsoft.Build.Logging.ConfigurableForwardingLogger
-Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.ConfigurableForwardingLogger() -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.get -> int
-Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.get -> string
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.set -> void
-Microsoft.Build.Logging.ConsoleLogger
-Microsoft.Build.Logging.ConsoleLogger.ApplyParameter(string parameterName, string parameterValue) -> void
-Microsoft.Build.Logging.ConsoleLogger.BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger() -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.Logging.WriteHandler write, Microsoft.Build.Logging.ColorSetter colorSet, Microsoft.Build.Logging.ColorResetter colorReset) -> void
-Microsoft.Build.Logging.ConsoleLogger.CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.Parameters.get -> string
-Microsoft.Build.Logging.ConsoleLogger.Parameters.set -> void
-Microsoft.Build.Logging.ConsoleLogger.ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ShowSummary.get -> bool
-Microsoft.Build.Logging.ConsoleLogger.ShowSummary.set -> void
-Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.get -> bool
-Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.set -> void
-Microsoft.Build.Logging.ConsoleLogger.TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ConsoleLogger.Verbosity.set -> void
-Microsoft.Build.Logging.ConsoleLogger.WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.WriteHandler.get -> Microsoft.Build.Logging.WriteHandler
-Microsoft.Build.Logging.ConsoleLogger.WriteHandler.set -> void
-Microsoft.Build.Logging.DistributedFileLogger
-Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.DistributedFileLogger() -> void
-Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Logging.DistributedFileLogger.NodeId.get -> int
-Microsoft.Build.Logging.DistributedFileLogger.NodeId.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.Parameters.get -> string
-Microsoft.Build.Logging.DistributedFileLogger.Parameters.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.Shutdown() -> void
-Microsoft.Build.Logging.DistributedFileLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.DistributedFileLogger.Verbosity.set -> void
-Microsoft.Build.Logging.EventArgsDispatcher
-Microsoft.Build.Logging.EventArgsDispatcher.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.Dispatch(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
-Microsoft.Build.Logging.EventArgsDispatcher.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.EventArgsDispatcher() -> void
-Microsoft.Build.Logging.EventArgsDispatcher.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Logging.FileLogger
-Microsoft.Build.Logging.FileLogger.FileLogger() -> void
-Microsoft.Build.Logging.ForwardingLoggerRecord
-Microsoft.Build.Logging.ForwardingLoggerRecord.CentralLogger.get -> Microsoft.Build.Framework.ILogger
-Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerDescription.get -> Microsoft.Build.Logging.LoggerDescription
-Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerRecord(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.Logging.LoggerDescription forwardingLoggerDescription) -> void
-Microsoft.Build.Logging.LoggerDescription
-Microsoft.Build.Logging.LoggerDescription.CreateLogger() -> Microsoft.Build.Framework.ILogger
-Microsoft.Build.Logging.LoggerDescription.IsOptional.get -> bool
-Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity, bool isOptional) -> void
-Microsoft.Build.Logging.LoggerDescription.LoggerSwitchParameters.get -> string
-Microsoft.Build.Logging.LoggerDescription.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ProfilerLogger
-Microsoft.Build.Logging.ProfilerLogger.FileToLog.get -> string
-Microsoft.Build.Logging.ProfilerLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.ProfilerLogger.Parameters.get -> string
-Microsoft.Build.Logging.ProfilerLogger.Parameters.set -> void
-Microsoft.Build.Logging.ProfilerLogger.ProfilerLogger(string fileToLog) -> void
-Microsoft.Build.Logging.ProfilerLogger.Shutdown() -> void
-Microsoft.Build.Logging.ProfilerLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ProfilerLogger.Verbosity.set -> void
-Microsoft.Build.Logging.WriteHandler
-Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider
-Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.ExternalProjectsProvider() -> void
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Collection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.Construction.ProjectImportElement importingElement, Microsoft.Build.Construction.ProjectRootElement importedProject, int versionEvaluated, Microsoft.Build.Framework.SdkResult sdkResult, bool isImported) -> Microsoft.Build.Evaluation.ResolvedImport
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink link) -> Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink link) -> Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink link) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectItemDefinition
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) -> Microsoft.Build.Evaluation.ProjectItem
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) -> Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) -> Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink link) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink link) -> Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink.ProjectChooseElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.ProjectElementContainerLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ProjectElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.ProjectExtensionsElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ProjectImportElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink.ProjectImportGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink.ProjectItemDefinitionElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink.ProjectItemDefinitionGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ProjectItemDefinitionLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ProjectItemElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink.ProjectItemGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ProjectItemLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectLink
-Microsoft.Build.ObjectModelRemoting.ProjectLink.ProjectLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ProjectMetadataElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.ProjectMetadataLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink.ProjectOnErrorElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink.ProjectOtherwiseElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink.ProjectOutputElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ProjectPropertyElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink.ProjectPropertyGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.ProjectPropertyLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectRootElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink.ProjectSdkElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.ProjectTargetElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ProjectTaskElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.ProjectUsingTaskBodyElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink.ProjectUsingTaskElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.ProjectUsingTaskParameterElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink.ProjectWhenElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink
-Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink.UsingTaskParameterGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.LocalName.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.NamespaceURI.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.Value.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink() -> void
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink(string localName, string value, string namespaceUri) -> void
-override Microsoft.Build.Construction.ElementLocation.Equals(object obj) -> bool
-override Microsoft.Build.Construction.ElementLocation.GetHashCode() -> int
-override Microsoft.Build.Construction.ElementLocation.ToString() -> string
-override Microsoft.Build.Construction.ProjectChooseElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectChooseElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectChooseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectExtensionsElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectExtensionsElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectItemElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectItemGroupElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectOtherwiseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectRootElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectRootElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectRootElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectTargetElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectTaskElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.get -> string
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.set -> void
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Exceptions.BuildAbortedException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InvalidProjectFileException.Message.get -> string
-override Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectItemInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectMetadataInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectOnErrorInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectOnErrorInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectOnErrorInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-override Microsoft.Build.Logging.FileLogger.Shutdown() -> void
-static Microsoft.Build.Construction.ProjectRootElement.Create() -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.SolutionFile.Parse(string solutionFile) -> Microsoft.Build.Construction.SolutionFile
-static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) -> Microsoft.Build.Evaluation.Context.EvaluationContext
-static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) -> Microsoft.Build.Evaluation.Context.EvaluationContext
-static Microsoft.Build.Evaluation.Project.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem item) -> string
-static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem item, string name) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadatum) -> string
-static Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.DisplayVersion.get -> string
-static Microsoft.Build.Evaluation.ProjectCollection.Escape(string unescapedString) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-static Microsoft.Build.Evaluation.ProjectCollection.Unescape(string escapedString) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.Version.get -> System.Version
-static Microsoft.Build.Execution.BuildManager.DefaultBuildManager.get -> Microsoft.Build.Execution.BuildManager
-static Microsoft.Build.Execution.ProjectInstance.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
-static Microsoft.Build.Execution.ProjectInstance.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
-static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item, string name) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemInstance item, string name) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectMetadataInstance metadatum) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetPropertyValueEscaped(Microsoft.Build.Execution.ProjectPropertyInstance property) -> string
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
-static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
-static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
-static Microsoft.Build.Globbing.MSBuildGlob.Parse(string globRoot, string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
-static Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.SetExternalProjectsProvider(Microsoft.Build.Evaluation.ProjectCollection collection, Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider link) -> void
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Get(Microsoft.Build.Evaluation.ProjectCollection collection) -> Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLink(object obj) -> object
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project>
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.IsLocal(object obj) -> bool
-static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectElement child) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectElement xml, Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(Microsoft.Build.Construction.ProjectElement xml, string attributeName) -> Microsoft.Build.Construction.ElementLocation
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributes(Microsoft.Build.Construction.ProjectElement xml) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(Microsoft.Build.Construction.ProjectElement xml, string attributeName, bool nullIfNotExists) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml) -> bool
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetPureText(Microsoft.Build.Construction.ProjectElement xml) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.MarkDirty(Microsoft.Build.Construction.ProjectElement xml, string reason, string param) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml, bool value) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(Microsoft.Build.Construction.ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetParent(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> object
-static Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
-virtual Microsoft.Build.Construction.ProjectElement.Condition.get -> string
-virtual Microsoft.Build.Construction.ProjectElement.Condition.set -> void
-virtual Microsoft.Build.Construction.ProjectElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-virtual Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-virtual Microsoft.Build.Construction.ProjectElementContainer.DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) -> void
-virtual Microsoft.Build.Evaluation.ProjectCollection.Dispose(bool disposing) -> void
-virtual Microsoft.Build.Execution.ProjectPropertyInstance.IsImmutable.get -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.DirectoryExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileOrDirectoryExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetAttributes(string path) -> System.IO.FileAttributes
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) -> System.IO.Stream
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetLastWriteTimeUtc(string path) -> System.DateTime
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFile(string path) -> System.IO.TextReader
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllBytes(string path) -> byte[]
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllText(string path) -> string
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) -> void
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index 47780d37b51..00000000000
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging, bool reuseProjectRootElementCache) -> void
-Microsoft.Build.Experimental.MSBuildClient
-Microsoft.Build.Experimental.MSBuildClient.Execute(System.Threading.CancellationToken cancellationToken) -> Microsoft.Build.Experimental.MSBuildClientExitResult
-Microsoft.Build.Experimental.MSBuildClient.MSBuildClient(string commandLine, string msbuildLocation) -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.get -> string
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.set -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitResult() -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.get -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.set -> void
-Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.LaunchError = 3 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.ServerBusy = 1 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.Success = 0 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.UnableToConnect = 2 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.Unexpected = 4 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.OutOfProcServerNode
-Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
-Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
-Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-static Microsoft.Build.Experimental.MSBuildClient.ShutdownServer(System.Threading.CancellationToken cancellationToken) -> bool
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index 38f8853c43d..00000000000
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,1836 +0,0 @@
-abstract Microsoft.Build.Construction.ElementLocation.Column.get -> int
-abstract Microsoft.Build.Construction.ElementLocation.File.get -> string
-abstract Microsoft.Build.Construction.ElementLocation.Line.get -> int
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsEnvironmentProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsGlobalProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsImported.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsReservedProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.Name.get -> string
-abstract Microsoft.Build.Evaluation.ProjectProperty.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.get -> string
-abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.set -> void
-abstract Microsoft.Build.Evaluation.ProjectProperty.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Condition.get -> string
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Condition.get -> string
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.get -> bool
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.set -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogError(string error) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = null) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogWarning(string warning) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult>
-abstract Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.GetLoadedProjects(string filePath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElement child) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.Count.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.LastChild.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Attributes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ElementName.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(string attributeName) -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(string attributeName, bool nullIfNotExists) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.OuterElement.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PureText.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.GetSubElement(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.SetSubElement(string name, string value) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadataValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ItemType.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ChangeItemType(string newType) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ChangeItemType(string newItemType) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.DirectMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.EvaluatedInclude.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadataValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.HasMetadata(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.MetadataCollection.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.RemoveMetadata(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Rename(string name) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ExpandString(string unexpandedValue) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetPropertyValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsDirty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.LastEvaluationId.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.MarkDirty() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveGlobalProperty(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SaveLogicalProject(System.IO.TextWriter writer) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetGlobalProperty(string name, string escapedValue) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SubToolsetVersion.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ToolsVersion.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Unload() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ChangeName(string newName) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.EvaluatedValueEscaped.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Parent.get -> object
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ChangeName(string newName) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.EvaluatedIncludeEscaped.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsEnvironmentProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsGlobalProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsImported.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsReservedProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.DirectoryPath.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Encoding.get -> System.Text.Encoding
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.HasUnsavedChanges.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.LastWriteTimeWhenRead.get -> System.DateTime
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.MarkDirty(string reason, string param) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.PreserveFormatting.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.RawXml.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.IO.TextWriter writer) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.Text.Encoding saveEncoding) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.TimeLastChanged.get -> System.DateTime
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Version.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Returns.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.GetParameter(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveAllParameters() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveParameter(string name) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.SetParameter(string name, string unevaluatedValue) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.set -> void
-const Microsoft.Build.Evaluation.MatchOnMetadataConstants.MatchOnMetadataOptionsDefaultValue = Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Resolver.get -> Microsoft.Build.Framework.SdkResolver
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Sdk.get -> Microsoft.Build.Framework.SdkReference
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.SdkResolverException(string resourceName, Microsoft.Build.Framework.SdkResolver resolver, Microsoft.Build.Framework.SdkReference sdk, System.Exception innerException, params string[] args) -> void
-Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ElementLocation.ElementLocation() -> void
-Microsoft.Build.Construction.ElementLocation.LocationString.get -> string
-Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.Bottom = 2 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.None = 0 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.Top = 1 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.Construction.ProjectChooseElement.OtherwiseElement.get -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectChooseElement.WhenElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectWhenElement>
-Microsoft.Build.Construction.ProjectConfigurationInSolution
-Microsoft.Build.Construction.ProjectConfigurationInSolution.ConfigurationName.get -> string
-Microsoft.Build.Construction.ProjectConfigurationInSolution.FullName.get -> string
-Microsoft.Build.Construction.ProjectConfigurationInSolution.IncludeInBuild.get -> bool
-Microsoft.Build.Construction.ProjectConfigurationInSolution.PlatformName.get -> string
-Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.AllParents.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElementContainer>
-Microsoft.Build.Construction.ProjectElement.Clone() -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectElement.ElementName.get -> string
-Microsoft.Build.Construction.ProjectElement.Label.get -> string
-Microsoft.Build.Construction.ProjectElement.Label.set -> void
-Microsoft.Build.Construction.ProjectElement.LabelLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectElement.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectElement.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.OuterElement.get -> string
-Microsoft.Build.Construction.ProjectElement.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
-Microsoft.Build.Construction.ProjectElement.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer
-Microsoft.Build.Construction.ProjectElementContainer.AllChildren.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectElementContainer.Children.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.ChildrenReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.Count.get -> int
-Microsoft.Build.Construction.ProjectElementContainer.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-Microsoft.Build.Construction.ProjectElementContainer.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-Microsoft.Build.Construction.ProjectElementContainer.LastChild.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer.PrependChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectElementContainer.RemoveAllChildren() -> void
-Microsoft.Build.Construction.ProjectElementContainer.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.Construction.ProjectExtensionsElement.Content.get -> string
-Microsoft.Build.Construction.ProjectExtensionsElement.Content.set -> void
-Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].get -> string
-Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].set -> void
-Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.get -> string
-Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.set -> void
-Microsoft.Build.Construction.ProjectImportElement.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectImportElement.Project.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Project.set -> void
-Microsoft.Build.Construction.ProjectImportElement.ProjectLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectImportElement.Sdk.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Sdk.set -> void
-Microsoft.Build.Construction.ProjectImportElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectImportElement.Version.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Version.set -> void
-Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectImportGroupElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectImportGroupElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
-Microsoft.Build.Construction.ProjectInSolution
-Microsoft.Build.Construction.ProjectInSolution.AbsolutePath.get -> string
-Microsoft.Build.Construction.ProjectInSolution.Dependencies.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Construction.ProjectInSolution.ParentProjectGuid.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectConfigurations.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution>
-Microsoft.Build.Construction.ProjectInSolution.ProjectGuid.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectName.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectType.get -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.ProjectInSolution.ProjectType.set -> void
-Microsoft.Build.Construction.ProjectInSolution.RelativePath.get -> string
-Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectItemDefinitionElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
-Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemElement.Exclude.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Exclude.set -> void
-Microsoft.Build.Construction.ProjectItemElement.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.HasMetadata.get -> bool
-Microsoft.Build.Construction.ProjectItemElement.Include.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Include.set -> void
-Microsoft.Build.Construction.ProjectItemElement.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectItemElement.ItemType.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.get -> string
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.get -> string
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.set -> void
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
-Microsoft.Build.Construction.ProjectItemElement.Remove.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Remove.set -> void
-Microsoft.Build.Construction.ProjectItemElement.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.Update.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Update.set -> void
-Microsoft.Build.Construction.ProjectItemElement.UpdateLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemGroupElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.get -> bool
-Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.set -> void
-Microsoft.Build.Construction.ProjectMetadataElement.Name.get -> string
-Microsoft.Build.Construction.ProjectMetadataElement.Name.set -> void
-Microsoft.Build.Construction.ProjectMetadataElement.Value.get -> string
-Microsoft.Build.Construction.ProjectMetadataElement.Value.set -> void
-Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.get -> string
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.set -> void
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectOtherwiseElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectOtherwiseElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectOtherwiseElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectOutputElement.IsOutputItem.get -> bool
-Microsoft.Build.Construction.ProjectOutputElement.IsOutputProperty.get -> bool
-Microsoft.Build.Construction.ProjectOutputElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.ItemType.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOutputElement.PropertyName.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.PropertyName.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectPropertyElement.Name.get -> string
-Microsoft.Build.Construction.ProjectPropertyElement.Name.set -> void
-Microsoft.Build.Construction.ProjectPropertyElement.Value.get -> string
-Microsoft.Build.Construction.ProjectPropertyElement.Value.set -> void
-Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectPropertyGroupElement.AddProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectPropertyGroupElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectPropertyGroupElement.PropertiesReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectPropertyGroupElement.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectRootElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectRootElement.AddImportGroup() -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemDefinitionGroup() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddProperty(string name, string value) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddTarget(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectRootElement.AddUsingTask(string name, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectRootElement.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.Construction.ProjectRootElement.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectRootElement.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectRootElement.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.Construction.ProjectRootElement.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.Construction.ProjectRootElement.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectRootElement.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.Construction.ProjectRootElement.DeepClone() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.get -> string
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.set -> void
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.DirectoryPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Encoding.get -> System.Text.Encoding
-Microsoft.Build.Construction.ProjectRootElement.EscapedFullPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.FullPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.FullPath.set -> void
-Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges.get -> bool
-Microsoft.Build.Construction.ProjectRootElement.ImportGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ImportGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
-Microsoft.Build.Construction.ProjectRootElement.InitialTargets.get -> string
-Microsoft.Build.Construction.ProjectRootElement.InitialTargets.set -> void
-Microsoft.Build.Construction.ProjectRootElement.InitialTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead.get -> System.DateTime
-Microsoft.Build.Construction.ProjectRootElement.PreserveFormatting.get -> bool
-Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectRootElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.PropertyGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.RawXml.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save() -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(string path) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(string path, System.Text.Encoding encoding) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(System.IO.TextWriter writer) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(System.Text.Encoding saveEncoding) -> void
-Microsoft.Build.Construction.ProjectRootElement.Sdk.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Sdk.set -> void
-Microsoft.Build.Construction.ProjectRootElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.Targets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTargetElement>
-Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged.get -> System.DateTime
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.get -> string
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.set -> void
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.get -> string
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.set -> void
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalPropertyLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.UsingTasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement>
-Microsoft.Build.Construction.ProjectRootElement.Version.get -> int
-Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.set -> void
-Microsoft.Build.Construction.ProjectSdkElement.Name.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.Name.set -> void
-Microsoft.Build.Construction.ProjectSdkElement.Version.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.Version.set -> void
-Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectTargetElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectTargetElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectTargetElement.AddTask(string taskName) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Inputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Inputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Name.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Name.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.NameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.OnErrors.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOnErrorElement>
-Microsoft.Build.Construction.ProjectTargetElement.Outputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Outputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectTargetElement.Returns.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Returns.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTaskElement>
-Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.GetParameter(string name) -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.Name.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.Outputs.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOutputElement>
-Microsoft.Build.Construction.ProjectTaskElement.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
-Microsoft.Build.Construction.ProjectTaskElement.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Construction.ProjectTaskElement.RemoveAllParameters() -> void
-Microsoft.Build.Construction.ProjectTaskElement.RemoveParameter(string name) -> void
-Microsoft.Build.Construction.ProjectTaskElement.SetParameter(string name, string unevaluatedValue) -> void
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.EvaluateLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.AddParameterGroup() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.AddUsingTaskBody(string evaluate, string taskBody) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.ArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.RuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskBody.get -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactoryLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.OutputLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.RequiredLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.Construction.ProjectWhenElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectWhenElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectWhenElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.SolutionConfigurationInSolution
-Microsoft.Build.Construction.SolutionConfigurationInSolution.ConfigurationName.get -> string
-Microsoft.Build.Construction.SolutionConfigurationInSolution.FullName.get -> string
-Microsoft.Build.Construction.SolutionConfigurationInSolution.PlatformName.get -> string
-Microsoft.Build.Construction.SolutionFile
-Microsoft.Build.Construction.SolutionFile.GetDefaultConfigurationName() -> string
-Microsoft.Build.Construction.SolutionFile.GetDefaultPlatformName() -> string
-Microsoft.Build.Construction.SolutionFile.ProjectsByGuid.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectInSolution>
-Microsoft.Build.Construction.SolutionFile.ProjectsInOrder.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.ProjectInSolution>
-Microsoft.Build.Construction.SolutionFile.SolutionConfigurations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.SolutionConfigurationInSolution>
-Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.EtpSubProject = 5 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.KnownToBeMSBuildFormat = 1 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.SharedProject = 6 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.SolutionFolder = 2 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.Unknown = 0 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.WebDeploymentProject = 4 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.WebProject = 3 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.Parameters.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskParameterElement>
-Microsoft.Build.Definition.ProjectOptions
-Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.get -> Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.set -> void
-Microsoft.Build.Definition.ProjectOptions.EvaluationContext.get -> Microsoft.Build.Evaluation.Context.EvaluationContext
-Microsoft.Build.Definition.ProjectOptions.EvaluationContext.set -> void
-Microsoft.Build.Definition.ProjectOptions.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Definition.ProjectOptions.GlobalProperties.set -> void
-Microsoft.Build.Definition.ProjectOptions.LoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Definition.ProjectOptions.LoadSettings.set -> void
-Microsoft.Build.Definition.ProjectOptions.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Definition.ProjectOptions.ProjectCollection.set -> void
-Microsoft.Build.Definition.ProjectOptions.ProjectOptions() -> void
-Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.get -> string
-Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.set -> void
-Microsoft.Build.Definition.ProjectOptions.ToolsVersion.get -> string
-Microsoft.Build.Definition.ProjectOptions.ToolsVersion.set -> void
-Microsoft.Build.Evaluation.Context.EvaluationContext
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Isolated = 1 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Shared = 0 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.GlobResult
-Microsoft.Build.Evaluation.GlobResult.Excludes.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.GlobResult(Microsoft.Build.Construction.ProjectItemElement itemElement, System.Collections.Generic.IEnumerable<string> includeGlobStrings, Microsoft.Build.Globbing.IMSBuildGlob globWithGaps, System.Collections.Generic.IEnumerable<string> excludeFragmentStrings, System.Collections.Generic.IEnumerable<string> removeFragmentStrings) -> void
-Microsoft.Build.Evaluation.GlobResult.IncludeGlobs.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.set -> void
-Microsoft.Build.Evaluation.GlobResult.Removes.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.Removes.set -> void
-Microsoft.Build.Evaluation.MatchOnMetadataConstants
-Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseInsensitive = 1 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive = 0 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.PathLike = 2 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeAllOptions = -1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeToolsVersion = 2 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlDeclaration = 1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlNamespace = 4 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.None = 0 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Exclude = 1 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Include = 0 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Remove = 3 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Update = 2 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.Project.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-Microsoft.Build.Evaluation.Project.Build() -> bool
-Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger logger) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
-Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-Microsoft.Build.Evaluation.Project.CreateProjectInstance() -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.DirectoryPath.get -> string
-Microsoft.Build.Evaluation.Project.DisableMarkDirty.get -> bool
-Microsoft.Build.Evaluation.Project.DisableMarkDirty.set -> void
-Microsoft.Build.Evaluation.Project.EvaluationCounter.get -> int
-Microsoft.Build.Evaluation.Project.ExpandString(string unexpandedValue) -> string
-Microsoft.Build.Evaluation.Project.FullPath.get -> string
-Microsoft.Build.Evaluation.Project.FullPath.set -> void
-Microsoft.Build.Evaluation.Project.GetAllGlobs() -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Evaluation.Project.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.Project.GetPropertyValue(string name) -> string
-Microsoft.Build.Evaluation.Project.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Evaluation.Project.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-Microsoft.Build.Evaluation.Project.IsBuildEnabled.get -> bool
-Microsoft.Build.Evaluation.Project.IsBuildEnabled.set -> void
-Microsoft.Build.Evaluation.Project.IsDirty.get -> bool
-Microsoft.Build.Evaluation.Project.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
-Microsoft.Build.Evaluation.Project.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Evaluation.Project.LastEvaluationId.get -> int
-Microsoft.Build.Evaluation.Project.MarkDirty() -> void
-Microsoft.Build.Evaluation.Project.Project() -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Evaluation.Project.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.Project.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary() -> void
-Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
-Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(string name) -> bool
-Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
-Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
-Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
-Microsoft.Build.Evaluation.Project.Save() -> void
-Microsoft.Build.Evaluation.Project.Save(string path) -> void
-Microsoft.Build.Evaluation.Project.Save(string path, System.Text.Encoding encoding) -> void
-Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter writer) -> void
-Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding encoding) -> void
-Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter writer) -> void
-Microsoft.Build.Evaluation.Project.SetGlobalProperty(string name, string escapedValue) -> bool
-Microsoft.Build.Evaluation.Project.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.Project.SkipEvaluation.get -> bool
-Microsoft.Build.Evaluation.Project.SkipEvaluation.set -> void
-Microsoft.Build.Evaluation.Project.SubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Project.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.get -> bool
-Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.set -> void
-Microsoft.Build.Evaluation.Project.ToolsVersion.get -> string
-Microsoft.Build.Evaluation.Project.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectChangedEventArgs
-Microsoft.Build.Evaluation.ProjectChangedEventArgs.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Evaluation.ProjectCollection.AddToolset(Microsoft.Build.Evaluation.Toolset toolset) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ContainsToolset(string toolsVersion) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.Count.get -> int
-Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.get -> string
-Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.Dispose() -> void
-Microsoft.Build.Evaluation.ProjectCollection.GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject) -> string
-Microsoft.Build.Evaluation.ProjectCollection.GetGlobalProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Evaluation.ProjectCollection.GetLoadedProjects(string fullPath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-Microsoft.Build.Evaluation.ProjectCollection.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Evaluation.ProjectCollection.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Evaluation.ProjectCollection.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Evaluation.ProjectCollection.HostServices.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.LoadedProjects.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.Loggers.get -> System.Collections.Generic.ICollection<Microsoft.Build.Framework.ILogger>
-Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAdded -> Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectRootElement.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection() -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.RegisterForwardingLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger(Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RegisterLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RemoveAllToolsets() -> void
-Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty(string name) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.RemoveToolset(string toolsVersion) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty(string name, string value) -> void
-Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.ToolsetLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ProjectCollection.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
-Microsoft.Build.Evaluation.ProjectCollection.TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.UnloadAllProjects() -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Evaluation.Project project) -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnregisterAllLoggers() -> void
-Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs
-Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs.Changed.get -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.DefaultToolsVersion = 0 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.DisableMarkDirty = 7 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.GlobalProperties = 3 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.HostServices = 6 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.IsBuildEnabled = 4 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.Loggers = 2 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.OnlyLogCriticalEvents = 5 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.SkipEvaluation = 8 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.Toolsets = 1 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectItem
-Microsoft.Build.Evaluation.ProjectItem.DirectMetadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude.get -> string
-Microsoft.Build.Evaluation.ProjectItem.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(string name) -> string
-Microsoft.Build.Evaluation.ProjectItem.HasMetadata(string name) -> bool
-Microsoft.Build.Evaluation.ProjectItem.IsImported.get -> bool
-Microsoft.Build.Evaluation.ProjectItem.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectItem.ItemType.set -> void
-Microsoft.Build.Evaluation.ProjectItem.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItem.MetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItem.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(string name) -> bool
-Microsoft.Build.Evaluation.ProjectItem.Rename(string name) -> void
-Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.get -> string
-Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.set -> void
-Microsoft.Build.Evaluation.ProjectItem.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.ProjectItemDefinition
-Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadataValue(string name) -> string
-Microsoft.Build.Evaluation.ProjectItemDefinition.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectItemDefinition.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItemDefinition.MetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItemDefinition.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectItemDefinition.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.Default = 0 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.DoNotEvaluateElementsWithFalseCondition = 32 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.FailOnUnresolvedSdk = 256 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreEmptyImports = 16 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports = 64 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports = 1 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.ProfileEvaluation = 128 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RecordDuplicateButNotCircularImports = 2 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements = 8 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RejectCircularImports = 4 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectMetadata.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.IsImported.get -> bool
-Microsoft.Build.Evaluation.ProjectMetadata.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.ProjectMetadata.Name.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectMetadata.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.set -> void
-Microsoft.Build.Evaluation.ProjectMetadata.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.ProjectProperty.EvaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectProperty.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.ProjectXml.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.Reason.get -> string
-Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Glob = 2 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Inconclusive = 4 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.StringLiteral = 1 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Undefined = 0 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.ProvenanceResult
-Microsoft.Build.Evaluation.ProvenanceResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.ProvenanceResult.Occurrences.get -> int
-Microsoft.Build.Evaluation.ProvenanceResult.Operation.get -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.ProvenanceResult.Provenance.get -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.ProvenanceResult.ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElement, Microsoft.Build.Evaluation.Operation operation, Microsoft.Build.Evaluation.Provenance provenance, int occurrences) -> void
-Microsoft.Build.Evaluation.ResolvedImport
-Microsoft.Build.Evaluation.ResolvedImport.ImportedProject.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ResolvedImport.ImportingElement.get -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Evaluation.ResolvedImport.IsImported.get -> bool
-Microsoft.Build.Evaluation.ResolvedImport.ResolvedImport() -> void
-Microsoft.Build.Evaluation.ResolvedImport.SdkResult.get -> Microsoft.Build.Framework.SdkResult
-Microsoft.Build.Evaluation.SubToolset
-Microsoft.Build.Evaluation.SubToolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Evaluation.SubToolset.SubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Evaluation.Toolset.DefaultSubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion() -> string
-Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion(System.Collections.Generic.IDictionary<string, string> overrideGlobalProperties, int solutionVersion) -> string
-Microsoft.Build.Evaluation.Toolset.GetProperty(string propertyName, string subToolsetVersion) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Evaluation.Toolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Evaluation.Toolset.SubToolsets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset>
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> subToolsets, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.ToolsPath.get -> string
-Microsoft.Build.Evaluation.Toolset.ToolsVersion.get -> string
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile = 1 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Default = 4 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Local = 4 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.None = 0 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry = 2 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Exceptions.BuildAbortedException
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException() -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.CircularDependencyException
-Microsoft.Build.Exceptions.CircularDependencyException.CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Exceptions.InternalLoggerException
-Microsoft.Build.Exceptions.InternalLoggerException.BuildEventArgs.get -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Exceptions.InternalLoggerException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InternalLoggerException.HelpKeyword.get -> string
-Microsoft.Build.Exceptions.InternalLoggerException.InitializationException.get -> bool
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException() -> void
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message) -> void
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException
-Microsoft.Build.Exceptions.InvalidProjectFileException.BaseMessage.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.ColumnNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.EndColumnNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.EndLineNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorSubcategory.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.HasBeenLogged.get -> bool
-Microsoft.Build.Exceptions.InvalidProjectFileException.HelpKeyword.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException() -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.LineNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.ProjectFile.get -> string
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException() -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) -> void
-Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) -> void
-Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Execution.BuildManager.BuildManager() -> void
-Microsoft.Build.Execution.BuildManager.BuildManager(string hostName) -> void
-Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Execution.BuildManager.CancelAllSubmissions() -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage() -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Importance.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Text.get -> string
-Microsoft.Build.Execution.BuildManager.Dispose() -> void
-Microsoft.Build.Execution.BuildManager.EndBuild() -> void
-Microsoft.Build.Execution.BuildManager.GetProjectInstanceForBuild(Microsoft.Build.Evaluation.Project project) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildSubmission
-Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildSubmission
-Microsoft.Build.Execution.BuildManager.ResetCaches() -> void
-Microsoft.Build.Execution.BuildManager.ShutdownAllNodes() -> void
-Microsoft.Build.Execution.BuildManager.~BuildManager() -> void
-Microsoft.Build.Execution.BuildParameters
-Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.get -> bool
-Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.set -> void
-Microsoft.Build.Execution.BuildParameters.BuildParameters() -> void
-Microsoft.Build.Execution.BuildParameters.BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.BuildParameters.BuildProcessEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Threading.ThreadPriority
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.Clone() -> Microsoft.Build.Execution.BuildParameters
-Microsoft.Build.Execution.BuildParameters.Culture.get -> System.Globalization.CultureInfo
-Microsoft.Build.Execution.BuildParameters.Culture.set -> void
-Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.get -> string
-Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.set -> void
-Microsoft.Build.Execution.BuildParameters.DetailedSummary.get -> bool
-Microsoft.Build.Execution.BuildParameters.DetailedSummary.set -> void
-Microsoft.Build.Execution.BuildParameters.DisableInProcNode.get -> bool
-Microsoft.Build.Execution.BuildParameters.DisableInProcNode.set -> void
-Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.get -> bool
-Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.set -> void
-Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.get -> bool
-Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.set -> void
-Microsoft.Build.Execution.BuildParameters.EnvironmentProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord>
-Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.set -> void
-Microsoft.Build.Execution.BuildParameters.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Execution.BuildParameters.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.GlobalProperties.set -> void
-Microsoft.Build.Execution.BuildParameters.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.BuildParameters.HostServices.set -> void
-Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.get -> string[]
-Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.set -> void
-Microsoft.Build.Execution.BuildParameters.Interactive.get -> bool
-Microsoft.Build.Execution.BuildParameters.Interactive.set -> void
-Microsoft.Build.Execution.BuildParameters.IsolateProjects.get -> bool
-Microsoft.Build.Execution.BuildParameters.IsolateProjects.set -> void
-Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.get -> bool
-Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.set -> void
-Microsoft.Build.Execution.BuildParameters.Loggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger>
-Microsoft.Build.Execution.BuildParameters.Loggers.set -> void
-Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.get -> bool
-Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.set -> void
-Microsoft.Build.Execution.BuildParameters.LogTaskInputs.get -> bool
-Microsoft.Build.Execution.BuildParameters.LogTaskInputs.set -> void
-Microsoft.Build.Execution.BuildParameters.LowPriority.get -> bool
-Microsoft.Build.Execution.BuildParameters.LowPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.MaxNodeCount.get -> int
-Microsoft.Build.Execution.BuildParameters.MaxNodeCount.set -> void
-Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.get -> int
-Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.set -> void
-Microsoft.Build.Execution.BuildParameters.NodeExeLocation.get -> string
-Microsoft.Build.Execution.BuildParameters.NodeExeLocation.set -> void
-Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.get -> string
-Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.set -> void
-Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.set -> void
-Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.set -> void
-Microsoft.Build.Execution.BuildParameters.ResetCaches.get -> bool
-Microsoft.Build.Execution.BuildParameters.ResetCaches.set -> void
-Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.get -> bool
-Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.set -> void
-Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.get -> bool
-Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.set -> void
-Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.set -> void
-Microsoft.Build.Execution.BuildParameters.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
-Microsoft.Build.Execution.BuildParameters.UICulture.get -> System.Globalization.CultureInfo
-Microsoft.Build.Execution.BuildParameters.UICulture.set -> void
-Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.get -> bool
-Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
-Microsoft.Build.Execution.BuildRequestData
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
-Microsoft.Build.Execution.BuildRequestData.ExplicitlySpecifiedToolsVersion.get -> string
-Microsoft.Build.Execution.BuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestData.GlobalProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Execution.BuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.BuildRequestData.ProjectFullPath.get -> string
-Microsoft.Build.Execution.BuildRequestData.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildRequestData.PropertiesToTransfer.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Execution.BuildRequestData.RequestedProjectState.get -> Microsoft.Build.Execution.RequestedProjectState
-Microsoft.Build.Execution.BuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild = 8 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.FailOnUnresolvedSdk = 128 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState = 4 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports = 64 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.None = 0 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild = 2 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild = 32 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance = 1 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets = 16 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildResult.AddResultsForTarget(string target, Microsoft.Build.Execution.TargetResult result) -> void
-Microsoft.Build.Execution.BuildResult.BuildResult() -> void
-Microsoft.Build.Execution.BuildResult.CircularDependency.get -> bool
-Microsoft.Build.Execution.BuildResult.ConfigurationId.get -> int
-Microsoft.Build.Execution.BuildResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.BuildResult.GlobalRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.HasResultsForTarget(string target) -> bool
-Microsoft.Build.Execution.BuildResult.MergeResults(Microsoft.Build.Execution.BuildResult results) -> void
-Microsoft.Build.Execution.BuildResult.NodeRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResult.ParentGlobalRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.set -> void
-Microsoft.Build.Execution.BuildResult.ResultsByTarget.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>
-Microsoft.Build.Execution.BuildResult.SubmissionId.get -> int
-Microsoft.Build.Execution.BuildResult.this[string target].get -> Microsoft.Build.Execution.ITargetResult
-Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResultCode.Failure = 1 -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResultCode.Success = 0 -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildSubmission
-Microsoft.Build.Execution.BuildSubmission.AsyncContext.get -> object
-Microsoft.Build.Execution.BuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Execution.BuildSubmission.BuildResult.get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildSubmission.BuildResult.set -> void
-Microsoft.Build.Execution.BuildSubmission.Execute() -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback callback, object context) -> void
-Microsoft.Build.Execution.BuildSubmission.IsCompleted.get -> bool
-Microsoft.Build.Execution.BuildSubmission.SubmissionId.get -> int
-Microsoft.Build.Execution.BuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
-Microsoft.Build.Execution.BuildSubmissionCompleteCallback
-Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.HostServices.GetHostObject(string projectFile, string targetName, string taskName) -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Execution.HostServices.GetNodeAffinity(string projectFile) -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.HostServices.HostServices() -> void
-Microsoft.Build.Execution.HostServices.OnRenameProject(string oldFullPath, string newFullPath) -> void
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) -> void
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
-Microsoft.Build.Execution.HostServices.SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) -> void
-Microsoft.Build.Execution.HostServices.UnregisterProject(string projectFullPath) -> void
-Microsoft.Build.Execution.ITargetResult
-Microsoft.Build.Execution.ITargetResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.ITargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Execution.ITargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.Any = 2 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.InProc = 0 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.OutOfProc = 1 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.BuildComplete = 0 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.BuildCompleteReuse = 1 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.ConnectionFailed = 2 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.Error = 3 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode
-Microsoft.Build.Execution.OutOfProcNode.OutOfProcNode() -> void
-Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude) -> Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectInstance.Build() -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.DeepCopy() -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.DeepCopy(bool isImmutable) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.DefaultTargets.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.ProjectInstance.Directory.get -> string
-Microsoft.Build.Execution.ProjectInstance.EvaluateCondition(string condition) -> bool
-Microsoft.Build.Execution.ProjectInstance.EvaluatedItemElements.get -> System.Collections.Generic.List<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Execution.ProjectInstance.EvaluationId.get -> int
-Microsoft.Build.Execution.ProjectInstance.EvaluationId.set -> void
-Microsoft.Build.Execution.ProjectInstance.ExpandString(string unexpandedValue) -> string
-Microsoft.Build.Execution.ProjectInstance.FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.FullPath.get -> string
-Microsoft.Build.Execution.ProjectInstance.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.GetProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectInstance.GetPropertyValue(string name) -> string
-Microsoft.Build.Execution.ProjectInstance.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.ProjectInstance.ImportPaths.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Execution.ProjectInstance.ImportPathsIncludingDuplicates.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Execution.ProjectInstance.InitialTargets.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.ProjectInstance.IsImmutable.get -> bool
-Microsoft.Build.Execution.ProjectInstance.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance>
-Microsoft.Build.Execution.ProjectInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.ProjectInstance.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Execution.ProjectInstance.RemoveItem(Microsoft.Build.Execution.ProjectItemInstance item) -> bool
-Microsoft.Build.Execution.ProjectInstance.RemoveProperty(string name) -> bool
-Microsoft.Build.Execution.ProjectInstance.SetProperty(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectInstance.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-Microsoft.Build.Execution.ProjectInstance.ToolsVersion.get -> string
-Microsoft.Build.Execution.ProjectInstance.ToProjectRootElement() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.get -> bool
-Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.set -> void
-Microsoft.Build.Execution.ProjectInstance.UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectState) -> void
-Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.Immutable = 1 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.ImmutableWithFastItemLookup = 3 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.None = 0 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectItemDefinitionInstance
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectMetadataInstance>
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataNames.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Execution.ProjectItemGroupTaskInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance>
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Exclude.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Include.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicates.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptions.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance>
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Remove.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Value.get -> string
-Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectItemInstance.DirectMetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.get -> string
-Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.set -> void
-Microsoft.Build.Execution.ProjectItemInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemInstance.GetMetadataValue(string name) -> string
-Microsoft.Build.Execution.ProjectItemInstance.HasMetadata(string name) -> bool
-Microsoft.Build.Execution.ProjectItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemInstance.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectMetadataInstance>
-Microsoft.Build.Execution.ProjectItemInstance.MetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemInstance.MetadataNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.ProjectItemInstance.Project.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectItemInstance.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadataDictionary) -> void
-Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectMetadataInstance.DeepClone() -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectMetadataInstance.EvaluatedValue.get -> string
-Microsoft.Build.Execution.ProjectMetadataInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectOnErrorInstance
-Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargets.get -> string
-Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance
-Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance>
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Value.get -> string
-Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.get -> string
-Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.set -> void
-Microsoft.Build.Execution.ProjectPropertyInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance
-Microsoft.Build.Execution.ProjectTargetInstance.AfterTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Children.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTargetInstanceChild>
-Microsoft.Build.Execution.ProjectTargetInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.FullPath.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.Inputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.OnErrorChildren.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectOnErrorInstance>
-Microsoft.Build.Execution.ProjectTargetInstance.Outputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Returns.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectTaskInstance>
-Microsoft.Build.Execution.ProjectTargetInstanceChild
-Microsoft.Build.Execution.ProjectTargetInstanceChild.FullPath.get -> string
-Microsoft.Build.Execution.ProjectTargetInstanceChild.ProjectTargetInstanceChild() -> void
-Microsoft.Build.Execution.ProjectTaskInstance
-Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnError.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitecture.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntime.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.Outputs.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTaskInstanceChild>
-Microsoft.Build.Execution.ProjectTaskInstance.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.ProjectTaskInstanceChild
-Microsoft.Build.Execution.ProjectTaskInstanceChild.ProjectTaskInstanceChild() -> void
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameter.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyName.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameter.get -> string
-Microsoft.Build.Execution.RequestedProjectState
-Microsoft.Build.Execution.RequestedProjectState.ItemFilters.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-Microsoft.Build.Execution.RequestedProjectState.ItemFilters.set -> void
-Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.set -> void
-Microsoft.Build.Execution.RequestedProjectState.RequestedProjectState() -> void
-Microsoft.Build.Execution.TargetResult
-Microsoft.Build.Execution.TargetResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.TargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Execution.TargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Failure = 2 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Skipped = 0 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Success = 1 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Experimental.ProjectCache.CacheContext
-Microsoft.Build.Experimental.ProjectCache.CacheContext.CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) -> void
-Microsoft.Build.Experimental.ProjectCache.CacheContext.FileSystem.get -> Microsoft.Build.FileSystem.MSBuildFileSystemBase
-Microsoft.Build.Experimental.ProjectCache.CacheContext.Graph.get -> Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Experimental.ProjectCache.CacheContext.GraphEntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.CacheContext.MSBuildExePath.get -> string
-Microsoft.Build.Experimental.ProjectCache.CacheContext.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.CacheResult
-Microsoft.Build.Experimental.ProjectCache.CacheResult.BuildResult.get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Experimental.ProjectCache.CacheResult.ProxyTargets.get -> Microsoft.Build.Experimental.ProjectCache.ProxyTargets
-Microsoft.Build.Experimental.ProjectCache.CacheResult.ResultType.get -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheHit = 1 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheMiss = 2 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheNotApplicable = 3 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.None = 0 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase() -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult() -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
-Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
-Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.ProjectCachePluginBase() -> void
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) -> void
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargetToRealTargetMap.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.FileSystem.FindPredicate
-Microsoft.Build.FileSystem.FindTransform<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache
-Microsoft.Build.FileSystem.IDirectoryCache.DirectoryExists(string path) -> bool
-Microsoft.Build.FileSystem.IDirectoryCache.EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache.EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache.FileExists(string path) -> bool
-Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
-Microsoft.Build.FileSystem.MSBuildFileSystemBase
-Microsoft.Build.FileSystem.MSBuildFileSystemBase.MSBuildFileSystemBase() -> void
-Microsoft.Build.Globbing.CompositeGlob
-Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) -> void
-Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> void
-Microsoft.Build.Globbing.CompositeGlob.Globs.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob>
-Microsoft.Build.Globbing.CompositeGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions
-Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.IMSBuildGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlob.FilenamePart.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.FixedDirectoryPart.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.IsLegal.get -> bool
-Microsoft.Build.Globbing.MSBuildGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(string stringToMatch) -> Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FilenamePartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FixedDirectoryPartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.IsMatch.get -> bool
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.MatchInfoResult() -> void
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.WildcardDirectoryPartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.WildcardDirectoryPart.get -> string
-Microsoft.Build.Globbing.MSBuildGlobWithGaps
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.Gaps.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MainGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, params Microsoft.Build.Globbing.IMSBuildGlob[] gaps) -> void
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> gaps) -> void
-Microsoft.Build.Graph.GraphBuildOptions
-Microsoft.Build.Graph.GraphBuildOptions.Build.get -> bool
-Microsoft.Build.Graph.GraphBuildOptions.Build.init -> void
-Microsoft.Build.Graph.GraphBuildRequestData
-Microsoft.Build.Graph.GraphBuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildOptions.get -> Microsoft.Build.Graph.GraphBuildOptions
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraphEntryPoints.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Graph.GraphBuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildResult.CircularDependency.get -> bool
-Microsoft.Build.Graph.GraphBuildResult.Exception.get -> System.Exception
-Microsoft.Build.Graph.GraphBuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Graph.GraphBuildResult.ResultsByNode.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, Microsoft.Build.Execution.BuildResult>
-Microsoft.Build.Graph.GraphBuildResult.SubmissionId.get -> int
-Microsoft.Build.Graph.GraphBuildResult.this[Microsoft.Build.Graph.ProjectGraphNode node].get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Graph.GraphBuildSubmission
-Microsoft.Build.Graph.GraphBuildSubmission.AsyncContext.get -> object
-Microsoft.Build.Graph.GraphBuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Graph.GraphBuildSubmission.BuildResult.get -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildSubmission.Execute() -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildSubmission.ExecuteAsync(Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback callback, object context) -> void
-Microsoft.Build.Graph.GraphBuildSubmission.IsCompleted.get -> bool
-Microsoft.Build.Graph.GraphBuildSubmission.SubmissionId.get -> int
-Microsoft.Build.Graph.GraphBuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
-Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback
-Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Graph.ProjectGraph.ConstructionMetrics.get -> Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
-Microsoft.Build.Graph.ProjectGraph.EntryPointNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>>
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.ConstructionTime.get -> System.TimeSpan
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.EdgeCount.get -> int
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics() -> void
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) -> void
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.NodeCount.get -> int
-Microsoft.Build.Graph.ProjectGraph.GraphRoots.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, int degreeOfParallelism, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc
-Microsoft.Build.Graph.ProjectGraph.ProjectNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.ProjectNodesTopologicallySorted.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraphEntryPoint
-Microsoft.Build.Graph.ProjectGraphEntryPoint.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectFile.get -> string
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint() -> void
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile) -> void
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraphNode
-Microsoft.Build.Graph.ProjectGraphNode.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Graph.ProjectGraphNode.ProjectReferences.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraphNode.ReferencingProjects.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Logging.BinaryLogger
-Microsoft.Build.Logging.BinaryLogger.BinaryLogger() -> void
-Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.get -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.set -> void
-Microsoft.Build.Logging.BinaryLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.BinaryLogger.Parameters.get -> string
-Microsoft.Build.Logging.BinaryLogger.Parameters.set -> void
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.Embed = 1 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.None = 0 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.ZipFile = 2 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.Shutdown() -> void
-Microsoft.Build.Logging.BinaryLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.BinaryLogger.Verbosity.set -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource
-Microsoft.Build.Logging.BinaryLogReplayEventSource.BinaryLogReplayEventSource() -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath) -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Logging.BuildEventArgsReader
-Microsoft.Build.Logging.BuildEventArgsReader.BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) -> void
-Microsoft.Build.Logging.BuildEventArgsReader.Dispose() -> void
-Microsoft.Build.Logging.BuildEventArgsReader.Read() -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Logging.ColorResetter
-Microsoft.Build.Logging.ColorSetter
-Microsoft.Build.Logging.ConfigurableForwardingLogger
-Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.ConfigurableForwardingLogger() -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.get -> int
-Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.get -> string
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.set -> void
-Microsoft.Build.Logging.ConsoleLogger
-Microsoft.Build.Logging.ConsoleLogger.ApplyParameter(string parameterName, string parameterValue) -> void
-Microsoft.Build.Logging.ConsoleLogger.BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger() -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.Logging.WriteHandler write, Microsoft.Build.Logging.ColorSetter colorSet, Microsoft.Build.Logging.ColorResetter colorReset) -> void
-Microsoft.Build.Logging.ConsoleLogger.CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.Parameters.get -> string
-Microsoft.Build.Logging.ConsoleLogger.Parameters.set -> void
-Microsoft.Build.Logging.ConsoleLogger.ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ShowSummary.get -> bool
-Microsoft.Build.Logging.ConsoleLogger.ShowSummary.set -> void
-Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.get -> bool
-Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.set -> void
-Microsoft.Build.Logging.ConsoleLogger.TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ConsoleLogger.Verbosity.set -> void
-Microsoft.Build.Logging.ConsoleLogger.WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.WriteHandler.get -> Microsoft.Build.Logging.WriteHandler
-Microsoft.Build.Logging.ConsoleLogger.WriteHandler.set -> void
-Microsoft.Build.Logging.DistributedFileLogger
-Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.DistributedFileLogger() -> void
-Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Logging.DistributedFileLogger.NodeId.get -> int
-Microsoft.Build.Logging.DistributedFileLogger.NodeId.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.Parameters.get -> string
-Microsoft.Build.Logging.DistributedFileLogger.Parameters.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.Shutdown() -> void
-Microsoft.Build.Logging.DistributedFileLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.DistributedFileLogger.Verbosity.set -> void
-Microsoft.Build.Logging.EventArgsDispatcher
-Microsoft.Build.Logging.EventArgsDispatcher.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.Dispatch(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
-Microsoft.Build.Logging.EventArgsDispatcher.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.EventArgsDispatcher() -> void
-Microsoft.Build.Logging.EventArgsDispatcher.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Logging.FileLogger
-Microsoft.Build.Logging.FileLogger.FileLogger() -> void
-Microsoft.Build.Logging.ForwardingLoggerRecord
-Microsoft.Build.Logging.ForwardingLoggerRecord.CentralLogger.get -> Microsoft.Build.Framework.ILogger
-Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerDescription.get -> Microsoft.Build.Logging.LoggerDescription
-Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerRecord(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.Logging.LoggerDescription forwardingLoggerDescription) -> void
-Microsoft.Build.Logging.LoggerDescription
-Microsoft.Build.Logging.LoggerDescription.CreateLogger() -> Microsoft.Build.Framework.ILogger
-Microsoft.Build.Logging.LoggerDescription.IsOptional.get -> bool
-Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity, bool isOptional) -> void
-Microsoft.Build.Logging.LoggerDescription.LoggerSwitchParameters.get -> string
-Microsoft.Build.Logging.LoggerDescription.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ProfilerLogger
-Microsoft.Build.Logging.ProfilerLogger.FileToLog.get -> string
-Microsoft.Build.Logging.ProfilerLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.ProfilerLogger.Parameters.get -> string
-Microsoft.Build.Logging.ProfilerLogger.Parameters.set -> void
-Microsoft.Build.Logging.ProfilerLogger.ProfilerLogger(string fileToLog) -> void
-Microsoft.Build.Logging.ProfilerLogger.Shutdown() -> void
-Microsoft.Build.Logging.ProfilerLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ProfilerLogger.Verbosity.set -> void
-Microsoft.Build.Logging.WriteHandler
-Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider
-Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.ExternalProjectsProvider() -> void
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Collection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.Construction.ProjectImportElement importingElement, Microsoft.Build.Construction.ProjectRootElement importedProject, int versionEvaluated, Microsoft.Build.Framework.SdkResult sdkResult, bool isImported) -> Microsoft.Build.Evaluation.ResolvedImport
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink link) -> Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink link) -> Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink link) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectItemDefinition
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) -> Microsoft.Build.Evaluation.ProjectItem
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) -> Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) -> Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink link) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink link) -> Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink.ProjectChooseElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.ProjectElementContainerLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ProjectElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.ProjectExtensionsElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ProjectImportElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink.ProjectImportGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink.ProjectItemDefinitionElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink.ProjectItemDefinitionGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ProjectItemDefinitionLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ProjectItemElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink.ProjectItemGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ProjectItemLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectLink
-Microsoft.Build.ObjectModelRemoting.ProjectLink.ProjectLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ProjectMetadataElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.ProjectMetadataLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink.ProjectOnErrorElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink.ProjectOtherwiseElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink.ProjectOutputElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ProjectPropertyElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink.ProjectPropertyGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.ProjectPropertyLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectRootElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink.ProjectSdkElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.ProjectTargetElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ProjectTaskElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.ProjectUsingTaskBodyElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink.ProjectUsingTaskElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.ProjectUsingTaskParameterElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink.ProjectWhenElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink
-Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink.UsingTaskParameterGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.LocalName.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.NamespaceURI.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.Value.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink() -> void
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink(string localName, string value, string namespaceUri) -> void
-override Microsoft.Build.Construction.ElementLocation.Equals(object obj) -> bool
-override Microsoft.Build.Construction.ElementLocation.GetHashCode() -> int
-override Microsoft.Build.Construction.ElementLocation.ToString() -> string
-override Microsoft.Build.Construction.ProjectChooseElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectChooseElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectChooseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectExtensionsElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectExtensionsElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectItemElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectItemGroupElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectOtherwiseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectRootElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectRootElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectRootElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectTargetElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectTaskElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.get -> string
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.set -> void
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Exceptions.BuildAbortedException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InvalidProjectFileException.Message.get -> string
-override Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectItemInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectMetadataInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectOnErrorInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectOnErrorInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectOnErrorInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-override Microsoft.Build.Logging.FileLogger.Shutdown() -> void
-static Microsoft.Build.Construction.ProjectRootElement.Create() -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.SolutionFile.Parse(string solutionFile) -> Microsoft.Build.Construction.SolutionFile
-static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) -> Microsoft.Build.Evaluation.Context.EvaluationContext
-static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) -> Microsoft.Build.Evaluation.Context.EvaluationContext
-static Microsoft.Build.Evaluation.Project.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem item) -> string
-static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem item, string name) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadatum) -> string
-static Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.DisplayVersion.get -> string
-static Microsoft.Build.Evaluation.ProjectCollection.Escape(string unescapedString) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-static Microsoft.Build.Evaluation.ProjectCollection.Unescape(string escapedString) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.Version.get -> System.Version
-static Microsoft.Build.Execution.BuildManager.DefaultBuildManager.get -> Microsoft.Build.Execution.BuildManager
-static Microsoft.Build.Execution.ProjectInstance.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
-static Microsoft.Build.Execution.ProjectInstance.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
-static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item, string name) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemInstance item, string name) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectMetadataInstance metadatum) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetPropertyValueEscaped(Microsoft.Build.Execution.ProjectPropertyInstance property) -> string
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
-static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
-static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
-static Microsoft.Build.Globbing.MSBuildGlob.Parse(string globRoot, string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
-static Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.SetExternalProjectsProvider(Microsoft.Build.Evaluation.ProjectCollection collection, Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider link) -> void
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Get(Microsoft.Build.Evaluation.ProjectCollection collection) -> Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLink(object obj) -> object
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project>
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.IsLocal(object obj) -> bool
-static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectElement child) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectElement xml, Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(Microsoft.Build.Construction.ProjectElement xml, string attributeName) -> Microsoft.Build.Construction.ElementLocation
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributes(Microsoft.Build.Construction.ProjectElement xml) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(Microsoft.Build.Construction.ProjectElement xml, string attributeName, bool nullIfNotExists) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml) -> bool
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetPureText(Microsoft.Build.Construction.ProjectElement xml) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.MarkDirty(Microsoft.Build.Construction.ProjectElement xml, string reason, string param) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml, bool value) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(Microsoft.Build.Construction.ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetParent(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> object
-static Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
-virtual Microsoft.Build.Construction.ProjectElement.Condition.get -> string
-virtual Microsoft.Build.Construction.ProjectElement.Condition.set -> void
-virtual Microsoft.Build.Construction.ProjectElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-virtual Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-virtual Microsoft.Build.Construction.ProjectElementContainer.DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) -> void
-virtual Microsoft.Build.Evaluation.ProjectCollection.Dispose(bool disposing) -> void
-virtual Microsoft.Build.Execution.ProjectPropertyInstance.IsImmutable.get -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.DirectoryExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileOrDirectoryExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetAttributes(string path) -> System.IO.FileAttributes
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) -> System.IO.Stream
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetLastWriteTimeUtc(string path) -> System.DateTime
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFile(string path) -> System.IO.TextReader
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllBytes(string path) -> byte[]
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllText(string path) -> string
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) -> void
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index 42acd772719..00000000000
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ /dev/null
@@ -1,22 +0,0 @@
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging, bool reuseProjectRootElementCache) -> void
-Microsoft.Build.Experimental.MSBuildClient
-Microsoft.Build.Experimental.MSBuildClient.Execute(System.Threading.CancellationToken cancellationToken) -> Microsoft.Build.Experimental.MSBuildClientExitResult
-Microsoft.Build.Experimental.MSBuildClient.MSBuildClient(string[] commandLine, string msbuildLocation) -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.get -> string
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.set -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitResult() -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.get -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.set -> void
-Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.LaunchError = 3 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.ServerBusy = 1 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.Success = 0 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.UnableToConnect = 2 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.Unexpected = 4 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.OutOfProcServerNode
-Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
-Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
-Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-static Microsoft.Build.Experimental.MSBuildClient.ShutdownServer(System.Threading.CancellationToken cancellationToken) -> bool
-
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 6e06bc6e423..7b1b4f411e1 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1271,6 +1271,10 @@
     <value>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</value>
     <comment>{StrBegin="MSB4067: "}</comment>
   </data>
+  <data name="PropertyOutsidePropertyGroupInTarget" xml:space="preserve" Condition="$([MSBuild]::AreFeaturesEnabled('17.6'))">
+    <value>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</value>
+    <comment>{StrBegin="MSB4067: "}</comment>
+  </data>
   <data name="InvalidChildElementDueToDuplication" xml:space="preserve">
     <value>MSB4173: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is invalid because a child element with that name already exists</value>
     <comment>{StrBegin="MSB4173: "}</comment>
@@ -1306,6 +1310,10 @@
   <data name="SDKResolverFailed" xml:space="preserve">
     <value>The SDK resolver "{0}" failed while attempting to resolve the SDK "{1}". Exception: "{2}"</value>
   </data>
+  <data name="FailedToResolveSDK" xml:space="preserve">
+    <value>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</value>
+  </data>
   <data name="CouldNotRunNuGetSdkResolver" xml:space="preserve">
     <value>The NuGet-based SDK resolver failed to run because NuGet assemblies could not be located.  Check your installation of MSBuild or set the environment variable "{0}" to the folder that contains the required NuGet assemblies. {1}</value>
   </data>
@@ -1963,4 +1971,10 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is a file path. {1} is a comma-separated list of target names
     </comment>
   </data>
+   <data name="DefaultSDKResolverError" xml:space="preserve">
+    <value>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</value>
+  </data>
+  <data name="SDKResolverReturnedNull" xml:space="preserve">
+    <value>SDK resolver "{0}" returned null.</value>
+  </data>
 </root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index fc0594e7c40..0fd2a55f4a1 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: Proměnná prostředí MSBuildDisableFeaturesFromVersion je nastavená na neplatný formát. Povolují se všechny verze vlny změn. Zadaná hodnota: {0}. Aktuální vlny změn: {1}</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: Proměnná prostředí MSBuildDisableFeaturesFromVersion je nastavená na verzi, která je mimo rotaci. Nastavuje se výchozí verze vlny změn: {0}. Zadaná hodnota: {1}. Aktuální vlny změn: {2}</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Došlo k pokusu o vytvoření více přepsání stejné úlohy: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Při zápisu do výstupních souborů mezipaměti pro výsledky v cestě {0} byla zjištěna chyba: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Na pozici {1} podmínky {0} je neočekávaná mezera. Nezapomněli jste ji odebrat?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">Načítá se následující modul plug-in mezipaměti projektu:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">Počáteční hodnota vlastnosti: $({0})={1} Zdroj: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: Zakázání uzlu inproc způsobí snížení výkonu při používání modulů plug-in mezipaměti projektu, které vysílají žádosti o sestavení proxy serveru.</target>
@@ -344,6 +360,11 @@
         <target state="translated">Překladač sady SDK {0} selhal při pokusu o překlad sady SDK {1}. Výjimka: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Projekt {0} přeskočil omezení izolace grafu v odkazovaném projektu {1}.</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznán.</target>
+        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznán.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 1972d1b88ed..49aab4ca53c 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: Die Umgebungsvariable "MSBuildDisableFeaturesFromVersion" ist auf ein ungültiges Format festgelegt. Alle Änderungszyklusversionen werden aktiviert. Eingegebener Wert: {0}. Aktuelle Änderungszyklen: {1}.</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: Die Umgebungsvariable "MSBuildDisableFeaturesFromVersion" ist auf eine nicht rotierende Version festgelegt und wird auf die Standard-Änderungszyklusversion gesetzt: {0}. Eingegebener Wert: {1}. Aktuelle Änderungszyklen: {2}.</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Es wurde versucht, mehrere Außerkraftsetzungen derselben Aufgabe zu erstellen: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Beim Schreiben der Cachedatei für Ausgabeergebnisse im Pfad "{0}" wurde ein Fehler festgestellt: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Unerwartetes Leerzeichen an Position "{1}" der Bedingung "{0}". Haben Sie vergessen, ein Leerzeichen zu entfernen?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">Folgendes Projektcache-Plug-In wird geladen:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">Anfangswert der Eigenschaft: $({0})="{1}", Quelle: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: Das Deaktivieren des In-Process-Knotens führt zu Leistungseinbußen bei der Verwendung von Projektcache-Plug-Ins, die Proxybuildanforderungen ausgeben.</target>
@@ -344,6 +360,11 @@
         <target state="translated">Ausfall beim Versuch des SDK-Resolver "{0}", das SDK "{1}" aufzulösen. Ausnahme: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Das Projekt "{0}" hat Graphisolationseinschränkungen für das referenzierte Projekt "{1}" übersprungen.</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
+        <target state="needs-review-translation">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 6dc804fa2a4..3e8d9e420ce 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: La variable de entorno MSBuildDisableFeaturesFromVersion está establecida en un formato no válido. Habilitando todas las versiones de oleadas de cambios. Valor especificado: {0}. Oleadas de cambios actuales: {1}.</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: La variable de entorno MSBuildDisableFeaturesFromVersion está establecida en una versión no incluida en la rotación. Se va a cambiar a la versión de oleada de cambios de forma predeterminada: {0}. Valor especificado: {1}. Oleadas de cambios actuales: {2}.</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Se intentaron crear varias invalidaciones de la misma tarea: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Error al escribir el archivo de caché de resultados de salida en la ruta de acceso "{0}": {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Espacio inesperado en la posición "{1}" de la condición "{0}". ¿Olvidó quitar un espacio?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">Cargando el complemento de caché de proyectos siguiente:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">Valor inicial de la propiedad: $({0})="{1}" Origen: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: Al deshabilitar el nodo InProc, se degrada el rendimiento cuando use los complementos de caché de proyectos que emiten solicitudes de compilación de proxy.</target>
@@ -344,6 +360,11 @@
         <target state="translated">Error en el solucionador del SDK "{0}" al intentar resolver el SDK "{1}". Excepción: "{2}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: El proyecto "{0}" ha omitido las restricciones de aislamiento de gráficos en el proyecto "{1}" al que se hace referencia.</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
+        <target state="needs-review-translation">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 2ee436b993c..369cad1fc61 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: la variable d'environnement MSBuildDisableFeaturesFromVersion a un format non valide. Activation de toutes les versions des vagues de changements. Valeur entrée : {0}. Vagues de changements actuelles : {1}.</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: la variable d'environnement MSBuildDisableFeaturesFromVersion a une valeur correspondant à une version hors rotation. Utilisation par défaut de la vague de changements version {0}. Valeur entrée : {1}. Vagues de changements actuelles : {2}.</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Tentative de création de plusieurs remplacements de la même tâche : {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: L'écriture du fichier cache des résultats de sortie dans le chemin "{0}" a rencontré une erreur : {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: espace inattendu à la position "{1}" de la condition "{0}". Avez-vous oublié de supprimer un espace ?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">Chargement du plug-in de cache de projet suivant:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">Valeur initiale de la propriété : $({0})="{1}" Source : {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: la désactivation du nœud inproc entraîne une détérioration des performances lors de l’utilisation de plug-ins de cache de projet qui émettent des requêtes de build proxy.</target>
@@ -344,6 +360,11 @@
         <target state="translated">Échec du programme de résolution SDK «{0}» lors de la tentative de résolution du kit de développement logiciel (SDK) «{1}». Exception : "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: le projet "{0}" a ignoré les contraintes d'isolement de graphe dans le projet référencé "{1}"</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: L'élément "{0}" situé sous l'élément &lt;{1}&gt; n'est pas reconnu.</target>
+        <target state="needs-review-translation">MSB4067: L'élément "{0}" situé sous l'élément &lt;{1}&gt; n'est pas reconnu.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 8e9c2904d7a..16c46738aa3 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: la variabile di ambiente MSBuildDisableFeaturesFromVersion è impostata su un formato non valido. Verranno abilitate tutte le versioni con flussi di modifiche. Valore immesso: {0}. Flussi di modifiche correnti: {1}.</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: la variabile di ambiente MSBuildDisableFeaturesFromVersion è impostata su una versione esclusa dalla rotazione. Per impostazione predefinita, verrà usata la versione con flussi di modifiche: {0}. Valore immesso: {1}. Flussi di modifiche correnti: {2}.</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: tentativo di creare più sostituzioni della stessa attività: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: durante la scrittura del file della cache dei risultati di output nel percorso "{0}" è stato rilevato un errore: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: spazio imprevisto alla posizione "{1}" della condizione "{0}". Si è dimenticato di rimuovere uno spazio?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">Caricamento del plug-in seguente della cache del progetto:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">Valore iniziale della proprietà: $({0})="{1}". Origine: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: la disabilitazione del nodo InProc porta a una riduzione del livello delle prestazioni quando si usano plug-in della cache del progetto che emettono richieste di compilazione proxy.</target>
@@ -344,6 +360,11 @@
         <target state="translated">Il sistema di risoluzione SDK "{0}" non è riuscito durante il tentativo di risolvere l'SDK "{1}". Eccezione: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: il progetto "{0}" ha ignorato i vincoli di isolamento del grafico nel progetto di riferimento "{1}"</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
+        <target state="needs-review-translation">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 7affbcbed39..2767d3b459d 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: 環境変数 MSBuildDisableFeaturesFromVersion が無効な形式に設定されています。すべての変更ウェーブ バージョンを有効にしています。入力された値: {0}。現在の変更ウェーブ: {1}。</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: 環境変数 MSBuildDisableFeaturesFromVersion が、ローテーションから外れているバージョンに設定されています。変更ウェーブ バージョンを既定値にしています: {0}。入力された値: {1}。現在の変更ウェーブ: {2}。</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: 同じタスクの複数のオーバーライドを作成しようとしました: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: パス "{0}" の出力結果キャッシュ ファイルに書き込む処理でエラーが発生しました: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: 条件 "{0}" の位置 "{1}" に予期しないスペースがあります。スペースを削除したか確認してください。</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">次のプロジェクト キャッシュ プラグインを読み込んでいます。
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">プロパティの初期値: $({0})="{1}" ソース: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: プロキシ・ビルド要求を出すプロジェクト キャッシュ プラグインを使用する場合、InProc ノードを無効にするとパフォーマンスが低下します。</target>
@@ -344,6 +360,11 @@
         <target state="translated">SDK "{1}" を解決しようとしているときに、SDK リゾルバー "{0}" に失敗しました。例外: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: プロジェクト "{0}" は、参照先のプロジェクト "{1}" で、グラフの分離制約をスキップしました</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: 要素 &lt;{1}&gt; の下の要素 &lt;{0}&gt; は認識されていません。</target>
+        <target state="needs-review-translation">MSB4067: 要素 &lt;{1}&gt; の下の要素 &lt;{0}&gt; は認識されていません。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index b6a55fd316f..a8b9e95d0a2 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: 환경 변수 MSBuildDisableFeaturesFromVersion이 잘못된 형식으로 설정되어 있습니다. 변경 웨이브 버전을 모두 사용하도록 설정합니다. 입력한 값: {0}. 현재 변경 웨이브: {1}.</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: 환경 변수 MSBuildDisableFeaturesFromVersion이 순환되지 않는 버전으로 설정되어 있습니다. 기본값인 변경 웨이브 버전 {0}(으)로 설정합니다. 입력한 값: {1}. 현재 변경 웨이브: {2}.</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: 동일한 작업의 여러 재정의를 만들려고 했습니다. {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: "{0}" 경로에서 출력 결과 캐시 파일을 쓰는 중 오류가 발생했습니다. {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: "{0}" 조건의 "{1}" 위치에 예기치 않은 공백이 있습니다. 공백을 제거했는지 확인하세요.</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">다음 프로젝트 캐시 플러그 인을 로드하는 중:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">속성 초기 값: $({0})="{1}" 소스: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: 프록시 빌드 요청을 내보내는 프로젝트 캐시 플러그 인을 사용할 때 inproc 노드를 사용하지 않도록 설정하면 성능이 저하됩니다.</target>
@@ -344,6 +360,11 @@
         <target state="translated">SDK "{1}"을(를) 확인하는 동안 SDK 확인자 "{0}"이(가) 실패했습니다. 예외: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 프로젝트 "{0}"에서 참조된 프로젝트 "{1}"의 그래프 격리 제약 조건을 건너뛰었습니다.</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: &lt;{1}&gt; 요소 아래의 &lt;{0}&gt; 요소를 인식할 수 없습니다.</target>
+        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; 요소 아래의 &lt;{0}&gt; 요소를 인식할 수 없습니다.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 45809868498..dd63fc75115 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: Zmienna środowiskowa MSBuildDisableFeaturesFromVersion ma nieprawidłowy format. Zostaną włączone wszystkie wersje fali zmian. Wprowadzona wartość: {0}. Bieżące fale zmian: {1}.</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: Zmienna środowiskowa MSBuildDisableFeaturesFromVersion ma ustawioną wersję, która została wycofana z użycia. Domyślnie zostanie użyta fala zmian w wersji: {0}. Wprowadzona wartość: {1}. Bieżące fale zmian: {2}.</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Podjęto próbę utworzenia wielu zastąpień tego samego zadania: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Podczas zapisywania pliku wyjściowej pamięci podręcznej wyników w ścieżce „{0}” wystąpił błąd: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Nieoczekiwana spacja na pozycji „{1}” warunku „{0}”. Czy zapomniano o usunięciu spacji?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">Ładowanie następującej wtyczki pamięci podręcznej projektu: 
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">Wartość początkowa właściwości: $({0})=„{1}” Źródło: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: wyłączenie węzła InProc prowadzi do obniżenia wydajności, gdy używane są wtyczki pamięci podręcznej projektu, które emitują żądania kompilowania serwera proxy.</target>
@@ -344,6 +360,11 @@
         <target state="translated">Wystąpił błąd programu do rozpoznawania zestawu SDK „{0}” podczas próby rozpoznania zestawu SDK „{1}”. Wyjątek: „{2}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: W przypadku projektu „{0}” pominięto ograniczenia izolacji grafu dla przywoływanego projektu „{1}”</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: Element &lt;{0}&gt; znajdujący się pod elementem &lt;{1}&gt; nie został rozpoznany.</target>
+        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; znajdujący się pod elementem &lt;{1}&gt; nie został rozpoznany.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index c537c8a988f..54b6e04475e 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: A variável de ambiente MSBuildDisableFeaturesFromVersion está definida com um formato inválido. Habilitando todas as versões do ciclo de alterações. Valor inserido: {0}. Ciclos de Alterações Atuais: {1}.</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: A variável de ambiente MSBuildDisableFeaturesFromVersion está definida como uma versão fora de rotação. Usando como padrão a versão do Ciclo de Alterações: {0}. Valor inserido: {1}. Ciclos de Alterações Atuais: {2}.</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: tentativa de criar várias substituições da mesma tarefa: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: a gravação do arquivo de cache do resultado de saída no caminho "{0}" encontrou um erro: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: espaço inesperado na posição "{1}" da condição "{0}". Você esqueceu de remover um espaço?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">Carregando o seguinte plug-in do projeto:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">Valor inicial da propriedade: $({0})="{1}" Origem: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: desativar o nó inproc leva à degradação do desempenho ao usar plug-ins de cache de projeto que emitem solicitações de construção de proxy.</target>
@@ -344,6 +360,11 @@
         <target state="translated">O resolvedor do SDK "{0}" falhou ao tentar resolver o SDK "{1}". Exceção: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: o projeto "{0}" ignorou as restrições de isolamento do gráfico no projeto referenciado "{1}"</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; não é reconhecido.</target>
+        <target state="needs-review-translation">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; não é reconhecido.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 4f5cc43877f..75cd9f7d0c3 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: для переменной среды MSBuildDisableFeaturesFromVersion задан недопустимый формат. Идет включение всех версий волн изменений. Введенное значение: {0}. Текущие волны изменений: {1}.</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: для переменной среды MSBuildDisableFeaturesFromVersion задана версия, которая больше не используется. Идет возвращение к версии волны изменений по умолчанию: {0}. Введенное значение: {1}. Текущие волны изменений: {2}.</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: попытка создать несколько переопределений одной задачи: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: произошла ошибка при записи выходного файла кэша результатов в пути "{0}": {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: неожиданный пробел в позиции "{1}" условия "{0}". Вы забыли удалить пробел?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">Идет загрузка следующего подключаемого модуля кэша проектов:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">Начальное значение свойства: $({0})="{1}" Источник: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: Отключение внутрипроцессного узла приводит к замедлению при использовании плагинов кэша проекта, которые создают запросы на сборку прокси-сервера.</target>
@@ -344,6 +360,11 @@
         <target state="translated">Сбой сопоставителя SDK "{0}" при попытке сопоставить пакет SDK "{1}". Исключение: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: проект "{0}" пропустил ограничения изоляции графа в проекте "{1}", на который указывает ссылка.</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: неопознанный элемент &lt;{0}&gt; в элементе &lt;{1}&gt;.</target>
+        <target state="needs-review-translation">MSB4067: неопознанный элемент &lt;{0}&gt; в элементе &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 4093eb4b5bd..83a86862dee 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: MSBuildDisableFeaturesFromVersion ortam değişkeni geçersiz bir biçime ayarlandı. Tüm değişiklik dalgası sürümleri etkinleştiriliyor. Girilen değer: {0}. Geçerli Değişiklik Dalgaları: {1}.</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: MSBuildDisableFeaturesFromVersion ortam değişkeni, düzenli değişiklik dışı bir sürüme ayarlandı. Varsayılan Değişiklik Dalgası sürümüne dönülüyor: {0}. Girilen değer: {1}. Geçerli Değişiklik Dalgaları: {2}.</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Aynı {0} görevi için birden çok geçersiz kılma işlemi oluşturulmaya çalışıldı</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Çıkış sonucu önbellek dosyası "{0}" yoluna yazılırken bir hatayla karşılaşıldı: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: "{0}" koşulunun "{1}" konumunda beklenmeyen boşluk var. Boşluğu kaldırmayı unutmuş olabilirsiniz.</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">Şu proje önbelleği eklentisi yükleniyor:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">Özellik başlangıç değeri: $({0})="{1}" Kaynak: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: InProc düğümünün devre dışı bırakılması, ara sunucu oluşturma istekleri gönderen proje önbelleği eklentileri kullanılırken performans düşüşüne yol açar.</target>
@@ -344,6 +360,11 @@
         <target state="translated">"{0}" SDK çözümleyicisi, "{1}" SDK'sını çözümlemeye çalışırken başarısız oldu. İstisna: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: "{0}" projesi, başvurulan "{1}" projesindeki graf yalıtımı kısıtlamalarını atladı</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: &lt;{1}&gt; öğesinin altındaki &lt;{0}&gt; öğesi tanınmıyor.</target>
+        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; öğesinin altındaki &lt;{0}&gt; öğesi tanınmıyor.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 87846c55e1b..9be6ea491ba 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: 设置的环境变量 MSBuildDisableFeaturesFromVersion 格式无效。正在启用所有更改批次版本。输入的值: {0}。当前更改批次:{1}。</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: 设置的环境变量 MSBuildDisableFeaturesFromVersion 版本不在轮换范围内。默认为“更改批次”版本: {0}。输入的值: {1}。当前更改批次: {2}。</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: 已尝试创建同一任务的多个重写: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: 从路径“{0}”写入输出结果缓存文件时遇到错误: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: 在条件“{0}”的位置“{1}”处出现意外空格。是否忘记了删除空格?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">正在加载以下项目缓存插件: 
-    {0}”</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">属性初始值: $({0})=“{1}”，源: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: 使用发出代理构建请求的项目缓存插件时，禁用 inproc 节点会导致性能下降。</target>
@@ -344,6 +360,11 @@
         <target state="translated">尝试解析 SDK "{1}" 时，SDK 解析程序 "{0}" 失败。异常: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 项目“{0}”已跳过所引用的项目“{1}”上的图形隔离约束</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: 无法识别元素 &lt;{1}&gt; 下面的元素 &lt;{0}&gt;。</target>
+        <target state="needs-review-translation">MSB4067: 无法识别元素 &lt;{1}&gt; 下面的元素 &lt;{0}&gt;。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 33d70db1062..70f6dd3f097 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -64,12 +64,12 @@
       </trans-unit>
       <trans-unit id="ChangeWave_InvalidFormat">
         <source>MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</source>
-        <target state="needs-review-translation">MSB4271: 環境變數 MSBuildDisableFeaturesFromVersion 設定的格式無效。正在啟用所有變更波版本。輸入的值: {0}。目前的變更波: {1}。</target>
+        <target state="new">MSB4271: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to an invalid format. Enabling all change wave versions. Entered value: {0}. Current Change Waves: {1}.</target>
         <note>{StrBegin="MSB4271: "}UE: Value should be of the format: xx.yy</note>
       </trans-unit>
       <trans-unit id="ChangeWave_OutOfRotation">
         <source>MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</source>
-        <target state="needs-review-translation">MSB4272: 環境變數 MSBuildDisableFeaturesFromVersion 已設定為無法輪替的版本。預設為變更波版本: {0}。輸入的值: {1}。目前的變更波: {2}。</target>
+        <target state="new">MSB4272: Environment variable MSBUILDDISABLEFEATURESFROMVERSION is set to a version that is out of rotation. Defaulting to Change Wave version: {0}. Entered value: {1}. Current Change Waves: {2}.</target>
         <note>{StrBegin="MSB4272: "}</note>
       </trans-unit>
       <trans-unit id="CircularDependency">
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: 已嘗試建立相同工作的多個覆寫: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: 在路徑 "{0}" 中寫入輸出結果快取檔案發生錯誤: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: 條件 "{0}" 的位置 "{1}" 出現非預期的空格。忘記移除空格了嗎?</target>
@@ -149,8 +161,7 @@
       </trans-unit>
       <trans-unit id="LoadingProjectCachePlugin">
         <source>Loading the following project cache plugin: {0}</source>
-        <target state="needs-review-translation">正在載入下列專案快取外掛程式:
-    {0}</target>
+        <target state="new">Loading the following project cache plugin: {0}</target>
         <note />
       </trans-unit>
       <trans-unit id="LogLoggerVerbosity">
@@ -329,6 +340,11 @@
         <target state="translated">屬性初始值: $({0})="{1}" 來源: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: 停用 inproc 節點會在使用可發出 proxy 組建要求的專案快取外掛程式時，導致效能降低。</target>
@@ -344,6 +360,11 @@
         <target state="translated">SDK 解析程式 "{0}" 在嘗試解析 SDK "{1}" 時失敗。例外狀況: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 專案 "{0}" 已跳過參考專案 "{1}" 上的圖形隔離條件約束</target>
@@ -1820,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: 無法辨認項目 &lt;{1}&gt; 下的項目 &lt;{0}&gt;。</target>
+        <target state="needs-review-translation">MSB4067: 無法辨認項目 &lt;{1}&gt; 下的項目 &lt;{0}&gt;。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index 052add40c0a..dd665af000e 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -22,9 +22,11 @@ namespace Microsoft.Build.Utilities
     ///
     /// Treats unspecified components as 0 (e.g. x == x.0 == x.0.0 == x.0.0.0).
     ///
-    /// Unlike System.Version, does not tolerate whitespace, and '+' is ignored as
-    /// semver metadata as described above, not tolerated as positive sign of integer
-    /// component.
+    /// Ignores leading and trailing whitespace, but does not tolerate whitespace
+    /// between components, unlike System.Version.
+    /// 
+    /// Also unlike System.Version, '+' is ignored as semver metadata as described
+    /// above, not tolerated as positive sign of integer component.
     /// </summary>
     /// <remarks>
     /// Tolerating leading 'v' allows using $(TargetFrameworkVersion) directly.
@@ -127,22 +129,23 @@ public static SimpleVersion Parse(string input)
 
         private static ReadOnlySpan<char> RemoveTrivia(string input)
         {
-            int startIndex = 0;
-            int endIndex = input.Length;
+            // Ignore leading/trailing whitespace in input.
+            ReadOnlySpan<char> span = input.AsSpan().Trim();
 
-            if (input.Length > 0 && (input[0] == 'v' || input[0] == 'V'))
+            // Ignore a leading "v".
+            if (span.Length > 0 && (span[0] == 'v' || span[0] == 'V'))
             {
-                startIndex = 1;
+                span = span.Slice(1);
             }
 
-            int separatorIndex = input.IndexOfAny(s_semverSeparators, startIndex);
-
+            // Ignore semver separator and anything after.
+            int separatorIndex = span.IndexOfAny(s_semverSeparators);
             if (separatorIndex >= 0)
             {
-                endIndex = separatorIndex;
+                span = span.Slice(0, separatorIndex);
             }
 
-            return input.AsSpan().Slice(startIndex, endIndex - startIndex);
+            return span;
         }
 
         private static bool ParseComponent(ref ReadOnlySpan<char> span, out int value)
diff --git a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
index 58ad5723984..0f73cd9c6d9 100644
--- a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
+++ b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
@@ -9,6 +9,7 @@
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
     <Nullable>disable</Nullable>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
   <ItemGroup>
     <!-- Source Files -->
diff --git a/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Shipped.txt b/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index cc40354b757..00000000000
--- a/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-Microsoft.Build.Conversion.ProjectFileConverter
-Microsoft.Build.Conversion.ProjectFileConverter.ConversionSkippedBecauseProjectAlreadyConverted.get -> bool
-Microsoft.Build.Conversion.ProjectFileConverter.ConversionWarnings.get -> string[]
-Microsoft.Build.Conversion.ProjectFileConverter.Convert() -> void
-Microsoft.Build.Conversion.ProjectFileConverter.Convert(Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
-Microsoft.Build.Conversion.ProjectFileConverter.Convert(string msbuildBinPath) -> void
-Microsoft.Build.Conversion.ProjectFileConverter.ConvertInMemory() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Conversion.ProjectFileConverter.ConvertInMemory(Microsoft.Build.BuildEngine.Engine engine) -> Microsoft.Build.BuildEngine.Project
-Microsoft.Build.Conversion.ProjectFileConverter.ConvertInMemory(Microsoft.Build.BuildEngine.Engine engine, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> Microsoft.Build.BuildEngine.Project
-Microsoft.Build.Conversion.ProjectFileConverter.FSharpSpecificConversions(bool actuallyMakeChanges) -> bool
-Microsoft.Build.Conversion.ProjectFileConverter.IsMinorUpgrade.get -> bool
-Microsoft.Build.Conversion.ProjectFileConverter.IsMinorUpgrade.set -> void
-Microsoft.Build.Conversion.ProjectFileConverter.IsUserFile.get -> bool
-Microsoft.Build.Conversion.ProjectFileConverter.IsUserFile.set -> void
-Microsoft.Build.Conversion.ProjectFileConverter.NewProjectFile.get -> string
-Microsoft.Build.Conversion.ProjectFileConverter.NewProjectFile.set -> void
-Microsoft.Build.Conversion.ProjectFileConverter.OldProjectFile.get -> string
-Microsoft.Build.Conversion.ProjectFileConverter.OldProjectFile.set -> void
-Microsoft.Build.Conversion.ProjectFileConverter.ProjectFileConverter() -> void
-Microsoft.Build.Conversion.ProjectFileConverter.SolutionFile.get -> string
-Microsoft.Build.Conversion.ProjectFileConverter.SolutionFile.set -> void
\ No newline at end of file
diff --git a/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
index 051c7517343..2b627bf1f99 100644
--- a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
+++ b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
@@ -14,6 +14,7 @@
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
     <Nullable>disable</Nullable>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Shipped.txt b/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index 7abb6ba25e8..00000000000
--- a/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,419 +0,0 @@
-Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItem.BuildItem(string itemName, Microsoft.Build.Framework.ITaskItem taskItem) -> void
-Microsoft.Build.BuildEngine.BuildItem.BuildItem(string itemName, string itemInclude) -> void
-Microsoft.Build.BuildEngine.BuildItem.Clone() -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItem.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildItem.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildItem.CopyCustomMetadataTo(Microsoft.Build.BuildEngine.BuildItem destinationItem) -> void
-Microsoft.Build.BuildEngine.BuildItem.CustomMetadataCount.get -> int
-Microsoft.Build.BuildEngine.BuildItem.CustomMetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.BuildEngine.BuildItem.Exclude.get -> string
-Microsoft.Build.BuildEngine.BuildItem.Exclude.set -> void
-Microsoft.Build.BuildEngine.BuildItem.FinalItemSpec.get -> string
-Microsoft.Build.BuildEngine.BuildItem.GetEvaluatedMetadata(string metadataName) -> string
-Microsoft.Build.BuildEngine.BuildItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.BuildEngine.BuildItem.HasMetadata(string metadataName) -> bool
-Microsoft.Build.BuildEngine.BuildItem.Include.get -> string
-Microsoft.Build.BuildEngine.BuildItem.Include.set -> void
-Microsoft.Build.BuildEngine.BuildItem.IsImported.get -> bool
-Microsoft.Build.BuildEngine.BuildItem.MetadataCount.get -> int
-Microsoft.Build.BuildEngine.BuildItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.BuildEngine.BuildItem.Name.get -> string
-Microsoft.Build.BuildEngine.BuildItem.Name.set -> void
-Microsoft.Build.BuildEngine.BuildItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.BuildEngine.BuildItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.BuildEngine.BuildItem.SetMetadata(string metadataName, string metadataValue, bool treatMetadataValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.BuildItemGroup.AddNewItem(string itemName, string itemInclude) -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItemGroup.AddNewItem(string itemName, string itemInclude, bool treatItemIncludeAsLiteral) -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItemGroup.BuildItemGroup() -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.Clear() -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.Clone(bool deepClone) -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.BuildItemGroup.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildItemGroup.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.Count.get -> int
-Microsoft.Build.BuildEngine.BuildItemGroup.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.BuildItemGroup.IsImported.get -> bool
-Microsoft.Build.BuildEngine.BuildItemGroup.RemoveItem(Microsoft.Build.BuildEngine.BuildItem itemToRemove) -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.RemoveItemAt(int index) -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.this[int index].get -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItemGroup.ToArray() -> Microsoft.Build.BuildEngine.BuildItem[]
-Microsoft.Build.BuildEngine.BuildItemGroupCollection
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.Count.get -> int
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildProperty.BuildProperty(string propertyName, string propertyValue) -> void
-Microsoft.Build.BuildEngine.BuildProperty.Clone(bool deepClone) -> Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildProperty.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildProperty.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildProperty.FinalValue.get -> string
-Microsoft.Build.BuildEngine.BuildProperty.IsImported.get -> bool
-Microsoft.Build.BuildEngine.BuildProperty.Name.get -> string
-Microsoft.Build.BuildEngine.BuildProperty.Value.get -> string
-Microsoft.Build.BuildEngine.BuildProperty.Value.set -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.BuildPropertyGroup.AddNewProperty(string propertyName, string propertyValue) -> Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildPropertyGroup.AddNewProperty(string propertyName, string propertyValue, bool treatPropertyValueAsLiteral) -> Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildPropertyGroup.BuildPropertyGroup() -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.BuildPropertyGroup(Microsoft.Build.BuildEngine.Project parentProject) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Clear() -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Clone(bool deepClone) -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Count.get -> int
-Microsoft.Build.BuildEngine.BuildPropertyGroup.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.BuildPropertyGroup.IsImported.get -> bool
-Microsoft.Build.BuildEngine.BuildPropertyGroup.RemoveProperty(Microsoft.Build.BuildEngine.BuildProperty property) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.RemoveProperty(string propertyName) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.SetImportedPropertyGroupCondition(string condition) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.SetProperty(string propertyName, string propertyValue) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.SetProperty(string propertyName, string propertyValue, bool treatPropertyValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.this[string propertyName].get -> Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildPropertyGroup.this[string propertyName].set -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.Count.get -> int
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.BuildSettings
-Microsoft.Build.BuildEngine.BuildSettings.DoNotResetPreviouslyBuiltTargets = 1 -> Microsoft.Build.BuildEngine.BuildSettings
-Microsoft.Build.BuildEngine.BuildSettings.None = 0 -> Microsoft.Build.BuildEngine.BuildSettings
-Microsoft.Build.BuildEngine.BuildTask
-Microsoft.Build.BuildEngine.BuildTask.AddOutputItem(string taskParameter, string itemName) -> void
-Microsoft.Build.BuildEngine.BuildTask.AddOutputProperty(string taskParameter, string propertyName) -> void
-Microsoft.Build.BuildEngine.BuildTask.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildTask.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildTask.ContinueOnError.get -> bool
-Microsoft.Build.BuildEngine.BuildTask.ContinueOnError.set -> void
-Microsoft.Build.BuildEngine.BuildTask.Execute() -> bool
-Microsoft.Build.BuildEngine.BuildTask.GetParameterNames() -> string[]
-Microsoft.Build.BuildEngine.BuildTask.GetParameterValue(string attributeName) -> string
-Microsoft.Build.BuildEngine.BuildTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.BuildEngine.BuildTask.HostObject.set -> void
-Microsoft.Build.BuildEngine.BuildTask.Name.get -> string
-Microsoft.Build.BuildEngine.BuildTask.SetParameterValue(string parameterName, string parameterValue) -> void
-Microsoft.Build.BuildEngine.BuildTask.SetParameterValue(string parameterName, string parameterValue, bool treatParameterValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.BuildTask.Type.get -> System.Type
-Microsoft.Build.BuildEngine.ColorResetter
-Microsoft.Build.BuildEngine.ColorSetter
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.ConfigurableForwardingLogger() -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.NodeId.get -> int
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.NodeId.set -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Parameters.get -> string
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Parameters.set -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Verbosity.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger
-Microsoft.Build.BuildEngine.ConsoleLogger.ApplyParameter(string parameterName, string parameterValue) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ConsoleLogger() -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.BuildEngine.WriteHandler write, Microsoft.Build.BuildEngine.ColorSetter colorSet, Microsoft.Build.BuildEngine.ColorResetter colorReset) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.Parameters.get -> string
-Microsoft.Build.BuildEngine.ConsoleLogger.Parameters.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ShowSummary.get -> bool
-Microsoft.Build.BuildEngine.ConsoleLogger.ShowSummary.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.SkipProjectStartedText.get -> bool
-Microsoft.Build.BuildEngine.ConsoleLogger.SkipProjectStartedText.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.BuildEngine.ConsoleLogger.Verbosity.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.WriteHandler.get -> Microsoft.Build.BuildEngine.WriteHandler
-Microsoft.Build.BuildEngine.ConsoleLogger.WriteHandler.set -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger
-Microsoft.Build.BuildEngine.DistributedFileLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.BuildEngine.DistributedFileLogger.BuildEventRedirector.set -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.DistributedFileLogger() -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.NodeId.get -> int
-Microsoft.Build.BuildEngine.DistributedFileLogger.NodeId.set -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Parameters.get -> string
-Microsoft.Build.BuildEngine.DistributedFileLogger.Parameters.set -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Shutdown() -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.BuildEngine.DistributedFileLogger.Verbosity.set -> void
-Microsoft.Build.BuildEngine.Engine
-Microsoft.Build.BuildEngine.Engine.BinPath.get -> string
-Microsoft.Build.BuildEngine.Engine.BinPath.set -> void
-Microsoft.Build.BuildEngine.Engine.BuildEnabled.get -> bool
-Microsoft.Build.BuildEngine.Engine.BuildEnabled.set -> void
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string targetName) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string targetName) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags, string toolsVersion) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject, Microsoft.Build.BuildEngine.BuildPropertyGroup[] globalPropertiesPerProject, System.Collections.IDictionary[] targetOutputsPerProject, Microsoft.Build.BuildEngine.BuildSettings buildFlags, string[] toolsVersions) -> bool
-Microsoft.Build.BuildEngine.Engine.CreateNewProject() -> Microsoft.Build.BuildEngine.Project
-Microsoft.Build.BuildEngine.Engine.DefaultToolsVersion.get -> string
-Microsoft.Build.BuildEngine.Engine.DefaultToolsVersion.set -> void
-Microsoft.Build.BuildEngine.Engine.Engine() -> void
-Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties) -> void
-Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations) -> void
-Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations, int numberOfCpus, string localNodeProviderParameters) -> void
-Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations) -> void
-Microsoft.Build.BuildEngine.Engine.Engine(string binPath) -> void
-Microsoft.Build.BuildEngine.Engine.GetLoadedProject(string projectFullFileName) -> Microsoft.Build.BuildEngine.Project
-Microsoft.Build.BuildEngine.Engine.GlobalProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Engine.GlobalProperties.set -> void
-Microsoft.Build.BuildEngine.Engine.IsBuilding.get -> bool
-Microsoft.Build.BuildEngine.Engine.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.BuildEngine.Engine.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.BuildEngine.Engine.RegisterDistributedLogger(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.BuildEngine.LoggerDescription forwardingLogger) -> void
-Microsoft.Build.BuildEngine.Engine.RegisterLogger(Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.BuildEngine.Engine.Shutdown() -> void
-Microsoft.Build.BuildEngine.Engine.Toolsets.get -> Microsoft.Build.BuildEngine.ToolsetCollection
-Microsoft.Build.BuildEngine.Engine.UnloadAllProjects() -> void
-Microsoft.Build.BuildEngine.Engine.UnloadProject(Microsoft.Build.BuildEngine.Project project) -> void
-Microsoft.Build.BuildEngine.Engine.UnregisterAllLoggers() -> void
-Microsoft.Build.BuildEngine.FileLogger
-Microsoft.Build.BuildEngine.FileLogger.FileLogger() -> void
-Microsoft.Build.BuildEngine.Import
-Microsoft.Build.BuildEngine.Import.Condition.get -> string
-Microsoft.Build.BuildEngine.Import.Condition.set -> void
-Microsoft.Build.BuildEngine.Import.EvaluatedProjectPath.get -> string
-Microsoft.Build.BuildEngine.Import.IsImported.get -> bool
-Microsoft.Build.BuildEngine.Import.ProjectPath.get -> string
-Microsoft.Build.BuildEngine.Import.ProjectPath.set -> void
-Microsoft.Build.BuildEngine.ImportCollection
-Microsoft.Build.BuildEngine.ImportCollection.AddNewImport(string projectFile, string condition) -> void
-Microsoft.Build.BuildEngine.ImportCollection.CopyTo(Microsoft.Build.BuildEngine.Import[] array, int index) -> void
-Microsoft.Build.BuildEngine.ImportCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.ImportCollection.Count.get -> int
-Microsoft.Build.BuildEngine.ImportCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.ImportCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.ImportCollection.RemoveImport(Microsoft.Build.BuildEngine.Import importToRemove) -> void
-Microsoft.Build.BuildEngine.ImportCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.InternalLoggerException
-Microsoft.Build.BuildEngine.InternalLoggerException.BuildEventArgs.get -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.BuildEngine.InternalLoggerException.ErrorCode.get -> string
-Microsoft.Build.BuildEngine.InternalLoggerException.HelpKeyword.get -> string
-Microsoft.Build.BuildEngine.InternalLoggerException.InitializationException.get -> bool
-Microsoft.Build.BuildEngine.InternalLoggerException.InternalLoggerException() -> void
-Microsoft.Build.BuildEngine.InternalLoggerException.InternalLoggerException(string message) -> void
-Microsoft.Build.BuildEngine.InternalLoggerException.InternalLoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException
-Microsoft.Build.BuildEngine.InvalidProjectFileException.BaseMessage.get -> string
-Microsoft.Build.BuildEngine.InvalidProjectFileException.ColumnNumber.get -> int
-Microsoft.Build.BuildEngine.InvalidProjectFileException.EndColumnNumber.get -> int
-Microsoft.Build.BuildEngine.InvalidProjectFileException.EndLineNumber.get -> int
-Microsoft.Build.BuildEngine.InvalidProjectFileException.ErrorCode.get -> string
-Microsoft.Build.BuildEngine.InvalidProjectFileException.ErrorSubcategory.get -> string
-Microsoft.Build.BuildEngine.InvalidProjectFileException.HelpKeyword.get -> string
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException() -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(string message) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(string message, System.Exception innerException) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(System.Xml.XmlNode xmlNode, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.LineNumber.get -> int
-Microsoft.Build.BuildEngine.InvalidProjectFileException.ProjectFile.get -> string
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.ErrorCode.get -> string
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException() -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message) -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode) -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, System.Exception innerException) -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.BuildEngine.LocalNode
-Microsoft.Build.BuildEngine.LoggerDescription
-Microsoft.Build.BuildEngine.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.BuildEngine.LoggerDescription.LoggerSwitchParameters.get -> string
-Microsoft.Build.BuildEngine.LoggerDescription.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.BuildEngine.Project
-Microsoft.Build.BuildEngine.Project.AddNewImport(string projectFile, string condition) -> void
-Microsoft.Build.BuildEngine.Project.AddNewItem(string itemName, string itemInclude) -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.Project.AddNewItem(string itemName, string itemInclude, bool treatItemIncludeAsLiteral) -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.Project.AddNewItemGroup() -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.AddNewPropertyGroup(bool insertAtEndOfProject) -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Project.AddNewUsingTaskFromAssemblyFile(string taskName, string assemblyFile) -> void
-Microsoft.Build.BuildEngine.Project.AddNewUsingTaskFromAssemblyName(string taskName, string assemblyName) -> void
-Microsoft.Build.BuildEngine.Project.Build() -> bool
-Microsoft.Build.BuildEngine.Project.Build(string targetName) -> bool
-Microsoft.Build.BuildEngine.Project.Build(string[] targetNames) -> bool
-Microsoft.Build.BuildEngine.Project.Build(string[] targetNames, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.BuildEngine.Project.Build(string[] targetNames, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) -> bool
-Microsoft.Build.BuildEngine.Project.BuildEnabled.get -> bool
-Microsoft.Build.BuildEngine.Project.BuildEnabled.set -> void
-Microsoft.Build.BuildEngine.Project.DefaultTargets.get -> string
-Microsoft.Build.BuildEngine.Project.DefaultTargets.set -> void
-Microsoft.Build.BuildEngine.Project.DefaultToolsVersion.get -> string
-Microsoft.Build.BuildEngine.Project.DefaultToolsVersion.set -> void
-Microsoft.Build.BuildEngine.Project.Encoding.get -> System.Text.Encoding
-Microsoft.Build.BuildEngine.Project.EvaluatedItems.get -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.EvaluatedItemsIgnoringCondition.get -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.EvaluatedProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Project.FullFileName.get -> string
-Microsoft.Build.BuildEngine.Project.FullFileName.set -> void
-Microsoft.Build.BuildEngine.Project.GetConditionedPropertyValues(string propertyName) -> string[]
-Microsoft.Build.BuildEngine.Project.GetEvaluatedItemsByName(string itemName) -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.GetEvaluatedItemsByNameIgnoringCondition(string itemName) -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.GetEvaluatedProperty(string propertyName) -> string
-Microsoft.Build.BuildEngine.Project.GetProjectExtensions(string id) -> string
-Microsoft.Build.BuildEngine.Project.GlobalProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Project.GlobalProperties.set -> void
-Microsoft.Build.BuildEngine.Project.HasToolsVersionAttribute.get -> bool
-Microsoft.Build.BuildEngine.Project.Imports.get -> Microsoft.Build.BuildEngine.ImportCollection
-Microsoft.Build.BuildEngine.Project.InitialTargets.get -> string
-Microsoft.Build.BuildEngine.Project.InitialTargets.set -> void
-Microsoft.Build.BuildEngine.Project.IsDirty.get -> bool
-Microsoft.Build.BuildEngine.Project.IsValidated.get -> bool
-Microsoft.Build.BuildEngine.Project.IsValidated.set -> void
-Microsoft.Build.BuildEngine.Project.ItemGroups.get -> Microsoft.Build.BuildEngine.BuildItemGroupCollection
-Microsoft.Build.BuildEngine.Project.Load(string projectFileName) -> void
-Microsoft.Build.BuildEngine.Project.Load(string projectFileName, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
-Microsoft.Build.BuildEngine.Project.Load(System.IO.TextReader textReader) -> void
-Microsoft.Build.BuildEngine.Project.Load(System.IO.TextReader textReader, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
-Microsoft.Build.BuildEngine.Project.LoadXml(string projectXml) -> void
-Microsoft.Build.BuildEngine.Project.LoadXml(string projectXml, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
-Microsoft.Build.BuildEngine.Project.MarkProjectAsDirty() -> void
-Microsoft.Build.BuildEngine.Project.ParentEngine.get -> Microsoft.Build.BuildEngine.Engine
-Microsoft.Build.BuildEngine.Project.Project() -> void
-Microsoft.Build.BuildEngine.Project.Project(Microsoft.Build.BuildEngine.Engine engine) -> void
-Microsoft.Build.BuildEngine.Project.Project(Microsoft.Build.BuildEngine.Engine engine, string toolsVersion) -> void
-Microsoft.Build.BuildEngine.Project.PropertyGroups.get -> Microsoft.Build.BuildEngine.BuildPropertyGroupCollection
-Microsoft.Build.BuildEngine.Project.RemoveAllItemGroups() -> void
-Microsoft.Build.BuildEngine.Project.RemoveAllPropertyGroups() -> void
-Microsoft.Build.BuildEngine.Project.RemoveImportedPropertyGroup(Microsoft.Build.BuildEngine.BuildPropertyGroup propertyGroupToRemove) -> void
-Microsoft.Build.BuildEngine.Project.RemoveItem(Microsoft.Build.BuildEngine.BuildItem itemToRemove) -> void
-Microsoft.Build.BuildEngine.Project.RemoveItemGroup(Microsoft.Build.BuildEngine.BuildItemGroup itemGroupToRemove) -> void
-Microsoft.Build.BuildEngine.Project.RemoveItemGroupsWithMatchingCondition(string matchCondition) -> void
-Microsoft.Build.BuildEngine.Project.RemoveItemsByName(string itemName) -> void
-Microsoft.Build.BuildEngine.Project.RemovePropertyGroup(Microsoft.Build.BuildEngine.BuildPropertyGroup propertyGroupToRemove) -> void
-Microsoft.Build.BuildEngine.Project.RemovePropertyGroupsWithMatchingCondition(string matchCondition) -> void
-Microsoft.Build.BuildEngine.Project.RemovePropertyGroupsWithMatchingCondition(string matchCondition, bool includeImportedPropertyGroups) -> void
-Microsoft.Build.BuildEngine.Project.ResetBuildStatus() -> void
-Microsoft.Build.BuildEngine.Project.Save(string projectFileName) -> void
-Microsoft.Build.BuildEngine.Project.Save(string projectFileName, System.Text.Encoding encoding) -> void
-Microsoft.Build.BuildEngine.Project.Save(System.IO.TextWriter textWriter) -> void
-Microsoft.Build.BuildEngine.Project.SchemaFile.get -> string
-Microsoft.Build.BuildEngine.Project.SchemaFile.set -> void
-Microsoft.Build.BuildEngine.Project.SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importedProject, Microsoft.Build.BuildEngine.PropertyPosition position) -> void
-Microsoft.Build.BuildEngine.Project.SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importedProject, Microsoft.Build.BuildEngine.PropertyPosition position, bool treatPropertyValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.Project.SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importProject) -> void
-Microsoft.Build.BuildEngine.Project.SetProjectExtensions(string id, string content) -> void
-Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue) -> void
-Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue, string condition) -> void
-Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.PropertyPosition position) -> void
-Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.PropertyPosition position, bool treatPropertyValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.Project.Targets.get -> Microsoft.Build.BuildEngine.TargetCollection
-Microsoft.Build.BuildEngine.Project.TimeOfLastDirty.get -> System.DateTime
-Microsoft.Build.BuildEngine.Project.ToolsVersion.get -> string
-Microsoft.Build.BuildEngine.Project.UsingTasks.get -> Microsoft.Build.BuildEngine.UsingTaskCollection
-Microsoft.Build.BuildEngine.Project.Xml.get -> string
-Microsoft.Build.BuildEngine.ProjectLoadSettings
-Microsoft.Build.BuildEngine.ProjectLoadSettings.IgnoreMissingImports = 1 -> Microsoft.Build.BuildEngine.ProjectLoadSettings
-Microsoft.Build.BuildEngine.ProjectLoadSettings.None = 0 -> Microsoft.Build.BuildEngine.ProjectLoadSettings
-Microsoft.Build.BuildEngine.PropertyPosition
-Microsoft.Build.BuildEngine.PropertyPosition.UseExistingOrCreateAfterLastImport = 1 -> Microsoft.Build.BuildEngine.PropertyPosition
-Microsoft.Build.BuildEngine.PropertyPosition.UseExistingOrCreateAfterLastPropertyGroup = 0 -> Microsoft.Build.BuildEngine.PropertyPosition
-Microsoft.Build.BuildEngine.RemoteErrorException
-Microsoft.Build.BuildEngine.SolutionWrapperProject
-Microsoft.Build.BuildEngine.Target
-Microsoft.Build.BuildEngine.Target.AddNewTask(string taskName) -> Microsoft.Build.BuildEngine.BuildTask
-Microsoft.Build.BuildEngine.Target.Condition.get -> string
-Microsoft.Build.BuildEngine.Target.Condition.set -> void
-Microsoft.Build.BuildEngine.Target.DependsOnTargets.get -> string
-Microsoft.Build.BuildEngine.Target.DependsOnTargets.set -> void
-Microsoft.Build.BuildEngine.Target.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.Target.Inputs.get -> string
-Microsoft.Build.BuildEngine.Target.Inputs.set -> void
-Microsoft.Build.BuildEngine.Target.IsImported.get -> bool
-Microsoft.Build.BuildEngine.Target.Name.get -> string
-Microsoft.Build.BuildEngine.Target.Outputs.get -> string
-Microsoft.Build.BuildEngine.Target.Outputs.set -> void
-Microsoft.Build.BuildEngine.Target.RemoveTask(Microsoft.Build.BuildEngine.BuildTask taskElement) -> void
-Microsoft.Build.BuildEngine.TargetCollection
-Microsoft.Build.BuildEngine.TargetCollection.AddNewTarget(string targetName) -> Microsoft.Build.BuildEngine.Target
-Microsoft.Build.BuildEngine.TargetCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.TargetCollection.Count.get -> int
-Microsoft.Build.BuildEngine.TargetCollection.Exists(string targetName) -> bool
-Microsoft.Build.BuildEngine.TargetCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.TargetCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.TargetCollection.RemoveTarget(Microsoft.Build.BuildEngine.Target targetToRemove) -> void
-Microsoft.Build.BuildEngine.TargetCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.TargetCollection.this[string index].get -> Microsoft.Build.BuildEngine.Target
-Microsoft.Build.BuildEngine.Toolset
-Microsoft.Build.BuildEngine.Toolset.BuildProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Toolset.Clone() -> Microsoft.Build.BuildEngine.Toolset
-Microsoft.Build.BuildEngine.Toolset.Toolset(string toolsVersion, string toolsPath) -> void
-Microsoft.Build.BuildEngine.Toolset.Toolset(string toolsVersion, string toolsPath, Microsoft.Build.BuildEngine.BuildPropertyGroup buildProperties) -> void
-Microsoft.Build.BuildEngine.Toolset.ToolsPath.get -> string
-Microsoft.Build.BuildEngine.Toolset.ToolsVersion.get -> string
-Microsoft.Build.BuildEngine.ToolsetCollection
-Microsoft.Build.BuildEngine.ToolsetCollection.Add(Microsoft.Build.BuildEngine.Toolset item) -> void
-Microsoft.Build.BuildEngine.ToolsetCollection.Clear() -> void
-Microsoft.Build.BuildEngine.ToolsetCollection.Contains(Microsoft.Build.BuildEngine.Toolset item) -> bool
-Microsoft.Build.BuildEngine.ToolsetCollection.Contains(string toolsVersion) -> bool
-Microsoft.Build.BuildEngine.ToolsetCollection.CopyTo(Microsoft.Build.BuildEngine.Toolset[] array, int arrayIndex) -> void
-Microsoft.Build.BuildEngine.ToolsetCollection.Count.get -> int
-Microsoft.Build.BuildEngine.ToolsetCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<Microsoft.Build.BuildEngine.Toolset>
-Microsoft.Build.BuildEngine.ToolsetCollection.IsReadOnly.get -> bool
-Microsoft.Build.BuildEngine.ToolsetCollection.Remove(Microsoft.Build.BuildEngine.Toolset item) -> bool
-Microsoft.Build.BuildEngine.ToolsetCollection.this[string toolsVersion].get -> Microsoft.Build.BuildEngine.Toolset
-Microsoft.Build.BuildEngine.ToolsetCollection.ToolsVersions.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
-Microsoft.Build.BuildEngine.ToolsetDefinitionLocations.ConfigurationFile = 1 -> Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
-Microsoft.Build.BuildEngine.ToolsetDefinitionLocations.None = 0 -> Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
-Microsoft.Build.BuildEngine.ToolsetDefinitionLocations.Registry = 2 -> Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
-Microsoft.Build.BuildEngine.UsingTask
-Microsoft.Build.BuildEngine.UsingTask.AssemblyFile.get -> string
-Microsoft.Build.BuildEngine.UsingTask.AssemblyName.get -> string
-Microsoft.Build.BuildEngine.UsingTask.Condition.get -> string
-Microsoft.Build.BuildEngine.UsingTask.IsImported.get -> bool
-Microsoft.Build.BuildEngine.UsingTask.TaskName.get -> string
-Microsoft.Build.BuildEngine.UsingTaskCollection
-Microsoft.Build.BuildEngine.UsingTaskCollection.CopyTo(Microsoft.Build.BuildEngine.UsingTask[] array, int index) -> void
-Microsoft.Build.BuildEngine.UsingTaskCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.UsingTaskCollection.Count.get -> int
-Microsoft.Build.BuildEngine.UsingTaskCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.UsingTaskCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.UsingTaskCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.Utilities
-Microsoft.Build.BuildEngine.WriteHandler
-override Microsoft.Build.BuildEngine.BuildProperty.ToString() -> string
-override Microsoft.Build.BuildEngine.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-override Microsoft.Build.BuildEngine.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-override Microsoft.Build.BuildEngine.FileLogger.Shutdown() -> void
-override Microsoft.Build.BuildEngine.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.BuildEngine.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.BuildEngine.InvalidProjectFileException.Message.get -> string
-override Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.BuildEngine.RemoteErrorException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-static Microsoft.Build.BuildEngine.BuildProperty.explicit operator string(Microsoft.Build.BuildEngine.BuildProperty propertyToCast) -> string
-static Microsoft.Build.BuildEngine.Engine.GlobalEngine.get -> Microsoft.Build.BuildEngine.Engine
-static Microsoft.Build.BuildEngine.Engine.Version.get -> System.Version
-static Microsoft.Build.BuildEngine.LocalNode.StartLocalNodeServer(int nodeNumber) -> void
-static Microsoft.Build.BuildEngine.SolutionWrapperProject.Generate(string solutionPath, string toolsVersionOverride, Microsoft.Build.Framework.BuildEventContext projectBuildEventContext) -> string
-static Microsoft.Build.BuildEngine.Utilities.Escape(string unescapedExpression) -> string
-virtual Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) -> void
-virtual Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Shutdown() -> void
-virtual Microsoft.Build.BuildEngine.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.BuildEngine.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-virtual Microsoft.Build.BuildEngine.ConsoleLogger.Shutdown() -> void
\ No newline at end of file
diff --git a/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 2495ec35840..fe1a2d71613 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -91,14 +91,6 @@
     <GenAPIFolderPath>$(RepoRoot)ref\$(GenAPIAssemblyName)\$(GenAPIShortFrameworkIdentifier)\</GenAPIFolderPath>
   </PropertyGroup>
 
-  <ItemGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true'">
-    <!-- Ensure API stability for shipping packages -->
-    <PackageReference Include="Microsoft.CodeAnalysis.PublicApiAnalyzers" PrivateAssets="all" Condition="'$(DotNetBuildFromSource)' != 'true'" />
-
-    <AdditionalFiles Include="PublicAPI/$(PublicApiTfm)/PublicAPI.Shipped.txt" />
-    <AdditionalFiles Include="PublicAPI/$(PublicApiTfm)/PublicAPI.Unshipped.txt" />
-  </ItemGroup>
-
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true' And '$(TargetFrameworkIdentifier)' != '.NETFramework' ">
     <PackageReference Include="xunit.console" />
   </ItemGroup>
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index deff3e26750..91acdc9bc59 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -24,10 +24,10 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves-Dev.md
     internal class ChangeWaves
     {
-        internal static readonly Version Wave17_0 = new Version(17, 0);
         internal static readonly Version Wave17_2 = new Version(17, 2);
         internal static readonly Version Wave17_4 = new Version(17, 4);
-        internal static readonly Version[] AllWaves = { Wave17_0, Wave17_2, Wave17_4 };
+        internal static readonly Version Wave17_6 = new Version(17, 6);
+        internal static readonly Version[] AllWaves = { Wave17_2, Wave17_4, Wave17_6 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/CompatibilitySuppressions.xml b/src/Framework/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..993613f410e
--- /dev/null
+++ b/src/Framework/CompatibilitySuppressions.xml
@@ -0,0 +1,56 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
+       This is intentional, because you can only use MSBuild in the context of a .NET SDK
+       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
+       have previously shipped netstandard2.0 packages, and if you want to support both
+       runtime contexts it still makes sense to target that. -->
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETCoreApp,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.1</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.2</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.3</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETStandard,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Tizen,Version=v4.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>UAP,Version=v10.0.15064</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation3,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation4,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStationVita,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.Xbox360,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.XboxOne,Version=v0.0</Target>
+  </Suppression>
+</Suppressions>
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index 5cd5303e605..a214a751443 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -76,17 +76,15 @@ internal class FileClassifier
         /// </remarks>
         public FileClassifier()
         {
-            string? programFiles32 = Environment.GetEnvironmentVariable("ProgramFiles(x86)");
-            string? programFiles64 = Environment.GetEnvironmentVariable("ProgramW6432");
-
-            if (!string.IsNullOrEmpty(programFiles32))
-            {
-                RegisterImmutableDirectory(Path.Combine(programFiles32, "Reference Assemblies", "Microsoft"));
-            }
-
-            if (!string.IsNullOrEmpty(programFiles64))
+            // Register Microsoft "Reference Assemblies" as immutable
+            string[] programFilesEnvs = new[] { "ProgramFiles(x86)", "ProgramW6432", "ProgramFiles(Arm)" };
+            foreach (string programFilesEnv in programFilesEnvs)
             {
-                RegisterImmutableDirectory(Path.Combine(programFiles64, "Reference Assemblies", "Microsoft"));
+                string? programFiles = Environment.GetEnvironmentVariable(programFilesEnv);
+                if (!string.IsNullOrEmpty(programFiles))
+                {
+                    RegisterImmutableDirectory(Path.Combine(programFiles, "Reference Assemblies", "Microsoft"));
+                }
             }
 
 #if !RUNTIME_TYPE_NETCORE
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index b4c3190f3b4..724e1a38496 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -8,6 +8,7 @@
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which is a common assembly used by other MSBuild assemblies.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">full</ApplyNgenOptimization>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 60d986402ca..f871d073876 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -10,6 +10,7 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
+using System.Text;
 using System.Threading;
 
 using Microsoft.Build.Shared;
@@ -36,7 +37,6 @@ internal static class NativeMethods
     internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
     internal const uint FILE_TYPE_CHAR = 0x0002;
     internal const Int32 STD_OUTPUT_HANDLE = -11;
-    internal const uint DISABLE_NEWLINE_AUTO_RETURN = 0x0008;
     internal const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;
     internal const uint RPC_S_CALLPENDING = 0x80010115;
     internal const uint E_ABORT = (uint)0x80004004;
@@ -201,9 +201,16 @@ internal enum ProcessorArchitectures
         Unknown
     }
 
-#endregion
+    internal enum SymbolicLink
+    {
+        File = 0,
+        Directory = 1,
+        AllowUnprivilegedCreate = 2,
+    }
 
-#region Structs
+    #endregion
+
+    #region Structs
 
     /// <summary>
     /// Structure that contain information about the system on which we are running
@@ -506,16 +513,10 @@ public static int GetLogicalCoreCount()
     {
         int numberOfCpus = Environment.ProcessorCount;
 #if !MONO
-        // .NET Core on Windows returns a core count limited to the current NUMA node
+        // .NET on Windows returns a core count limited to the current NUMA node
         //     https://github.com/dotnet/runtime/issues/29686
         // so always double-check it.
-        if (IsWindows
-#if NETFRAMEWORK
-            // .NET Framework calls Windows APIs that have a core count limit (32/64 depending on process bitness).
-            // So if we get a high core count on full framework, double-check it.
-            && (numberOfCpus >= 32)
-#endif
-            )
+        if (IsWindows)
         {
             var result = GetLogicalCoreCountOnWindows();
             if (result != -1)
@@ -1042,6 +1043,123 @@ internal static MemoryStatus GetMemoryStatus()
         return null;
     }
 
+    internal static bool ExistAndHasContent(string path)
+    {
+        var fileInfo = new FileInfo(path);
+
+        // File exist and has some content
+        return fileInfo.Exists &&
+               (fileInfo.Length > 0 ||
+                    // Or final destination of the link is nonempty file
+                    (
+                        IsSymLink(fileInfo) &&
+                        TryGetFinalLinkTarget(fileInfo, out string finalTarget, out _) &&
+                        File.Exists(finalTarget) &&
+                        new FileInfo(finalTarget).Length > 0
+                    )
+               );
+    }
+
+    internal static bool IsSymLink(FileInfo fileInfo)
+    {
+#if NET
+        return fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget);
+#else
+        if (!IsWindows)
+        {
+            return false;
+        }
+
+        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
+
+        return NativeMethods.GetFileAttributesEx(fileInfo.FullName, 0, ref data) &&
+               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&
+               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;
+#endif
+    }
+
+    internal static bool IsSymLink(string path)
+    {
+        return IsSymLink(new FileInfo(path));
+    }
+
+    internal static bool TryGetFinalLinkTarget(FileInfo fileInfo, out string finalTarget, out string errorMessage)
+    {
+        if (!IsWindows)
+        {
+            errorMessage = null;
+#if NET
+            while(!string.IsNullOrEmpty(fileInfo.LinkTarget))
+            {
+                fileInfo = new FileInfo(fileInfo.LinkTarget);
+            }
+            finalTarget = fileInfo.FullName;
+            return true;
+#else
+
+            finalTarget = null;
+            return false;
+#endif
+        }
+
+        using SafeFileHandle handle = OpenFileThroughSymlinks(fileInfo.FullName);
+        if (handle.IsInvalid)
+        {
+            // Link is broken.
+            errorMessage = Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
+            finalTarget = null;
+            return false;
+        }
+
+        const int initialBufferSize = 4096;
+        char[] targetPathBuffer = new char[initialBufferSize];
+        uint result = GetFinalPathNameByHandle(handle, targetPathBuffer);
+
+        // Buffer too small
+        if (result > targetPathBuffer.Length)
+        {
+            targetPathBuffer = new char[(int)result];
+            result = GetFinalPathNameByHandle(handle, targetPathBuffer);
+        }
+
+        // Error
+        if (result == 0)
+        {
+            errorMessage = Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
+            finalTarget = null;
+            return false;
+        }
+
+        // Normalize \\?\ and \??\ syntax.
+        finalTarget = new string(targetPathBuffer, 0, (int)result).TrimStart(new char[] { '\\', '?' });
+        errorMessage = null;
+        return true;
+    }
+
+    internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)
+    {
+        bool symbolicLinkCreated;
+        if (IsWindows)
+        {
+            Version osVersion = Environment.OSVersion.Version;
+            SymbolicLink flags = SymbolicLink.File;
+            if (osVersion.Major >= 11 || (osVersion.Major == 10 && osVersion.Build >= 14972))
+            {
+                flags |= SymbolicLink.AllowUnprivilegedCreate;
+            }
+
+            symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, flags);
+            errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
+        }
+        else
+        {
+            symbolicLinkCreated = symlink(exitingFileName, newFileName) == 0;
+            errorMessage = symbolicLinkCreated ? null : "The link() library call failed with the following error code: " + Marshal.GetLastWin32Error();
+        }
+
+        return symbolicLinkCreated;
+    }
+
     /// <summary>
     /// Get the last write time of the fullpath to the file.
     /// </summary>
@@ -1055,7 +1173,7 @@ internal static MemoryStatus GetMemoryStatus()
     internal static DateTime GetLastWriteFileUtcTime(string fullPath)
     {
 #if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-        if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+        if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)
         {
             return LastWriteFileUtcTime(fullPath);
         }
@@ -1118,6 +1236,23 @@ DateTime LastWriteFileUtcTime(string path)
         }
     }
 
+    /// <summary>
+    /// Get the SafeFileHandle for a file, while skipping reparse points (going directly to target file).
+    /// </summary>
+    /// <param name="fullPath">Full path to the file in the filesystem</param>
+    /// <returns>the SafeFileHandle for a file (target file in case of symlinks)</returns>
+    [SupportedOSPlatform("windows")]
+    private static SafeFileHandle OpenFileThroughSymlinks(string fullPath)
+    {
+        return CreateFile(fullPath,
+            GENERIC_READ,
+            FILE_SHARE_READ,
+            IntPtr.Zero,
+            OPEN_EXISTING,
+            FILE_ATTRIBUTE_NORMAL, /* No FILE_FLAG_OPEN_REPARSE_POINT; read through to content */
+            IntPtr.Zero);
+    }
+
     /// <summary>
     /// Get the last write time of the content pointed to by a file path.
     /// </summary>
@@ -1132,14 +1267,7 @@ private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
     {
         DateTime fileModifiedTime = DateTime.MinValue;
 
-        using (SafeFileHandle handle =
-            CreateFile(fullPath,
-                GENERIC_READ,
-                FILE_SHARE_READ,
-                IntPtr.Zero,
-                OPEN_EXISTING,
-                FILE_ATTRIBUTE_NORMAL, /* No FILE_FLAG_OPEN_REPARSE_POINT; read through to content */
-                IntPtr.Zero))
+        using (SafeFileHandle handle = OpenFileThroughSymlinks(fullPath))
         {
             if (!handle.IsInvalid)
             {
@@ -1642,9 +1770,31 @@ out FILETIME lpLastWriteTime
     [SupportedOSPlatform("windows")]
     internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
 
-#endregion
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    [return: MarshalAs(UnmanagedType.I1)]
+    [SupportedOSPlatform("windows")]
+    internal static extern bool CreateSymbolicLink(string symLinkFileName, string targetFileName, SymbolicLink dwFlags);
+
+    [DllImport("libc", SetLastError = true)]
+    internal static extern int symlink(string oldpath, string newpath);
+
+    internal const uint FILE_NAME_NORMALIZED = 0x0;
+
+    [SupportedOSPlatform("windows")]
+    static uint GetFinalPathNameByHandle(SafeFileHandle fileHandle, char[] filePath) =>
+        GetFinalPathNameByHandle(fileHandle, filePath, (uint) filePath.Length, FILE_NAME_NORMALIZED);
+
+    [DllImport("Kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
+    [SupportedOSPlatform("windows")]
+    static extern uint GetFinalPathNameByHandle(
+        SafeFileHandle hFile,
+        [Out] char[] lpszFilePath,
+        uint cchFilePath,
+        uint dwFlags);
+
+    #endregion
 
-#region helper methods
+    #region helper methods
 
     internal static bool DirectoryExists(string fullPath)
     {
diff --git a/src/Framework/PublicAPI/net/PublicAPI.Shipped.txt b/src/Framework/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index ec298ae0076..00000000000
--- a/src/Framework/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,919 +0,0 @@
-abstract Microsoft.Build.Framework.SdkLogger.LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-abstract Microsoft.Build.Framework.SdkResolver.Name.get -> string
-abstract Microsoft.Build.Framework.SdkResolver.Priority.get -> int
-abstract Microsoft.Build.Framework.SdkResolver.Resolve(Microsoft.Build.Framework.SdkReference sdkReference, Microsoft.Build.Framework.SdkResolverContext resolverContext, Microsoft.Build.Framework.SdkResultFactory factory) -> Microsoft.Build.Framework.SdkResult
-abstract Microsoft.Build.Framework.SdkResultFactory.IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-abstract Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-const Microsoft.Build.Framework.BuildEventContext.InvalidEvaluationId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidNodeId = -2 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidProjectContextId = -2 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidProjectInstanceId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidSubmissionId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidTargetId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidTaskId = -1 -> int
-const Microsoft.Build.Framework.EngineServices.Version1 = 1 -> int
-const Microsoft.Build.Framework.ProjectStartedEventArgs.InvalidProjectId = -1 -> int
-Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Framework.BuildEngineResult
-Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult() -> void
-Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) -> void
-Microsoft.Build.Framework.BuildEngineResult.Result.get -> bool
-Microsoft.Build.Framework.BuildEngineResult.TargetOutputsPerProject.get -> System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>>
-Microsoft.Build.Framework.BuildErrorEventArgs
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs() -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.HelpLink.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs() -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.set -> void
-Microsoft.Build.Framework.BuildEventArgs.HelpKeyword.get -> string
-Microsoft.Build.Framework.BuildEventArgs.RawMessage.get -> string
-Microsoft.Build.Framework.BuildEventArgs.RawMessage.set -> void
-Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.get -> System.DateTime
-Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.set -> void
-Microsoft.Build.Framework.BuildEventArgs.SenderName.get -> string
-Microsoft.Build.Framework.BuildEventArgs.ThreadId.get -> int
-Microsoft.Build.Framework.BuildEventArgs.Timestamp.get -> System.DateTime
-Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int targetId, int projectContextId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int evaluationId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildRequestId.get -> long
-Microsoft.Build.Framework.BuildEventContext.EvaluationId.get -> int
-Microsoft.Build.Framework.BuildEventContext.NodeId.get -> int
-Microsoft.Build.Framework.BuildEventContext.ProjectContextId.get -> int
-Microsoft.Build.Framework.BuildEventContext.ProjectInstanceId.get -> int
-Microsoft.Build.Framework.BuildEventContext.SubmissionId.get -> int
-Microsoft.Build.Framework.BuildEventContext.TargetId.get -> int
-Microsoft.Build.Framework.BuildEventContext.TaskId.get -> int
-Microsoft.Build.Framework.BuildFinishedEventArgs
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs() -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Framework.BuildMessageEventArgs
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs() -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.Importance.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.BuildMessageEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Framework.BuildStartedEventArgs
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs() -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.Collections.Generic.IDictionary<string, string> environmentOfBuild) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Framework.BuildStatusEventArgs
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs() -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Framework.BuildWarningEventArgs
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs() -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.HelpLink.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs() -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs() -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Framework.EngineServices
-Microsoft.Build.Framework.EngineServices.EngineServices() -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.get -> string
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.set -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs() -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs() -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs() -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames) -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.TargetNames.get -> string
-Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Framework.IBuildEngine.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.Framework.IBuildEngine.ColumnNumberOfTaskNode.get -> int
-Microsoft.Build.Framework.IBuildEngine.ContinueOnError.get -> bool
-Microsoft.Build.Framework.IBuildEngine.LineNumberOfTaskNode.get -> int
-Microsoft.Build.Framework.IBuildEngine.LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.ProjectFileOfTaskNode.get -> string
-Microsoft.Build.Framework.IBuildEngine10
-Microsoft.Build.Framework.IBuildEngine10.EngineServices.get -> Microsoft.Build.Framework.EngineServices
-Microsoft.Build.Framework.IBuildEngine2
-Microsoft.Build.Framework.IBuildEngine2.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs, string toolsVersion) -> bool
-Microsoft.Build.Framework.IBuildEngine2.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion) -> bool
-Microsoft.Build.Framework.IBuildEngine2.IsRunningMultipleNodes.get -> bool
-Microsoft.Build.Framework.IBuildEngine3
-Microsoft.Build.Framework.IBuildEngine3.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.Generic.IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs) -> Microsoft.Build.Framework.BuildEngineResult
-Microsoft.Build.Framework.IBuildEngine3.Reacquire() -> void
-Microsoft.Build.Framework.IBuildEngine3.Yield() -> void
-Microsoft.Build.Framework.IBuildEngine4
-Microsoft.Build.Framework.IBuildEngine4.GetRegisteredTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
-Microsoft.Build.Framework.IBuildEngine4.RegisterTaskObject(object key, object obj, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection) -> void
-Microsoft.Build.Framework.IBuildEngine4.UnregisterTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
-Microsoft.Build.Framework.IBuildEngine5
-Microsoft.Build.Framework.IBuildEngine5.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
-Microsoft.Build.Framework.IBuildEngine6
-Microsoft.Build.Framework.IBuildEngine6.GetGlobalProperties() -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Framework.IBuildEngine7
-Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.get -> bool
-Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.set -> void
-Microsoft.Build.Framework.IBuildEngine8
-Microsoft.Build.Framework.IBuildEngine8.ShouldTreatWarningAsError(string warningCode) -> bool
-Microsoft.Build.Framework.IBuildEngine9
-Microsoft.Build.Framework.IBuildEngine9.ReleaseCores(int coresToRelease) -> void
-Microsoft.Build.Framework.IBuildEngine9.RequestCores(int requestedCores) -> int
-Microsoft.Build.Framework.ICancelableTask
-Microsoft.Build.Framework.ICancelableTask.Cancel() -> void
-Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Framework.IEventRedirector.ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
-Microsoft.Build.Framework.IEventSource
-Microsoft.Build.Framework.IEventSource.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Framework.IEventSource.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Framework.IEventSource.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Framework.IEventSource.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Framework.IEventSource.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Framework.IEventSource.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Framework.IEventSource.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Framework.IEventSource.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Framework.IEventSource.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Framework.IEventSource.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Framework.IEventSource2
-Microsoft.Build.Framework.IEventSource2.TelemetryLogged -> Microsoft.Build.Framework.TelemetryEventHandler
-Microsoft.Build.Framework.IEventSource3
-Microsoft.Build.Framework.IEventSource3.IncludeEvaluationMetaprojects() -> void
-Microsoft.Build.Framework.IEventSource3.IncludeEvaluationProfiles() -> void
-Microsoft.Build.Framework.IEventSource3.IncludeTaskInputs() -> void
-Microsoft.Build.Framework.IEventSource4
-Microsoft.Build.Framework.IEventSource4.IncludeEvaluationPropertiesAndItems() -> void
-Microsoft.Build.Framework.IForwardingLogger
-Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Framework.IForwardingLogger.NodeId.get -> int
-Microsoft.Build.Framework.IForwardingLogger.NodeId.set -> void
-Microsoft.Build.Framework.IGeneratedTask
-Microsoft.Build.Framework.IGeneratedTask.GetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property) -> object
-Microsoft.Build.Framework.IGeneratedTask.SetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property, object value) -> void
-Microsoft.Build.Framework.ILogger
-Microsoft.Build.Framework.ILogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Framework.ILogger.Parameters.get -> string
-Microsoft.Build.Framework.ILogger.Parameters.set -> void
-Microsoft.Build.Framework.ILogger.Shutdown() -> void
-Microsoft.Build.Framework.ILogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.ILogger.Verbosity.set -> void
-Microsoft.Build.Framework.INodeLogger
-Microsoft.Build.Framework.INodeLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Framework.IProjectElement
-Microsoft.Build.Framework.IProjectElement.ElementName.get -> string
-Microsoft.Build.Framework.IProjectElement.OuterElement.get -> string
-Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Framework.ITask.BuildEngine.set -> void
-Microsoft.Build.Framework.ITask.Execute() -> bool
-Microsoft.Build.Framework.ITask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Framework.ITask.HostObject.set -> void
-Microsoft.Build.Framework.ITaskFactory
-Microsoft.Build.Framework.ITaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Framework.ITaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITaskFactory.FactoryName.get -> string
-Microsoft.Build.Framework.ITaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Framework.ITaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Framework.ITaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Framework.ITaskFactory2
-Microsoft.Build.Framework.ITaskFactory2.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITaskFactory2.Initialize(string taskName, System.Collections.Generic.IDictionary<string, string> factoryIdentityParameters, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
-Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
-Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.Framework.ITaskItem.ItemSpec.get -> string
-Microsoft.Build.Framework.ITaskItem.ItemSpec.set -> void
-Microsoft.Build.Framework.ITaskItem.MetadataCount.get -> int
-Microsoft.Build.Framework.ITaskItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.Framework.ITaskItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.Framework.ITaskItem2
-Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() -> System.Collections.IDictionary
-Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.get -> string
-Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.set -> void
-Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName) -> string
-Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs() -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute
-Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute.LoadInSeparateAppDomainAttribute() -> void
-Microsoft.Build.Framework.LoggerException
-Microsoft.Build.Framework.LoggerException.ErrorCode.get -> string
-Microsoft.Build.Framework.LoggerException.HelpKeyword.get -> string
-Microsoft.Build.Framework.LoggerException.LoggerException() -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException, string errorCode, string helpKeyword) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Detailed = 3 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Diagnostic = 4 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Minimal = 1 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Normal = 2 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Quiet = 0 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.High = 0 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.Low = 2 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.Normal = 1 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) -> void
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.metaprojectXml -> string
-Microsoft.Build.Framework.OutputAttribute
-Microsoft.Build.Framework.OutputAttribute.OutputAttribute() -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementDescription.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementName.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation() -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPass.get -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPassDescription.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.File.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Id.get -> long
-Microsoft.Build.Framework.Profiler.EvaluationLocation.IsEvaluationPass.get -> bool
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Kind.get -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Line.get -> int?
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ParentId.get -> long?
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFile(string file) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndCondition(string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithGlob(string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithParentId(long? parentId) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Condition = 1 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Element = 0 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Glob = 2 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.InitialProperties = 2 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.ItemDefinitionGroups = 4 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Items = 5 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.LazyItems = 6 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Properties = 3 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Targets = 8 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.TotalEvaluation = 0 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.TotalGlobbing = 1 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.UsingTasks = 7 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.ProfiledLocation
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ExclusiveTime.get -> System.TimeSpan
-Microsoft.Build.Framework.Profiler.ProfiledLocation.InclusiveTime.get -> System.TimeSpan
-Microsoft.Build.Framework.Profiler.ProfiledLocation.NumberOfHits.get -> int
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation() -> void
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) -> void
-Microsoft.Build.Framework.Profiler.ProfilerResult
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfiledLocations.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation>
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult() -> void
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.get -> Microsoft.Build.Framework.Profiler.ProfilerResult?
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs() -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.set -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs() -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs() -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded) -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Framework.ProjectImportedEventArgs
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.get -> string
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.set -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.get -> bool
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.set -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs() -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs(int lineNumber, int columnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.get -> string
-Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.set -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs
-Microsoft.Build.Framework.ProjectStartedEventArgs.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.ProjectStartedEventArgs.Items.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectStartedEventArgs.ParentProjectBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectId.get -> int
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs() -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.Properties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectStartedEventArgs.TargetNames.get -> string
-Microsoft.Build.Framework.ProjectStartedEventArgs.ToolsVersion.get -> string
-Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs() -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.set -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs() -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime.AppDomain = 1 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime.Build = 0 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RequiredAttribute
-Microsoft.Build.Framework.RequiredAttribute.RequiredAttribute() -> void
-Microsoft.Build.Framework.RequiredRuntimeAttribute
-Microsoft.Build.Framework.RequiredRuntimeAttribute.RequiredRuntimeAttribute(string runtimeVersion) -> void
-Microsoft.Build.Framework.RequiredRuntimeAttribute.RuntimeVersion.get -> string
-Microsoft.Build.Framework.RunInMTAAttribute
-Microsoft.Build.Framework.RunInMTAAttribute.RunInMTAAttribute() -> void
-Microsoft.Build.Framework.RunInSTAAttribute
-Microsoft.Build.Framework.RunInSTAAttribute.RunInSTAAttribute() -> void
-Microsoft.Build.Framework.SdkLogger
-Microsoft.Build.Framework.SdkLogger.SdkLogger() -> void
-Microsoft.Build.Framework.SdkReference
-Microsoft.Build.Framework.SdkReference.Equals(Microsoft.Build.Framework.SdkReference other) -> bool
-Microsoft.Build.Framework.SdkReference.MinimumVersion.get -> string
-Microsoft.Build.Framework.SdkReference.Name.get -> string
-Microsoft.Build.Framework.SdkReference.SdkReference(string name, string version, string minimumVersion) -> void
-Microsoft.Build.Framework.SdkReference.Version.get -> string
-Microsoft.Build.Framework.SdkResolver
-Microsoft.Build.Framework.SdkResolver.SdkResolver() -> void
-Microsoft.Build.Framework.SdkResolverContext
-Microsoft.Build.Framework.SdkResolverContext.SdkResolverContext() -> void
-Microsoft.Build.Framework.SdkResult
-Microsoft.Build.Framework.SdkResult.SdkResult() -> void
-Microsoft.Build.Framework.SdkResultFactory
-Microsoft.Build.Framework.SdkResultFactory.SdkResultFactory() -> void
-Microsoft.Build.Framework.SdkResultItem
-Microsoft.Build.Framework.SdkResultItem.ItemSpec.get -> string
-Microsoft.Build.Framework.SdkResultItem.ItemSpec.set -> void
-Microsoft.Build.Framework.SdkResultItem.Metadata.get -> System.Collections.Generic.Dictionary<string, string>
-Microsoft.Build.Framework.SdkResultItem.SdkResultItem() -> void
-Microsoft.Build.Framework.SdkResultItem.SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) -> void
-Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.AfterTargets = 3 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.BeforeTargets = 1 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.DependsOn = 2 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.None = 0 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetFinishedEventArgs
-Microsoft.Build.Framework.TargetFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs() -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.Collections.IEnumerable targetOutputs) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.DateTime eventTimestamp, System.Collections.IEnumerable targetOutputs) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.set -> void
-Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Framework.TargetSkippedEventArgs
-Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.get -> bool
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.get -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs() -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.ConditionWasFalse = 4 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.None = 0 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.OutputsUpToDate = 3 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltSuccessfully = 1 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltUnsuccessfully = 2 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetStartedEventArgs
-Microsoft.Build.Framework.TargetStartedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetStartedEventArgs.ParentTarget.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs() -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile) -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, Microsoft.Build.Framework.TargetBuiltReason buildReason, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Framework.TaskCommandLineEventArgs
-Microsoft.Build.Framework.TaskCommandLineEventArgs.CommandLine.get -> string
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs() -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs
-Microsoft.Build.Framework.TaskFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFile.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs() -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded) -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Framework.TaskParameterEventArgs
-Microsoft.Build.Framework.TaskParameterEventArgs.Items.get -> System.Collections.IList
-Microsoft.Build.Framework.TaskParameterEventArgs.ItemType.get -> string
-Microsoft.Build.Framework.TaskParameterEventArgs.Kind.get -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterEventArgs.LogItemMetadata.get -> bool
-Microsoft.Build.Framework.TaskParameterEventArgs.TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.AddItem = 2 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.RemoveItem = 3 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetInputs = 4 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetOutputs = 5 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.TaskInput = 0 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.TaskOutput = 1 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskPropertyInfo
-Microsoft.Build.Framework.TaskPropertyInfo.Log.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.Log.set -> void
-Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.set -> void
-Microsoft.Build.Framework.TaskPropertyInfo.Name.get -> string
-Microsoft.Build.Framework.TaskPropertyInfo.Output.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.PropertyType.get -> System.Type
-Microsoft.Build.Framework.TaskPropertyInfo.Required.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) -> void
-Microsoft.Build.Framework.TaskStartedEventArgs
-Microsoft.Build.Framework.TaskStartedEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.TaskStartedEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.TaskStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskFile.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs() -> void
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) -> void
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Framework.TelemetryEventArgs
-Microsoft.Build.Framework.TelemetryEventArgs.EventName.get -> string
-Microsoft.Build.Framework.TelemetryEventArgs.EventName.set -> void
-Microsoft.Build.Framework.TelemetryEventArgs.Properties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.TelemetryEventArgs.Properties.set -> void
-Microsoft.Build.Framework.TelemetryEventArgs.TelemetryEventArgs() -> void
-Microsoft.Build.Framework.TelemetryEventHandler
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs() -> void
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.XamlTypes.Argument
-Microsoft.Build.Framework.XamlTypes.Argument.Argument() -> void
-Microsoft.Build.Framework.XamlTypes.Argument.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.Argument.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.Argument.IsRequired.get -> bool
-Microsoft.Build.Framework.XamlTypes.Argument.IsRequired.set -> void
-Microsoft.Build.Framework.XamlTypes.Argument.Property.get -> string
-Microsoft.Build.Framework.XamlTypes.Argument.Property.set -> void
-Microsoft.Build.Framework.XamlTypes.Argument.Separator.get -> string
-Microsoft.Build.Framework.XamlTypes.Argument.Separator.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Arguments.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Argument>
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Arguments.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.BaseProperty() -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Category.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Category.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ContainingRule.get -> Microsoft.Build.Framework.XamlTypes.Rule
-Microsoft.Build.Framework.XamlTypes.BaseProperty.DataSource.get -> Microsoft.Build.Framework.XamlTypes.DataSource
-Microsoft.Build.Framework.XamlTypes.BaseProperty.DataSource.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Default.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Default.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Description.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Description.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.F1Keyword.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.F1Keyword.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpContext.get -> int
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpContext.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpFile.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpFile.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpUrl.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpUrl.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.IncludeInCommandLine.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.IncludeInCommandLine.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.IsRequired.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.IsRequired.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.MultipleValuesAllowed.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.MultipleValuesAllowed.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ReadOnly.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ReadOnly.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Separator.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Separator.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Subcategory.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Subcategory.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Switch.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Switch.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.SwitchPrefix.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.SwitchPrefix.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ValueEditors.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.ValueEditor>
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ValueEditors.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Visible.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Visible.set -> void
-Microsoft.Build.Framework.XamlTypes.BoolProperty
-Microsoft.Build.Framework.XamlTypes.BoolProperty.BoolProperty() -> void
-Microsoft.Build.Framework.XamlTypes.BoolProperty.ReverseSwitch.get -> string
-Microsoft.Build.Framework.XamlTypes.BoolProperty.ReverseSwitch.set -> void
-Microsoft.Build.Framework.XamlTypes.Category
-Microsoft.Build.Framework.XamlTypes.Category.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.Category.Category() -> void
-Microsoft.Build.Framework.XamlTypes.Category.Description.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.Description.set -> void
-Microsoft.Build.Framework.XamlTypes.Category.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.Category.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.Category.HelpString.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.HelpString.set -> void
-Microsoft.Build.Framework.XamlTypes.Category.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.Category.Subtype.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.Subtype.set -> void
-Microsoft.Build.Framework.XamlTypes.CategorySchema
-Microsoft.Build.Framework.XamlTypes.CategorySchema.CategorySchema() -> void
-Microsoft.Build.Framework.XamlTypes.ContentType
-Microsoft.Build.Framework.XamlTypes.ContentType.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.ContentType() -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.DefaultContentTypeForItemType.get -> bool
-Microsoft.Build.Framework.XamlTypes.ContentType.DefaultContentTypeForItemType.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.GetMetadata(string metadataName) -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.ContentType.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.ContentType.ItemGroupName.get -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.ItemGroupName.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.ItemType.get -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.ItemType.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.ContentType.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource
-Microsoft.Build.Framework.XamlTypes.DataSource.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.DataSource() -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.HasConfigurationCondition.get -> bool
-Microsoft.Build.Framework.XamlTypes.DataSource.HasConfigurationCondition.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.ItemType.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.ItemType.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.Label.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.Label.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.MSBuildTarget.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.MSBuildTarget.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.PersistedName.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.PersistedName.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.Persistence.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.Persistence.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.PersistenceStyle.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.PersistenceStyle.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.SourceOfDefaultValue.get -> Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
-Microsoft.Build.Framework.XamlTypes.DataSource.SourceOfDefaultValue.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.SourceType.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.SourceType.set -> void
-Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
-Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation.AfterContext = 1 -> Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
-Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation.BeforeContext = 0 -> Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.DynamicEnumProperty() -> void
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.EnumProvider.get -> string
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.EnumProvider.set -> void
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.ProviderSettings.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.ProviderSettings.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumProperty
-Microsoft.Build.Framework.XamlTypes.EnumProperty.AdmissibleValues.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.EnumValue>
-Microsoft.Build.Framework.XamlTypes.EnumProperty.AdmissibleValues.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumProperty.EnumProperty() -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue
-Microsoft.Build.Framework.XamlTypes.EnumValue.Arguments.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Argument>
-Microsoft.Build.Framework.XamlTypes.EnumValue.Arguments.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.Description.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.Description.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.EnumValue() -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.HelpString.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.HelpString.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.IsDefault.get -> bool
-Microsoft.Build.Framework.XamlTypes.EnumValue.IsDefault.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.EnumValue.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.Switch.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.Switch.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.SwitchPrefix.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.SwitchPrefix.set -> void
-Microsoft.Build.Framework.XamlTypes.FileExtension
-Microsoft.Build.Framework.XamlTypes.FileExtension.ContentType.get -> string
-Microsoft.Build.Framework.XamlTypes.FileExtension.ContentType.set -> void
-Microsoft.Build.Framework.XamlTypes.FileExtension.FileExtension() -> void
-Microsoft.Build.Framework.XamlTypes.FileExtension.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.FileExtension.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.FileExtension.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.FileExtension.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.IntProperty
-Microsoft.Build.Framework.XamlTypes.IntProperty.IntProperty() -> void
-Microsoft.Build.Framework.XamlTypes.IntProperty.MaxValue.get -> int?
-Microsoft.Build.Framework.XamlTypes.IntProperty.MaxValue.set -> void
-Microsoft.Build.Framework.XamlTypes.IntProperty.MinValue.get -> int?
-Microsoft.Build.Framework.XamlTypes.IntProperty.MinValue.set -> void
-Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode
-Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.ItemType
-Microsoft.Build.Framework.XamlTypes.ItemType.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.DefaultContentType.get -> string
-Microsoft.Build.Framework.XamlTypes.ItemType.DefaultContentType.set -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.ItemType.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.ItemType.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.ItemType.ItemType() -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.ItemType.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.UpToDateCheckInput.get -> bool
-Microsoft.Build.Framework.XamlTypes.ItemType.UpToDateCheckInput.set -> void
-Microsoft.Build.Framework.XamlTypes.NameValuePair
-Microsoft.Build.Framework.XamlTypes.NameValuePair.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.NameValuePair.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.NameValuePair.NameValuePair() -> void
-Microsoft.Build.Framework.XamlTypes.NameValuePair.Value.get -> string
-Microsoft.Build.Framework.XamlTypes.NameValuePair.Value.set -> void
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.Nodes.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode>
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.Nodes.set -> void
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.ProjectSchemaDefinitions() -> void
-Microsoft.Build.Framework.XamlTypes.Rule
-Microsoft.Build.Framework.XamlTypes.Rule.AdditionalInputs.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.AdditionalInputs.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Categories.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Category>
-Microsoft.Build.Framework.XamlTypes.Rule.Categories.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.CommandLine.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.CommandLine.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.DataSource.get -> Microsoft.Build.Framework.XamlTypes.DataSource
-Microsoft.Build.Framework.XamlTypes.Rule.DataSource.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Description.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.Description.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.Rule.EvaluatedCategories.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Category>
-Microsoft.Build.Framework.XamlTypes.Rule.ExecutionDescription.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.ExecutionDescription.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.FileExtension.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.FileExtension.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.GetPropertiesByCategory() -> System.Collections.Specialized.OrderedDictionary
-Microsoft.Build.Framework.XamlTypes.Rule.GetPropertiesInCategory(string categoryName) -> System.Collections.Generic.IList<Microsoft.Build.Framework.XamlTypes.BaseProperty>
-Microsoft.Build.Framework.XamlTypes.Rule.GetProperty(string propertyName) -> Microsoft.Build.Framework.XamlTypes.BaseProperty
-Microsoft.Build.Framework.XamlTypes.Rule.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.Rule.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.Rule.HelpString.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.HelpString.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Metadata.get -> System.Collections.Generic.Dictionary<string, object>
-Microsoft.Build.Framework.XamlTypes.Rule.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Order.get -> int
-Microsoft.Build.Framework.XamlTypes.Rule.Order.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Outputs.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.Outputs.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.OverrideMode.get -> Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
-Microsoft.Build.Framework.XamlTypes.Rule.OverrideMode.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.PageTemplate.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.PageTemplate.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Properties.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.BaseProperty>
-Microsoft.Build.Framework.XamlTypes.Rule.Properties.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.PropertyPagesHidden.get -> bool
-Microsoft.Build.Framework.XamlTypes.Rule.PropertyPagesHidden.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Rule() -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Separator.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.Separator.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.ShowOnlyRuleProperties.get -> bool
-Microsoft.Build.Framework.XamlTypes.Rule.ShowOnlyRuleProperties.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.SupportsFileBatching.get -> bool
-Microsoft.Build.Framework.XamlTypes.Rule.SupportsFileBatching.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.SwitchPrefix.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.SwitchPrefix.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.ToolName.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.ToolName.set -> void
-Microsoft.Build.Framework.XamlTypes.RuleBag
-Microsoft.Build.Framework.XamlTypes.RuleBag.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.RuleBag.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.RuleBag.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.RuleBag.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.RuleBag.RuleBag() -> void
-Microsoft.Build.Framework.XamlTypes.RuleBag.Rules.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Rule>
-Microsoft.Build.Framework.XamlTypes.RuleBag.Rules.set -> void
-Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
-Microsoft.Build.Framework.XamlTypes.RuleOverrideMode.Extend = 1 -> Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
-Microsoft.Build.Framework.XamlTypes.RuleOverrideMode.Replace = 0 -> Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
-Microsoft.Build.Framework.XamlTypes.RuleSchema
-Microsoft.Build.Framework.XamlTypes.RuleSchema.RuleSchema() -> void
-Microsoft.Build.Framework.XamlTypes.StringListProperty
-Microsoft.Build.Framework.XamlTypes.StringListProperty.CommandLineValueSeparator.get -> string
-Microsoft.Build.Framework.XamlTypes.StringListProperty.CommandLineValueSeparator.set -> void
-Microsoft.Build.Framework.XamlTypes.StringListProperty.RendererValueSeparator.get -> string
-Microsoft.Build.Framework.XamlTypes.StringListProperty.RendererValueSeparator.set -> void
-Microsoft.Build.Framework.XamlTypes.StringListProperty.StringListProperty() -> void
-Microsoft.Build.Framework.XamlTypes.StringListProperty.Subtype.get -> string
-Microsoft.Build.Framework.XamlTypes.StringListProperty.Subtype.set -> void
-Microsoft.Build.Framework.XamlTypes.StringProperty
-Microsoft.Build.Framework.XamlTypes.StringProperty.StringProperty() -> void
-Microsoft.Build.Framework.XamlTypes.StringProperty.Subtype.get -> string
-Microsoft.Build.Framework.XamlTypes.StringProperty.Subtype.set -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor
-Microsoft.Build.Framework.XamlTypes.ValueEditor.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.ValueEditor.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.EditorType.get -> string
-Microsoft.Build.Framework.XamlTypes.ValueEditor.EditorType.set -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.ValueEditor.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.ValueEditor() -> void
-override Microsoft.Build.Framework.BuildEventContext.Equals(object obj) -> bool
-override Microsoft.Build.Framework.BuildEventContext.GetHashCode() -> int
-override Microsoft.Build.Framework.BuildEventContext.ToString() -> string
-override Microsoft.Build.Framework.LazyFormattedBuildEventArgs.Message.get -> string
-override Microsoft.Build.Framework.LoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.GetHashCode() -> int
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.ToString() -> string
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.GetHashCode() -> int
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.ToString() -> string
-override Microsoft.Build.Framework.Profiler.ProfilerResult.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.ProfilerResult.GetHashCode() -> int
-override Microsoft.Build.Framework.ProjectFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.ProjectStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.PropertyReassignmentEventArgs.Message.get -> string
-override Microsoft.Build.Framework.SdkReference.Equals(object obj) -> bool
-override Microsoft.Build.Framework.SdkReference.GetHashCode() -> int
-override Microsoft.Build.Framework.SdkReference.ToString() -> string
-override Microsoft.Build.Framework.SdkResultItem.Equals(object obj) -> bool
-override Microsoft.Build.Framework.SdkResultItem.GetHashCode() -> int
-override Microsoft.Build.Framework.TargetFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TargetSkippedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TargetStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskParameterEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.XamlTypes.EnumProperty.EndInit() -> void
-override Microsoft.Build.Framework.XamlTypes.IntProperty.EndInit() -> void
-static Microsoft.Build.Framework.BuildEventContext.Invalid.get -> Microsoft.Build.Framework.BuildEventContext
-static Microsoft.Build.Framework.BuildEventContext.operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
-static Microsoft.Build.Framework.BuildEventContext.operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForAggregatedGlob() -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.EmptyLocation.get -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.SdkReference.TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) -> bool
-virtual Microsoft.Build.Framework.BuildEventArgs.Message.get -> string
-virtual Microsoft.Build.Framework.BuildEventArgs.Message.set -> void
-virtual Microsoft.Build.Framework.EngineServices.IsTaskInputLoggingEnabled.get -> bool
-virtual Microsoft.Build.Framework.EngineServices.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
-virtual Microsoft.Build.Framework.EngineServices.Version.get -> int
-virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.get -> bool
-virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.get -> bool
-virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.Logger.get -> Microsoft.Build.Framework.SdkLogger
-virtual Microsoft.Build.Framework.SdkResolverContext.Logger.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.get -> System.Version
-virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.get -> string
-virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.get -> string
-virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.State.get -> object
-virtual Microsoft.Build.Framework.SdkResolverContext.State.set -> void
-virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.get -> System.Collections.Generic.IList<string>
-virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.set -> void
-virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem>
-virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Path.get -> string
-virtual Microsoft.Build.Framework.SdkResult.Path.set -> void
-virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.get -> System.Collections.Generic.IDictionary<string, string>
-virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.set -> void
-virtual Microsoft.Build.Framework.SdkResult.SdkReference.get -> Microsoft.Build.Framework.SdkReference
-virtual Microsoft.Build.Framework.SdkResult.SdkReference.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Success.get -> bool
-virtual Microsoft.Build.Framework.SdkResult.Success.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Version.get -> string
-virtual Microsoft.Build.Framework.SdkResult.Version.set -> void
-virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-virtual Microsoft.Build.Framework.XamlTypes.BaseProperty.BeginInit() -> void
-virtual Microsoft.Build.Framework.XamlTypes.BaseProperty.EndInit() -> void
\ No newline at end of file
diff --git a/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Framework/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Framework/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index fa0dac7c7ef..00000000000
--- a/src/Framework/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,632 +0,0 @@
-abstract Microsoft.Build.Framework.SdkLogger.LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-abstract Microsoft.Build.Framework.SdkResolver.Name.get -> string
-abstract Microsoft.Build.Framework.SdkResolver.Priority.get -> int
-abstract Microsoft.Build.Framework.SdkResolver.Resolve(Microsoft.Build.Framework.SdkReference sdkReference, Microsoft.Build.Framework.SdkResolverContext resolverContext, Microsoft.Build.Framework.SdkResultFactory factory) -> Microsoft.Build.Framework.SdkResult
-abstract Microsoft.Build.Framework.SdkResultFactory.IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-abstract Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-const Microsoft.Build.Framework.BuildEventContext.InvalidEvaluationId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidNodeId = -2 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidProjectContextId = -2 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidProjectInstanceId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidSubmissionId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidTargetId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidTaskId = -1 -> int
-const Microsoft.Build.Framework.EngineServices.Version1 = 1 -> int
-const Microsoft.Build.Framework.ProjectStartedEventArgs.InvalidProjectId = -1 -> int
-Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Framework.BuildEngineResult
-Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult() -> void
-Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) -> void
-Microsoft.Build.Framework.BuildEngineResult.Result.get -> bool
-Microsoft.Build.Framework.BuildEngineResult.TargetOutputsPerProject.get -> System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>>
-Microsoft.Build.Framework.BuildErrorEventArgs
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs() -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.HelpLink.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs() -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.set -> void
-Microsoft.Build.Framework.BuildEventArgs.HelpKeyword.get -> string
-Microsoft.Build.Framework.BuildEventArgs.RawMessage.get -> string
-Microsoft.Build.Framework.BuildEventArgs.RawMessage.set -> void
-Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.get -> System.DateTime
-Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.set -> void
-Microsoft.Build.Framework.BuildEventArgs.SenderName.get -> string
-Microsoft.Build.Framework.BuildEventArgs.ThreadId.get -> int
-Microsoft.Build.Framework.BuildEventArgs.Timestamp.get -> System.DateTime
-Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int targetId, int projectContextId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int evaluationId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildRequestId.get -> long
-Microsoft.Build.Framework.BuildEventContext.EvaluationId.get -> int
-Microsoft.Build.Framework.BuildEventContext.NodeId.get -> int
-Microsoft.Build.Framework.BuildEventContext.ProjectContextId.get -> int
-Microsoft.Build.Framework.BuildEventContext.ProjectInstanceId.get -> int
-Microsoft.Build.Framework.BuildEventContext.SubmissionId.get -> int
-Microsoft.Build.Framework.BuildEventContext.TargetId.get -> int
-Microsoft.Build.Framework.BuildEventContext.TaskId.get -> int
-Microsoft.Build.Framework.BuildFinishedEventArgs
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs() -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Framework.BuildMessageEventArgs
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs() -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.Importance.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.BuildMessageEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Framework.BuildStartedEventArgs
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs() -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.Collections.Generic.IDictionary<string, string> environmentOfBuild) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Framework.BuildStatusEventArgs
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs() -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Framework.BuildWarningEventArgs
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs() -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.HelpLink.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs() -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs() -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Framework.EngineServices
-Microsoft.Build.Framework.EngineServices.EngineServices() -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.get -> string
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.set -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs() -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs() -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs() -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames) -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.TargetNames.get -> string
-Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Framework.IBuildEngine.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.Framework.IBuildEngine.ColumnNumberOfTaskNode.get -> int
-Microsoft.Build.Framework.IBuildEngine.ContinueOnError.get -> bool
-Microsoft.Build.Framework.IBuildEngine.LineNumberOfTaskNode.get -> int
-Microsoft.Build.Framework.IBuildEngine.LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.ProjectFileOfTaskNode.get -> string
-Microsoft.Build.Framework.IBuildEngine10
-Microsoft.Build.Framework.IBuildEngine10.EngineServices.get -> Microsoft.Build.Framework.EngineServices
-Microsoft.Build.Framework.IBuildEngine2
-Microsoft.Build.Framework.IBuildEngine2.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs, string toolsVersion) -> bool
-Microsoft.Build.Framework.IBuildEngine2.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion) -> bool
-Microsoft.Build.Framework.IBuildEngine2.IsRunningMultipleNodes.get -> bool
-Microsoft.Build.Framework.IBuildEngine3
-Microsoft.Build.Framework.IBuildEngine3.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.Generic.IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs) -> Microsoft.Build.Framework.BuildEngineResult
-Microsoft.Build.Framework.IBuildEngine3.Reacquire() -> void
-Microsoft.Build.Framework.IBuildEngine3.Yield() -> void
-Microsoft.Build.Framework.IBuildEngine4
-Microsoft.Build.Framework.IBuildEngine4.GetRegisteredTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
-Microsoft.Build.Framework.IBuildEngine4.RegisterTaskObject(object key, object obj, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection) -> void
-Microsoft.Build.Framework.IBuildEngine4.UnregisterTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
-Microsoft.Build.Framework.IBuildEngine5
-Microsoft.Build.Framework.IBuildEngine5.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
-Microsoft.Build.Framework.IBuildEngine6
-Microsoft.Build.Framework.IBuildEngine6.GetGlobalProperties() -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Framework.IBuildEngine7
-Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.get -> bool
-Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.set -> void
-Microsoft.Build.Framework.IBuildEngine8
-Microsoft.Build.Framework.IBuildEngine8.ShouldTreatWarningAsError(string warningCode) -> bool
-Microsoft.Build.Framework.IBuildEngine9
-Microsoft.Build.Framework.IBuildEngine9.ReleaseCores(int coresToRelease) -> void
-Microsoft.Build.Framework.IBuildEngine9.RequestCores(int requestedCores) -> int
-Microsoft.Build.Framework.ICancelableTask
-Microsoft.Build.Framework.ICancelableTask.Cancel() -> void
-Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Framework.IEventRedirector.ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
-Microsoft.Build.Framework.IEventSource
-Microsoft.Build.Framework.IEventSource.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Framework.IEventSource.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Framework.IEventSource.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Framework.IEventSource.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Framework.IEventSource.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Framework.IEventSource.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Framework.IEventSource.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Framework.IEventSource.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Framework.IEventSource.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Framework.IEventSource.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Framework.IEventSource2
-Microsoft.Build.Framework.IEventSource2.TelemetryLogged -> Microsoft.Build.Framework.TelemetryEventHandler
-Microsoft.Build.Framework.IEventSource3
-Microsoft.Build.Framework.IEventSource3.IncludeEvaluationMetaprojects() -> void
-Microsoft.Build.Framework.IEventSource3.IncludeEvaluationProfiles() -> void
-Microsoft.Build.Framework.IEventSource3.IncludeTaskInputs() -> void
-Microsoft.Build.Framework.IEventSource4
-Microsoft.Build.Framework.IEventSource4.IncludeEvaluationPropertiesAndItems() -> void
-Microsoft.Build.Framework.IForwardingLogger
-Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Framework.IForwardingLogger.NodeId.get -> int
-Microsoft.Build.Framework.IForwardingLogger.NodeId.set -> void
-Microsoft.Build.Framework.IGeneratedTask
-Microsoft.Build.Framework.IGeneratedTask.GetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property) -> object
-Microsoft.Build.Framework.IGeneratedTask.SetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property, object value) -> void
-Microsoft.Build.Framework.ILogger
-Microsoft.Build.Framework.ILogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Framework.ILogger.Parameters.get -> string
-Microsoft.Build.Framework.ILogger.Parameters.set -> void
-Microsoft.Build.Framework.ILogger.Shutdown() -> void
-Microsoft.Build.Framework.ILogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.ILogger.Verbosity.set -> void
-Microsoft.Build.Framework.INodeLogger
-Microsoft.Build.Framework.INodeLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Framework.IProjectElement
-Microsoft.Build.Framework.IProjectElement.ElementName.get -> string
-Microsoft.Build.Framework.IProjectElement.OuterElement.get -> string
-Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Framework.ITask.BuildEngine.set -> void
-Microsoft.Build.Framework.ITask.Execute() -> bool
-Microsoft.Build.Framework.ITask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Framework.ITask.HostObject.set -> void
-Microsoft.Build.Framework.ITaskFactory
-Microsoft.Build.Framework.ITaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Framework.ITaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITaskFactory.FactoryName.get -> string
-Microsoft.Build.Framework.ITaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Framework.ITaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Framework.ITaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Framework.ITaskFactory2
-Microsoft.Build.Framework.ITaskFactory2.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITaskFactory2.Initialize(string taskName, System.Collections.Generic.IDictionary<string, string> factoryIdentityParameters, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
-Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
-Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.Framework.ITaskItem.ItemSpec.get -> string
-Microsoft.Build.Framework.ITaskItem.ItemSpec.set -> void
-Microsoft.Build.Framework.ITaskItem.MetadataCount.get -> int
-Microsoft.Build.Framework.ITaskItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.Framework.ITaskItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.Framework.ITaskItem2
-Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() -> System.Collections.IDictionary
-Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.get -> string
-Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.set -> void
-Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName) -> string
-Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs() -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute
-Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute.LoadInSeparateAppDomainAttribute() -> void
-Microsoft.Build.Framework.LoggerException
-Microsoft.Build.Framework.LoggerException.ErrorCode.get -> string
-Microsoft.Build.Framework.LoggerException.HelpKeyword.get -> string
-Microsoft.Build.Framework.LoggerException.LoggerException() -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException, string errorCode, string helpKeyword) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Detailed = 3 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Diagnostic = 4 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Minimal = 1 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Normal = 2 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Quiet = 0 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.High = 0 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.Low = 2 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.Normal = 1 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) -> void
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.metaprojectXml -> string
-Microsoft.Build.Framework.OutputAttribute
-Microsoft.Build.Framework.OutputAttribute.OutputAttribute() -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementDescription.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementName.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation() -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPass.get -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPassDescription.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.File.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Id.get -> long
-Microsoft.Build.Framework.Profiler.EvaluationLocation.IsEvaluationPass.get -> bool
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Kind.get -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Line.get -> int?
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ParentId.get -> long?
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFile(string file) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndCondition(string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithGlob(string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithParentId(long? parentId) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Condition = 1 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Element = 0 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Glob = 2 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.InitialProperties = 2 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.ItemDefinitionGroups = 4 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Items = 5 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.LazyItems = 6 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Properties = 3 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Targets = 8 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.TotalEvaluation = 0 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.TotalGlobbing = 1 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.UsingTasks = 7 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.ProfiledLocation
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ExclusiveTime.get -> System.TimeSpan
-Microsoft.Build.Framework.Profiler.ProfiledLocation.InclusiveTime.get -> System.TimeSpan
-Microsoft.Build.Framework.Profiler.ProfiledLocation.NumberOfHits.get -> int
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation() -> void
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) -> void
-Microsoft.Build.Framework.Profiler.ProfilerResult
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfiledLocations.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation>
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult() -> void
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.get -> Microsoft.Build.Framework.Profiler.ProfilerResult?
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs() -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.set -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs() -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs() -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded) -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Framework.ProjectImportedEventArgs
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.get -> string
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.set -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.get -> bool
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.set -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs() -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs(int lineNumber, int columnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.get -> string
-Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.set -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs
-Microsoft.Build.Framework.ProjectStartedEventArgs.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.ProjectStartedEventArgs.Items.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectStartedEventArgs.ParentProjectBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectId.get -> int
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs() -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.Properties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectStartedEventArgs.TargetNames.get -> string
-Microsoft.Build.Framework.ProjectStartedEventArgs.ToolsVersion.get -> string
-Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs() -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.set -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs() -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime.AppDomain = 1 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime.Build = 0 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RequiredAttribute
-Microsoft.Build.Framework.RequiredAttribute.RequiredAttribute() -> void
-Microsoft.Build.Framework.RequiredRuntimeAttribute
-Microsoft.Build.Framework.RequiredRuntimeAttribute.RequiredRuntimeAttribute(string runtimeVersion) -> void
-Microsoft.Build.Framework.RequiredRuntimeAttribute.RuntimeVersion.get -> string
-Microsoft.Build.Framework.RunInMTAAttribute
-Microsoft.Build.Framework.RunInMTAAttribute.RunInMTAAttribute() -> void
-Microsoft.Build.Framework.RunInSTAAttribute
-Microsoft.Build.Framework.RunInSTAAttribute.RunInSTAAttribute() -> void
-Microsoft.Build.Framework.SdkLogger
-Microsoft.Build.Framework.SdkLogger.SdkLogger() -> void
-Microsoft.Build.Framework.SdkReference
-Microsoft.Build.Framework.SdkReference.Equals(Microsoft.Build.Framework.SdkReference other) -> bool
-Microsoft.Build.Framework.SdkReference.MinimumVersion.get -> string
-Microsoft.Build.Framework.SdkReference.Name.get -> string
-Microsoft.Build.Framework.SdkReference.SdkReference(string name, string version, string minimumVersion) -> void
-Microsoft.Build.Framework.SdkReference.Version.get -> string
-Microsoft.Build.Framework.SdkResolver
-Microsoft.Build.Framework.SdkResolver.SdkResolver() -> void
-Microsoft.Build.Framework.SdkResolverContext
-Microsoft.Build.Framework.SdkResolverContext.SdkResolverContext() -> void
-Microsoft.Build.Framework.SdkResult
-Microsoft.Build.Framework.SdkResult.SdkResult() -> void
-Microsoft.Build.Framework.SdkResultFactory
-Microsoft.Build.Framework.SdkResultFactory.SdkResultFactory() -> void
-Microsoft.Build.Framework.SdkResultItem
-Microsoft.Build.Framework.SdkResultItem.ItemSpec.get -> string
-Microsoft.Build.Framework.SdkResultItem.ItemSpec.set -> void
-Microsoft.Build.Framework.SdkResultItem.Metadata.get -> System.Collections.Generic.Dictionary<string, string>
-Microsoft.Build.Framework.SdkResultItem.SdkResultItem() -> void
-Microsoft.Build.Framework.SdkResultItem.SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) -> void
-Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.AfterTargets = 3 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.BeforeTargets = 1 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.DependsOn = 2 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.None = 0 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetFinishedEventArgs
-Microsoft.Build.Framework.TargetFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs() -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.Collections.IEnumerable targetOutputs) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.DateTime eventTimestamp, System.Collections.IEnumerable targetOutputs) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.set -> void
-Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Framework.TargetSkippedEventArgs
-Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.get -> bool
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.get -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs() -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.ConditionWasFalse = 4 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.None = 0 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.OutputsUpToDate = 3 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltSuccessfully = 1 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltUnsuccessfully = 2 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetStartedEventArgs
-Microsoft.Build.Framework.TargetStartedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetStartedEventArgs.ParentTarget.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs() -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile) -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, Microsoft.Build.Framework.TargetBuiltReason buildReason, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Framework.TaskCommandLineEventArgs
-Microsoft.Build.Framework.TaskCommandLineEventArgs.CommandLine.get -> string
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs() -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs
-Microsoft.Build.Framework.TaskFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFile.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs() -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded) -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Framework.TaskParameterEventArgs
-Microsoft.Build.Framework.TaskParameterEventArgs.Items.get -> System.Collections.IList
-Microsoft.Build.Framework.TaskParameterEventArgs.ItemType.get -> string
-Microsoft.Build.Framework.TaskParameterEventArgs.Kind.get -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterEventArgs.LogItemMetadata.get -> bool
-Microsoft.Build.Framework.TaskParameterEventArgs.TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.AddItem = 2 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.RemoveItem = 3 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetInputs = 4 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetOutputs = 5 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.TaskInput = 0 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.TaskOutput = 1 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskPropertyInfo
-Microsoft.Build.Framework.TaskPropertyInfo.Log.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.Log.set -> void
-Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.set -> void
-Microsoft.Build.Framework.TaskPropertyInfo.Name.get -> string
-Microsoft.Build.Framework.TaskPropertyInfo.Output.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.PropertyType.get -> System.Type
-Microsoft.Build.Framework.TaskPropertyInfo.Required.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) -> void
-Microsoft.Build.Framework.TaskStartedEventArgs
-Microsoft.Build.Framework.TaskStartedEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.TaskStartedEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.TaskStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskFile.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs() -> void
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) -> void
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Framework.TelemetryEventArgs
-Microsoft.Build.Framework.TelemetryEventArgs.EventName.get -> string
-Microsoft.Build.Framework.TelemetryEventArgs.EventName.set -> void
-Microsoft.Build.Framework.TelemetryEventArgs.Properties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.TelemetryEventArgs.Properties.set -> void
-Microsoft.Build.Framework.TelemetryEventArgs.TelemetryEventArgs() -> void
-Microsoft.Build.Framework.TelemetryEventHandler
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs() -> void
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-override Microsoft.Build.Framework.BuildEventContext.Equals(object obj) -> bool
-override Microsoft.Build.Framework.BuildEventContext.GetHashCode() -> int
-override Microsoft.Build.Framework.BuildEventContext.ToString() -> string
-override Microsoft.Build.Framework.LazyFormattedBuildEventArgs.Message.get -> string
-override Microsoft.Build.Framework.LoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.GetHashCode() -> int
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.ToString() -> string
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.GetHashCode() -> int
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.ToString() -> string
-override Microsoft.Build.Framework.Profiler.ProfilerResult.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.ProfilerResult.GetHashCode() -> int
-override Microsoft.Build.Framework.ProjectFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.ProjectStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.PropertyReassignmentEventArgs.Message.get -> string
-override Microsoft.Build.Framework.SdkReference.Equals(object obj) -> bool
-override Microsoft.Build.Framework.SdkReference.GetHashCode() -> int
-override Microsoft.Build.Framework.SdkReference.ToString() -> string
-override Microsoft.Build.Framework.SdkResultItem.Equals(object obj) -> bool
-override Microsoft.Build.Framework.SdkResultItem.GetHashCode() -> int
-override Microsoft.Build.Framework.TargetFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TargetSkippedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TargetStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskParameterEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskStartedEventArgs.Message.get -> string
-static Microsoft.Build.Framework.BuildEventContext.Invalid.get -> Microsoft.Build.Framework.BuildEventContext
-static Microsoft.Build.Framework.BuildEventContext.operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
-static Microsoft.Build.Framework.BuildEventContext.operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForAggregatedGlob() -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.EmptyLocation.get -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.SdkReference.TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) -> bool
-virtual Microsoft.Build.Framework.BuildEventArgs.Message.get -> string
-virtual Microsoft.Build.Framework.BuildEventArgs.Message.set -> void
-virtual Microsoft.Build.Framework.EngineServices.IsTaskInputLoggingEnabled.get -> bool
-virtual Microsoft.Build.Framework.EngineServices.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
-virtual Microsoft.Build.Framework.EngineServices.Version.get -> int
-virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.get -> bool
-virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.get -> bool
-virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.Logger.get -> Microsoft.Build.Framework.SdkLogger
-virtual Microsoft.Build.Framework.SdkResolverContext.Logger.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.get -> System.Version
-virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.get -> string
-virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.get -> string
-virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.State.get -> object
-virtual Microsoft.Build.Framework.SdkResolverContext.State.set -> void
-virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.get -> System.Collections.Generic.IList<string>
-virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.set -> void
-virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem>
-virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Path.get -> string
-virtual Microsoft.Build.Framework.SdkResult.Path.set -> void
-virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.get -> System.Collections.Generic.IDictionary<string, string>
-virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.set -> void
-virtual Microsoft.Build.Framework.SdkResult.SdkReference.get -> Microsoft.Build.Framework.SdkReference
-virtual Microsoft.Build.Framework.SdkResult.SdkReference.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Success.get -> bool
-virtual Microsoft.Build.Framework.SdkResult.Success.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Version.get -> string
-virtual Microsoft.Build.Framework.SdkResult.Version.set -> void
-virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
\ No newline at end of file
diff --git a/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Framework/ResponseFileUsedEventArgs.cs b/src/Framework/ResponseFileUsedEventArgs.cs
new file mode 100644
index 00000000000..28e4200402f
--- /dev/null
+++ b/src/Framework/ResponseFileUsedEventArgs.cs
@@ -0,0 +1,26 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Arguments for the response file used event
+    /// </summary>
+    [Serializable]
+    public class ResponseFileUsedEventArgs : BuildMessageEventArgs
+    {
+        public ResponseFileUsedEventArgs()
+        {
+        }
+        /// <summary>
+        /// Initialize a new instance of the ResponseFileUsedEventArgs class.
+        /// </summary>
+        public ResponseFileUsedEventArgs(string responseFilePath) : base()
+        {
+            ResponseFilePath = responseFilePath;
+        }
+        public string? ResponseFilePath { set; get; }
+    }
+}
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index bdd2f2e19c5..5ebb1fa8b8a 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -25,6 +25,10 @@
     <!-- Include NuGet build tasks -->
     <PackageReference Include="NuGet.Build.Tasks" />
     <PackageReference Include="Microsoft.Build.NuGetSdkResolver" />
+
+    <!-- As of 17.5, NuGet.Build.Tasks and Microsoft.Build.NuGetSdkResolver depends on Newtonsoft.Json version 13.0.1,
+         causing it to be downloaded and flagged by component governance -->
+    <PackageReference Include="Newtonsoft.Json" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(MonoBuild)' == 'true'">
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index 44e1b3a9c67..e211fc36115 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -281,6 +281,44 @@ public void ServerShouldNotStartWhenBuildIsInteractive()
             pidOfInitialProcess.ShouldBe(pidOfServerProcess, "We started a server node even when build is interactive.");
         }
 
+        [Fact]
+        public void PropertyMSBuildStartupDirectoryOnServer()
+        {
+            string reportMSBuildStartupDirectoryProperty = @$"
+<Project>
+    <UsingTask TaskName=""ProcessIdTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
+	<Target Name=""DisplayMessages"">
+        <ProcessIdTask>
+            <Output PropertyName=""PID"" TaskParameter=""Pid"" />
+        </ProcessIdTask>
+        <Message Text=""Server ID is $(PID)"" Importance=""High"" />
+		<Message Text="":MSBuildStartupDirectory:$(MSBuildStartupDirectory):"" Importance=""high"" />
+	</Target> 
+</Project>";
+
+            TransientTestFile project = _env.CreateFile("testProject.proj", reportMSBuildStartupDirectoryProperty);
+            _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+
+            // Start on current working directory
+            string output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, $"/t:DisplayMessages {project.Path}", out bool success, false, _output);
+            success.ShouldBeTrue();
+            int pidOfServerProcess = ParseNumber(output, "Server ID is ");
+            _env.WithTransientProcess(pidOfServerProcess);
+            output.ShouldContain($@":MSBuildStartupDirectory:{Environment.CurrentDirectory}:");
+
+            // Start on transient project directory
+            _env.SetCurrentDirectory(Path.GetDirectoryName(project.Path));
+            output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, $"/t:DisplayMessages {project.Path}", out success, false, _output);
+            int pidOfNewServerProcess = ParseNumber(output, "Server ID is ");
+            if (pidOfServerProcess != pidOfNewServerProcess)
+            {
+                // Register process to clean up (be killed) after tests ends.
+                _env.WithTransientProcess(pidOfNewServerProcess);
+            }
+            pidOfNewServerProcess.ShouldBe(pidOfServerProcess);
+            output.ShouldContain($@":MSBuildStartupDirectory:{Environment.CurrentDirectory}:");
+        }
+
         private int ParseNumber(string searchString, string toFind)
         {
             Regex regex = new(@$"{toFind}(\d+)");
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index e99faefea4b..4ec352da9a3 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -47,6 +47,7 @@ internal enum ParameterlessSwitch
             FileLogger8,
             FileLogger9,
             DistributedFileLogger,
+            FancyLogger,
 #if DEBUG
             WaitForDebugger,
 #endif
@@ -220,6 +221,7 @@ bool emptyParametersAllowed
             new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },            ParameterlessSwitch.FileLogger8,           null),
             new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },            ParameterlessSwitch.FileLogger9,           null),
             new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },  ParameterlessSwitch.DistributedFileLogger, null),
+            new ParameterlessSwitchInfo(  new string[] { "fancylogger", "flg" },            ParameterlessSwitch.FancyLogger,           null),
 #if DEBUG
             new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },        ParameterlessSwitch.WaitForDebugger,       null),
 #endif
diff --git a/src/MSBuild/FancyLogger/ANSIBuilder.cs b/src/MSBuild/FancyLogger/ANSIBuilder.cs
new file mode 100644
index 00000000000..2a161bd6667
--- /dev/null
+++ b/src/MSBuild/FancyLogger/ANSIBuilder.cs
@@ -0,0 +1,386 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    internal static class ANSIBuilder
+    {
+        public static string ANSIRemove(string text)
+        {
+            return Regex.Replace(text, "\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])", "");
+        }
+
+        public static class Alignment
+        {
+            public static string Center(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth) return text;
+                int space = (Console.BufferWidth - noFormatString.Length) / 2;
+                result += new string(' ', space);
+                result += text;
+                result += new string(' ', space);
+                return result;
+            }
+
+            public static string Right(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth) return text;
+                int space = Console.BufferWidth - noFormatString.Length;
+                result += new string(' ', space);
+                result += text;
+                return result;
+            }
+
+            public static string Left(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth) return text;
+                int space = Console.BufferWidth - noFormatString.Length;
+                result += text;
+                result += new string(' ', space);
+                return result;
+            }
+
+            public static string SpaceBetween(string leftText, string rightText, int width)
+            {
+                string result = String.Empty;
+                string leftNoFormatString = ANSIRemove(leftText);
+                string rightNoFormatString = ANSIRemove(rightText);
+                if (leftNoFormatString.Length + rightNoFormatString.Length > Console.BufferWidth) return leftText + rightText;
+                int space = Console.BufferWidth - (leftNoFormatString.Length + rightNoFormatString.Length) - 1;
+                result += leftText;
+                result += new string(' ', space);
+                result += rightText;
+                return result;
+            }
+        }
+
+        public static class Formatting
+        {
+            public enum ForegroundColor
+            {
+                Black = 30,
+                Red = 31,
+                Green = 32,
+                Yellow = 33,
+                Blue = 34,
+                Magenta = 35,
+                Cyan = 36,
+                White = 37,
+                Default = 39
+            };
+
+            public enum BackgroundColor
+            {
+                Black = 40,
+                Red = 41,
+                Green = 42,
+                Yellow = 43,
+                Blue = 44,
+                Magenta = 45,
+                Cyan = 46,
+                White = 47,
+                Default = 49
+            }
+
+            public static string Color(string text, ForegroundColor color)
+            {
+                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
+            }
+
+            public static string Color(string text, BackgroundColor color)
+            {
+                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
+            }
+
+            public static string Color(string text, BackgroundColor backgrdoundColor, ForegroundColor foregroundColor)
+            {
+                return String.Format("\x1b[{0};{1}m{2}\x1b[0m", (int)backgrdoundColor, (int)foregroundColor, text);
+            }
+
+            public static string Bold(string text)
+            {
+                return String.Format("\x1b[1m{0}\x1b[22m", text);
+            }
+
+            public static string Dim(string text)
+            {
+                return String.Format("\x1b[2m{0}\x1b[22m", text);
+            }
+
+            public static string Italic(string text)
+            {
+                return String.Format("\x1b[3m{0}\x1b[23m", text);
+            }
+
+            public static string Underlined(string text)
+            {
+                return String.Format("\x1b[4m{0}\x1b[24m", text);
+            }
+
+            public static string DoubleUnderlined(string text)
+            {
+                return String.Format("\x1b[21m{0}\x1b[24m", text);
+            }
+
+            public static string Blinking(string text)
+            {
+                return String.Format("\x1b[5m{0}\x1b[25m", text);
+            }
+
+            public static string Inverse(string text)
+            {
+                return String.Format("\x1b[7m{0}\x1b[27m", text);
+            }
+
+            public static string Invisible(string text)
+            {
+                return String.Format("\x1b[8m{0}\x1b[28m", text);
+            }
+
+            public static string CrossedOut(string text)
+            {
+                return String.Format("\x1b[9m{0}\x1b[29m", text);
+            }
+
+            public static string Overlined(string text)
+            {
+                return String.Format("\x1b[53m{0}\x1b[55m", text);
+            }
+
+            // TODO: Right now only replaces \ with /. Needs review to make sure it works on all or most terminal emulators.
+            public static string Hyperlink(string text, string url)
+            {
+                // return String.Format("\x1b[]8;;{0}\x1b\\{1}\x1b[]8;\x1b\\", text, url);
+                return url.Replace("\\", "/");
+            }
+
+            public static string DECLineDrawing(string text)
+            {
+                return String.Format("\x1b(0{0}\x1b(B", text);
+            }
+        }
+
+        public static class Cursor
+        {
+            public enum CursorStyle
+            {
+                Default = 0,
+                BlockBlinking = 1,
+                BlockSteady = 2,
+                UnderlineBlinking = 3,
+                UnderlineSteady = 4,
+                BarBlinking = 5,
+                BarSteady = 6,
+            }
+
+            public static string Style(CursorStyle style)
+            {
+                return String.Format("\x1b[{0} q", (int)style);
+            }
+
+            public static string Up(int n = 1)
+            {
+                return String.Format("\x1b[{0}A", n);
+            }
+
+            public static string UpAndScroll(int n)
+            {
+                string result = "";
+                for (int i = 0; i < n; i++) {
+                    result += "\x1bM";
+                }
+                return result;
+            }
+
+            public static string Down(int n = 1)
+            {
+                return String.Format("\x1b[{0}B", n);
+            }
+
+            public static string Forward(int n = 1)
+            {
+                return String.Format("\x1b[{0}C", n);
+            }
+
+            public static string Backward(int n = 1)
+            {
+                return String.Format("\x1b[{0}D", n);
+            }
+
+            public static string Home()
+            {
+                return String.Format("\x1b[H");
+            }
+
+            public static string Position(int row, int column)
+            {
+                return String.Format("\x1b[{0};{1}H", row, column);
+            }
+
+            public static string SavePosition()
+            {
+                return String.Format("\x1b[s");
+            }
+
+            public static string RestorePosition() {
+                return String.Format("\x1b[u");
+            }
+        }
+
+        public static class Tabulator
+        {
+            public static string SetStop()
+            {
+                return String.Format("\x1bH");
+            }
+
+            public static string ForwardTab(int n)
+            {
+                if (n == 0) return "";
+                return String.Format("\x1b[{0}I", n);
+            }
+
+            public static string BackwardTab(int n)
+            {
+                return String.Format("\x1b[{0}Z", n);
+            }
+
+            public static string UnsetStop()
+            {
+                return String.Format("\x1b[0g");
+            }
+
+            public static string UnserAlStops()
+            {
+                return String.Format("\x1b[3g");
+            }
+        }
+
+        public static class Viewport
+        {
+            public static string ScrollDown(int n)
+            {
+                return String.Format("\x1b[{0}T", n);
+            }
+
+            public static string ScrollUp(int n)
+            {
+                return String.Format("\x1b[{0}S", n);
+            }
+
+            public static string SetScrollingRegion(int start, int end)
+            {
+                return String.Format("\x1b[{0};{1}r", start, end);
+            }
+
+            public static string PrependLines(int n)
+            {
+                return String.Format("\x1b[{0}L", n);
+            }
+
+            public static string DeleteLines(int n)
+            {
+                return String.Format("\x1b[{0}M", n);
+            }
+        }
+
+        public static class Eraser
+        {
+            public static string DisplayCursorToEnd()
+            {
+                return String.Format("\x1b[0J");
+            }
+
+            public static string DisplayStartToCursor()
+            {
+                return String.Format("\x1b[1J");
+            }
+
+            public static string Display()
+            {
+                return String.Format("\x1b[2J");
+            }
+
+            public static string LineCursorToEnd()
+            {
+                return String.Format("\x1b[0K");
+            }
+
+            public static string LineStartToCursor()
+            {
+                return String.Format("\x1b[1K");
+            }
+
+            public static string Line()
+            {
+                return String.Format("\x1b[2k");
+            }
+        }
+
+        public static class Graphics
+        {
+            private static int spinnerCounter = 0;
+            public static string Spinner()
+            {
+                return Spinner(spinnerCounter++);
+            }
+
+            public static string Spinner(int n)
+            {
+                char[] chars = { '\\', '|', '/', '-'};
+                return chars[n % (chars.Length - 1)].ToString();
+            }
+
+            public static string ProgressBar(float percentage, int width = 10, char completedChar = '█', char remainingChar = '░')
+            {
+                string result = String.Empty;
+                for (int i = 0; i < (int)Math.Floor(width * percentage); i++)
+                {
+                    result += completedChar;
+                }
+                for (int i = (int)Math.Floor(width * percentage); i < width; i++)
+                {
+                    result += remainingChar;
+                }
+                return result;
+            }
+
+            public static string Bell()
+            {
+                return String.Format("\x07");
+            }
+        }
+
+        public static class Buffer
+        {
+            public static string Fill()
+            {
+                return String.Format("\x1b#8");
+            }
+
+            public static string UseAlternateBuffer()
+            {
+                return "\x1b[?1049h";
+            }
+
+            public static string UseMainBuffer()
+            {
+                return "\x1b[?1049l";
+            }
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLogger.cs b/src/MSBuild/FancyLogger/FancyLogger.cs
new file mode 100644
index 00000000000..c1906c25ba5
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLogger.cs
@@ -0,0 +1,172 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+
+using Microsoft.Build.Framework;
+using System.Runtime.InteropServices;
+using System.Threading;
+using System.Threading.Tasks;
+using System.IO;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    internal class FancyLogger : ILogger
+    {   
+        private Dictionary<int, FancyLoggerProjectNode> projects = new Dictionary<int, FancyLoggerProjectNode>();
+
+        private bool Succeeded;
+
+        private float existingTasks = 1;
+        private float completedTasks = 0;
+
+        public string Parameters {  get; set; }
+
+        public LoggerVerbosity Verbosity { get; set; }
+
+        public FancyLogger()
+        {
+            Parameters = "";
+        }
+
+        public void Initialize(IEventSource eventSource)
+        {
+            // Register for different events
+            // Started
+            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);
+            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);
+            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
+            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
+            // Finished
+            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);
+            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);
+            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
+            // eventSource.TaskFinished += new TaskFinishedEventHandler(eventSource_TaskFinished);
+            // Raised
+            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);
+            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);
+            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);
+            // Initialize FancyLoggerBuffer
+            FancyLoggerBuffer.Initialize();
+        }
+
+        // Build
+        void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
+        {
+        }
+        void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
+        {
+            Succeeded = e.Succeeded;
+            // Console.WriteLine(LoggerFormatting.Bold("[Build]") + "\t Finished");
+        }
+
+        // Project
+        void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            // If id already exists...
+            if (projects.ContainsKey(id)) return;
+            // Add project
+            FancyLoggerProjectNode node = new FancyLoggerProjectNode(e);
+            projects[id] = node;
+            // Log
+            node.Log();
+        }
+        void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update line
+            node.Finished = true;
+            node.Log();
+        }
+        // Target
+        void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddTarget(e);
+            node.Log();
+        }
+        void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.FinishedTargets++;
+            node.Log();
+        }
+
+        // Task
+        void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddTask(e);
+            node.Log();
+            existingTasks++;
+        }
+
+        void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
+        {
+            completedTasks++;
+        }
+
+        void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddMessage(e);
+            node.Log();
+        }
+        void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddWarning(e);
+            node.Log();
+        }
+        void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddError(e);
+            node.Log();
+        }
+
+
+        public void Shutdown()
+        {
+            FancyLoggerBuffer.Terminate();
+            // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer
+            Console.Clear();
+            // Console.WriteLine("Build status, warnings and errors will be shown here after the build has ended and the interactive logger has closed");
+            if (Succeeded)
+            {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build succeeded.", ANSIBuilder.Formatting.ForegroundColor.Green));
+                Console.WriteLine("\tX Warning(s)");
+            }
+            else
+            {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build failed.", ANSIBuilder.Formatting.ForegroundColor.Red));
+                Console.WriteLine("\tX Warnings(s)");
+                Console.WriteLine("\tX Errors(s)");
+            }
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerBuffer.cs b/src/MSBuild/FancyLogger/FancyLoggerBuffer.cs
new file mode 100644
index 00000000000..cb3b44cfa65
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerBuffer.cs
@@ -0,0 +1,199 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Specialized;
+using System.Linq;
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    internal class FancyLoggerBufferLine
+    {
+        private static int Counter = 0;
+        public int Id;
+        public string Text;
+
+        public FancyLoggerBufferLine()
+        {
+            Id = Counter++;
+            Text = String.Empty;
+        }
+        public FancyLoggerBufferLine(string text)
+            : this()
+        {
+            Text = text;
+        }
+    }
+
+    internal class FancyLoggerBuffer
+    {
+        private static List<FancyLoggerBufferLine> Lines = new();
+        private static int TopLineIndex = 0;
+        private static bool AutoScrollEnabled = true;
+        public static void Initialize()
+        {
+            // Use alternate buffer
+            // TODO: Remove. Tries to solve a bug when switching from and to the alternate buffer
+            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
+            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
+
+            Task.Run(async () => {
+                while (true)
+                {
+                    await Task.Delay(500 / 60);
+                    Render();
+                }
+            });
+
+            Task.Run(() =>
+            {
+                while (true)
+                {
+                    switch (Console.ReadKey().Key)
+                    {
+                        case ConsoleKey.UpArrow:
+                            if (TopLineIndex > 0) TopLineIndex--;
+                            break;
+                        case ConsoleKey.DownArrow:
+                            if (TopLineIndex < Console.BufferHeight - 3) TopLineIndex++;
+                            break;
+                        case ConsoleKey.Spacebar:
+                        case ConsoleKey.Escape:
+                            AutoScrollEnabled = !AutoScrollEnabled;
+                            break;
+                    }
+                }
+            });
+        }
+
+        public static void Terminate()
+        {
+            // TODO: Remove. Tries to solve a bug when switching from and to the alternate buffer
+            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
+            Console.Write(ANSIBuilder.Eraser.Display());
+            Lines = new();
+        }
+
+        #region Rendering
+        public static void Render()
+        {
+            if (Lines.Count == 0) return;
+            // Write Header
+            Console.Write(
+                // Write header
+                ANSIBuilder.Cursor.Home() +
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress")) +
+                // Write footer
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
+                // TODO: Remove and replace with actual footer
+                new string('-', Console.BufferWidth) + '\n' + "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
+            );
+            // Write lines
+            for (int i = 0; i < Console.BufferHeight - 3; i++)
+            {
+                int lineIndex = i + TopLineIndex;
+                Console.Write(
+                    ANSIBuilder.Cursor.Position(i + 2, 0) +
+                    ANSIBuilder.Eraser.LineCursorToEnd() + 
+                    (lineIndex < Lines.Count ? Lines[lineIndex].Text : String.Empty)
+                );
+            }
+        }
+        #endregion
+
+        #region Line identification
+        public static int GetLineIndexById(int lineId)
+        {
+            for (int i = 0; i < Lines.Count; i++)
+            {
+                if (Lines[i].Id == lineId) return i;
+            }
+            return -1;
+        }
+
+        public static FancyLoggerBufferLine? GetLineById(int lineId)
+        {
+            int index = GetLineIndexById(lineId);
+            if (index == -1) return null;
+            return Lines[index];
+        }
+        #endregion
+
+        #region Line create, update and delete
+        // Write new line
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, string text)
+        {
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
+            return WriteNewLineAfter(lineId, line);
+        }
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, FancyLoggerBufferLine line)
+        {
+            // Get line index
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1) return null;
+            // Save top line
+            int topLineId = Lines[TopLineIndex].Id;
+            // Add
+            Lines.Insert(lineIndex + 1, line);
+            // Get updated top line index
+            TopLineIndex = GetLineIndexById(topLineId);
+            // Return
+            return line;
+        }
+
+        public static FancyLoggerBufferLine? WriteNewLine(string text)
+        {
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
+            return WriteNewLine(line);
+        }
+        public static FancyLoggerBufferLine? WriteNewLine(FancyLoggerBufferLine line)
+        {
+            // Get last id
+            if (Lines.Count > 0)
+            {
+                int lineId = Lines.Last().Id;
+                return WriteNewLineAfter(lineId, line);
+            }
+            else
+            {
+                Lines.Add(line);
+                return line;
+            }
+        }
+
+        // Update line
+        public static FancyLoggerBufferLine? UpdateLine(int lineId, string text)
+        {
+            // Get line
+            FancyLoggerBufferLine? line = GetLineById(lineId);
+            if (line == null) return null;
+            line.Text = text;
+            // Return
+            return line;
+        }
+
+        // Delete line
+        public static void DeleteLine(int lineId)
+        {
+            // TODO: What if line id is equal to topLineId?????
+            // Get line index
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1) return;
+            // Save top line
+            int topLineId = Lines[TopLineIndex].Id;
+            // Delete
+            Lines.RemoveAt(lineIndex);
+            // Get updated top line index
+            if (topLineId != lineId)
+            {
+                TopLineIndex = GetLineIndexById(topLineId);
+            }
+        }
+        #endregion
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerMessageNode.cs b/src/MSBuild/FancyLogger/FancyLoggerMessageNode.cs
new file mode 100644
index 00000000000..3da62c3e39e
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerMessageNode.cs
@@ -0,0 +1,44 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    internal class FancyLoggerMessageNode
+    {
+        public string Message;
+        public FancyLoggerBufferLine? Line;
+
+        public FancyLoggerMessageNode(LazyFormattedBuildEventArgs args)
+        {
+            // TODO: Replace
+            if (args.Message == null)
+            {
+                Message = string.Empty;
+            }
+            else if (args.Message.Length > Console.WindowWidth - 1)
+            {
+                Message = args.Message.Substring(0, Console.WindowWidth - 1);
+            }
+            else
+            {
+                Message = args.Message;
+            }
+        }
+
+        public void Log()
+        {
+            if (Line == null) return;
+            FancyLoggerBuffer.UpdateLine(Line.Id, $"    └── {ANSIBuilder.Formatting.Italic(Message)}");
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerProjectNode.cs b/src/MSBuild/FancyLogger/FancyLoggerProjectNode.cs
new file mode 100644
index 00000000000..a97e265960a
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerProjectNode.cs
@@ -0,0 +1,120 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+    internal class FancyLoggerProjectNode
+    {
+        /// <summary>
+        /// Given a list of paths, this method will get the shortest not ambiguous path for a project.
+        /// Example: for `/users/documents/foo/project.csproj` and `/users/documents/bar/project.csproj`, the respective non ambiguous paths would be `foo/project.csproj` and `bar/project.csproj`
+        /// Still work in progress...
+        /// </summary>
+        private static string GetUnambiguousPath(string path)
+        {
+            return Path.GetFileName(path);
+        }
+
+        public int Id;
+        public string ProjectPath;
+        public string TargetFramework;
+        public bool Finished;
+        // Line to display project info
+        public FancyLoggerBufferLine? Line;
+        // Targets
+        public int FinishedTargets;
+        public FancyLoggerBufferLine? CurrentTargetLine;
+        public FancyLoggerTargetNode? CurrentTargetNode;
+        // Messages, errors and warnings
+        List<FancyLoggerMessageNode> AdditionalDetails = new();
+        public FancyLoggerProjectNode(ProjectStartedEventArgs args)
+        {
+            Id = args.ProjectId;
+            ProjectPath = args.ProjectFile!;
+            Finished = false;
+            FinishedTargets = 0;
+            if (args.GlobalProperties != null && args.GlobalProperties.ContainsKey("TargetFramework"))
+            {
+                TargetFramework = args.GlobalProperties["TargetFramework"];
+            }
+            else
+            {
+                TargetFramework = "";
+            }
+        }
+
+        public void Log()
+        {
+            // Project details
+            string lineContents = ANSIBuilder.Alignment.SpaceBetween(
+                $"{(Finished ? ANSIBuilder.Formatting.Color("✓", ANSIBuilder.Formatting.ForegroundColor.Green) : ANSIBuilder.Graphics.Spinner())} {ANSIBuilder.Formatting.Dim("Project: ")} {ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), Finished ? ANSIBuilder.Formatting.ForegroundColor.Green : ANSIBuilder.Formatting.ForegroundColor.Default )} [{TargetFramework}]",
+                $"({FinishedTargets} targets completed)",
+                Console.WindowWidth
+            );
+
+            // Create or update line
+            if (Line == null) Line = FancyLoggerBuffer.WriteNewLine(lineContents);
+            else FancyLoggerBuffer.UpdateLine(Line.Id, lineContents);
+
+            // For finished projects
+            if (Finished)
+            {
+                if (CurrentTargetLine != null) FancyLoggerBuffer.DeleteLine(CurrentTargetLine.Id);
+                foreach (FancyLoggerMessageNode node in AdditionalDetails)
+                {
+                    if (node.Line != null) FancyLoggerBuffer.DeleteLine(node.Line.Id);
+                    node.Line = null;
+                }
+            }
+
+            // Current target details
+            if (CurrentTargetNode == null) return;
+            string currentTargetLineContents = $"    └── {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
+            if (CurrentTargetLine == null) CurrentTargetLine = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
+            else FancyLoggerBuffer.UpdateLine(CurrentTargetLine.Id, currentTargetLineContents);
+
+            // Messages, warnings and errors
+            foreach (FancyLoggerMessageNode node in AdditionalDetails)
+            {
+                if (node.Line == null) node.Line = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, "Message");
+                node.Log();
+            }
+        }
+
+        public void AddTarget(TargetStartedEventArgs args)
+        {
+            CurrentTargetNode = new FancyLoggerTargetNode(args);
+        }
+        public void AddTask(TaskStartedEventArgs args)
+        {
+            // Get target id
+            int targetId = args.BuildEventContext!.TargetId;
+            if (CurrentTargetNode?.Id == targetId)
+            {
+                CurrentTargetNode.AddTask(args);
+            }
+        }
+        public void AddMessage(BuildMessageEventArgs args)
+        {
+            if (args.Importance != MessageImportance.High) return;
+            AdditionalDetails.Add(new FancyLoggerMessageNode(args));
+        }
+        public void AddWarning(BuildWarningEventArgs args)
+        {
+            AdditionalDetails.Add(new FancyLoggerMessageNode(args));
+        }
+        public void AddError(BuildErrorEventArgs args)
+        {
+            AdditionalDetails.Add(new FancyLoggerMessageNode(args));
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerTargetNode.cs b/src/MSBuild/FancyLogger/FancyLoggerTargetNode.cs
new file mode 100644
index 00000000000..479b78a5cb8
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerTargetNode.cs
@@ -0,0 +1,31 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    internal class FancyLoggerTargetNode
+    {
+        public int Id;
+        public string TargetName;
+        public FancyLoggerTaskNode? CurrentTaskNode;
+        public FancyLoggerTargetNode(TargetStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TargetId;
+            TargetName = args.TargetName;
+        }
+        public void AddTask(TaskStartedEventArgs args)
+        {
+            CurrentTaskNode = new FancyLoggerTaskNode(args);
+        }
+    }
+}
diff --git a/src/MSBuild/FancyLogger/FancyLoggerTaskNode.cs b/src/MSBuild/FancyLogger/FancyLoggerTaskNode.cs
new file mode 100644
index 00000000000..b94b02e5725
--- /dev/null
+++ b/src/MSBuild/FancyLogger/FancyLoggerTaskNode.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    internal class FancyLoggerTaskNode
+    {
+        public int Id;
+        public string TaskName;
+        public FancyLoggerTaskNode(TaskStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TaskId;
+            TaskName = args.TaskName;
+        }
+    }
+}
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 2fd51da537c..e3d5d6b9589 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -172,6 +172,7 @@
     <Compile Include="DistributedLoggerRecord.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="FancyLogger\*.cs" />
     <Compile Include="InitializationException.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -241,8 +242,10 @@
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
   </ItemGroup>
 
+  <!-- Xsds are not TF or arch-specific so copy once them in the outer build -->
   <Target Name="CopyXsds"
-          BeforeTargets="AfterBuild">
+          BeforeTargets="Build"
+          Condition="'$(IsInnerBuild)' != 'true'">
     <Copy SourceFiles="@(XsdsForVS)"
           DestinationFiles="@(XsdsForVS->'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')"
           SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
index 9177f76aa19..0fd4ea40181 100644
--- a/src/MSBuild/MSBuildClientApp.cs
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -76,6 +76,7 @@ public static MSBuildApp.ExitType Execute(
 
             if (exitResult.MSBuildClientExitType == MSBuildClientExitType.ServerBusy ||
                 exitResult.MSBuildClientExitType == MSBuildClientExitType.UnableToConnect ||
+                exitResult.MSBuildClientExitType == MSBuildClientExitType.UnknownServerState ||
                 exitResult.MSBuildClientExitType == MSBuildClientExitType.LaunchError)
             {
                 if (KnownTelemetry.BuildTelemetry != null)
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 83498322bea..629795762ae 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -516,39 +516,41 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleloggerparameters:&lt;parameters&gt;
-                     Parametry protokolovacího nástroje konzoly. (Krátký tvar: -clp)
-                     Dostupné parametry:
-                        PerformanceSummary – zobrazí dobu zpracování úloh, cílů
-                            a projektů.
-                        Summary – na konci zobrazí souhrn chyb a upozornění.
-                        NoSummary – na konci nezobrazí souhrny chyb
-                            a upozornění.
-                        ErrorsOnly – zobrazí jenom chyby.
-                        WarningsOnly – zobrazí jenom upozornění.
-                        NoItemAndPropertyList – nezobrazí na začátku sestavení každého
-                            projektu seznamy položek a vlastností.
-                        ShowCommandLine – zobrazí zprávy TaskCommandLineEvent.
-                        ShowTimestamp – před každou zprávou zobrazí
-                            časové razítko.
-                        ShowEventId – zobrazí ID události pro spuštěné a dokončené
-                            události a zprávy.
-                        ForceNoAlign – nenastavuje text podle velikosti vyrovnávací
-                            paměti konzoly.
-                        DisableConsoleColor – použije výchozí barvy konzoly
-                            pro všechny zprávy protokolování.
-                        DisableMPLogging – zakáže víceprocesorový styl výstupu
-                            protokolování při práci v jiném než víceprocesorovém
-                            režimu.
-                        EnableMPLogging – povolí víceprocesorový styl výstupu
-                            protokolování i při práci v jiném
-                            režimu. Tento styl protokolování je výchozí. 
-                        ForceConsoleColor – použije barvy konzoly ANSI,
-                            i když to konzola nepodporuje.
-                        Verbosity – potlačí nastavení -verbosity
-                            pro tento protokolovací nástroj.
-                     Příklad:
-                        -consoleloggerparameters:PerformanceSummary;NoSummary;
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
+                        -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index a4661df67c5..3c0965cfed9 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -513,39 +513,41 @@ Beispiel:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleloggerparameters:&lt;Parameter&gt;
-                     Parameter für die Konsolenprotokollierung. (Kurzform: -clp)
-                     Folgende Parameter sind verfügbar:
-                        PerformanceSummary: Zeigt die in Aufgaben, Zielen und
-                            Projekten verbrachte Zeit an.
-                        Summary: Zeigt abschließend eine Zusammenfassung der Fehler und Warnungen an.
-                        NoSummary: Zeigt keine Fehler- und Warnungsübersicht am
-                            Ende an.
-                        ErrorsOnly: Zeigt nur Fehler an.
-                        WarningsOnly: Zeigt nur Warnungen an.
-                        NoItemAndPropertyList: Zeigt keine Liste der Elemente
-                            und Eigenschaften am Anfang jeder Projekterstellung an.
-                        ShowCommandLine: Zeigt TaskCommandLineEvent-Meldungen an. 
-                        ShowTimestamp: Zeigt den Timestamp als Präfix einer
-                            Meldung an.                                           
-                        ShowEventId: Zeigt die eventId für gestartete
-                            Ereignisse, abgeschlossene Ereignisse und Meldungen an.
-                        ForceNoAlign: Richtet den Text nicht an der Größe des
-                            Konsolenpuffers aus.
-                        DisableConsoleColor: Verwendet die Standardkonsolenfarben
-                            für alle Protokollierungsmeldungen.
-                        DisableMPLogging: Deaktiviert die Ausgabe wie
-                            bei der Mehrprozessorprotokollierung im Modus mit nur einem Prozessor.
-                        EnableMPLogging: Aktiviert das Format der
-                            Mehrprozessorprotokollierung auch bei der Ausführung
-                            im Modus mit nur einem Prozessor. Dieses Protokollierungsformat ist standardmäßig aktiviert. 
-                        ForceConsoleColor: Verwendet selbst dann
-                            ANSI-Konsolenfarben, wenn
-                            die Konsole dies nicht unterstützt.
-                        Verbosity: Überschreibt die Einstellung für -verbosity für 
-                            diese Protokollierung.
-                     Beispiel:
-                        -consoleloggerparameters:PerformanceSummary;NoSummary;
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
+                        -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 0264ff8e278..061121dec63 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -517,38 +517,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parámetros&gt;
-                     Parámetros del registrador de consola. (Forma corta: -clp)
-                     Los parámetros disponibles son:
-                        PerformanceSummary: muestra el tiempo empleado en tareas, destinos
-                            y proyectos.
-                        Summary: muestra un resumen de errores y advertencias al final.
-                        NoSummary: no muestra el resumen de errores y advertencias al
-                            final.
-                        ErrorsOnly: muestra solo errores.
-                        WarningsOnly: muestra solo advertencias.
-                        NoItemAndPropertyList: no muestra la lista de elementos y
-                            propiedades al principio de cada compilación del proyecto.
-                        ShowCommandLine: muestra los mensajes de TaskCommandLineEvent
-                        ShowTimestamp: muestra la marca de tiempo como un prefijo en los
-                            mensajes.
-                        ShowEventId: muestra el identificador de evento para los eventos iniciados, los eventos 
-                            finalizados y los mensajes.
-                        ForceNoAlign: no alinea el texto al tamaño del
-                            búfer de la consola
-                        DisableConsoleColor: usa los colores de consola predeterminados
-                            para todos los mensajes de registro.
-                        DisableMPLogging: deshabilita el estilo de registro de resultados
-                            de multiprocesador al ejecutarse en el
-                            modo de no multiprocesador.
-                        EnableMPLogging: habilita el estilo de registro de
-                            multiprocesador aunque se ejecute en el modo de
-                            no multiprocesador. Este estilo de registro está habilitado de forma predeterminada.
-                     ForceConsoleColor: usa los colores de consola ANSI incluso si
-                            la consola no lo admite.
-                        Verbosity: invalida el valor -verbosity para este
-                            registrador.
-                     Ejemplo:
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index f67550e3ebe..cbe9a27f313 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -513,40 +513,42 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;paramètres&gt;
-         Paramètres du journaliseur de la console. (Forme abrégée : -clp)
-         Paramètres disponibles :
-            PerformanceSummary--Affiche la durée des tâches, des cibles
-                et des projets.
-            Summary--Récapitulatif des erreurs et des avertissements à la fin.
-            NoSummary--Aucun récapitulatif des erreurs et des avertissements
-                à la fin.
-            ErrorsOnly--Affiche uniquement les erreurs.
-            WarningsOnly--Affiche uniquement les avertissements.
-            NoItemAndPropertyList--N'affiche pas la liste des éléments et
-                des propriétés au début de chaque build de projet.
-            ShowCommandLine--Affiche les messages de TaskCommandLineEvent
-            ShowTimestamp--Affiche l'horodatage en tant que préfixe des
-                messages.
-            ShowEventId--Affiche eventId pour les événements démarrés et
-                achevés ainsi que les messages
-            ForceNoAlign--N'aligne pas le texte par rapport à la taille de la
-                mémoire tampon de la console
-            DisableConsoleColor--Utilise les couleurs de la console par défaut
-                pour tous les messages de journalisation.
-            DisableMPLogging--Désactive le style de journalisation
-                multiprocesseur de la sortie durant l'exécution en
-                mode non multiprocesseur.
-            EnableMPLogging--Active le style de journalisation multiprocesseur
-                même durant l'exécution en mode non
-                multiprocesseur. Style de journalisation activé par défaut.
-            ForceConsoleColor--Utilise les couleurs de la console ANSI même si
-                cela n'est pas pris en charge par la console
-            Verbosity--Remplace le paramètre -verbosity pour ce
-                journaliseur.
-         Exemple :
-            -consoleLoggerParameters:PerformanceSummary;NoSummary;
-                         Verbosity=minimal
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
+                        -consoleLoggerParameters:PerformanceSummary;NoSummary;
+                                                 Verbosity=minimal
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 16817ae88bf..c222fdf2e2e 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -523,48 +523,42 @@ Esempio:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parametri&gt;
-                      Parametri per il logger di console. Forma breve: -clp.
-                      I parametri disponibili sono:
-                      PerformanceSummary: indica il tempo impiegato per le
-                      attività, le destinazioni e i progetti.
-                      Summary: visualizza un riepilogo degli errori e degli
-                      avvisi alla fine.
-                      NoSummary: non visualizza un riepilogo degli errori e
-                      degli avvisi alla fine.
-                      ErrorsOnly: visualizza solo gli errori.
-                      WarningsOnly: visualizza solo gli avvisi.
-                      NoItemAndPropertyList: non visualizza l'elenco di
-                      elementi e proprietà all'inizio
-                      di ogni compilazione del
-                      progetto.
-                      ShowCommandLine: visualizza i messaggi
-                      TaskCommandLineEvent.
-                      ShowTimestamp: visualizza il timestamp sotto forma di
-                      prefisso per ogni messaggio.
-                      ShowEventId: mostra l'ID evento per gli eventi iniziati,
-                      gli eventi finiti e i messaggi.
-                      ForceNoAlign: non allinea il testo alle dimensioni del
-                      buffer della console.
-                      DisableConsoleColor: usa i colori predefiniti della
-                      console per tutti i messaggi di
-                      registrazione.
-                      DisableMPLogging: disabilita lo stile di registrazione
-                      multiprocessore dell'output quando è
-                      in esecuzione in modalità non-
-                      multiprocessore.
-                      EnableMPLogging: abilita lo stile di registrazione
-                      multiprocessore anche quando è in
-                      esecuzione in modalità non-
-                      multiprocessore. Si tratta dello stile
-                      di registrazione predefinito.
-                      ForceConsoleColor: usa i colori della console ANSI anche
-                      se non sono supportati dalla console.
-                      Verbosity: esegue l'override dell'impostazione
-                      -verbosity per questo logger.
-                      Esempio:
-                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
-                                                  Verbosity=minimal
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
+                        -consoleLoggerParameters:PerformanceSummary;NoSummary;
+                                                 Verbosity=minimal
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 0d83ec719f6..b43a24ea5b0 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -513,38 +513,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parameters&gt;
-                     コンソール ロガーへのパラメーターです。(短縮形: -clp)
-                     利用可能なパラメーター:
-                        PerformanceSummary--タスク、ターゲット、プロジェクトにかかった時間を
-                            表示します。
-                        Summary--最後にエラーと警告の概要を表示します。
-                        NoSummary--最後にエラーと警告の概要を表示
-                            しません。
-                        ErrorsOnly--エラーのみを表示します。
-                        WarningsOnly--警告のみを表示します。
-                        NoItemAndPropertyList--各プロジェクトのビルド開始時に、
-                            項目とプロパティのリストを表示しません。
-                        ShowCommandLine--TaskCommandLineEvent メッセージを表示します
-                        ShowTimestamp--Timestamp を任意のメッセージへのプレフィックスとして
-                            表示します。
-                        ShowEventId--開始されたイベント、終了したイベント、
-                            メッセージの eventId を表示します。
-                        ForceNoAlign--テキストを、コンソール バッファーの
-                            サイズに合わせません
-                        DisableConsoleColor--すべてのログ メッセージに対して
-                            既定のコンソール カラーを使用します。
-                        DisableMPLogging-- 非マルチプロセッサ モードで
-                            実行する際、マルチプロセッサの
-                            出力ログ形式を無効にします。
-                        EnableMPLogging--非マルチプロセッサ モードで
-                            実行する場合も、マルチプロセッサのログ形式を有効にします。
-                            このログ形式は、既定で有効です。
-                        ForceConsoleColor--コンソールでサポートされていない場合でも、
-                            ANSI コンソール カラーを使用します。
-                        Verbosity--このロガーの -verbosity 設定を
-                            上書きします。
-                     例:
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 996484c8d56..212687577a1 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -513,38 +513,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parameters&gt;
-                     콘솔 로거에 대한 매개 변수입니다. (약식: -clp)
-                     사용 가능한 매개 변수는 다음과 같습니다.
-                        PerformanceSummary--작업, 대상 및 프로젝트에서 소요된 시간을 
-                            표시합니다.
-                        Summary--종료 시 오류 및 경고 요약을 표시합니다.
-                        NoSummary--종료 시 오류 및 경고 요약을 표시하지 
-                            않습니다.
-                        ErrorsOnly--오류만 표시합니다.
-                        WarningsOnly--경고만 표시합니다.
-                        NoItemAndPropertyList--각 프로젝트 빌드를 시작할 때 항목 및 속성 목록을 
-                            표시하지 않습니다.
-                        ShowCommandLine--TaskCommandLineEvent 메시지를 표시합니다.
-                        ShowTimestamp--메시지 접두사로 타임스탬프를 
-                            표시합니다.
-                        ShowEventId--시작된 이벤트 완료된 이벤트 및 메시지의 eventId를 
-                            표시합니다.
-                        ForceNoAlign--콘솔 버퍼 크기에 텍스트를 맞추지 
-                            않습니다.
-                        DisableConsoleColor--모든 로깅 메시지에 기본 콘솔 색을 
-                            사용합니다.
-                        DisableMPLogging--다중 프로세서가 아닌 모드에서 실행할 경우 
-                            출력의 다중 프로세서 로깅 스타일을 
-                            사용하지 않도록 설정합니다.
-                        EnableMPLogging--다중 프로세서가 아닌 모드에서 실행할 경우에도 
-                            다중 프로세서 로깅 스타일을 사용하도록 설정합니다.
-                            이 로깅 스타일은 기본적으로 켜집니다.
-                        ForceConsoleColor--콘솔에서 지원하지 않더라도 ANSI 콘솔 색을 
-                            사용합니다
-                        Verbosity--이 로거에 대한 -verbosity 설정을 
-                            재정의합니다.
-                     예:
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 1e40a134ce5..b25931898c2 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -523,40 +523,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parametry&gt;
-                     Parametry rejestratora konsoli. (Krótka wersja: -clp)
-                     Dostępne parametry:
-                        PerformanceSummary — pokazuje czas spędzony
-                        na zadaniach, elementach docelowych i projektach.
-                        Summary — pokazuje na końcu podsumowanie błędów i ostrzeżeń.
-                        NoSummary — nie pokazuje na końcu podsumowania błędów
-                        i ostrzeżeń.
-                        ErrorsOnly — pokazuje tylko błędy.
-                        WarningsOnly — pokazuje tylko ostrzeżenia.
-                        NoItemAndPropertyList — nie pokazuje listy elementów
-                        i właściwości na początku każdej kompilacji projektu.    
-                        ShowCommandLine — pokazuje komunikaty
-                        TaskCommandLineEvent.
-                        ShowTimestamp — wyświetla sygnaturę czasową jako
-                        prefiks każdego komunikatu.                                           
-                        ShowEventId — pokazuje identyfikator zdarzenia dla
-                        rozpoczętych zdarzeń, zakończonych zdarzeń
-                        i komunikatów.
-                        ForceNoAlign — nie dopasowuje tekstu do rozmiaru
-                        buforu konsoli.
-                        DisableConsoleColor — używa domyślnych kolorów konsoli
-                            dla wszystkich komunikatów dotyczących rejestrowania.
-                        DisableMPLogging — wyłącza styl rejestrowania
-                        wieloprocesorowego wyników podczas działania w trybie
-                        jednoprocesorowym.
-                        EnableMPLogging — włącza styl rejestrowania
-                        wieloprocesorowego nawet podczas działania w trybie
-                        jednoprocesorowym. Ten styl rejestrowania jest włączony domyślnie. 
-                        ForceConsoleColor — używa kolorów konsoli ANSI nawet wtedy,
-                            gdy konsola ich nie obsługuje.
-                        Verbosity — przesłania ustawienie -verbosity dla tego
-                        rejestratora.
-                     Przykład:
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 157b81ac122..690d79cd062 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -514,38 +514,40 @@ isoladamente.
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parameters&gt;
-                     Parâmetros do agente do console. (Forma abreviada: -clp)
-                     Os parâmetros disponíveis são:
-                        PerformanceSummary – mostrar o tempo gasto nas tarefas, nos destinos
-                            e nos projetos.
-                        Summary – mostrar o resumo de erros e avisos no final.
-                        NoSummary – não mostrar o resumo de erros e avisos no
-                            final.
-                        ErrorsOnly – mostrar somente os erros.
-                        WarningsOnly – mostrar somente os avisos.
-                        NoItemAndPropertyList – não mostrar a lista de itens e de
-                            propriedades no início de cada build do projeto.
-                        ShowCommandLine – mostrar as mensagens de TaskCommandLineEvent
-                        ShowTimestamp – exibir o Carimbo de data/hora como um prefixo em todas as
-                            mensagens.
-                        ShowEventId – mostrar eventId para eventos iniciados, eventos
-                            concluídos e mensagens
-                        ForceNoAlign – não alinhar o texto ao tamanho do
-                            buffer do console
-                        DisableConsoleColor – usar as cores padrão do console
-                            para todas as mensagens de registro em log.
-                        DisableMPLogging – desabilitar o estilo de saída do registro em log do
-                            multiprocessador quando executado no
-                            modo não multiprocessador.
-                        EnableMPLogging – habilitar o estilo de registro em log do
-                            multiprocessador mesmo quando executado no modo não
-                            multiprocessador. Esse estilo de registro em log é habilitado por padrão.
-                        ForceConsoleColor – usar as cores ANSI do console mesmo se
-                            o console não for compatível com elas
-                        Verbosity – substitui as configurações de -verbosity deste
-                            agente.
-                     Exemplo:
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 339b3ce1319..3e778b63862 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -512,38 +512,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;параметры&gt;
-                     Параметры журнала консоли. (Краткая форма: -clp)
-                     Доступны следующие параметры:
-                        PerformanceSummary--выводить время, затраченное на выполнение задач,
-                            целевых объектов и  проектов.
-                        Summary--выводить сводку ошибок и предупреждений по завершении работы.
-                        NoSummary--не выводить сводку ошибок и предупреждений по
-                            завершении работы.
-                        ErrorsOnly--выводить только ошибки.
-                        WarningsOnly--выводить только предупреждения.
-                        NoItemAndPropertyList--не отображать список элементов и
-                            свойств в начале сборки каждого проекта.
-                        ShowCommandLine--выводить сообщения TaskCommandLineEvent
-                        ShowTimestamp--выводить метку времени в качестве префикса к любому
-                            сообщению.
-                        ShowEventId--выводить код события eventId для запущенных событий,
-                            завершенных событий и сообщений
-                        ForceNoAlign--не выравнивать текст относительно размера
-                            буфера консоли
-                        DisableConsoleColor--использовать цвета консоли по умолчанию
-                            для всех сообщений ведения журнала.
-                        DisableMPLogging--отключить многопроцессорный
-                            стиль ведения журнала выходных данных при работе в
-                            режиме, отличном от многопроцессорного.
-                        EnableMPLogging--включить многопроцессорный стиль ведения журнала
-                            даже при работе в режиме, отличном от
-                            многопроцессорного. Этот стиль ведения журнала включен по умолчанию.
-                        ForceConsoleColor--использовать ANSI-цвета в консоли, даже если
-                            она не поддерживает их
-                        Verbosity--переопределяет параметр -verbosity (уровень детализации) для этого
-                            журнала.
-                     Пример:
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 3a7140e5fa4..acbff27d93c 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -513,39 +513,41 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parametreler&gt;
-                     Konsol günlükçüsü için parametreler. (Kısa biçim: -clp)
-                     Kullanılabilir parametreler:
-                        PerformanceSummary--Görevlerde, hedeflerde ve 
-                            projelerde harcanan süreyi göster.
-                        Summary--Sonda hata ve uyarı özetini göster.
-                        NoSummary--Sonda hata ve uyarı özetini gösterme.
-                        ErrorsOnly--Yalnızca hataları göster.
-                        WarningsOnly--Yalnızca uyarıları göster.
-                        NoItemAndPropertyList--Her proje derlemesinin
-                            başında öğe ve özelliklerin listesini gösterme. 
-                        ShowCommandLine--TaskCommandLineEvent iletilerini 
-                            göster.
-                        ShowTimestamp--Tüm iletilerde önek olarak Zaman
-                            Damgasını göster.
-                        ShowEventId--Başlatılan olaylar, bitirilen olaylar ve 
-                            iletiler için eventId'yi göster.
-                        ForceNoAlign--Metni konsol arabelleğinin boyutuna göre
-                            ayarlama.
-                        DisableConsoleColor--Tüm günlük iletileri için
-                            varsayılan konsol renklerini kullan.
-                        DisableMPLogging--Çoklu işlemci olmayan modda 
-                            çalışırken çıkışta çok işlemcili günlük stilini 
-                            devre dışı bırak.
-                        EnableMPLogging--Çok işlemci olmayan modda çalışırken 
-                            bile çok işlemcili günlük stilini etkinleştir. Bu 
-                            günlük stili varsayılan olarak açıktır.
-                        ForceConsoleColor--Konsol desteklemese bile ANSI
-                            konsol renklerini kullan
-                                                Verbosity--Bu günlükçü için /verbosity ayarını
-                            geçersiz kılar.
-                     Örnek:
-                        /consoleloggerparameters:PerformanceSummary;NoSummary;
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
+                        -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
         <note>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index ce870f5b882..ac8ff48e194 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -513,40 +513,42 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleloggerparameters:&lt;parameters&gt;
-           控制台记录器的参数。(缩写: -clp)
-           可用参数包括:
-            PerformanceSummary -- 显示在任务、目标和项目上
-              花费的时间。
-            Summary -- 结束时显示错误和警告的摘要。
-            NoSummary -- 结束时不显示错误和警告
-              的摘要。
-            ErrorsOnly -- 仅显示错误。
-            WarningsOnly -- 仅显示警告。
-            NoItemAndPropertyList -- 在开始生成每个项目时不显示
-              项和属性的列表。  
-            ShowCommandLine -- 显示 TaskCommandLineEvent 消息 
-            ShowTimestamp -- 将时间戳作为所有消息的前缀
-              显示。                      
-            ShowEventId -- 显示已开始事件、已完成事件和消息
-              的事件 ID。
-            ForceNoAlign -- 不将文本与控制台缓冲区的大小
-              匹配。
-            DisableConsoleColor -- 将默认控制台颜色
-              用于所有记录消息。
-            DisableMPLogging -- 在非多处理器
-              模式下运行时，禁用输出的多处理器
-              日志记录样式。
-            EnableMPLogging -- 即使在非多处理器
-              模式下运行，也启用多处理器
-              日志记录样式。默认情况下启用此日志记录样式。
-                        ForceConsoleColor--使用 ANSI 控制台颜色，即使
-                            控制台不支持它
-                        Verbosity -- 重写此记录器的 -verbosity
-              设置。
-           示例:
-                        -consoleloggerparameters:PerformanceSummary;NoSummary;
-                         Verbosity=minimal
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
+                        -consoleLoggerParameters:PerformanceSummary;NoSummary;
+                                                 Verbosity=minimal
 </target>
         <note>
       LOCALIZATION: The following should not be localized:
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 4458f52f1cc..b2f5a5a0110 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -513,38 +513,40 @@
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;參數&gt;
-                     主控台記錄器的參數。(簡短形式: -clp)
-                     可用的參數為:
-                        PerformanceSummary--顯示工作、目標
-                            及專案所花費的時間。
-                        Summary--結束時顯示錯誤與警告摘要。
-                        NoSummary--結束時不顯示錯誤
-                            與警告摘要。
-                        ErrorsOnly--只顯示錯誤。
-                        WarningsOnly--只顯示警告。
-                        NoItemAndPropertyList--不在每個專案開始建置時，
-                            顯示項目與屬性清單。
-                        ShowCommandLine--顯示 TaskCommandLineEvent 訊息
-                        ShowTimestamp--在所有訊息開頭顯示
-                            時間戳記。
-                        ShowEventId--顯示已開始之事件、已完成之事件
-                            以及訊息的事件識別碼
-                        ForceNoAlign--不將文字調整成主控台
-                            緩衝區的大小
-                        DisableConsoleColor--為所有記錄訊息使用預設的
-                            主控台色彩。
-                        DisableMPLogging-- 在非多處理器模式下執行時，
-                            停用輸出的多處理器
-                            記錄樣式。
-                        EnableMPLogging--在非多處理器模式下執行時，
-                            啟用多處理器記錄樣式。
-                            此記錄樣式預設為啟用。
-                        ForceConsoleColor--即使主控台不支援 ANSI 主控台色彩，
-                            也一律使用該色彩
-                        Verbosity--覆寫此記錄器的 -verbosity
-                             設定。
-                     範例:
+        <target state="new">  -consoleLoggerParameters:&lt;parameters&gt;
+                     Parameters to console logger. (Short form: -clp)
+                     The available parameters are:
+                        PerformanceSummary--Show time spent in tasks, targets
+                            and projects.
+                        Summary--Show error and warning summary at the end.
+                        NoSummary--Don't show error and warning summary at the
+                            end.
+                        ErrorsOnly--Show only errors.
+                        WarningsOnly--Show only warnings.
+                        NoItemAndPropertyList--Don't show list of items and
+                            properties at the start of each project build.
+                        ShowCommandLine--Show TaskCommandLineEvent messages
+                        ShowTimestamp--Display the Timestamp as a prefix to any
+                            message.
+                        ShowEventId--Show eventId for started events, finished
+                            events, and messages
+                        ForceNoAlign--Does not align the text to the size of
+                            the console buffer
+                        DisableConsoleColor--Use the default console colors
+                            for all logging messages.
+                        DisableMPLogging-- Disable the multiprocessor
+                            logging style of output when running in
+                            non-multiprocessor mode.
+                        EnableMPLogging--Enable the multiprocessor logging
+                            style even when running in non-multiprocessor
+                            mode. This logging style is on by default.
+                        ForceConsoleColor--Use ANSI console colors even if
+                            console does not support it
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
+                            logger.
+                     Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </target>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index f70e92bb9a0..cf6ba40db6a 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -38,6 +38,8 @@
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Logging.FancyLogger;
+using System.Runtime.InteropServices;
 
 #nullable disable
 
@@ -126,7 +128,7 @@ public enum ExitType
         private static readonly CancellationTokenSource s_buildCancellationSource = new CancellationTokenSource();
 
         private static readonly char[] s_commaSemicolon = { ',', ';' };
-
+ 
         /// <summary>
         /// Static constructor
         /// </summary>
@@ -678,6 +680,7 @@ string[] commandLine
                 Dictionary<string, string> restoreProperties = null;
                 ILogger[] loggers = Array.Empty<ILogger>();
                 LoggerVerbosity verbosity = LoggerVerbosity.Normal;
+                LoggerVerbosity originalVerbosity = LoggerVerbosity.Normal;
                 List<DistributedLoggerRecord> distributedLoggerRecords = null;
 #if FEATURE_XML_SCHEMA_VALIDATION
                 bool needToValidateProject = false;
@@ -715,6 +718,7 @@ string[] commandLine
                                             ref globalProperties,
                                             ref loggers,
                                             ref verbosity,
+                                            ref originalVerbosity,
                                             ref distributedLoggerRecords,
 #if FEATURE_XML_SCHEMA_VALIDATION
                                             ref needToValidateProject,
@@ -1080,6 +1084,11 @@ private static void ResetGatheringSwitchesState()
         /// </summary>
         private const string msbuildLogFileName = "msbuild.log";
 
+        /// <summary>
+        /// List of messages to be sent to the logger when it is attached
+        /// </summary>
+        private static List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
+
         /// <summary>
         /// Initializes the build engine, and starts the project building.
         /// </summary>
@@ -1317,11 +1326,12 @@ string[] commandLine
                         }
                     }
 
+                    // List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = null;
+
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
 
                     BuildResultCode? result = null;
 
-                    IEnumerable<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = null;
                     if (!Traits.Instance.EscapeHatches.DoNotSendDeferredMessagesToBuildManager)
                     {
                         var commandLineString =
@@ -1330,7 +1340,18 @@ string[] commandLine
 #else
                             string.Join(" ", commandLine);
 #endif
-                        messagesToLogInBuildLoggers = GetMessagesToLogInBuildLoggers(commandLineString);
+                        messagesToLogInBuildLoggers.AddRange(GetMessagesToLogInBuildLoggers(commandLineString));
+
+                        // Log a message for every response file and include it in log
+                        foreach (var responseFilePath in s_includedResponseFiles)
+                        {
+                            messagesToLogInBuildLoggers.Add(
+                                new BuildManager.DeferredBuildMessage(
+                                    String.Format("Included response file: {0}", responseFilePath),
+                                    MessageImportance.Normal,
+                                    responseFilePath
+                                ));
+                        }
                     }
 
                     buildManager.BeginBuild(parameters, messagesToLogInBuildLoggers);
@@ -1485,7 +1506,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
             }
         }
 
-        private static IEnumerable<BuildManager.DeferredBuildMessage> GetMessagesToLogInBuildLoggers(string commandLineString)
+        private static List<BuildManager.DeferredBuildMessage> GetMessagesToLogInBuildLoggers(string commandLineString)
         {
             List<BuildManager.DeferredBuildMessage> messages = new()
             {
@@ -2186,6 +2207,7 @@ private static bool ProcessCommandLineSwitches
             ref Dictionary<string, string> globalProperties,
             ref ILogger[] loggers,
             ref LoggerVerbosity verbosity,
+            ref LoggerVerbosity originalVerbosity,
             ref List<DistributedLoggerRecord> distributedLoggerRecords,
 #if FEATURE_XML_SCHEMA_VALIDATION
             ref bool needToValidateProject,
@@ -2301,6 +2323,7 @@ string commandLine
                                                            ref globalProperties,
                                                            ref loggers,
                                                            ref verbosity,
+                                                           ref originalVerbosity,
                                                            ref distributedLoggerRecords,
 #if FEATURE_XML_SCHEMA_VALIDATION
                                                            ref needToValidateProject,
@@ -2401,6 +2424,7 @@ string commandLine
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
+                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.FancyLogger], 
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
@@ -2408,6 +2432,7 @@ string commandLine
                         groupedFileLoggerParameters,
                         out distributedLoggerRecords,
                         out verbosity,
+                        out originalVerbosity,
                         cpuCount,
                         out profilerLogger,
                         out enableProfiler
@@ -2438,7 +2463,7 @@ out enableProfiler
                         Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("PickedUpSwitchesFromAutoResponse", autoResponseFileName));
                     }
 
-                    if (verbosity == LoggerVerbosity.Diagnostic)
+                    if (originalVerbosity == LoggerVerbosity.Diagnostic)
                     {
                         string equivalentCommandLine = commandLineSwitches.GetEquivalentCommandLineExceptProjectFile();
                         Console.WriteLine($"{Path.Combine(s_exePath, s_exeName)} {equivalentCommandLine} {projectFile}");
@@ -3184,6 +3209,7 @@ private static ILogger[] ProcessLoggingSwitches
             string[] verbositySwitchParameters,
             bool noConsoleLogger,
             bool distributedFileLogger,
+            bool fancyLoggerCommandLineOptIn, 
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
@@ -3191,18 +3217,21 @@ private static ILogger[] ProcessLoggingSwitches
             string[][] groupedFileLoggerParameters,
             out List<DistributedLoggerRecord> distributedLoggerRecords,
             out LoggerVerbosity verbosity,
+            out LoggerVerbosity originalVerbosity,
             int cpuCount,
             out ProfilerLogger profilerLogger,
             out bool enableProfiler
         )
         {
             // if verbosity level is not specified, use the default
-            verbosity = LoggerVerbosity.Normal;
+            originalVerbosity = LoggerVerbosity.Normal;
+            verbosity = originalVerbosity;
 
             if (verbositySwitchParameters.Length > 0)
             {
                 // Read the last verbosity switch found
-                verbosity = ProcessVerbositySwitch(verbositySwitchParameters[verbositySwitchParameters.Length - 1]);
+                originalVerbosity = ProcessVerbositySwitch(verbositySwitchParameters[verbositySwitchParameters.Length - 1]);
+                verbosity = originalVerbosity;
             }
 
             var loggers = ProcessLoggerSwitch(loggerSwitchParameters, verbosity);
@@ -3210,7 +3239,15 @@ out bool enableProfiler
             // Add any loggers which have been specified on the commandline
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
-            ProcessConsoleLoggerSwitch(noConsoleLogger, consoleLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
+            // Choose default console logger
+            if ((fancyLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true") && DoesEnvironmentSupportFancyLogger())
+            {
+                ProcessFancyLogger(noConsoleLogger, loggers);
+            }
+            else
+            {
+                ProcessConsoleLoggerSwitch(noConsoleLogger, consoleLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
+            }
 
             ProcessDistributedFileLogger(distributedFileLogger, fileLoggerParameters, distributedLoggerRecords, loggers, cpuCount);
 
@@ -3218,6 +3255,9 @@ out bool enableProfiler
 
             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref verbosity);
 
+            // TOOD: Review
+            // ProcessFancyLogger(noConsoleLogger, loggers);
+
             profilerLogger = ProcessProfileEvaluationSwitch(profileEvaluationParameters, loggers, out enableProfiler);
 
             return loggers.ToArray();
@@ -3380,6 +3420,43 @@ List<ILogger> loggers
             }
         }
 
+        private static bool DoesEnvironmentSupportFancyLogger()
+        {
+            // If output is redirected
+            if (Console.IsOutputRedirected)
+            {
+                messagesToLogInBuildLoggers.Add(
+                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is being redirected to a file.", MessageImportance.Low)
+                );
+                return false;
+            }
+            // If terminal is dumb
+            if (
+                (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && Environment.GetEnvironmentVariable("WT_SESSION") == "")
+                || Environment.GetEnvironmentVariable("TERM") == "dumb"
+            )
+            {
+                messagesToLogInBuildLoggers.Add(
+                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is not supported.", MessageImportance.Low)
+                );
+                return false;
+            }
+            return true;
+        }
+
+        private static void ProcessFancyLogger(
+            bool noConsoleLogger,
+            List<ILogger> loggers
+        )
+        {
+            // Check for flags and env variables
+            if (!noConsoleLogger)
+            {
+                FancyLogger l = new FancyLogger();
+                loggers.Add(l);
+            }
+        }
+
         /// <summary>
         /// Returns a DistributedLoggerRecord containing this logger and a ConfigurableForwardingLogger.
         /// Looks at the logger's parameters for any verbosity parameter in order to make sure it is setting up the ConfigurableForwardingLogger
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 4cdef2986d2..664d8a094c5 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -177,9 +177,11 @@
         <property name="MSBuildFrameworkToolsPath" value="$(SystemRoot)\Microsoft.NET\Framework\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsPath32" value="$(SystemRoot)\Microsoft.NET\Framework\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsPath64" value="$(SystemRoot)\Microsoft.NET\Framework64\v$(MSBuildRuntimeVersion)\" />
+        <property name="MSBuildFrameworkToolsPathArm64" value="$(SystemRoot)\Microsoft.NET\FrameworkArm64\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsRoot" value="$(SystemRoot)\Microsoft.NET\Framework\" />
         <property name="SDK35ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.0A\WinSDK-NetFx35Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
-        <property name="SDK40ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
+        <!-- Attempt to use net4.8.1 if possible, falling back to 4.8 when unavailable. -->
+        <property name="SDK40ToolsPath" value="$([MSBuild]::ValueOrDefault($([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32)), $([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))))" />
         <property name="WindowsSDK80Path" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="VsInstallRoot" value="$([MSBuild]::GetVsInstallRoot())" />
         <property name="MSBuildToolsRoot" value="$(VsInstallRoot)\MSBuild" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 3f412c2716a..8864b5931da 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -147,9 +147,11 @@
         <property name="MSBuildFrameworkToolsPath" value="$(SystemRoot)\Microsoft.NET\Framework\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsPath32" value="$(SystemRoot)\Microsoft.NET\Framework\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsPath64" value="$(SystemRoot)\Microsoft.NET\Framework64\v$(MSBuildRuntimeVersion)\" />
+        <property name="MSBuildFrameworkToolsPathArm64" value="$(SystemRoot)\Microsoft.NET\FrameworkArm64\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsRoot" value="$(SystemRoot)\Microsoft.NET\Framework\" />
         <property name="SDK35ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.0A\WinSDK-NetFx35Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
-        <property name="SDK40ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
+        <!-- Attempt to use net4.8.1 if possible, falling back to 4.8 when unavailable. -->
+        <property name="SDK40ToolsPath" value="$([MSBuild]::ValueOrDefault($([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32)), $([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))))" />
         <property name="WindowsSDK80Path" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="VsInstallRoot" value="$([MSBuild]::GetVsInstallRoot())" />
         <property name="MSBuildToolsRoot" value="$(VsInstallRoot)\MSBuild" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index ec7f04055ae..0628e295bd9 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -62,6 +62,7 @@
       <Link>ITaskItem2.cs</Link>
     </Compile>
     <Compile Include="..\Framework\AssemblyUtilities.cs" />
+    <Compile Include="..\Framework\ResponseFileUsedEventArgs.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index dbdb1d17ad5..9e4f47ac424 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -6,14 +6,16 @@ package name=Microsoft.Build.Arm64
         vs.package.language=neutral
 
 vs.relatedProcessFiles
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\arm64\Microsoft.Build.dll"
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\arm64\Microsoft.Build.Tasks.Core.dll"
 
 folder InstallDir:\MSBuild\Current\Bin\arm64
-  file source=$(Arm64BinPath)MSBuild.exe vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)MSBuild.exe vs.file.ngenArchitecture=arm64
   file source=$(Arm64BinPath)MSBuild.exe.config
 
   file source=$(FrameworkBinPath)x64\Microsoft.Build.Framework.tlb
-  file source=$(Arm64BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)Microsoft.Build.dll vs.file.ngenArchitecture=arm64
+  file source=$(Arm64BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=arm64
   file source=$(Arm64BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(Arm64BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(Arm64BinPath)Microsoft.Common.overridetasks
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index a685938430f..9251c6a3bcf 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -684,9 +684,7 @@ internal static void Trace(int nodeId, string format, params object[] args)
 #if CLR2COMPATIBILITY
                         Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
-                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                            ? DebugUtils.DebugPath
-                            : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                        DebugUtils.DebugPath;
 #endif
 
                     if (String.IsNullOrEmpty(s_debugDumpPath))
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index 3f0b910b267..8752511e6b8 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -47,9 +47,7 @@ private static string GetDebugDumpPath()
 #if CLR2COMPATIBILITY || MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
                         Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
-                ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                    ? DebugUtils.DebugPath
-                    : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                DebugUtils.DebugPath;
 #endif
 
             return !string.IsNullOrEmpty(debugPath)
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 894249cbd64..6edc65786a8 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -24,7 +24,7 @@ private static bool ShouldUseMicrosoftIO
             get
             {
 #if !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-                return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0) && NativeMethodsShared.IsWindows;
+                return NativeMethodsShared.IsWindows;
 #else
                 // We need to mock usage of ChangeWaves class,
                 // because Microsoft.Build.Engine.OM.UnitTests should not have access to internals of Microsoft.Build.Framework.
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 3861a120d79..63025199472 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -61,6 +61,8 @@ internal static void ClearCacheDirectoryPath()
 
         internal static readonly StringComparison PathComparison = GetIsFileSystemCaseSensitive() ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;
 
+        internal static readonly StringComparer PathComparer = GetIsFileSystemCaseSensitive() ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase;
+
         /// <summary>
         /// Determines whether the file system is case sensitive.
         /// Copied from https://github.com/dotnet/runtime/blob/73ba11f3015216b39cb866d9fb7d3d25e93489f2/src/libraries/Common/src/System/IO/PathInternal.CaseSensitivity.cs#L41-L59
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 01ff320cf7d..2105da9a21a 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -61,6 +61,7 @@ internal static class FrameworkLocationHelper
         internal static readonly Version dotNetFrameworkVersion471 = new Version(4, 7, 1);
         internal static readonly Version dotNetFrameworkVersion472 = new Version(4, 7, 2);
         internal static readonly Version dotNetFrameworkVersion48 = new Version(4, 8);
+        internal static readonly Version dotNetFrameworkVersion481 = new Version(4, 8, 1);
 
         // visual studio versions.
         internal static readonly Version visualStudioVersion100 = new Version(10, 0);
@@ -217,6 +218,9 @@ internal static class FrameworkLocationHelper
 
             // v4.8
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion48, visualStudioVersion150),
+
+            // v4.8.1
+            CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion481, visualStudioVersion170),
         };
 
         /// <summary>
@@ -327,6 +331,7 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion471,
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
+                dotNetFrameworkVersion481,
             }),
         });
 
@@ -373,6 +378,18 @@ private static readonly (Version, Version)[,] s_explicitFallbackRulesForPathToDo
             { (dotNetFrameworkVersion471, visualStudioVersion160), (dotNetFrameworkVersion47, visualStudioVersion160) },
             { (dotNetFrameworkVersion472, visualStudioVersion160), (dotNetFrameworkVersion471, visualStudioVersion160) },
             { (dotNetFrameworkVersion48, visualStudioVersion160), (dotNetFrameworkVersion472, visualStudioVersion160) },
+
+            // VS 17
+            { (dotNetFrameworkVersion451, visualStudioVersion170), (dotNetFrameworkVersion45, visualStudioVersion170) },
+            { (dotNetFrameworkVersion452, visualStudioVersion170), (dotNetFrameworkVersion451, visualStudioVersion170) },
+            { (dotNetFrameworkVersion46, visualStudioVersion170), (dotNetFrameworkVersion451, visualStudioVersion170) },
+            { (dotNetFrameworkVersion461, visualStudioVersion170), (dotNetFrameworkVersion46, visualStudioVersion170) },
+            { (dotNetFrameworkVersion462, visualStudioVersion170), (dotNetFrameworkVersion461, visualStudioVersion170) },
+            { (dotNetFrameworkVersion47, visualStudioVersion170), (dotNetFrameworkVersion462, visualStudioVersion170) },
+            { (dotNetFrameworkVersion471, visualStudioVersion170), (dotNetFrameworkVersion47, visualStudioVersion170) },
+            { (dotNetFrameworkVersion472, visualStudioVersion170), (dotNetFrameworkVersion471, visualStudioVersion170) },
+            { (dotNetFrameworkVersion48, visualStudioVersion170), (dotNetFrameworkVersion472, visualStudioVersion170) },
+            { (dotNetFrameworkVersion481, visualStudioVersion170), (dotNetFrameworkVersion48, visualStudioVersion170) },
         };
 #endif // FEATURE_WIN32_REGISTRY
 
@@ -1212,7 +1229,11 @@ public string GetDotNetFrameworkSdkRegistryKey(Version dotNetSdkVersion)
             {
                 string sdkVersionFolder = "4.6"; // Default for back-compat
 
-                if (dotNetSdkVersion == dotNetFrameworkVersion48)
+                if (dotNetSdkVersion == dotNetFrameworkVersion481)
+                {
+                    sdkVersionFolder = "4.8.1";
+                }
+                else if (dotNetSdkVersion == dotNetFrameworkVersion48)
                 {
                     sdkVersionFolder = "4.8";
                 }
@@ -1380,10 +1401,14 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                                     Directory.GetDirectories,
                                     architecture);
 
-                // .net was improperly uninstalled: msbuild.exe isn't there
+                // Assume if either MSBuild.exe or Microsoft.Build.dll are shipped, there is a valid install.
+                // Note: net481 did not ship an ARM64 MSBuild.exe, so checking its dll's is the fallback for a valid install.
+                // Context: https://github.com/dotnet/msbuild/pull/7689
                 if (this._hasMsBuild &&
                     generatedPathToDotNetFramework != null &&
-                    !FileSystems.Default.FileExists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")))
+                    (!FileSystems.Default.FileExists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")) &&
+                     !FileSystems.Default.FileExists(Path.Combine(generatedPathToDotNetFramework, "Microsoft.Build.dll")))
+                    )
                 {
                     return null;
                 }
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 9f625373ed9..7d518897aa6 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -135,6 +135,11 @@ internal enum LoggingEventType : int
         /// Event is an EnvironmentVariableReadEventArgs
         /// </summary>
         EnvironmentVariableReadEvent = 19,
+
+        /// <summary>
+        /// Event is a ResponseFileUsedEventArgs
+        /// </summary>
+        ResponseFileUsedEvent = 20
     }
     #endregion
 
@@ -517,6 +522,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
+                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
                 LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
@@ -619,6 +625,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.EnvironmentVariableReadEvent;
             }
+            else if (eventType == typeof(ResponseFileUsedEventArgs))
+            {
+                return LoggingEventType.ResponseFileUsedEvent;
+            }
             else
             {
                 return LoggingEventType.CustomEvent;
@@ -658,6 +668,9 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.BuildMessageEvent:
                     WriteBuildMessageEventToStream((BuildMessageEventArgs)buildEvent, translator);
                     break;
+                case LoggingEventType.ResponseFileUsedEvent:
+                    WriteResponseFileUsedEventToStream((ResponseFileUsedEventArgs)buildEvent, translator);
+                    break;
                 case LoggingEventType.TaskCommandLineEvent:
                     WriteTaskCommandLineEventToStream((TaskCommandLineEventArgs)buildEvent, translator);
                     break;
@@ -800,6 +813,15 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
             translator.TranslateEnum(ref importance, (int)importance);
         }
 
+        /// <summary>
+        /// Write a response file used log message into the translator
+        /// </summary>
+        private void WriteResponseFileUsedEventToStream(ResponseFileUsedEventArgs responseFileUsedEventArgs, ITranslator translator)
+        {
+            string filePath = responseFileUsedEventArgs.ResponseFilePath;
+            translator.Translate(ref filePath);
+        }
+
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
         private void WriteProjectEvaluationStartedEventToStream(ProjectEvaluationStartedEventArgs args, ITranslator translator)
         {
@@ -1037,6 +1059,7 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
                 LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.ResponseFileUsedEvent => ReadResponseFileUsedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),
                 _ => null,
@@ -1218,6 +1241,14 @@ private BuildMessageEventArgs ReadBuildMessageEventFromStream(ITranslator transl
             return buildEvent;
         }
 
+        private ResponseFileUsedEventArgs ReadResponseFileUsedEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
+        {
+            string responseFilePath = String.Empty;
+            translator.Translate(ref responseFilePath);
+            ResponseFileUsedEventArgs buildEvent = new ResponseFileUsedEventArgs(responseFilePath);
+            return buildEvent;
+        }
+
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
         private ProjectEvaluationStartedEventArgs ReadProjectEvaluationStartedEventFromStream(ITranslator translator)
         {
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index d8102f69f4e..0e0e2913faf 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -77,6 +77,13 @@ internal static string GetNearestPlatform(string referencedProjectPlatform, stri
                     // Platform/PlatformTarget when this is the case.
                     log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
                 }
+                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
+                // If we're about to tell the reference to build using its default platform, don't pass it as a global property.
+                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(buildProjectReferenceAs, StringComparison.OrdinalIgnoreCase))
+                {
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
+                    buildProjectReferenceAs = string.Empty;
+                }
             return buildProjectReferenceAs;
         }
         internal static Dictionary<string, string>? ExtractLookupTable(string stringTable, TaskLoggingHelper? log = null)
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index d9cdca05e73..ff2b4901582 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -923,6 +923,17 @@ public void LogErrorFromException(Exception exception, bool showStackTrace, bool
             // global state.
             ErrorUtilities.VerifyThrowArgumentNull(exception, nameof(exception));
 
+            // For an AggregateException call LogErrorFromException on each inner exception
+            if (exception is AggregateException aggregateException)
+            {
+                foreach (Exception innerException in aggregateException.Flatten().InnerExceptions)
+                {
+                    LogErrorFromException(innerException, showStackTrace, showDetail, file);
+                }
+
+                return;
+            }
+
             string message;
 
             if (!showDetail && (Environment.GetEnvironmentVariable("MSBUILDDIAGNOSTICS") == null)) // This env var is also used in ToolTask
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 3e96ab7c6cb..1111b257726 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -31,32 +31,25 @@ internal static class ToolsetConfigurationReaderHelpers
 
         internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Configuration configuration)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+            if (configuration == null)
             {
-                if (configuration == null)
-                {
-                    return null;
-                }
+                return null;
+            }
 
-                lock (s_syncLock)
+            lock (s_syncLock)
+            {
+                // Cache 1st requested configuration section. In unit tests, different Configuration is provided for particular test cases.
+                // During runtime, however, only MSBuild exe configuration file is provided to read toolset configuration from,
+                //   and modifying MSBuild exe configuration during lifetime of msbuild nodes is neither expected nor supported.
+                if (s_toolsetConfigurationSectionCache == null)
                 {
-                    // Cache 1st requested configuration section. In unit tests, different Configuration is provided for particular test cases.
-                    // During runtime, however, only MSBuild exe configuration file is provided to read toolset configuration from,
-                    //   and modifying MSBuild exe configuration during lifetime of msbuild nodes is neither expected nor supported.
-                    if (s_toolsetConfigurationSectionCache == null)
-                    {
-                        s_toolsetConfigurationSectionCache = GetToolsetConfigurationSection(configuration);
-                        s_configurationOfCachedSection = configuration;
-                    }
-
-                    return s_configurationOfCachedSection == configuration ?
-                        s_toolsetConfigurationSectionCache :
-                        GetToolsetConfigurationSection(configuration);
+                    s_toolsetConfigurationSectionCache = GetToolsetConfigurationSection(configuration);
+                    s_configurationOfCachedSection = configuration;
                 }
-            }
-            else
-            {
-                return GetToolsetConfigurationSection(configuration);
+
+                return s_configurationOfCachedSection == configuration ?
+                    s_toolsetConfigurationSectionCache :
+                    GetToolsetConfigurationSection(configuration);
             }
         }
 
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index e29d3e3a89c..7f6d55178ac 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -1268,27 +1268,6 @@ public void IllegalPaths()
             ValidateIllegal("http://www.website.com");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // Nothing's too long for Unix
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
-        public void IllegalTooLongPathOptOutWave17_0()
-        {
-            using (var env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_0.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string longString = new string('X', 500) + "*"; // need a wildcard to do anything
-                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString).FileList;
-
-                Assert.Equal(longString, result[0]); // Does not throw
-                ChangeWaves.ResetStateForTests();
-            }
-            // Not checking that GetFileSpecMatchInfo returns the illegal-path flag,
-            // not certain that won't break something; this fix is merely to avoid a crash.
-        }
-
         [Fact]
         public void SplitFileSpec()
         {
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index 1dff7e28c37..3f51a4c8233 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -132,7 +132,7 @@ public void TestMergeRuntimeValuesCurrentToCore()
         [Fact]
         public void TestArchitectureValuesMatch()
         {
-            string currentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x64 : XMakeAttributes.MSBuildArchitectureValues.x86;
+            string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
             string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             Assert.True(XMakeAttributes.ArchitectureValuesMatch(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.currentArchitecture));
@@ -147,7 +147,7 @@ public void TestArchitectureValuesMatch()
         [Fact]
         public void TestMergeArchitectureValues()
         {
-            string currentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x64 : XMakeAttributes.MSBuildArchitectureValues.x86;
+            string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
             string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             string mergedArchitecture;
diff --git a/src/StringTools/CompatibilitySuppressions.xml b/src/StringTools/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..b2f2578762f
--- /dev/null
+++ b/src/StringTools/CompatibilitySuppressions.xml
@@ -0,0 +1,8 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <Suppression>
+    <!-- Dropped net35 for 17.5; see https://github.com/dotnet/msbuild/pull/8198 -->
+    <DiagnosticId>PKV006</DiagnosticId>
+    <Target>.NETFramework,Version=v3.5</Target>
+  </Suppression>
+</Suppressions>
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index 88126da5c6f..59da6520dcb 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -34,12 +34,12 @@ namespace Microsoft.NET.StringTools
     /// <remarks>
     /// This is a simple and inefficient implementation compatible with .NET Framework 3.5.
     /// </remarks>
-    internal ref struct InternableString
+    internal struct InternableString
     {
         /// <summary>
         /// Enumerator for the top-level struct. Enumerates characters of the string.
         /// </summary>
-        public ref struct Enumerator
+        public struct Enumerator
         {
             /// <summary>
             /// The InternableString being enumerated.
@@ -51,7 +51,7 @@ public ref struct Enumerator
             /// </summary>
             private int _charIndex;
 
-            public Enumerator(ref InternableString spanBuilder)
+            public Enumerator(InternableString spanBuilder)
             {
                 _string = spanBuilder;
                 _charIndex = -1;
@@ -127,7 +127,7 @@ internal InternableString(SpanBasedStringBuilder builder)
         /// <returns>The enumerator.</returns>
         public Enumerator GetEnumerator()
         {
-            return new Enumerator(ref this);
+            return new Enumerator(this);
         }
 
         /// <summary>
diff --git a/src/StringTools/PublicAPI/net/PublicAPI.Shipped.txt b/src/StringTools/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index 9086e5e2c2a..00000000000
--- a/src/StringTools/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-Microsoft.NET.StringTools.SpanBasedStringBuilder
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string value) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string value, int startIndex, int count) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(System.ReadOnlyMemory<char> span) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Capacity.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Clear() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Dispose() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Current.get -> char
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.MoveNext() -> bool
-Microsoft.NET.StringTools.SpanBasedStringBuilder.GetEnumerator() -> Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Length.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(int capacity = 4) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(string str) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Trim() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimEnd() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimStart() -> void
-Microsoft.NET.StringTools.Strings
-override Microsoft.NET.StringTools.SpanBasedStringBuilder.ToString() -> string
-static Microsoft.NET.StringTools.Strings.CreateDiagnosticReport() -> string
-static Microsoft.NET.StringTools.Strings.EnableDiagnostics() -> void
-static Microsoft.NET.StringTools.Strings.GetSpanBasedStringBuilder() -> Microsoft.NET.StringTools.SpanBasedStringBuilder
-static Microsoft.NET.StringTools.Strings.WeakIntern(string str) -> string
-static Microsoft.NET.StringTools.Strings.WeakIntern(System.ReadOnlySpan<char> str) -> string
\ No newline at end of file
diff --git a/src/StringTools/PublicAPI/net/PublicAPI.Unshipped.txt b/src/StringTools/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/StringTools/PublicAPI/net35/PublicAPI.Shipped.txt b/src/StringTools/PublicAPI/net35/PublicAPI.Shipped.txt
deleted file mode 100644
index e2b05b1bd03..00000000000
--- a/src/StringTools/PublicAPI/net35/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-Microsoft.NET.StringTools.SpanBasedStringBuilder
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Clear() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Dispose() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Current.get -> char
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator(System.Text.StringBuilder builder) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.MoveNext() -> bool
-Microsoft.NET.StringTools.SpanBasedStringBuilder.GetEnumerator() -> Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Length.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(int capacity = 4) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(string str) -> void
-Microsoft.NET.StringTools.Strings
-override Microsoft.NET.StringTools.SpanBasedStringBuilder.ToString() -> string
-static Microsoft.NET.StringTools.Strings.CreateDiagnosticReport() -> string
-static Microsoft.NET.StringTools.Strings.EnableDiagnostics() -> void
-static Microsoft.NET.StringTools.Strings.GetSpanBasedStringBuilder() -> Microsoft.NET.StringTools.SpanBasedStringBuilder
-static Microsoft.NET.StringTools.Strings.WeakIntern(string str) -> string
-static System.MemoryExtensions.AsSpan<T>(this T[] array, int start, int length) -> string
-System.MemoryExtensions
\ No newline at end of file
diff --git a/src/StringTools/PublicAPI/net35/PublicAPI.Unshipped.txt b/src/StringTools/PublicAPI/net35/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/StringTools/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/StringTools/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index 9086e5e2c2a..00000000000
--- a/src/StringTools/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-Microsoft.NET.StringTools.SpanBasedStringBuilder
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string value) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string value, int startIndex, int count) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(System.ReadOnlyMemory<char> span) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Capacity.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Clear() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Dispose() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Current.get -> char
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.MoveNext() -> bool
-Microsoft.NET.StringTools.SpanBasedStringBuilder.GetEnumerator() -> Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Length.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(int capacity = 4) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(string str) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Trim() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimEnd() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimStart() -> void
-Microsoft.NET.StringTools.Strings
-override Microsoft.NET.StringTools.SpanBasedStringBuilder.ToString() -> string
-static Microsoft.NET.StringTools.Strings.CreateDiagnosticReport() -> string
-static Microsoft.NET.StringTools.Strings.EnableDiagnostics() -> void
-static Microsoft.NET.StringTools.Strings.GetSpanBasedStringBuilder() -> Microsoft.NET.StringTools.SpanBasedStringBuilder
-static Microsoft.NET.StringTools.Strings.WeakIntern(string str) -> string
-static Microsoft.NET.StringTools.Strings.WeakIntern(System.ReadOnlySpan<char> str) -> string
\ No newline at end of file
diff --git a/src/StringTools/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/StringTools/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index 60f23ad625f..238bd8a4ca1 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -12,8 +12,16 @@
     <AssemblyVersion>1.0.0.0</AssemblyVersion>
     <SemanticVersioningV1>true</SemanticVersioningV1>
 
+    <EnablePackageValidation>true</EnablePackageValidation>
+
     <AssemblyName>Microsoft.NET.StringTools</AssemblyName>
     <PackageDescription>This package contains the $(AssemblyName) assembly which implements common string-related functionality such as weak interning.</PackageDescription>
+    
+    <IncludeBuildOutput Condition="'$(TargetFramework)' == 'net35'">false</IncludeBuildOutput>
+    <!-- Don't publish the reference assembly if the build output isn't included. -->
+    <TargetsForTfmSpecificBuildOutput Condition="'$(IncludeBuildOutput)' == 'false'" />
+    <!-- NU5128: Add lib or ref assemblies for the net35 target framework. -->
+    <NoWarn>$(NoWarn);NU5128</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
@@ -27,7 +35,7 @@
     <AssemblyName>Microsoft.NET.StringTools.net35</AssemblyName>
   </PropertyGroup>
 
-  <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
+  <ItemGroup Condition="'$(TargetFramework)' != 'net35' AND '$(TargetFrameworkIdentifier)' != '.NETCoreApp'">
     <PackageReference Include="System.Memory" />
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
   </ItemGroup>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 0a520b9f82b..4e9c4f61589 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -14,6 +14,7 @@
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 using Xunit.Abstractions;
 using Shouldly;
+using Microsoft.Build.UnitTests.Shared;
 
 #nullable disable
 
@@ -94,6 +95,24 @@ public Miscellaneous(ITestOutputHelper output) : base(output)
         {
         }
 
+        [Fact]
+        public void VerifyPrimaryReferenceToBadImageDoesNotThrow()
+        {
+            ITaskItem x = new TaskItem(Path.Combine(s_myComponentsRootPath, "X.dll"));
+            ITaskItem xpdb = new TaskItem(Path.Combine(s_myComponentsRootPath, "X.pdb"));
+            ResolveAssemblyReference t = new()
+            {
+                BuildEngine = new MockEngine(),
+                AllowedRelatedFileExtensions = new string[] { ".pdb" },
+                Assemblies = new ITaskItem[] { xpdb },
+                AssemblyFiles = new ITaskItem[] { x },
+                SearchPaths = new string[] { "{RawFileName}" },
+            };
+
+            bool success = Execute(t);
+            success.ShouldBeTrue();
+        }
+
         /// <summary>
         /// Let us have the following dependency structure
         ///
@@ -3373,6 +3392,14 @@ public void ResolveBadImageInPrimary()
 
             // There should have been one warning about the exception.
             Assert.Equal(1, engine.Warnings);
+            engine.AssertLogContains("MSB3246");
+
+            // There should have been no ugly callstack dumped
+            engine.AssertLogDoesntContain("Microsoft.Build.UnitTests");
+
+            // But it should contain the message from the BadImageFormatException, something like
+            //     WARNING MSB3246: Resolved file has a bad image, no metadata, or is otherwise inaccessible. The format of the file 'C:\WINNT\Microsoft.NET\Framework\v2.0.MyVersion\BadImage.dll' is invalid
+            engine.AssertLogContains("'C:\\WINNT\\Microsoft.NET\\Framework\\v2.0.MyVersion\\BadImage.dll'"); // just search for the un-localized part
         }
 
         /// <summary>
@@ -3410,6 +3437,9 @@ public void ResolveBadImageInSecondary()
 
             // There should have been no warning about the exception because it's only a dependency
             Assert.Equal(0, engine.Warnings);
+        
+            // There should have been no ugly callstack dumped
+            engine.AssertLogDoesntContain("Microsoft.Build.UnitTests");
         }
 
         /// <summary>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 2d572ebf1dc..7ca93cd930e 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -546,6 +546,7 @@ internal void StopIOMonitoring()
             Path.Combine(s_myComponentsRootPath, "V.dll"),
             Path.Combine(s_myComponents2RootPath, "W.dll"),
             Path.Combine(s_myComponentsRootPath, "X.dll"),
+            Path.Combine(s_myComponentsRootPath, "X.pdb"),
             Path.Combine(s_myComponentsRootPath, "Y.dll"),
             Path.Combine(s_myComponentsRootPath, "Z.dll"),
 
@@ -1435,6 +1436,12 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "X.pdb"), StringComparison.OrdinalIgnoreCase))
+            {
+                // return new AssemblyNameExtension("X, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
+                throw new BadImageFormatException("X.pdb is a PDB file, not a managed assembly");
+            }
+
             if (String.Equals(path, @"C:\Regress714052\X86\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 293fec51354..c5e6153dcf7 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -7,7 +7,6 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
-using System.Security.Principal;
 using System.Threading;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
@@ -2049,6 +2048,9 @@ public CopyNotHardLink_Tests(ITestOutputHelper testOutputHelper)
 
     public class CopyHardAndSymbolicLink_Tests
     {
+        /// <summary>
+        /// Verify build sucessfully when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true 
+        /// </summary>
         [Fact]
         public void CopyWithHardAndSymbolicLinks()
         {
@@ -2075,10 +2077,9 @@ public void CopyWithHardAndSymbolicLinks()
 
                 bool success = t.Execute();
 
-                Assert.False(success);
-
+                Assert.True(success);
                 MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
-                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.ExactlyOneTypeOfLink", "UseHardlinksIfPossible", "UseSymboliclinksIfPossible");
+                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
             }
             finally
             {
@@ -2397,77 +2398,63 @@ public CopySymbolicLink_Tests(ITestOutputHelper testOutputHelper)
         [Fact]
         public void CopyToDestinationFolderWithSymbolicLinkCheck()
         {
-            var isPrivileged = true;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                if (!new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(new SecurityIdentifier(WellKnownSidType.BuiltinAdministratorsSid, null)))
-                {
-                    isPrivileged = false;
-                    Assert.True(true, "It seems that you don't have the permission to create symbolic links. Try to run this test again with higher privileges");
-                }
-            }
-
-            if (isPrivileged)
+            string sourceFile = FileUtilities.GetTemporaryFile();
+            string temp = Path.GetTempPath();
+            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
+            string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
+            try
             {
-                string sourceFile = FileUtilities.GetTemporaryFile();
-                string temp = Path.GetTempPath();
-                string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
-                string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
-                try
-                {
-                    File.WriteAllText(sourceFile, "This is a source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
-
-                    // Don't create the dest folder, let task do that
+                File.WriteAllText(sourceFile, "This is a source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
 
-                    ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                // Don't create the dest folder, let task do that
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
 
-                    var me = new MockEngine(true);
-                    var t = new Copy
-                    {
-                        RetryDelayMilliseconds = 1,  // speed up tests!
-                        BuildEngine = me,
-                        SourceFiles = sourceFiles,
-                        DestinationFolder = new TaskItem(destFolder),
-                        SkipUnchangedFiles = true,
-                        UseSymboliclinksIfPossible = true
-                    };
+                var me = new MockEngine(true);
+                var t = new Copy
+                {
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = me,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destFolder),
+                    SkipUnchangedFiles = true,
+                    UseSymboliclinksIfPossible = true
+                };
 
-                    bool success = t.Execute();
+                bool success = t.Execute();
 
-                    Assert.True(success); // "success"
-                    Assert.True(File.Exists(destFile)); // "destination exists"
+                Assert.True(success); // "success"
+                Assert.True(File.Exists(destFile)); // "destination exists"
+                Assert.True((File.GetAttributes(destFile) & FileAttributes.ReparsePoint) != 0, "File was copied but is not a symlink");
 
-                    MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
+                MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
 
-                    me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.SymbolicLinkComment", sourceFile, destFile);
+                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.SymbolicLinkComment", sourceFile, destFile);
 
-                    string destinationFileContents = File.ReadAllText(destFile);
-                    Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination symbolic linked file to contain the contents of source file."
+                string destinationFileContents = File.ReadAllText(destFile);
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination symbolic linked file to contain the contents of source file."
 
-                    Assert.Single(t.DestinationFiles);
-                    Assert.Single(t.CopiedFiles);
-                    Assert.Equal(destFile, t.DestinationFiles[0].ItemSpec);
-                    Assert.Equal(destFile, t.CopiedFiles[0].ItemSpec);
+                Assert.Single(t.DestinationFiles);
+                Assert.Single(t.CopiedFiles);
+                Assert.Equal(destFile, t.DestinationFiles[0].ItemSpec);
+                Assert.Equal(destFile, t.CopiedFiles[0].ItemSpec);
 
-                    // Now we will write new content to the source file
-                    // we'll then check that the destination file automatically
-                    // has the same content (i.e. it's been hard linked)
+                // Now we will write new content to the source file
+                // we'll then check that the destination file automatically
+                // has the same content (i.e. it's been hard linked)
 
-                    File.WriteAllText(sourceFile, "This is another source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
+                File.WriteAllText(sourceFile, "This is another source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
 
-                    // Read the destination file (it should have the same modified content as the source)
-                    destinationFileContents = File.ReadAllText(destFile);
-                    Assert.Equal("This is another source temp file.", destinationFileContents); // "Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
+                // Read the destination file (it should have the same modified content as the source)
+                destinationFileContents = File.ReadAllText(destFile);
+                Assert.Equal("This is another source temp file.", destinationFileContents); // "Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
 
-                    ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3891"); // Didn't do retries
-                }
-                finally
-                {
-                    File.Delete(sourceFile);
-                    File.Delete(destFile);
-                    FileUtilities.DeleteWithoutTrailingBackslash(destFolder, true);
-                }
+                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3891"); // Didn't do retries
+            }
+            finally
+            {
+                File.Delete(sourceFile);
+                File.Delete(destFile);
+                FileUtilities.DeleteWithoutTrailingBackslash(destFolder, true);
             }
         }
 
diff --git a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
index 620cb08680b..d65901d9ccb 100644
--- a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
+++ b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
@@ -84,6 +84,28 @@ public void ResolvesViaAnyCPUDefault()
 
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("AnyCPU");
         }
+        
+        [Fact]
+        public void ResolvesViaAnyCPUDefaultWithDefaultPlatformEnabled()
+        {
+            // No valid mapping via the lookup table, should default to AnyCPU when the current project
+            // and ProjectReference platforms don't match.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;AnyCPU");
+            projectReference.SetMetadata("Platform", "AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "AnyCPU=x64", 
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+        }
 
         [Fact]
         public void ResolvesViaSamePlatform()
@@ -226,5 +248,28 @@ public void PlatformIsChosenAsDefault(string referencedPlatforms, string referen
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
             task.Log.HasLoggedErrors.ShouldBeFalse();
         }
+        
+        // When `Platform` is retrieved in "GetTargetFrameworks" and that platform matches what the task has decided the project should be built as
+        // through negotiation. build that project _without_ a global property for Platform.
+        [Fact]
+        public void ChosenPlatformMatchesDefault()
+        {
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "AnyCPU;x64");
+            projectReference.SetMetadata("Platform", "AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "", // invalid format
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            task.Log.HasLoggedErrors.ShouldBeFalse();
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 8003c95c70a..0bcb3ac0fec 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -15,6 +15,7 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Xunit;
+using Shouldly;
 
 #nullable disable
 
@@ -4202,6 +4203,29 @@ public void CheckDefaultingOfTargetConfigAndArchitecture()
             }
         }
 
+        [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        public void VerifyPlatformAliasesWork()
+        {
+            // This verifies that UAP is an alias for windows, so verifying the target platforms align. Other parts of the reference don't matter here.
+            SDKReference reference = new(new TaskItem("sdkReference", new Dictionary<string, string>() { { SDKManifest.Attributes.TargetPlatform, "UAP" } }), "sdkName", "1.0.2");
+            reference.Resolve(
+                new Dictionary<string, ITaskItem>() { { "sdkName, Version=1.0.2", new TaskItem(Path.GetTempFileName(), new Dictionary<string, string>() { { "PlatformVersion", "1.0.2" } }) } },
+                "Release",
+                "x64",
+                new HashSet<string>() { "sdkName" },
+                treatErrorsAsWarnings: false,
+                prefer32Bit: false,
+                "windows",
+                new Version("1.0.2"),
+                "projectName",
+                enableMaxPlatformVersionEmptyWarning: true);
+
+            reference.ResolutionErrors.ShouldBeEmpty();
+            reference.ResolutionWarnings.ShouldBeEmpty();
+            reference.TargetPlatform.ShouldBe("UAP");
+        }
+
         [Fact]
         [PlatformSpecific(TestPlatforms.Windows)]     // No GetResolvedSDKReferences target in Unix
         public void CheckAttributesFromManifestArePassedToResolvedAssemblies()
diff --git a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
index a93ae6fb390..ded433fe021 100644
--- a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
+++ b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
@@ -29,5 +29,10 @@ private BadImageReferenceException(SerializationInfo info, StreamingContext cont
             : base(info, context)
         {
         }
+
+        /// <summary>
+        /// Gets a message that describes the exception.
+        /// </summary>
+        public override string Message => (InnerException == null) ? base.Message : $"{base.Message} {InnerException.Message}";
     }
 }
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index e6f506668e7..97d6ab34104 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -72,6 +72,11 @@ internal enum CopyLocalState
         /// The property copyLocalDependenciesWhenParentReferenceInGac is set to false and all the parent source items were found in the GAC.
         /// </summary>
         NoBecauseParentReferencesFoundInGAC,
+
+        /// <summary>
+        /// The "assembly" should not be copied because it is a bad image—possibly not managed, possibly not an assembly at all.
+        /// </summary>
+        NoBecauseBadImage,
     }
 
     /// <remarks>
@@ -98,6 +103,7 @@ internal static bool IsCopyLocal(CopyLocalState state)
                 case CopyLocalState.NoBecauseReferenceFoundInGAC:
                 case CopyLocalState.NoBecauseEmbedded:
                 case CopyLocalState.NoBecauseParentReferencesFoundInGAC:
+                case CopyLocalState.NoBecauseBadImage:
                     return false;
                 default:
                     throw new InternalErrorException("Unexpected CopyLocal flag.");
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index db5d30bda9d..9ad4a1f1bdb 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -969,6 +969,12 @@ internal void SetFinalCopyLocalState
             ReferenceTable referenceTable
         )
         {
+            if (IsBadImage)
+            {
+                CopyLocal = CopyLocalState.NoBecauseBadImage;
+                return;
+            }
+
             // If this item was unresolvable, then copy-local is false.
             if (IsUnresolvable)
             {
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 4cb1e0d2a63..8408c19de17 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -409,7 +409,7 @@ internal void AddReference(AssemblyNameExtension assemblyName, Reference referen
                 }
             }
 
-            if (reference.FullPath.Length > 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+            if (reference.FullPath.Length > 0)
             {
                 // Saves effort and makes deduplication possible downstream
                 reference.NormalizeFullPath();
@@ -1340,16 +1340,7 @@ out userRequestedSpecificFile
             // If the path was resolved, then specify the full path on the reference.
             if (resolvedPath != null)
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-                {
-                    resolvedPath = FileUtilities.NormalizePath(resolvedPath);
-                }
-                else if (!Path.IsPathRooted(resolvedPath))
-                {
-                    resolvedPath = Path.GetFullPath(resolvedPath);
-                }
-
-                reference.FullPath = resolvedPath;
+                reference.FullPath = FileUtilities.NormalizePath(resolvedPath);
                 reference.ResolvedSearchPath = resolvedSearchPath;
                 reference.UserRequestedSpecificFile = userRequestedSpecificFile;
             }
@@ -2628,49 +2619,51 @@ out ITaskItem[] copyLocalFiles
                 AssemblyNameExtension assemblyName = kvp.Key;
                 Reference reference = kvp.Value;
 
+                reference.SetFinalCopyLocalState
+                (
+                    assemblyName,
+                    _frameworkPaths,
+                    _targetProcessorArchitecture,
+                    _getRuntimeVersion,
+                    _targetedRuntimeVersion,
+                    _fileExists,
+                    _getAssemblyPathInGac,
+                    _copyLocalDependenciesWhenParentReferenceInGac,
+                    _doNotCopyLocalIfInGac,
+                    this
+                );
+
                 // Conflict victims and badimages are filtered out.
-                if (!reference.IsBadImage)
+                if (reference.IsBadImage)
                 {
-                    reference.SetFinalCopyLocalState
-                    (
-                        assemblyName,
-                        _frameworkPaths,
-                        _targetProcessorArchitecture,
-                        _getRuntimeVersion,
-                        _targetedRuntimeVersion,
-                        _fileExists,
-                        _getAssemblyPathInGac,
-                        _copyLocalDependenciesWhenParentReferenceInGac,
-                        _doNotCopyLocalIfInGac,
-                        this
-                    );
+                    continue;
+                }
 
-                    // If mscorlib was found as a dependency and not a primary reference we will assume that mscorlib on the target machine will be ok to use.
-                    // If mscorlib was a primary reference then we may have resolved one which is a differnt version that is on the target
-                    // machine and we should gather it along with the other references.
-                    if (!reference.IsPrimary && IsPseudoAssembly(assemblyName.Name))
-                    {
-                        continue;
-                    }
+                // If mscorlib was found as a dependency and not a primary reference we will assume that mscorlib on the target machine will be ok to use.
+                // If mscorlib was a primary reference then we may have resolved one which is a differnt version that is on the target
+                // machine and we should gather it along with the other references.
+                if (!reference.IsPrimary && IsPseudoAssembly(assemblyName.Name))
+                {
+                    continue;
+                }
 
-                    if (reference.IsResolved)
-                    {
-                        ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, assemblyName.FullName, reference, assemblyName);
+                if (reference.IsResolved)
+                {
+                    ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, assemblyName.FullName, reference, assemblyName);
 
-                        if (reference.IsPrimary)
-                        {
-                            if (!reference.IsBadImage)
-                            {
-                                // Add a primary item.
-                                primaryItems.Add(referenceItem);
-                            }
-                        }
-                        else
+                    if (reference.IsPrimary)
+                    {
+                        if (!reference.IsBadImage)
                         {
-                            // Add the reference item.
-                            dependencyItems.Add(referenceItem);
+                            // Add a primary item.
+                            primaryItems.Add(referenceItem);
                         }
                     }
+                    else
+                    {
+                        // Add the reference item.
+                        dependencyItems.Add(referenceItem);
+                    }
                 }
             }
 
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 706749d4953..d943ca958c1 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -83,6 +83,7 @@ private static class Strings
             public static string LogAttributeFormat;
             public static string LogTaskPropertyFormat;
             public static string NoBecauseParentReferencesFoundInGac;
+            public static string NoBecauseBadImage;
             public static string NotCopyLocalBecauseConflictVictim;
             public static string NotCopyLocalBecauseEmbedded;
             public static string NotCopyLocalBecauseFrameworksFiles;
@@ -132,6 +133,7 @@ internal static void Initialize(TaskLoggingHelper log)
                 IsAWinMdFile = GetResourceFourSpaces("ResolveAssemblyReference.IsAWinMdFile");
                 LogAttributeFormat = GetResourceEightSpaces("ResolveAssemblyReference.LogAttributeFormat");
                 LogTaskPropertyFormat = GetResource("ResolveAssemblyReference.LogTaskPropertyFormat");
+                NoBecauseBadImage = GetResourceFourSpaces("ResolveAssemblyReference.NoBecauseBadImage");
                 NoBecauseParentReferencesFoundInGac = GetResourceFourSpaces("ResolveAssemblyReference.NoBecauseParentReferencesFoundInGac");
                 NotCopyLocalBecauseConflictVictim = GetResourceFourSpaces("ResolveAssemblyReference.NotCopyLocalBecauseConflictVictim");
                 NotCopyLocalBecauseEmbedded = GetResourceFourSpaces("ResolveAssemblyReference.NotCopyLocalBecauseEmbedded");
@@ -1689,7 +1691,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
                 }
                 else if (itemError is BadImageReferenceException)
                 {
-                    message = Log.FormatResourceString("ResolveAssemblyReference.FailedWithException", itemError.InnerException?.ToString() ?? itemError.ToString());
+                    message = Log.FormatResourceString("ResolveAssemblyReference.FailedWithException", itemError.Message);
                     helpKeyword = "MSBuild.ResolveAssemblyReference.FailedWithException";
                     dependencyProblem = false;
                 }
@@ -1940,6 +1942,10 @@ private void LogCopyLocalState(Reference reference, MessageImportance importance
                         Log.LogMessage(importance, Strings.NoBecauseParentReferencesFoundInGac);
                         break;
 
+                    case CopyLocalState.NoBecauseBadImage:
+                        Log.LogMessage(importance, Strings.NoBecauseBadImage);
+                        break;
+
                     default:
                         Debug.Assert(false, "Should have handled this case.");
                         break;
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..1314aae19e3
--- /dev/null
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -0,0 +1,67 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <Suppression>
+    <!-- For ease of logging the "not supported on Core" message, this task is a
+         TaskExtension on netstandard/netcore. Since the type is sealed there,
+         that shouldn't cause any implementation problems since no one can derive
+         from it and try to call TaskExtension.Log. -->
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.ResolveComReference</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+
+  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
+       This is intentional, because you can only use MSBuild in the context of a .NET SDK
+       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
+       have previously shipped netstandard2.0 packages, and if you want to support both
+       runtime contexts it still makes sense to target that. -->
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETCoreApp,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.1</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.2</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.3</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETStandard,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Tizen,Version=v4.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>UAP,Version=v10.0.15064</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation3,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation4,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStationVita,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.Xbox360,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.XboxOne,Version=v0.0</Target>
+  </Suppression>
+</Suppressions>
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 45a3a11ae8d..48e28ca03dc 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -58,6 +58,7 @@ public Copy()
                 FileComment = Log.GetResourceMessage("Copy.FileComment");
                 HardLinkComment = Log.GetResourceMessage("Copy.HardLinkComment");
                 RetryingAsFileCopy = Log.GetResourceMessage("Copy.RetryingAsFileCopy");
+                RetryingAsSymbolicLink = Log.GetResourceMessage("Copy.RetryingAsSymbolicLink");
                 RemovingReadOnlyAttribute = Log.GetResourceMessage("Copy.RemovingReadOnlyAttribute");
                 SymbolicLinkComment = Log.GetResourceMessage("Copy.SymbolicLinkComment");
             }
@@ -68,6 +69,7 @@ public Copy()
         private static string FileComment;
         private static string HardLinkComment;
         private static string RetryingAsFileCopy;
+        private static string RetryingAsSymbolicLink;
         private static string RemovingReadOnlyAttribute;
         private static string SymbolicLinkComment;
 
@@ -274,20 +276,39 @@ FileState destinationFileState  // The destination file
                 destinationFileExists = destinationFileState.FileExists;
             }
 
-            bool linkCreated = false;
+            bool symbolicLinkCreated = false;
+            bool hardLinkCreated = false;
             string errorMessage = string.Empty;
 
-            // If we want to create hard or symbolic links, then try that first
+            // Create hard links if UseHardlinksIfPossible is true
             if (UseHardlinksIfPossible)
             {
-                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out linkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage));
+                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out hardLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage));
+                if(!hardLinkCreated)
+                {
+                    if(UseSymboliclinksIfPossible)
+                    {
+                        // This is a message for fallback to SymbolicLinks if HardLinks fail when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true
+                        Log.LogMessage(MessageImportance.Normal, RetryingAsSymbolicLink, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                    }
+                    else
+                    {
+                        Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                    }
+                }
             }
-            else if (UseSymboliclinksIfPossible)
+
+            // Create symbolic link if UseSymboliclinksIfPossible is true and hard link is not created
+            if (!hardLinkCreated && UseSymboliclinksIfPossible)
             {
-                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out linkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeSymbolicLink(destination, source, ref errorMessage));
+                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out symbolicLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethodsShared.MakeSymbolicLink(destination, source, ref errorMessage));
+                if(!symbolicLinkCreated)
+                {
+                    Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                }
             }
 
-            if (ErrorIfLinkFails && !linkCreated)
+            if (ErrorIfLinkFails && !hardLinkCreated && !symbolicLinkCreated)
             {
                 Log.LogErrorWithCodeFromResources("Copy.LinkFailed", sourceFileState.Name, destinationFileState.Name);
                 return false;
@@ -295,7 +316,7 @@ FileState destinationFileState  // The destination file
 
             // If the link was not created (either because the user didn't want one, or because it couldn't be created)
             // then let's copy the file
-            if (!linkCreated)
+            if (!hardLinkCreated && !symbolicLinkCreated)
             {
                 // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
                 string sourceFilePath = FileUtilities.GetFullPathNoThrow(sourceFileState.Name);
@@ -339,12 +360,6 @@ private void TryCopyViaLink(string linkComment, MessageImportance messageImporta
             }
 
             linkCreated = createLink(sourceFileState.Name, destinationFileState.Name, errorMessage);
-
-            if (!linkCreated)
-            {
-                // This is only a message since we don't want warnings when copying to network shares etc.
-                Log.LogMessage(messageImportance, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
-            }
         }
 
         /// <summary>
@@ -653,12 +668,6 @@ private bool ValidateInputs()
                 return false;
             }
 
-            // First check if create hard or symbolic link option is selected. If both then return an error
-            if (UseHardlinksIfPossible & UseSymboliclinksIfPossible)
-            {
-                Log.LogErrorWithCodeFromResources("Copy.ExactlyOneTypeOfLink", "UseHardlinksIfPossible", "UseSymboliclinksIfPossible");
-                return false;
-            }
 
             if (ErrorIfLinkFails && !UseHardlinksIfPossible && !UseSymboliclinksIfPossible)
             {
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 87e92685ed8..2dde971a9c7 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -905,24 +905,29 @@ public override bool Execute()
             return !Log.HasLoggedErrors && outOfProcExecutionSucceeded;
         }
 
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
         private static readonly bool AllowMOTW = !NativeMethodsShared.IsWindows || (Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\SDK", "AllowProcessOfUntrustedResourceFiles", null) is string allowUntrustedFiles && allowUntrustedFiles.Equals("true", StringComparison.OrdinalIgnoreCase));
 
         private const string CLSID_InternetSecurityManager = "7b8a2d94-0ac9-11d1-896c-00c04fb6bfc4";
         private const uint ZoneInternet = 3;
         private static IInternetSecurityManager internetSecurityManager = null;
+#endif
 
         // Resources can have arbitrarily serialized objects in them which can execute arbitrary code
         // so check to see if we should trust them before analyzing them
         private bool IsDangerous(String filename)
         {
+#if !FEATURE_RESXREADER_LIVEDESERIALIZATION
+            return false;
+        }
+#else
             // If they are opted out, there's no work to do
-            if (AllowMOTW || !NativeMethodsShared.IsWindows)
+            if (AllowMOTW)
             {
                 return false;
             }
 
             // First check the zone, if they are not an untrusted zone, they aren't dangerous
-
             if (internetSecurityManager == null)
             {
                 Type iismType = Type.GetTypeFromCLSID(new Guid(CLSID_InternetSecurityManager));
@@ -989,7 +994,6 @@ private bool IsDangerous(String filename)
             return dangerous;
         }
 
-#if FEATURE_APPDOMAIN
         /// <summary>
         /// For setting OutputResources and ensuring it can be read after the second AppDomain has been unloaded.
         /// </summary>
@@ -1974,7 +1978,6 @@ private bool NeedSeparateAppDomainBasedOnSerializedType(XmlReader reader)
             // Return true to err on the side of caution. Error will appear later.
             return true;
         }
-#endif
 
         /// <summary>
         /// Deserializes a base64 block from a resx in order to figure out if its type is in the GAC.
@@ -1995,6 +1998,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
                 return result != null;
             }
         }
+#endif
 
         /// <summary>
         /// Chars that should be ignored in the nicely justified block of base64
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 6421d98c638..972776ac9e0 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -16,6 +16,7 @@
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which implements the commonly used tasks of MSBuild.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">full</ApplyNgenOptimization>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 7ea9782cedb..0ff4125961f 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -514,12 +514,6 @@ internal struct PROCESS_INFORMATION
         public int dwThreadId;
     }
 
-    internal enum SymbolicLink
-    {
-        File = 0,
-        Directory = 1
-    }
-
     /// <summary>
     /// Interop methods.
     /// </summary>
@@ -818,33 +812,6 @@ internal static bool MakeHardLink(string newFileName, string exitingFileName, re
             return hardLinkCreated;
         }
 
-        //------------------------------------------------------------------------------
-        // CreateSymbolicLink
-        //------------------------------------------------------------------------------
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
-        [return: MarshalAs(UnmanagedType.I1)]
-        internal static extern bool CreateSymbolicLink(string symLinkFileName, string targetFileName, SymbolicLink dwFlags);
-
-        [DllImport("libc", SetLastError = true)]
-        internal static extern int symlink(string oldpath, string newpath);
-
-        internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)
-        {
-            bool symbolicLinkCreated;
-            if (NativeMethodsShared.IsWindows)
-            {
-                symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, SymbolicLink.File);
-                errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
-            }
-            else
-            {
-                symbolicLinkCreated = symlink(exitingFileName, newFileName) == 0;
-                errorMessage = symbolicLinkCreated ? null : "The link() library call failed with the following error code: " + Marshal.GetLastWin32Error();
-            }
-
-            return symbolicLinkCreated;
-        }
-
         //------------------------------------------------------------------------------
         // MoveFileEx
         //------------------------------------------------------------------------------
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index 1cc4f59b5e8..00000000000
--- a/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,2429 +0,0 @@
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.IsSourceFile(string fileName) -> bool
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.SourceFileExtension.get -> string
-abstract Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SortName.get -> string
-abstract Microsoft.Build.Tasks.GenerateManifestBase.GetObjectType() -> System.Type
-abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
-abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
-Microsoft.Build.Tasks.AL
-Microsoft.Build.Tasks.AL.AL() -> void
-Microsoft.Build.Tasks.AL.AlgorithmId.get -> string
-Microsoft.Build.Tasks.AL.AlgorithmId.set -> void
-Microsoft.Build.Tasks.AL.BaseAddress.get -> string
-Microsoft.Build.Tasks.AL.BaseAddress.set -> void
-Microsoft.Build.Tasks.AL.CompanyName.get -> string
-Microsoft.Build.Tasks.AL.CompanyName.set -> void
-Microsoft.Build.Tasks.AL.Configuration.get -> string
-Microsoft.Build.Tasks.AL.Configuration.set -> void
-Microsoft.Build.Tasks.AL.Copyright.get -> string
-Microsoft.Build.Tasks.AL.Copyright.set -> void
-Microsoft.Build.Tasks.AL.Culture.get -> string
-Microsoft.Build.Tasks.AL.Culture.set -> void
-Microsoft.Build.Tasks.AL.DelaySign.get -> bool
-Microsoft.Build.Tasks.AL.DelaySign.set -> void
-Microsoft.Build.Tasks.AL.Description.get -> string
-Microsoft.Build.Tasks.AL.Description.set -> void
-Microsoft.Build.Tasks.AL.EmbedResources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AL.EmbedResources.set -> void
-Microsoft.Build.Tasks.AL.EvidenceFile.get -> string
-Microsoft.Build.Tasks.AL.EvidenceFile.set -> void
-Microsoft.Build.Tasks.AL.FileVersion.get -> string
-Microsoft.Build.Tasks.AL.FileVersion.set -> void
-Microsoft.Build.Tasks.AL.Flags.get -> string
-Microsoft.Build.Tasks.AL.Flags.set -> void
-Microsoft.Build.Tasks.AL.GenerateFullPaths.get -> bool
-Microsoft.Build.Tasks.AL.GenerateFullPaths.set -> void
-Microsoft.Build.Tasks.AL.KeyContainer.get -> string
-Microsoft.Build.Tasks.AL.KeyContainer.set -> void
-Microsoft.Build.Tasks.AL.KeyFile.get -> string
-Microsoft.Build.Tasks.AL.KeyFile.set -> void
-Microsoft.Build.Tasks.AL.LinkResources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AL.LinkResources.set -> void
-Microsoft.Build.Tasks.AL.MainEntryPoint.get -> string
-Microsoft.Build.Tasks.AL.MainEntryPoint.set -> void
-Microsoft.Build.Tasks.AL.OutputAssembly.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.AL.OutputAssembly.set -> void
-Microsoft.Build.Tasks.AL.Platform.get -> string
-Microsoft.Build.Tasks.AL.Platform.set -> void
-Microsoft.Build.Tasks.AL.Prefer32Bit.get -> bool
-Microsoft.Build.Tasks.AL.Prefer32Bit.set -> void
-Microsoft.Build.Tasks.AL.ProductName.get -> string
-Microsoft.Build.Tasks.AL.ProductName.set -> void
-Microsoft.Build.Tasks.AL.ProductVersion.get -> string
-Microsoft.Build.Tasks.AL.ProductVersion.set -> void
-Microsoft.Build.Tasks.AL.ResponseFiles.get -> string[]
-Microsoft.Build.Tasks.AL.ResponseFiles.set -> void
-Microsoft.Build.Tasks.AL.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.AL.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.AL.SourceModules.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AL.SourceModules.set -> void
-Microsoft.Build.Tasks.AL.TargetType.get -> string
-Microsoft.Build.Tasks.AL.TargetType.set -> void
-Microsoft.Build.Tasks.AL.TemplateFile.get -> string
-Microsoft.Build.Tasks.AL.TemplateFile.set -> void
-Microsoft.Build.Tasks.AL.Title.get -> string
-Microsoft.Build.Tasks.AL.Title.set -> void
-Microsoft.Build.Tasks.AL.Trademark.get -> string
-Microsoft.Build.Tasks.AL.Trademark.set -> void
-Microsoft.Build.Tasks.AL.Version.get -> string
-Microsoft.Build.Tasks.AL.Version.set -> void
-Microsoft.Build.Tasks.AL.Win32Icon.get -> string
-Microsoft.Build.Tasks.AL.Win32Icon.set -> void
-Microsoft.Build.Tasks.AL.Win32Resource.get -> string
-Microsoft.Build.Tasks.AL.Win32Resource.set -> void
-Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension
-Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.AspNetCompiler
-Microsoft.Build.Tasks.AspNetCompiler.AllowPartiallyTrustedCallers.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.AllowPartiallyTrustedCallers.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.AspNetCompiler() -> void
-Microsoft.Build.Tasks.AspNetCompiler.Clean.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.Clean.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.Debug.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.Debug.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.DelaySign.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.DelaySign.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.FixedNames.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.FixedNames.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.Force.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.Force.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.KeyContainer.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.KeyContainer.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.KeyFile.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.KeyFile.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.MetabasePath.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.MetabasePath.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.PhysicalPath.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.PhysicalPath.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.TargetPath.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.TargetPath.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.Updateable.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.Updateable.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.VirtualPath.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.VirtualPath.set -> void
-Microsoft.Build.Tasks.AssignCulture
-Microsoft.Build.Tasks.AssignCulture.AssignCulture() -> void
-Microsoft.Build.Tasks.AssignCulture.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithCulture.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithNoCulture.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.CultureNeutralAssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.Files.set -> void
-Microsoft.Build.Tasks.AssignLinkMetadata
-Microsoft.Build.Tasks.AssignLinkMetadata.AssignLinkMetadata() -> void
-Microsoft.Build.Tasks.AssignLinkMetadata.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignLinkMetadata.Items.set -> void
-Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration
-Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignProjectConfiguration() -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.set -> void
-Microsoft.Build.Tasks.AssignTargetPath
-Microsoft.Build.Tasks.AssignTargetPath.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignTargetPath.AssignTargetPath() -> void
-Microsoft.Build.Tasks.AssignTargetPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignTargetPath.Files.set -> void
-Microsoft.Build.Tasks.AssignTargetPath.RootFolder.get -> string
-Microsoft.Build.Tasks.AssignTargetPath.RootFolder.set -> void
-Microsoft.Build.Tasks.CallTarget
-Microsoft.Build.Tasks.CallTarget.CallTarget() -> void
-Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.get -> bool
-Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.set -> void
-Microsoft.Build.Tasks.CallTarget.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CallTarget.Targets.get -> string[]
-Microsoft.Build.Tasks.CallTarget.Targets.set -> void
-Microsoft.Build.Tasks.CallTarget.UseResultsCache.get -> bool
-Microsoft.Build.Tasks.CallTarget.UseResultsCache.set -> void
-Microsoft.Build.Tasks.CodeTaskFactory
-Microsoft.Build.Tasks.CodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.CodeTaskFactory.CodeTaskFactory() -> void
-Microsoft.Build.Tasks.CodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine loggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.CodeTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.CodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.CodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.CodeTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.CombinePath
-Microsoft.Build.Tasks.CombinePath.BasePath.get -> string
-Microsoft.Build.Tasks.CombinePath.BasePath.set -> void
-Microsoft.Build.Tasks.CombinePath.CombinedPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombinePath.CombinedPaths.set -> void
-Microsoft.Build.Tasks.CombinePath.CombinePath() -> void
-Microsoft.Build.Tasks.CombinePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombinePath.Paths.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.CombineTargetFrameworkInfoProperties() -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.get -> string
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.get -> string
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.get -> bool
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.set -> void
-Microsoft.Build.Tasks.CombineXmlElements
-Microsoft.Build.Tasks.CombineXmlElements.CombineXmlElements() -> void
-Microsoft.Build.Tasks.CombineXmlElements.Result.get -> string
-Microsoft.Build.Tasks.CombineXmlElements.Result.set -> void
-Microsoft.Build.Tasks.CombineXmlElements.RootElementName.get -> string
-Microsoft.Build.Tasks.CombineXmlElements.RootElementName.set -> void
-Microsoft.Build.Tasks.CombineXmlElements.XmlElements.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombineXmlElements.XmlElements.set -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension
-Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension() -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension.GetQuotedText(string unquotedText) -> string
-Microsoft.Build.Tasks.ConvertToAbsolutePath
-Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.set -> void
-Microsoft.Build.Tasks.ConvertToAbsolutePath.ConvertToAbsolutePath() -> void
-Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.set -> void
-Microsoft.Build.Tasks.Copy
-Microsoft.Build.Tasks.Copy.Cancel() -> void
-Microsoft.Build.Tasks.Copy.CopiedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.Copy() -> void
-Microsoft.Build.Tasks.Copy.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.DestinationFiles.set -> void
-Microsoft.Build.Tasks.Copy.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Copy.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.get -> bool
-Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.set -> void
-Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Copy.Retries.get -> int
-Microsoft.Build.Tasks.Copy.Retries.set -> void
-Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.get -> int
-Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.set -> void
-Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.Copy.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.SourceFiles.set -> void
-Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.get -> bool
-Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.set -> void
-Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.get -> bool
-Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.set -> void
-Microsoft.Build.Tasks.Copy.WroteAtLeastOneFile.get -> bool
-Microsoft.Build.Tasks.CreateCSharpManifestResourceName
-Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateCSharpManifestResourceName() -> void
-Microsoft.Build.Tasks.CreateItem
-Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.get -> string[]
-Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.set -> void
-Microsoft.Build.Tasks.CreateItem.CreateItem() -> void
-Microsoft.Build.Tasks.CreateItem.Exclude.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateItem.Exclude.set -> void
-Microsoft.Build.Tasks.CreateItem.Include.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateItem.Include.set -> void
-Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.get -> bool
-Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName
-Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestResourceName() -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.itemSpecToTaskitem -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem>
-Microsoft.Build.Tasks.CreateManifestResourceName.ManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.get -> bool
-Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.get -> string
-Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.get -> bool
-Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.set -> void
-Microsoft.Build.Tasks.CreateProperty
-Microsoft.Build.Tasks.CreateProperty.CreateProperty() -> void
-Microsoft.Build.Tasks.CreateProperty.Value.get -> string[]
-Microsoft.Build.Tasks.CreateProperty.Value.set -> void
-Microsoft.Build.Tasks.CreateProperty.ValueSetByTask.get -> string[]
-Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName
-Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateVisualBasicManifestResourceName() -> void
-Microsoft.Build.Tasks.Delete
-Microsoft.Build.Tasks.Delete.Cancel() -> void
-Microsoft.Build.Tasks.Delete.Delete() -> void
-Microsoft.Build.Tasks.Delete.DeletedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Delete.DeletedFiles.set -> void
-Microsoft.Build.Tasks.Delete.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Delete.Files.set -> void
-Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.get -> bool
-Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder(string visualStudioVersion) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpId.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Message.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Error = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Info = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Warning = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.ComponentFiles.get -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.KeyFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Succeeded.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.BuildSettings() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Absolute = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.HomeSite = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Relative = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpId.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Message.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.ComponentFiles.get -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.KeyFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Succeeded.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Name.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductCode.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Name.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Product() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductCode.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest(string targetFrameworkVersion) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.FileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.All = Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture | Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Default = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsFrameworkAssembly.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsInFramework(string frameworkIdentifier, string frameworkVersion) -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsNeutralPlatform.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsStrongName.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.AssemblyManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.ExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(string name) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ClickOnceManifest = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ManagedAssembly = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.NativeAssembly = 3 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.Unspecified = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.get -> long
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ClsId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ComClass() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ThreadingModel.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.CompatibleFramework() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest(string targetFrameworkMoniker) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.FileAssociation() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.TypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.Build(string filename, string outputPath) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherBuilder(string launcherPath) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.FileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.get -> System.IO.Stream
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Manifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.OutputMessages.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles(string[] searchPaths) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo(string targetFrameworkVersion) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ValidatePlatform() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.GetArguments() -> string[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Text.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Type.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.ErrorCount.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.WarningCount.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Error = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Info = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Warning = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.BaseInterface.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.IID.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.NumMethods.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.ProxyStub() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.HasUnmanagedCodePermission.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PermissionSet.get -> System.Security.PermissionSet
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PermissionSet.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(System.IO.Stream input) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(System.IO.Stream input) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.TrustInfo() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream input, System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Flags.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.HelpDirectory.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.ResourceId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TypeLib() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Background = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Foreground = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Days = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Hours = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Weeks = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Versioned.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass(string name, bool versioned) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.set -> void
-Microsoft.Build.Tasks.DownloadFile
-Microsoft.Build.Tasks.DownloadFile.Cancel() -> void
-Microsoft.Build.Tasks.DownloadFile.DestinationFileName.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DestinationFileName.set -> void
-Microsoft.Build.Tasks.DownloadFile.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DestinationFolder.set -> void
-Microsoft.Build.Tasks.DownloadFile.DownloadedFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DownloadedFile.set -> void
-Microsoft.Build.Tasks.DownloadFile.DownloadFile() -> void
-Microsoft.Build.Tasks.DownloadFile.Retries.get -> int
-Microsoft.Build.Tasks.DownloadFile.Retries.set -> void
-Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.get -> int
-Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.set -> void
-Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
-Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
-Microsoft.Build.Tasks.DownloadFile.Timeout.get -> int
-Microsoft.Build.Tasks.DownloadFile.Timeout.set -> void
-Microsoft.Build.Tasks.Error
-Microsoft.Build.Tasks.Error.Code.get -> string
-Microsoft.Build.Tasks.Error.Code.set -> void
-Microsoft.Build.Tasks.Error.Error() -> void
-Microsoft.Build.Tasks.Error.File.get -> string
-Microsoft.Build.Tasks.Error.File.set -> void
-Microsoft.Build.Tasks.Error.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Error.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Error.HelpLink.get -> string
-Microsoft.Build.Tasks.Error.HelpLink.set -> void
-Microsoft.Build.Tasks.Error.Text.get -> string
-Microsoft.Build.Tasks.Error.Text.set -> void
-Microsoft.Build.Tasks.ErrorFromResources
-Microsoft.Build.Tasks.ErrorFromResources.Arguments.get -> string[]
-Microsoft.Build.Tasks.ErrorFromResources.Arguments.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.Code.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.Code.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.ErrorFromResources() -> void
-Microsoft.Build.Tasks.ErrorFromResources.File.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.File.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.Resource.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.Resource.set -> void
-Microsoft.Build.Tasks.Exec
-Microsoft.Build.Tasks.Exec.Command.get -> string
-Microsoft.Build.Tasks.Exec.Command.set -> void
-Microsoft.Build.Tasks.Exec.ConsoleOutput.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.get -> bool
-Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.set -> void
-Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.get -> string
-Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.set -> void
-Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.get -> string
-Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.set -> void
-Microsoft.Build.Tasks.Exec.Exec() -> void
-Microsoft.Build.Tasks.Exec.IgnoreExitCode.get -> bool
-Microsoft.Build.Tasks.Exec.IgnoreExitCode.set -> void
-Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.get -> bool
-Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.set -> void
-Microsoft.Build.Tasks.Exec.Outputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Exec.Outputs.set -> void
-Microsoft.Build.Tasks.Exec.StdErrEncoding.get -> string
-Microsoft.Build.Tasks.Exec.StdErrEncoding.set -> void
-Microsoft.Build.Tasks.Exec.StdOutEncoding.get -> string
-Microsoft.Build.Tasks.Exec.StdOutEncoding.set -> void
-Microsoft.Build.Tasks.Exec.WorkingDirectory.get -> string
-Microsoft.Build.Tasks.Exec.WorkingDirectory.set -> void
-Microsoft.Build.Tasks.ExtractedClassName
-Microsoft.Build.Tasks.ExtractedClassName.ExtractedClassName() -> void
-Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.get -> bool
-Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.set -> void
-Microsoft.Build.Tasks.ExtractedClassName.Name.get -> string
-Microsoft.Build.Tasks.ExtractedClassName.Name.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile
-Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.FindAppConfigFile() -> void
-Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.get -> string
-Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.set -> void
-Microsoft.Build.Tasks.FindInList
-Microsoft.Build.Tasks.FindInList.CaseSensitive.get -> bool
-Microsoft.Build.Tasks.FindInList.CaseSensitive.set -> void
-Microsoft.Build.Tasks.FindInList.FindInList() -> void
-Microsoft.Build.Tasks.FindInList.FindLastMatch.get -> bool
-Microsoft.Build.Tasks.FindInList.FindLastMatch.set -> void
-Microsoft.Build.Tasks.FindInList.ItemFound.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindInList.ItemFound.set -> void
-Microsoft.Build.Tasks.FindInList.ItemSpecToFind.get -> string
-Microsoft.Build.Tasks.FindInList.ItemSpecToFind.set -> void
-Microsoft.Build.Tasks.FindInList.List.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInList.List.set -> void
-Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.get -> bool
-Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences
-Microsoft.Build.Tasks.FindInvalidProjectReferences.FindInvalidProjectReferences() -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.InvalidReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.FindUnderPath
-Microsoft.Build.Tasks.FindUnderPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.Files.set -> void
-Microsoft.Build.Tasks.FindUnderPath.FindUnderPath() -> void
-Microsoft.Build.Tasks.FindUnderPath.InPath.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.InPath.set -> void
-Microsoft.Build.Tasks.FindUnderPath.OutOfPath.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.OutOfPath.set -> void
-Microsoft.Build.Tasks.FindUnderPath.Path.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindUnderPath.Path.set -> void
-Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.get -> bool
-Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.set -> void
-Microsoft.Build.Tasks.FormatUrl
-Microsoft.Build.Tasks.FormatUrl.FormatUrl() -> void
-Microsoft.Build.Tasks.FormatUrl.InputUrl.get -> string
-Microsoft.Build.Tasks.FormatUrl.InputUrl.set -> void
-Microsoft.Build.Tasks.FormatUrl.OutputUrl.get -> string
-Microsoft.Build.Tasks.FormatUrl.OutputUrl.set -> void
-Microsoft.Build.Tasks.FormatVersion
-Microsoft.Build.Tasks.FormatVersion.FormatType.get -> string
-Microsoft.Build.Tasks.FormatVersion.FormatType.set -> void
-Microsoft.Build.Tasks.FormatVersion.FormatVersion() -> void
-Microsoft.Build.Tasks.FormatVersion.OutputVersion.get -> string
-Microsoft.Build.Tasks.FormatVersion.OutputVersion.set -> void
-Microsoft.Build.Tasks.FormatVersion.Revision.get -> int
-Microsoft.Build.Tasks.FormatVersion.Revision.set -> void
-Microsoft.Build.Tasks.FormatVersion.Version.get -> string
-Microsoft.Build.Tasks.FormatVersion.Version.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest
-Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.Files.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.GenerateApplicationManifest() -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Product.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.Product.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects
-Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.GenerateBindingRedirects() -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.get -> string
-Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationFile.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationFile.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationName.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationName.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperComponentFiles.get -> string[]
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperComponentFiles.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperItems.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperItems.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperKeyFile.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperKeyFile.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsLocation.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.CopyComponents.get -> bool
-Microsoft.Build.Tasks.GenerateBootstrapper.CopyComponents.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.Culture.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.Culture.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.FallbackCulture.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.FallbackCulture.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.GenerateBootstrapper() -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.OutputPath.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.OutputPath.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.Path.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.Path.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.Validate.get -> bool
-Microsoft.Build.Tasks.GenerateBootstrapper.Validate.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.VisualStudioVersion.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.VisualStudioVersion.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest
-Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.GenerateDeploymentManifest() -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.get -> int
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.set -> void
-Microsoft.Build.Tasks.GenerateLauncher
-Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.GenerateLauncher() -> void
-Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.OutputPath.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.OutputPath.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase
-Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.Description.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.Description.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.GenerateManifestBase.GenerateManifestBase() -> void
-Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.get -> int
-Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.Platform.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.Platform.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.GenerateResource
-Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.set -> void
-Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.get -> string[]
-Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.get -> bool
-Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.get -> bool
-Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.set -> void
-Microsoft.Build.Tasks.GenerateResource.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.GenerateResource() -> void
-Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.get -> bool
-Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.set -> void
-Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.get -> bool
-Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.set -> void
-Microsoft.Build.Tasks.GenerateResource.OutputDirectory.get -> string
-Microsoft.Build.Tasks.GenerateResource.OutputDirectory.set -> void
-Microsoft.Build.Tasks.GenerateResource.OutputResources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.OutputResources.set -> void
-Microsoft.Build.Tasks.GenerateResource.PublicClass.get -> bool
-Microsoft.Build.Tasks.GenerateResource.PublicClass.set -> void
-Microsoft.Build.Tasks.GenerateResource.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.References.set -> void
-Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.Sources.set -> void
-Microsoft.Build.Tasks.GenerateResource.StateFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateResource.StateFile.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.set -> void
-Microsoft.Build.Tasks.GenerateResource.TLogReadFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.TLogWriteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.get -> string
-Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.get -> bool
-Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.set -> void
-Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.get -> bool
-Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.set -> void
-Microsoft.Build.Tasks.GenerateResource.UseSourcePath.get -> bool
-Microsoft.Build.Tasks.GenerateResource.UseSourcePath.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo
-Microsoft.Build.Tasks.GenerateTrustInfo.ApplicationDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateTrustInfo.ApplicationDependencies.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.BaseManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateTrustInfo.BaseManifest.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.ExcludedPermissions.get -> string
-Microsoft.Build.Tasks.GenerateTrustInfo.ExcludedPermissions.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.GenerateTrustInfo() -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GenerateTrustInfo.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.TargetZone.get -> string
-Microsoft.Build.Tasks.GenerateTrustInfo.TargetZone.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.TrustInfoFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateTrustInfo.TrustInfoFile.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity
-Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity.GetAssemblyIdentity() -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform
-Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.get -> string
-Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.GetCompatiblePlatform() -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.get -> string
-Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.set -> void
-Microsoft.Build.Tasks.GetFileHash
-Microsoft.Build.Tasks.GetFileHash.Algorithm.get -> string
-Microsoft.Build.Tasks.GetFileHash.Algorithm.set -> void
-Microsoft.Build.Tasks.GetFileHash.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetFileHash.Files.set -> void
-Microsoft.Build.Tasks.GetFileHash.GetFileHash() -> void
-Microsoft.Build.Tasks.GetFileHash.Hash.get -> string
-Microsoft.Build.Tasks.GetFileHash.Hash.set -> void
-Microsoft.Build.Tasks.GetFileHash.HashEncoding.get -> string
-Microsoft.Build.Tasks.GetFileHash.HashEncoding.set -> void
-Microsoft.Build.Tasks.GetFileHash.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetFileHash.Items.set -> void
-Microsoft.Build.Tasks.GetFileHash.MetadataName.get -> string
-Microsoft.Build.Tasks.GetFileHash.MetadataName.set -> void
-Microsoft.Build.Tasks.GetFrameworkPath
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion11Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion20Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion30Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion35Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion40Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion451Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion452Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion45Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion461Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion462Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion46Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion471Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion472Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion47Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion48Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.GetFrameworkPath() -> void
-Microsoft.Build.Tasks.GetFrameworkPath.Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion20Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion35Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion40Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion451Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion45Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion461Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion46Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.GetFrameworkSdkPath() -> void
-Microsoft.Build.Tasks.GetFrameworkSdkPath.Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.Path.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations
-Microsoft.Build.Tasks.GetInstalledSDKLocations.GetInstalledSDKLocations() -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.get -> bool
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.get -> bool
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.FullFrameworkReferenceAssemblyPaths.get -> string[]
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.GetReferenceAssemblyPaths() -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.ReferenceAssemblyPaths.get -> string[]
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.get -> bool
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.GetSDKReferenceFiles() -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.RedistFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.get -> string[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.set -> void
-Microsoft.Build.Tasks.Hash
-Microsoft.Build.Tasks.Hash.Hash() -> void
-Microsoft.Build.Tasks.Hash.HashResult.get -> string
-Microsoft.Build.Tasks.Hash.HashResult.set -> void
-Microsoft.Build.Tasks.Hash.IgnoreCase.get -> bool
-Microsoft.Build.Tasks.Hash.IgnoreCase.set -> void
-Microsoft.Build.Tasks.Hash.ItemsToHash.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Hash.ItemsToHash.set -> void
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles) -> bool
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAnalyzers(Microsoft.Build.Framework.ITaskItem[] analyzers) -> bool
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetRuleSet(string ruleSetFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject
-Microsoft.Build.Tasks.Hosting.ICscHostObject.BeginInitialization() -> void
-Microsoft.Build.Tasks.Hosting.ICscHostObject.Compile() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.EndInitialization(out string errorMessage, out int errorCode) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.IsDesignTime() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.IsUpToDate() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAddModules(string[] addModules) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAllowUnsafeBlocks(bool allowUnsafeBlocks) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetBaseAddress(string baseAddress) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCodePage(int codePage) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDebugType(string debugType) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDefineConstants(string defineConstants) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDelaySign(bool delaySignExplicitlySet, bool delaySign) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDocumentationFile(string documentationFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetEmitDebugInformation(bool emitDebugInformation) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetErrorReport(string errorReport) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetFileAlignment(int fileAlignment) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetGenerateFullPaths(bool generateFullPaths) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyContainer(string keyContainer) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyFile(string keyFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLangVersion(string langVersion) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetMainEntryPoint(string targetType, string mainEntryPoint) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetModuleAssemblyName(string moduleAssemblyName) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoConfig(bool noConfig) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoStandardLib(bool noStandardLib) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOptimize(bool optimize) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOutputAssembly(string outputAssembly) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPdbFile(string pdbFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPlatform(string platform) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTargetType(string targetType) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningLevel(int warningLevel) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Icon(string win32Icon) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Resource(string win32Resource) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject2
-Microsoft.Build.Tasks.Hosting.ICscHostObject2.SetWin32Manifest(string win32Manifest) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject3
-Microsoft.Build.Tasks.Hosting.ICscHostObject3.SetApplicationConfiguration(string applicationConfiguration) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetHighEntropyVA(bool highEntropyVA) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetSubsystemVersion(string subsystemVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.BeginInitialization() -> void
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.Compile() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.EndInitialization() -> void
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsDesignTime() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsUpToDate() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAddModules(string[] addModules) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetBaseAddress(string targetType, string baseAddress) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetCodePage(int codePage) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDebugType(bool emitDebugInformation, string debugType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDefineConstants(string defineConstants) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDelaySign(bool delaySign) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDocumentationFile(string documentationFile) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetErrorReport(string errorReport) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetFileAlignment(int fileAlignment) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetGenerateDocumentation(bool generateDocumentation) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetImports(Microsoft.Build.Framework.ITaskItem[] importsList) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyContainer(string keyContainer) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyFile(string keyFile) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetMainEntryPoint(string mainEntryPoint) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoConfig(bool noConfig) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoStandardLib(bool noStandardLib) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoWarnings(bool noWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptimize(bool optimize) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionCompare(string optionCompare) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionExplicit(bool optionExplicit) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrict(bool optionStrict) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrictType(string optionStrictType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOutputAssembly(string outputAssembly) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetPlatform(string platform) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRemoveIntegerChecks(bool removeIntegerChecks) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRootNamespace(string rootNamespace) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSdkPath(string sdkPath) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetCompactFramework(bool targetCompactFramework) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetType(string targetType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Icon(string win32Icon) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Resource(string win32Resource) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetModuleAssemblyName(string moduleAssemblyName) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetOptionInfer(bool optionInfer) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetWin32Manifest(string win32Manifest) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject3
-Microsoft.Build.Tasks.Hosting.IVbcHostObject3.SetLanguageVersion(string languageVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject4
-Microsoft.Build.Tasks.Hosting.IVbcHostObject4.SetVBRuntime(string VBRuntime) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent) -> int
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.EndCompile(bool buildSuccess) -> int
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.GetFreeThreadedHostObject() -> Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetHighEntropyVA(bool highEntropyVA) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetSubsystemVersion(string subsystemVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
-Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded.Compile() -> bool
-Microsoft.Build.Tasks.IFixedTypeInfo
-Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
-Microsoft.Build.Tasks.LC
-Microsoft.Build.Tasks.LC.LC() -> void
-Microsoft.Build.Tasks.LC.LicenseTarget.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.LC.LicenseTarget.set -> void
-Microsoft.Build.Tasks.LC.NoLogo.get -> bool
-Microsoft.Build.Tasks.LC.NoLogo.set -> void
-Microsoft.Build.Tasks.LC.OutputDirectory.get -> string
-Microsoft.Build.Tasks.LC.OutputDirectory.set -> void
-Microsoft.Build.Tasks.LC.OutputLicense.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.LC.OutputLicense.set -> void
-Microsoft.Build.Tasks.LC.ReferencedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.LC.ReferencedAssemblies.set -> void
-Microsoft.Build.Tasks.LC.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.LC.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.LC.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.LC.Sources.set -> void
-Microsoft.Build.Tasks.LC.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.LC.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.MakeDir
-Microsoft.Build.Tasks.MakeDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MakeDir.Directories.set -> void
-Microsoft.Build.Tasks.MakeDir.DirectoriesCreated.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MakeDir.MakeDir() -> void
-Microsoft.Build.Tasks.Message
-Microsoft.Build.Tasks.Message.Code.get -> string
-Microsoft.Build.Tasks.Message.Code.set -> void
-Microsoft.Build.Tasks.Message.File.get -> string
-Microsoft.Build.Tasks.Message.File.set -> void
-Microsoft.Build.Tasks.Message.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Message.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Message.Importance.get -> string
-Microsoft.Build.Tasks.Message.Importance.set -> void
-Microsoft.Build.Tasks.Message.IsCritical.get -> bool
-Microsoft.Build.Tasks.Message.IsCritical.set -> void
-Microsoft.Build.Tasks.Message.Message() -> void
-Microsoft.Build.Tasks.Message.Text.get -> string
-Microsoft.Build.Tasks.Message.Text.set -> void
-Microsoft.Build.Tasks.Move
-Microsoft.Build.Tasks.Move.Cancel() -> void
-Microsoft.Build.Tasks.Move.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.DestinationFiles.set -> void
-Microsoft.Build.Tasks.Move.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Move.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Move.Move() -> void
-Microsoft.Build.Tasks.Move.MovedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Move.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.SourceFiles.set -> void
-Microsoft.Build.Tasks.MSBuild
-Microsoft.Build.Tasks.MSBuild.BuildInParallel.get -> bool
-Microsoft.Build.Tasks.MSBuild.BuildInParallel.set -> void
-Microsoft.Build.Tasks.MSBuild.MSBuild() -> void
-Microsoft.Build.Tasks.MSBuild.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MSBuild.Projects.set -> void
-Microsoft.Build.Tasks.MSBuild.Properties.get -> string[]
-Microsoft.Build.Tasks.MSBuild.Properties.set -> void
-Microsoft.Build.Tasks.MSBuild.RebaseOutputs.get -> bool
-Microsoft.Build.Tasks.MSBuild.RebaseOutputs.set -> void
-Microsoft.Build.Tasks.MSBuild.RemoveProperties.get -> string
-Microsoft.Build.Tasks.MSBuild.RemoveProperties.set -> void
-Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.get -> bool
-Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.set -> void
-Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.get -> string
-Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.set -> void
-Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.get -> bool
-Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.set -> void
-Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.get -> string[]
-Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.set -> void
-Microsoft.Build.Tasks.MSBuild.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MSBuild.Targets.get -> string[]
-Microsoft.Build.Tasks.MSBuild.Targets.set -> void
-Microsoft.Build.Tasks.MSBuild.ToolsVersion.get -> string
-Microsoft.Build.Tasks.MSBuild.ToolsVersion.set -> void
-Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.get -> bool
-Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.set -> void
-Microsoft.Build.Tasks.MSBuild.UseResultsCache.get -> bool
-Microsoft.Build.Tasks.MSBuild.UseResultsCache.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile
-Microsoft.Build.Tasks.ReadLinesFromFile.File.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ReadLinesFromFile.File.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ReadLinesFromFile.Lines.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile.ReadLinesFromFile() -> void
-Microsoft.Build.Tasks.RegisterAssembly
-Microsoft.Build.Tasks.RegisterAssembly.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RegisterAssembly.Assemblies.set -> void
-Microsoft.Build.Tasks.RegisterAssembly.AssemblyListFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.RegisterAssembly.AssemblyListFile.set -> void
-Microsoft.Build.Tasks.RegisterAssembly.CreateCodeBase.get -> bool
-Microsoft.Build.Tasks.RegisterAssembly.CreateCodeBase.set -> void
-Microsoft.Build.Tasks.RegisterAssembly.RegisterAssembly() -> void
-Microsoft.Build.Tasks.RegisterAssembly.ReportEvent(System.Runtime.InteropServices.ExporterEventKind kind, int code, string msg) -> void
-Microsoft.Build.Tasks.RegisterAssembly.ResolveRef(System.Reflection.Assembly assemblyToResolve) -> object
-Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles.set -> void
-Microsoft.Build.Tasks.RemoveDir
-Microsoft.Build.Tasks.RemoveDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDir.Directories.set -> void
-Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.set -> void
-Microsoft.Build.Tasks.RemoveDir.RemoveDir() -> void
-Microsoft.Build.Tasks.RemoveDuplicates
-Microsoft.Build.Tasks.RemoveDuplicates.Filtered.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDuplicates.Filtered.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.get -> bool
-Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.Inputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDuplicates.Inputs.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.RemoveDuplicates() -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Assemblies.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.DeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.DeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.EntryPoint.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Files.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ReferencedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ReferencedAssemblies.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.RequiresFramework35SP1Assembly() -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.RequiresMinimumFramework35SP1.get -> bool
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.RequiresMinimumFramework35SP1.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SigningManifests.get -> bool
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SigningManifests.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SuiteName.get -> string
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SuiteName.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnNETStandard.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnSystemRuntime.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.RelatedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolveAssemblyReference() -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedDependencyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SatelliteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ScatterFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SerializationAssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolvedAssemblyConflicts.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.get -> string
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.get -> string
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolveCodeAnalysisRuleSet() -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolvedCodeAnalysisRuleSet.get -> string
-Microsoft.Build.Tasks.ResolveComReference
-Microsoft.Build.Tasks.ResolveComReference.DelaySign.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.DelaySign.set -> void
-Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.get -> string[]
-Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.set -> void
-Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.set -> void
-Microsoft.Build.Tasks.ResolveComReference.KeyContainer.get -> string
-Microsoft.Build.Tasks.ResolveComReference.KeyContainer.set -> void
-Microsoft.Build.Tasks.ResolveComReference.KeyFile.get -> string
-Microsoft.Build.Tasks.ResolveComReference.KeyFile.set -> void
-Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolveComReference() -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.set -> void
-Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.ResolveComReference.Silent.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.Silent.set -> void
-Microsoft.Build.Tasks.ResolveComReference.StateFile.get -> string
-Microsoft.Build.Tasks.ResolveComReference.StateFile.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.set -> void
-Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.get -> string
-Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.set -> void
-Microsoft.Build.Tasks.ResolveKeySource
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.get -> int
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.get -> int
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.KeyFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.KeyFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolveKeySource() -> void
-Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.get -> bool
-Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.get -> bool
-Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles
-Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.Files.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ResolveManifestFiles() -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference
-Microsoft.Build.Tasks.ResolveNativeReference.AdditionalSearchPaths.get -> string[]
-Microsoft.Build.Tasks.ResolveNativeReference.AdditionalSearchPaths.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedComComponents.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedComComponents.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseEtcFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseEtcFiles.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseTlbFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseTlbFiles.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedPrerequisiteAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedPrerequisiteAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedTypeLibraries.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedTypeLibraries.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainingReferenceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainingReferenceFiles.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.NativeReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.NativeReferences.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ResolveNativeReference() -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.get -> string
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolveNonMSBuildProjectOutput() -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.set -> void
-Microsoft.Build.Tasks.ResolveProjectBase
-Microsoft.Build.Tasks.ResolveProjectBase.AddSyntheticProjectReferences(string currentProjectAbsolutePath) -> void
-Microsoft.Build.Tasks.ResolveProjectBase.GetProjectElement(Microsoft.Build.Framework.ITaskItem projectRef) -> System.Xml.XmlElement
-Microsoft.Build.Tasks.ResolveProjectBase.GetProjectItem(Microsoft.Build.Framework.ITaskItem projectRef) -> string
-Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.set -> void
-Microsoft.Build.Tasks.ResolveProjectBase.ResolveProjectBase() -> void
-Microsoft.Build.Tasks.ResolveSDKReference
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.References.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.ResolveSDKReference() -> void
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.set -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.RoslynCodeTaskFactory() -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.SGen
-Microsoft.Build.Tasks.SGen.BuildAssemblyName.get -> string
-Microsoft.Build.Tasks.SGen.BuildAssemblyName.set -> void
-Microsoft.Build.Tasks.SGen.BuildAssemblyPath.get -> string
-Microsoft.Build.Tasks.SGen.BuildAssemblyPath.set -> void
-Microsoft.Build.Tasks.SGen.DelaySign.get -> bool
-Microsoft.Build.Tasks.SGen.DelaySign.set -> void
-Microsoft.Build.Tasks.SGen.KeyContainer.get -> string
-Microsoft.Build.Tasks.SGen.KeyContainer.set -> void
-Microsoft.Build.Tasks.SGen.KeyFile.get -> string
-Microsoft.Build.Tasks.SGen.KeyFile.set -> void
-Microsoft.Build.Tasks.SGen.Platform.get -> string
-Microsoft.Build.Tasks.SGen.Platform.set -> void
-Microsoft.Build.Tasks.SGen.References.get -> string[]
-Microsoft.Build.Tasks.SGen.References.set -> void
-Microsoft.Build.Tasks.SGen.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.SGen.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.SGen.SerializationAssembly.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SGen.SerializationAssembly.set -> void
-Microsoft.Build.Tasks.SGen.SerializationAssemblyName.get -> string
-Microsoft.Build.Tasks.SGen.SGen() -> void
-Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.get -> bool
-Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.set -> void
-Microsoft.Build.Tasks.SGen.Types.get -> string[]
-Microsoft.Build.Tasks.SGen.Types.set -> void
-Microsoft.Build.Tasks.SGen.UseKeep.get -> bool
-Microsoft.Build.Tasks.SGen.UseKeep.set -> void
-Microsoft.Build.Tasks.SGen.UseProxyTypes.get -> bool
-Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
-Microsoft.Build.Tasks.SignFile
-Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
-Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-Microsoft.Build.Tasks.SignFile.SignFile() -> void
-Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
-Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.get -> string
-Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.set -> void
-Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.SignFile.TimestampUrl.get -> string
-Microsoft.Build.Tasks.SignFile.TimestampUrl.set -> void
-Microsoft.Build.Tasks.TaskExtension
-Microsoft.Build.Tasks.TaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.TaskLoggingHelperExtension
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskLoggingHelperExtension(Microsoft.Build.Framework.ITask taskInstance, System.Resources.ResourceManager primaryResources, System.Resources.ResourceManager sharedResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.set -> void
-Microsoft.Build.Tasks.Telemetry
-Microsoft.Build.Tasks.Telemetry.EventData.get -> string
-Microsoft.Build.Tasks.Telemetry.EventData.set -> void
-Microsoft.Build.Tasks.Telemetry.EventName.get -> string
-Microsoft.Build.Tasks.Telemetry.EventName.set -> void
-Microsoft.Build.Tasks.Telemetry.Telemetry() -> void
-Microsoft.Build.Tasks.ToolTaskExtension
-Microsoft.Build.Tasks.ToolTaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.Touch
-Microsoft.Build.Tasks.Touch.AlwaysCreate.get -> bool
-Microsoft.Build.Tasks.Touch.AlwaysCreate.set -> void
-Microsoft.Build.Tasks.Touch.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Touch.Files.set -> void
-Microsoft.Build.Tasks.Touch.ForceTouch.get -> bool
-Microsoft.Build.Tasks.Touch.ForceTouch.set -> void
-Microsoft.Build.Tasks.Touch.Time.get -> string
-Microsoft.Build.Tasks.Touch.Time.set -> void
-Microsoft.Build.Tasks.Touch.Touch() -> void
-Microsoft.Build.Tasks.Touch.TouchedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Touch.TouchedFiles.set -> void
-Microsoft.Build.Tasks.UnregisterAssembly
-Microsoft.Build.Tasks.UnregisterAssembly.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.UnregisterAssembly.Assemblies.set -> void
-Microsoft.Build.Tasks.UnregisterAssembly.AssemblyListFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.UnregisterAssembly.AssemblyListFile.set -> void
-Microsoft.Build.Tasks.UnregisterAssembly.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.UnregisterAssembly.TypeLibFiles.set -> void
-Microsoft.Build.Tasks.UnregisterAssembly.UnregisterAssembly() -> void
-Microsoft.Build.Tasks.Unzip
-Microsoft.Build.Tasks.Unzip.Cancel() -> void
-Microsoft.Build.Tasks.Unzip.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Unzip.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Unzip.Exclude.get -> string
-Microsoft.Build.Tasks.Unzip.Exclude.set -> void
-Microsoft.Build.Tasks.Unzip.Include.get -> string
-Microsoft.Build.Tasks.Unzip.Include.set -> void
-Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.Unzip.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Unzip.SourceFiles.set -> void
-Microsoft.Build.Tasks.Unzip.Unzip() -> void
-Microsoft.Build.Tasks.UpdateManifest
-Microsoft.Build.Tasks.UpdateManifest.ApplicationManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.UpdateManifest.ApplicationManifest.set -> void
-Microsoft.Build.Tasks.UpdateManifest.ApplicationPath.get -> string
-Microsoft.Build.Tasks.UpdateManifest.ApplicationPath.set -> void
-Microsoft.Build.Tasks.UpdateManifest.InputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.UpdateManifest.InputManifest.set -> void
-Microsoft.Build.Tasks.UpdateManifest.OutputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.UpdateManifest.OutputManifest.set -> void
-Microsoft.Build.Tasks.UpdateManifest.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.UpdateManifest.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.UpdateManifest.UpdateManifest() -> void
-Microsoft.Build.Tasks.VerifyFileHash
-Microsoft.Build.Tasks.VerifyFileHash.Algorithm.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.Algorithm.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.File.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.File.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.Hash.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.Hash.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.VerifyFileHash() -> void
-Microsoft.Build.Tasks.Warning
-Microsoft.Build.Tasks.Warning.Code.get -> string
-Microsoft.Build.Tasks.Warning.Code.set -> void
-Microsoft.Build.Tasks.Warning.File.get -> string
-Microsoft.Build.Tasks.Warning.File.set -> void
-Microsoft.Build.Tasks.Warning.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Warning.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Warning.HelpLink.get -> string
-Microsoft.Build.Tasks.Warning.HelpLink.set -> void
-Microsoft.Build.Tasks.Warning.Text.get -> string
-Microsoft.Build.Tasks.Warning.Text.set -> void
-Microsoft.Build.Tasks.Warning.Warning() -> void
-Microsoft.Build.Tasks.WinMDExp
-Microsoft.Build.Tasks.WinMDExp.AssemblyUnificationPolicy.get -> string
-Microsoft.Build.Tasks.WinMDExp.AssemblyUnificationPolicy.set -> void
-Microsoft.Build.Tasks.WinMDExp.DisabledWarnings.get -> string
-Microsoft.Build.Tasks.WinMDExp.DisabledWarnings.set -> void
-Microsoft.Build.Tasks.WinMDExp.InputDocumentationFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.InputDocumentationFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.InputPDBFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.InputPDBFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.OutputDocumentationFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.OutputDocumentationFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.OutputPDBFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.OutputPDBFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.OutputWindowsMetadataFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.OutputWindowsMetadataFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WinMDExp.References.set -> void
-Microsoft.Build.Tasks.WinMDExp.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.WinMDExp.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.WinMDExp.TreatWarningsAsErrors.get -> bool
-Microsoft.Build.Tasks.WinMDExp.TreatWarningsAsErrors.set -> void
-Microsoft.Build.Tasks.WinMDExp.UTF8Output.get -> bool
-Microsoft.Build.Tasks.WinMDExp.UTF8Output.set -> void
-Microsoft.Build.Tasks.WinMDExp.WinMDExp() -> void
-Microsoft.Build.Tasks.WinMDExp.WinMDModule.get -> string
-Microsoft.Build.Tasks.WinMDExp.WinMDModule.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment
-Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.Language.get -> string
-Microsoft.Build.Tasks.WriteCodeFragment.Language.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.WriteCodeFragment() -> void
-Microsoft.Build.Tasks.WriteLinesToFile
-Microsoft.Build.Tasks.WriteLinesToFile.Encoding.get -> string
-Microsoft.Build.Tasks.WriteLinesToFile.Encoding.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.File.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteLinesToFile.File.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WriteLinesToFile.Lines.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.get -> bool
-Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.WriteLinesToFile() -> void
-Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.get -> bool
-Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation
-Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.CommandLineArgumentRelation(string argument, string value, bool required, string separator) -> void
-Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.Separator.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.Separator.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AdditionalOptions.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AdditionalOptions.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AlwaysAppend.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AlwaysAppend.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineGenerator(Microsoft.Build.Framework.XamlTypes.Rule rule, System.Collections.Generic.Dictionary<string, object> parameterValues) -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineTemplate.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineTemplate.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.GenerateCommandLine() -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.AllowMultipleValues.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.AllowMultipleValues.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ArgumentRequired.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ArgumentRequired.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Arguments.get -> System.Collections.Generic.ICollection<System.Tuple<string, bool>>
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Arguments.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.BooleanValue.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.BooleanValue.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.CommandLineToolSwitch() -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.CommandLineToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType toolType) -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Description.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Description.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.DisplayName.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.DisplayName.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FallbackArgumentParameter.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FallbackArgumentParameter.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FalseSuffix.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FalseSuffix.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IncludeInCommandLine.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IncludeInCommandLine.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IsValid.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IsValid.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Name.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Name.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Number.get -> int
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Number.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Overrides.get -> System.Collections.Generic.LinkedList<System.Collections.Generic.KeyValuePair<string, string>>
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Parents.get -> System.Collections.Generic.LinkedList<string>
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Required.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Required.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ReverseSwitchValue.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ReverseSwitchValue.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Reversible.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Reversible.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Separator.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Separator.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.StringList.get -> string[]
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.StringList.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.SwitchValue.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.SwitchValue.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TaskItemArray.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TaskItemArray.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TrueSuffix.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TrueSuffix.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Type.get -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Type.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Value.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Value.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.Boolean = 0 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.Integer = 1 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.ITaskItemArray = 4 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.String = 2 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.StringArray = 3 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.PropertyRelation
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Argument.get -> string
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Argument.set -> void
-Microsoft.Build.Tasks.Xaml.PropertyRelation.PropertyRelation() -> void
-Microsoft.Build.Tasks.Xaml.PropertyRelation.PropertyRelation(string argument, string value, bool required) -> void
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Required.get -> bool
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Required.set -> void
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Value.get -> string
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Value.set -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitches.get -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch>
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitchesValues.get -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch>
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitchesValues.set -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AddActiveSwitchToolValue(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch switchToAdd) -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AdditionalOptions.get -> string
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AdditionalOptions.set -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CommandLineTemplate.get -> string
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CommandLineTemplate.set -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CreateSwitchValue(string propertyName, string baseSwitch, string separator, System.Tuple<string, bool>[] arguments) -> string
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.IsPropertySet(string propertyName) -> bool
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReadSwitchMap(string propertyName, string[][] switchMap, string value) -> string
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReadSwitchMap2(string propertyName, System.Tuple<string, string, System.Tuple<string, bool>[]>[] switchMap, string value) -> int
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReplaceToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch switchToAdd) -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateInteger(string switchName, int min, int max, int value) -> bool
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.XamlDataDrivenToolTask(string[] switchOrderList, System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Tasks.XamlTaskFactory
-Microsoft.Build.Tasks.XamlTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.XamlTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.XamlTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.XamlTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.XamlTaskFactory.TaskElementContents.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.TaskName.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.TaskNamespace.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.XamlTaskFactory.XamlTaskFactory() -> void
-Microsoft.Build.Tasks.XmlPeek
-Microsoft.Build.Tasks.XmlPeek.Namespaces.get -> string
-Microsoft.Build.Tasks.XmlPeek.Namespaces.set -> void
-Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.get -> bool
-Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.set -> void
-Microsoft.Build.Tasks.XmlPeek.Query.get -> string
-Microsoft.Build.Tasks.XmlPeek.Query.set -> void
-Microsoft.Build.Tasks.XmlPeek.Result.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XmlPeek.XmlContent.get -> string
-Microsoft.Build.Tasks.XmlPeek.XmlContent.set -> void
-Microsoft.Build.Tasks.XmlPeek.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPeek.XmlInputPath.set -> void
-Microsoft.Build.Tasks.XmlPeek.XmlPeek() -> void
-Microsoft.Build.Tasks.XmlPoke
-Microsoft.Build.Tasks.XmlPoke.Namespaces.get -> string
-Microsoft.Build.Tasks.XmlPoke.Namespaces.set -> void
-Microsoft.Build.Tasks.XmlPoke.Query.get -> string
-Microsoft.Build.Tasks.XmlPoke.Query.set -> void
-Microsoft.Build.Tasks.XmlPoke.Value.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPoke.Value.set -> void
-Microsoft.Build.Tasks.XmlPoke.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPoke.XmlInputPath.set -> void
-Microsoft.Build.Tasks.XmlPoke.XmlPoke() -> void
-Microsoft.Build.Tasks.XslTransformation
-Microsoft.Build.Tasks.XslTransformation.OutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XslTransformation.OutputPaths.set -> void
-Microsoft.Build.Tasks.XslTransformation.Parameters.get -> string
-Microsoft.Build.Tasks.XslTransformation.Parameters.set -> void
-Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.get -> bool
-Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.set -> void
-Microsoft.Build.Tasks.XslTransformation.XmlContent.get -> string
-Microsoft.Build.Tasks.XslTransformation.XmlContent.set -> void
-Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslContent.get -> string
-Microsoft.Build.Tasks.XslTransformation.XslContent.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XslTransformation.XslInputPath.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslTransformation() -> void
-Microsoft.Build.Tasks.ZipDirectory
-Microsoft.Build.Tasks.ZipDirectory.DestinationFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ZipDirectory.DestinationFile.set -> void
-Microsoft.Build.Tasks.ZipDirectory.Overwrite.get -> bool
-Microsoft.Build.Tasks.ZipDirectory.Overwrite.set -> void
-Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.set -> void
-Microsoft.Build.Tasks.ZipDirectory.ZipDirectory() -> void
-override Microsoft.Build.Tasks.AL.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.AL.Execute() -> bool
-override Microsoft.Build.Tasks.AL.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.AL.ToolName.get -> string
-override Microsoft.Build.Tasks.AspNetCompiler.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.AspNetCompiler.Execute() -> bool
-override Microsoft.Build.Tasks.AspNetCompiler.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.AspNetCompiler.ToolName.get -> string
-override Microsoft.Build.Tasks.AspNetCompiler.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.AssignCulture.Execute() -> bool
-override Microsoft.Build.Tasks.AssignLinkMetadata.Execute() -> bool
-override Microsoft.Build.Tasks.AssignProjectConfiguration.Execute() -> bool
-override Microsoft.Build.Tasks.AssignTargetPath.Execute() -> bool
-override Microsoft.Build.Tasks.CallTarget.Execute() -> bool
-override Microsoft.Build.Tasks.CombinePath.Execute() -> bool
-override Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Execute() -> bool
-override Microsoft.Build.Tasks.CombineXmlElements.Execute() -> bool
-override Microsoft.Build.Tasks.ConvertToAbsolutePath.Execute() -> bool
-override Microsoft.Build.Tasks.Copy.Execute() -> bool
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.IsSourceFile(string fileName) -> bool
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.SourceFileExtension.get -> string
-override Microsoft.Build.Tasks.CreateItem.Execute() -> bool
-override Microsoft.Build.Tasks.CreateManifestResourceName.Execute() -> bool
-override Microsoft.Build.Tasks.CreateProperty.Execute() -> bool
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.IsSourceFile(string fileName) -> bool
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.SourceFileExtension.get -> string
-override Microsoft.Build.Tasks.Delete.Execute() -> bool
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.set -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Validate() -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.set -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Validate() -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ToString() -> string
-override Microsoft.Build.Tasks.DownloadFile.Execute() -> bool
-override Microsoft.Build.Tasks.Error.Execute() -> bool
-override Microsoft.Build.Tasks.ErrorFromResources.Execute() -> bool
-override Microsoft.Build.Tasks.Exec.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.Exec.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
-override Microsoft.Build.Tasks.Exec.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.Exec.GetWorkingDirectory() -> string
-override Microsoft.Build.Tasks.Exec.HandleTaskExecutionErrors() -> bool
-override Microsoft.Build.Tasks.Exec.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
-override Microsoft.Build.Tasks.Exec.LogPathToTool(string toolName, string pathToTool) -> void
-override Microsoft.Build.Tasks.Exec.LogToolCommand(string message) -> void
-override Microsoft.Build.Tasks.Exec.StandardErrorEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Exec.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-override Microsoft.Build.Tasks.Exec.StandardOutputEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Exec.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-override Microsoft.Build.Tasks.Exec.ToolName.get -> string
-override Microsoft.Build.Tasks.Exec.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.FindAppConfigFile.Execute() -> bool
-override Microsoft.Build.Tasks.FindInList.Execute() -> bool
-override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
-override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
-override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
-override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateBootstrapper.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateTrustInfo.Execute() -> bool
-override Microsoft.Build.Tasks.GetAssemblyIdentity.Execute() -> bool
-override Microsoft.Build.Tasks.GetCompatiblePlatform.Execute() -> bool
-override Microsoft.Build.Tasks.GetFileHash.Execute() -> bool
-override Microsoft.Build.Tasks.GetFrameworkPath.Execute() -> bool
-override Microsoft.Build.Tasks.GetFrameworkSdkPath.Execute() -> bool
-override Microsoft.Build.Tasks.GetInstalledSDKLocations.Execute() -> bool
-override Microsoft.Build.Tasks.GetReferenceAssemblyPaths.Execute() -> bool
-override Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute() -> bool
-override Microsoft.Build.Tasks.Hash.Execute() -> bool
-override Microsoft.Build.Tasks.LC.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.LC.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.LC.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.LC.ToolName.get -> string
-override Microsoft.Build.Tasks.LC.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.MakeDir.Execute() -> bool
-override Microsoft.Build.Tasks.Message.Execute() -> bool
-override Microsoft.Build.Tasks.Move.Execute() -> bool
-override Microsoft.Build.Tasks.MSBuild.Execute() -> bool
-override Microsoft.Build.Tasks.ReadLinesFromFile.Execute() -> bool
-override Microsoft.Build.Tasks.RegisterAssembly.Execute() -> bool
-override Microsoft.Build.Tasks.RemoveDir.Execute() -> bool
-override Microsoft.Build.Tasks.RemoveDuplicates.Execute() -> bool
-override Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveAssemblyReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveComReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveKeySource.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveManifestFiles.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveNativeReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveSDKReference.Execute() -> bool
-override Microsoft.Build.Tasks.SGen.GenerateCommandLineCommands() -> string
-override Microsoft.Build.Tasks.SGen.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.SGen.SkipTaskExecution() -> bool
-override Microsoft.Build.Tasks.SGen.ToolName.get -> string
-override Microsoft.Build.Tasks.SGen.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.SignFile.Execute() -> bool
-override Microsoft.Build.Tasks.TaskLoggingHelperExtension.FormatResourceString(string resourceName, params object[] args) -> string
-override Microsoft.Build.Tasks.Telemetry.Execute() -> bool
-override Microsoft.Build.Tasks.Touch.Execute() -> bool
-override Microsoft.Build.Tasks.UnregisterAssembly.Execute() -> bool
-override Microsoft.Build.Tasks.Unzip.Execute() -> bool
-override Microsoft.Build.Tasks.UpdateManifest.Execute() -> bool
-override Microsoft.Build.Tasks.VerifyFileHash.Execute() -> bool
-override Microsoft.Build.Tasks.Warning.Execute() -> bool
-override Microsoft.Build.Tasks.WinMDExp.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.WinMDExp.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.WinMDExp.SkipTaskExecution() -> bool
-override Microsoft.Build.Tasks.WinMDExp.StandardErrorEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.WinMDExp.StandardOutputEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.WinMDExp.ToolName.get -> string
-override Microsoft.Build.Tasks.WinMDExp.UseNewLineSeparatorInResponseFile.get -> bool
-override Microsoft.Build.Tasks.WinMDExp.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.WriteCodeFragment.Execute() -> bool
-override Microsoft.Build.Tasks.WriteLinesToFile.Execute() -> bool
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.Execute() -> bool
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateCommandLineCommands() -> string
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateResponseFileCommands() -> string
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.HandleTaskExecutionErrors() -> bool
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ResponseFileEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.XmlPeek.Execute() -> bool
-override Microsoft.Build.Tasks.XmlPoke.Execute() -> bool
-override Microsoft.Build.Tasks.XslTransformation.Execute() -> bool
-override Microsoft.Build.Tasks.ZipDirectory.Execute() -> bool
-override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureDeformatter
-override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureFormatter
-static Microsoft.Build.Tasks.CreateManifestResourceName.MakeValidEverettIdentifier(string name) -> string
-static Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.XmlToConfigurationFile(System.Xml.XmlNode input) -> string
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromAssemblyName(string assemblyName) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromFile(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManagedAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManifest(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromNativeAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.ComputeZonePermissionSet(string targetZone, System.Security.PermissionSet includedPermissionSet, string[] excludedPermissions) -> System.Security.PermissionSet
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.IdentityListToPermissionSet(string[] ids) -> System.Security.PermissionSet
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.PermissionSetToIdentityList(System.Security.PermissionSet permissionSet) -> string[]
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.XmlToPermissionSet(System.Xml.XmlElement element) -> System.Security.PermissionSet
-System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
-System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.RSAPKCS1SHA256SignatureDescription() -> void
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.set -> void
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Validate() -> void
-virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateInputs() -> bool
-virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateOutput() -> bool
-virtual Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AcceptableNonZeroExitCodes.get -> string[]
-virtual Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AcceptableNonZeroExitCodes.set -> void
\ No newline at end of file
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e2378ba70a3..00000000000
--- a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.set -> void
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.SetRidAgnosticValueForProjects() -> void
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.set -> void
-override Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Execute() -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index 942972d067e..00000000000
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,2032 +0,0 @@
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.IsSourceFile(string fileName) -> bool
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.SourceFileExtension.get -> string
-abstract Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SortName.get -> string
-abstract Microsoft.Build.Tasks.GenerateManifestBase.GetObjectType() -> System.Type
-abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
-abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
-Microsoft.Build.Tasks.AssignCulture
-Microsoft.Build.Tasks.AssignCulture.AssignCulture() -> void
-Microsoft.Build.Tasks.AssignCulture.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithCulture.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithNoCulture.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.CultureNeutralAssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.Files.set -> void
-Microsoft.Build.Tasks.AssignLinkMetadata
-Microsoft.Build.Tasks.AssignLinkMetadata.AssignLinkMetadata() -> void
-Microsoft.Build.Tasks.AssignLinkMetadata.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignLinkMetadata.Items.set -> void
-Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration
-Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignProjectConfiguration() -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.set -> void
-Microsoft.Build.Tasks.AssignTargetPath
-Microsoft.Build.Tasks.AssignTargetPath.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignTargetPath.AssignTargetPath() -> void
-Microsoft.Build.Tasks.AssignTargetPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignTargetPath.Files.set -> void
-Microsoft.Build.Tasks.AssignTargetPath.RootFolder.get -> string
-Microsoft.Build.Tasks.AssignTargetPath.RootFolder.set -> void
-Microsoft.Build.Tasks.CallTarget
-Microsoft.Build.Tasks.CallTarget.CallTarget() -> void
-Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.get -> bool
-Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.set -> void
-Microsoft.Build.Tasks.CallTarget.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CallTarget.Targets.get -> string[]
-Microsoft.Build.Tasks.CallTarget.Targets.set -> void
-Microsoft.Build.Tasks.CallTarget.UseResultsCache.get -> bool
-Microsoft.Build.Tasks.CallTarget.UseResultsCache.set -> void
-Microsoft.Build.Tasks.CodeTaskFactory
-Microsoft.Build.Tasks.CodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.CodeTaskFactory.CodeTaskFactory() -> void
-Microsoft.Build.Tasks.CodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.CodeTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.CodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.CodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.CodeTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.CombinePath
-Microsoft.Build.Tasks.CombinePath.BasePath.get -> string
-Microsoft.Build.Tasks.CombinePath.BasePath.set -> void
-Microsoft.Build.Tasks.CombinePath.CombinedPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombinePath.CombinedPaths.set -> void
-Microsoft.Build.Tasks.CombinePath.CombinePath() -> void
-Microsoft.Build.Tasks.CombinePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombinePath.Paths.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.CombineTargetFrameworkInfoProperties() -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.get -> string
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.get -> string
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.get -> bool
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.set -> void
-Microsoft.Build.Tasks.CombineXmlElements
-Microsoft.Build.Tasks.CombineXmlElements.CombineXmlElements() -> void
-Microsoft.Build.Tasks.CombineXmlElements.Result.get -> string
-Microsoft.Build.Tasks.CombineXmlElements.Result.set -> void
-Microsoft.Build.Tasks.CombineXmlElements.RootElementName.get -> string
-Microsoft.Build.Tasks.CombineXmlElements.RootElementName.set -> void
-Microsoft.Build.Tasks.CombineXmlElements.XmlElements.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombineXmlElements.XmlElements.set -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension
-Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension() -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension.GetQuotedText(string unquotedText) -> string
-Microsoft.Build.Tasks.ConvertToAbsolutePath
-Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.set -> void
-Microsoft.Build.Tasks.ConvertToAbsolutePath.ConvertToAbsolutePath() -> void
-Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.set -> void
-Microsoft.Build.Tasks.Copy
-Microsoft.Build.Tasks.Copy.Cancel() -> void
-Microsoft.Build.Tasks.Copy.CopiedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.Copy() -> void
-Microsoft.Build.Tasks.Copy.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.DestinationFiles.set -> void
-Microsoft.Build.Tasks.Copy.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Copy.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.get -> bool
-Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.set -> void
-Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Copy.Retries.get -> int
-Microsoft.Build.Tasks.Copy.Retries.set -> void
-Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.get -> int
-Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.set -> void
-Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.Copy.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.SourceFiles.set -> void
-Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.get -> bool
-Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.set -> void
-Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.get -> bool
-Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.set -> void
-Microsoft.Build.Tasks.Copy.WroteAtLeastOneFile.get -> bool
-Microsoft.Build.Tasks.CreateCSharpManifestResourceName
-Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateCSharpManifestResourceName() -> void
-Microsoft.Build.Tasks.CreateItem
-Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.get -> string[]
-Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.set -> void
-Microsoft.Build.Tasks.CreateItem.CreateItem() -> void
-Microsoft.Build.Tasks.CreateItem.Exclude.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateItem.Exclude.set -> void
-Microsoft.Build.Tasks.CreateItem.Include.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateItem.Include.set -> void
-Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.get -> bool
-Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName
-Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestResourceName() -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.itemSpecToTaskitem -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem>
-Microsoft.Build.Tasks.CreateManifestResourceName.ManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.get -> bool
-Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.get -> string
-Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.get -> bool
-Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.set -> void
-Microsoft.Build.Tasks.CreateProperty
-Microsoft.Build.Tasks.CreateProperty.CreateProperty() -> void
-Microsoft.Build.Tasks.CreateProperty.Value.get -> string[]
-Microsoft.Build.Tasks.CreateProperty.Value.set -> void
-Microsoft.Build.Tasks.CreateProperty.ValueSetByTask.get -> string[]
-Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName
-Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateVisualBasicManifestResourceName() -> void
-Microsoft.Build.Tasks.Delete
-Microsoft.Build.Tasks.Delete.Cancel() -> void
-Microsoft.Build.Tasks.Delete.Delete() -> void
-Microsoft.Build.Tasks.Delete.DeletedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Delete.DeletedFiles.set -> void
-Microsoft.Build.Tasks.Delete.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Delete.Files.set -> void
-Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.get -> bool
-Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder(string visualStudioVersion) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpId.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Message.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Error = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Info = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Warning = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.ComponentFiles.get -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.KeyFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Succeeded.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.BuildSettings() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Absolute = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.HomeSite = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Relative = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpId.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Message.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.ComponentFiles.get -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.KeyFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Succeeded.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Name.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductCode.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Name.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Product() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductCode.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest(string targetFrameworkVersion) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.FileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.All = Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture | Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Default = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsFrameworkAssembly.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsInFramework(string frameworkIdentifier, string frameworkVersion) -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsNeutralPlatform.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsStrongName.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.AssemblyManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.ExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(string name) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ClickOnceManifest = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ManagedAssembly = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.NativeAssembly = 3 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.Unspecified = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.get -> long
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ClsId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ComClass() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ThreadingModel.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.CompatibleFramework() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest(string targetFrameworkMoniker) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.FileAssociation() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.TypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.Build(string filename, string outputPath) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherBuilder(string launcherPath) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.FileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.get -> System.IO.Stream
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Manifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.OutputMessages.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles(string[] searchPaths) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo(string targetFrameworkVersion) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ValidatePlatform() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.GetArguments() -> string[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Text.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Type.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.ErrorCount.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.WarningCount.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Error = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Info = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Warning = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.BaseInterface.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.IID.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.NumMethods.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.ProxyStub() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.HasUnmanagedCodePermission.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(System.IO.Stream input) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(System.IO.Stream input) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.TrustInfo() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream input, System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Flags.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.HelpDirectory.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.ResourceId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TypeLib() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Background = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Foreground = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Days = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Hours = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Weeks = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Versioned.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass(string name, bool versioned) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.set -> void
-Microsoft.Build.Tasks.DownloadFile
-Microsoft.Build.Tasks.DownloadFile.Cancel() -> void
-Microsoft.Build.Tasks.DownloadFile.DestinationFileName.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DestinationFileName.set -> void
-Microsoft.Build.Tasks.DownloadFile.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DestinationFolder.set -> void
-Microsoft.Build.Tasks.DownloadFile.DownloadedFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DownloadedFile.set -> void
-Microsoft.Build.Tasks.DownloadFile.DownloadFile() -> void
-Microsoft.Build.Tasks.DownloadFile.Retries.get -> int
-Microsoft.Build.Tasks.DownloadFile.Retries.set -> void
-Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.get -> int
-Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.set -> void
-Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
-Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
-Microsoft.Build.Tasks.DownloadFile.Timeout.get -> int
-Microsoft.Build.Tasks.DownloadFile.Timeout.set -> void
-Microsoft.Build.Tasks.Error
-Microsoft.Build.Tasks.Error.Code.get -> string
-Microsoft.Build.Tasks.Error.Code.set -> void
-Microsoft.Build.Tasks.Error.Error() -> void
-Microsoft.Build.Tasks.Error.File.get -> string
-Microsoft.Build.Tasks.Error.File.set -> void
-Microsoft.Build.Tasks.Error.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Error.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Error.HelpLink.get -> string
-Microsoft.Build.Tasks.Error.HelpLink.set -> void
-Microsoft.Build.Tasks.Error.Text.get -> string
-Microsoft.Build.Tasks.Error.Text.set -> void
-Microsoft.Build.Tasks.ErrorFromResources
-Microsoft.Build.Tasks.ErrorFromResources.Arguments.get -> string[]
-Microsoft.Build.Tasks.ErrorFromResources.Arguments.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.Code.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.Code.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.ErrorFromResources() -> void
-Microsoft.Build.Tasks.ErrorFromResources.File.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.File.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.Resource.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.Resource.set -> void
-Microsoft.Build.Tasks.Exec
-Microsoft.Build.Tasks.Exec.Command.get -> string
-Microsoft.Build.Tasks.Exec.Command.set -> void
-Microsoft.Build.Tasks.Exec.ConsoleOutput.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.get -> bool
-Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.set -> void
-Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.get -> string
-Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.set -> void
-Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.get -> string
-Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.set -> void
-Microsoft.Build.Tasks.Exec.Exec() -> void
-Microsoft.Build.Tasks.Exec.IgnoreExitCode.get -> bool
-Microsoft.Build.Tasks.Exec.IgnoreExitCode.set -> void
-Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.get -> bool
-Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.set -> void
-Microsoft.Build.Tasks.Exec.Outputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Exec.Outputs.set -> void
-Microsoft.Build.Tasks.Exec.StdErrEncoding.get -> string
-Microsoft.Build.Tasks.Exec.StdErrEncoding.set -> void
-Microsoft.Build.Tasks.Exec.StdOutEncoding.get -> string
-Microsoft.Build.Tasks.Exec.StdOutEncoding.set -> void
-Microsoft.Build.Tasks.Exec.WorkingDirectory.get -> string
-Microsoft.Build.Tasks.Exec.WorkingDirectory.set -> void
-Microsoft.Build.Tasks.ExtractedClassName
-Microsoft.Build.Tasks.ExtractedClassName.ExtractedClassName() -> void
-Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.get -> bool
-Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.set -> void
-Microsoft.Build.Tasks.ExtractedClassName.Name.get -> string
-Microsoft.Build.Tasks.ExtractedClassName.Name.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile
-Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.FindAppConfigFile() -> void
-Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.get -> string
-Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.set -> void
-Microsoft.Build.Tasks.FindInList
-Microsoft.Build.Tasks.FindInList.CaseSensitive.get -> bool
-Microsoft.Build.Tasks.FindInList.CaseSensitive.set -> void
-Microsoft.Build.Tasks.FindInList.FindInList() -> void
-Microsoft.Build.Tasks.FindInList.FindLastMatch.get -> bool
-Microsoft.Build.Tasks.FindInList.FindLastMatch.set -> void
-Microsoft.Build.Tasks.FindInList.ItemFound.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindInList.ItemFound.set -> void
-Microsoft.Build.Tasks.FindInList.ItemSpecToFind.get -> string
-Microsoft.Build.Tasks.FindInList.ItemSpecToFind.set -> void
-Microsoft.Build.Tasks.FindInList.List.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInList.List.set -> void
-Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.get -> bool
-Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences
-Microsoft.Build.Tasks.FindInvalidProjectReferences.FindInvalidProjectReferences() -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.InvalidReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.FindUnderPath
-Microsoft.Build.Tasks.FindUnderPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.Files.set -> void
-Microsoft.Build.Tasks.FindUnderPath.FindUnderPath() -> void
-Microsoft.Build.Tasks.FindUnderPath.InPath.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.InPath.set -> void
-Microsoft.Build.Tasks.FindUnderPath.OutOfPath.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.OutOfPath.set -> void
-Microsoft.Build.Tasks.FindUnderPath.Path.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindUnderPath.Path.set -> void
-Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.get -> bool
-Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.set -> void
-Microsoft.Build.Tasks.FormatUrl
-Microsoft.Build.Tasks.FormatUrl.FormatUrl() -> void
-Microsoft.Build.Tasks.FormatUrl.InputUrl.get -> string
-Microsoft.Build.Tasks.FormatUrl.InputUrl.set -> void
-Microsoft.Build.Tasks.FormatUrl.OutputUrl.get -> string
-Microsoft.Build.Tasks.FormatUrl.OutputUrl.set -> void
-Microsoft.Build.Tasks.FormatVersion
-Microsoft.Build.Tasks.FormatVersion.FormatType.get -> string
-Microsoft.Build.Tasks.FormatVersion.FormatType.set -> void
-Microsoft.Build.Tasks.FormatVersion.FormatVersion() -> void
-Microsoft.Build.Tasks.FormatVersion.OutputVersion.get -> string
-Microsoft.Build.Tasks.FormatVersion.OutputVersion.set -> void
-Microsoft.Build.Tasks.FormatVersion.Revision.get -> int
-Microsoft.Build.Tasks.FormatVersion.Revision.set -> void
-Microsoft.Build.Tasks.FormatVersion.Version.get -> string
-Microsoft.Build.Tasks.FormatVersion.Version.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest
-Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.Files.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.GenerateApplicationManifest() -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Product.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.Product.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects
-Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.GenerateBindingRedirects() -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.get -> string
-Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest
-Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.GenerateDeploymentManifest() -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.get -> int
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.set -> void
-Microsoft.Build.Tasks.GenerateLauncher
-Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.GenerateLauncher() -> void
-Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.OutputPath.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.OutputPath.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase
-Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.Description.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.Description.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.GenerateManifestBase.GenerateManifestBase() -> void
-Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.get -> int
-Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.Platform.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.Platform.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.GenerateResource
-Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.set -> void
-Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.get -> string[]
-Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.get -> bool
-Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.get -> bool
-Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.set -> void
-Microsoft.Build.Tasks.GenerateResource.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.GenerateResource() -> void
-Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.get -> bool
-Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.set -> void
-Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.get -> bool
-Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.set -> void
-Microsoft.Build.Tasks.GenerateResource.OutputDirectory.get -> string
-Microsoft.Build.Tasks.GenerateResource.OutputDirectory.set -> void
-Microsoft.Build.Tasks.GenerateResource.OutputResources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.OutputResources.set -> void
-Microsoft.Build.Tasks.GenerateResource.PublicClass.get -> bool
-Microsoft.Build.Tasks.GenerateResource.PublicClass.set -> void
-Microsoft.Build.Tasks.GenerateResource.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.References.set -> void
-Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.Sources.set -> void
-Microsoft.Build.Tasks.GenerateResource.StateFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateResource.StateFile.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.set -> void
-Microsoft.Build.Tasks.GenerateResource.TLogReadFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.TLogWriteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.get -> string
-Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.get -> bool
-Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.set -> void
-Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.get -> bool
-Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.set -> void
-Microsoft.Build.Tasks.GenerateResource.UseSourcePath.get -> bool
-Microsoft.Build.Tasks.GenerateResource.UseSourcePath.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity
-Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity.GetAssemblyIdentity() -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform
-Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.get -> string
-Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.GetCompatiblePlatform() -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.get -> string
-Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.set -> void
-Microsoft.Build.Tasks.GetFileHash
-Microsoft.Build.Tasks.GetFileHash.Algorithm.get -> string
-Microsoft.Build.Tasks.GetFileHash.Algorithm.set -> void
-Microsoft.Build.Tasks.GetFileHash.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetFileHash.Files.set -> void
-Microsoft.Build.Tasks.GetFileHash.GetFileHash() -> void
-Microsoft.Build.Tasks.GetFileHash.Hash.get -> string
-Microsoft.Build.Tasks.GetFileHash.Hash.set -> void
-Microsoft.Build.Tasks.GetFileHash.HashEncoding.get -> string
-Microsoft.Build.Tasks.GetFileHash.HashEncoding.set -> void
-Microsoft.Build.Tasks.GetFileHash.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetFileHash.Items.set -> void
-Microsoft.Build.Tasks.GetFileHash.MetadataName.get -> string
-Microsoft.Build.Tasks.GetFileHash.MetadataName.set -> void
-Microsoft.Build.Tasks.GetFrameworkPath
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion11Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion20Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion30Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion35Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion40Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion451Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion452Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion45Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion461Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion462Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion46Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion471Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion472Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion47Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion48Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.GetFrameworkPath() -> void
-Microsoft.Build.Tasks.GetFrameworkPath.Path.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations
-Microsoft.Build.Tasks.GetInstalledSDKLocations.GetInstalledSDKLocations() -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.get -> bool
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.get -> bool
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.FullFrameworkReferenceAssemblyPaths.get -> string[]
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.GetReferenceAssemblyPaths() -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.ReferenceAssemblyPaths.get -> string[]
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.get -> bool
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.GetSDKReferenceFiles() -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.RedistFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.get -> string[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.set -> void
-Microsoft.Build.Tasks.Hash
-Microsoft.Build.Tasks.Hash.Hash() -> void
-Microsoft.Build.Tasks.Hash.HashResult.get -> string
-Microsoft.Build.Tasks.Hash.HashResult.set -> void
-Microsoft.Build.Tasks.Hash.IgnoreCase.get -> bool
-Microsoft.Build.Tasks.Hash.IgnoreCase.set -> void
-Microsoft.Build.Tasks.Hash.ItemsToHash.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Hash.ItemsToHash.set -> void
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles) -> bool
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAnalyzers(Microsoft.Build.Framework.ITaskItem[] analyzers) -> bool
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetRuleSet(string ruleSetFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject
-Microsoft.Build.Tasks.Hosting.ICscHostObject.BeginInitialization() -> void
-Microsoft.Build.Tasks.Hosting.ICscHostObject.Compile() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.EndInitialization(out string errorMessage, out int errorCode) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.IsDesignTime() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.IsUpToDate() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAddModules(string[] addModules) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAllowUnsafeBlocks(bool allowUnsafeBlocks) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetBaseAddress(string baseAddress) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCodePage(int codePage) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDebugType(string debugType) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDefineConstants(string defineConstants) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDelaySign(bool delaySignExplicitlySet, bool delaySign) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDocumentationFile(string documentationFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetEmitDebugInformation(bool emitDebugInformation) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetErrorReport(string errorReport) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetFileAlignment(int fileAlignment) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetGenerateFullPaths(bool generateFullPaths) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyContainer(string keyContainer) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyFile(string keyFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLangVersion(string langVersion) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetMainEntryPoint(string targetType, string mainEntryPoint) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetModuleAssemblyName(string moduleAssemblyName) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoConfig(bool noConfig) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoStandardLib(bool noStandardLib) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOptimize(bool optimize) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOutputAssembly(string outputAssembly) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPdbFile(string pdbFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPlatform(string platform) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTargetType(string targetType) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningLevel(int warningLevel) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Icon(string win32Icon) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Resource(string win32Resource) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject2
-Microsoft.Build.Tasks.Hosting.ICscHostObject2.SetWin32Manifest(string win32Manifest) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject3
-Microsoft.Build.Tasks.Hosting.ICscHostObject3.SetApplicationConfiguration(string applicationConfiguration) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetHighEntropyVA(bool highEntropyVA) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetSubsystemVersion(string subsystemVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.BeginInitialization() -> void
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.Compile() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.EndInitialization() -> void
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsDesignTime() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsUpToDate() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAddModules(string[] addModules) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetBaseAddress(string targetType, string baseAddress) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetCodePage(int codePage) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDebugType(bool emitDebugInformation, string debugType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDefineConstants(string defineConstants) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDelaySign(bool delaySign) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDocumentationFile(string documentationFile) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetErrorReport(string errorReport) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetFileAlignment(int fileAlignment) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetGenerateDocumentation(bool generateDocumentation) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetImports(Microsoft.Build.Framework.ITaskItem[] importsList) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyContainer(string keyContainer) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyFile(string keyFile) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetMainEntryPoint(string mainEntryPoint) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoConfig(bool noConfig) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoStandardLib(bool noStandardLib) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoWarnings(bool noWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptimize(bool optimize) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionCompare(string optionCompare) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionExplicit(bool optionExplicit) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrict(bool optionStrict) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrictType(string optionStrictType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOutputAssembly(string outputAssembly) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetPlatform(string platform) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRemoveIntegerChecks(bool removeIntegerChecks) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRootNamespace(string rootNamespace) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSdkPath(string sdkPath) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetCompactFramework(bool targetCompactFramework) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetType(string targetType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Icon(string win32Icon) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Resource(string win32Resource) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetModuleAssemblyName(string moduleAssemblyName) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetOptionInfer(bool optionInfer) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetWin32Manifest(string win32Manifest) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject3
-Microsoft.Build.Tasks.Hosting.IVbcHostObject3.SetLanguageVersion(string languageVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject4
-Microsoft.Build.Tasks.Hosting.IVbcHostObject4.SetVBRuntime(string VBRuntime) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent) -> int
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.EndCompile(bool buildSuccess) -> int
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.GetFreeThreadedHostObject() -> Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetHighEntropyVA(bool highEntropyVA) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetSubsystemVersion(string subsystemVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
-Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded.Compile() -> bool
-Microsoft.Build.Tasks.IFixedTypeInfo
-Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
-Microsoft.Build.Tasks.LC
-Microsoft.Build.Tasks.LC.LC() -> void
-Microsoft.Build.Tasks.LC.LicenseTarget.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.LC.LicenseTarget.set -> void
-Microsoft.Build.Tasks.LC.NoLogo.get -> bool
-Microsoft.Build.Tasks.LC.NoLogo.set -> void
-Microsoft.Build.Tasks.LC.OutputDirectory.get -> string
-Microsoft.Build.Tasks.LC.OutputDirectory.set -> void
-Microsoft.Build.Tasks.LC.OutputLicense.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.LC.OutputLicense.set -> void
-Microsoft.Build.Tasks.LC.ReferencedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.LC.ReferencedAssemblies.set -> void
-Microsoft.Build.Tasks.LC.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.LC.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.LC.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.LC.Sources.set -> void
-Microsoft.Build.Tasks.LC.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.LC.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.MakeDir
-Microsoft.Build.Tasks.MakeDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MakeDir.Directories.set -> void
-Microsoft.Build.Tasks.MakeDir.DirectoriesCreated.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MakeDir.MakeDir() -> void
-Microsoft.Build.Tasks.Message
-Microsoft.Build.Tasks.Message.Code.get -> string
-Microsoft.Build.Tasks.Message.Code.set -> void
-Microsoft.Build.Tasks.Message.File.get -> string
-Microsoft.Build.Tasks.Message.File.set -> void
-Microsoft.Build.Tasks.Message.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Message.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Message.Importance.get -> string
-Microsoft.Build.Tasks.Message.Importance.set -> void
-Microsoft.Build.Tasks.Message.IsCritical.get -> bool
-Microsoft.Build.Tasks.Message.IsCritical.set -> void
-Microsoft.Build.Tasks.Message.Message() -> void
-Microsoft.Build.Tasks.Message.Text.get -> string
-Microsoft.Build.Tasks.Message.Text.set -> void
-Microsoft.Build.Tasks.Move
-Microsoft.Build.Tasks.Move.Cancel() -> void
-Microsoft.Build.Tasks.Move.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.DestinationFiles.set -> void
-Microsoft.Build.Tasks.Move.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Move.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Move.Move() -> void
-Microsoft.Build.Tasks.Move.MovedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Move.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.SourceFiles.set -> void
-Microsoft.Build.Tasks.MSBuild
-Microsoft.Build.Tasks.MSBuild.BuildInParallel.get -> bool
-Microsoft.Build.Tasks.MSBuild.BuildInParallel.set -> void
-Microsoft.Build.Tasks.MSBuild.MSBuild() -> void
-Microsoft.Build.Tasks.MSBuild.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MSBuild.Projects.set -> void
-Microsoft.Build.Tasks.MSBuild.Properties.get -> string[]
-Microsoft.Build.Tasks.MSBuild.Properties.set -> void
-Microsoft.Build.Tasks.MSBuild.RebaseOutputs.get -> bool
-Microsoft.Build.Tasks.MSBuild.RebaseOutputs.set -> void
-Microsoft.Build.Tasks.MSBuild.RemoveProperties.get -> string
-Microsoft.Build.Tasks.MSBuild.RemoveProperties.set -> void
-Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.get -> bool
-Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.set -> void
-Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.get -> string
-Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.set -> void
-Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.get -> bool
-Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.set -> void
-Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.get -> string[]
-Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.set -> void
-Microsoft.Build.Tasks.MSBuild.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MSBuild.Targets.get -> string[]
-Microsoft.Build.Tasks.MSBuild.Targets.set -> void
-Microsoft.Build.Tasks.MSBuild.ToolsVersion.get -> string
-Microsoft.Build.Tasks.MSBuild.ToolsVersion.set -> void
-Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.get -> bool
-Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.set -> void
-Microsoft.Build.Tasks.MSBuild.UseResultsCache.get -> bool
-Microsoft.Build.Tasks.MSBuild.UseResultsCache.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile
-Microsoft.Build.Tasks.ReadLinesFromFile.File.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ReadLinesFromFile.File.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ReadLinesFromFile.Lines.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile.ReadLinesFromFile() -> void
-Microsoft.Build.Tasks.RemoveDir
-Microsoft.Build.Tasks.RemoveDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDir.Directories.set -> void
-Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.set -> void
-Microsoft.Build.Tasks.RemoveDir.RemoveDir() -> void
-Microsoft.Build.Tasks.RemoveDuplicates
-Microsoft.Build.Tasks.RemoveDuplicates.Filtered.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDuplicates.Filtered.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.get -> bool
-Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.Inputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDuplicates.Inputs.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.RemoveDuplicates() -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnNETStandard.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnSystemRuntime.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.RelatedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolveAssemblyReference() -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedDependencyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SatelliteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ScatterFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SerializationAssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolvedAssemblyConflicts.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.get -> string
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.get -> string
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolveCodeAnalysisRuleSet() -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolvedCodeAnalysisRuleSet.get -> string
-Microsoft.Build.Tasks.ResolveComReference
-Microsoft.Build.Tasks.ResolveComReference.DelaySign.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.DelaySign.set -> void
-Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.get -> string[]
-Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.set -> void
-Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.set -> void
-Microsoft.Build.Tasks.ResolveComReference.KeyContainer.get -> string
-Microsoft.Build.Tasks.ResolveComReference.KeyContainer.set -> void
-Microsoft.Build.Tasks.ResolveComReference.KeyFile.get -> string
-Microsoft.Build.Tasks.ResolveComReference.KeyFile.set -> void
-Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolveComReference() -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.set -> void
-Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.ResolveComReference.Silent.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.Silent.set -> void
-Microsoft.Build.Tasks.ResolveComReference.StateFile.get -> string
-Microsoft.Build.Tasks.ResolveComReference.StateFile.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.set -> void
-Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.get -> string
-Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.set -> void
-Microsoft.Build.Tasks.ResolveKeySource
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.get -> int
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.get -> int
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.KeyFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.KeyFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolveKeySource() -> void
-Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.get -> bool
-Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.get -> bool
-Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles
-Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.Files.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ResolveManifestFiles() -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.get -> string
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolveNonMSBuildProjectOutput() -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.set -> void
-Microsoft.Build.Tasks.ResolveProjectBase
-Microsoft.Build.Tasks.ResolveProjectBase.AddSyntheticProjectReferences(string currentProjectAbsolutePath) -> void
-Microsoft.Build.Tasks.ResolveProjectBase.GetProjectElement(Microsoft.Build.Framework.ITaskItem projectRef) -> System.Xml.XmlElement
-Microsoft.Build.Tasks.ResolveProjectBase.GetProjectItem(Microsoft.Build.Framework.ITaskItem projectRef) -> string
-Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.set -> void
-Microsoft.Build.Tasks.ResolveProjectBase.ResolveProjectBase() -> void
-Microsoft.Build.Tasks.ResolveSDKReference
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.References.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.ResolveSDKReference() -> void
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.set -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.RoslynCodeTaskFactory() -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.SGen
-Microsoft.Build.Tasks.SGen.BuildAssemblyName.get -> string
-Microsoft.Build.Tasks.SGen.BuildAssemblyName.set -> void
-Microsoft.Build.Tasks.SGen.BuildAssemblyPath.get -> string
-Microsoft.Build.Tasks.SGen.BuildAssemblyPath.set -> void
-Microsoft.Build.Tasks.SGen.DelaySign.get -> bool
-Microsoft.Build.Tasks.SGen.DelaySign.set -> void
-Microsoft.Build.Tasks.SGen.KeyContainer.get -> string
-Microsoft.Build.Tasks.SGen.KeyContainer.set -> void
-Microsoft.Build.Tasks.SGen.KeyFile.get -> string
-Microsoft.Build.Tasks.SGen.KeyFile.set -> void
-Microsoft.Build.Tasks.SGen.Platform.get -> string
-Microsoft.Build.Tasks.SGen.Platform.set -> void
-Microsoft.Build.Tasks.SGen.References.get -> string[]
-Microsoft.Build.Tasks.SGen.References.set -> void
-Microsoft.Build.Tasks.SGen.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.SGen.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.SGen.SerializationAssembly.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SGen.SerializationAssembly.set -> void
-Microsoft.Build.Tasks.SGen.SerializationAssemblyName.get -> string
-Microsoft.Build.Tasks.SGen.SGen() -> void
-Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.get -> bool
-Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.set -> void
-Microsoft.Build.Tasks.SGen.Types.get -> string[]
-Microsoft.Build.Tasks.SGen.Types.set -> void
-Microsoft.Build.Tasks.SGen.UseKeep.get -> bool
-Microsoft.Build.Tasks.SGen.UseKeep.set -> void
-Microsoft.Build.Tasks.SGen.UseProxyTypes.get -> bool
-Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
-Microsoft.Build.Tasks.SignFile
-Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
-Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-Microsoft.Build.Tasks.SignFile.SignFile() -> void
-Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
-Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.get -> string
-Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.set -> void
-Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.SignFile.TimestampUrl.get -> string
-Microsoft.Build.Tasks.SignFile.TimestampUrl.set -> void
-Microsoft.Build.Tasks.TaskExtension
-Microsoft.Build.Tasks.TaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.TaskLoggingHelperExtension
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskLoggingHelperExtension(Microsoft.Build.Framework.ITask taskInstance, System.Resources.ResourceManager primaryResources, System.Resources.ResourceManager sharedResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.set -> void
-Microsoft.Build.Tasks.Telemetry
-Microsoft.Build.Tasks.Telemetry.EventData.get -> string
-Microsoft.Build.Tasks.Telemetry.EventData.set -> void
-Microsoft.Build.Tasks.Telemetry.EventName.get -> string
-Microsoft.Build.Tasks.Telemetry.EventName.set -> void
-Microsoft.Build.Tasks.Telemetry.Telemetry() -> void
-Microsoft.Build.Tasks.ToolTaskExtension
-Microsoft.Build.Tasks.ToolTaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.Touch
-Microsoft.Build.Tasks.Touch.AlwaysCreate.get -> bool
-Microsoft.Build.Tasks.Touch.AlwaysCreate.set -> void
-Microsoft.Build.Tasks.Touch.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Touch.Files.set -> void
-Microsoft.Build.Tasks.Touch.ForceTouch.get -> bool
-Microsoft.Build.Tasks.Touch.ForceTouch.set -> void
-Microsoft.Build.Tasks.Touch.Time.get -> string
-Microsoft.Build.Tasks.Touch.Time.set -> void
-Microsoft.Build.Tasks.Touch.Touch() -> void
-Microsoft.Build.Tasks.Touch.TouchedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Touch.TouchedFiles.set -> void
-Microsoft.Build.Tasks.Unzip
-Microsoft.Build.Tasks.Unzip.Cancel() -> void
-Microsoft.Build.Tasks.Unzip.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Unzip.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Unzip.Exclude.get -> string
-Microsoft.Build.Tasks.Unzip.Exclude.set -> void
-Microsoft.Build.Tasks.Unzip.Include.get -> string
-Microsoft.Build.Tasks.Unzip.Include.set -> void
-Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.Unzip.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Unzip.SourceFiles.set -> void
-Microsoft.Build.Tasks.Unzip.Unzip() -> void
-Microsoft.Build.Tasks.VerifyFileHash
-Microsoft.Build.Tasks.VerifyFileHash.Algorithm.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.Algorithm.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.File.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.File.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.Hash.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.Hash.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.VerifyFileHash() -> void
-Microsoft.Build.Tasks.Warning
-Microsoft.Build.Tasks.Warning.Code.get -> string
-Microsoft.Build.Tasks.Warning.Code.set -> void
-Microsoft.Build.Tasks.Warning.File.get -> string
-Microsoft.Build.Tasks.Warning.File.set -> void
-Microsoft.Build.Tasks.Warning.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Warning.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Warning.HelpLink.get -> string
-Microsoft.Build.Tasks.Warning.HelpLink.set -> void
-Microsoft.Build.Tasks.Warning.Text.get -> string
-Microsoft.Build.Tasks.Warning.Text.set -> void
-Microsoft.Build.Tasks.Warning.Warning() -> void
-Microsoft.Build.Tasks.WriteCodeFragment
-Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.Language.get -> string
-Microsoft.Build.Tasks.WriteCodeFragment.Language.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.WriteCodeFragment() -> void
-Microsoft.Build.Tasks.WriteLinesToFile
-Microsoft.Build.Tasks.WriteLinesToFile.Encoding.get -> string
-Microsoft.Build.Tasks.WriteLinesToFile.Encoding.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.File.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteLinesToFile.File.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WriteLinesToFile.Lines.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.get -> bool
-Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.WriteLinesToFile() -> void
-Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.get -> bool
-Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.set -> void
-Microsoft.Build.Tasks.XamlTaskFactory
-Microsoft.Build.Tasks.XamlTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.XamlTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.XamlTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.XamlTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.XamlTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.XamlTaskFactory.XamlTaskFactory() -> void
-Microsoft.Build.Tasks.XmlPeek
-Microsoft.Build.Tasks.XmlPeek.Namespaces.get -> string
-Microsoft.Build.Tasks.XmlPeek.Namespaces.set -> void
-Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.get -> bool
-Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.set -> void
-Microsoft.Build.Tasks.XmlPeek.Query.get -> string
-Microsoft.Build.Tasks.XmlPeek.Query.set -> void
-Microsoft.Build.Tasks.XmlPeek.Result.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XmlPeek.XmlContent.get -> string
-Microsoft.Build.Tasks.XmlPeek.XmlContent.set -> void
-Microsoft.Build.Tasks.XmlPeek.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPeek.XmlInputPath.set -> void
-Microsoft.Build.Tasks.XmlPeek.XmlPeek() -> void
-Microsoft.Build.Tasks.XmlPoke
-Microsoft.Build.Tasks.XmlPoke.Namespaces.get -> string
-Microsoft.Build.Tasks.XmlPoke.Namespaces.set -> void
-Microsoft.Build.Tasks.XmlPoke.Query.get -> string
-Microsoft.Build.Tasks.XmlPoke.Query.set -> void
-Microsoft.Build.Tasks.XmlPoke.Value.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPoke.Value.set -> void
-Microsoft.Build.Tasks.XmlPoke.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPoke.XmlInputPath.set -> void
-Microsoft.Build.Tasks.XmlPoke.XmlPoke() -> void
-Microsoft.Build.Tasks.XslTransformation
-Microsoft.Build.Tasks.XslTransformation.OutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XslTransformation.OutputPaths.set -> void
-Microsoft.Build.Tasks.XslTransformation.Parameters.get -> string
-Microsoft.Build.Tasks.XslTransformation.Parameters.set -> void
-Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.get -> bool
-Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.set -> void
-Microsoft.Build.Tasks.XslTransformation.XmlContent.get -> string
-Microsoft.Build.Tasks.XslTransformation.XmlContent.set -> void
-Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslContent.get -> string
-Microsoft.Build.Tasks.XslTransformation.XslContent.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XslTransformation.XslInputPath.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslTransformation() -> void
-Microsoft.Build.Tasks.ZipDirectory
-Microsoft.Build.Tasks.ZipDirectory.DestinationFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ZipDirectory.DestinationFile.set -> void
-Microsoft.Build.Tasks.ZipDirectory.Overwrite.get -> bool
-Microsoft.Build.Tasks.ZipDirectory.Overwrite.set -> void
-Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.set -> void
-Microsoft.Build.Tasks.ZipDirectory.ZipDirectory() -> void
-override Microsoft.Build.Tasks.AssignCulture.Execute() -> bool
-override Microsoft.Build.Tasks.AssignLinkMetadata.Execute() -> bool
-override Microsoft.Build.Tasks.AssignProjectConfiguration.Execute() -> bool
-override Microsoft.Build.Tasks.AssignTargetPath.Execute() -> bool
-override Microsoft.Build.Tasks.CallTarget.Execute() -> bool
-override Microsoft.Build.Tasks.CombinePath.Execute() -> bool
-override Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Execute() -> bool
-override Microsoft.Build.Tasks.CombineXmlElements.Execute() -> bool
-override Microsoft.Build.Tasks.ConvertToAbsolutePath.Execute() -> bool
-override Microsoft.Build.Tasks.Copy.Execute() -> bool
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.IsSourceFile(string fileName) -> bool
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.SourceFileExtension.get -> string
-override Microsoft.Build.Tasks.CreateItem.Execute() -> bool
-override Microsoft.Build.Tasks.CreateManifestResourceName.Execute() -> bool
-override Microsoft.Build.Tasks.CreateProperty.Execute() -> bool
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.IsSourceFile(string fileName) -> bool
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.SourceFileExtension.get -> string
-override Microsoft.Build.Tasks.Delete.Execute() -> bool
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.set -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Validate() -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.set -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Validate() -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ToString() -> string
-override Microsoft.Build.Tasks.DownloadFile.Execute() -> bool
-override Microsoft.Build.Tasks.Error.Execute() -> bool
-override Microsoft.Build.Tasks.ErrorFromResources.Execute() -> bool
-override Microsoft.Build.Tasks.Exec.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.Exec.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
-override Microsoft.Build.Tasks.Exec.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.Exec.GetWorkingDirectory() -> string
-override Microsoft.Build.Tasks.Exec.HandleTaskExecutionErrors() -> bool
-override Microsoft.Build.Tasks.Exec.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
-override Microsoft.Build.Tasks.Exec.LogPathToTool(string toolName, string pathToTool) -> void
-override Microsoft.Build.Tasks.Exec.LogToolCommand(string message) -> void
-override Microsoft.Build.Tasks.Exec.StandardErrorEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Exec.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-override Microsoft.Build.Tasks.Exec.StandardOutputEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Exec.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-override Microsoft.Build.Tasks.Exec.ToolName.get -> string
-override Microsoft.Build.Tasks.Exec.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.FindAppConfigFile.Execute() -> bool
-override Microsoft.Build.Tasks.FindInList.Execute() -> bool
-override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
-override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
-override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
-override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
-override Microsoft.Build.Tasks.GetAssemblyIdentity.Execute() -> bool
-override Microsoft.Build.Tasks.GetCompatiblePlatform.Execute() -> bool
-override Microsoft.Build.Tasks.GetFileHash.Execute() -> bool
-override Microsoft.Build.Tasks.GetFrameworkPath.Execute() -> bool
-override Microsoft.Build.Tasks.GetInstalledSDKLocations.Execute() -> bool
-override Microsoft.Build.Tasks.GetReferenceAssemblyPaths.Execute() -> bool
-override Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute() -> bool
-override Microsoft.Build.Tasks.Hash.Execute() -> bool
-override Microsoft.Build.Tasks.LC.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.LC.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.LC.Execute() -> bool
-override Microsoft.Build.Tasks.LC.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.LC.ToolName.get -> string
-override Microsoft.Build.Tasks.LC.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.MakeDir.Execute() -> bool
-override Microsoft.Build.Tasks.Message.Execute() -> bool
-override Microsoft.Build.Tasks.Move.Execute() -> bool
-override Microsoft.Build.Tasks.MSBuild.Execute() -> bool
-override Microsoft.Build.Tasks.ReadLinesFromFile.Execute() -> bool
-override Microsoft.Build.Tasks.RemoveDir.Execute() -> bool
-override Microsoft.Build.Tasks.RemoveDuplicates.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveAssemblyReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveComReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveKeySource.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveManifestFiles.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveSDKReference.Execute() -> bool
-override Microsoft.Build.Tasks.SGen.Execute() -> bool
-override Microsoft.Build.Tasks.SGen.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.SGen.ToolName.get -> string
-override Microsoft.Build.Tasks.SignFile.Execute() -> bool
-override Microsoft.Build.Tasks.TaskLoggingHelperExtension.FormatResourceString(string resourceName, params object[] args) -> string
-override Microsoft.Build.Tasks.Telemetry.Execute() -> bool
-override Microsoft.Build.Tasks.Touch.Execute() -> bool
-override Microsoft.Build.Tasks.Unzip.Execute() -> bool
-override Microsoft.Build.Tasks.VerifyFileHash.Execute() -> bool
-override Microsoft.Build.Tasks.Warning.Execute() -> bool
-override Microsoft.Build.Tasks.WriteCodeFragment.Execute() -> bool
-override Microsoft.Build.Tasks.WriteLinesToFile.Execute() -> bool
-override Microsoft.Build.Tasks.XmlPeek.Execute() -> bool
-override Microsoft.Build.Tasks.XmlPoke.Execute() -> bool
-override Microsoft.Build.Tasks.XslTransformation.Execute() -> bool
-override Microsoft.Build.Tasks.ZipDirectory.Execute() -> bool
-override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureDeformatter
-override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureFormatter
-static Microsoft.Build.Tasks.CreateManifestResourceName.MakeValidEverettIdentifier(string name) -> string
-static Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.XmlToConfigurationFile(System.Xml.XmlNode input) -> string
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromAssemblyName(string assemblyName) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromFile(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManagedAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManifest(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromNativeAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
-System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
-System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.RSAPKCS1SHA256SignatureDescription() -> void
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.set -> void
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Validate() -> void
-virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateInputs() -> bool
-virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateOutput() -> bool
\ No newline at end of file
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index 176cca35d60..00000000000
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.set -> void
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.SetRidAgnosticValueForProjects() -> void
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.set -> void
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
-override Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Execute() -> bool
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 6695d3196f9..80e55c6aaca 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -24,7 +24,7 @@ namespace Microsoft.Build.Tasks
     /// <comment>
     /// This task executes following steps:
     ///   (1) Filter out Framework assemblies
-    ///   (2) Filter out non-existant files
+    ///   (2) Filter out non-existent files
     ///   (3) Build list of Dependencies from built items with CopyLocal=True
     ///   (4) Build list of Prerequisites from built items with CopyLocal=False
     ///   (5) Build list of Satellites from built items based on TargetCulture
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index f45d483f733..9936453c588 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -25,6 +25,14 @@ public class ResolveSDKReference : TaskExtension
     {
         #region fields
 
+        /// <summary>
+        /// Platform aliases
+        /// </summary>
+        private static readonly Dictionary<string, string> PlatformAliases = new(StringComparer.OrdinalIgnoreCase)
+        {
+            { "UAP", "Windows" }
+        };
+
         /// <summary>
         /// Regex for breaking up the sdk reference include into pieces.
         /// Example: XNA, Version=8.0
@@ -1251,7 +1259,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                     AddResolutionWarning("ResolveSDKReference.MaxPlatformVersionNotSpecified", projectName, DisplayName, Version, targetPlatformIdentifier, targetPlatformVersionFromItem.ToString(), targetPlatformIdentifier, targetPlatformVersion.ToString());
                 }
 
-                if (!String.IsNullOrEmpty(TargetPlatform) && !String.Equals(targetPlatformIdentifier, TargetPlatform))
+                if (!String.IsNullOrEmpty(TargetPlatform) && !String.Equals(targetPlatformIdentifier, TargetPlatform) && (!PlatformAliases.TryGetValue(TargetPlatform, out string platform) || !String.Equals(targetPlatformIdentifier, platform, StringComparison.OrdinalIgnoreCase)))
                 {
                     AddResolutionErrorOrWarning("ResolveSDKReference.TargetPlatformIdentifierDoesNotMatch", projectName, DisplayName, Version, targetPlatformIdentifier, TargetPlatform);
                 }
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index a128fd658e2..d824b1f8d91 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -251,6 +251,10 @@
     <value>Could not use a link to copy "{0}" to "{1}". Copying the file instead. {2}</value>
     <comment>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</comment>
   </data>
+  <data name="Copy.RetryingAsSymbolicLink">
+    <value>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</value>
+    <comment>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</comment>
+  </data>
   <data name="Copy.NeedsDestination">
     <value>MSB3023: No destination specified for Copy. Please supply either "{0}" or "{1}".</value>
     <comment>{StrBegin="MSB3023: "}</comment>
@@ -1615,6 +1619,12 @@
         LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name. "CopyLocalDependenciesWhenParentReferenceInGac" is a property name.
    </comment>
   </data>
+  <data name="ResolveAssemblyReference.NoBecauseBadImage">
+    <value>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</value>
+    <comment>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </comment>
+  </data>
   <data name="ResolveAssemblyReference.NotCopyLocalBecauseEmbedded">
     <value>This reference is not "CopyLocal" because its types will be embedded into the target assembly.</value>
     <comment>
@@ -2726,9 +2736,6 @@
         MSB3891 - MSB3900   Targets: Copy Overflow
         If this bucket overflows, pls. contact 'vsppbdev'.
   -->
-  <data name="Copy.ExactlyOneTypeOfLink">
-    <value>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</value>
-  </data>
   <data name="Copy.ErrorIfLinkFailsSetWithoutLinkOption" xml:space="preserve">
     <value>MSB3892: ErrorIfLinkFails requires UseHardlinksIfPossible or UseSymbolicLinksIfPossible to be set.</value>
     <comment>{StrBegin="MSB3892: "} LOCALIZATION: Do not localize "ErrorIfLinkFails", "UseHardLinksIfPossible", or "UseSymbolicLinksIfPossible".</comment>
@@ -2832,6 +2839,9 @@
   <data name="Unzip.DidNotUnzipBecauseOfFilter">
     <value>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</value>
   </data>
+  <data name="Unzip.ZipSlipExploit">
+    <value>Entry is outside the target directory: "{0}"</value>
+  </data>
   <data name="Unzip.FileComment">
     <value>Unzipping file "{0}" to "{1}".</value>
   </data>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 8814629bec1..37e133a2806 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Probíhá odebírání atributu pouze pro čtení z položky {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Zdrojový soubor {0} je ve skutečnosti adresář.  Úloha kopírování nepodporuje kopírování adresářů.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">Umístění AssemblyFoldersEx: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Byla uvažována umístění AssemblyFoldersEx.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">Soubor {0} se rozzipovává do {1}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: {1} je neplatná hodnota parametru {0}.  Platné hodnoty jsou : {2}.</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Konfigurační soubor AssemblyFolder ({0}) zadaný v Microsoft.Common.CurrentVersion.targets byl neplatný. Chyba: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: V souboru projektu jste zadali jak položku {0}, tak i {1}. Zvolte buď jednu, nebo druhou.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: Nešlo přečíst existující soubor {0}, aby se zjistilo, jestli je jeho obsah aktuální. Přepíše se.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 34a490ed1d1..4c37c0de5e9 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Das schreibgeschützte Attribut wird aus "{0}" entfernt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Die Quelldatei "{0}" ist keine Datei, sondern ein Verzeichnis.  Mit der Copy-Aufgabe können keine Verzeichnisse kopiert werden.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">Speicherort von AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Berücksichtigte Speicherorte von AssemblyFoldersEx.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">Die Datei "{0}" wird in "{1}" entzippt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" ist ein ungültiger Wert für den Parameter "{0}". Gültige Werte sind: {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Die in Microsoft.Common.CurrentVersion.targets festgelegte AssemblyFolder-Konfigurationsdatei ({0}) ist ungültig. Fehler: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: "{0}" und "{1}" wurden in der Projektdatei angegeben. Verwenden Sie nur einen dieser Werte.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: Die vorhandene Datei "{0}" konnte nicht gelesen werden, um zu bestimmen, ob ihr Inhalt aktuell ist. Die Datei wird überschrieben.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index f8474cd8820..c777b61b72a 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Se quitará el atributo de solo lectura de "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: El archivo de origen "{0}" es un directorio.  La tarea "Copy" no permite copiar directorios.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">Ubicación de AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Ubicaciones de AssemblyFoldersEx consideradas.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">Descomprimiendo el archivo "{0}" en "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" no es un valor válido para el parámetro "{0}".  Los valores válidos son: {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">El archivo de configuración ('{0}') de AssemblyFolder especificado en Microsoft.Common.CurrentVersion.targets no es válido. Error: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: Se especificó "{0}" y "{1}" en el archivo de proyecto. Elija solo uno de los dos.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: No se pudo leer el archivo existente "{0}"para determinar si su contenido está actualizado. Sobrescribiéndolo.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index fb4965cc9e3..c2b46ad0e05 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Suppression de l'attribut de lecture seule de "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Le fichier source "{0}" est en fait un répertoire.  La tâche "Copy" ne prend pas en charge la copie des répertoires.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">Emplacement d'AssemblyFoldersEx : "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Emplacements d'AssemblyFoldersEx envisagés.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">Décompression du fichier "{0}" dans "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" n'est pas une valeur valide pour le paramètre "{0}". Les valeurs valides sont : {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Le fichier config AssemblyFolder ('{0}') spécifié dans Microsoft.Common.CurrentVersion.targets est non valide. Erreur : {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: "{0}" et "{1}" ont été spécifiés dans le fichier projet. Choisissez l'un ou l'autre.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: Impossible de lire le fichier existant "{0}" pour déterminer si son contenu est à jour. Remplacement du fichier.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index a00f3a2e2de..cc7bc3dca94 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Rimozione dell'attributo di sola lettura da "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: il file di origine "{0}" è in realtà una directory. L'attività "Copia" non supporta la copia di directory.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">Percorso AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Percorsi AssemblyFoldersEx considerati.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">Decompressione del file "{0}" in "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" è un valore non valido per il parametro "{0}". I valori validi sono: {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Il file config AssemblyFolder ('{0}') specificato in Microsoft.Common.CurrentVersion.targets non è valido. Errore: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: nel file di progetto sono stati specificati sia "{0}" che "{1}". Sceglierne uno.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: non è stato possibile leggere il file esistente "{0}" per determinare se il relativo contenuto è aggiornato. Verrà sovrascritto.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index b4dd3d4c9e0..6d2d47ce825 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -201,6 +201,11 @@
         <target state="translated">"{0}" から読み取り専用属性を削除しています。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: ソース ファイル "{0}" はディレクトリです。"Copy" タスクはディレクトリのコピーをサポートしません。</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">AssemblyFoldersEx の場所:"{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">AssemblyFoldersEx の場所が考慮されました。</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">ファイル "{0}" を "{1}" に解凍しています。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" は "{0}" パラメーターに対して無効な値です。有効な値は {2} です。</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets に指定されている AssemblyFolder 構成ファイル ('{0}') が無効です。エラー: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: "{0}" と "{1}" の両方がプロジェクト ファイルで指定されました。いずれか 1 つを選択してください。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: ファイル "{0}" のコンテンツが最新であるかを判断するため、そのファイルを読み取ることができませんでした。ファイルは上書きされます。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index 90b1ad0ff3b..b9e078753f1 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -201,6 +201,11 @@
         <target state="translated">"{0}"에서 읽기 전용 특성을 제거하고 있습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 소스 파일 "{0}"은(는) 실제로 디렉터리입니다.  "Copy" 작업으로는 디렉터리를 복사할 수 없습니다.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">AssemblyFoldersEx 위치: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">AssemblyFoldersEx 위치로 간주했습니다.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">파일 "{0}"의 압축을 "{1}"에 푸는 중입니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}"은(는) "{0}" 매개 변수에 사용할 수 없는 값입니다.  유효한 값은 {2}입니다.</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets에 지정된 AssemblyFolder 구성 파일('{0}')이 잘못되었습니다. 오류: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: 프로젝트 파일에서 "{0}" 및 "{1}"을(를) 모두 지정했습니다. 둘 중 하나만 선택하세요.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: 기존 파일 "{0}"을(를) 읽을 수 없어 콘텐츠가 최신 상태인지 확인할 수 없습니다. 덮어씁니다.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 57e040f6e97..527cad494c5 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Usuwanie atrybutu tylko do odczytu z elementu „{0}”.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Plik źródłowy „{0}” jest w rzeczywistości katalogiem.  Zadanie „Copy” nie obsługuje kopiowania katalogów.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">Lokalizacja klucza rejestru AssemblyFoldersEx: „{0}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Wybrano lokalizacje klucza rejestru AssemblyFoldersEx.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">Rozpakowywanie pliku „{0}” do pliku „{1}”.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: „{1}” jest nieprawidłową wartością parametru „{0}”.  Prawidłowe wartości: {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Plik konfiguracji AssemblyFolder („{0}”) określony w elemencie Microsoft.Common.CurrentVersion.targets był nieprawidłowy. Błąd: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: W pliku projektu określono elementy „{0}” i „{1}”. Wybierz jeden z nich.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: nie można odczytać istniejącego pliku „{0}” w celu sprawdzenia, czy jego zawartość jest aktualna. Zostanie on zastąpiony.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 5f825ffffa4..14a8a58fd48 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Removendo o atributo somente leitura de "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: O arquivo de origem "{0}" é, na verdade, um diretório.  A tarefa "Copy" não dá suporte à cópia de diretórios.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">Localização de AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Localizações de AssemblyFoldersEx consideradas.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">Descompactando o arquivo "{0}" em "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" é um nome inválido para o parâmetro "{0}".  Os valores válidos são: {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">O arquivo de configuração AssemblyFolder ('{0}') especificado em Microsoft.Common.CurrentVersion.targets era inválido. O erro era: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: "{0}" e "{1}" foram especificados no arquivo do projeto. Escolha um ou outro.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: não foi possível ler o arquivo existente "{0}" para determinar se seus conteúdos estão atualizados. Substituindo-o.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 0c7a66933a5..2c1b47e4804 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Удаление доступного только для чтения атрибута из "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: исходный файл "{0}" в действительности является каталогом.  Задача Copy не поддерживает копирование каталогов.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">Расположение AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Рассмотрены расположения AssemblyFoldersEx.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">Распаковка файла "{0}" в"{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" — недопустимое значение для параметра "{0}".  Допустимые значения: {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Файл конфигурации AssemblyFolder ("{0}"), указанный в Microsoft.Common.CurrentVersion.targets, недопустим. Ошибка: {1}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: в файле проекта указан как "{0}", так и "{1}". Укажите только один из них.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: не удалось считать данные из существующего файла ("{0}") и определить, актуально ли его содержимое. Файл перезаписывается.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 077758b4edd..33d1387e148 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -201,6 +201,11 @@
         <target state="translated">"{0}" öğesinin salt okunur özniteliği kaldırılıyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: "{0}" kaynak dosyası aslında bir dizindir.  "Kopyala" görevi, dizinleri kopyalamayı desteklemez.</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">AssemblyFoldersEx konumu: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">AssemblyFoldersEx konumları dikkate alındı.</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">"{0}" dosyasının sıkıştırması "{1}" hedefine açılıyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" değeri, "{0}" parametresi için geçersiz.  Geçerli değerler şunlardır: {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets içinde belirtilen AssemblyFolder yapılandırma dosyası ('{0}') geçersiz. Hata: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: Proje dosyasında hem "{0}" hem de "{1}" belirtilmiş. Lütfen yalnızca birini seçin.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: İçeriğinin güncel olup olmadığını belirlemek üzere "{0}" adlı mevcut dosya okunamadı. Dosyanın üzerine yazılıyor.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.xlf b/src/Tasks/Resources/xlf/Strings.xlf
index 0fb97061f54..c4900cd99f9 100644
--- a/src/Tasks/Resources/xlf/Strings.xlf
+++ b/src/Tasks/Resources/xlf/Strings.xlf
@@ -2387,10 +2387,6 @@
         <source>The AssemblyFolder config file ('{0}') specified in Microsoft.Common.CurrentVersion.targets was invalid. The error was: {1}</source>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <note>{StrBegin="MSB3491: "}</note>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 26b89d23285..5979367e5cd 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -201,6 +201,11 @@
         <target state="translated">正在从“{0}”中移除只读特性。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 源文件“{0}”实际上是一个目录。“Copy”任务不支持复制目录。</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">AssemblyFoldersEx 位置:“{0}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">已考虑 AssemblyFoldersEx 位置。</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">将文件“{0}”解压缩到“{1}”。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: “{1}”是无效的“{0}”参数值。有效值为: {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets 中指定的 AssemblyFolder 配置文件(“{0}”)无效。错误为: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: 项目文件中同时指定了“{0}”和“{1}”。请任选其一。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: 无法读取现有文件“{0}”以确定其内容是否是最新的。覆盖此文件。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index ad011ed8d31..8f0aef6d180 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -201,6 +201,11 @@
         <target state="translated">正在從 "{0}" 移除唯讀屬性。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 來源檔案 "{0}" 其實是目錄。"Copy" 工作不支援複製目錄。</target>
@@ -1612,6 +1617,13 @@
         <target state="translated">AssemblyFoldersEx 位置: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">已考慮 AssemblyFoldersEx 位置。</target>
@@ -2590,6 +2602,11 @@
         <target state="translated">正在將檔案 "{0}" 解壓縮到 "{1}"。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" 是 "{0}" 參數的無效值。有效值為: {2}</target>
@@ -3275,11 +3292,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets 中所指定的 AssemblyFolder 組態檔 ('{0}') 無效。錯誤為: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: 專案檔中已同時指定 "{0}" 和 "{1}"。請選擇使用其中一個。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: 無法讀取現有的檔案 "{0}"，所以無法判斷其是否包含最新的內容。將予覆寫。</target>
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 40a6acd512b..eff8d18aec5 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -156,6 +156,8 @@ public override bool Execute()
         /// <param name="destinationDirectory">The <see cref="DirectoryInfo"/> to extract files to.</param>
         private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)
         {
+            string fullDestinationDirectoryPath = Path.GetFullPath(FileUtilities.EnsureTrailingSlash(destinationDirectory.FullName));
+
             foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
             {
                 if (ShouldSkipEntry(zipArchiveEntry))
@@ -164,7 +166,10 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
                     continue;
                 }
 
-                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));
+                string fullDestinationPath = Path.GetFullPath(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));
+                ErrorUtilities.VerifyThrowInvalidOperation(fullDestinationPath.StartsWith(fullDestinationDirectoryPath, FileUtilities.PathComparison), "Unzip.ZipSlipExploit", fullDestinationPath);
+
+                FileInfo destinationPath = new(fullDestinationPath);
 
                 // Zip archives can have directory entries listed explicitly.
                 // If this entry is a directory we should create it and move to the next entry.
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index b0eab96849c..73fc516867b 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -158,7 +158,7 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
             //  - or xml content with the current dir prepended (like "/foo/bar/<abc .. />"),
             //    but not on Windows
             //
-            // On Windows, this means that @contentOrFile is really a non-existant file name
+            // On Windows, this means that @contentOrFile is really a non-existent file name
             if (NativeMethodsShared.IsWindows)
                 throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Xaml.RuleFileNotFound", maybeFullPath));
             else // On !Windows, try parsing as XML
diff --git a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
index a66d88e48dc..36670c64bc3 100644
--- a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
+++ b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.IO;
+using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -283,5 +284,29 @@ public void TestLogFromException()
                 engine.AssertLogContains("InvalidOperationException");
             }
         }
+
+        /// <summary>
+        /// Verify that <see cref="TaskLoggingHelper.LogErrorFromException(Exception, bool, bool, string)" /> logs inner exceptions from an <see cref="AggregateException" />.
+        /// </summary>
+        [Fact]
+        public void TestLogFromExceptionWithAggregateException()
+        {
+            AggregateException aggregateException = new AggregateException(
+                new InvalidOperationException("The operation was invalid"),
+                new IOException("An I/O error occurred"));
+
+            MockEngine engine = new MockEngine();
+            MockTask task = new MockTask
+            {
+                BuildEngine = engine
+            };
+
+            task.Log.LogErrorFromException(aggregateException);
+
+            engine.Errors.ShouldBe(2);
+
+            engine.AssertLogContains("The operation was invalid");
+            engine.AssertLogContains("An I/O error occurred");
+        }
     }
 }
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 7a1f034a25c..ad43b36401b 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -796,6 +796,7 @@ public void TestGetDotNetFrameworkSdkRootRegistryKey()
             string fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK471 = @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.1\WinSDK-NetFx40Tools-x86";
             string fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK472 = @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.2\WinSDK-NetFx40Tools-x86";
             string fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48 = @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86";
+            string fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK481 = @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1\WinSDK-NetFx40Tools-x86";
 
             // v4.0
             ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version40, VisualStudioVersion.Version100).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK70A);
@@ -863,9 +864,20 @@ public void TestGetDotNetFrameworkSdkRootRegistryKey()
             Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version120));
             Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version140));
             ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version150).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48);
+            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version160).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48);
+            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version170).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48);
+
+            // v4.8.1
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version100));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version110));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version120));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version140));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version150));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version160));
+            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version170).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK481);
 
             // Latest
-            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Latest, VisualStudioVersion.Version150).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48);
+            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Latest, VisualStudioVersion.Version170).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK481);
         }
 
         [Fact]
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..993613f410e
--- /dev/null
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -0,0 +1,56 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
+       This is intentional, because you can only use MSBuild in the context of a .NET SDK
+       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
+       have previously shipped netstandard2.0 packages, and if you want to support both
+       runtime contexts it still makes sense to target that. -->
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETCoreApp,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.1</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.2</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.3</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETStandard,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Tizen,Version=v4.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>UAP,Version=v10.0.15064</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation3,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation4,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStationVita,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.Xbox360,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.XboxOne,Version=v0.0</Target>
+  </Suppression>
+</Suppressions>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index b5e520f25a3..64fa68b16e5 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -15,6 +15,7 @@
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which is used to implement custom MSBuild tasks.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">full</ApplyNgenOptimization>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index 0c8ceeed580..00000000000
--- a/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,583 +0,0 @@
-abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
-abstract Microsoft.Build.Utilities.Logger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-abstract Microsoft.Build.Utilities.Task.Execute() -> bool
-abstract Microsoft.Build.Utilities.ToolTask.GenerateFullPathToTool() -> string
-abstract Microsoft.Build.Utilities.ToolTask.ToolName.get -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.AMD64 = "AMD64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.ARM = "ARM" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.ARM64 = "ARM64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.IA64 = "IA64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.MSIL = "MSIL" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.X86 = "x86" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.APPX = "APPX" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.AppxLocation = "AppxLocation" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyLocalExpandedReferenceAssemblies = "CopyLocalExpandedReferenceAssemblies" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedist = "CopyRedist" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedistToSubDirectory = "CopyRedistToSubDirectory" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.DependsOnSDK = "DependsOn" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.DisplayName = "DisplayName" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.ExpandReferenceAssemblies = "ExpandReferenceAssemblies" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.FrameworkIdentity = "FrameworkIdentity" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxOSVersionTested = "MaxOSVersionTested" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxPlatformVersion = "MaxPlatformVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MinOSVersion = "MinOSVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MinVSVersion = "MinVSVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MoreInfo = "MoreInfo" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.PlatformIdentity = "PlatformIdentity" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.ProductFamilyName = "ProductFamilyName" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SDKType = "SDKType" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportedArchitectures = "SupportedArchitectures" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportPrefer32Bit = "SupportPrefer32Bit" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportsMultipleVersions = "SupportsMultipleVersions" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDK = "TargetedSDKArchitecture" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDKConfiguration = "TargetedSDKConfiguration" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatform = "TargetPlatform" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformMinVersion = "TargetPlatformMinVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformVersion = "TargetPlatformVersion" -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem sourceFile, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Framework.ITaskItem[] outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.ComputeSourcesNeedingCompilation() -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.ComputeSourcesNeedingCompilation(bool searchForSubRootsInCompositeRootingMarkers) -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.DependencyTable.get -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, string>>
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.FileIsExcludedFromDependencyCheck(string fileName) -> bool
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveEntryForSourceRoot(string rootingMarker) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.SaveTlog() -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.AddComputedOutputForSourceRoot(string sourceKey, string computedOutput) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.AddComputedOutputsForSourceRoot(string sourceKey, Microsoft.Build.Framework.ITaskItem[] computedOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.AddComputedOutputsForSourceRoot(string sourceKey, string[] computedOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool constructOutputsFromTLogs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.DependencyTable.get -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, System.DateTime>>
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.OutputsForNonCompositeSource(params Microsoft.Build.Framework.ITaskItem[] sources) -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.OutputsForSource(Microsoft.Build.Framework.ITaskItem[] sources, bool searchForSubRootsInCompositeRootingMarkers) -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.OutputsForSource(params Microsoft.Build.Framework.ITaskItem[] sources) -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveOutputForSourceRoot(string sourceRoot, string outputPathToRemove) -> bool
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveRootsWithSharedOutputs(Microsoft.Build.Framework.ITaskItem[] sources) -> string[]
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.SaveTlog() -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) -> void
-Microsoft.Build.Utilities.CommandLineBuilder
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(Microsoft.Build.Framework.ITaskItem fileItem) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(string fileName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(Microsoft.Build.Framework.ITaskItem[] fileItems, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(string[] fileNames, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameWithQuoting(string fileName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendQuotedTextToBuffer(System.Text.StringBuilder buffer, string unquotedTextToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSpaceIfNotEmpty() -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitch(string switchName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendTextUnquoted(string textToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendTextWithQuoting(string textToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLine.get -> System.Text.StringBuilder
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder() -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.Length.get -> int
-Microsoft.Build.Utilities.DependencyFilter
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness32 = 1 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness64 = 2 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Current = 0 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.Managed32Bit = 3 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.Managed64Bit = 4 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.ManagedARM64 = 7 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.ManagedIL = 2 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.Native32Bit = 0 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.Native64Bit = 1 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.NativeARM64 = 6 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.SameAsCurrentProcess = 5 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.FileTracker
-Microsoft.Build.Utilities.FlatTrackingData
-Microsoft.Build.Utilities.FlatTrackingData.FileIsExcludedFromDependencyCheck(string fileName) -> bool
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool skipMissingFiles) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, System.DateTime missingFileTimeUtc) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool skipMissingFiles) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc, string[] excludedInputPaths, System.Collections.Generic.IDictionary<string, System.DateTime> sharedLastWriteTimeUtcCache) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc, string[] excludedInputPaths, System.Collections.Generic.IDictionary<string, System.DateTime> sharedLastWriteTimeUtcCache, bool treatRootMarkersAsEntries) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, System.DateTime missingFileTimeUtc) -> void
-Microsoft.Build.Utilities.FlatTrackingData.GetLastWriteTimeUtc(string file) -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.MissingFiles.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Utilities.FlatTrackingData.MissingFiles.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileName.get -> string
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileName.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileTime.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileTime.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileTimeUtc.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileTimeUtc.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogFileName.get -> string
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogFileName.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTime.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTime.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTimeUtc.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTimeUtc.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileName.get -> string
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileName.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileTime.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileTime.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileTimeUtc.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileTimeUtc.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.SaveTlog() -> void
-Microsoft.Build.Utilities.FlatTrackingData.SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) -> void
-Microsoft.Build.Utilities.FlatTrackingData.SkipMissingFiles.get -> bool
-Microsoft.Build.Utilities.FlatTrackingData.SkipMissingFiles.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.TlogFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.FlatTrackingData.TlogFiles.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.TlogsAvailable.get -> bool
-Microsoft.Build.Utilities.FlatTrackingData.TlogsAvailable.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.TreatRootMarkersAsEntries.get -> bool
-Microsoft.Build.Utilities.FlatTrackingData.TreatRootMarkersAsEntries.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.UpdateFileEntryDetails() -> void
-Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnFailure = 3 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnSuccess = 2 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.UseAlternateToolToExecute = 1 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.UseHostObjectToExecute = 0 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.Logger
-Microsoft.Build.Utilities.Logger.IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity checkVerbosity) -> bool
-Microsoft.Build.Utilities.Logger.Logger() -> void
-Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Allow = 0 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Error = 2 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Warning = 1 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MuxLogger
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.set -> void
-Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int maxNodeCount) -> void
-Microsoft.Build.Utilities.MuxLogger.MuxLogger() -> void
-Microsoft.Build.Utilities.MuxLogger.Parameters.get -> string
-Microsoft.Build.Utilities.MuxLogger.Parameters.set -> void
-Microsoft.Build.Utilities.MuxLogger.RegisterLogger(int submissionId, Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.Utilities.MuxLogger.Shutdown() -> void
-Microsoft.Build.Utilities.MuxLogger.UnregisterLoggers(int submissionId) -> bool
-Microsoft.Build.Utilities.MuxLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Utilities.MuxLogger.Verbosity.set -> void
-Microsoft.Build.Utilities.ProcessorArchitecture
-Microsoft.Build.Utilities.SDKManifest
-Microsoft.Build.Utilities.SDKManifest.AppxLocations.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Utilities.SDKManifest.Attributes
-Microsoft.Build.Utilities.SDKManifest.CopyRedistToSubDirectory.get -> string
-Microsoft.Build.Utilities.SDKManifest.DependsOnSDK.get -> string
-Microsoft.Build.Utilities.SDKManifest.DisplayName.get -> string
-Microsoft.Build.Utilities.SDKManifest.FrameworkIdentities.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Utilities.SDKManifest.FrameworkIdentity.get -> string
-Microsoft.Build.Utilities.SDKManifest.MaxOSVersionTested.get -> string
-Microsoft.Build.Utilities.SDKManifest.MaxPlatformVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MinOSVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MinVSVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MoreInfo.get -> string
-Microsoft.Build.Utilities.SDKManifest.PlatformIdentity.get -> string
-Microsoft.Build.Utilities.SDKManifest.ProductFamilyName.get -> string
-Microsoft.Build.Utilities.SDKManifest.ReadError.get -> bool
-Microsoft.Build.Utilities.SDKManifest.ReadErrorMessage.get -> string
-Microsoft.Build.Utilities.SDKManifest.SDKManifest(string pathToSdk) -> void
-Microsoft.Build.Utilities.SDKManifest.SDKType.get -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKManifest.SupportedArchitectures.get -> string
-Microsoft.Build.Utilities.SDKManifest.SupportPrefer32Bit.get -> string
-Microsoft.Build.Utilities.SDKManifest.SupportsMultipleVersions.get -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.SDKManifest.TargetPlatform.get -> string
-Microsoft.Build.Utilities.SDKManifest.TargetPlatformMinVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.TargetPlatformVersion.get -> string
-Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.External = 1 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Framework = 3 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Platform = 2 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Unspecified = 0 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Latest = 9999 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version11 = 0 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version20 = 1 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version30 = 2 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version35 = 3 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version40 = 4 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version45 = 5 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version451 = 6 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version452 = 9 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version46 = 7 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version461 = 8 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version462 = 10 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version47 = 11 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version471 = 12 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version472 = 13 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version48 = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.VersionLatest = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetPlatformSDK
-Microsoft.Build.Utilities.TargetPlatformSDK.ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion) -> bool
-Microsoft.Build.Utilities.TargetPlatformSDK.DisplayName.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.Equals(Microsoft.Build.Utilities.TargetPlatformSDK other) -> bool
-Microsoft.Build.Utilities.TargetPlatformSDK.MinOSVersion.get -> System.Version
-Microsoft.Build.Utilities.TargetPlatformSDK.MinVSVersion.get -> System.Version
-Microsoft.Build.Utilities.TargetPlatformSDK.Path.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.Path.set -> void
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformSDK(string targetPlatformIdentifier, System.Version targetPlatformVersion, string path) -> void
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformVersion.get -> System.Version
-Microsoft.Build.Utilities.Task
-Microsoft.Build.Utilities.Task.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.Task.BuildEngine.set -> void
-Microsoft.Build.Utilities.Task.BuildEngine2.get -> Microsoft.Build.Framework.IBuildEngine2
-Microsoft.Build.Utilities.Task.BuildEngine3.get -> Microsoft.Build.Framework.IBuildEngine3
-Microsoft.Build.Utilities.Task.BuildEngine4.get -> Microsoft.Build.Framework.IBuildEngine4
-Microsoft.Build.Utilities.Task.BuildEngine5.get -> Microsoft.Build.Framework.IBuildEngine5
-Microsoft.Build.Utilities.Task.BuildEngine6.get -> Microsoft.Build.Framework.IBuildEngine6
-Microsoft.Build.Utilities.Task.BuildEngine7.get -> Microsoft.Build.Framework.IBuildEngine7
-Microsoft.Build.Utilities.Task.BuildEngine8.get -> Microsoft.Build.Framework.IBuildEngine8
-Microsoft.Build.Utilities.Task.BuildEngine9.get -> Microsoft.Build.Framework.IBuildEngine9
-Microsoft.Build.Utilities.Task.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.Task.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.Task.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.Task.HostObject.set -> void
-Microsoft.Build.Utilities.Task.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.Task.Task() -> void
-Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.Task.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.Task.TaskResources.set -> void
-Microsoft.Build.Utilities.TaskItem
-Microsoft.Build.Utilities.TaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
-Microsoft.Build.Utilities.TaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
-Microsoft.Build.Utilities.TaskItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.Utilities.TaskItem.ItemSpec.get -> string
-Microsoft.Build.Utilities.TaskItem.ItemSpec.set -> void
-Microsoft.Build.Utilities.TaskItem.MetadataCount.get -> int
-Microsoft.Build.Utilities.TaskItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.Utilities.TaskItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Utilities.TaskItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem() -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(Microsoft.Build.Framework.ITaskItem sourceItem) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec, System.Collections.IDictionary itemMetadata) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.TaskLoggingHelper.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.TaskLoggingHelper.ExtractMessageCode(string message, out string messageWithoutCodePrefix) -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.HasLoggedErrors.get -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.IsTaskInputLoggingEnabled.get -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(Microsoft.Build.Framework.MessageImportance importance, string commandLine) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(string commandLine) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(Microsoft.Build.Framework.MessageImportance importance, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromText(string lineOfText, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception, bool showStackTrace) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.MarkAsInactive() -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskName.get -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.set -> void
-Microsoft.Build.Utilities.ToolLocationHelper
-Microsoft.Build.Utilities.ToolTask
-Microsoft.Build.Utilities.ToolTask.DeleteTempFile(string fileName) -> void
-Microsoft.Build.Utilities.ToolTask.EchoOff.get -> bool
-Microsoft.Build.Utilities.ToolTask.EchoOff.set -> void
-Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.get -> string[]
-Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.set -> void
-Microsoft.Build.Utilities.ToolTask.ExitCode.get -> int
-Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.get -> bool
-Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.get -> string
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.get -> string
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.get -> int
-Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.set -> void
-Microsoft.Build.Utilities.ToolTask.ToolCanceled.get -> System.Threading.ManualResetEvent
-Microsoft.Build.Utilities.ToolTask.ToolPath.get -> string
-Microsoft.Build.Utilities.ToolTask.ToolPath.set -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask() -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.get -> bool
-Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.set -> void
-Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.get -> string
-Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.set -> void
-Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.get -> bool
-Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.set -> void
-Microsoft.Build.Utilities.TrackedDependencies
-Microsoft.Build.Utilities.UpToDateCheckType
-Microsoft.Build.Utilities.UpToDateCheckType.InputNewerThanOutput = 0 -> Microsoft.Build.Utilities.UpToDateCheckType
-Microsoft.Build.Utilities.UpToDateCheckType.InputNewerThanTracking = 2 -> Microsoft.Build.Utilities.UpToDateCheckType
-Microsoft.Build.Utilities.UpToDateCheckType.InputOrOutputNewerThanTracking = 1 -> Microsoft.Build.Utilities.UpToDateCheckType
-Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version100 = 0 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version110 = 1 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version120 = 2 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version140 = 3 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version150 = 4 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version160 = 5 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version170 = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.VersionLatest = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
-override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
-override Microsoft.Build.Utilities.CommandLineBuilder.ToString() -> string
-override Microsoft.Build.Utilities.TargetPlatformSDK.Equals(object obj) -> bool
-override Microsoft.Build.Utilities.TargetPlatformSDK.GetHashCode() -> int
-override Microsoft.Build.Utilities.TaskItem.InitializeLifetimeService() -> object
-override Microsoft.Build.Utilities.TaskItem.ToString() -> string
-override Microsoft.Build.Utilities.TaskLoggingHelper.InitializeLifetimeService() -> object
-override Microsoft.Build.Utilities.ToolTask.Execute() -> bool
-static Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile(Microsoft.Build.Framework.ITaskItem[] sources) -> string
-static Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile(string rootMarker) -> string
-static Microsoft.Build.Utilities.FileTracker.EndTrackingContext() -> void
-static Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath() -> string
-static Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath(string rootPath) -> string
-static Microsoft.Build.Utilities.FileTracker.FileIsExcludedFromDependencies(string fileName) -> bool
-static Microsoft.Build.Utilities.FileTracker.FileIsUnderPath(string fileName, string path) -> bool
-static Microsoft.Build.Utilities.FileTracker.FindTrackerOnPath() -> string
-static Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType toolType) -> bool
-static Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string cancelEventName) -> bool
-static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem source) -> string
-static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem output) -> string
-static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[] sources) -> string
-static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem[] outputs) -> string
-static Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType) -> string
-static Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) -> string
-static Microsoft.Build.Utilities.FileTracker.GetTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType) -> string
-static Microsoft.Build.Utilities.FileTracker.GetTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) -> string
-static Microsoft.Build.Utilities.FileTracker.ResumeTracking() -> void
-static Microsoft.Build.Utilities.FileTracker.SetThreadCount(int threadCount) -> void
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string intermediateDirectory, string rootFiles) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string rootFiles) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartTrackingContext(string intermediateDirectory, string taskName) -> void
-static Microsoft.Build.Utilities.FileTracker.StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarkerResponseFile) -> void
-static Microsoft.Build.Utilities.FileTracker.StopTrackingAndCleanup() -> void
-static Microsoft.Build.Utilities.FileTracker.SuspendTracking() -> void
-static Microsoft.Build.Utilities.FileTracker.TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles) -> string
-static Microsoft.Build.Utilities.FileTracker.TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) -> string
-static Microsoft.Build.Utilities.FileTracker.TrackerCommandArguments(string command, string arguments) -> string
-static Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles) -> string
-static Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) -> string
-static Microsoft.Build.Utilities.FileTracker.WriteAllTLogs(string intermediateDirectory, string taskName) -> void
-static Microsoft.Build.Utilities.FileTracker.WriteContextTLogs(string intermediateDirectory, string taskName) -> void
-static Microsoft.Build.Utilities.FlatTrackingData.FinalizeTLogs(bool trackedOperationsSucceeded, Microsoft.Build.Framework.ITaskItem[] readTLogNames, Microsoft.Build.Framework.ITaskItem[] writeTLogNames, Microsoft.Build.Framework.ITaskItem[] trackedFilesToRemoveFromTLogs) -> void
-static Microsoft.Build.Utilities.FlatTrackingData.IsUpToDate(Microsoft.Build.Utilities.Task hostTask, Microsoft.Build.Utilities.UpToDateCheckType upToDateCheckType, Microsoft.Build.Framework.ITaskItem[] readTLogNames, Microsoft.Build.Framework.ITaskItem[] writeTLogNames) -> bool
-static Microsoft.Build.Utilities.FlatTrackingData.IsUpToDate(Microsoft.Build.Utilities.TaskLoggingHelper Log, Microsoft.Build.Utilities.UpToDateCheckType upToDateCheckType, Microsoft.Build.Utilities.FlatTrackingData inputs, Microsoft.Build.Utilities.FlatTrackingData outputs) -> bool
-static Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture.get -> string
-static Microsoft.Build.Utilities.TaskItem.explicit operator string(Microsoft.Build.Utilities.TaskItem taskItemToCast) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.ClearSDKStaticCache() -> void
-static Microsoft.Build.Utilities.ToolLocationHelper.CurrentToolsVersion.get -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk() -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToSystemFile(string fileName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string[] extensionDiskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetProgramFilesReferenceAssemblyRoot() -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSupportedTargetFrameworks() -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks() -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks(string[] diskRoots, string registryRoot) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier) -> System.Runtime.Versioning.FrameworkName
-static Microsoft.Build.Utilities.ToolLocationHelper.PathToSystem.get -> string
-static Microsoft.Build.Utilities.TrackedDependencies.ExpandWildcards(Microsoft.Build.Framework.ITaskItem[] expand) -> Microsoft.Build.Framework.ITaskItem[]
-virtual Microsoft.Build.Utilities.CommandLineBuilder.IsQuotingRequired(string parameter) -> bool
-virtual Microsoft.Build.Utilities.CommandLineBuilder.VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter) -> void
-virtual Microsoft.Build.Utilities.Logger.FormatErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs args) -> string
-virtual Microsoft.Build.Utilities.Logger.FormatWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs args) -> string
-virtual Microsoft.Build.Utilities.Logger.Parameters.get -> string
-virtual Microsoft.Build.Utilities.Logger.Parameters.set -> void
-virtual Microsoft.Build.Utilities.Logger.Shutdown() -> void
-virtual Microsoft.Build.Utilities.Logger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-virtual Microsoft.Build.Utilities.Logger.Verbosity.set -> void
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatResourceString(string resourceName, params object[] args) -> string
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatString(string unformatted, params object[] args) -> string
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.GetResourceMessage(string resourceName) -> string
-virtual Microsoft.Build.Utilities.ToolTask.AdjustCommandsForOperatingSystem(string input) -> string
-virtual Microsoft.Build.Utilities.ToolTask.CallHostObjectToExecute() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.Cancel() -> void
-virtual Microsoft.Build.Utilities.ToolTask.EnvironmentOverride.get -> System.Collections.Generic.Dictionary<string, string>
-virtual Microsoft.Build.Utilities.ToolTask.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
-virtual Microsoft.Build.Utilities.ToolTask.GenerateCommandLineCommands() -> string
-virtual Microsoft.Build.Utilities.ToolTask.GenerateResponseFileCommands() -> string
-virtual Microsoft.Build.Utilities.ToolTask.GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch) -> System.Diagnostics.ProcessStartInfo
-virtual Microsoft.Build.Utilities.ToolTask.GetResponseFileSwitch(string responseFilePath) -> string
-virtual Microsoft.Build.Utilities.ToolTask.GetWorkingDirectory() -> string
-virtual Microsoft.Build.Utilities.ToolTask.HandleTaskExecutionErrors() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.HasLoggedErrors.get -> bool
-virtual Microsoft.Build.Utilities.ToolTask.InitializeHostObject() -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-virtual Microsoft.Build.Utilities.ToolTask.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
-virtual Microsoft.Build.Utilities.ToolTask.LogPathToTool(string toolName, string pathToTool) -> void
-virtual Microsoft.Build.Utilities.ToolTask.LogToolCommand(string message) -> void
-virtual Microsoft.Build.Utilities.ToolTask.ProcessStarted() -> void
-virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEscape(string responseString) -> string
-virtual Microsoft.Build.Utilities.ToolTask.SkipTaskExecution() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.StandardErrorEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-virtual Microsoft.Build.Utilities.ToolTask.StandardOutputEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-virtual Microsoft.Build.Utilities.ToolTask.Timeout.get -> int
-virtual Microsoft.Build.Utilities.ToolTask.Timeout.set -> void
-virtual Microsoft.Build.Utilities.ToolTask.ToolExe.get -> string
-virtual Microsoft.Build.Utilities.ToolTask.ToolExe.set -> void
-virtual Microsoft.Build.Utilities.ToolTask.ValidateParameters() -> bool
\ No newline at end of file
diff --git a/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index 9efcc6b3e9d..00000000000
--- a/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,439 +0,0 @@
-abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
-abstract Microsoft.Build.Utilities.Logger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-abstract Microsoft.Build.Utilities.Task.Execute() -> bool
-abstract Microsoft.Build.Utilities.ToolTask.GenerateFullPathToTool() -> string
-abstract Microsoft.Build.Utilities.ToolTask.ToolName.get -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.AMD64 = "AMD64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.ARM = "ARM" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.ARM64 = "ARM64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.IA64 = "IA64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.MSIL = "MSIL" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.X86 = "x86" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.APPX = "APPX" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.AppxLocation = "AppxLocation" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyLocalExpandedReferenceAssemblies = "CopyLocalExpandedReferenceAssemblies" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedist = "CopyRedist" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedistToSubDirectory = "CopyRedistToSubDirectory" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.DependsOnSDK = "DependsOn" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.DisplayName = "DisplayName" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.ExpandReferenceAssemblies = "ExpandReferenceAssemblies" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.FrameworkIdentity = "FrameworkIdentity" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxOSVersionTested = "MaxOSVersionTested" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxPlatformVersion = "MaxPlatformVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MinOSVersion = "MinOSVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MinVSVersion = "MinVSVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MoreInfo = "MoreInfo" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.PlatformIdentity = "PlatformIdentity" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.ProductFamilyName = "ProductFamilyName" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SDKType = "SDKType" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportedArchitectures = "SupportedArchitectures" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportPrefer32Bit = "SupportPrefer32Bit" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportsMultipleVersions = "SupportsMultipleVersions" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDK = "TargetedSDKArchitecture" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDKConfiguration = "TargetedSDKConfiguration" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatform = "TargetPlatform" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformMinVersion = "TargetPlatformMinVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformVersion = "TargetPlatformVersion" -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.CommandLineBuilder
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(Microsoft.Build.Framework.ITaskItem fileItem) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(string fileName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(Microsoft.Build.Framework.ITaskItem[] fileItems, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(string[] fileNames, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameWithQuoting(string fileName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendQuotedTextToBuffer(System.Text.StringBuilder buffer, string unquotedTextToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSpaceIfNotEmpty() -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitch(string switchName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendTextUnquoted(string textToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendTextWithQuoting(string textToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLine.get -> System.Text.StringBuilder
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder() -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.Length.get -> int
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness32 = 1 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness64 = 2 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Current = 0 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnFailure = 3 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnSuccess = 2 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.UseAlternateToolToExecute = 1 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.UseHostObjectToExecute = 0 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.Logger
-Microsoft.Build.Utilities.Logger.IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity checkVerbosity) -> bool
-Microsoft.Build.Utilities.Logger.Logger() -> void
-Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Allow = 0 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Error = 2 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Warning = 1 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MuxLogger
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.set -> void
-Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int maxNodeCount) -> void
-Microsoft.Build.Utilities.MuxLogger.MuxLogger() -> void
-Microsoft.Build.Utilities.MuxLogger.Parameters.get -> string
-Microsoft.Build.Utilities.MuxLogger.Parameters.set -> void
-Microsoft.Build.Utilities.MuxLogger.RegisterLogger(int submissionId, Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.Utilities.MuxLogger.Shutdown() -> void
-Microsoft.Build.Utilities.MuxLogger.UnregisterLoggers(int submissionId) -> bool
-Microsoft.Build.Utilities.MuxLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Utilities.MuxLogger.Verbosity.set -> void
-Microsoft.Build.Utilities.ProcessorArchitecture
-Microsoft.Build.Utilities.SDKManifest
-Microsoft.Build.Utilities.SDKManifest.AppxLocations.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Utilities.SDKManifest.Attributes
-Microsoft.Build.Utilities.SDKManifest.CopyRedistToSubDirectory.get -> string
-Microsoft.Build.Utilities.SDKManifest.DependsOnSDK.get -> string
-Microsoft.Build.Utilities.SDKManifest.DisplayName.get -> string
-Microsoft.Build.Utilities.SDKManifest.FrameworkIdentities.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Utilities.SDKManifest.FrameworkIdentity.get -> string
-Microsoft.Build.Utilities.SDKManifest.MaxOSVersionTested.get -> string
-Microsoft.Build.Utilities.SDKManifest.MaxPlatformVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MinOSVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MinVSVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MoreInfo.get -> string
-Microsoft.Build.Utilities.SDKManifest.PlatformIdentity.get -> string
-Microsoft.Build.Utilities.SDKManifest.ProductFamilyName.get -> string
-Microsoft.Build.Utilities.SDKManifest.ReadError.get -> bool
-Microsoft.Build.Utilities.SDKManifest.ReadErrorMessage.get -> string
-Microsoft.Build.Utilities.SDKManifest.SDKManifest(string pathToSdk) -> void
-Microsoft.Build.Utilities.SDKManifest.SDKType.get -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKManifest.SupportedArchitectures.get -> string
-Microsoft.Build.Utilities.SDKManifest.SupportPrefer32Bit.get -> string
-Microsoft.Build.Utilities.SDKManifest.SupportsMultipleVersions.get -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.SDKManifest.TargetPlatform.get -> string
-Microsoft.Build.Utilities.SDKManifest.TargetPlatformMinVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.TargetPlatformVersion.get -> string
-Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.External = 1 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Framework = 3 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Platform = 2 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Unspecified = 0 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Latest = 9999 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version11 = 0 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version20 = 1 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version30 = 2 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version35 = 3 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version40 = 4 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version45 = 5 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version451 = 6 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version452 = 9 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version46 = 7 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version461 = 8 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version462 = 10 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version47 = 11 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version471 = 12 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version472 = 13 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version48 = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.VersionLatest = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetPlatformSDK
-Microsoft.Build.Utilities.TargetPlatformSDK.ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion) -> bool
-Microsoft.Build.Utilities.TargetPlatformSDK.DisplayName.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.Equals(Microsoft.Build.Utilities.TargetPlatformSDK other) -> bool
-Microsoft.Build.Utilities.TargetPlatformSDK.MinOSVersion.get -> System.Version
-Microsoft.Build.Utilities.TargetPlatformSDK.MinVSVersion.get -> System.Version
-Microsoft.Build.Utilities.TargetPlatformSDK.Path.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.Path.set -> void
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformSDK(string targetPlatformIdentifier, System.Version targetPlatformVersion, string path) -> void
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformVersion.get -> System.Version
-Microsoft.Build.Utilities.Task
-Microsoft.Build.Utilities.Task.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.Task.BuildEngine.set -> void
-Microsoft.Build.Utilities.Task.BuildEngine2.get -> Microsoft.Build.Framework.IBuildEngine2
-Microsoft.Build.Utilities.Task.BuildEngine3.get -> Microsoft.Build.Framework.IBuildEngine3
-Microsoft.Build.Utilities.Task.BuildEngine4.get -> Microsoft.Build.Framework.IBuildEngine4
-Microsoft.Build.Utilities.Task.BuildEngine5.get -> Microsoft.Build.Framework.IBuildEngine5
-Microsoft.Build.Utilities.Task.BuildEngine6.get -> Microsoft.Build.Framework.IBuildEngine6
-Microsoft.Build.Utilities.Task.BuildEngine7.get -> Microsoft.Build.Framework.IBuildEngine7
-Microsoft.Build.Utilities.Task.BuildEngine8.get -> Microsoft.Build.Framework.IBuildEngine8
-Microsoft.Build.Utilities.Task.BuildEngine9.get -> Microsoft.Build.Framework.IBuildEngine9
-Microsoft.Build.Utilities.Task.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.Task.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.Task.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.Task.HostObject.set -> void
-Microsoft.Build.Utilities.Task.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.Task.Task() -> void
-Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.Task.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.Task.TaskResources.set -> void
-Microsoft.Build.Utilities.TaskItem
-Microsoft.Build.Utilities.TaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
-Microsoft.Build.Utilities.TaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
-Microsoft.Build.Utilities.TaskItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.Utilities.TaskItem.ItemSpec.get -> string
-Microsoft.Build.Utilities.TaskItem.ItemSpec.set -> void
-Microsoft.Build.Utilities.TaskItem.MetadataCount.get -> int
-Microsoft.Build.Utilities.TaskItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.Utilities.TaskItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Utilities.TaskItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem() -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(Microsoft.Build.Framework.ITaskItem sourceItem) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec, System.Collections.IDictionary itemMetadata) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.TaskLoggingHelper.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.TaskLoggingHelper.ExtractMessageCode(string message, out string messageWithoutCodePrefix) -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.HasLoggedErrors.get -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.IsTaskInputLoggingEnabled.get -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(Microsoft.Build.Framework.MessageImportance importance, string commandLine) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(string commandLine) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(Microsoft.Build.Framework.MessageImportance importance, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromText(string lineOfText, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception, bool showStackTrace) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskName.get -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.set -> void
-Microsoft.Build.Utilities.ToolLocationHelper
-Microsoft.Build.Utilities.ToolTask
-Microsoft.Build.Utilities.ToolTask.DeleteTempFile(string fileName) -> void
-Microsoft.Build.Utilities.ToolTask.EchoOff.get -> bool
-Microsoft.Build.Utilities.ToolTask.EchoOff.set -> void
-Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.get -> string[]
-Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.set -> void
-Microsoft.Build.Utilities.ToolTask.ExitCode.get -> int
-Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.get -> bool
-Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.get -> string
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.get -> string
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.get -> int
-Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.set -> void
-Microsoft.Build.Utilities.ToolTask.ToolCanceled.get -> System.Threading.ManualResetEvent
-Microsoft.Build.Utilities.ToolTask.ToolPath.get -> string
-Microsoft.Build.Utilities.ToolTask.ToolPath.set -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask() -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.get -> bool
-Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.set -> void
-Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.get -> string
-Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.set -> void
-Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.get -> bool
-Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.set -> void
-Microsoft.Build.Utilities.TrackedDependencies
-Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version100 = 0 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version110 = 1 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version120 = 2 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version140 = 3 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version150 = 4 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version160 = 5 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version170 = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.VersionLatest = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
-override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
-override Microsoft.Build.Utilities.CommandLineBuilder.ToString() -> string
-override Microsoft.Build.Utilities.TargetPlatformSDK.Equals(object obj) -> bool
-override Microsoft.Build.Utilities.TargetPlatformSDK.GetHashCode() -> int
-override Microsoft.Build.Utilities.TaskItem.ToString() -> string
-override Microsoft.Build.Utilities.ToolTask.Execute() -> bool
-static Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture.get -> string
-static Microsoft.Build.Utilities.TaskItem.explicit operator string(Microsoft.Build.Utilities.TaskItem taskItemToCast) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.ClearSDKStaticCache() -> void
-static Microsoft.Build.Utilities.ToolLocationHelper.CurrentToolsVersion.get -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk() -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToSystemFile(string fileName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string[] extensionDiskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetProgramFilesReferenceAssemblyRoot() -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSupportedTargetFrameworks() -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks() -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks(string[] diskRoots, string registryRoot) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier) -> System.Runtime.Versioning.FrameworkName
-static Microsoft.Build.Utilities.ToolLocationHelper.PathToSystem.get -> string
-static Microsoft.Build.Utilities.TrackedDependencies.ExpandWildcards(Microsoft.Build.Framework.ITaskItem[] expand) -> Microsoft.Build.Framework.ITaskItem[]
-virtual Microsoft.Build.Utilities.CommandLineBuilder.IsQuotingRequired(string parameter) -> bool
-virtual Microsoft.Build.Utilities.CommandLineBuilder.VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter) -> void
-virtual Microsoft.Build.Utilities.Logger.FormatErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs args) -> string
-virtual Microsoft.Build.Utilities.Logger.FormatWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs args) -> string
-virtual Microsoft.Build.Utilities.Logger.Parameters.get -> string
-virtual Microsoft.Build.Utilities.Logger.Parameters.set -> void
-virtual Microsoft.Build.Utilities.Logger.Shutdown() -> void
-virtual Microsoft.Build.Utilities.Logger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-virtual Microsoft.Build.Utilities.Logger.Verbosity.set -> void
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatResourceString(string resourceName, params object[] args) -> string
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatString(string unformatted, params object[] args) -> string
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.GetResourceMessage(string resourceName) -> string
-virtual Microsoft.Build.Utilities.ToolTask.AdjustCommandsForOperatingSystem(string input) -> string
-virtual Microsoft.Build.Utilities.ToolTask.CallHostObjectToExecute() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.Cancel() -> void
-virtual Microsoft.Build.Utilities.ToolTask.EnvironmentOverride.get -> System.Collections.Generic.Dictionary<string, string>
-virtual Microsoft.Build.Utilities.ToolTask.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
-virtual Microsoft.Build.Utilities.ToolTask.GenerateCommandLineCommands() -> string
-virtual Microsoft.Build.Utilities.ToolTask.GenerateResponseFileCommands() -> string
-virtual Microsoft.Build.Utilities.ToolTask.GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch) -> System.Diagnostics.ProcessStartInfo
-virtual Microsoft.Build.Utilities.ToolTask.GetResponseFileSwitch(string responseFilePath) -> string
-virtual Microsoft.Build.Utilities.ToolTask.GetWorkingDirectory() -> string
-virtual Microsoft.Build.Utilities.ToolTask.HandleTaskExecutionErrors() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.HasLoggedErrors.get -> bool
-virtual Microsoft.Build.Utilities.ToolTask.InitializeHostObject() -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-virtual Microsoft.Build.Utilities.ToolTask.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
-virtual Microsoft.Build.Utilities.ToolTask.LogPathToTool(string toolName, string pathToTool) -> void
-virtual Microsoft.Build.Utilities.ToolTask.LogToolCommand(string message) -> void
-virtual Microsoft.Build.Utilities.ToolTask.ProcessStarted() -> void
-virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEscape(string responseString) -> string
-virtual Microsoft.Build.Utilities.ToolTask.SkipTaskExecution() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.StandardErrorEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-virtual Microsoft.Build.Utilities.ToolTask.StandardOutputEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-virtual Microsoft.Build.Utilities.ToolTask.Timeout.get -> int
-virtual Microsoft.Build.Utilities.ToolTask.Timeout.set -> void
-virtual Microsoft.Build.Utilities.ToolTask.ToolExe.get -> string
-virtual Microsoft.Build.Utilities.ToolTask.ToolExe.set -> void
-virtual Microsoft.Build.Utilities.ToolTask.ValidateParameters() -> bool
\ No newline at end of file
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 8028af19a93..2d20b9f110b 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -105,6 +105,11 @@ public enum TargetDotNetFrameworkVersion
         /// </summary>
         Version48 = 14,
 
+        /// <summary>
+        /// version 4.8.1
+        /// </summary>
+        Version481 = 15,
+
         /// <summary>
         /// The latest version available at the time of major release. This
         /// value should not be updated in minor releases as it could be a
@@ -2047,10 +2052,14 @@ private static Version TargetDotNetFrameworkVersionToSystemVersion(TargetDotNetF
 
                 case TargetDotNetFrameworkVersion.Version472:
                     return FrameworkLocationHelper.dotNetFrameworkVersion472;
+
                 case TargetDotNetFrameworkVersion.Version48:
-                case TargetDotNetFrameworkVersion.Latest: // Latest is a special value to indicate the highest version we know about.
                     return FrameworkLocationHelper.dotNetFrameworkVersion48;
 
+                case TargetDotNetFrameworkVersion.Version481:
+                case TargetDotNetFrameworkVersion.Latest: // Latest is a special value to indicate the highest version we know about.
+                    return FrameworkLocationHelper.dotNetFrameworkVersion481;
+
                 default:
                     ErrorUtilities.ThrowArgument("ToolLocationHelper.UnsupportedFrameworkVersion", version);
                     return null;
diff --git a/testenvironments.json b/testenvironments.json
new file mode 100644
index 00000000000..86278391870
--- /dev/null
+++ b/testenvironments.json
@@ -0,0 +1,15 @@
+{
+    "version": "1",
+    "environments": [
+      {
+        "name": "WSL-Ubuntu",
+        "type": "wsl",
+        "wslDistribution": "Ubuntu"
+      },
+      {
+        "name": "docker dotnet 7.0",
+        "type": "docker",
+        "dockerImage": "mcr.microsoft.com/dotnet/sdk:7.0"
+      }
+    ]
+}
