diff --git a/eng/Packages.props b/eng/Packages.props
index 7496689a0f5..80e14eb1d86 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -39,7 +39,6 @@
     <PackageReference Update="System.Runtime.Serialization.Primitives" Version="4.1.1" />
     <PackageReference Update="System.Security.Principal.Windows" Version="4.3.0" />
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
-    <PackageReference Update="System.Text.Json" Version="4.6.0" />
     <PackageReference Update="System.Threading.Tasks.Dataflow" Version="4.9.0" />
     <PackageReference Update="System.Threading.Thread" Version="4.0.0" />
     <PackageReference Update="System.Xml.XPath" Version="4.3.0" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 4ee2e210efd..84809c75278 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20077.3">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20124.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>69a67461460d99125742d5c2dd94dad83add84a3</Sha>
+      <Sha>0b8ce7c1c078eefb4cbc4d7e67ffc02f1f73382d</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index b121d77e07d..3c69186f03a 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -341,4 +341,28 @@ stages:
     channelId: 557
     transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
     shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-public-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'NETCore_SDK_313xx_Publishing'
+    channelName: '.NET Core SDK 3.1.3xx'
+    channelId: 759
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1/nuget/v3/index.json'
+    symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet3.1-symbols/nuget/v3/index.json'
+
+- template: \eng\common\templates\post-build\channels\generic-internal-channel.yml
+  parameters:
+    artifactsPublishingAdditionalParameters: ${{ parameters.artifactsPublishingAdditionalParameters }}
+    publishInstallersAndChecksums: ${{ parameters.publishInstallersAndChecksums }}
+    symbolPublishingAdditionalParameters: ${{ parameters.symbolPublishingAdditionalParameters }}
+    stageName: 'NETCore_SDK_313xx_Internal_Publishing'
+    channelName: '.NET Core SDK 3.1.3xx Internal'
+    channelId: 760
+    transportFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v3/index.json'
+    shippingFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v3/index.json'
     symbolsFeed: 'https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-symbols/nuget/v3/index.json'
\ No newline at end of file
diff --git a/global.json b/global.json
index ec1e5d920bf..e2c34768525 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20077.3"
+    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20124.2"
   }
 }
diff --git a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
index 535066ec94b..649fa056cbb 100644
--- a/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/net/Microsoft.Build.Framework.cs
@@ -143,6 +143,12 @@ protected CustomBuildEventArgs(string message, string helpKeyword, string sender
         protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
     }
     public delegate void CustomBuildEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e);
+    public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public EnvironmentVariableReadEventArgs() { }
+        public EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public string EnvironmentVariableName { get { throw null; } set { } }
+    }
     public partial class ExternalProjectFinishedEventArgs : Microsoft.Build.Framework.CustomBuildEventArgs
     {
         protected ExternalProjectFinishedEventArgs() { }
@@ -411,6 +417,23 @@ public ProjectStartedEventArgs(string message, string helpKeyword, string projec
         public string ToolsVersion { get { throw null; } }
     }
     public delegate void ProjectStartedEventHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e);
+    public partial class PropertyInitialValueSetEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public PropertyInitialValueSetEventArgs() { }
+        public PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public string PropertyName { get { throw null; } set { } }
+        public string PropertySource { get { throw null; } set { } }
+        public string PropertyValue { get { throw null; } set { } }
+    }
+    public partial class PropertyReassignmentEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public PropertyReassignmentEventArgs() { }
+        public PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public string Location { get { throw null; } set { } }
+        public string NewValue { get { throw null; } set { } }
+        public string PreviousValue { get { throw null; } set { } }
+        public string PropertyName { get { throw null; } set { } }
+    }
     public enum RegisteredTaskObjectLifetime
     {
         AppDomain = 1,
@@ -571,6 +594,12 @@ public TelemetryEventArgs() { }
         public System.Collections.Generic.IDictionary<string, string> Properties { get { throw null; } set { } }
     }
     public delegate void TelemetryEventHandler(object sender, Microsoft.Build.Framework.TelemetryEventArgs e);
+    public partial class UninitializedPropertyReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public UninitializedPropertyReadEventArgs() { }
+        public UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public string PropertyName { get { throw null; } set { } }
+    }
 }
 namespace Microsoft.Build.Framework.Profiler
 {
diff --git a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
index d202cdd397d..38e32b4eaa7 100644
--- a/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
+++ b/ref/Microsoft.Build.Framework/netstandard/Microsoft.Build.Framework.cs
@@ -143,6 +143,12 @@ protected CustomBuildEventArgs(string message, string helpKeyword, string sender
         protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) { }
     }
     public delegate void CustomBuildEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e);
+    public partial class EnvironmentVariableReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public EnvironmentVariableReadEventArgs() { }
+        public EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public string EnvironmentVariableName { get { throw null; } set { } }
+    }
     public partial class ExternalProjectFinishedEventArgs : Microsoft.Build.Framework.CustomBuildEventArgs
     {
         protected ExternalProjectFinishedEventArgs() { }
@@ -410,6 +416,23 @@ public ProjectStartedEventArgs(string message, string helpKeyword, string projec
         public string ToolsVersion { get { throw null; } }
     }
     public delegate void ProjectStartedEventHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e);
+    public partial class PropertyInitialValueSetEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public PropertyInitialValueSetEventArgs() { }
+        public PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public string PropertyName { get { throw null; } set { } }
+        public string PropertySource { get { throw null; } set { } }
+        public string PropertyValue { get { throw null; } set { } }
+    }
+    public partial class PropertyReassignmentEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public PropertyReassignmentEventArgs() { }
+        public PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public string Location { get { throw null; } set { } }
+        public string NewValue { get { throw null; } set { } }
+        public string PreviousValue { get { throw null; } set { } }
+        public string PropertyName { get { throw null; } set { } }
+    }
     public enum RegisteredTaskObjectLifetime
     {
         AppDomain = 1,
@@ -570,6 +593,12 @@ public TelemetryEventArgs() { }
         public System.Collections.Generic.IDictionary<string, string> Properties { get { throw null; } set { } }
     }
     public delegate void TelemetryEventHandler(object sender, Microsoft.Build.Framework.TelemetryEventArgs e);
+    public partial class UninitializedPropertyReadEventArgs : Microsoft.Build.Framework.BuildMessageEventArgs
+    {
+        public UninitializedPropertyReadEventArgs() { }
+        public UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword=null, string senderName=null, Microsoft.Build.Framework.MessageImportance importance=(Microsoft.Build.Framework.MessageImportance)(2)) { }
+        public string PropertyName { get { throw null; } set { } }
+    }
 }
 namespace Microsoft.Build.Framework.Profiler
 {
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index 9da67ecc15a..7fb7115821e 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -49,6 +49,8 @@ $filesToCopyToBin = @(
     "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework\Microsoft.CSharp.CurrentVersion.targets"
     "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework\Microsoft.CSharp.targets"
     "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework\Microsoft.Managed.targets"
+    "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework\Microsoft.Managed.Before.targets"
+    "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework\Microsoft.Managed.After.targets"
     "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework\Microsoft.Net.props"
     "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework\Microsoft.NetFramework.CurrentVersion.props"
     "artifacts\bin\MSBuild.Bootstrap\$configuration\$targetFramework\Microsoft.NetFramework.CurrentVersion.targets"
@@ -89,4 +91,4 @@ foreach ($file in $filesToCopyToBin) {
 }
 
 Write-Host -ForegroundColor Green "Copy succeeded"
-Write-Verbose "Run $destination\MSBuild.exe"
\ No newline at end of file
+Write-Verbose "Run $destination\MSBuild.exe"
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index a4e0c79e34e..a1c01d9bd6c 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
-using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.Construction
@@ -17,72 +16,6 @@ namespace Microsoft.Build.UnitTests.Construction
     /// </summary>
     public class SolutionFile_Tests
     {
-        [Theory]
-        [InlineData(@"
-                {
-                  ""solution"": {
-                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
-                    ""projects2"": [
-                      ""src\\Build\\Microsoft.Build.csproj"",
-                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
-                      ""src\\MSBuild\\MSBuild.csproj"",
-                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
-                    ]
-                    }
-                }
-                ", "MSBuild.SolutionFilterJsonParsingError")]
-        [InlineData(@"
-                [{
-                  ""solution"": {
-                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
-                    ""projects"": [
-                      ""src\\Build\\Microsoft.Build.csproj"",
-                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
-                      ""src\\MSBuild\\MSBuild.csproj"",
-                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
-                    ]
-                    }
-                }]
-                ", "MSBuild.SolutionFilterJsonParsingError")]
-        [InlineData(@"
-                {
-                  ""solution"": {
-                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
-                    ""projects"": [
-                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
-                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
-                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
-                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
-                    ]
-                    }
-                }
-                ", "MSBuild.SolutionFilterJsonParsingError")]
-        [InlineData(@"
-                {
-                  ""solution"": {
-                    ""path"": ""C:\\notAPath2\\MSBuild.Dev.sln"",
-                    ""projects"": [
-                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
-                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
-                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
-                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
-                    ]
-                    }
-                }
-                ", "MSBuild.SolutionFilterMissingSolutionError")]
-        public void InvalidSolutionFilters(string slnfValue, string exceptionReason)
-        {
-            Assert.False(File.Exists("C:\\notAPath2\\MSBuild.Dev.sln"));
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
-            {
-                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
-                TransientTestFile sln = testEnvironment.CreateFile(folder, "Dev.sln");
-                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf", slnfValue.Replace(@"C:\\notAPath\\MSBuild.Dev.sln", sln.Path.Replace("\\", "\\\\")));
-                InvalidProjectFileException e = Should.Throw<InvalidProjectFileException>(() => SolutionFile.Parse(slnf.Path));
-                e.HelpKeyword.ShouldBe(exceptionReason);
-            }
-        }
-
         /// <summary>
         /// Test that a project with the C++ project guid and an extension of vcproj is seen as invalid.
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index c6da21d4976..7da61e2d3b8 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -2111,8 +2111,8 @@ public void RemoveShouldMatchNonCanonicPaths(string include, string remove)
 
             Assert.Empty(items);
         }
-		
-		[Fact]
+        
+        [Fact]
         public void RemoveShouldRespectCondition()
         {
             var projectContents = ObjectModelHelpers.FormatProjectContentsWithItemGroupFragment(
@@ -2371,6 +2371,8 @@ public void UpdateShouldSupportComplexMetadata()
                               <i2 Update='a;b'>
                                   <m1>%(Identity)</m1>
                                   <m2>%(m1)@(i1 -> '%(m1)')</m2>
+                                  <m3 Condition='%(Identity) == a'>value</m3>
+                                  <m4 Condition='%(m1) == b'>%(m1)</m4>
                               </i2>";
 
             IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, true);
@@ -2386,12 +2388,14 @@ public void UpdateShouldSupportComplexMetadata()
             {
                 {"m1", "a"},
                 {"m2", "ax"},
+                {"m3", "value"},
             };
 
             var expectedMetadataB = new Dictionary<string, string>
             {
                 {"m1", "b"},
                 {"m2", "bx"},
+                {"m4", "b"},
             };
 
             ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataX, items[0]);
@@ -2399,6 +2403,317 @@ public void UpdateShouldSupportComplexMetadata()
             ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataB, items[2]);
         }
 
+        [Fact]
+        public void UpdateShouldImportMetadataFromReferencedItem()
+        {
+            string content = @"
+                              <from Include='a;b'>
+                                  <m1>%(Identity)-m1</m1>
+                                  <m2>%(Identity)-m2</m2>
+                              </from>
+
+                              <to Include='a;b;c'>
+                                  <m1>m1_contents</m1>
+                                  <m2>m2_contents</m2>
+                              </to>
+
+                              <to Update='@(from)'>
+                                  <m2>%(m2);%(to.m2);%(from.m2)</m2>
+                                  <m3 Condition=`'%(Identity);%(to.Identity);%(from.m1)' == 'a;a;a-m1'`>%(from.m1)</m3>
+                                  <m4 Condition=`'%(from.m1)' == 'b-m1'`>%(m1)</m4>
+                              </to>";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, true);
+
+            var expectedMetadataA = new Dictionary<string, string>
+            {
+                {"m1", "m1_contents"},
+                {"m2", "m2_contents;m2_contents;a-m2"},
+                {"m3", "a-m1"},
+            };
+
+            var expectedMetadataB = new Dictionary<string, string>
+            {
+                {"m1", "m1_contents"},
+                {"m2", "m2_contents;m2_contents;b-m2"},
+                {"m4", "m1_contents"},
+            };
+
+            var expectedMetadataC = new Dictionary<string, string>
+            {
+                {"m1", "m1_contents"},
+                {"m2", "m2_contents"}
+            };
+
+            items[2].ItemType.ShouldBe("to");
+
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[2]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataB, items[3]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataC, items[4]);
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void EscapeHatchTurnsOffQualifiedMetadataExpansionInUpdateOperation(bool doNotExpandQualifiedMetadataInUpdateOperation)
+        {
+            using var env = TestEnvironment.Create();
+
+            if (doNotExpandQualifiedMetadataInUpdateOperation)
+            {
+                env.SetEnvironmentVariable("MSBuildDoNotExpandQualifiedMetadataInUpdateOperation", "non empty value");
+            }
+
+            string content = @"
+                              <from Include='a'>
+                                  <m1>updated contents</m1>
+                              </from>
+
+                              <to Include='a'>
+                                  <m1>original contents</m1>
+                              </to>
+
+                              <to Update='@(from)'>
+                                  <m1>%(from.m1)</m1>
+                              </to>";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, true);
+
+            var expectedMetadataA = doNotExpandQualifiedMetadataInUpdateOperation
+                ? new Dictionary<string, string>
+                {
+                    {"m1", string.Empty}
+                }
+                : new Dictionary<string, string>
+                {
+                    {"m1", "updated contents"}
+                };
+
+            items[1].ItemType.ShouldBe("to");
+
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[1]);
+        }
+
+        [Fact]
+        public void UpdateFromReferencedItemShouldBeCaseInsensitive()
+        {
+            string content = @"
+                              <from Include='a'>
+                                  <metadata>m1_contents</metadata>
+                              </from>
+
+                              <to Include='a' />
+
+                              <to Update='@(FrOm)' m='%(fRoM.MetaDATA)' />";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, true);
+
+            var expectedMetadataA = new Dictionary<string, string>
+            {
+                {"m", "m1_contents"},
+            };
+
+            items[1].ItemType.ShouldBe("to");
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[1]);
+        }
+
+        [Fact]
+        public void UndeclaredQualifiedMetadataReferencesInUpdateShouldResolveToEmptyStrings()
+        {
+            string content = @"
+                              <from1 Include='a'>
+                                  <metadata>m1_contents</metadata>
+                              </from1>
+
+                              <from2 Include='a'>
+                                  <metadata2>m1_contents</metadata2>
+                              </from2>
+
+                              <to Include='a' />
+
+                              <to Update='@(from1)' m1='%(nonexistent.metadata)' m2='%(from2.metadata2)'/>";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, true);
+
+            var expectedMetadataA = new Dictionary<string, string>
+            {
+                { "m1", string.Empty },
+                { "m2", string.Empty },
+            };
+
+            items[2].ItemType.ShouldBe("to");
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[2]);
+        }
+
+        [Fact]
+        public void UpdateShouldImportMetadataFromMultipleReferencedItems()
+        {
+            string content = @"
+                              <from1 Include='x.cs;y.cs'>
+                                  <m1>%(Identity)-m1</m1>
+                              </from1>
+
+                              <from2 Include='1;2'>
+                                  <m2>%(Identity)-m2</m2>
+                              </from2>
+
+                              <from3 Include='1;2'>
+                                  <m3>%(Identity)-m3</m3>
+                              </from3>
+
+                              <to Include='x.cs;2;ccc;1;d;y.cs'>
+                                  <m3>m3_contents</m3>
+                              </to>
+
+                              <to Update='@(from1);d;c*c;*.cs;@(from2);@(from3)'>
+                                  <m2>%(from2.m2);%(from3.m3)</m2>
+                                  <m3>%(from1.m1);%(from2.m2)</m3>
+                                  <m4>%(from1.m2);%(from2.m1)</m4>
+                                  <m5>%(Identity)</m5>
+                                  <m6 Condition='%(Identity) == 1'>%(from2.m2)</m6>
+                              </to>";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, true);
+
+            var expectedMetadataX = new Dictionary<string, string>
+            {
+                {"m2", ";"},
+                {"m3", "x.cs-m1;"},
+                {"m4", ";"},
+                {"m5", "x.cs"},
+            };
+
+            var expectedMetadata2 = new Dictionary<string, string>
+            {
+                {"m2", "2-m2;2-m3"},
+                {"m3", ";2-m2"},
+                {"m4", ";"},
+                {"m5", "2"},
+            };
+
+            var expectedMetadataCCC = new Dictionary<string, string>
+            {
+                {"m2", ";"},
+                {"m3", ";"},
+                {"m4", ";"},
+                {"m5", "ccc"},
+            };
+
+            var expectedMetadata1 = new Dictionary<string, string>
+            {
+                {"m2", "1-m2;1-m3"},
+                {"m3", ";1-m2"},
+                {"m4", ";"},
+                {"m5", "1"},
+                {"m6", "1-m2"},
+            };
+
+            var expectedMetadataD = new Dictionary<string, string>
+            {
+                {"m2", ";"},
+                {"m3", ";"},
+                {"m4", ";"},
+                {"m5", "d"},
+            };
+
+            var expectedMetadataY = new Dictionary<string, string>
+            {
+                {"m2", ";"},
+                {"m3", "y.cs-m1;"},
+                {"m4", ";"},
+                {"m5", "y.cs"},
+            };
+
+            items[5].ItemType.ShouldBe("from3");
+            items[6].ItemType.ShouldBe("to");
+
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataX, items[6]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadata2, items[7]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataCCC, items[8]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadata1, items[9]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataD, items[10]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataY, items[11]);
+        }
+
+        [Fact]
+        public void UpdateFromReferencedItemsWithDuplicatesShouldUseLastItemFromEachItemType()
+        {
+            using var env = TestEnvironment.Create();
+
+            env.SetEnvironmentVariable("MSBUILDENABLEALLPROPERTYFUNCTIONS", "1");
+
+            string content = @"
+                              <to Include='a;b;c'/>
+
+                              <from1 Include='b;a;b'>
+                                  <!-- %(Identity) forces re-evaluating each metadata for each item, leading to different DateTime ticks -->
+                                  <m>from1:%(Identity):$([System.DateTime]::Now.Ticks)</m>
+                              </from1>
+
+                              <from2 Include='a;c;a'>
+                                  <!-- %(Identity) forces re-evaluating each metadata for each item, leading to different DateTime ticks -->
+                                  <m>from2:%(Identity):$([System.DateTime]::Now.Ticks)</m>
+                              </from2>
+
+                              <to Update='@(from1);@(from2)'>
+                                  <m1 Condition='%(from1.Identity) == b'>%(from1.m);%(from2.m)</m1>
+                                  <m2 Condition='%(Identity) == a'>%(from1.m);%(from2.m)</m2>
+                              </to>";
+
+            IList<ProjectItem> items = ObjectModelHelpers.GetItemsFromFragment(content, true);
+
+            var lastItemMetadataForBFrom1 = LastItemMetadata("from1", "b");
+            var lastItemMetadataForAFrom1 = LastItemMetadata("from1", "a");
+            var lastItemMetadataForAFrom2 = LastItemMetadata("from2", "a");
+
+            var expectedMetadataB = new Dictionary<string, string>
+            {
+                {"m1", $"{lastItemMetadataForBFrom1};"},
+            };
+
+            var expectedMetadataA = new Dictionary<string, string>()
+            {
+                {"m2", $"{lastItemMetadataForAFrom1};{lastItemMetadataForAFrom2}"},
+            };
+
+            var expectedMetadataC = new Dictionary<string, string>();
+
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataA, items[0]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataB, items[1]);
+            ObjectModelHelpers.AssertItemHasMetadata(expectedMetadataC, items[2]);
+
+            string LastItemMetadata(string itemType, string itemValue)
+            {
+                var lastItemMetadata = items.Last(i => i.ItemType.Equals(itemType) && i.EvaluatedInclude.Equals(itemValue)).GetMetadataValue("m");
+
+                lastItemMetadata.ShouldNotBeNullOrEmpty();
+
+                return lastItemMetadata;
+            }
+        }
+
+        [Fact]
+        public void UpdateFromReferenceItemAndNoMetadataNOOPS()
+        {
+            string content = @"
+                              <to Include='a'/>
+
+                              <from Include='a'>
+                                  <m>m_contents</m>
+                              </from>
+
+                              <to Update='@(from)' />";
+
+            var items = ObjectModelHelpers.GetItemsFromFragment(content, true).Where(i => i.ItemType.Equals("to")).ToArray();
+
+            items.ShouldNotBeEmpty();
+
+            foreach (var item in items)
+            {
+                ObjectModelHelpers.AssertItemHasMetadata(null, item);
+            }
+        }
+
         [Fact]
         public void UpdateShouldBeAbleToContainGlobs()
         {
@@ -2644,6 +2959,42 @@ public void UpdateAndRemoveShouldWorkWithEscapedCharacters(string projectContent
             ObjectModelHelpers.AssertItemEvaluationFromProject(formattedProjectContents, new string[0], expectedInclude, expectedMetadata);
         }
 
+        [Fact]
+        public void UpdateAndRemoveShouldNotUseGlobMatchingOnEscapedGlobsFromReferencedItems()
+        {
+            var project = @"
+                    <Project>
+                        <ItemGroup>
+                            <!-- %2A is an escaped '*' character -->
+                            <from1 Include='%2A.cs' />
+                            <from2 Include='%2A.js' />
+                            <i Include='1.cs;2.js' />
+
+                            <i Update='@(from1)'>
+                               <m>updated</m>
+                            </i>
+
+                            <i Remove='@(from2)'/>
+                        </ItemGroup>
+                    </Project>
+                ";
+
+            ObjectModelHelpers.AssertItemEvaluationFromGenericItemEvaluator(
+                (p, c) =>
+                {
+                    return new Project(p, new Dictionary<string, string>(), MSBuildConstants.CurrentToolsVersion, c)
+                        .Items
+                        .Where(i => i.ItemType.Equals("i"))
+                        .Select(i => (ObjectModelHelpers.TestItem) new ObjectModelHelpers.ProjectItemTestItemAdapter(i))
+                        .ToList();
+                },
+                project,
+                inputFiles: new string[0],
+                expectedInclude: new[] { "1.cs", "2.js" },
+                expectedMetadataPerItem: null
+                );
+        }
+
         [Theory]
         [InlineData(@"1.foo;.\2.foo;.\.\3.foo", @"1.foo;.\2.foo;.\.\3.foo")]
         [InlineData(@"1.foo;.\2.foo;.\.\3.foo", @".\1.foo;.\.\2.foo;.\.\.\3.foo")]
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index 3d53625c4da..fb14064c4f4 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -10,8 +10,8 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
+using Shouldly;
 using Xunit;
-
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 namespace Microsoft.Build.UnitTests.BackEnd
diff --git a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
index 861d10cd4b6..338cc793c8e 100644
--- a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
@@ -4,8 +4,10 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
+using Shouldly;
 using System;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -14,29 +16,36 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class LoggingContext_Tests
     {
+        private readonly ITestOutputHelper _output;
+
+        public LoggingContext_Tests(ITestOutputHelper outputHelper)
+        {
+            _output = outputHelper;
+        }
+
         /// <summary>
         /// A few simple tests for NodeLoggingContexts. 
         /// </summary>
         [Fact]
         public void CreateValidNodeLoggingContexts()
         {
-            NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(), 1, true);
-            Assert.True(context.IsInProcNode);
-            Assert.True(context.IsValid);
+            NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 1, true);
+            context.IsInProcNode.ShouldBeTrue();
+            context.IsValid.ShouldBeTrue();
 
             context.LogBuildFinished(true);
-            Assert.False(context.IsValid);
+            context.IsValid.ShouldBeFalse();
 
-            Assert.Equal(1, context.BuildEventContext.NodeId);
+            context.BuildEventContext.NodeId.ShouldBe(1);
 
-            NodeLoggingContext context2 = new NodeLoggingContext(new MockLoggingService(), 2, false);
-            Assert.False(context2.IsInProcNode);
-            Assert.True(context2.IsValid);
+            NodeLoggingContext context2 = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 2, false);
+            context2.IsInProcNode.ShouldBeFalse();
+            context2.IsValid.ShouldBeTrue();
 
             context2.LogBuildFinished(true);
-            Assert.False(context2.IsValid);
+            context2.IsValid.ShouldBeFalse();
 
-            Assert.Equal(2, context2.BuildEventContext.NodeId);
+            context2.BuildEventContext.NodeId.ShouldBe(2);
         }
 
         /// <summary>
@@ -49,9 +58,25 @@ public void InvalidNodeIdOnNodeLoggingContext()
         {
             Assert.Throws<InternalErrorException>(() =>
             {
-                NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(), -2, true);
+                _ = new NodeLoggingContext(new MockLoggingService(), -2, true);
             }
            );
         }
+
+        [Fact]
+        public void HasLoggedErrors()
+        {
+            NodeLoggingContext context = new NodeLoggingContext(new MockLoggingService(_output.WriteLine), 1, true);
+            context.HasLoggedErrors.ShouldBeFalse();
+
+            context.LogCommentFromText(Framework.MessageImportance.High, "Test message");
+            context.HasLoggedErrors.ShouldBeFalse();
+
+            context.LogWarningFromText(null, null, null, null, "Test warning");
+            context.HasLoggedErrors.ShouldBeFalse();
+
+            context.LogErrorFromText(null, null, null, null, "Test error");
+            context.HasLoggedErrors.ShouldBeTrue();
+        }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs b/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs
new file mode 100644
index 00000000000..8d9b0b8b436
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/ReturnFailureWithoutLoggingErrorTask.cs
@@ -0,0 +1,26 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Utilities;
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    /// This task was created for https://github.com/microsoft/msbuild/issues/2036
+    /// </summary>
+    public class ReturnFailureWithoutLoggingErrorTask : Task
+    {
+        /// <summary>
+        /// Intentionally return false without logging an error to test proper error catching.
+        /// </summary>
+        /// <returns></returns>
+        public override bool Execute()
+        {
+            return false;
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 7d2431c7402..a797ef0a01c 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -44,20 +44,21 @@ public void TestBinaryLoggerRoundtrip()
 
             binaryLogger.Parameters = _logFile;
 
-            var mockLogger1 = new MockLogger();
+            var mockLogFromBuild = new MockLogger();
 
             // build and log into binary logger and mockLogger1
-            ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger, mockLogger1);
+            ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger, mockLogFromBuild);
 
-            var mockLogger2 = new MockLogger();
+            var mockLogFromPlayback = new MockLogger();
 
             var binaryLogReader = new BinaryLogReplayEventSource();
-            mockLogger2.Initialize(binaryLogReader);
+            mockLogFromPlayback.Initialize(binaryLogReader);
 
             // read the binary log and replay into mockLogger2testassembly
             binaryLogReader.Replay(_logFile);
 
-            Assert.Equal(mockLogger1.FullLog, mockLogger2.FullLog);
+            // the binlog will have more information than recorded by the text log
+            Assert.Contains(mockLogFromBuild.FullLog, mockLogFromPlayback.FullLog);
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 2642cb426da..765ddad0dff 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -418,6 +418,79 @@ public void RoundtripTargetSkippedEventArgs()
                 e => e.BuildReason.ToString());
         }
 
+        [Fact]
+        public void RoundTripEnvironmentVariableReadEventArgs()
+        {
+            var args = new EnvironmentVariableReadEventArgs(
+                environmentVariableName: Guid.NewGuid().ToString(),
+                message: Guid.NewGuid().ToString(),
+                helpKeyword: Guid.NewGuid().ToString(),
+                senderName: Guid.NewGuid().ToString());
+
+            Roundtrip(args,
+                e => e.EnvironmentVariableName,
+                e => e.Message,
+                e => e.HelpKeyword,
+                e => e.SenderName);
+        }
+
+        [Fact]
+        public void RoundTripPropertyReassignmentEventArgs()
+        {
+            var args = new PropertyReassignmentEventArgs(
+                propertyName: Guid.NewGuid().ToString(),
+                previousValue: Guid.NewGuid().ToString(),
+                newValue: Guid.NewGuid().ToString(),
+                location: Guid.NewGuid().ToString(),
+                message: Guid.NewGuid().ToString(),
+                helpKeyword: Guid.NewGuid().ToString(),
+                senderName: Guid.NewGuid().ToString());
+
+            Roundtrip(args,
+                e => e.PropertyName,
+                e => e.PreviousValue,
+                e => e.NewValue,
+                e => e.Location,
+                e => e.Message,
+                e => e.HelpKeyword,
+                e => e.SenderName);
+        }
+
+        [Fact]
+        public void UninitializedPropertyReadEventArgs()
+        {
+            var args = new UninitializedPropertyReadEventArgs(
+                propertyName: Guid.NewGuid().ToString(),
+                message: Guid.NewGuid().ToString(),
+                helpKeyword: Guid.NewGuid().ToString(),
+                senderName: Guid.NewGuid().ToString());
+
+            Roundtrip(args,
+                e => e.PropertyName,
+                e => e.Message,
+                e => e.HelpKeyword,
+                e => e.SenderName);
+        }
+
+        [Fact]
+        public void PropertyInitialValueEventArgs()
+        {
+            var args = new PropertyInitialValueSetEventArgs(
+                propertyName: Guid.NewGuid().ToString(),
+                propertyValue: Guid.NewGuid().ToString(),
+                propertySource: Guid.NewGuid().ToString(),
+                message: Guid.NewGuid().ToString(),
+                helpKeyword: Guid.NewGuid().ToString(),
+                senderName: Guid.NewGuid().ToString());
+
+            Roundtrip(args,
+                e => e.PropertyName,
+                e => e.PropertyValue,
+                e => e.PropertySource,
+                e => e.Message,
+                e => e.HelpKeyword,
+                e => e.SenderName);
+        }
         [Fact]
         public void ReadingCorruptedStreamThrows()
         {
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index e9dc6951439..c9b10410185 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -17,64 +17,6 @@ namespace Microsoft.Build.UnitTests.Construction
 {
     public class SolutionFile_Tests
     {
-        /// <summary>
-        /// Test that a solution filter file is parsed correctly, and it can accurately respond as to whether a project should be filtered out.
-        /// </summary>
-        [Fact]
-        public void ParseSolutionFilter()
-        {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
-            {
-                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
-                TransientTestFolder src = testEnvironment.CreateFolder(Path.Combine(folder.Path, "src"), createFolder: true);
-                TransientTestFile microsoftBuild = testEnvironment.CreateFile(src, "Microsoft.Build.csproj");
-                TransientTestFile msbuild = testEnvironment.CreateFile(src, "MSBuild.csproj");
-                TransientTestFile commandLineUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.CommandLine.UnitTests.csproj");
-                TransientTestFile tasksUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.Tasks.UnitTests.csproj");
-                // The important part of this .sln is that it has references to each of the four projects we just created.
-                TransientTestFile sln = testEnvironment.CreateFile(folder, "Microsoft.Build.Dev.sln",
-                    @"
-                    Microsoft Visual Studio Solution File, Format Version 12.00
-                    # Visual Studio 15
-                    VisualStudioVersion = 15.0.27004.2009
-                    MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
-                    EndProject
-                    Global
-                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        EndGlobalSection
-                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(ExtensibilityGlobals) = postSolution
-                    EndGlobalSection
-                    EndGlobal
-                    ");
-                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf",
-                    @"
-                    {
-                      ""solution"": {
-                        ""path"": """ + sln.Path.Replace("\\", "\\\\") + @""",
-                        ""projects"": [
-                          """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)).Replace("\\", "\\\\") + @""",
-                          """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)).Replace("\\", "\\\\") + @"""
-                        ]
-                        }
-                    }");
-                SolutionFile sp = SolutionFile.Parse(slnf.Path);
-                Assert.True(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(microsoftBuild.Path))) && sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(tasksUnitTests.Path))));
-                Assert.False(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path))) || sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(msbuild.Path))) || sp.ProjectShouldBuild(Path.Combine("src", "notAProject.csproj")));
-            }
-        }
-
         /// <summary>
         /// Test just the most basic, plain vanilla first project line.
         /// </summary>
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 4cc129d7abd..655a4ad71c3 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -60,121 +60,6 @@ public void Dispose()
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
         }
 
-        /// <summary>
-        /// Test that if a before.{sln}>.targets or after.{sln}.targets file has one of the default targets (Build, Clean, etc.) that it includes only the user-defined target.
-        /// </summary>
-        [Theory]
-        [InlineData("before.MySln.sln.targets")]
-        [InlineData("after.MySln.sln.targets")]
-        [InlineData("name.that.does.Not.Affect.The.Build.targets")]
-        public void SolutionProjectIgnoresDuplicateDefaultTargets(string name)
-        {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
-            {
-                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
-                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", @"Microsoft Visual Studio Solution File, Format Version 16.00");
-                TransientTestFile targetsFile = testEnvironment.CreateFile(folder, name,
-                    @"<Project>
-                        <Target Name=""Build"" AfterTargets=""NonsenseTarget"">
-                        </Target>
-                      </Project>");
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(SolutionFile.Parse(sln.Path), null, null, _buildEventContext, CreateMockLoggingService());
-                instances.ShouldHaveSingleItem();
-                instances[0].Targets["Build"].AfterTargets.ShouldBe(string.Empty);
-                MockLogger logger = new MockLogger(output);
-                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
-            }
-        }
-
-        /// <summary>
-        /// Test that a solution filter file excludes projects not covered by its list of projects or their dependencies.
-        /// </summary>
-        [Fact]
-        public void SolutionFilterFiltersProjects()
-        {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
-            {
-                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);              
-                TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "ClassLibrary"), createFolder: true);
-                TransientTestFolder classLibSubFolder = testEnvironment.CreateFolder(Path.Combine(classLibFolder.Path, "ClassLibrary"), createFolder: true);
-                TransientTestFile classLibrary = testEnvironment.CreateFile(classLibSubFolder, "ClassLibrary.csproj",
-                    @"<Project>
-                  <Target Name=""ClassLibraryTarget"">
-                      <Message Text=""ClassLibraryBuilt""/>
-                  </Target>
-                  </Project>
-                    ");
-
-                TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "SimpleProject"), createFolder: true);
-                TransientTestFolder simpleProjectSubFolder = testEnvironment.CreateFolder(Path.Combine(simpleProjectFolder.Path, "SimpleProject"), createFolder: true);
-                TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectSubFolder, "SimpleProject.csproj",
-                    @"<Project DefaultTargets=""SimpleProjectTarget"">
-                  <Target Name=""SimpleProjectTarget"">
-                      <Message Text=""SimpleProjectBuilt""/>
-                  </Target>
-                  </Project>
-                    ");
-                TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
-                    @"
-                    Microsoft Visual Studio Solution File, Format Version 12.00
-                    # Visual Studio Version 16
-                    VisualStudioVersion = 16.0.29326.124
-                    MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", """ + Path.Combine("SimpleProject", "SimpleProject.csproj") + @""", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
-                    EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", """ + Path.Combine("..", "ClassLibrary", "ClassLibrary", "ClassLibrary.csproj") + @""", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
-                    EndProject
-                    Global
-                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                            Debug|Any CPU = Debug|Any CPU
-                            Release|Any CPU = Release|Any CPU
-                            EndGlobalSection
-                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.Build.0 = Release|Any CPU
-                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.Build.0 = Release|Any CPU
-                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.Build.0 = Release|Any CPU
-                        EndGlobalSection
-                        GlobalSection(SolutionProperties) = preSolution
-                            HideSolutionNode = FALSE
-                        EndGlobalSection
-                        GlobalSection(ExtensibilityGlobals) = postSolution
-                            SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
-                        EndGlobalSection
-                    EndGlobal
-                ");
-                TransientTestFile filterFile = testEnvironment.CreateFile(folder, "solutionFilter.slnf",
-                    @"
-                {
-                  ""solution"": {
-                    ""path"": """ + solutionFile.Path.Replace("\\", "\\\\") + @""",
-                    ""projects"": [
-                      """ + Path.Combine("SimpleProject", "SimpleProject.csproj").Replace("\\", "\\\\") + @"""
-                    ]
-                    }
-                }
-                ");
-                SolutionFile solution = SolutionFile.Parse(filterFile.Path);
-                ILoggingService mockLogger = CreateMockLoggingService();
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, mockLogger);
-                instances.ShouldHaveSingleItem();
-
-                // Check that dependencies are built, and non-dependencies in the .sln are not.
-                MockLogger logger = new MockLogger(output);
-                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
-                logger.AssertLogContains(new string[] { "SimpleProjectBuilt" });
-                logger.AssertLogDoesntContain("ClassLibraryBuilt");
-            }
-        }
-
         /// <summary>
         /// Verify the AddNewErrorWarningMessageElement method
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 272dba2e0fb..3d16f82ecf3 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -506,9 +506,12 @@ public void EmptyPropertyIsThenSetEnvironmentVariableNotSet()
             string testTargetPath = Path.Combine(targetDirectory, "test.proj");
 
             string originalValue = Environment.GetEnvironmentVariable("MSBUILDWARNONUNINITIALIZEDPROPERTY");
+            bool originalValue2 = BuildParameters.WarnOnUninitializedProperty;
+
             try
             {
                 Environment.SetEnvironmentVariable("MSBUILDWARNONUNINITIALIZEDPROPERTY", null);
+                BuildParameters.WarnOnUninitializedProperty = false;
                 Directory.CreateDirectory(targetDirectory);
                 File.WriteAllText(testTargetPath, testtargets);
 
@@ -524,6 +527,7 @@ public void EmptyPropertyIsThenSetEnvironmentVariableNotSet()
             finally
             {
                 Environment.SetEnvironmentVariable("MSBUILDWARNONUNINITIALIZEDPROPERTY", originalValue);
+                BuildParameters.WarnOnUninitializedProperty = originalValue2;
                 FileUtilities.DeleteWithoutTrailingBackslash(targetDirectory, true);
             }
         }
@@ -661,55 +665,6 @@ public void UsePropertyBeforeSet()
             }
         }
 
-        /// <summary>
-        /// Log when a property is being assigned a new value.
-        /// </summary>
-        [Fact]
-        public void LogPropertyAssignments()
-        {
-            string testtargets = ObjectModelHelpers.CleanupFileContents(@"
-                                <Project xmlns='msbuildnamespace'>
-                                     <PropertyGroup>
-                                         <Prop>OldValue</Prop>
-                                         <Prop>NewValue</Prop>
-                                     </PropertyGroup>
-
-                                  <Target Name=""Test""/>
-                                </Project>");
-
-            string tempPath = Path.GetTempPath();
-            string targetDirectory = Path.Combine(tempPath, "LogPropertyAssignments");
-            string testTargetPath = Path.Combine(targetDirectory, "test.proj");
-
-            bool originalValue = BuildParameters.WarnOnUninitializedProperty;
-            try
-            {
-                BuildParameters.WarnOnUninitializedProperty = true;
-                Directory.CreateDirectory(targetDirectory);
-                File.WriteAllText(testTargetPath, testtargets);
-
-                MockLogger logger = new MockLogger();
-                logger.Verbosity = LoggerVerbosity.Diagnostic;
-                ProjectCollection pc = new ProjectCollection();
-                pc.RegisterLogger(logger);
-                Project project = pc.LoadProject(testTargetPath);
-
-                bool result = project.Build();
-                Assert.True(result);
-                logger.AssertLogContains("Evaluation started");
-                logger.AssertLogContains("Property reassignment");
-                logger.AssertLogContains("Evaluation finished");
-                logger.AssertLogContains("Prop");
-                logger.AssertLogContains("OldValue");
-                logger.AssertLogContains("NewValue");
-            }
-            finally
-            {
-                BuildParameters.WarnOnUninitializedProperty = originalValue;
-                FileUtilities.DeleteWithoutTrailingBackslash(targetDirectory, true);
-            }
-        }
-
         /// <summary>
         /// If we use a property twice make sure we warn and don't crash due to the dictionary which is holding the used but uninitialized variables..
         /// </summary>
@@ -4556,6 +4511,305 @@ public void VerifyMSBuildLogsAMessageWhenLocalPropertyCannotOverrideValueOfGloba
                 ResourceUtilities.FormatResourceStringStripCodeAndKeyword("OM_GlobalProperty", "Foo"));
         }
 
+        [Fact]
+        public void VerifyPropertyTrackingLoggingDefault()
+        {
+            // Having nothing defined should default to nothing being logged.
+            this.VerifyPropertyTrackingLoggingScenario(
+                null,
+                logger =>
+                {
+                    logger
+                        .AllBuildEvents
+                        .OfType<UninitializedPropertyReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<EnvironmentVariableReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyReassignmentEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyInitialValueSetEventArgs>()
+                        .ShouldBeEmpty();
+
+                });
+        }
+
+        [Fact]
+        public void VerifyPropertyTrackingLoggingPropertyReassignment()
+        {
+            this.VerifyPropertyTrackingLoggingScenario(
+                "1",
+                logger =>
+                {
+                    logger
+                        .AllBuildEvents
+                        .OfType<UninitializedPropertyReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<EnvironmentVariableReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyReassignmentEventArgs>()
+                        .ShouldContain(r => r.PropertyName == "Prop2" && r.PreviousValue == "Value1" && r.NewValue == "Value2");
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyInitialValueSetEventArgs>()
+                        .ShouldBeEmpty();
+
+                });
+        }
+
+        [Fact]
+        public void VerifyPropertyTrackingLoggingNone()
+        {
+            this.VerifyPropertyTrackingLoggingScenario(
+                "0",
+                logger =>
+                {
+                    logger
+                        .AllBuildEvents
+                        .OfType<UninitializedPropertyReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<EnvironmentVariableReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyReassignmentEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyInitialValueSetEventArgs>()
+                        .ShouldBeEmpty();
+                });
+        }
+
+        [Fact]
+        public void VerifyPropertyTrackingLoggingPropertyInitialValue()
+        {
+            this.VerifyPropertyTrackingLoggingScenario(
+                "2",
+                logger =>
+                {
+                    logger
+                        .AllBuildEvents
+                        .OfType<UninitializedPropertyReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<EnvironmentVariableReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyReassignmentEventArgs>()
+                        .ShouldBeEmpty();
+
+                    IDictionary<string, PropertyInitialValueSetEventArgs> propertyInitialValueMap = logger
+                        .AllBuildEvents
+                        .OfType<PropertyInitialValueSetEventArgs>()
+                        .ToDictionary(piv => piv.PropertyName);
+
+                    // Verify logging of property initial values.
+                    propertyInitialValueMap.ShouldContainKey("Prop");
+                    propertyInitialValueMap["Prop"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop"].PropertyValue.ShouldBe(string.Empty);
+
+                    propertyInitialValueMap.ShouldContainKey("EnvVar");
+                    propertyInitialValueMap["EnvVar"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["EnvVar"].PropertyValue.ShouldBe("It's also Defined!");
+
+                    propertyInitialValueMap.ShouldContainKey("DEFINED_ENVIRONMENT_VARIABLE");
+                    propertyInitialValueMap["DEFINED_ENVIRONMENT_VARIABLE"].PropertySource.ShouldBe("EnvironmentVariable");
+                    propertyInitialValueMap["DEFINED_ENVIRONMENT_VARIABLE"].PropertyValue.ShouldBe("It's Defined!");
+
+                    propertyInitialValueMap.ShouldContainKey("NotEnvVarRead");
+                    propertyInitialValueMap["NotEnvVarRead"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["NotEnvVarRead"].PropertyValue.ShouldBe("Overwritten!");
+
+                    propertyInitialValueMap.ShouldContainKey("Prop2");
+                    propertyInitialValueMap["Prop2"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop2"].PropertyValue.ShouldBe("Value1");
+                });
+        }
+
+        [Fact]
+        public void VerifyPropertyTrackingLoggingEnvironmentVariableRead()
+        {
+            this.VerifyPropertyTrackingLoggingScenario(
+                "4",
+                logger =>
+                {
+                    logger
+                        .AllBuildEvents
+                        .OfType<UninitializedPropertyReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<EnvironmentVariableReadEventArgs>()
+                        .ShouldContain(ev => ev.EnvironmentVariableName == "DEFINED_ENVIRONMENT_VARIABLE2");
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<EnvironmentVariableReadEventArgs>()
+                        .ShouldNotContain(ev => ev.EnvironmentVariableName == "DEFINED_ENVIRONMENT_VARIABLE");
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyReassignmentEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyInitialValueSetEventArgs>()
+                        .ShouldBeEmpty();
+                });
+        }
+
+        [Fact]
+        public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
+        {
+            this.VerifyPropertyTrackingLoggingScenario(
+                "8",
+                logger =>
+                {
+                    logger
+                        .AllBuildEvents
+                        .OfType<UninitializedPropertyReadEventArgs>()
+                        .ShouldContain(p => p.PropertyName == "DOES_NOT_EXIST");
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<EnvironmentVariableReadEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyReassignmentEventArgs>()
+                        .ShouldBeEmpty();
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyInitialValueSetEventArgs>()
+                        .ShouldBeEmpty();
+                });
+        }
+
+        [Fact]
+        public void VerifyPropertyTrackingLoggingAll()
+        {
+            this.VerifyPropertyTrackingLoggingScenario(
+                "15",
+                logger =>
+                {
+                    logger
+                        .AllBuildEvents
+                        .OfType<UninitializedPropertyReadEventArgs>()
+                        .ShouldContain(p => p.PropertyName == "DOES_NOT_EXIST");
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<EnvironmentVariableReadEventArgs>()
+                        .ShouldContain(ev => ev.EnvironmentVariableName == "DEFINED_ENVIRONMENT_VARIABLE2");
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<EnvironmentVariableReadEventArgs>()
+                        .ShouldNotContain(ev => ev.EnvironmentVariableName == "DEFINED_ENVIRONMENT_VARIABLE");
+
+                    logger
+                        .AllBuildEvents
+                        .OfType<PropertyReassignmentEventArgs>()
+                        .ShouldContain(r => r.PropertyName == "Prop2" && r.PreviousValue == "Value1" && r.NewValue == "Value2");
+
+                    IDictionary<string, PropertyInitialValueSetEventArgs> propertyInitialValueMap = logger
+                        .AllBuildEvents
+                        .OfType<PropertyInitialValueSetEventArgs>()
+                        .ToDictionary(piv => piv.PropertyName);
+
+                    // Verify logging of property initial values.
+                    propertyInitialValueMap.ShouldContainKey("Prop");
+                    propertyInitialValueMap["Prop"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop"].PropertyValue.ShouldBe(string.Empty);
+
+                    propertyInitialValueMap.ShouldContainKey("EnvVar");
+                    propertyInitialValueMap["EnvVar"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["EnvVar"].PropertyValue.ShouldBe("It's also Defined!");
+
+                    propertyInitialValueMap.ShouldContainKey("DEFINED_ENVIRONMENT_VARIABLE");
+                    propertyInitialValueMap["DEFINED_ENVIRONMENT_VARIABLE"].PropertySource.ShouldBe("EnvironmentVariable");
+                    propertyInitialValueMap["DEFINED_ENVIRONMENT_VARIABLE"].PropertyValue.ShouldBe("It's Defined!");
+
+                    propertyInitialValueMap.ShouldContainKey("NotEnvVarRead");
+                    propertyInitialValueMap["NotEnvVarRead"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["NotEnvVarRead"].PropertyValue.ShouldBe("Overwritten!");
+
+                    propertyInitialValueMap.ShouldContainKey("Prop2");
+                    propertyInitialValueMap["Prop2"].PropertySource.ShouldBe("Xml");
+                    propertyInitialValueMap["Prop2"].PropertyValue.ShouldBe("Value1");
+                });
+        }
+
+        private void VerifyPropertyTrackingLoggingScenario(string envVarValue, Action<MockLogger> loggerEvaluatorAction)
+        {
+            // The default is that only reassignments are logged.
+
+            string testTargets = ObjectModelHelpers.CleanupFileContents(@"
+                                <Project>
+                                     <PropertyGroup>
+                                         <Prop>$(DOES_NOT_EXIST)</Prop>
+                                         <EnvVar>$(DEFINED_ENVIRONMENT_VARIABLE2)</EnvVar>
+                                         <DEFINED_ENVIRONMENT_VARIABLE>Overwritten!</DEFINED_ENVIRONMENT_VARIABLE>
+                                         <NotEnvVarRead>$(DEFINED_ENVIRONMENT_VARIABLE)</NotEnvVarRead>
+                                         <Prop2>Value1</Prop2>
+                                         <Prop2>Value2</Prop2>
+                                     </PropertyGroup>
+                                     <Target Name='Build' />
+                                </Project>");
+
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                if (!string.IsNullOrWhiteSpace(envVarValue))
+                    env.SetEnvironmentVariable("MsBuildLogPropertyTracking", envVarValue);
+
+                env.SetEnvironmentVariable("DEFINED_ENVIRONMENT_VARIABLE", "It's Defined!");
+                env.SetEnvironmentVariable("DEFINED_ENVIRONMENT_VARIABLE2", "It's also Defined!");
+
+                var tempPath = env.CreateFile(Guid.NewGuid().ToString(), testTargets);
+
+                BuildParameters.WarnOnUninitializedProperty = true;
+
+                MockLogger logger = new MockLogger();
+                logger.Verbosity = LoggerVerbosity.Diagnostic;
+                ProjectCollection pc = new ProjectCollection();
+                pc.RegisterLogger(logger);
+                Project project = pc.LoadProject(tempPath.Path);
+
+                project.Build().ShouldBeTrue();
+
+                loggerEvaluatorAction?.Invoke(logger);
+            }
+        }
+
 #if FEATURE_HTTP_LISTENER
         /// <summary>
         /// HTTP server code running on a separate thread that expects a connection request
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index 1b3aba784ba..07c44ac86cb 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -3,7 +3,9 @@
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests;
+using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.Engine.UnitTests
 {
@@ -12,6 +14,13 @@ public sealed class WarningsAsMessagesAndErrorsTests
         private const string ExpectedEventMessage = "03767942CDB147B98D0ECDBDE1436DA3";
         private const string ExpectedEventCode = "0BF68998";
 
+        ITestOutputHelper _output;
+
+        public WarningsAsMessagesAndErrorsTests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
         [Fact]
         public void TreatAllWarningsAsErrors()
         {
@@ -28,7 +37,7 @@ public void TreatAllWarningsAsErrors()
         [Fact]
         public void TreatWarningsAsErrorsWhenBuildingSameProjectMultipleTimes()
         {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            using (TestEnvironment testEnvironment = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles project2 = testEnvironment.CreateTestProjectWithFiles($@"
                 <Project xmlns=""msbuildnamespace"">
@@ -122,7 +131,7 @@ public void TreatWarningsAsMessagesWhenSpecified()
         [Fact]
         public void TreatWarningsAsMessagesWhenBuildingSameProjectMultipleTimes()
         {
-            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            using (TestEnvironment testEnvironment = TestEnvironment.Create(_output))
             {
                 TransientTestProjectWithFiles project2 = testEnvironment.CreateTestProjectWithFiles($@"
                 <Project xmlns=""msbuildnamespace"">
@@ -262,5 +271,111 @@ private string GetTestProject(bool? treatAllWarningsAsErrors = null, string warn
                 </Target>
             </Project>";
         }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.AssertLogContains("MSB4132");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""WarnAndContinue""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+
+                logger.WarningCount.ShouldBe(1);
+
+                logger.AssertLogContains("MSB4132");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""true""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+
+                logger.AssertLogContains("MSB4132");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_ErrorAndStop()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""ErrorAndStop""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.AssertLogContains("MSB4132");
+            }
+        }
+
+        [Fact]
+        public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_False()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <ReturnFailureWithoutLoggingErrorTask
+                            ContinueOnError=""false""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectFailure();
+
+                logger.AssertLogContains("MSB4132");
+            }
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index e7eb27b0d06..5cb0afd7c05 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -1137,7 +1137,7 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                             configurationId: request.Config.ConfigurationId,
                             escapedTargets: request.Targets,
                             hostServices: issuingEntry.Request.HostServices,
-                            parentBuildEventContext: issuingEntry.Request.BuildEventContext,
+                            parentBuildEventContext: issuingEntry.Request.CurrentTaskContext ?? issuingEntry.Request.BuildEventContext,
                             parentRequest: issuingEntry.Request,
                             buildRequestDataFlags: buildRequestDataFlags,
                             requestedProjectState: null,
diff --git a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
index 49f31354b1c..888ba5a557c 100644
--- a/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildLoggingContext.cs
@@ -65,6 +65,7 @@ internal void LogFatalTaskError(Exception exception, BuildEventFileInfo file, st
         {
             ErrorUtilities.VerifyThrow(IsValid, "must be valid");
             LoggingService.LogFatalTaskError(BuildEventContext, exception, file, taskName);
+            _hasLoggedErrors = true;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index 76ab4ee2278..2ba4ef2be8c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -28,6 +28,8 @@ internal class LoggingContext
         /// </summary>
         private bool _isValid;
 
+        protected bool _hasLoggedErrors;
+
         /// <summary>
         /// Constructs the logging context from a logging service and an event context.
         /// </summary>
@@ -41,6 +43,7 @@ public LoggingContext(ILoggingService loggingService, BuildEventContext eventCon
             _loggingService = loggingService;
             _eventContext = eventContext;
             _isValid = false;
+            _hasLoggedErrors = false;
         }
 
         /// <summary>
@@ -106,6 +109,8 @@ protected set
             }
         }
 
+        internal bool HasLoggedErrors { get { return _hasLoggedErrors; } set { _hasLoggedErrors = value; } }
+
         /// <summary>
         ///  Helper method to create a message build event from a string resource and some parameters
         /// </summary>
@@ -139,6 +144,7 @@ internal void LogError(BuildEventFileInfo file, string messageResourceName, para
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogError(_eventContext, file, messageResourceName, messageArgs);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -152,6 +158,7 @@ internal void LogErrorWithSubcategory(string subcategoryResourceName, BuildEvent
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogError(_eventContext, subcategoryResourceName, file, messageResourceName, messageArgs);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -166,6 +173,7 @@ internal void LogErrorFromText(string subcategoryResourceName, string errorCode,
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogErrorFromText(_eventContext, subcategoryResourceName, errorCode, helpKeyword, file, message);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -176,6 +184,7 @@ internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProj
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogInvalidProjectFileError(_eventContext, invalidProjectFileException);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -189,6 +198,7 @@ internal void LogFatalError(Exception exception, BuildEventFileInfo file, string
         {
             ErrorUtilities.VerifyThrow(_isValid, "must be valid");
             _loggingService.LogFatalError(_eventContext, exception, file, messageResourceName, messageArgs);
+            _hasLoggedErrors = true;
         }
 
         /// <summary>
@@ -231,12 +241,13 @@ internal void LogBuildEvent(BuildEventArgs buildEvent)
         /// <summary>
         /// Log an error based on an exception
         /// </summary>
-        /// <param name="exception">The exception wich is to be logged</param>
+        /// <param name="exception">The exception to be logged</param>
         /// <param name="file">The file in which the error occurred</param>
         internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
         {
             ErrorUtilities.VerifyThrow(IsValid, "must be valid");
             LoggingService.LogFatalBuildError(BuildEventContext, exception, file);
+            _hasLoggedErrors = true;
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 8963ddba8c3..86731a89db0 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -430,6 +430,8 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                     if (requirements != null)
                     {
                         TaskLoggingContext taskLoggingContext = _targetLoggingContext.LogTaskBatchStarted(_projectFullPath, _targetChildInstance);
+                        _buildRequestEntry.Request.CurrentTaskContext = taskLoggingContext.BuildEventContext;
+
                         try
                         {
                             if (
@@ -471,6 +473,8 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                         }
                         finally
                         {
+                            _buildRequestEntry.Request.CurrentTaskContext = null;
+
                             // Flag the completion of the task.
                             taskLoggingContext.LogTaskBatchFinished(_projectFullPath, taskResult.ResultCode == WorkUnitResultCode.Success || taskResult.ResultCode == WorkUnitResultCode.Skipped);
 
@@ -741,6 +745,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
             UpdateContinueOnError(bucket, taskHost);
 
             bool taskResult = false;
+            bool isMSBuildTask = false;
 
             WorkUnitResultCode resultCode = WorkUnitResultCode.Success;
             WorkUnitActionCode actionCode = WorkUnitActionCode.Continue;
@@ -764,9 +769,11 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     if (taskType == typeof(MSBuild))
                     {
                         MSBuild msbuildTask = host.TaskInstance as MSBuild;
+
                         ErrorUtilities.VerifyThrow(msbuildTask != null, "Unexpected MSBuild internal task.");
 
                         var undeclaredProjects = GetUndeclaredProjects(msbuildTask);
+                        isMSBuildTask = true;
 
                         if (undeclaredProjects != null && undeclaredProjects.Count != 0)
                         {
@@ -946,6 +953,28 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     }
                 }
 
+                // When a task fails it must log an error. If a task fails to do so,
+                // that is logged as an error. MSBuild tasks are an exception because
+                // errors are not logged directly from them, but the tasks spawned by them.
+                if (!isMSBuildTask && taskReturned && !taskResult && !taskLoggingContext.HasLoggedErrors)
+                {
+                    if (_continueOnError == ContinueOnError.WarnAndContinue)
+                    {
+                        taskLoggingContext.LogWarning(null,
+                            new BuildEventFileInfo(_targetChildInstance.Location),
+                            "TaskReturnedFalseButDidNotLogError",
+                            _taskNode.Name);
+
+                        taskLoggingContext.LogComment(MessageImportance.Normal, "ErrorConvertedIntoWarning");
+                    }
+                    else
+                    {
+                        taskLoggingContext.LogError(new BuildEventFileInfo(_targetChildInstance.Location),
+                            "TaskReturnedFalseButDidNotLogError",
+                            _taskNode.Name);
+                    }
+                }
+
                 // If the task returned attempt to gather its outputs.  If gathering outputs fails set the taskResults
                 // to false
                 if (taskReturned)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 7abf6948ee0..47626b64e6c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -441,6 +441,7 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                 {
                     e.BuildEventContext = _taskLoggingContext.BuildEventContext;
                     _taskLoggingContext.LoggingService.LogBuildEvent(e);
+                    _taskLoggingContext.HasLoggedErrors = true;
                 }
             }
         }
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 0b76c0090a2..ab48153c24a 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -1,4 +1,4 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
+// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
@@ -268,6 +268,13 @@ public BuildEventContext BuildEventContext
             }
         }
 
+        /// <summary>
+        /// The <see cref="BuildEventContext" /> of the currently executing task, if any.
+        /// Used to correlate a project's build with the parent task that spawned it
+        /// (usually the MSBuild task).
+        /// </summary>
+        public BuildEventContext CurrentTaskContext { get; set; }
+
         /// <summary>
         /// The set of flags specified in the BuildRequestData for this request.
         /// </summary>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index e080ba53491..065eb68560f 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -8,7 +8,6 @@
 using System.Text;
 using System.Globalization;
 using System.Security;
-using System.Text.Json;
 using System.Text.RegularExpressions;
 
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
@@ -19,7 +18,6 @@
 using ExceptionUtilities = Microsoft.Build.Shared.ExceptionHandling;
 using System.Collections.ObjectModel;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Construction
 {
@@ -88,7 +86,6 @@ public sealed class SolutionFile
         #endregion
         #region Member data
         private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
-        private HashSet<string> _solutionFilter;     // The project files to include in loading the solution.
         private bool _parsingForConversionOnly;      // Are we parsing this solution to get project reference data during
                                                      // conversion, or in preparation for actually building the solution?
 
@@ -199,48 +196,7 @@ internal string FullPath
             {
                 // Should already be canonicalized to a full path
                 ErrorUtilities.VerifyThrowInternalRooted(value);
-                if (FileUtilities.IsSolutionFilterFilename(value))
-                {
-                    try
-                    {
-                        using JsonDocument text = JsonDocument.Parse(File.ReadAllText(value));
-                        JsonElement solution = text.RootElement.GetProperty("solution");
-                        _solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
-                        if (!FileSystems.Default.FileExists(_solutionFile))
-                        {
-                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
-                            (
-                                "SubCategoryForSolutionParsingErrors",
-                                new BuildEventFileInfo(_solutionFile),
-                                "SolutionFilterMissingSolutionError",
-                                value,
-                                _solutionFile
-                            );
-                        }
-                        _solutionFilter = new HashSet<string>(NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
-                        foreach (JsonElement project in solution.GetProperty("projects").EnumerateArray())
-                        {
-                            _solutionFilter.Add(project.GetString());
-                        }
-                    }
-                    catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
-                    {
-                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
-                        (
-                            false, /* Just throw the exception */
-                            "SubCategoryForSolutionParsingErrors",
-                            new BuildEventFileInfo(value),
-                            e,
-                            "SolutionFilterJsonParsingError",
-                            value
-                        );
-                    }
-                }
-                else
-                {
-                    _solutionFile = value;
-                    _solutionFilter = null;
-                }
+                _solutionFile = value;
             }
         }
 
@@ -263,11 +219,6 @@ internal string FullPath
 
         #region Methods
 
-        internal bool ProjectShouldBuild(string projectFile)
-        {
-            return _solutionFilter == null || _solutionFilter.Contains(projectFile);
-        }
-
         /// <summary>
         /// This method takes a path to a solution file, parses the projects and project dependencies
         /// in the solution file, and creates internal data structures representing the projects within
@@ -338,6 +289,7 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
                         {
                             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
                                 (
+                                    false /* just throw the exception */,
                                     "SubCategoryForSolutionParsingErrors",
                                     new BuildEventFileInfo(solutionFile),
                                     "SolutionParseVersionMismatchError",
@@ -385,6 +337,7 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
             // Didn't find the header in lines 1-4, so the solution file is invalid.
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
                 (
+                    false /* just throw the exception */,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(solutionFile),
                     "SolutionParseNoHeaderError"
@@ -509,30 +462,6 @@ internal void ParseSolution()
                 }
             }
 
-            if (_solutionFilter != null)
-            {
-                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
-                foreach (ProjectInSolution project in _projectsInOrder)
-                {
-                    projectPaths.Add(project.RelativePath);
-                }
-                foreach (string project in _solutionFilter)
-                {
-                    if (!projectPaths.Contains(project))
-                    {
-                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
-                        (
-                            "SubCategoryForSolutionParsingErrors",
-                            new BuildEventFileInfo(project),
-                            "SolutionFilterFilterContainsProjectNotInSolution",
-                            _solutionFilter,
-                            project,
-                            _solutionFile
-                        );
-                    }
-                }
-            }
-
             if (rawProjectConfigurationsEntries != null)
             {
                 ProcessProjectConfigurationSection(rawProjectConfigurationsEntries);
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 308f5716534..1084744c3ba 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -637,12 +637,6 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionFile so
         /// </summary>
         private static bool WouldProjectBuild(SolutionFile solutionFile, string selectedSolutionConfiguration, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration)
         {
-            // If the solution filter does not contain this project, do not build it.
-            if (!solutionFile.ProjectShouldBuild(project.RelativePath))
-            {
-                return false;
-            }
-
             if (projectConfiguration == null)
             {
                 if (project.ProjectType == SolutionProjectType.WebProject)
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index c6e666f0c6d..fa1758c2ab5 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -30,7 +30,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 using EvaluationItemSpec = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>;
-using EvaluationItemExpressionFragment = Microsoft.Build.Evaluation.ItemExpressionFragment<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>;
+using EvaluationItemExpressionFragment = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>.ItemExpressionFragment;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 using System.Data.OleDb;
 
@@ -2501,13 +2501,13 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
             {
                 var includeItemspec = new EvaluationItemSpec(itemElement.Include, _data.Expander, itemElement.IncludeLocation, itemElement.ContainingProject.DirectoryPath);
 
-                ImmutableArray<ItemFragment> includeGlobFragments = includeItemspec.Fragments.Where(f => f is GlobFragment).ToImmutableArray();
+                ImmutableArray<ItemSpecFragment> includeGlobFragments = includeItemspec.Fragments.Where(f => f is GlobFragment).ToImmutableArray();
                 if (includeGlobFragments.Length == 0)
                 {
                     return null;
                 }
 
-                ImmutableArray<string> includeGlobStrings = includeGlobFragments.Select(f => f.ItemSpecFragment).ToImmutableArray();
+                ImmutableArray<string> includeGlobStrings = includeGlobFragments.Select(f => f.TextFragment).ToImmutableArray();
                 var includeGlob = new CompositeGlob(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
 
                 IEnumerable<string> excludeFragmentStrings = Enumerable.Empty<string>();
@@ -2751,7 +2751,7 @@ private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec
             {
                 provenance = Provenance.Undefined;
 
-                IEnumerable<ItemFragment> fragmentsMatchingItem = itemSpec.FragmentsMatchingItem(itemToMatch, out int occurrences);
+                IEnumerable<ItemSpecFragment> fragmentsMatchingItem = itemSpec.FragmentsMatchingItem(itemToMatch, out int occurrences);
                 foreach (var fragment in fragmentsMatchingItem)
                 {
                     if (fragment is ValueFragment)
@@ -3960,6 +3960,11 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// </summary>
             public PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
 
+            /// <summary>
+            /// A dictionary of all of the properties read from environment variables during evaluation.
+            /// </summary>
+            public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => this.Project.ProjectCollection.EnvironmentProperties;
+
             /// <summary>
             /// List of names of the properties that, while global, are still treated as overridable 
             /// </summary>
@@ -4334,7 +4339,7 @@ public IItemDefinition<ProjectMetadata> GetItemDefinition(string itemType)
             /// <summary>
             /// Sets a property which is not derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
+            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
             {
                 ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
                 Properties.Set(property);
@@ -4346,13 +4351,10 @@ public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bo
 
             /// <summary>
             /// Sets a property derived from Xml.
-            /// Predecessor is any immediately previous property that was overridden by this one during evaluation.
-            /// This would include all properties with the same name that lie above in the logical
-            /// project file, and whose conditions evaluated to true.
-            /// If there are none above this is null.
             /// </summary>
-            public ProjectProperty SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, ProjectProperty predecessor)
+            public ProjectProperty SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
             {
+                ProjectProperty predecessor = GetProperty(propertyElement.Name);
                 ProjectProperty property = ProjectProperty.Create(Project, propertyElement, evaluatedValueEscaped, predecessor);
                 Properties.Set(property);
 
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 3c27218071b..252498dfc67 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Collections.Immutable;
 using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.Globalization;
@@ -195,11 +194,26 @@ private Evaluator(
             int submissionId,
             EvaluationContext evaluationContext,
             bool profileEvaluation,
-            bool interactive)
+            bool interactive,
+            ILoggingService loggingService,
+            BuildEventContext buildEventContext)
         {
             ErrorUtilities.VerifyThrowInternalNull(data, nameof(data));
             ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
+            ErrorUtilities.VerifyThrowInternalNull(loggingService, nameof(loggingService));
+            ErrorUtilities.VerifyThrowInternalNull(buildEventContext, nameof(buildEventContext));
+
+            _evaluationLoggingContext = new EvaluationLoggingContext(
+                loggingService,
+                buildEventContext,
+                string.IsNullOrEmpty(projectRootElement.ProjectFileLocation.File) ? "(null)" : projectRootElement.ProjectFileLocation.File);
 
+            // If someone sets the 'MsBuildLogPropertyTracking' environment variable to a non-zero value, wrap property accesses for event reporting.
+            if (Traits.Instance.LogPropertyTracking > 0)
+            {
+                // Wrap the IEvaluatorData<> object passed in.
+                data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
+            }
             _evaluationContext = evaluationContext ?? EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated);
 
             // Create containers for the evaluation results
@@ -277,27 +291,27 @@ internal static void Evaluate(
             EvaluationContext evaluationContext = null,
             bool interactive = false)
         {
-            {
-                MSBuildEventSource.Log.EvaluateStart(root.ProjectFileLocation.File);
-                var profileEvaluation = (loadSettings & ProjectLoadSettings.ProfileEvaluation) != 0 || loggingService.IncludeEvaluationProfile;
-                var evaluator = new Evaluator<P, I, M, D>(
-                    data,
-                    root,
-                    loadSettings,
-                    maxNodeCount,
-                    environmentProperties,
-                    itemFactory,
-                    toolsetProvider,
-                    projectRootElementCache,
-                    sdkResolverService,
-                    submissionId,
-                    evaluationContext,
-                    profileEvaluation,
-                    interactive);
-
-                evaluator.Evaluate(loggingService, buildEventContext);
-                MSBuildEventSource.Log.EvaluateStop(root.ProjectFileLocation.File);
-            }
+            MSBuildEventSource.Log.EvaluateStart(root.ProjectFileLocation.File);
+            var profileEvaluation = (loadSettings & ProjectLoadSettings.ProfileEvaluation) != 0 || loggingService.IncludeEvaluationProfile;
+            var evaluator = new Evaluator<P, I, M, D>(
+                data,
+                root,
+                loadSettings,
+                maxNodeCount,
+                environmentProperties,
+                itemFactory,
+                toolsetProvider,
+                projectRootElementCache,
+                sdkResolverService,
+                submissionId,
+                evaluationContext,
+                profileEvaluation,
+                interactive,
+                loggingService,
+                buildEventContext);
+
+            evaluator.Evaluate();
+            MSBuildEventSource.Log.EvaluateStop(root.ProjectFileLocation.File);
         }
 
         /// <summary>
@@ -584,18 +598,16 @@ private static ProjectTargetInstance ReadNewTargetElement(ProjectTargetElement t
         /// Do the evaluation.
         /// Called by the static helper method.
         /// </summary>
-        private void Evaluate(ILoggingService loggingService, BuildEventContext buildEventContext)
+        private void Evaluate()
         {
-            string projectFile;
+            string projectFile = String.IsNullOrEmpty(_projectRootElement.ProjectFileLocation.File) ? "(null)" : _projectRootElement.ProjectFileLocation.File;
             using (_evaluationProfiler.TrackPass(EvaluationPass.TotalEvaluation))
             {
                 ErrorUtilities.VerifyThrow(_data.EvaluationId == BuildEventContext.InvalidEvaluationId, "There is no prior evaluation ID. The evaluator data needs to be reset at this point");
+                _data.EvaluationId = _evaluationLoggingContext.BuildEventContext.EvaluationId;
 
                 _logProjectImportedEvents = Traits.Instance.EscapeHatches.LogProjectImports;
 
-                ICollection<P> builtInProperties;
-                ICollection<P> environmentProperties;
-                ICollection<P> toolsetProperties;
                 ICollection<P> globalProperties;
 
                 using (_evaluationProfiler.TrackPass(EvaluationPass.InitialProperties))
@@ -603,9 +615,9 @@ private void Evaluate(ILoggingService loggingService, BuildEventContext buildEve
                     // Pass0: load initial properties
                     // Follow the order of precedence so that Global properties overwrite Environment properties
                     MSBuildEventSource.Log.EvaluatePass0Start(_projectRootElement.ProjectFileLocation.File);
-                    builtInProperties = AddBuiltInProperties();
-                    environmentProperties = AddEnvironmentProperties();
-                    toolsetProperties = AddToolsetProperties();
+                    AddBuiltInProperties();
+                    AddEnvironmentProperties();
+                    AddToolsetProperties();
                     globalProperties = AddGlobalProperties();
 
                     if (_interactive)
@@ -614,11 +626,6 @@ private void Evaluate(ILoggingService loggingService, BuildEventContext buildEve
                     }
                 }
 
-                projectFile = String.IsNullOrEmpty(_projectRootElement.ProjectFileLocation.File) ? "(null)" : _projectRootElement.ProjectFileLocation.File;
-
-                _evaluationLoggingContext = new EvaluationLoggingContext(loggingService, buildEventContext, projectFile);
-                _data.EvaluationId = _evaluationLoggingContext.BuildEventContext.EvaluationId;
-
                 _evaluationLoggingContext.LogProjectEvaluationStarted();
 
                 ErrorUtilities.VerifyThrow(_data.EvaluationId != BuildEventContext.InvalidEvaluationId, "Evaluation should produce an evaluation ID");
@@ -1205,7 +1212,7 @@ private ICollection<P> AddEnvironmentProperties()
 
             foreach (ProjectPropertyInstance environmentProperty in _environmentProperties)
             {
-                P property = _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, false /* NOT global property */, false /* may NOT be a reserved name */);
+                P property = _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
                 environmentPropertiesList.Add(property);
             }
 
@@ -1342,13 +1349,19 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
 
                 _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = null;
 
-                P predecessor = _data.GetProperty(propertyElement.Name);
-
-                P property = _data.SetProperty(propertyElement, evaluatedValue, predecessor);
+                if (Traits.Instance.LogPropertyTracking == 0)
+                {
+                    P predecessor = _data.GetProperty(propertyElement.Name);
+                    P property = _data.SetProperty(propertyElement, evaluatedValue);
 
-                if (predecessor != null)
+                    if (predecessor != null)
+                    {
+                        LogPropertyReassignment(predecessor, property, propertyElement.Location.LocationString);
+                    }
+                }
+                else
                 {
-                    LogPropertyReassignment(predecessor, property, propertyElement.Location.LocationString);
+                    _data.SetProperty(propertyElement, evaluatedValue);
                 }
             }
         }
@@ -1356,7 +1369,7 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
         private void LogPropertyReassignment(P predecessor, P property, string location)
         {
             string newValue = property.EvaluatedValue;
-            string oldValue = predecessor.EvaluatedValue;
+            string oldValue = predecessor?.EvaluatedValue;
 
             if (newValue != oldValue)
             {
@@ -2388,11 +2401,6 @@ private void SetAllProjectsProperty()
                         : $"{_lastModifiedProject.FullPath}{streamImports};{oldValue.EvaluatedValue}",
                     isGlobalProperty: false,
                     mayBeReserved: false);
-
-                if (oldValue != null)
-                {
-                    LogPropertyReassignment(oldValue, newValue, String.Empty);
-                }
             }
         }
     }
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index eb965e2c2ec..b91daae440a 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -205,6 +205,11 @@ List<ProjectItemElement> EvaluatedItemElements
             get;
         }
 
+        /// <summary>
+        /// A dictionary of all of the environment variable properties.
+        /// </summary>
+        PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary { get; }
+
         /// <summary>
         /// Prepares the data block for a new evaluation pass
         /// </summary>
@@ -263,16 +268,12 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
-        /// Predecessor is any immediately previous property that was overridden by this one during evaluation.
-        /// This would include all properties with the same name that lie above in the logical
-        /// project file, and whose conditions evaluated to true.
-        /// If there are none above this is null.
         /// </summary>
-        P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, P predecessor);
+        P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped);
 
         /// <summary>
         /// Retrieves an existing target, if any.
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 65c7c1936ef..460dcf6abbf 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -1,10 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.Collections.Generic;
-using System.Collections.Immutable;
-using System.IO;
 using System.Linq;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Internal;
@@ -13,30 +10,131 @@
 
 namespace Microsoft.Build.Evaluation
 {
-
     /// <summary>
-    /// Represents the elements of an item specification string and 
-    /// provides some operations over them (like matching items against a given ItemSpec)
+    ///     Represents the elements of an item specification string (e.g. Include="*.cs;foo;@(i)") and
+    ///     provides some operations over them (like matching items against a given ItemSpec)
     /// </summary>
     internal class ItemSpec<P, I>
         where P : class, IProperty
-        where I : class, IItem
+        where I : class, IItem, IMetadataTable
     {
+        internal readonly struct ReferencedItem
+        {
+            public I Item { get; }
+            public ValueFragment ItemAsValueFragment { get; }
+
+            public ReferencedItem(I item, ValueFragment itemAsValueFragment)
+            {
+                Item = item;
+                ItemAsValueFragment = itemAsValueFragment;
+            }
+        }
+
+        internal class ItemExpressionFragment : ItemSpecFragment
+        {
+            private readonly ItemSpec<P, I> _containingItemSpec;
+            private Expander<P, I> _expander;
+
+            private IMSBuildGlob _msbuildGlob;
+
+            private List<ReferencedItem> _referencedItems;
+            public ExpressionShredder.ItemExpressionCapture Capture { get; }
+
+            public List<ReferencedItem> ReferencedItems
+            {
+                get
+                {
+                    InitReferencedItemsIfNecessary();
+                    return _referencedItems;
+                }
+            }
+
+            protected override IMSBuildGlob MsBuildGlob
+            {
+                get
+                {
+                    if (InitReferencedItemsIfNecessary() || _msbuildGlob == null)
+                    {
+                        _msbuildGlob = CreateMsBuildGlob();
+                    }
+
+                    return _msbuildGlob;
+                }
+            }
+
+            public ItemExpressionFragment(
+                ExpressionShredder.ItemExpressionCapture capture,
+                string textFragment,
+                ItemSpec<P, I> containingItemSpec,
+                string projectDirectory)
+                : base(textFragment, projectDirectory)
+            {
+                Capture = capture;
+
+                _containingItemSpec = containingItemSpec;
+                _expander = _containingItemSpec.Expander;
+            }
+
+            public override int MatchCount(string itemToMatch)
+            {
+                return ReferencedItems.Count(v => v.ItemAsValueFragment.MatchCount(itemToMatch) > 0);
+            }
+
+            public override bool IsMatch(string itemToMatch)
+            {
+                return ReferencedItems.Any(v => v.ItemAsValueFragment.IsMatch(itemToMatch));
+            }
+
+            public override IMSBuildGlob ToMSBuildGlob()
+            {
+                return MsBuildGlob;
+            }
+
+            protected override IMSBuildGlob CreateMsBuildGlob()
+            {
+                return new CompositeGlob(ReferencedItems.Select(i => i.ItemAsValueFragment.ToMSBuildGlob()));
+            }
+
+            private bool InitReferencedItemsIfNecessary()
+            {
+                // cache referenced items as long as the expander does not change
+                // reference equality works for now since the expander cannot mutate its item state (hopefully it stays that way)
+                if (_referencedItems == null || _expander != _containingItemSpec.Expander)
+                {
+                    _expander = _containingItemSpec.Expander;
+
+                    _expander.ExpandExpressionCapture(
+                        Capture,
+                        _containingItemSpec.ItemSpecLocation,
+                        ExpanderOptions.ExpandItems,
+                        includeNullEntries: false,
+                        isTransformExpression: out _,
+                        itemsFromCapture: out var itemsFromCapture);
+                    _referencedItems =
+                        itemsFromCapture.Select(i => new ReferencedItem(i.Value, new ValueFragment(i.Key, ProjectDirectory))).ToList();
+
+                    return true;
+                }
+
+                return false;
+            }
+        }
+
         public string ItemSpecString { get; }
 
         /// <summary>
-        /// The fragments that compose an item spec string (values, globs, item references)
+        ///     The fragments that compose an item spec string (values, globs, item references)
         /// </summary>
-        public List<ItemFragment> Fragments { get; }
+        public List<ItemSpecFragment> Fragments { get; }
 
         /// <summary>
-        /// The expander needs to have a default item factory set.
+        ///     The expander needs to have a default item factory set.
         /// </summary>
         // todo Make this type immutable. Dealing with an Expander change is painful. See the ItemExpressionFragment
-        public Expander<P, I> Expander { get; set; }
+            public Expander<P, I> Expander { get; set; }
 
         /// <summary>
-        /// The xml attribute where this itemspec comes from
+        ///     The xml attribute where this itemspec comes from
         /// </summary>
         public IElementLocation ItemSpecLocation { get; }
 
@@ -45,7 +143,12 @@ internal class ItemSpec<P, I>
         /// <param name="itemSpecLocation">The xml location the itemspec comes from</param>
         /// <param name="projectDirectory">The directory that the project is in.</param>
         /// <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
-        public ItemSpec(string itemSpec, Expander<P, I> expander, IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties = true)
+        public ItemSpec(
+            string itemSpec,
+            Expander<P, I> expander,
+            IElementLocation itemSpecLocation,
+            string projectDirectory,
+            bool expandProperties = true)
         {
             ItemSpecString = itemSpec;
             Expander = expander;
@@ -54,20 +157,23 @@ public ItemSpec(string itemSpec, Expander<P, I> expander, IElementLocation itemS
             Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties);
         }
 
-        private List<ItemFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
+        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
         {
             //  Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
 
             if (string.IsNullOrEmpty(evaluatedItemspecEscaped))
             {
-                return new List<ItemFragment>();
+                return new List<ItemSpecFragment>();
             }
 
             // STEP 1: Expand properties in Include
             if (expandProperties)
             {
-                evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(ItemSpecString, ExpanderOptions.ExpandProperties, itemSpecLocation);
+                evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(
+                    ItemSpecString,
+                    ExpanderOptions.ExpandProperties,
+                    itemSpecLocation);
             }
 
             var semicolonCount = 0;
@@ -80,7 +186,7 @@ private List<ItemFragment> BuildItemFragments(IElementLocation itemSpecLocation,
             }
 
             // estimate the number of fragments with the number of semicolons. This is will overestimate in case of transforms with semicolons, but won't underestimate.
-            var fragments = new List<ItemFragment>(semicolonCount + 1);
+            var fragments = new List<ItemSpecFragment>(semicolonCount + 1);
 
             // STEP 2: Split Include on any semicolons, and take each split in turn
             if (evaluatedItemspecEscaped.Length > 0)
@@ -90,8 +196,11 @@ private List<ItemFragment> BuildItemFragments(IElementLocation itemSpecLocation,
                 foreach (var splitEscaped in splitsEscaped)
                 {
                     // STEP 3: If expression is "@(x)" copy specified list with its metadata, otherwise just treat as string
-                    bool isItemListExpression;
-                    var itemReferenceFragment = ProcessItemExpression(splitEscaped, itemSpecLocation, projectDirectory, out isItemListExpression);
+                    var itemReferenceFragment = ProcessItemExpression(
+                        splitEscaped,
+                        itemSpecLocation,
+                        projectDirectory,
+                        out var isItemListExpression);
 
                     if (isItemListExpression)
                     {
@@ -109,7 +218,6 @@ private List<ItemFragment> BuildItemFragments(IElementLocation itemSpecLocation,
                         // todo: file-system assumption on legal path characters: https://github.com/Microsoft/msbuild/issues/781
                         if (containsEscapedWildcards && containsRealWildcards)
                         {
-
                             // Just return the original string.
                             fragments.Add(new ValueFragment(splitEscaped, projectDirectory));
                         }
@@ -135,7 +243,11 @@ private List<ItemFragment> BuildItemFragments(IElementLocation itemSpecLocation,
             return fragments;
         }
 
-        private ItemExpressionFragment<P, I> ProcessItemExpression(string expression, IElementLocation elementLocation, string projectDirectory, out bool isItemListExpression)
+        private ItemExpressionFragment ProcessItemExpression(
+            string expression,
+            IElementLocation elementLocation,
+            string projectDirectory,
+            out bool isItemListExpression)
         {
             isItemListExpression = false;
 
@@ -145,7 +257,10 @@ private ItemExpressionFragment<P, I> ProcessItemExpression(string expression, IE
                 return null;
             }
 
-            var capture = Expander<P, I>.ExpandSingleItemVectorExpressionIntoExpressionCapture(expression, ExpanderOptions.ExpandItems, elementLocation);
+            var capture = Expander<P, I>.ExpandSingleItemVectorExpressionIntoExpressionCapture(
+                expression,
+                ExpanderOptions.ExpandItems,
+                elementLocation);
 
             if (capture == null)
             {
@@ -154,37 +269,40 @@ private ItemExpressionFragment<P, I> ProcessItemExpression(string expression, IE
 
             isItemListExpression = true;
 
-            return new ItemExpressionFragment<P, I>(capture, expression, this, projectDirectory);
+            return new ItemExpressionFragment(capture, expression, this, projectDirectory);
         }
 
         /// <summary>
-        /// Return true if the given <paramref name="item"/> matches this itemspec
+        ///     Return true if the given <paramref name="item" /> matches this itemspec
         /// </summary>
         /// <param name="item">The item to attempt to find a match for.</param>
         public bool MatchesItem(I item)
         {
             // Avoid unnecessary LINQ/Func/Enumerator allocations on this path, this is called a lot
 
-            string evaluatedInclude = item.EvaluatedInclude;
-            foreach (ItemFragment fragment in Fragments)
+            var evaluatedInclude = item.EvaluatedInclude;
+            foreach (var fragment in Fragments)
             {
-                if (fragment.MatchCount(evaluatedInclude) > 0)
+                if (fragment.IsMatch(evaluatedInclude))
+                {
                     return true;
+                }
             }
 
             return false;
         }
 
         /// <summary>
-        /// Return the fragments that match against the given <paramref name="itemToMatch"/>
+        ///     Return the fragments that match against the given <paramref name="itemToMatch" />
         /// </summary>
         /// <param name="itemToMatch">The item to match.</param>
         /// <param name="matches">
-        /// Total number of matches. Some fragments match more than once (item expression may contain multiple instances of <paramref name="itemToMatch"/>)
+        ///     Total number of matches. Some fragments match more than once (item expression may contain multiple instances of
+        ///     <paramref name="itemToMatch" />)
         /// </param>
-        public IEnumerable<ItemFragment> FragmentsMatchingItem(string itemToMatch, out int matches)
+        public IEnumerable<ItemSpecFragment> FragmentsMatchingItem(string itemToMatch, out int matches)
         {
-            var result = new List<ItemFragment>(Fragments.Count());
+            var result = new List<ItemSpecFragment>(Fragments.Count);
             matches = 0;
 
             foreach (var fragment in Fragments)
@@ -202,7 +320,7 @@ public IEnumerable<ItemFragment> FragmentsMatchingItem(string itemToMatch, out i
         }
 
         /// <summary>
-        /// Return an MSBuildGlob that represents this ItemSpec.
+        ///     Return an MSBuildGlob that represents this ItemSpec.
         /// </summary>
         public IMSBuildGlob ToMSBuildGlob()
         {
@@ -212,7 +330,6 @@ public IMSBuildGlob ToMSBuildGlob()
         /// <summary>
         ///     Returns all the fragment strings that represent it.
         ///     "1;*;2;@(foo)" gets returned as ["1", "2", "*", "a", "b"], given that @(foo)=["a", "b"]
-        /// 
         ///     Order is not preserved. Globs are not expanded. Item expressions get replaced with their referring item instances.
         /// </summary>
         public IEnumerable<string> FlattenFragmentsAsStrings()
@@ -221,15 +338,13 @@ public IEnumerable<string> FlattenFragmentsAsStrings()
             {
                 if (fragment is ValueFragment || fragment is GlobFragment)
                 {
-                    yield return fragment.ItemSpecFragment;
+                    yield return fragment.TextFragment;
                 }
-                else if (fragment is ItemExpressionFragment<P, I>)
+                else if (fragment is ItemExpressionFragment itemExpression)
                 {
-                    var itemExpression = (ItemExpressionFragment<P, I>) fragment;
-
                     foreach (var referencedItem in itemExpression.ReferencedItems)
                     {
-                        yield return referencedItem.ItemSpecFragment;
+                        yield return referencedItem.ItemAsValueFragment.TextFragment;
                     }
                 }
                 else
@@ -238,28 +353,31 @@ public IEnumerable<string> FlattenFragmentsAsStrings()
                 }
             }
         }
-		
+
         public override string ToString()
         {
             return ItemSpecString;
         }
     }
 
-    internal abstract class ItemFragment
+    internal abstract class ItemSpecFragment
     {
+        private FileSpecMatcherTester _fileMatcher;
+
+        private bool _fileMatcherInitialized;
+
+        private IMSBuildGlob _msbuildGlob;
+
         /// <summary>
-        /// The substring from the original itemspec representing this fragment
+        ///     The substring from the original itemspec representing this fragment
         /// </summary>
-        public string ItemSpecFragment { get; }
+        public string TextFragment { get; }
 
         /// <summary>
-        /// Path of the project the itemspec is coming from
+        ///     Path of the project the itemspec is coming from
         /// </summary>
         protected string ProjectDirectory { get; }
 
-        private bool _fileMatcherInitialized;
-        private FileSpecMatcherTester _fileMatcher;
-
         // not a Lazy to reduce memory
         private FileSpecMatcherTester FileMatcher
         {
@@ -277,32 +395,29 @@ private FileSpecMatcherTester FileMatcher
             }
         }
 
-        private IMSBuildGlob _msbuildGlob;
-
         // not a Lazy to reduce memory
-        protected virtual IMSBuildGlob MsBuildGlob
-        {
-            get
-            {
-                if (_msbuildGlob == null)
-                {
-                    _msbuildGlob = CreateMsBuildGlob();
-                }
-
-                return _msbuildGlob;
-            }
-        }
+        protected virtual IMSBuildGlob MsBuildGlob => _msbuildGlob ??= CreateMsBuildGlob();
 
-        protected ItemFragment(string itemSpecFragment, string projectDirectory)
+        protected ItemSpecFragment(string textFragment, string projectDirectory)
         {
-            ItemSpecFragment = itemSpecFragment;
+            TextFragment = textFragment;
             ProjectDirectory = projectDirectory;
         }
 
-        /// <returns>The number of times the <param name="itemToMatch"></param> appears in this fragment</returns>
+        /// <returns>The number of times the
+        ///     <param name="itemToMatch"></param>
+        ///     appears in this fragment
+        /// </returns>
         public virtual int MatchCount(string itemToMatch)
         {
-            return FileMatcher.IsMatch(itemToMatch) ? 1 : 0;
+            return IsMatch(itemToMatch)
+                ? 1
+                : 0;
+        }
+
+        public virtual bool IsMatch(string itemToMatch)
+        {
+            return FileMatcher.IsMatch(itemToMatch);
         }
 
         public virtual IMSBuildGlob ToMSBuildGlob()
@@ -312,112 +427,28 @@ public virtual IMSBuildGlob ToMSBuildGlob()
 
         protected virtual IMSBuildGlob CreateMsBuildGlob()
         {
-            return Globbing.MSBuildGlob.Parse(ProjectDirectory, ItemSpecFragment.Unescape());
+            return MSBuildGlob.Parse(ProjectDirectory, TextFragment.Unescape());
         }
 
         private FileSpecMatcherTester CreateFileSpecMatcher()
         {
-            return FileSpecMatcherTester.Parse(ProjectDirectory, ItemSpecFragment);
+            return FileSpecMatcherTester.Parse(ProjectDirectory, TextFragment);
         }
     }
 
-    internal class ValueFragment : ItemFragment
+    internal class ValueFragment : ItemSpecFragment
     {
-        public ValueFragment(string itemSpecFragment, string projectDirectory)
-            : base(itemSpecFragment, projectDirectory)
+        public ValueFragment(string textFragment, string projectDirectory)
+            : base(textFragment, projectDirectory)
         {
         }
     }
 
-    internal class GlobFragment : ItemFragment
+    internal class GlobFragment : ItemSpecFragment
     {
-        public GlobFragment(string itemSpecFragment, string projectDirectory)
-            : base(itemSpecFragment, projectDirectory)
-        {
-        }
-    }
-
-    internal class ItemExpressionFragment<P, I> : ItemFragment
-        where P : class, IProperty
-        where I : class, IItem
-    {
-        public ExpressionShredder.ItemExpressionCapture Capture { get; }
-
-        private readonly ItemSpec<P, I> _containingItemSpec;
-        private Expander<P, I> _expander;
-
-        private IList<ValueFragment> _referencedItems;
-        public IList<ValueFragment> ReferencedItems
-        {
-            get
-            {
-                InitReferencedItemsIfNecessary();
-                return _referencedItems;
-            }
-        }
-
-        private IMSBuildGlob _msbuildGlob;
-        protected override IMSBuildGlob MsBuildGlob
+        public GlobFragment(string textFragment, string projectDirectory)
+            : base(textFragment, projectDirectory)
         {
-            get
-            {
-                if (InitReferencedItemsIfNecessary() || _msbuildGlob == null)
-                {
-                    _msbuildGlob = CreateMsBuildGlob();
-                }
-
-                return _msbuildGlob;
-            }
-        }
-
-        public ItemExpressionFragment(ExpressionShredder.ItemExpressionCapture capture, string itemSpecFragment, ItemSpec<P, I> containingItemSpec, string projectDirectory)
-            : base(itemSpecFragment, projectDirectory)
-        {
-            Capture = capture;
-
-            _containingItemSpec = containingItemSpec;
-            _expander = _containingItemSpec.Expander;
-        }
-
-        public override int MatchCount(string itemToMatch)
-        {
-
-            return ReferencedItems.Count(v => v.MatchCount(itemToMatch) > 0);
-        }
-
-        public override IMSBuildGlob ToMSBuildGlob()
-        {
-            return MsBuildGlob;
-        }
-
-        protected override IMSBuildGlob CreateMsBuildGlob()
-        {
-            return new CompositeGlob(ReferencedItems.Select(i => i.ToMSBuildGlob()));
-        }
-
-        private bool InitReferencedItemsIfNecessary()
-        {
-            // cache referenced items as long as the expander does not change
-            // reference equality works for now since the expander cannot mutate its item state (hopefully it stays that way)
-            if (_referencedItems == null || _expander != _containingItemSpec.Expander)
-            {
-                _expander = _containingItemSpec.Expander;
-
-                List<Pair<string, I>> itemsFromCapture;
-                bool throwaway;
-                _expander.ExpandExpressionCapture(
-                    Capture,
-                    _containingItemSpec.ItemSpecLocation,
-                    ExpanderOptions.ExpandItems,
-                    false /* do not include null expansion results */,
-                    out throwaway,
-                    out itemsFromCapture);
-                _referencedItems = itemsFromCapture.Select(i => new ValueFragment(i.Key, ProjectDirectory)).ToList();
-
-                return true;
-            }
-
-            return false;
         }
     }
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index df3f02f78ac..550b876c290 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -124,6 +124,14 @@ public PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesDictionary
                 }
             }
 
+            public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary
+            {
+                get
+                {
+                    return _wrappedData.EnvironmentVariablePropertiesDictionary;
+                }
+            }
+
             public ISet<string> GlobalPropertiesToTreatAsLocal
             {
                 get
@@ -292,12 +300,12 @@ public void RecordImportWithDuplicates(ProjectImportElement importElement, Proje
                 _wrappedData.RecordImportWithDuplicates(importElement, import, versionEvaluated);
             }
 
-            public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, P predecessor)
+            public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
             {
-                return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped, predecessor);
+                return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped);
             }
 
-            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
+            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
             {
                 return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
             }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index a6643b784c2..cdd16bf54e6 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -60,26 +60,26 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
 
                 foreach (var fragment in _itemSpec.Fragments)
                 {
-                    if (fragment is ItemExpressionFragment<P, I>)
+                    if (fragment is ItemSpec<P, I>.ItemExpressionFragment itemReferenceFragment)
                     {
                         // STEP 3: If expression is "@(x)" copy specified list with its metadata, otherwise just treat as string
-                        bool throwaway;
                         var itemsFromExpression = _expander.ExpandExpressionCaptureIntoItems(
-                            ((ItemExpressionFragment<P, I>)fragment).Capture, _evaluatorData, _itemFactory, ExpanderOptions.ExpandItems,
-                            false /* do not include null expansion results */, out throwaway, _itemElement.IncludeLocation);
-
-                        if (excludeTester != null)
-                        {
-                            itemsToAdd.AddRange(itemsFromExpression.Where(item => !excludeTester.Value(item.EvaluatedInclude)));
-                        }
-                        else
-                        {
-                            itemsToAdd.AddRange(itemsFromExpression);
-                        }
+                            itemReferenceFragment.Capture,
+                            _evaluatorData,
+                            _itemFactory,
+                            ExpanderOptions.ExpandItems,
+                            includeNullEntries: false,
+                            isTransformExpression: out _,
+                            elementLocation: _itemElement.IncludeLocation);
+
+                        itemsToAdd.AddRange(
+                            excludeTester != null
+                                ? itemsFromExpression.Where(item => !excludeTester.Value(item.EvaluatedInclude))
+                                : itemsFromExpression);
                     }
-                    else if (fragment is ValueFragment)
+                    else if (fragment is ValueFragment valueFragment)
                     {
-                        string value = ((ValueFragment)fragment).ItemSpecFragment;
+                        string value = valueFragment.TextFragment;
 
                         if (excludeTester == null ||
                             !excludeTester.Value(EscapingUtilities.UnescapeAll(value)))
@@ -88,9 +88,9 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                             itemsToAdd.Add(item);
                         }
                     }
-                    else if (fragment is GlobFragment)
+                    else if (fragment is GlobFragment globFragment)
                     {
-                        string glob = ((GlobFragment)fragment).ItemSpecFragment;
+                        string glob = globFragment.TextFragment;
 
                         if (excludePatternsForGlobs == null)
                         {
@@ -132,9 +132,9 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
             private static ISet<string> BuildExcludePatternsForGlobs(ImmutableHashSet<string> globsToIgnore, ImmutableList<string>.Builder excludePatterns)
             {
                 var anyExcludes = excludePatterns.Count > 0;
-                var anyGlobstoIgnore = globsToIgnore.Count > 0;
+                var anyGlobsToIgnore = globsToIgnore.Count > 0;
 
-                if (anyGlobstoIgnore && anyExcludes)
+                if (anyGlobsToIgnore && anyExcludes)
                 {
                     return excludePatterns.Concat(globsToIgnore).ToImmutableHashSet();
                 }
@@ -144,7 +144,7 @@ private static ISet<string> BuildExcludePatternsForGlobs(ImmutableHashSet<string
 
             protected override void MutateItems(ImmutableList<I> items)
             {
-                DecorateItemsWithMetadata(items, _metadata);
+                DecorateItemsWithMetadata(items.Select(i => new ItemBatchingContext(i)), _metadata);
             }
 
             protected override void SaveItems(ImmutableList<I> items, ImmutableList<ItemData>.Builder listBuilder)
@@ -161,7 +161,7 @@ class IncludeOperationBuilder : OperationBuilderWithMetadata
             public int ElementOrder { get; set; }
             public string RootDirectory { get; set; }
 
-            public ImmutableList<string>.Builder Excludes { get; set; } = ImmutableList.CreateBuilder<string>();
+            public ImmutableList<string>.Builder Excludes { get; } = ImmutableList.CreateBuilder<string>();
 
             public IncludeOperationBuilder(ProjectItemElement itemElement, bool conditionResult) : base(itemElement, conditionResult)
             {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index e548eaa222c..45866736036 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -5,8 +5,10 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
+using System.Diagnostics;
 using System.Linq;
 
 namespace Microsoft.Build.Evaluation
@@ -48,18 +50,23 @@ protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M,
 
             protected EngineFileUtilities EngineFileUtilities => _lazyEvaluator.EngineFileUtilities;
 
-            public virtual void Apply(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            public void Apply(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
                 MSBuildEventSource.Log.ApplyLazyItemOperationsStart(_itemElement.ItemType);
                 using (_lazyEvaluator._evaluationProfiler.TrackElement(_itemElement))
                 {
-                    var items = SelectItems(listBuilder, globsToIgnore);
-                    MutateItems(items);
-                    SaveItems(items, listBuilder);
+                    ApplyImpl(listBuilder, globsToIgnore);
                 }
                 MSBuildEventSource.Log.ApplyLazyItemOperationsStop(_itemElement.ItemType);
             }
 
+            protected virtual void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+            {
+                var items = SelectItems(listBuilder, globsToIgnore);
+                MutateItems(items);
+                SaveItems(items, listBuilder);
+            }
+
             /// <summary>
             /// Produce the items to operate on. For example, create new ones or select existing ones
             /// </summary>
@@ -76,8 +83,7 @@ protected virtual void SaveItems(ImmutableList<I> items, ImmutableList<ItemData>
 
             private IList<I> GetReferencedItems(string itemType, ImmutableHashSet<string> globsToIgnore)
             {
-                LazyItemList itemList;
-                if (_referencedItemLists.TryGetValue(itemType, out itemList))
+                if (_referencedItemLists.TryGetValue(itemType, out var itemList))
                 {
                     return itemList.GetMatchedItems(globsToIgnore);
                 }
@@ -87,7 +93,88 @@ private IList<I> GetReferencedItems(string itemType, ImmutableHashSet<string> gl
                 }
             }
 
-            protected void DecorateItemsWithMetadata(ImmutableList<I> items, ImmutableList<ProjectMetadataElement> metadata)
+            [DebuggerDisplay(@"{DebugString()}")]
+            protected readonly struct ItemBatchingContext
+            {
+                public I OperationItem { get; }
+                private Dictionary<string, I> CapturedItems { get; }
+
+                public ItemBatchingContext(I operationItem, Dictionary<string, I> capturedItems = null)
+                {
+                    OperationItem = operationItem;
+
+                    CapturedItems = capturedItems == null || capturedItems.Count == 0
+                        ? null
+                        : capturedItems;
+                }
+
+                public IMetadataTable GetMetadataTable()
+                {
+                    return CapturedItems == null
+                        ? (IMetadataTable) OperationItem
+                        : new ItemOperationMetadataTable(OperationItem, CapturedItems);
+                }
+
+                private string DebugString()
+                {
+                    var referencedItemsString = CapturedItems == null
+                        ? "none"
+                        : string.Join(";", CapturedItems.Select(kvp => $"{kvp.Key} : {kvp.Value.EvaluatedInclude}"));
+
+                    return $"{OperationItem.Key} : {OperationItem.EvaluatedInclude}; CapturedItems: {referencedItemsString}";
+                }
+            }
+
+            private class ItemOperationMetadataTable : IMetadataTable
+            {
+                private readonly I _operationItem;
+                private readonly Dictionary<string, I> _capturedItems;
+
+                public ItemOperationMetadataTable(I operationItem, Dictionary<string, I> capturedItems)
+                {
+                    ErrorUtilities.VerifyThrow(
+                        capturedItems.Comparer == StringComparer.OrdinalIgnoreCase,
+                        "MSBuild assumes case insensitive item name comparison");
+
+                    _operationItem = operationItem;
+                    _capturedItems = capturedItems;
+                }
+
+                public string GetEscapedValue(string name)
+                {
+                    return _operationItem.GetEscapedValue(name);
+                }
+
+                public string GetEscapedValue(string itemType, string name)
+                {
+                    return RouteCall(itemType, name, (t, it, n) => t.GetEscapedValue(it, n));
+                }
+
+                public string GetEscapedValueIfPresent(string itemType, string name)
+                {
+                    return RouteCall(itemType, name, (t, it, n) => t.GetEscapedValueIfPresent(it, n));
+                }
+
+                private string RouteCall(string itemType, string name, Func<IMetadataTable, string, string, string> getEscapedValueFunc)
+                {
+                    if (itemType == null || itemType.Equals(_operationItem.Key, StringComparison.OrdinalIgnoreCase))
+                    {
+                        return getEscapedValueFunc(_operationItem, itemType, name);
+                    }
+                    else if (_capturedItems.ContainsKey(itemType))
+                    {
+                        var item = _capturedItems[itemType];
+
+                        return getEscapedValueFunc(item, itemType, name);
+                    }
+                    else
+                    {
+                        return string.Empty;
+                    }
+                }
+            }
+
+            protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBatchingContexts, ImmutableList<ProjectMetadataElement> metadata, bool? needToExpandMetadata = null)
             {
                 if (metadata.Count > 0)
                 {
@@ -120,46 +207,13 @@ protected void DecorateItemsWithMetadata(ImmutableList<I> items, ImmutableList<P
                     // Prior to lazy evaluation ExpanderOptions.ExpandAll was used.
                     const ExpanderOptions metadataExpansionOptions = ExpanderOptions.ExpandAll;
 
-                    List<string> values = new List<string>(metadata.Count * 2);
-
-                    foreach (var metadataElement in metadata)
-                    {
-                        values.Add(metadataElement.Value);
-                        values.Add(metadataElement.Condition);
-                    }
-
-                    ItemsAndMetadataPair itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(values);
-
-                    bool needToProcessItemsIndividually = false;
-
-                    if (itemsAndMetadataFound.Metadata != null && itemsAndMetadataFound.Metadata.Values.Count > 0)
-                    {
-                        // If there is bare metadata of any kind, and the Include involved an item list, we should
-                        // run items individually, as even non-built-in metadata might differ between items
-
-                        if (_referencedItemLists.Count >= 0)
-                        {
-                            needToProcessItemsIndividually = true;
-                        }
-                        else
-                        {
-                            // If there is bare built-in metadata, we must always run items individually, as that almost
-                            // always differs between items.
-
-                            // UNDONE: When batching is implemented for real, we need to make sure that
-                            // item definition metadata is included in all metadata operations during evaluation
-                            if (itemsAndMetadataFound.Metadata.Values.Count > 0)
-                            {
-                                needToProcessItemsIndividually = true;
-                            }
-                        }
-                    }
+                    needToExpandMetadata ??= NeedToExpandMetadataForEachItem(metadata, out _);
 
-                    if (needToProcessItemsIndividually)
+                    if (needToExpandMetadata.Value)
                     {
-                        foreach (I item in items)
+                        foreach (var itemContext in itemBatchingContexts)
                         {
-                            _expander.Metadata = item;
+                            _expander.Metadata = itemContext.GetMetadataTable();
 
                             foreach (var metadataElement in metadata)
                             {
@@ -170,7 +224,7 @@ protected void DecorateItemsWithMetadata(ImmutableList<I> items, ImmutableList<P
 
                                 string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location);
 
-                                item.SetMetadata(metadataElement, FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath));
+                                itemContext.OperationItem.SetMetadata(metadataElement, FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath));
                             }
                         }
 
@@ -222,13 +276,53 @@ protected void DecorateItemsWithMetadata(ImmutableList<I> items, ImmutableList<P
                         // This is valuable in the case where one item element evaluates to
                         // many items (either by semicolon or wildcards)
                         // and that item also has the same piece/s of metadata for each item.
-                        _itemFactory.SetMetadata(metadataList, items);
+                        _itemFactory.SetMetadata(metadataList, itemBatchingContexts.Select(i => i.OperationItem));
 
                         // End of legal area for metadata expressions.
                         _expander.Metadata = null;
                     }
                 }
             }
+
+            protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElement> metadata, out ItemsAndMetadataPair itemsAndMetadataFound)
+            {
+                List<string> values = new List<string>(metadata.Count * 2);
+
+                foreach (var metadataElement in metadata)
+                {
+                    values.Add(metadataElement.Value);
+                    values.Add(metadataElement.Condition);
+                }
+
+                itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(values);
+
+                bool needToExpandMetadataForEachItem = false;
+
+                if (itemsAndMetadataFound.Metadata != null && itemsAndMetadataFound.Metadata.Values.Count > 0)
+                {
+                    // If there is bare metadata of any kind, and the Include involved an item list, we should
+                    // run items individually, as even non-built-in metadata might differ between items
+
+                    if (_referencedItemLists.Count >= 0)
+                    {
+                        needToExpandMetadataForEachItem = true;
+                    }
+                    else
+                    {
+                        // If there is bare built-in metadata, we must always run items individually, as that almost
+                        // always differs between items.
+
+                        // UNDONE: When batching is implemented for real, we need to make sure that
+                        // item definition metadata is included in all metadata operations during evaluation
+                        if (itemsAndMetadataFound.Metadata.Values.Count > 0)
+                        {
+                            needToExpandMetadataForEachItem = true;
+                        }
+                    }
+                }
+
+                return needToExpandMetadataForEachItem;
+            }
         }
     }
 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index 83505983155..d4223130213 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
 
@@ -49,7 +48,7 @@ public ImmutableHashSet<string>.Builder GetRemovedGlobs()
                     return builder;
                 }
 
-                var globs = _itemSpec.Fragments.OfType<GlobFragment>().Select(g => g.ItemSpecFragment);
+                var globs = _itemSpec.Fragments.OfType<GlobFragment>().Select(g => g.TextFragment);
 
                 builder.UnionWith(globs);
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index ebd2232f541..24b3d9a375b 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -5,6 +5,8 @@
 using System.Collections.Generic;
 using Microsoft.Build.Construction;
 using System.Collections.Immutable;
+using System.Linq;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -20,9 +22,21 @@ public UpdateOperation(OperationBuilderWithMetadata builder, LazyItemEvaluator<P
                 _metadata = builder.Metadata.ToImmutable();
             }
 
-            delegate bool ItemSpecMatchesItem(ItemSpec<P, I> itemSpec, I item);
+            readonly struct MatchResult
+            {
+                public bool IsMatch { get; }
+                public Dictionary<string, I> CapturedItemsFromReferencedItemTypes { get; }
 
-            public override void Apply(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
+                public MatchResult(bool isMatch, Dictionary<string, I> capturedItemsFromReferencedItemTypes)
+                {
+                    IsMatch = isMatch;
+                    CapturedItemsFromReferencedItemTypes = capturedItemsFromReferencedItemTypes;
+                }
+            }
+
+            delegate MatchResult ItemSpecMatchesItem(ItemSpec<P, I> itemSpec, I itemToMatch);
+
+            protected override void ApplyImpl(ImmutableList<ItemData>.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
                 if (!_conditionResult)
                 {
@@ -30,25 +44,58 @@ public override void Apply(ImmutableList<ItemData>.Builder listBuilder, Immutabl
                 }
 
                 ItemSpecMatchesItem matchItemspec;
+                bool? needToExpandMetadataForEachItem = null;
 
-                if (ItemSpecOnlyReferencesOneItemType(_itemSpec, _itemElement.ItemType))
+                if (ItemspecContainsASingleItemReference(_itemSpec, _itemElement.ItemType))
                 {
                     // Perf optimization: If the Update operation references itself (e.g. <I Update="@(I)"/>)
                     // then all items are updated and matching is not necessary
-                    matchItemspec = (itemSpec, item) => true;
+                    matchItemspec = (itemSpec, item) => new MatchResult(true, null);
+                }
+                else if (ItemSpecContainsItemReferences(_itemSpec)
+                         && QualifiedMetadataReferencesExist(_metadata, out needToExpandMetadataForEachItem)
+                         && !Traits.Instance.EscapeHatches.DoNotExpandQualifiedMetadataInUpdateOperation)
+                {
+                    var itemReferenceFragments = _itemSpec.Fragments.OfType<ItemSpec<P,I>.ItemExpressionFragment>().ToArray();
+                    var nonItemReferenceFragments = _itemSpec.Fragments.Where(f => !(f is ItemSpec<P,I>.ItemExpressionFragment)).ToArray();
+
+                    matchItemspec = (itemSpec, item) =>
+                    {
+                        var isMatch = nonItemReferenceFragments.Any(f => f.IsMatch(item.EvaluatedInclude));
+                        Dictionary<string, I> capturedItemsFromReferencedItemTypes = null;
+
+                        foreach (var itemReferenceFragment in itemReferenceFragments)
+                        {
+                            foreach (var referencedItem in itemReferenceFragment.ReferencedItems)
+                            {
+                                if (referencedItem.ItemAsValueFragment.IsMatch(item.EvaluatedInclude))
+                                {
+                                    isMatch = true;
+
+                                    capturedItemsFromReferencedItemTypes ??= new Dictionary<string, I>(StringComparer.OrdinalIgnoreCase);
+
+                                    capturedItemsFromReferencedItemTypes[referencedItem.Item.Key] = referencedItem.Item;
+                                }
+                            }
+                        }
+
+                        return new MatchResult(isMatch, capturedItemsFromReferencedItemTypes);
+                    };
                 }
                 else
                 {
-                    matchItemspec = (itemSpec, item) => itemSpec.MatchesItem(item);
+                    matchItemspec = (itemSpec, item) => new MatchResult(itemSpec.MatchesItem(item), null);
                 }
 
-                var matchedItems = ImmutableList.CreateBuilder<I>();
+                var itemsToUpdate = ImmutableList.CreateBuilder<ItemBatchingContext>();
 
                 for (int i = 0; i < listBuilder.Count; i++)
                 {
                     var itemData = listBuilder[i];
 
-                    if (matchItemspec(_itemSpec, itemData.Item))
+                    var matchResult = matchItemspec(_itemSpec, itemData.Item);
+
+                    if (matchResult.IsMatch)
                     {
                         // items should be deep immutable, so clone and replace items before mutating them
                         // otherwise, with GetItems caching enabled, the mutations would leak into the cache causing
@@ -56,27 +103,52 @@ public override void Apply(ImmutableList<ItemData>.Builder listBuilder, Immutabl
                         var clonedItemData = listBuilder[i].Clone(_itemFactory, _itemElement);
                         listBuilder[i] = clonedItemData;
 
-                        matchedItems.Add(clonedItemData.Item);
+                        itemsToUpdate.Add(new ItemBatchingContext(clonedItemData.Item, matchResult.CapturedItemsFromReferencedItemTypes));
                     }
                 }
 
-                DecorateItemsWithMetadata(matchedItems.ToImmutableList(), _metadata);
+                DecorateItemsWithMetadata(itemsToUpdate.ToImmutableList(), _metadata, needToExpandMetadataForEachItem);
+            }
+
+            private bool QualifiedMetadataReferencesExist(ImmutableList<ProjectMetadataElement> metadata, out bool? needToExpandMetadataForEachItem)
+            {
+                needToExpandMetadataForEachItem = NeedToExpandMetadataForEachItem(metadata, out var itemsAndMetadataFound);
+
+                if (itemsAndMetadataFound.Metadata == null)
+                {
+                    return false;
+                }
+
+                foreach (var metadataReference in itemsAndMetadataFound.Metadata)
+                {
+                    if (!string.IsNullOrWhiteSpace(metadataReference.Value.ItemName))
+                    {
+                        return true;
+                    }
+                }
+
+                return false;
+            }
+
+            private static bool ItemSpecContainsItemReferences(ItemSpec<P, I> itemSpec)
+            {
+                return itemSpec.Fragments.Any(f => f is ItemSpec<P,I>.ItemExpressionFragment);
             }
 
-            private static bool ItemSpecOnlyReferencesOneItemType(ItemSpec<P, I> itemSpec, string itemType)
+            private static bool ItemspecContainsASingleItemReference(ItemSpec<P, I> itemSpec, string referencedItemType)
             {
                 if (itemSpec.Fragments.Count != 1)
                 {
                     return false;
                 }
 
-                var itemExpressionFragment = itemSpec.Fragments[0] as ItemExpressionFragment<P, I>;
+                var itemExpressionFragment = itemSpec.Fragments[0] as ItemSpec<P,I>.ItemExpressionFragment;
                 if (itemExpressionFragment == null)
                 {
                     return false;
                 }
 
-                if (!itemExpressionFragment.Capture.ItemType.Equals(itemType, StringComparison.OrdinalIgnoreCase))
+                if (!itemExpressionFragment.Capture.ItemType.Equals(referencedItemType, StringComparison.OrdinalIgnoreCase))
                 {
                     return false;
                 }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index ae62318c0a2..c0fa8277eb3 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -527,10 +527,9 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
         {
             builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory);
 
-            foreach (ItemFragment fragment in builder.ItemSpec.Fragments)
+            foreach (ItemSpecFragment fragment in builder.ItemSpec.Fragments)
             {
-                ItemExpressionFragment<P, I> itemExpression = fragment as ItemExpressionFragment<P, I>;
-                if (itemExpression != null)
+                if (fragment is ItemSpec<P, I>.ItemExpressionFragment itemExpression)
                 {
                     AddReferencedItemLists(builder, itemExpression.Capture);
                 }
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
new file mode 100644
index 00000000000..5d9b15567be
--- /dev/null
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -0,0 +1,323 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Shared.FileSystem;
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+
+namespace Microsoft.Build.Evaluation
+{
+    /// <summary>
+    /// Wraps an existing <see cref="IEvaluatorData{P,I,M,D}"/> allowing the property usage to be tracked.
+    /// </summary>
+    /// <typeparam name="P">The type of properties to be produced.</typeparam>
+    /// <typeparam name="I">The type of items to be produced.</typeparam>
+    /// <typeparam name="M">The type of metadata on those items.</typeparam>
+    /// <typeparam name="D">The type of item definitions to be produced.</typeparam>
+    internal class PropertyTrackingEvaluatorDataWrapper<P, I, M, D> : IEvaluatorData<P, I, M, D>
+        where P : class, IProperty, IEquatable<P>, IValued
+        where I : class, IItem
+        where M : class, IMetadatum
+        where D : class, IItemDefinition<M>
+    {
+        private readonly IEvaluatorData<P, I, M, D> _wrapped;
+        private readonly HashSet<string> _overwrittenEnvironmentVariables = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+        private readonly EvaluationLoggingContext _evaluationLoggingContext;
+        private readonly PropertyTrackingSetting _settings;
+
+        /// <summary>
+        /// Creates an instance of the PropertyTrackingEvaluatorDataWrapper class.
+        /// </summary>
+        /// <param name="dataToWrap">The underlying <see cref="IEvaluatorData{P,I,M,D}"/> to wrap for property tracking.</param>
+        /// <param name="evaluationLoggingContext">The <see cref="EvaluationLoggingContext"/> used to log relevant events.</param>
+        public PropertyTrackingEvaluatorDataWrapper(IEvaluatorData<P, I, M, D> dataToWrap, EvaluationLoggingContext evaluationLoggingContext, int settingValue)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(dataToWrap, nameof(dataToWrap));
+            ErrorUtilities.VerifyThrowInternalNull(evaluationLoggingContext, nameof(evaluationLoggingContext));
+
+            _wrapped = dataToWrap;
+            _evaluationLoggingContext = evaluationLoggingContext;
+            _settings = (PropertyTrackingSetting)settingValue;
+        }
+
+        #region IEvaluatorData<> members with tracking-related code in them.
+
+        /// <summary>
+        /// Returns a property with the specified name, or null if it was not found.
+        /// </summary>
+        /// <param name="name">The property name.</param>
+        /// <returns>The property.</returns>
+        public P GetProperty(string name)
+        {
+            P prop = _wrapped.GetProperty(name);
+            this.TrackPropertyRead(name, prop);
+            return prop;
+        }
+
+        /// <summary>
+        /// Returns a property with the specified name, or null if it was not found.
+        /// Name is the segment of the provided string with the provided start and end indexes.
+        /// </summary>
+        public P GetProperty(string name, int startIndex, int endIndex)
+        {
+            P prop = _wrapped.GetProperty(name, startIndex, endIndex);
+            this.TrackPropertyRead(name.Substring(startIndex, endIndex - startIndex + 1), prop);
+            return prop;
+        }
+
+        /// <summary>
+        /// Sets a property which does not come from the Xml.
+        /// </summary>
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
+        {
+            P originalProperty = _wrapped.GetProperty(name);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable);
+
+            this.TrackPropertyWrite(
+                originalProperty,
+                newProperty,
+                string.Empty,
+                this.DeterminePropertySource(isGlobalProperty, mayBeReserved, isEnvironmentVariable));
+
+            return newProperty;
+        }
+
+        /// <summary>
+        /// Sets a property which comes from the Xml.
+        /// Predecessor is any immediately previous property that was overridden by this one during evaluation.
+        /// This would include all properties with the same name that lie above in the logical
+        /// project file, and whose conditions evaluated to true.
+        /// If there are none above this is null.
+        /// </summary>
+        public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
+        {
+            P originalProperty = _wrapped.GetProperty(propertyElement.Name);
+            P newProperty = _wrapped.SetProperty(propertyElement, evaluatedValueEscaped);
+
+            this.TrackPropertyWrite(
+                originalProperty,
+                newProperty,
+                propertyElement.Location.LocationString,
+                PropertySource.Xml);
+
+            return newProperty;
+        }
+        #endregion
+
+        #region IEvaluatorData<> members that are forwarded directly to wrapped object.
+        public ICollection<I> GetItems(string itemType) => _wrapped.GetItems(itemType);
+        public int EvaluationId { get => _wrapped.EvaluationId; set => _wrapped.EvaluationId = value; }
+        public string Directory => _wrapped.Directory;
+        public TaskRegistry TaskRegistry { get => _wrapped.TaskRegistry; set => _wrapped.TaskRegistry = value; }
+        public Toolset Toolset => _wrapped.Toolset;
+        public string SubToolsetVersion => _wrapped.SubToolsetVersion;
+        public string ExplicitToolsVersion => _wrapped.ExplicitToolsVersion;
+        public PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesDictionary => _wrapped.GlobalPropertiesDictionary;
+        public ISet<string> GlobalPropertiesToTreatAsLocal => _wrapped.GlobalPropertiesToTreatAsLocal;
+        public List<string> InitialTargets { get => _wrapped.InitialTargets; set => _wrapped.InitialTargets = value; }
+        public List<string> DefaultTargets { get => _wrapped.DefaultTargets; set => _wrapped.DefaultTargets = value; }
+        public IDictionary<string, List<TargetSpecification>> BeforeTargets { get => _wrapped.BeforeTargets; set => _wrapped.BeforeTargets = value; }
+        public IDictionary<string, List<TargetSpecification>> AfterTargets { get => _wrapped.AfterTargets; set => _wrapped.AfterTargets = value; }
+        public Dictionary<string, List<string>> ConditionedProperties => _wrapped.ConditionedProperties;
+        public bool ShouldEvaluateForDesignTime => _wrapped.ShouldEvaluateForDesignTime;
+        public bool CanEvaluateElementsWithFalseConditions => _wrapped.CanEvaluateElementsWithFalseConditions;
+        public PropertyDictionary<P> Properties => _wrapped.Properties;
+        public IEnumerable<D> ItemDefinitionsEnumerable => _wrapped.ItemDefinitionsEnumerable;
+        public ItemDictionary<I> Items => _wrapped.Items;
+        public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
+        public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
+        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem) => _wrapped.InitializeForEvaluation(toolsetProvider, fileSystem);
+        public void FinishEvaluation() => _wrapped.FinishEvaluation();
+        public void AddItem(I item) => _wrapped.AddItem(item);
+        public void AddItemIgnoringCondition(I item) => _wrapped.AddItemIgnoringCondition(item);
+        public IItemDefinition<M> AddItemDefinition(string itemType) => _wrapped.AddItemDefinition(itemType);
+        public void AddToAllEvaluatedPropertiesList(P property) => _wrapped.AddToAllEvaluatedPropertiesList(property);
+        public void AddToAllEvaluatedItemDefinitionMetadataList(M itemDefinitionMetadatum) => _wrapped.AddToAllEvaluatedItemDefinitionMetadataList(itemDefinitionMetadatum);
+        public void AddToAllEvaluatedItemsList(I item) => _wrapped.AddToAllEvaluatedItemsList(item);
+        public IItemDefinition<M> GetItemDefinition(string itemType) => _wrapped.GetItemDefinition(itemType);
+        public ProjectTargetInstance GetTarget(string targetName) => _wrapped.GetTarget(targetName);
+        public void AddTarget(ProjectTargetInstance target) => _wrapped.AddTarget(target);
+        public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult) => _wrapped.RecordImport(importElement, import, versionEvaluated, sdkResult);
+        public void RecordImportWithDuplicates(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated) => _wrapped.RecordImportWithDuplicates(importElement, import, versionEvaluated);
+        public string ExpandString(string unexpandedValue) => _wrapped.ExpandString(unexpandedValue);
+        public bool EvaluateCondition(string condition) => _wrapped.EvaluateCondition(condition);
+        #endregion
+
+        #region Private Methods...
+        /// <summary>
+        /// Logic containing what to do when a property is read.
+        /// </summary>
+        /// <param name="name">The name of the property.</param>
+        /// <param name="property">The value of the property that was read (null if there is no value).</param>
+        private void TrackPropertyRead(string name, P property)
+        {
+            // MSBuild looks up a property called "InnerBuildProperty". If that isn't present,
+            // an empty string is returned and it then attempts to look up the value for that property
+            // (which is an empty string). Thus this check.
+            if (string.IsNullOrEmpty(name)) return;
+
+            // If a property matches the name of an environment variable, but has NOT been overwritten by a non-environment-variable property
+            // track it as an environment variable read.
+            if (_wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && !_overwrittenEnvironmentVariables.Contains(name))
+            {
+                this.TrackEnvironmentVariableRead(name);
+            }
+            else if (property == null)
+            {
+                this.TrackUninitializedPropertyRead(name);
+            }
+        }
+
+        /// <summary>
+        /// Logs an EnvironmentVariableRead event.
+        /// </summary>
+        /// <param name="name">The name of the environment variable read.</param>
+        private void TrackEnvironmentVariableRead(string name)
+        {
+            if ((_settings & PropertyTrackingSetting.EnvironmentVariableRead) != PropertyTrackingSetting.EnvironmentVariableRead) return;
+
+            var args = new EnvironmentVariableReadEventArgs(
+                name,
+                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentVariableRead", name));
+            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
+
+            _evaluationLoggingContext.LogBuildEvent(args);
+        }
+
+        /// <summary>
+        /// Logs an UninitializedPropertyRead event.
+        /// </summary>
+        /// <param name="name">The name of the uninitialized property read.</param>
+        private void TrackUninitializedPropertyRead(string name)
+        {
+            if ((_settings & PropertyTrackingSetting.UninitializedPropertyRead) != PropertyTrackingSetting.UninitializedPropertyRead) return;
+
+            var args = new UninitializedPropertyReadEventArgs(
+                name,
+                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("UninitializedPropertyRead", name));
+            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
+
+            _evaluationLoggingContext.LogBuildEvent(args);
+        }
+
+        private void TrackPropertyWrite(P predecessor, P property, string location, PropertySource source)
+        {
+            string name = property.Name;
+
+            // If this property was an environment variable but no longer is, track it.
+            if (_wrapped.EnvironmentVariablePropertiesDictionary.Contains(name) && source != PropertySource.EnvironmentVariable)
+            {
+                _overwrittenEnvironmentVariables.Add(name);
+            }
+
+            if (predecessor == null)
+            {
+                // If this property had no previous value, then track an initial value.
+                TrackPropertyInitialValueSet(property, source);
+            }
+            else
+            {
+                // There was a previous value, and it might have been changed. Track that.
+                TrackPropertyReassignment(predecessor, property, location);
+            }
+        }
+
+        /// <summary>
+        /// If the property's initial value is set, it logs a PropertyInitialValueSet event.
+        /// </summary>
+        /// <param name="property">The property being set.</param>
+        /// <param name="source">The source of the property.</param>
+        private void TrackPropertyInitialValueSet(P property, PropertySource source)
+        {
+            if ((_settings & PropertyTrackingSetting.PropertyInitialValueSet) != PropertyTrackingSetting.PropertyInitialValueSet) return;
+
+            var args = new PropertyInitialValueSetEventArgs(
+                    property.Name,
+                    property.EvaluatedValue,
+                    source.ToString(),
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("PropertyAssignment", property.Name, property.EvaluatedValue, source)
+                );
+            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
+
+            _evaluationLoggingContext.LogBuildEvent(args);
+        }
+
+        /// <summary>
+        /// If the property's value has changed, it logs a PropertyReassignment event.
+        /// </summary>
+        /// <param name="predecessor">The property's preceding state. Null if none.</param>
+        /// <param name="property">The property's current state.</param>
+        /// <param name="location">The location of this property's reassignment.</param>
+        private void TrackPropertyReassignment(P predecessor, P property, string location)
+        {
+            if ((_settings & PropertyTrackingSetting.PropertyReassignment) != PropertyTrackingSetting.PropertyReassignment) return;
+
+            string newValue = property.EvaluatedValue;
+            string oldValue = predecessor.EvaluatedValue;
+            if (newValue == oldValue) return;
+
+            var args = new PropertyReassignmentEventArgs(
+                property.Name,
+                oldValue,
+                newValue,
+                location,
+                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("PropertyReassignment", property.Name, newValue, oldValue, location));
+            args.BuildEventContext = _evaluationLoggingContext.BuildEventContext;
+
+            _evaluationLoggingContext.LogBuildEvent(args);
+        }
+
+        /// <summary>
+        /// Determines the source of a property given the variables SetProperty arguments provided. This logic follows what's in <see cref="Evaluator{P,I,M,D}"/>.
+        /// </summary>
+        private PropertySource DeterminePropertySource(bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable)
+        {
+            if (isEnvironmentVariable)
+            {
+                return PropertySource.EnvironmentVariable;
+            }
+
+            if (isGlobalProperty)
+            {
+                return PropertySource.Global;
+            }
+
+            return mayBeReserved ? PropertySource.BuiltIn : PropertySource.Toolset;
+        }
+
+        #endregion
+
+        /// <summary>
+        /// The available sources for a property.
+        /// </summary>
+        private enum PropertySource
+        {
+            Xml,
+            BuiltIn,
+            Global,
+            Toolset,
+            EnvironmentVariable
+        }
+
+        [Flags]
+        private enum PropertyTrackingSetting
+        {
+            None = 0,
+
+            PropertyReassignment = 1,
+            PropertyInitialValueSet = 1 << 1,
+            EnvironmentVariableRead = 1 << 2,
+            UninitializedPropertyRead = 1 << 3,
+
+            All = PropertyReassignment | PropertyInitialValueSet | EnvironmentVariableRead | UninitializedPropertyRead
+        }
+    }
+}
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 1ca74004420..ac9d3200de3 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -10,7 +10,6 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.CompilerServices;
-using System.Text.Json;
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
@@ -977,6 +976,11 @@ PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstan
             { return _globalProperties; }
         }
 
+        PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.EnvironmentVariablePropertiesDictionary
+        {
+            get => _environmentVariableProperties;
+        }
+
         /// <summary>
         /// List of names of the properties that, while global, are still treated as overridable 
         /// </summary>
@@ -1414,7 +1418,7 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// immutable if we are immutable.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable)
         {
             // Mutability not verified as this is being populated during evaluation
             ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable);
@@ -1427,7 +1431,7 @@ ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInsta
         /// Predecessor is discarded as it is a design time only artefact.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped, ProjectPropertyInstance predecessor)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped)
         {
             // Mutability not verified as this is being populated during evaluation
             ProjectPropertyInstance property = ProjectPropertyInstance.Create(propertyElement.Name, evaluatedValueEscaped, false /* may not be reserved */, _isImmutable);
@@ -2138,29 +2142,9 @@ internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, Prope
             // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution. 
             else
             {
-                string solutionFile = projectFile;
-                if (FileUtilities.IsSolutionFilterFilename(projectFile))
-                {
-                    try
-                    {
-                        using JsonDocument text = JsonDocument.Parse(File.ReadAllText(projectFile));
-                        JsonElement solution = text.RootElement.GetProperty("solution");
-                        solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
-                    }
-                    catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
-                    {
-                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
-                        (
-                            false, /* Just throw the exception */
-                            "SubCategoryForSolutionParsingErrors",
-                            new BuildEventFileInfo(projectFile),
-                            e,
-                            "SolutionFilterJsonParsingError",
-                            projectFile
-                        );
-                    }
-                }
-                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFile, out int solutionVersion, out int visualStudioVersion);
+                int solutionVersion;
+                int visualStudioVersion;
+                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(projectFile, out solutionVersion, out visualStudioVersion);
 
                 // If we get to this point, it's because it's a valid version.  Map the solution version 
                 // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old 
@@ -2188,7 +2172,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, Prope
 
                     string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
                         explicitToolsVersion: null,
-                        toolsVersionFromProject: FileUtilities.IsSolutionFilterFilename(projectFile) ? MSBuildConstants.CurrentToolsVersion : toolsVersion,
+                        toolsVersionFromProject: toolsVersion,
                         getToolset: buildParameters.GetToolset,
                         defaultToolsVersion: Constants.defaultSolutionWrapperProjectToolsVersion,
                         usingDifferentToolsVersionFromProjectFile: out _);
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index ac2345d8c20..61ad2576bb6 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -20,6 +20,10 @@ internal enum BinaryLogRecordKind
         ProjectEvaluationFinished,
         ProjectImported,
         ProjectImportArchive,
-        TargetSkipped
+        TargetSkipped,
+        PropertyReassignment,
+        UninitializedPropertyRead,
+        EnvironmentVariableRead,
+        PropertyInitialValueSet,
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index db193d0400c..052ab6a9f3a 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -1,6 +1,9 @@
 ﻿using System;
+using System.Diagnostics;
 using System.IO;
 using System.IO.Compression;
+using System.Linq;
+using System.Reflection;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -29,10 +32,14 @@ public sealed class BinaryLogger : ILogger
         // version 5:
         //   - new EvaluationFinished.ProfilerResult
         // version 6:
-        //   -  Ids and parent ids for the evaluation locations
+        //   - Ids and parent ids for the evaluation locations
         // version 7:
-        //   -  Include ProjectStartedEventArgs.GlobalProperties
-        internal const int FileFormatVersion = 7;
+        //   - Include ProjectStartedEventArgs.GlobalProperties
+        // version 8:
+        //   - This was used in a now-reverted change but is the same as 9.
+        // version 9:
+        //   - new record kinds: EnvironmentVariableRead, PropertyReassignment, UninitializedPropertyRead
+        internal const int FileFormatVersion = 9;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -139,9 +146,23 @@ public void Initialize(IEventSource eventSource)
 
             binaryWriter.Write(FileFormatVersion);
 
+            LogInitialInfo();
+
             eventSource.AnyEventRaised += EventSource_AnyEventRaised;
         }
 
+        private void LogInitialInfo()
+        {
+            LogMessage("BinLogFilePath=" + FilePath);
+        }
+
+        private void LogMessage(string text)
+        {
+            var args = new BuildMessageEventArgs(text, helpKeyword: null, senderName: "BinaryLogger", MessageImportance.Normal);
+            args.BuildEventContext = BuildEventContext.Invalid;
+            Write(args);
+        }
+
         /// <summary>
         /// Closes the underlying file stream.
         /// </summary>
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 213aa6f7d59..e67c64310af 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -112,6 +112,18 @@ public BuildEventArgs Read()
                 case BinaryLogRecordKind.TargetSkipped:
                     result = ReadTargetSkippedEventArgs();
                     break;
+                case BinaryLogRecordKind.EnvironmentVariableRead:
+                    result = ReadEnvironmentVariableReadEventArgs();
+                    break;
+                case BinaryLogRecordKind.PropertyReassignment:
+                    result = ReadPropertyReassignmentEventArgs();
+                    break;
+                case BinaryLogRecordKind.UninitializedPropertyRead:
+                    result = ReadUninitializedPropertyReadEventArgs();
+                    break;
+                case BinaryLogRecordKind.PropertyInitialValueSet:
+                    result = ReadPropertyInitialValueSetEventArgs();
+                    break;
                 default:
                     break;
             }
@@ -508,6 +520,85 @@ private BuildEventArgs ReadCriticalBuildMessageEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadEnvironmentVariableReadEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var importance = (MessageImportance)ReadInt32();
+
+            var environmentVariableName = ReadString();
+
+            var e = new EnvironmentVariableReadEventArgs(
+                environmentVariableName,
+                fields.Message,
+                fields.HelpKeyword,
+                fields.SenderName,
+                importance);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
+        private BuildEventArgs ReadPropertyReassignmentEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var importance = (MessageImportance)ReadInt32();
+            string propertyName = ReadString();
+            string previousValue = ReadString();
+            string newValue = ReadString();
+            string location = ReadString();
+
+            var e = new PropertyReassignmentEventArgs(
+                propertyName,
+                previousValue,
+                newValue,
+                location,
+                fields.Message,
+                fields.HelpKeyword,
+                fields.SenderName,
+                importance);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
+        private BuildEventArgs ReadUninitializedPropertyReadEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var importance = (MessageImportance)ReadInt32();
+            string propertyName = ReadString();
+
+            var e = new UninitializedPropertyReadEventArgs(
+                propertyName,
+                fields.Message,
+                fields.HelpKeyword,
+                fields.SenderName,
+                importance);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
+        private BuildEventArgs ReadPropertyInitialValueSetEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var importance = (MessageImportance)ReadInt32();
+            string propertyName = ReadString();
+            string propertyValue = ReadString();
+            string propertySource = ReadString();
+
+            var e = new PropertyInitialValueSetEventArgs(
+                propertyName,
+                propertyValue,
+                propertySource,
+                fields.Message,
+                fields.HelpKeyword,
+                fields.SenderName,
+                importance);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         /// <summary>
         /// For errors and warnings these 8 fields are written out explicitly
         /// (their presence is not marked as a bit in the flags). So we have to
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index a68e837a10a..8a46cb45cac 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -286,6 +286,30 @@ private void Write(BuildMessageEventArgs e)
                 return;
             }
 
+            if (e is PropertyReassignmentEventArgs)
+            {
+                Write((PropertyReassignmentEventArgs)e);
+                return;
+            }
+
+            if (e is UninitializedPropertyReadEventArgs)
+            {
+                Write((UninitializedPropertyReadEventArgs)e);
+                return;
+            }
+
+            if (e is EnvironmentVariableReadEventArgs)
+            {
+                Write((EnvironmentVariableReadEventArgs)e);
+                return;
+            }
+
+            if (e is PropertyInitialValueSetEventArgs)
+            {
+                Write((PropertyInitialValueSetEventArgs)e);
+                return;
+            }
+
             Write(BinaryLogRecordKind.Message);
             WriteMessageFields(e);
         }
@@ -315,6 +339,39 @@ private void Write(CriticalBuildMessageEventArgs e)
             WriteMessageFields(e);
         }
 
+        private void Write(PropertyReassignmentEventArgs e)
+        {
+            Write(BinaryLogRecordKind.PropertyReassignment);
+            WriteMessageFields(e);
+            Write(e.PropertyName);
+            Write(e.PreviousValue);
+            Write(e.NewValue);
+            Write(e.Location);
+        }
+
+        private void Write(UninitializedPropertyReadEventArgs e)
+        {
+            Write(BinaryLogRecordKind.UninitializedPropertyRead);
+            WriteMessageFields(e);
+            Write(e.PropertyName);
+        }
+
+        private void Write(PropertyInitialValueSetEventArgs e)
+        {
+            Write(BinaryLogRecordKind.PropertyInitialValueSet);
+            WriteMessageFields(e);
+            Write(e.PropertyName);
+            Write(e.PropertyValue);
+            Write(e.PropertySource);
+        }
+
+        private void Write(EnvironmentVariableReadEventArgs e)
+        {
+            Write(BinaryLogRecordKind.EnvironmentVariableRead);
+            WriteMessageFields(e);
+            Write(e.EnvironmentVariableName);
+        }
+
         private void Write(TaskCommandLineEventArgs e)
         {
             Write(BinaryLogRecordKind.TaskCommandLine);
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 1635d60e537..aa55562d5a5 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -34,7 +34,6 @@
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
     <PackageReference Include="System.Memory" />
-    <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
   </ItemGroup>
@@ -164,6 +163,7 @@
     <Compile Include="ObjectModelRemoting\DefinitionObjectsLinks\ProjectItemDefinitionLink.cs" />
     <Compile Include="ObjectModelRemoting\DefinitionObjectsLinks\ProjectItemLink.cs" />
     <Compile Include="ObjectModelRemoting\DefinitionObjectsLinks\ProjectLink.cs" />
+    <Compile Include="Evaluation\PropertyTrackingEvaluatorDataWrapper.cs" />
     <Compile Include="Graph\GraphBuilder.cs" />
     <Compile Include="Graph\ParallelWorkSet.cs" />
     <Compile Include="Graph\ProjectInterpretation.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index ded6b1fcf9a..d609f327a2f 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1063,6 +1063,10 @@
       LOCALIZATION: "{2}" is a localized message from a CLR/FX exception. Also, Microsoft.Build.Framework should not be localized
     </comment>
   </data>
+  <data name="TaskReturnedFalseButDidNotLogError">
+    <value>MSB4132: The "{0}" task returned false but did not log an error.</value>
+    <comment>{StrBegin="MSB4132: "}</comment>
+  </data>
   <data name="LoggerCreationError" UESanitized="true" Visibility="Public">
     <value>MSB1021: Cannot create an instance of the logger. {0}</value>
     <comment>{StrBegin="MSB1021: "}
@@ -1808,6 +1812,21 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="InvalidVersionFormat" xml:space="preserve">
     <value>Version string was not in a correct format.</value>
   </data>
+  <data name="UninitializedPropertyRead" UESanitized="false" Visibility="Public">
+    <value>Read uninitialized property "{0}"</value>
+    <comment>
+    </comment>
+  </data>
+  <data name="EnvironmentVariableRead" UESanitized="false" Visibility="Public">
+    <value>Read environment variable "{0}"</value>
+    <comment>
+    </comment>
+  </data>
+  <data name="PropertyAssignment" UESanitized="false" Visibility="Public">
+    <value>Property initial value: $({0})="{1}" Source: {2}</value>
+    <comment>
+    </comment>
+  </data>
   <!--
         The engine message bucket is: MSB4001 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index cf2198d6eed..33b6e3392ab 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: Zadaný výstupní soubor mezipaměti pro výsledky je prázdný.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: Při čtení vstupních souborů mezipaměti pro výsledky z cesty {0} byla zjištěna chyba: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Projekt {0} přeskočil omezení izolace grafu v odkazovaném projektu {1}.</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: Úloha MSBuild sestavuje projekty {0}, které nejsou zadané v položce ProjectReference. V izolovaných sestaveních to pravděpodobně znamená, že tyto odkazy nejsou v {1} explicitně zadané jako položka ProjectReference.</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Použití vstupních mezipamětí pro výsledky sestavení: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 590b4eccf11..251cf3c1df8 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: Die angegebene Cachedatei für Ausgabeergebnisse ist leer.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: Beim Lesen der Cachedateien für Eingabeergebnisse aus dem Pfad "{0}" wurde ein Fehler festgestellt: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Das Projekt "{0}" hat Graphisolationseinschränkungen für das referenzierte Projekt "{1}" übersprungen.</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: Der MSBuild-Task erstellt die Projekte "{0}", die im ProjectReference-Element nicht angegeben sind. In isolierten Builds bedeutet dies wahrscheinlich, dass die Verweise nicht explizit als ProjectReference-Element in "{1}" angegeben werden.</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Verwendete Eingabecaches für Buildergebnisse: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index efe19856060..4cbe8cb8cbb 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -75,6 +75,11 @@
         <target state="new">MSB4257: The specified output result cache file is empty.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="new">MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="new">MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="new">MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="new">Using input build results caches: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index ccc65afc673..685fbadd8ea 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: El archivo de caché de resultados de salida especificado está vacío.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: Error al leer los archivos de caché de resultados de entrada en la ruta de acceso "{0}": {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: El proyecto "{0}" ha omitido las restricciones de aislamiento de gráficos en el proyecto "{1}" al que se hace referencia.</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: La tarea MSBuild está compilando proyectos "{0}" que no se especifican en el elemento ProjectReference. En compilaciones aisladas, esto significa probablemente que las referencias no se especifican explícitamente como un elemento ProjectReference en "{1}".</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Usando las cachés de resultados de compilación: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 439b3e3cfca..db343510d59 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: Le fichier cache des résultats de sortie spécifié est vide.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: La lecture des fichiers cache des résultats d'entrée à partir du chemin "{0}" a rencontré une erreur : {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: le projet "{0}" a ignoré les contraintes d'isolement de graphe dans le projet référencé "{1}"</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: la tâche MSBuild génère un ou plusieurs projets "{0}" qui ne sont pas spécifiés dans l'élément ProjectReference. Dans les builds isolées, cela signifie probablement que les références ne sont pas explicitement spécifiées en tant qu'élément ProjectReference dans "{1}"</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Utilisation des caches de résultats de la build d'entrée : {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 8003caadb29..2606ef8f03b 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: il file della cache dei risultati di output specificato è vuoto.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: durante la lettura dei file della cache dei risultati di input dal percorso "{0}" è stato rilevato un errore: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: il progetto "{0}" ha ignorato i vincoli di isolamento del grafico nel progetto di riferimento "{1}"</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: il task MSBuild compila progetti "{0}" che non sono specificati nell'elemento ProjectReference. Nelle compilazioni isolate questa condizione indica probabilmente che i riferimenti non sono specificati in modo esplicito come elemento ProjectReference in "{1}"</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Uso delle cache dei risultati di compilazione di input: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index cfc1bc37222..e8eb191a8e1 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: 指定された出力結果キャッシュ ファイルは空です。</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: パス "{0}" から入力結果キャッシュ ファイルを読み取る処理でエラーが発生しました: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: プロジェクト "{0}" は、参照先のプロジェクト "{1}" で、グラフの分離制約をスキップしました</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: ProjectReference 項目で指定されていないプロジェクト "{0}" が MSBuild task によってビルドされています。分離されたビルドでは、これは多くの場合、参照が "{1}" で ProjectReference 項目として明示的に指定されていないことを意味します</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">次の入力ビルド結果キャッシュを使用しています: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 820bf445661..352879280c8 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: 지정한 출력 결과 캐시 파일이 비어 있습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: "{0}" 경로에서 입력 결과 캐시 파일을 읽는 중 오류가 발생했습니다. {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 프로젝트 "{0}"에서 참조된 프로젝트 "{1}"의 그래프 격리 제약 조건을 건너뛰었습니다.</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: MSBuild 작업에서 ProjectReference 항목에 지정되지 않은 "{0}" 프로젝트를 빌드하고 있습니다. 격리된 빌드에서 참조가 "{1}"에서 ProjectReference 항목으로 명시적으로 지정되지 않은 상태일 수 있습니다.</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">입력 빌드 결과 캐시 사용: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 0462cfbf7e6..2018cdcb104 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: Określony plik wyjściowej pamięci podręcznej wyników jest pusty.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: Podczas odczytywania plików wejściowej pamięci podręcznej wyników ze ścieżki „{0}” wystąpił błąd: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: W przypadku projektu „{0}” pominięto ograniczenia izolacji grafu dla przywoływanego projektu „{1}”</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: Zadanie programu MSBuild kompiluje projekty „{0}”, które nie są określone w elemencie ProjectReference. W przypadku kompilacji izolowanych prawdopodobnie oznacza to, że odwołania nie zostały jawnie określone jako element ProjectReference w pliku „{1}”</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Używanie wejściowych pamięci podręcznych wyników kompilacji: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index d96ab64cf04..ef4fc0fc9b3 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: o arquivo de cache do resultado de saída especificado está vazio.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: a leitura dos arquivos de cache do resultado de entrada do caminho "{0}" encontrou um erro: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: o projeto "{0}" ignorou as restrições de isolamento do gráfico no projeto referenciado "{1}"</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: a task MSBuild está criando projetos "{0}" que não estão especificados no item ProjectReference. Nos builds isolados isso provavelmente significa que as referências não estão explicitamente especificadas como um item ProjectReference em "{1}"</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Usando caches de resultados de build de entrada: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 35c5d5e5e28..94f60764ee7 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: указанный выходной файл кэша результатов пустой.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: произошла ошибка при чтении входных файлов кэша результатов из пути "{0}": {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: проект "{0}" пропустил ограничения изоляции графа в проекте "{1}", на который указывает ссылка.</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: задача MSBuild собирает проект(ы) {0}, которые не указаны в элементе ProjectReference. В изолированных сборках это может означать, что ссылки явно не указаны как элемент ProjectReference в "{1}".</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Используются входные файлы кэша результатов сборки: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 3db882d5d87..6e286b658ee 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: Belirtilen çıkış sonucu önbellek dosyası boş.</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: "{0}" yolundan giriş sonucu önbellek dosyaları okunurken bir hatayla karşılaşıldı: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: "{0}" projesi, başvurulan "{1}" projesindeki graf yalıtımı kısıtlamalarını atladı</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: MSBuild task, ProjectReference öğesinde belirtilmeyen "{0}" projelerini derliyor. Yalıtılmış derlemelerde bu, genellikle başvuruların "{1}" içinde açıkça ProjectReference öğesi olarak belirtilmediği anlamına gelir</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Giriş derleme sonuçları önbellekleri kullanılıyor: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 7c7d6f29a71..de877a23fb9 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: 指定的输出结果缓存文件为空。</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: 从路径“{0}”读取输入结果缓存文件时遇到错误: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 项目“{0}”已跳过所引用的项目“{1}”上的图形隔离约束</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: MSBuild 任务正在生成未在 ProjectReference 项中指定的项目“{0}”。在独立生成中，这可能表示未将引用显式地指定为“{1}”中的 ProjectReference 项</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">Using 输入生成结果缓存: {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 9fa55769437..61558f48a1c 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -75,6 +75,11 @@
         <target state="translated">MSB4257: 指定的輸出結果快取檔案是空的。</target>
         <note />
       </trans-unit>
+      <trans-unit id="EnvironmentVariableRead">
+        <source>Read environment variable "{0}"</source>
+        <target state="new">Read environment variable "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ErrorReadingCacheFile">
         <source>MSB4256: Reading input result cache files from path "{0}" encountered an error: {1}</source>
         <target state="translated">MSB4256: 從路徑 "{0}" 讀取輸入結果快取檔案發生錯誤: {1}</target>
@@ -133,6 +138,11 @@
       LOCALIZATION:  Do not localize the following words: ProjectGraph, ProjectReference, ToolsVersion.
     </note>
       </trans-unit>
+      <trans-unit id="PropertyAssignment">
+        <source>Property initial value: $({0})="{1}" Source: {2}</source>
+        <target state="new">Property initial value: $({0})="{1}" Source: {2}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 專案 "{0}" 已跳過參考專案 "{1}" 上的圖形隔離條件約束</target>
@@ -169,6 +179,11 @@
       LOCALIZATION: {0} is a file, {1} and {2} are semicolon delimited lists of messages
     </note>
       </trans-unit>
+      <trans-unit id="TaskReturnedFalseButDidNotLogError">
+        <source>MSB4132: The "{0}" task returned false but did not log an error.</source>
+        <target state="new">MSB4132: The "{0}" task returned false but did not log an error.</target>
+        <note>{StrBegin="MSB4132: "}</note>
+      </trans-unit>
       <trans-unit id="UndeclaredMSBuildTasksNotAllowedInIsolatedGraphBuilds">
         <source>MSB4254: The MSBuild task is building project(s) "{0}" which are not specified in the ProjectReference item. In isolated builds this probably means that the references are not explicitly specified as a ProjectReference item in "{1}"</source>
         <target state="translated">MSB4254: MSBuild 工作正在建置未在 ProjectReference 項目中指定的專案 "{0}"。在隔離式組建中，這可能代表未在 "{1}" 中將該參考明確指定為 ProjectReference 項目</target>
@@ -177,6 +192,11 @@
       LOCALIZATION: Do not localize the following words: ProjectReference, MSBuild, task.
     </note>
       </trans-unit>
+      <trans-unit id="UninitializedPropertyRead">
+        <source>Read uninitialized property "{0}"</source>
+        <target state="new">Read uninitialized property "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="UsingInputCaches">
         <source>Using input build results caches: {0}</source>
         <target state="translated">使用輸入組建結果快取: {0}</target>
diff --git a/src/Framework/EnvironmentVariableReadEventArgs.cs b/src/Framework/EnvironmentVariableReadEventArgs.cs
new file mode 100644
index 00000000000..f34cade967b
--- /dev/null
+++ b/src/Framework/EnvironmentVariableReadEventArgs.cs
@@ -0,0 +1,40 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Arguments for the environment variable read event.
+    /// </summary>
+    [Serializable]
+    public class EnvironmentVariableReadEventArgs : BuildMessageEventArgs
+    {
+        /// <summary>
+        /// Initializes an instance of the EnvironmentVariableReadEventArgs class.
+        /// </summary>
+        public EnvironmentVariableReadEventArgs()
+        {
+        }
+
+        /// <summary>
+        /// Initializes an instance of the EnvironmentVariableReadEventArgs class.
+        /// </summary>
+        /// <param name="environmentVariableName">The name of the environment variable that was read.</param>
+        public EnvironmentVariableReadEventArgs(
+            string environmentVariableName,
+            string message,
+            string helpKeyword = null,
+            string senderName = null,
+            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
+        {
+            this.EnvironmentVariableName = environmentVariableName;
+        }
+
+        /// <summary>
+        /// The name of the environment variable that was read.
+        /// </summary>
+        public string EnvironmentVariableName { get; set; }
+    }
+}
diff --git a/src/Framework/PropertyInitialValueSetEventArgs.cs b/src/Framework/PropertyInitialValueSetEventArgs.cs
new file mode 100644
index 00000000000..49754632277
--- /dev/null
+++ b/src/Framework/PropertyInitialValueSetEventArgs.cs
@@ -0,0 +1,54 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// The argument for a property initial value set event.
+    /// </summary>
+    [Serializable]
+    public class PropertyInitialValueSetEventArgs : BuildMessageEventArgs
+    {
+        /// <summary>
+        /// Creates an instance of the <see cref="PropertyInitialValueSetEventArgs"/> class.
+        /// </summary>
+        public PropertyInitialValueSetEventArgs() { }
+
+        /// <summary>
+        /// Creates an instance of the <see cref="PropertyInitialValueSetEventArgs"/> class.
+        /// </summary>
+        /// <param name="propertyName">The name of the property.</param>
+        /// <param name="propertyValue">The value of the property.</param>
+        /// <param name="propertySource">The source of the property.</param>
+        public PropertyInitialValueSetEventArgs(
+            string propertyName,
+            string propertyValue,
+            string propertySource,
+            string message,
+            string helpKeyword = null,
+            string senderName = null,
+            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
+        {
+            this.PropertyName = propertyName;
+            this.PropertyValue = propertyValue;
+            this.PropertySource = propertySource;
+        }
+
+        /// <summary>
+        /// The name of the property.
+        /// </summary>
+        public string PropertyName { get; set; }
+
+        /// <summary>
+        /// The value of the property.
+        /// </summary>
+        public string PropertyValue { get; set; }
+
+        /// <summary>
+        /// The source of the property.
+        /// </summary>
+        public string PropertySource { get; set; }
+    }
+}
diff --git a/src/Framework/PropertyReassignmentEventArgs.cs b/src/Framework/PropertyReassignmentEventArgs.cs
new file mode 100644
index 00000000000..6de36dab633
--- /dev/null
+++ b/src/Framework/PropertyReassignmentEventArgs.cs
@@ -0,0 +1,64 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// The argument for a property reassignment event.
+    /// </summary>
+    [Serializable]
+    public class PropertyReassignmentEventArgs : BuildMessageEventArgs
+    {
+        /// <summary>
+        /// Creates an instance of the PropertyReassignmentEventArgs class.
+        /// </summary>
+        public PropertyReassignmentEventArgs()
+        {
+        }
+
+        /// <summary>
+        /// Creates an instance of the PropertyReassignmentEventArgs class.
+        /// </summary>
+        /// <param name="propertyName">The name of the property whose value was reassigned.</param>
+        /// <param name="previousValue">The previous value of the reassigned property.</param>
+        /// <param name="newValue">The new value of the reassigned property.</param>
+        /// <param name="location">The location of the reassignment.</param>
+        public PropertyReassignmentEventArgs(
+            string propertyName,
+            string previousValue,
+            string newValue,
+            string location,
+            string message,
+            string helpKeyword = null,
+            string senderName = null,
+            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
+        {
+            this.PropertyName = propertyName;
+            this.PreviousValue = previousValue;
+            this.NewValue = newValue;
+            this.Location = location;
+        }
+
+        /// <summary>
+        /// The name of the property whose value was reassigned.
+        /// </summary>
+        public string PropertyName { get; set; }
+
+        /// <summary>
+        /// The previous value of the reassigned property.
+        /// </summary>
+        public string PreviousValue { get; set; }
+
+        /// <summary>
+        /// The new value of the reassigned property.
+        /// </summary>
+        public string NewValue { get; set; }
+
+        /// <summary>
+        /// The location of the reassignment.
+        /// </summary>
+        public string Location { get; set; }
+    }
+}
diff --git a/src/Framework/UninitializedPropertyReadEventArgs.cs b/src/Framework/UninitializedPropertyReadEventArgs.cs
new file mode 100644
index 00000000000..62448bdb008
--- /dev/null
+++ b/src/Framework/UninitializedPropertyReadEventArgs.cs
@@ -0,0 +1,40 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// The arguments for an uninitialized property read event.
+    /// </summary>
+    [Serializable]
+    public class UninitializedPropertyReadEventArgs : BuildMessageEventArgs
+    {
+        /// <summary>
+        /// UninitializedPropertyReadEventArgs
+        /// </summary>
+        public UninitializedPropertyReadEventArgs()
+        {
+        }
+
+        /// <summary>
+        /// Creates an instance of the UninitializedPropertyReadEventArgs class
+        /// </summary>
+        /// <param name="propertyName">The name of the uninitialized property that was read.</param>
+        public UninitializedPropertyReadEventArgs(
+            string propertyName,
+            string message,
+            string helpKeyword = null,
+            string senderName = null,
+            MessageImportance importance = MessageImportance.Low) : base(message, helpKeyword, senderName, importance)
+        {
+            this.PropertyName = propertyName;
+        }
+
+        /// <summary>
+        /// The name of the uninitialized property that was read.
+        /// </summary>
+        public string PropertyName { get; set; }
+    }
+}
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 49561847a6c..be9203b581a 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -45,12 +45,12 @@
     <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
-    <EmbeddedResource Include="..\MSBuild\Microsoft.Build.Core.xsd">
+    <EmbeddedResource Include="..\MSBuild\MSBuild\Microsoft.Build.Core.xsd">
       <Link>Microsoft.Build.Core.xsd</Link>
       <SubType>
       </SubType>
     </EmbeddedResource>
-    <EmbeddedResource Include="..\MSBuild\Microsoft.Build.CommonTypes.xsd">
+    <EmbeddedResource Include="..\MSBuild\MSBuild\Microsoft.Build.CommonTypes.xsd">
       <Link>Microsoft.Build.CommonTypes.xsd</Link>
       <SubType>
       </SubType>
diff --git a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
index 64d82056947..ae0e0d671f2 100644
--- a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
+++ b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
@@ -262,17 +262,21 @@ public void VerifyInvalidImportNotCaughtBySchema
         /// </summary>
         private string[] PrepareSchemaFiles()
         {
+            string msbuildXsdRootDirectory = Path.GetTempPath();
+            Directory.CreateDirectory(msbuildXsdRootDirectory);
+
             Stream msbuildXsdStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("Microsoft.Build.CommandLine.UnitTests.Microsoft.Build.xsd");
             StreamReader msbuildXsdStreamReader = new StreamReader(msbuildXsdStream);
             string msbuildXsdContents = msbuildXsdStreamReader.ReadToEnd();
-            string msbuildTempXsdFilename = FileUtilities.GetTemporaryFile();
+            string msbuildTempXsdFilename = Path.Combine(msbuildXsdRootDirectory, "Microsoft.Build.xsd");
             File.WriteAllText(msbuildTempXsdFilename, msbuildXsdContents);
 
+            string msbuildXsdSubDirectory = Path.Combine(msbuildXsdRootDirectory, "MSBuild");
+            Directory.CreateDirectory(msbuildXsdSubDirectory);
+
             msbuildXsdStream = Assembly.GetExecutingAssembly().GetManifestResourceStream("Microsoft.Build.CommandLine.UnitTests.Microsoft.Build.Core.xsd");
             msbuildXsdStreamReader = new StreamReader(msbuildXsdStream);
             msbuildXsdContents = msbuildXsdStreamReader.ReadToEnd();
-            string msbuildXsdSubDirectory = Path.Combine(Path.GetTempPath(), "MSBuild");
-            Directory.CreateDirectory(msbuildXsdSubDirectory);
             string msbuildTempXsdFilename2 = Path.Combine(msbuildXsdSubDirectory, "Microsoft.Build.Core.xsd");
             File.WriteAllText(msbuildTempXsdFilename2, msbuildXsdContents);
 
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 9e448504a9c..a2aa2c10440 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -735,10 +735,11 @@ public void MSBuildEngineLogger()
             string projectString =
                    "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
                     "<Project ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">" +
-                    "<Target Name=\"t\"><Message Text=\"Hello\"/></Target>" +
+                    "<Target Name=\"t\"><Message Text=\"[Hello]\"/></Target>" +
                     "</Project>";
             string tempdir = Path.GetTempPath();
             string projectFileName = Path.Combine(tempdir, "msbLoggertest.proj");
+            string logFile = Path.Combine(tempdir, "logFile");
             string quotedProjectFileName = "\"" + projectFileName + "\"";
 
             try
@@ -749,7 +750,7 @@ public void MSBuildEngineLogger()
                 }
 #if FEATURE_GET_COMMANDLINE
                 //Should pass
-                MSBuildApp.Execute(@"c:\bin\msbuild.exe /logger:FileLogger,""Microsoft.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"" " + quotedProjectFileName).ShouldBe(MSBuildApp.ExitType.Success);
+                MSBuildApp.Execute(@$"c:\bin\msbuild.exe /logger:FileLogger,""Microsoft.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"";""LogFile={logFile}"" /verbosity:detailed " + quotedProjectFileName).ShouldBe(MSBuildApp.ExitType.Success);
 
 #else
                 //Should pass
@@ -757,14 +758,26 @@ public void MSBuildEngineLogger()
                     new[]
                         {
                             NativeMethodsShared.IsWindows ? @"c:\bin\msbuild.exe" : "/msbuild.exe",
-                            @"/logger:FileLogger,""Microsoft.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a""",
+                            @$"/logger:FileLogger,""Microsoft.Build, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"";""LogFile={logFile}""",
+                            "/verbosity:detailed",
                             quotedProjectFileName
                         }).ShouldBe(MSBuildApp.ExitType.Success);
 #endif
+                File.Exists(logFile).ShouldBeTrue();
+
+                var logFileContents = File.ReadAllText(logFile);
+
+                logFileContents.ShouldContain("Process = ");
+                logFileContents.ShouldContain("MSBuild executable path = ");
+                logFileContents.ShouldContain("Command line arguments = ");
+                logFileContents.ShouldContain("Current directory = ");
+                logFileContents.ShouldContain("MSBuild version = ");
+                logFileContents.ShouldContain("[Hello]");
             }
             finally
             {
                 File.Delete(projectFileName);
+                File.Delete(logFile);
             }
         }
 
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 973855eb618..f86c9b04817 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -212,11 +212,15 @@
     <Content Include="MSBuild.rsp" Pack="false">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
-    <None Include="Microsoft.Build.CommonTypes.xsd">
+    <None Include="MSBuild\Microsoft.Build.CommonTypes.xsd">
       <SubType>Designer</SubType>
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
-    <None Include="Microsoft.Build.Core.xsd">
+    <None Include="MSBuild\Microsoft.Build.Core.xsd">
+      <SubType>Designer</SubType>
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+    <None Include="Microsoft.Build.xsd">
       <SubType>Designer</SubType>
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
@@ -293,6 +297,8 @@
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Common.tasks" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Managed.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
+      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Managed.Before.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
+      <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.Managed.After.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.CSharp.CrossTargeting.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.CSharp.CurrentVersion.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
       <_OurFiles Include="$(OutputPath)%(_TargetFrameworks.Identity)\Microsoft.CSharp.targets" TargetFramework="%(_TargetFrameworks.Identity)" />
diff --git a/src/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
similarity index 100%
rename from src/MSBuild/Microsoft.Build.CommonTypes.xsd
rename to src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
diff --git a/src/MSBuild/Microsoft.Build.Core.xsd b/src/MSBuild/MSBuild/Microsoft.Build.Core.xsd
similarity index 100%
rename from src/MSBuild/Microsoft.Build.Core.xsd
rename to src/MSBuild/MSBuild/Microsoft.Build.Core.xsd
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 69cbcd118b2..2911461fffc 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1248,6 +1248,21 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       LOCALIZATION: {0} contains the exception message explaining why the
       logger could not be created -- this message comes from the CLR/FX and is localized.
     </comment>
+  </data>
+  <data name="Process" UESanitized="true" Visibility="Public">
+    <value>Process = "{0}"</value>
+  </data>
+  <data name="MSBExePath" UESanitized="true" Visibility="Public">
+    <value>MSBuild executable path = "{0}"</value>
+  </data>
+  <data name="CommandLine" UESanitized="true" Visibility="Public">
+    <value>Command line arguments = "{0}"</value>
+  </data>
+  <data name="CurrentDirectory" UESanitized="true" Visibility="Public">
+    <value>Current directory = "{0}"</value>
+  </data>
+  <data name="MSBVersion" UESanitized="true" Visibility="Public">
+    <value>MSBuild version = "{0}"</value>
   </data>
     <!--
         The command line message bucket is: MSB1001 - MSB1999
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 187bec992eb..fa4e9982267 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : Konfigurace - error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: Lze zadat pouze jednu výstupní mezipaměť pro výsledky.</target>
@@ -1087,6 +1097,16 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Zadejte protokolovací nástroj.</target>
@@ -1185,6 +1205,11 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Soubor projektu neexistuje.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 33a04bfe27c..99c818a7b3e 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : Konfiguration, error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: Es darf nur ein Cache für Ausgabeergebnisse angegeben werden.</target>
@@ -1079,6 +1089,16 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Geben Sie eine Protokollierung an.</target>
@@ -1177,6 +1197,11 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Die Projektdatei ist nicht vorhanden.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.en.xlf b/src/MSBuild/Resources/xlf/Strings.en.xlf
index 54831323f57..340b05667a9 100644
--- a/src/MSBuild/Resources/xlf/Strings.en.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.en.xlf
@@ -20,6 +20,11 @@
       LOCALIZATION: The prefix "MSB1050 : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="new">MSBUILD : Configuration error {0}: {1}</target>
@@ -42,6 +47,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="new">MSBUILD : error MSB1058: Only one output results cache can be specified.</target>
@@ -1268,6 +1278,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="new">MSBUILD : error MSB1007: Specify a logger.</target>
@@ -1366,6 +1386,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="new">MSBUILD : error MSB1009: Project file does not exist.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 8ceb302dd0e..60af3a30c9a 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : Error de configuración; error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: Solo se puede especificar una memoria caché de resultados de salida.</target>
@@ -1088,6 +1098,16 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especifique un registrador.</target>
@@ -1186,6 +1206,11 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: El archivo de proyecto no existe.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 90bcbfb3912..2998a87346d 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : Configuration - error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: un seul cache de résultats de sortie peut être spécifié.</target>
@@ -1080,6 +1090,16 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Spécifiez un journal.</target>
@@ -1178,6 +1198,11 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Le fichier projet n'existe pas.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 842f9f7358f..20b4fb9a3e8 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : Configuration error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: è possibile specificare una sola cache dei risultati di output.</target>
@@ -1100,6 +1110,16 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: specificare un logger.</target>
@@ -1198,6 +1218,11 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: il file di progetto non esiste.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index dded98303db..50dcccbd76a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : 構成 error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation.All rights reserved.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: 指定できる出力結果キャッシュは 1 つのみです。</target>
@@ -1079,6 +1089,16 @@ Copyright (C) Microsoft Corporation.All rights reserved.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Logger を指定してください。</target>
@@ -1177,6 +1197,11 @@ Copyright (C) Microsoft Corporation.All rights reserved.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: プロジェクト ファイルが存在しません。</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index f7c9e9d83c5..0aa6ba4fe5e 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : 구성 error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: 출력 결과 캐시는 하나만 지정할 수 있습니다.</target>
@@ -1079,6 +1089,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 로거를 지정하십시오.</target>
@@ -1177,6 +1197,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 프로젝트 파일이 없습니다.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index b42f354646d..f99ca5a358a 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : konfiguracja — error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: można określić tylko jedną wyjściową pamięć podręczną wyników.</target>
@@ -1092,6 +1102,16 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: określ rejestrator.</target>
@@ -1190,6 +1210,11 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: plik projektu nie istnieje.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index d62dccfaf1e..7b88570d489 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : Configuration error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. Todos os direitos reservados.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: somente um cache de resultados de saída pode ser especificado.</target>
@@ -1080,6 +1090,16 @@ isoladamente.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especificar um agente de log.</target>
@@ -1178,6 +1198,11 @@ isoladamente.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Arquivo de projeto não existe.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 7208572366e..4d3fa935718 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : конфигурации error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: можно указать только один выходной файл кэша результатов.</target>
@@ -1079,6 +1089,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: укажите журнал.</target>
@@ -1177,6 +1197,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: файл проекта не существует.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 534daca3b7a..9b66eec9a29 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : Yapılandırma error {0}: {1}</target>
@@ -32,6 +37,11 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: Yalnızca bir çıkış sonuçları önbelleği belirtilebilir.</target>
@@ -1083,6 +1093,16 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Günlükçü belirtin.</target>
@@ -1181,6 +1201,11 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: Proje dosyası yok.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 066dc627c2b..9cda849791a 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : 配置 error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: 只能指定一个输出结果缓存。</target>
@@ -1079,6 +1089,16 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 请指定记录器。</target>
@@ -1177,6 +1197,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 项目文件不存在。</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index d4905ca2b9b..dd7e4a7a4a3 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -10,6 +10,11 @@
       fire this error.
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="CommandLine">
+        <source>Command line arguments = "{0}"</source>
+        <target state="new">Command line arguments = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ConfigurationFailurePrefixNoErrorCode">
         <source>MSBUILD : Configuration error {0}: {1}</source>
         <target state="translated">MSBUILD : 組態 error {0}: {1}</target>
@@ -32,6 +37,11 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
 </target>
         <note>LOCALIZATION: {0} contains the DLL version number. {1} contains the name of a runtime, like ".NET Framework", ".NET Core", or "Mono"</note>
       </trans-unit>
+      <trans-unit id="CurrentDirectory">
+        <source>Current directory = "{0}"</source>
+        <target state="new">Current directory = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOutputResultsCache">
         <source>MSBUILD : error MSB1058: Only one output results cache can be specified.</source>
         <target state="translated">MSBUILD : error MSB1058: 只能指定一個輸出結果快取。</target>
@@ -1079,6 +1089,16 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
         LOCALIZATION: The word "Logger" should be localized, the words "MSBuild" and "error" should NOT be localized.
       </note>
       </trans-unit>
+      <trans-unit id="MSBExePath">
+        <source>MSBuild executable path = "{0}"</source>
+        <target state="new">MSBuild executable path = "{0}"</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="MSBVersion">
+        <source>MSBuild version = "{0}"</source>
+        <target state="new">MSBuild version = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 指定記錄器。</target>
@@ -1177,6 +1197,11 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
       where the switches are coming from.
     </note>
       </trans-unit>
+      <trans-unit id="Process">
+        <source>Process = "{0}"</source>
+        <target state="new">Process = "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="ProjectNotFoundError">
         <source>MSBUILD : error MSB1009: Project file does not exist.</source>
         <target state="translated">MSBUILD : error MSB1009: 專案檔不存在。</target>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 170e7e200ed..19ad5bd1ded 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -13,6 +13,7 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Resources;
 using System.Security;
 using System.Text;
 using System.Text.RegularExpressions;
@@ -1178,7 +1179,13 @@ string outputResultsCache
                    new Semaphore(cpuCount, cpuCount, "cpuCount");
 
                     BuildResultCode? result = null;
-                    buildManager.BeginBuild(parameters);
+
+                    var messagesToLogInBuildLoggers = Traits.Instance.EscapeHatches.DoNotSendDeferredMessagesToBuildManager
+                        ? null
+                        : GetMessagesToLogInBuildLoggers();
+
+                    buildManager.BeginBuild(parameters, messagesToLogInBuildLoggers);
+
                     Exception exception = null;
                     try
                     {
@@ -1329,6 +1336,38 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
             }
         }
 
+        private static IEnumerable<BuildManager.DeferredBuildMessage> GetMessagesToLogInBuildLoggers()
+        {
+            return new[]
+            {
+                new BuildManager.DeferredBuildMessage(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                        "Process",
+                        Process.GetCurrentProcess().MainModule?.FileName ?? string.Empty),
+                    MessageImportance.Low),
+                new BuildManager.DeferredBuildMessage(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                        "MSBExePath",
+                        BuildEnvironmentHelper.Instance.CurrentMSBuildExePath),
+                    MessageImportance.Low),
+                new BuildManager.DeferredBuildMessage(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                        "CommandLine",
+                        Environment.CommandLine),
+                    MessageImportance.Low),
+                new BuildManager.DeferredBuildMessage(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                        "CurrentDirectory",
+                        Environment.CurrentDirectory),
+                    MessageImportance.Low),
+                new BuildManager.DeferredBuildMessage(
+                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                        "MSBVersion",
+                        ProjectCollection.DisplayVersion),
+                    MessageImportance.Low)
+            };
+        }
+
         private static (BuildResultCode result, Exception exception) ExecuteBuild(BuildManager buildManager, BuildRequestData request)
         {
             BuildSubmission submission;
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index 3d2c3a79701..e2ae215109f 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -30,21 +30,17 @@
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/System.Buffers.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/System.Text.Encodings.Web.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/System.Threading.Tasks.Extensions.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/System.ValueTuple.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Numerics.Vectors.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin" />
 
-    <file src="$X86BinPath$/Microsoft.Build.Core.xsd" target="v15.0/bin/MSBuild" />
-    <file src="$X86BinPath$/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/MSBuild" />
+    <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/MSBuild" />
+    <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/MSBuild" />
     <file src="$X86BinPath$/MSBuild.rsp" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.Managed.targets" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.Managed.Before.targets" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.Managed.After.targets" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.CSharp.targets" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.VisualBasic.targets" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.Common.CrossTargeting.targets" target="v15.0/bin" />
@@ -82,21 +78,17 @@
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin/amd64" />
-    <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin/amd64" />
-    <file src="$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll" target="v15.0/bin/amd64" />
-    <file src="$X86BinPath$/System.Buffers.dll" target="v15.0/bin/amd64" />
-    <file src="$X86BinPath$/System.Text.Encodings.Web.dll" target="v15.0/bin/amd64" />
-    <file src="$X86BinPath$/System.Threading.Tasks.Extensions.dll" target="v15.0/bin/amd64" />
-    <file src="$X86BinPath$/System.ValueTuple.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Numerics.Vectors.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin/amd64" />
 
-    <file src="$X86BinPath$/Microsoft.Build.Core.xsd" target="v15.0/bin/amd64/MSBuild" />
-    <file src="$X86BinPath$/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/amd64/MSBuild" />
+    <file src="$X86BinPath$/MSBuild/Microsoft.Build.Core.xsd" target="v15.0/bin/amd64/MSBuild" />
+    <file src="$X86BinPath$/MSBuild/Microsoft.Build.CommonTypes.xsd" target="v15.0/bin/amd64/MSBuild" />
     <file src="$X86BinPath$/MSBuild.rsp" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.Managed.targets" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.Managed.Before.targets" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.Managed.After.targets" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.CSharp.targets" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.VisualBasic.targets" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.Common.CrossTargeting.targets" target="v15.0/bin/amd64" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 693cc3049e2..3a0d9203509 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -38,11 +38,6 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
@@ -54,6 +49,8 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.Common.targets
   file source=$(X86BinPath)Microsoft.Common.tasks
   file source=$(X86BinPath)Microsoft.Managed.targets
+  file source=$(X86BinPath)Microsoft.Managed.Before.targets
+  file source=$(X86BinPath)Microsoft.Managed.After.targets
   file source=$(X86BinPath)Microsoft.CSharp.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.CSharp.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.CSharp.targets
@@ -75,8 +72,8 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.WorkflowBuildExtensions.targets
 
 folder InstallDir:\MSBuild\Current\Bin\MSBuild
-  file source=$(X86BinPath)Microsoft.Build.Core.xsd
-  file source=$(X86BinPath)Microsoft.Build.CommonTypes.xsd
+  file source=$(X86BinPath)\MSBuild\Microsoft.Build.Core.xsd
+  file source=$(X86BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
 
 folder InstallDir:\MSBuild\Current\Bin\ref
   file source=$(X86BinPath)ref\mscorlib.dll
@@ -184,11 +181,6 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
@@ -200,6 +192,8 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Common.targets
   file source=$(X86BinPath)Microsoft.Common.tasks
   file source=$(X86BinPath)Microsoft.Managed.targets
+  file source=$(X86BinPath)Microsoft.Managed.Before.targets
+  file source=$(X86BinPath)Microsoft.Managed.After.targets
   file source=$(X86BinPath)Microsoft.CSharp.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.CSharp.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.CSharp.targets
@@ -221,8 +215,8 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.WorkflowBuildExtensions.targets
 
 folder InstallDir:\MSBuild\Current\Bin\amd64\MSBuild
-  file source=$(X86BinPath)Microsoft.Build.Core.xsd
-  file source=$(X86BinPath)Microsoft.Build.CommonTypes.xsd
+  file source=$(X86BinPath)\MSBuild\Microsoft.Build.Core.xsd
+  file source=$(X86BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
 
 folder InstallDir:\MSBuild\Current\Bin\amd64\cs
   file source=$(X64BinPath)cs\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 885aaebc57e..7a69513847b 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -329,7 +329,13 @@ private static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)
 
         private static string GetMSBuildExeFromVsRoot(string visualStudioRoot)
         {
-            return FileUtilities.CombinePaths(visualStudioRoot, "MSBuild", CurrentToolsVersion, "Bin", "MSBuild.exe");
+            return FileUtilities.CombinePaths(
+                visualStudioRoot,
+                "MSBuild",
+                CurrentToolsVersion,
+                "Bin",
+                IntPtr.Size == 8 ? "amd64" : string.Empty,
+                "MSBuild.exe");
         }
 
         private static bool? _runningTests;
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 99661543b4b..92c330b45e3 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -954,21 +954,12 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
         }
 
         /// <summary>
-        /// This method returns true if the specified filename is a solution file (.sln) or
-        /// solution filter file (.slnf); otherwise, it returns false.
+        /// This method returns true if the specified filename is a solution file (.sln), otherwise
+        /// it returns false.
         /// </summary>
-        /// <remarks>
-        /// Solution filters are included because they are a thin veneer over solutions, just
-        /// with a more limited set of projects to build, and should be treated the same way.
-        /// </remarks>
         internal static bool IsSolutionFilename(string filename)
         {
-            return HasExtension(filename, ".sln") || HasExtension(filename, ".slnf");
-        }
-
-        internal static bool IsSolutionFilterFilename(string filename)
-        {
-            return HasExtension(filename, ".slnf");
+            return HasExtension(filename, ".sln");
         }
 
         /// <summary>
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 6bc94246966..c2f69cf67c5 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -670,11 +670,6 @@ internal static string GetOSNameForExtensionsPath()
             return IsOSX ? "osx" : IsUnixLike ? "unix" : "windows";
         }
 
-        internal static bool OSUsesCaseSensitivePaths
-        {
-            get { return IsLinux; }
-        }
-
         /// <summary>
         /// The base directory for all framework paths in Mono
         /// </summary>
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index b69f4998adc..9e49658e8b4 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -77,29 +77,6 @@ params object[] args
             VerifyThrowInvalidProjectFile(condition, null, projectFile, resourceName, args);
         }
 
-        /// <summary>
-        /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
-        /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
-        /// 
-        /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
-        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
-        /// </summary>
-        /// <param name="condition">The condition to check.</param>
-        /// <param name="errorSubCategoryResourceName">The resource string for the error sub-category (can be null).</param>
-        /// <param name="projectFile">The invalid project file.</param>
-        /// <param name="resourceName">The resource string for the error message.</param>
-        /// <param name="args">Extra arguments for formatting the error message.</param>
-        internal static void VerifyThrowInvalidProjectFile
-        (
-            string errorSubCategoryResourceName,
-            BuildEventFileInfo projectFile,
-            string resourceName,
-            params object[] args
-        )
-        {
-            VerifyThrowInvalidProjectFile(false, errorSubCategoryResourceName, projectFile, null, resourceName, args);
-        }
-
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index fd568252430..ad6b7925fc1 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -262,22 +262,10 @@
     <value>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</value>
     <comment></comment>
   </data>
-  <data name="SolutionFilterJsonParsingError" Visibility="Public">
-    <value>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</value>
-    <comment>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</comment>
-  </data>
-  <data name="SolutionFilterMissingSolutionError" Visibility="Public">
-    <value>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</value>
-    <comment>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</comment>
-  </data>
-  <data name="SolutionFilterFilterContainsProjectNotInSolution" Visibility="Public">
-    <value>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</value>
-    <comment>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</comment>
-  </data>
   <!--
         The shared message bucket is: MSB5001 - MSB5999
 
-        Next message code should be MSB5029
+        Next message code should be MSB5025
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 00a783fd1db..5d65ee0a93b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -65,21 +65,6 @@
         <target state="translated">Cesta: {0} překračuje maximální limit pro cestu k OS. Plně kvalifikovaný název souboru musí být kratší než {1} znaků.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Verze nástrojů {0} je neznámá. Dostupné verze nástrojů jsou {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index e3bd8284ae0..0a0fce1dbb9 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -65,21 +65,6 @@
         <target state="translated">Der Pfad "{0}" überschreitet das maximale Pfadlimit des Betriebssystems. Der vollqualifizierte Dateiname muss weniger als {1} Zeichen umfassen.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Die Toolsversion "{0}" ist unbekannt. Verfügbare Toolversionen sind {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.en.xlf b/src/Shared/Resources/xlf/Strings.shared.en.xlf
index cf10e5c095a..89e1330b798 100644
--- a/src/Shared/Resources/xlf/Strings.shared.en.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.en.xlf
@@ -70,21 +70,6 @@
         <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 0860cf5f017..62c0b3ef027 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -65,21 +65,6 @@
         <target state="translated">La ruta de acceso {0} supera el límite máximo para la ruta de acceso del sistema operativo. El nombre de archivo completo debe ser inferior a {1} caracteres.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: No se reconoce la versión de herramientas "{0}". Las versiones de herramientas disponibles son {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index b0ee0eaf271..09edfc73b93 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -65,21 +65,6 @@
         <target state="translated">Le chemin {0} dépasse la limite maximale de chemin du système d'exploitation. Le nom du fichier qualifié complet doit contenir moins de {1} caractères.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: La version des outils "{0}" n'est pas reconnue. Les versions disponibles sont {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index fa13a591797..33fb3b72d80 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -65,21 +65,6 @@
         <target state="translated">Il percorso {0} supera il limite massimo dei percorsi del sistema operativo. Il nome completo del file deve essere composto da meno di {1}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: versione degli strumenti "{0}" non riconosciuta. Le versioni disponibili sono {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index d4c5be36d60..d38f7aba8ed 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -4,67 +4,47 @@
     <body>
       <trans-unit id="BuildAborted">
         <source>MSB4188: Build was canceled.</source>
-        <target state="new">MSB4188: Build was canceled.</target>
+        <target state="translated">MSB4188: ビルドが取り消されました。</target>
         <note>{StrBegin="MSB4188: "} Error when the build stops suddenly for some reason. For example, because a child node died.</note>
       </trans-unit>
       <trans-unit id="BuildEngineCallbacksInTaskHostUnsupported">
         <source>MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</source>
-        <target state="new">MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</target>
+        <target state="translated">MSB5022: MSBuild タスク ホストは、IBuildEngine コールバックを実行するタスクの実行をサポートしていません。これらの操作を実行する場合は、タスクをコア MSBuild プロセスで実行してください。UsingTask の属性として設定されている "Runtime" または "Architecture" の値、あるいはタスク呼び出しの属性として設定されている "MSBuildRuntime" または "MSBuildArchitecture" の値が MSBuild の現在のランタイムまたはアーキテクチャと一致しない場合、タスクは自動的にタスク ホストで実行されます。</target>
         <note>{StrBegin="MSB5022: "} "Runtime", "Architecture", "MSBuildRuntime", and "MSBuildArchitecture" are all attributes in the project file, and thus should not be localized.</note>
       </trans-unit>
       <trans-unit id="BuildStarted">
         <source>Build started.</source>
-        <target state="new">Build started.</target>
+        <target state="translated">ビルドを開始しました。</target>
         <note />
       </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
-        <target state="new">MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</target>
+        <target state="translated">MSB4008: タスク アセンブリ "{0}" に対して競合しているアセンブリが "{1}" で見つかりました。</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
-      <trans-unit id="DirectoryNotFound">
-        <source>Could not find directory path: {0}</source>
-        <target state="new">Could not find directory path: {0}</target>
-        <note>Directory must exist</note>
-      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
-        <target state="new">Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</target>
+        <target state="translated">イベントの種類 "{0}" は .NET シリアライザーを使用してシリアル化可能であることが想定されていましたが、シリアル化可能でなかったため無視されました。</target>
         <note />
       </trans-unit>
       <trans-unit id="FileLocation">
         <source>{0} ({1},{2})</source>
-        <target state="new">{0} ({1},{2})</target>
+        <target state="translated">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
-        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
-        <target state="new">When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</target>
-        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
-        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
-        <target state="new">.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
-        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
-        <target state="new">.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
-        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
-        <target state="new">Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</target>
-        <note />
+      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
+        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
+        <target state="translated">親ノードから受け取った環境をタスク ホストに適用する前に、次の変更を行っています:</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
-      <trans-unit id="InvalidLogFileFormat">
-        <source>MSB4233: There was an exception while reading the log file: {0}</source>
-        <target state="new">MSB4233: There was an exception while reading the log file: {0}</target>
-        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
+      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
+        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
+        <target state="translated">  '{0}' を親環境の値 '{2}' ではなく '{1}' に設定しています。</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
       <trans-unit id="InvalidProjectFile">
         <source>MSB4025: The project file could not be loaded. {0}</source>
-        <target state="new">MSB4025: The project file could not be loaded. {0}</target>
+        <target state="translated">MSB4025: プロジェクト ファイルを読み込めませんでした。{0}</target>
         <note>{StrBegin="MSB4025: "}UE: This message is shown when the project file given to the engine cannot be loaded because the filename/path is
     invalid, or due to lack of permissions, or incorrect XML. The project filename is not part of the message because it is
     provided separately to loggers.
@@ -72,236 +52,241 @@
       </trans-unit>
       <trans-unit id="InvalidVerbosity">
         <source>MSB4103: "{0}" is not a valid logger verbosity level.</source>
-        <target state="new">MSB4103: "{0}" is not a valid logger verbosity level.</target>
+        <target state="translated">MSB4103: "{0}" は有効なロガー詳細レベルではありません。</target>
         <note>{StrBegin="MSB4103: "}</note>
       </trans-unit>
       <trans-unit id="MissingProject">
         <source>MSBuild is expecting a valid "{0}" object.</source>
-        <target state="new">MSBuild is expecting a valid "{0}" object.</target>
+        <target state="translated">MSBuild は有効な "{0}" オブジェクトを必要としています。</target>
         <note />
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
-        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
-        <target state="new">Making the following modifications to the environment received from the parent node before applying it to the task host:</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="Shared.PathTooLong">
+        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
+        <target state="translated">パス: {0} は OS のパスの上限を越えています。完全修飾のファイル名は {1} 文字以下にする必要があります。</target>
+        <note />
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
-        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
-        <target state="new">  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="UnrecognizedToolsVersion">
+        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
+        <target state="translated">MSB4132: ツール バージョン "{0}" が認識されません。使用可能なツール バージョンは {1} です。</target>
+        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
       </trans-unit>
       <trans-unit id="NameInvalid">
         <source>MSB5016: The name "{0}" contains an invalid character "{1}".</source>
-        <target state="new">MSB5016: The name "{0}" contains an invalid character "{1}".</target>
+        <target state="translated">MSB5016: 名前 "{0}" は無効な文字 "{1}" を含んでいます。</target>
         <note>{StrBegin="MSB5016: "}</note>
       </trans-unit>
-      <trans-unit id="OM_NotSupportedReadOnlyCollection">
-        <source>This collection is read-only.</source>
-        <target state="new">This collection is read-only.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
-        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
-        <target state="new">MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</target>
-        <note>{StrBegin="MSB5024: "}</note>
-      </trans-unit>
       <trans-unit id="Shared.CannotChangeItemSpecModifiers">
         <source>"{0}" is a reserved item metadata, and cannot be modified or deleted.</source>
-        <target state="new">"{0}" is a reserved item metadata, and cannot be modified or deleted.</target>
+        <target state="translated">"{0}" は予約された項目メタデータです。変更または削除することはできません。</target>
         <note>UE: Tasks and OM users are not allowed to remove or change the value of the built-in metadata on items e.g. the meta-data "FullPath", "RelativeDir", etc. are reserved.</note>
       </trans-unit>
       <trans-unit id="Shared.CannotConvertStringToBool">
         <source>The string "{0}" cannot be converted to a boolean (true/false) value.</source>
-        <target state="new">The string "{0}" cannot be converted to a boolean (true/false) value.</target>
+        <target state="translated">文字列 "{0}" をブール値 (true/false) に変換することはできません。</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.FailedCreatingTempFile">
         <source>MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</source>
-        <target state="new">MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</target>
+        <target state="translated">MSB5003: 一時ファイルを作成できませんでした。一時ファイル フォルダーがいっぱいであるか、またはそのパスが正しくありません。{0}</target>
         <note>{StrBegin="MSB5003: "}</note>
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1}</source>
-        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1}</target>
+        <target state="translated">MSB5018: 一時ファイル "{0}" を削除できませんでした。{1}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
         <source>The item metadata "%({0})" cannot be applied to the path "{1}". {2}</source>
-        <target state="new">The item metadata "%({0})" cannot be applied to the path "{1}". {2}</target>
+        <target state="translated">項目メタデータ "%({0})" をパス "{1}" に適用できません。{2}</target>
         <note>UE: This message is shown when the user tries to perform path manipulations using one of the built-in item metadata e.g. %(RootDir), on an item-spec that's not a valid path. LOCALIZATION: "{2}" is a localized message from a CLR/FX exception.</note>
       </trans-unit>
-      <trans-unit id="Shared.InvalidProjectFile">
-        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
-        <target state="new">MSB5019: The project file is malformed: "{0}". {1}</target>
-        <note>{StrBegin="MSB5019: "}</note>
+      <trans-unit id="TaskNotMarshalByRef">
+        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
+        <target state="translated">MSB4077: "{0}" タスクに属性 LoadInSeparateAppDomain が設定されていますが、MarshalByRefObject から派生していません。そのタスクが MarshalByRefObject または AppDomainIsolatedTask から派生していることを確認してください。</target>
+        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
+        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
+        <target state="translated">.NET Framework のバージョン "{0}" はサポートされていません。列挙 Microsoft.Build.Utilities.TargetDotNetFrameworkVersion から値を指定してください。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
+        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
+        <target state="translated">Windows SDK を明示的にターゲットとする場合、.NET Framework のバージョン "{0}" はサポートされません。Windows SDK は、.NET 4.5 以降でのみサポートされています。列挙 Microsoft.Build.Utilities.TargetDotNetFrameworkVersion から Version45 以上の値を指定してください。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
+        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
+        <target state="translated">Visual Studio のバージョン "{0}" はサポートされていません。列挙 Microsoft.Build.Utilities.VisualStudioVersion から値を指定してください。</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
+        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
+        <target state="translated">参照アセンブリ パスをパス "{0}" とフレームワーク モニカー "{1}" から生成しようとしたときに、エラーが発生しました。{2}</target>
+        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
+      </trans-unit>
+      <trans-unit id="DirectoryNotFound">
+        <source>Could not find directory path: {0}</source>
+        <target state="translated">ディレクトリ パスが見つかりませんでした: {0}</target>
+        <note>Directory must exist</note>
+      </trans-unit>
+      <trans-unit id="UnauthorizedAccess">
+        <source>You do not have access to: {0}</source>
+        <target state="translated">{0} へのアクセス権がありません</target>
+        <note>Directory must have access</note>
+      </trans-unit>
+      <trans-unit id="SubCategoryForSchemaValidationErrors">
+        <source>Schema validation</source>
+        <target state="translated">スキーマの検証</target>
+        <note>
+      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
+      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
+      "MSBUILD : Schema validation error MSB0000: This is an error."
+      LOCALIZATION: This fragment needs to be localized.
+    </note>
       </trans-unit>
       <trans-unit id="Shared.KillingProcess">
         <source>MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</source>
-        <target state="new">MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</target>
+        <target state="translated">MSB5002: 実行可能なタスク "{0}" は、指定された制限 ({1} ミリ秒) 内で完了しなかったため、終了しています。</target>
         <note>{StrBegin="MSB5002: "}</note>
       </trans-unit>
-      <trans-unit id="Shared.KillingProcessByCancellation">
-        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
-        <target state="new">MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</target>
-        <note>{StrBegin="MSB5021: "}</note>
-      </trans-unit>
       <trans-unit id="Shared.ParameterCannotBeNull">
         <source>Parameter "{0}" cannot be null.</source>
-        <target state="new">Parameter "{0}" cannot be null.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
-        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
-        <target state="new">Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</target>
+        <target state="translated">パラメーター "{0}" を null にすることはできません。</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParameterCannotHaveZeroLength">
         <source>Parameter "{0}" cannot have zero length.</source>
-        <target state="new">Parameter "{0}" cannot have zero length.</target>
+        <target state="translated">パラメーター "{0}" の長さを 0 にすることはできません。</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParametersMustHaveTheSameLength">
         <source>Parameters "{0}" and "{1}" must have the same number of elements.</source>
-        <target state="new">Parameters "{0}" and "{1}" must have the same number of elements.</target>
+        <target state="translated">パラメーター "{0}" と "{1}" の要素数は同じである必要があります。</target>
         <note />
       </trans-unit>
-      <trans-unit id="Shared.PathTooLong">
-        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
-        <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
-        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
-        <target state="new">MSB5020: Could not load the project file: "{0}". {1}</target>
-        <note>{StrBegin="MSB5020: "}</note>
-      </trans-unit>
       <trans-unit id="Shared.TaskResourceNotFound">
         <source>The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</source>
-        <target state="new">The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</target>
+        <target state="translated">"{1}" タスクのリソース文字列 "{0}" が見つかりません。リソース名 "{0}" のスペルが正しいこと、およびリソースがタスクのアセンブリ内に存在することを確認してください。</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.TaskResourcesNotRegistered">
         <source>The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</source>
-        <target state="new">The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</target>
+        <target state="translated">"{0}" タスクのリソースが登録されていません。"TaskLoggingHelper.FormatResourceString()" メソッドを使用するためには、構築時に、または "TaskResources" プロパティを通じて、このタスクのリソースを登録する必要があります。</target>
         <note>LOCALIZATION: "TaskLoggingHelper.FormatResourceString()" and "TaskResources" should not be localized.</note>
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="SolutionParseDuplicateProject">
         <source>MSB5004: The solution file has two projects named "{0}".</source>
-        <target state="new">MSB5004: The solution file has two projects named "{0}".</target>
+        <target state="translated">MSB5004: ソリューション ファイルには "{0}" という名前のプロジェクトが 2 つあります。</target>
         <note>{StrBegin="MSB5004: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameCharacters">
         <source>MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</source>
-        <target state="new">MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</target>
+        <target state="translated">MSB5005: プロジェクト "{0}" のプロジェクト セクションを解析中にエラーが発生しました。プロジェクトのファイル名 "{1}" に無効な文字が使用されています。</target>
         <note>{StrBegin="MSB5005: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameEmpty">
         <source>MSB5006: Error parsing project section for project "{0}". The project file name is empty.</source>
-        <target state="new">MSB5006: Error parsing project section for project "{0}". The project file name is empty.</target>
+        <target state="translated">MSB5006: プロジェクト "{0}" のプロジェクト セクションを解析中にエラーが発生しました。プロジェクトのファイル名が空です。</target>
         <note>{StrBegin="MSB5006: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectSolutionConfigurationEntry">
         <source>MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="new">MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</target>
+        <target state="translated">MSB5007: ソリューション ファイル内のプロジェクト構成セクションを解析中にエラーが発生しました。エントリ "{0}" は無効です。</target>
         <note>{StrBegin="MSB5007: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidSolutionConfigurationEntry">
         <source>MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="new">MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</target>
+        <target state="translated">MSB5008: ソリューション ファイル内のソリューション構成セクションを解析中にエラーが発生しました。エントリ "{0}" は無効です。</target>
         <note>{StrBegin="MSB5008: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
+        <target state="translated">MSB5009: ソリューション ファイル内の入れ子にされたプロジェクト セクションを解析中にエラーが発生しました。</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
         <source>MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</source>
-        <target state="new">MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</target>
+        <target state="translated">MSB5023: ソリューション ファイルの入れ子になったプロジェクト セクションを解析中にエラーが発生しました。GUID "{0}" のプロジェクトは、プロジェクト "{1}" 下に入れ子として表示されていますが、ソリューション内に存在しません。</target>
         <note>{StrBegin="MSB5023: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNoHeaderError">
         <source>MSB5010: No file format header found.</source>
-        <target state="new">MSB5010: No file format header found.</target>
+        <target state="translated">MSB5010: ファイル形式のヘッダーが見つかりませんでした。</target>
         <note>{StrBegin="MSB5010: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectDepGuidError">
         <source>MSB5011: Parent project GUID not found in "{0}" project dependency section.</source>
-        <target state="new">MSB5011: Parent project GUID not found in "{0}" project dependency section.</target>
+        <target state="translated">MSB5011: 親プロジェクト GUID が "{0}" プロジェクト依存セクションで見つかりませんでした。</target>
         <note>{StrBegin="MSB5011: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectEofError">
         <source>MSB5012: Unexpected end-of-file reached inside "{0}" project section.</source>
-        <target state="new">MSB5012: Unexpected end-of-file reached inside "{0}" project section.</target>
+        <target state="translated">MSB5012: "{0}" プロジェクト セクション内で、予期しない EOF に到達しました。</target>
         <note>{StrBegin="MSB5012: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectError">
         <source>MSB5013: Error parsing a project section.</source>
-        <target state="new">MSB5013: Error parsing a project section.</target>
+        <target state="translated">MSB5013: プロジェクト セクションを解析中にエラーが発生しました。</target>
         <note>{StrBegin="MSB5013: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseVersionMismatchError">
         <source>MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</source>
-        <target state="new">MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</target>
+        <target state="translated">MSB5014: ファイル形式のバージョンを認識できません。MSBuild で読み取ることができるのは、バージョン {0}.0 ～ {1}.0 のソリューション ファイルだけです。</target>
         <note>{StrBegin="MSB5014: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseWebProjectPropertiesError">
         <source>MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</source>
-        <target state="new">MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</target>
+        <target state="translated">MSB5015: "{0}" プロジェクトの WebsiteProperties セクションからプロパティを読み取れませんでした。</target>
         <note>{StrBegin="MSB5015: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
-      <trans-unit id="SubCategoryForSchemaValidationErrors">
-        <source>Schema validation</source>
-        <target state="new">Schema validation</target>
-        <note>
-      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
-      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
-      "MSBUILD : Schema validation error MSB0000: This is an error."
-      LOCALIZATION: This fragment needs to be localized.
-    </note>
+      <trans-unit id="UnrecognizedSolutionComment">
+        <source>Unrecognized solution version "{0}", attempting to continue.</source>
+        <target state="translated">"{0}" は認識できないソリューション バージョンです。続行を試みます。</target>
+        <note />
       </trans-unit>
       <trans-unit id="SubCategoryForSolutionParsingErrors">
         <source>Solution file</source>
-        <target state="new">Solution file</target>
+        <target state="translated">ソリューション ファイル</target>
         <note>UE: this fragment is used to describe errors found while parsing solution files. For example, if a normal error is
       displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from solution parsing would look like this:
       "MSBUILD : Solution file error MSB0000: This is an error."
       LOCALIZATION: This fragment needs to be localized.</note>
       </trans-unit>
-      <trans-unit id="TaskNotMarshalByRef">
-        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="new">MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</target>
-        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
+      <trans-unit id="Shared.InvalidProjectFile">
+        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
+        <target state="translated">MSB5019: プロジェクト ファイルの形式が正しくありません: "{0}"。{1}</target>
+        <note>{StrBegin="MSB5019: "}</note>
       </trans-unit>
-      <trans-unit id="UnauthorizedAccess">
-        <source>You do not have access to: {0}</source>
-        <target state="new">You do not have access to: {0}</target>
-        <note>Directory must have access</note>
+      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
+        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
+        <target state="translated">MSB5020: プロジェクト ファイル "{0}" を読み込めませんでした。{1}</target>
+        <note>{StrBegin="MSB5020: "}</note>
       </trans-unit>
-      <trans-unit id="UnrecognizedSolutionComment">
-        <source>Unrecognized solution version "{0}", attempting to continue.</source>
-        <target state="new">Unrecognized solution version "{0}", attempting to continue.</target>
+      <trans-unit id="Shared.KillingProcessByCancellation">
+        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
+        <target state="translated">MSB5021: ビルドが取り消されたため、実行可能なタスク "{0}" とその子プロセスを終了しています。</target>
+        <note>{StrBegin="MSB5021: "}</note>
+      </trans-unit>
+      <trans-unit id="OM_NotSupportedReadOnlyCollection">
+        <source>This collection is read-only.</source>
+        <target state="translated">このコレクションは読み取り専用です。</target>
         <note />
       </trans-unit>
-      <trans-unit id="UnrecognizedToolsVersion">
-        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
-        <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
-        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
+      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
+        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
+        <target state="translated">MSB5024: MSBuild への有効な場所が決定できませんでした。Visual Studio の開発者コマンド プロンプトからこのプロセスを実行してください。</target>
+        <note>{StrBegin="MSB5024: "}</note>
+      </trans-unit>
+      <trans-unit id="InvalidLogFileFormat">
+        <source>MSB4233: There was an exception while reading the log file: {0}</source>
+        <target state="translated">MSB4233: ログ ファイルの読み取り中に例外が発生しました: {0}</target>
+        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
+      </trans-unit>
+      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
+        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
+        <target state="translated">値 "{1}" が割り当てられたパラメーター "{0}" には、無効なパスまたは無効なファイル内の文字を指定することはできません。</target>
+        <note />
       </trans-unit>
     </body>
   </file>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 0a9784913d7..3ec69e93682 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -65,21 +65,6 @@
         <target state="translated">경로: {0}은(는) OS 최대 경로 제한을 초과합니다. 정규화된 파일 이름은 {1}자 이하여야 합니다.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: 도구 버전 "{0}"을(를) 인식할 수 없습니다. 사용할 수 있는 도구 버전은 {1}입니다.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 6d6f964b8a2..2d38506af57 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -65,21 +65,6 @@
         <target state="translated">Ścieżka: {0} przekracza limit maksymalnej długości ścieżki w systemie operacyjnym. W pełni kwalifikowana nazwa pliku musi się składać z mniej niż {1} znaków.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Wersja narzędzi „{0}” nie została rozpoznana. Dostępne wersje narzędzi to {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index f2b419f77df..4aa21acdb48 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -65,21 +65,6 @@
         <target state="translated">Caminho: {0} excede o limite máximo do caminho do SO. O nome do arquivo totalmente qualificado deve ter menos de {1} caracteres.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: A versão das ferramentas "{0}" não é reconhecida. As versões das ferramentas disponíveis são {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 111a49830f4..d37b4d76c6c 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -65,21 +65,6 @@
         <target state="translated">Длина пути {0} превышает максимально допустимую в ОС. Символов в полном имени файла должно быть не больше {1}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: версия инструментов "{0}" не распознана. Доступные версии инструментов: {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index b0b741a3960..24caa67ffa5 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -65,21 +65,6 @@
         <target state="translated">Yol: {0}, işletim sisteminin en yüksek yol sınırını aşıyor. Tam dosya adı en fazla {1} karakter olmalıdır.</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Araçlar sürümü "{0}" tanınmıyor. Kullanılabilir araç sürümleri şunlardır: {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 398938a8677..78941fb4a60 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -65,21 +65,6 @@
         <target state="translated">路径: {0} 超过 OS 最大路径限制。完全限定的文件名必须少于 {1} 个字符。</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: 无法识别工具版本“{0}”。可用的工具版本为 {1}。</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 418a2c2a06b..8053d2d6e4b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -65,21 +65,6 @@
         <target state="translated">路徑: {0} 超過 OS 路徑上限。完整檔案名稱必須少於 {1} 個字元。</target>
         <note />
       </trans-unit>
-      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
-        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
-        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
-        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterJsonParsingError">
-        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
-        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
-        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
-      <trans-unit id="SolutionFilterMissingSolutionError">
-        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
-        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
-        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
-      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: 工具版本 "{0}" 無法辨認。可用的工具版本為 {1}。</target>
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 0ab43e56198..9a38caea385 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -79,6 +79,11 @@ public Traits()
         /// </summary>
         public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection"));
 
+        /// <summary>
+        /// Log property tracking information.
+        /// </summary>
+        public readonly int LogPropertyTracking = ParseIntFromEnvironmentVariableOrDefault("MsBuildLogPropertyTracking", 0); // Default to logging nothing via the property tracker.
+
         private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVariable, int defaultValue)
         {
             return int.TryParse(Environment.GetEnvironmentVariable(environmentVariable), out int result)
@@ -89,6 +94,17 @@ private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVa
 
     internal class EscapeHatches
     {
+        /// <summary>
+        /// Do not log command line information to build loggers. Useful to unbreak people who parse the msbuild log and who are unwilling to change their code.
+        /// </summary>
+        public readonly bool DoNotSendDeferredMessagesToBuildManager = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildDoNotSendDeferredMessagesToBuildManager"));
+
+        /// <summary>
+        /// https://github.com/microsoft/msbuild/pull/4975 started expanding qualified metadata in Update operations. Before they'd expand to empty strings.
+        /// This escape hatch turns back the old empty string behavior.
+        /// </summary>
+        public readonly bool DoNotExpandQualifiedMetadataInUpdateOperation = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildDoNotExpandQualifiedMetadataInUpdateOperation"));
+
         /// <summary>
         /// Force whether Project based evaluations should evaluate elements with false conditions.
         /// </summary>
@@ -196,6 +212,11 @@ public bool LogTaskInputs
         /// </summary>
         public readonly bool DisableNuGetSdkResolver = Environment.GetEnvironmentVariable("MSBUILDDISABLENUGETSDKRESOLVER") == "1";
 
+        /// <summary>
+        /// Don't delete TargetPath metadata from associated files found by RAR.
+        /// </summary>
+        public readonly bool TargetPathForRelatedFiles = Environment.GetEnvironmentVariable("MSBUILDTARGETPATHFORRELATEDFILES") == "1";
+
         /// <summary>
         /// Disable AssemblyLoadContext isolation for plugins.
         /// </summary>
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 7bdbb14bdc3..42d56c62448 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -420,11 +420,14 @@ internal static void AssertItemHasMetadata(Dictionary<string, string> expected,
 
         internal static void AssertItemHasMetadata(Dictionary<string, string> expected, TestItem item)
         {
-            Assert.Equal(expected.Keys.Count, item.DirectMetadataCount);
+            expected ??= new Dictionary<string, string>();
+
+            item.DirectMetadataCount.ShouldBe(expected.Keys.Count);
 
             foreach (var key in expected.Keys)
             {
-                Assert.Equal(expected[key], item.GetMetadataValue(key));
+                item.GetMetadataValue(key).ShouldBe(expected[key]);
+
             }
         }
 
diff --git a/src/Shared/UnitTests/xunit.runner.json b/src/Shared/UnitTests/xunit.runner.json
index 5638079c9ab..2677ff464a7 100644
--- a/src/Shared/UnitTests/xunit.runner.json
+++ b/src/Shared/UnitTests/xunit.runner.json
@@ -1,6 +1,8 @@
 ﻿{
+    "$schema": "https://xunit.net/schema/current/xunit.runner.schema.json",
     "shadowCopy": false,
     "appDomain": "required",
+    "longRunningTestSeconds": 60,
     "maxParallelThreads": 1,
     "parallelizeTestCollections": false,
     "diagnosticMessages":  true
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 72e2751ba71..52973541190 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -3,15 +3,13 @@
 
 using System;
 using System.IO;
-using System.Reflection;
-using System.Collections;
+using System.Linq;
+
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
-using System.Text.RegularExpressions;
 
-using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -1408,5 +1406,92 @@ public void NonexistentTargetFailsAfterSkipped()
             // 2nd invocation of t_missing should fail the build resulting in target not found error (MSB4057)
             logger.FullLog.ShouldContain("MSB4057");
         }
+
+        [Fact]
+        public void MSBuildTaskPassesTaskIdToSpawnedBuilds()
+        {
+            string projectFile1 = ObjectModelHelpers.CreateTempFileOnDisk(@"
+                <Project>
+                    <Target Name=`Build`>
+                        <Message Text=`test`/>
+                    </Target>
+                </Project>");
+
+            string projectFile2 = ObjectModelHelpers.CreateTempFileOnDisk(@"
+                <Project>
+                    <Target Name=`Build`>
+                        <MSBuild Projects=`" + projectFile1 + @"` Targets=`Build` />
+                    </Target>	
+                </Project>");
+
+            try
+            {
+                Project project = new Project(projectFile2);
+                var logger = new MockLogger();
+
+                Assert.True(project.Build(logger));
+
+                var expectedTaskId = logger.TaskStartedEvents.First(t => t.TaskName == "MSBuild").BuildEventContext.TaskId;
+                var actualTaskId = logger.ProjectStartedEvents
+                    .Where(p => p.ParentProjectBuildEventContext != null && p.ParentProjectBuildEventContext.TaskId > 0)
+                    .First()
+                    .ParentProjectBuildEventContext.TaskId;
+
+                Assert.Equal(expectedTaskId, actualTaskId);
+            }
+            finally
+            {
+                File.Delete(projectFile1);
+                File.Delete(projectFile2);
+            }
+        }
+
+        [Fact]
+        public void CustomTaskWithBuildProjectFilePassesTaskId()
+        {
+            string projectFile1 = ObjectModelHelpers.CreateTempFileOnDisk($@"
+                <Project>
+                    <UsingTask TaskName=`{nameof(BuildProjectFileTask)}` AssemblyFile =`{typeof(BuildProjectFileTask).Assembly.Location}` />
+                    <Target Name=`Build`>
+                        <{nameof(BuildProjectFileTask)} Project=`$(MSBuildThisFileFullPath)` Targets=`Other` />
+                    </Target>
+                    <Target Name=`Other`>
+                        <Message Text=`test`/>
+                    </Target>
+                </Project>");
+
+            try
+            {
+                Project project = new Project(projectFile1);
+                var logger = new MockLogger();
+
+                Assert.True(project.Build(logger));
+
+                var expectedTaskId = logger.TaskStartedEvents.First(t => t.TaskName == nameof(BuildProjectFileTask)).BuildEventContext.TaskId;
+                var actualTaskId = logger.ProjectStartedEvents
+                    .Where(p => p.ParentProjectBuildEventContext != null && p.ParentProjectBuildEventContext.TaskId > 0)
+                    .First()
+                    .ParentProjectBuildEventContext.TaskId;
+
+                Assert.Equal(expectedTaskId, actualTaskId);
+            }
+            finally
+            {
+                File.Delete(projectFile1);
+            }
+        }
+    }
+
+    public class BuildProjectFileTask : Task
+    {
+        public string Project { get; set; }
+        public string[] Targets { get; set; }
+
+        public override bool Execute()
+        {
+            this.BuildEngine.BuildProjectFile(Project, Targets, null, null);
+
+            return true;
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/NuGetPropsImportTests.cs b/src/Tasks.UnitTests/NuGetPropsImportTests.cs
new file mode 100644
index 00000000000..d1ed2d2f7f6
--- /dev/null
+++ b/src/Tasks.UnitTests/NuGetPropsImportTests.cs
@@ -0,0 +1,83 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Evaluation;
+using System;
+using System.IO;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests
+{
+    /// <summary>
+    /// Test the NuGet.props import functionality in Microsoft.Common.props.
+    /// </summary>
+    public sealed class NuGetPropsImportTests : IDisposable
+    {
+        private const string NuGetPropsContent = @"
+                <Project xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                    <PropertyGroup>
+                        <NuGetPropsIsImported>true</NuGetPropsIsImported>
+                    </PropertyGroup>
+                </Project>";
+
+        private const string NuGetPropsProjectFile = "NuGet.props";
+        private const string NuGetPropsPropertyName = "NuGetPropsFile";
+
+        public void Dispose()
+        {
+            ObjectModelHelpers.DeleteTempProjectDirectory();
+        }
+
+        /// <summary>
+        /// Ensures that if a NuGet.props exists, it will be imported.
+        /// </summary>
+        [Fact]
+        public void ImportNuGetPropsWhenExists()
+        {
+            var projectRelativePath = Path.Combine("src", "foo1", "foo1.csproj");
+            var nugetPropsRelativePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(NuGetPropsProjectFile, NuGetPropsContent);
+
+            // ---------------------
+            // src\Foo\Foo.csproj
+            // ---------------------
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(projectRelativePath, $@"
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                    <PropertyGroup>
+                        <{NuGetPropsPropertyName}>{nugetPropsRelativePath}</{NuGetPropsPropertyName}>
+                    </PropertyGroup>
+                    <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
+                </Project>
+            ");
+
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectRelativePath);
+
+            Assert.Equal("true", project.GetPropertyValue("NuGetPropsIsImported"), StringComparer.OrdinalIgnoreCase);
+        }
+
+        /// <summary>
+        /// Ensures that if the NuGet.props does not exists no exception will be produced.
+        /// </summary>
+        [Fact]
+        public void ImportNuGetPropsWhenDoesNotExists()
+        {
+            var projectRelativePath = Path.Combine("src", "foo1", "foo1.csproj");
+            var nugetPropsRelativePath = Path.Combine(Path.GetDirectoryName(projectRelativePath), NuGetPropsProjectFile);
+
+            // ---------------------
+            // src\Foo\Foo.csproj
+            // ---------------------
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(projectRelativePath, $@"
+                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                    <PropertyGroup>
+                        <{NuGetPropsPropertyName}>{nugetPropsRelativePath}</{NuGetPropsPropertyName}>
+                    </PropertyGroup>
+                    <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
+                </Project>
+            ");
+
+            Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectRelativePath);
+
+            Assert.Empty(project.GetPropertyValue("NuGetPropsIsImported"));
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 16726115c2c..344c40c092d 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -2918,6 +2918,10 @@ private static void RemoveNonForwardableMetadata(ITaskItem item)
             item.RemoveMetadata(ItemMetadataNames.winmdImplmentationFile);
             item.RemoveMetadata(ItemMetadataNames.imageRuntime);
             item.RemoveMetadata(ItemMetadataNames.winMDFile);
+            if (!Traits.Instance.EscapeHatches.TargetPathForRelatedFiles)
+            {
+                item.RemoveMetadata(ItemMetadataNames.targetPath);
+            }
         }
 
         /// <summary>
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 410f1991f93..6e2421f9294 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -709,6 +709,12 @@
     <Content Include="Microsoft.Managed.targets">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
+    <Content Include="Microsoft.Managed.Before.targets">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
+    <Content Include="Microsoft.Managed.After.targets">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </Content>
     <Content Include="Microsoft.CSharp.CurrentVersion.targets">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
@@ -842,6 +848,8 @@
       <SubType>Designer</SubType>
     </DataFile>
     <DataFile Include="Microsoft.Managed.targets" />
+    <DataFile Include="Microsoft.Managed.Before.targets" />
+    <DataFile Include="Microsoft.Managed.After.targets" />
     <DataFile Include="Microsoft.CSharp.targets" />
     <DataFile Include="Microsoft.CSharp.CurrentVersion.targets" />
     <DataFile Include="Microsoft.CSharp.CrossTargeting.targets" />
diff --git a/src/Tasks/Microsoft.CSharp.targets b/src/Tasks/Microsoft.CSharp.targets
index b9e606e208b..beda9624db2 100644
--- a/src/Tasks/Microsoft.CSharp.targets
+++ b/src/Tasks/Microsoft.CSharp.targets
@@ -156,11 +156,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
    </ImportGroup> 
 
-   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.targets" />
+   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
 
    <Import Project="$(CSharpTargetsPath)" />
 
-   <!-- Really should be imported right after Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports 
+   <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets" />
+
+   <!-- Really should be imported right after Microsoft.NETFramework.props, but because Microsoft.CSharp.targets imports
         Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
         targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
         way instead. --> 
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index 041c365c8c1..0c5e0242a92 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -136,7 +136,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     This will import NuGet restore targets. We need restore to work before any package assets are available.
   -->
   <PropertyGroup>
-    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$([MSBuild]::IsRunningFromVisualStudio())'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
+    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
+    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
     <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'==''">$(MSBuildToolsPath)\NuGet.targets</NuGetRestoreTargets>
   </PropertyGroup>
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 65be71ad95d..748ced91249 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -6170,7 +6170,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <!-- Import NuGet.targets (required for GetReferenceNearestTargetFrameworkTask and used for Restore functionality) -->
   <PropertyGroup>
-    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$([MSBuild]::IsRunningFromVisualStudio())'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
+    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
+    <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.targets</NuGetRestoreTargets>
     <NuGetRestoreTargets Condition="'$(NuGetRestoreTargets)'==''">$(MSBuildToolsPath)\NuGet.targets</NuGetRestoreTargets>
   </PropertyGroup>
 
diff --git a/src/Tasks/Microsoft.Common.props b/src/Tasks/Microsoft.Common.props
index 1a923c0f9ec..e78168f28b0 100644
--- a/src/Tasks/Microsoft.Common.props
+++ b/src/Tasks/Microsoft.Common.props
@@ -164,4 +164,14 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')"/>
     <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonProps)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Imports\Microsoft.Common.props\ImportAfter')"/>
   </ImportGroup>
+
+  <!-- 
+        Import NuGet.props file.
+    -->
+  <PropertyGroup>
+    <MSBuildUseVisualStudioDirectoryLayout Condition="'$(MSBuildUseVisualStudioDirectoryLayout)'==''">$([MSBuild]::IsRunningFromVisualStudio())</MSBuildUseVisualStudioDirectoryLayout>
+    <NuGetPropsFile Condition="'$(NuGetPropsFile)'=='' and '$(MSBuildUseVisualStudioDirectoryLayout)'=='true'">$(MSBuildToolsPath32)\..\..\..\Common7\IDE\CommonExtensions\Microsoft\NuGet\NuGet.props</NuGetPropsFile>
+    <NuGetPropsFile Condition="'$(NuGetPropsFile)'==''">$(MSBuildToolsPath)\NuGet.props</NuGetPropsFile>
+  </PropertyGroup>
+  <Import Condition="Exists('$(NuGetPropsFile)')" Project="$(NuGetPropsFile)" />
 </Project>
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
new file mode 100644
index 00000000000..c372dcbd388
--- /dev/null
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -0,0 +1,78 @@
+﻿<!--
+***********************************************************************************************
+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
+          created a backup copy.  Incorrect changes to this file will make it
+          impossible to load or build your projects from the command-line or the IDE.
+
+This file defines common build logic for all managed languaged: C#, VisualBasic, F#
+It is imported after the common targets have been imported.
+
+Copyright (C) Microsoft Corporation. All rights reserved.
+***********************************************************************************************
+-->
+
+<Project>
+
+   <!-- Define crosstargeting for static graph, so it can identify inner and outer build graph nodes -->
+   <PropertyGroup>
+      <InnerBuildProperty>TargetFramework</InnerBuildProperty>
+      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
+   </PropertyGroup>
+
+   <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
+      <!-- Microsoft.Net.Sdk adds all transitive project references to ProjectReference. It does this at build time
+           via a target. This fails the undeclared msbuild reference /isolate constraint, so disable transitive
+           references.
+           Do not disable transitive references if BuildProjectReferences is false. If building references is false,
+           then MSBuild won't try to build the transitive references, which won't trigger undeclared reference constraints.
+          -->
+      <DisableTransitiveProjectReferences Condition="'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''">true</DisableTransitiveProjectReferences>
+   </PropertyGroup>
+
+   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
+      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.
+           Detect WPF, and exclude the generated project from static graph isolation constraint checking.
+           Escape the item to avoid eager evaluation of the wildcards.
+      -->
+      <GraphIsolationExemptReference
+         Condition="'$(UseWPF)' == 'true' or '@(Page)' != '' or '@(ApplicationDefinition)' != '' or '@(XamlPage)' != '' or '@(XamlAppDef)' != ''"
+         Include="$([MSBuild]::Escape('$(MSBuildProjectDirectory)\$(MSBuildProjectName)*_wpftmp$(MSBuildProjectExtension)'))" />
+   </ItemGroup>
+
+  <!--
+    Properties for extension of ProjectReferenceTargets.
+    Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
+  -->
+  <PropertyGroup>
+    <!-- Empty case is for outer builds which do not import the target files that set BuildProjectReferences -->
+    <_MainReferenceTarget Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTarget>
+    <_MainReferenceTarget Condition="'$(_MainReferenceTarget)' == ''">GetTargetPath</_MainReferenceTarget>
+
+    <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
+    <ProjectReferenceTargetsForBuild>$(_MainReferenceTarget);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+
+    <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
+    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
+
+    <ProjectReferenceTargetsForRebuildInOuterBuild>$(ProjectReferenceTargetsForCleanInOuterBuild);$(ProjectReferenceTargetsForBuildInOuterBuild);$(ProjectReferenceTargetsForRebuildInOuterBuild)</ProjectReferenceTargetsForRebuildInOuterBuild>
+    <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
+
+    <ProjectReferenceTargetsForPublish>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForPublish>
+    <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true"/>
+    <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
+
+    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true"/>
+    <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
+
+    <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForRebuildInOuterBuild)' != '' " />
+    <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
+
+    <ProjectReferenceTargets Include="Publish" Targets="$(ProjectReferenceTargetsForPublish)" Condition=" '$(ProjectReferenceTargetsForPublish)' != '' " />
+    <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
+  </ItemGroup>
+
+</Project>
diff --git a/src/Tasks/Microsoft.Managed.Before.targets b/src/Tasks/Microsoft.Managed.Before.targets
new file mode 100644
index 00000000000..e7154e0a2f9
--- /dev/null
+++ b/src/Tasks/Microsoft.Managed.Before.targets
@@ -0,0 +1,24 @@
+﻿<!--
+***********************************************************************************************
+WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
+          created a backup copy.  Incorrect changes to this file will make it
+          impossible to load or build your projects from the command-line or the IDE.
+
+This file defines common build logic for all managed languaged: C#, VisualBasic, F#
+It is imported before the common targets have been imported.
+
+Copyright (C) Microsoft Corporation. All rights reserved.
+***********************************************************************************************
+-->
+
+<Project>
+   <!--
+        We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
+        and there is no current target framework being built individually. In that case, a multitargeting
+        project file like Microsoft.<language>.CrossTargeting.targets gets imported.
+   -->
+   <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">
+      <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
+   </PropertyGroup>
+
+</Project>
diff --git a/src/Tasks/Microsoft.Managed.targets b/src/Tasks/Microsoft.Managed.targets
index 7bfefbe39ff..25d1e7528c2 100644
--- a/src/Tasks/Microsoft.Managed.targets
+++ b/src/Tasks/Microsoft.Managed.targets
@@ -1,49 +1,14 @@
 ﻿<!--
 ***********************************************************************************************
-WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
-          created a backup copy.  Incorrect changes to this file will make it
-          impossible to load or build your projects from the command-line or the IDE.
-
-This file defines common build logic for all managed languaged: C#, VisualBasic, F#
+This file is deprecated and left here for back compat reasons. It is replaced by Microsoft.Managed.<Before|After>.targets
 
 Copyright (C) Microsoft Corporation. All rights reserved.
 ***********************************************************************************************
 -->
 
 <Project>
-   <!--
-        We are doing a cross-targeting build if there is a non-empty list of target frameworks specified
-        and there is no current target framework being built individually. In that case, a multitargeting
-        project file like Microsoft.<language>.CrossTargeting.targets gets imported.
-   -->
-   <PropertyGroup Condition="'$(TargetFrameworks)' != '' and '$(TargetFramework)' == ''">
-      <IsCrossTargetingBuild>true</IsCrossTargetingBuild>
-   </PropertyGroup>
-
-   <PropertyGroup>
-      <InnerBuildProperty>TargetFramework</InnerBuildProperty>
-      <InnerBuildPropertyValues>TargetFrameworks</InnerBuildPropertyValues>
-   </PropertyGroup>
 
-   <PropertyGroup Condition="'$(IsGraphBuild)' == 'true'">
-      <!-- Microsoft.Net.Sdk adds all transitive project references to ProjectReference. It does this at build time
-           via a target. This fails the undeclared msbuild reference /isolate constraint, so disable transitive
-           references.
-           Do not disable transitive references if BuildProjectReferences is false. If building references is false,
-           then MSBuild won't try to build the transitive references, which won't trigger undeclared reference constraints.
-          -->
-      <DisableTransitiveProjectReferences Condition="'$(BuildProjectReferences)' != 'false' and '$(DisableTransitiveProjectReferences)' == ''">true</DisableTransitiveProjectReferences>
-   </PropertyGroup>
-
-   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
-      <!-- WPF projects generate a project with a random name at build time and then build the project via the IBuildEngine callbacks.
-           Detect WPF, and exclude the generated project from static graph isolation constraint checking.
-           Escape the item to avoid eager evaluation of the wildcards.
-      -->
-      <GraphIsolationExemptReference
-         Condition="'$(UseWPF)' == 'true' or '@(Page)' != '' or '@(ApplicationDefinition)' != '' or '@(XamlPage)' != '' or '@(XamlAppDef)' != ''"
-         Include="$([MSBuild]::Escape('$(MSBuildProjectDirectory)\$(MSBuildProjectName)*_wpftmp$(MSBuildProjectExtension)'))" />
-   </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
 
    <!-- Item copied from Microsoft.Common.Currentversion.targets   -->
   <PropertyGroup>
@@ -51,37 +16,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_RecursiveTargetForContentCopying Condition=" '$(MSBuildCopyContentTransitively)' == 'false' ">_GetCopyToOutputDirectoryItemsFromThisProject</_RecursiveTargetForContentCopying>
   </PropertyGroup>
 
-  <!--
-    Properties for extension of ProjectReferenceTargets.
-    Append any current value which may have been provided in a Directory.Build.props since the intent was likely to append, not prepend.
-  -->
-  <PropertyGroup>
-    <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
-    <ProjectReferenceTargetsForBuild>.projectReferenceTargetsOrDefaultTargets;GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
-
-    <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
-    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
-
-    <ProjectReferenceTargetsForRebuildInOuterBuild>$(ProjectReferenceTargetsForCleanInOuterBuild);$(ProjectReferenceTargetsForBuildInOuterBuild);$(ProjectReferenceTargetsForRebuildInOuterBuild)</ProjectReferenceTargetsForRebuildInOuterBuild>
-    <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
-
-    <ProjectReferenceTargetsForPublish>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForPublish)</ProjectReferenceTargetsForPublish>
-    <ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>GetCopyToPublishDirectoryItems;$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)</ProjectReferenceTargetsForGetCopyToPublishDirectoryItems>
-  </PropertyGroup>
-
-  <ItemGroup>
-      <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true"/>
-      <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
-
-      <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true"/>
-      <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
-
-      <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForRebuildInOuterBuild)' != '' " />
-      <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
-
-      <ProjectReferenceTargets Include="Publish" Targets="$(ProjectReferenceTargetsForPublish)" Condition=" '$(ProjectReferenceTargetsForPublish)' != '' " />
-      <ProjectReferenceTargets Include="GetCopyToPublishDirectoryItems" Targets="$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)" Condition=" '$(ProjectReferenceTargetsForGetCopyToPublishDirectoryItems)' != '' " />
-
-  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets" />
 
 </Project>
diff --git a/src/Tasks/Microsoft.VisualBasic.targets b/src/Tasks/Microsoft.VisualBasic.targets
index 215152a8287..3e597e1f304 100644
--- a/src/Tasks/Microsoft.VisualBasic.targets
+++ b/src/Tasks/Microsoft.VisualBasic.targets
@@ -156,11 +156,13 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <Import Project="$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore\*" Condition="'$(ImportByWildcardBefore40MicrosoftNetFrameworkProps)' == 'true' and exists('$(MSBuildExtensionsPath)\4.0\Microsoft.NETFramework.props\ImportBefore')"/>
   </ImportGroup> 
 
-  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.targets" />
+  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.Before.targets" />
 
   <Import Project="$(VisualBasicTargetsPath)" />
-  
-  <!-- Really should be imported right after Microsoft.NETFramework.props, but because Microsoft.VisualBasic.targets imports 
+
+  <Import Project="$(MSBuildToolsPath)\Microsoft.Managed.After.targets" />
+
+  <!-- Really should be imported right after Microsoft.NETFramework.props, but because Microsoft.VisualBasic.targets imports
        Microsoft.Common.targets from the current directory rather than using MSBuildToolsPath (which would redirect to our
        targets), and Microsoft.Common.targets does likewise with Microsoft.NETFramework.props, we're stuck doing it this 
        way instead. --> 
