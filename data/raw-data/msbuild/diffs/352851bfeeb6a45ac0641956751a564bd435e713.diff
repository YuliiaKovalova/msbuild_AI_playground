diff --git a/src/Build/BackEnd/Components/Caching/IConfigCache.cs b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
index 83b13f615fe..599a86d4c1d 100644
--- a/src/Build/BackEnd/Components/Caching/IConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/IConfigCache.cs
@@ -54,7 +54,7 @@ BuildRequestConfiguration this[int configId]
         BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
 
         /// <summary>
-        /// Gets a matching configuration.  If no such configration exists, one is created and optionally loaded.
+        /// Gets a matching configuration. If no such configuration exists, one is created and optionally loaded.
         /// </summary>
         /// <param name="configMetadata">The configuration metadata to match.</param>
         /// <param name="callback">Callback to be invoked if the configuration does not exist.</param>
diff --git a/src/Build/BuildCheck/.editorconfig b/src/Build/BuildCheck/.editorconfig
new file mode 100644
index 00000000000..731ad1c1785
--- /dev/null
+++ b/src/Build/BuildCheck/.editorconfig
@@ -0,0 +1,2 @@
+[*.cs]
+csharp_style_namespace_declarations = file_scoped:warning
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
index 4940db20fd1..ab817077725 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
@@ -1,6 +1,10 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
@@ -42,4 +46,73 @@ public class BuildAnalyzerConfiguration
     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
     /// </summary>
     public bool? IsEnabled { get; internal init; }
+
+    /// <summary>
+    /// Creates a <see cref="BuildAnalyzerConfiguration"/> object based on the provided configuration dictionary.
+    /// If the BuildAnalyzerConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
+    /// If parsing failed the value will be equal to null.
+    /// </summary>
+    /// <param name="configDictionary">The configuration dictionary containing the settings for the build analyzer. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
+    /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
+    internal static BuildAnalyzerConfiguration Create(Dictionary<string, string>? configDictionary)
+    {
+        return new()
+        {
+            EvaluationAnalysisScope = TryExtractValue(nameof(EvaluationAnalysisScope), configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,
+            Severity = TryExtractValue(nameof(Severity), configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,
+            IsEnabled = TryExtractValue(nameof(IsEnabled), configDictionary, out bool isEnabled) ? isEnabled : null,
+        };
+    }
+
+    private static bool TryExtractValue<T>(string key, Dictionary<string, string>? config, out T value) where T : struct, Enum
+    {
+        value = default;
+
+        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
+        {
+            return false;
+        }
+
+        var isParsed = Enum.TryParse(stringValue, true, out value);
+
+        if (!isParsed)
+        {
+            ThrowIncorrectValueException(key, stringValue);
+        }
+
+        return isParsed;
+    }
+
+    private static bool TryExtractValue(string key, Dictionary<string, string>? config, out bool value)
+    {
+        value = default;
+
+        if (config == null || !config.TryGetValue(key.ToLower(), out var stringValue) || stringValue is null)
+        {
+            return false;
+        }
+
+        bool isParsed = false;
+        
+        if (bool.TryParse(stringValue, out bool boolValue))
+        {
+            value = boolValue;
+            isParsed = true;
+        }
+        
+        if (!isParsed)
+        {
+            ThrowIncorrectValueException(key, stringValue);
+        }
+
+        return isParsed;
+    }
+
+    private static void ThrowIncorrectValueException(string key, string value)
+    {
+        // TODO: It will be nice to have the filename where the incorrect configuration was placed. 
+        throw new BuildCheckConfigurationException(
+                $"Incorrect value provided in config for key {key}: '{value}'",
+                buildCheckConfigurationErrorScope: BuildCheckConfigurationErrorScope.EditorConfigParser);
+    }
 }
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
index 81576a42fb5..3ecdd7c6527 100644
--- a/src/Build/BuildCheck/API/ConfigurationContext.cs
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -20,19 +20,9 @@ private ConfigurationContext(CustomConfigurationData[] customConfigurationData)
 
     internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData)
     {
-        if (!customConfigurationData.Any(BuildCheck.CustomConfigurationData.NotNull))
-        {
-            return Null;
-        }
-
-        return new ConfigurationContext(
-            customConfigurationData
-                .Where(BuildCheck.CustomConfigurationData.NotNull)
-                .ToArray());
+        return new ConfigurationContext(customConfigurationData);
     }
 
-    internal static ConfigurationContext Null { get; } = new(Array.Empty<CustomConfigurationData>());
-
     /// <summary>
     /// Custom configuration data - per each rule that has some specified.
     /// </summary>
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index d73b9bb6231..32078038875 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -15,6 +15,13 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// </summary>
 internal sealed class BuildCheckCentralContext
 {
+    private readonly ConfigurationProvider _configurationProvider;
+
+    internal BuildCheckCentralContext(ConfigurationProvider configurationProvider)
+    {
+        _configurationProvider = configurationProvider;
+    }
+
     private record CallbackRegistry(
         List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>)> EvaluatedPropertiesActions,
         List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions,
@@ -126,7 +133,7 @@ private void RunRegisteredActions<T>(
                 else
                 {
                     configPerRule =
-                        ConfigurationProvider.GetMergedConfigurations(projectFullPath,
+                        _configurationProvider.GetMergedConfigurations(projectFullPath,
                             analyzerCallback.Item1.BuildAnalyzer);
                     if (configPerRule.All(c => !c.IsEnabled))
                     {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs
new file mode 100644
index 00000000000..9c4c06511be
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationErrorScope.cs
@@ -0,0 +1,17 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+internal enum BuildCheckConfigurationErrorScope
+{
+    /// <summary>
+    /// Error related to the single rule.
+    /// </summary>
+    SingleRule,
+
+    /// <summary>
+    /// Error related to the parsing of .editorconfig file. 
+    /// </summary>
+    EditorConfigParser
+}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
index ed795891df5..69f3335681d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -15,7 +15,15 @@ internal sealed class BuildCheckConfigurationException : Exception
     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
     /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
     /// </summary>
-    public BuildCheckConfigurationException(string message) : base(message)
+    internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;
+
+    public BuildCheckConfigurationException(string message, Exception innerException, BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message, innerException)
+    {
+        this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
+    }
+
+    public BuildCheckConfigurationException(string message, BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope = BuildCheckConfigurationErrorScope.SingleRule) : base(message)
     {
+        this.buildCheckConfigurationErrorScope = buildCheckConfigurationErrorScope;
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 0e425360d0f..f76b6434356 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -64,7 +64,8 @@ public void InitializeComponent(IBuildComponentHost host)
     internal sealed class BuildCheckManager : IBuildCheckManager
     {
         private readonly TracingReporter _tracingReporter = new TracingReporter();
-        private readonly BuildCheckCentralContext _buildCheckCentralContext = new();
+        private readonly ConfigurationProvider _configurationProvider = new ConfigurationProvider();
+        private readonly BuildCheckCentralContext _buildCheckCentralContext;
         private readonly ILoggingService _loggingService;
         private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
@@ -76,6 +77,7 @@ internal BuildCheckManager(ILoggingService loggingService)
             _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule(loggingService);
             _loggingService = loggingService;
+            _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
         }
 
@@ -213,7 +215,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
             if (analyzerFactoryContext.MaterializedAnalyzer == null)
             {
                 BuildAnalyzerConfiguration[] userConfigs =
-                    ConfigurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
                 if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
                 {
@@ -222,7 +224,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                 }
 
                 CustomConfigurationData[] customConfigData =
-                    ConfigurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData);
 
@@ -246,7 +248,7 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                         $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
                 }
 
-                configurations = ConfigurationProvider.GetMergedConfigurations(userConfigs, analyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, analyzer);
 
                 // technically all analyzers rules could be disabled, but that would mean
                 // that the provided 'IsEnabledByDefault' value wasn't correct - the only
@@ -261,9 +263,9 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
             {
                 wrapper = analyzerFactoryContext.MaterializedAnalyzer;
 
-                configurations = ConfigurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
 
-                ConfigurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
+                _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
                     analyzerFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index fe563a087f6..ab2e298879b 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -3,72 +3,39 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
-using System.IO;
 using System.Linq;
-using System.Text;
-using System.Text.Json.Serialization;
-using System.Text.Json;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
 using Microsoft.Build.Experimental.BuildCheck;
-using System.Configuration;
+using System.Collections.Concurrent;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-
-// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)
-// Tracked via: https://github.com/dotnet/msbuild/issues/9828
-internal static class ConfigurationProvider
+internal sealed class ConfigurationProvider
 {
-    // We might want to have a mechanism for removing unneeded configurations
-    //  (disabled rules and analyzers that need to run in different node)
-    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();
-
-    // This is just a testing implementation for quicker unblock of testing.
-    // Real implementation will use .editorconfig file.
-    // Sample json:
-    /////*lang=json,strict*/
-    ////"""
-    ////    {
-    ////        "ABC123": {
-    ////            "IsEnabled": true,
-    ////            "Severity": "Info"
-    ////        },
-    ////        "COND0543": {
-    ////            "IsEnabled": false,
-    ////            "Severity": "Error",
-    ////    		"EvaluationAnalysisScope": "AnalyzedProjectOnly",
-    ////    		"CustomSwitch": "QWERTY"
-    ////        },
-    ////        "BLA": {
-    ////            "IsEnabled": false
-    ////        }
-    ////    }
-    ////    """
-    //
-    // Plus there will need to be a mechanism of distinguishing different configs in different folders
-    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?
-    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()
-    {
-        const string configFileName = "editorconfig.json";
-        string configPath = configFileName;
+    private readonly EditorConfigParser _editorConfigParser = new EditorConfigParser();
 
-        if (!File.Exists(configPath))
-        {
-            // This is just a dummy implementation for testing purposes
-            var dir = Environment.CurrentDirectory;
-            configPath = Path.Combine(dir, configFileName);
+    private const string BuildCheck_ConfigurationKey = "build_check";
 
-            if (!File.Exists(configPath))
-            {
-                return new Dictionary<string, BuildAnalyzerConfiguration>();
-            }
-        }
+    /// <summary>
+    /// The dictionary used for storing the BuildAnalyzerConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, BuildAnalyzerConfiguration> _buildAnalyzerConfiguration = new ConcurrentDictionary<string, BuildAnalyzerConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
-        var json = File.ReadAllText(configPath);
-        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };
-        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??
-               new Dictionary<string, BuildAnalyzerConfiguration>();
-    }
+    /// <summary>
+    /// The dictionary used for storing the key-value pairs retrieved from the .editorconfigs for specific projectfile. The key is equal to projectFullPath.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, Dictionary<string, string>> _editorConfigData = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.InvariantCultureIgnoreCase);
+
+    /// <summary>
+    /// The dictionary used for storing the CustomConfigurationData per ruleId. The key is equal to ruleId.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, CustomConfigurationData> _customConfigurationData = new ConcurrentDictionary<string, CustomConfigurationData>(StringComparer.InvariantCultureIgnoreCase);
+
+    private readonly string[] _infrastructureConfigurationKeys = new string[] {
+        nameof(BuildAnalyzerConfiguration.EvaluationAnalysisScope).ToLower(),
+        nameof(BuildAnalyzerConfiguration.IsEnabled).ToLower(),
+        nameof(BuildAnalyzerConfiguration.Severity).ToLower()
+    };
 
     /// <summary>
     /// Gets the user specified unrecognized configuration for the given analyzer rule.
@@ -80,39 +47,82 @@ private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration(
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    public static CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
+    public CustomConfigurationData GetCustomConfiguration(string projectFullPath, string ruleId)
     {
-        return CustomConfigurationData.Null;
+        var configuration = GetConfiguration(projectFullPath, ruleId);
+
+        if (configuration is null)
+        {
+            return CustomConfigurationData.Null;
+        }
+
+        // remove the infrastructure owned key names
+        foreach (var infraConfigurationKey in _infrastructureConfigurationKeys)
+        {
+            configuration.Remove(infraConfigurationKey);
+        }
+
+        if (!configuration.Any())
+        {
+            return CustomConfigurationData.Null;
+        }
+
+        var data = new CustomConfigurationData(ruleId, configuration);
+
+        if (!_customConfigurationData.ContainsKey(ruleId))
+        {
+            _customConfigurationData[ruleId] = data;
+        }
+
+        return data;
     }
 
     /// <summary>
-    /// 
+    /// Verifies if previously fetched custom configurations are equal to current one. 
     /// </summary>
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <throws><see cref="BuildCheckConfigurationException"/> If CustomConfigurationData differs in a build for a same ruleId</throws>
     /// <returns></returns>
-    public static void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
+    internal void CheckCustomConfigurationDataValidity(string projectFullPath, string ruleId)
     {
-        // TBD
+        var configuration = GetCustomConfiguration(projectFullPath, ruleId);
+        VerifyCustomConfigurationEquality(ruleId, configuration);
     }
 
-    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+    internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurationData configurationData)
+    {
+        if (_customConfigurationData.TryGetValue(ruleId, out var storedConfiguration))
+        {
+            if (!storedConfiguration.Equals(configurationData))
+            {
+                throw new BuildCheckConfigurationException("Custom configuration should be equal between projects");
+            }
+        }
+    }
+
+    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         string projectFullPath,
         BuildAnalyzer analyzer)
         => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
 
-    public static BuildAnalyzerConfiguration[] GetUserConfigurations(
+    internal BuildAnalyzerConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
 
-    public static CustomConfigurationData[] GetCustomConfigurations(
+    /// <summary>
+    /// Retrieve array of CustomConfigurationData for a given projectPath and ruleIds
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <param name="ruleIds"></param>
+    /// <returns></returns>
+    public CustomConfigurationData[] GetCustomConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
+    internal BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         BuildAnalyzerConfiguration[] userConfigs,
         BuildAnalyzer analyzer)
     {
@@ -120,7 +130,7 @@ public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
-            configurations[idx] = ConfigurationProvider.MergeConfiguration(
+            configurations[idx] = MergeConfiguration(
                 analyzer.SupportedRules[idx].Id,
                 analyzer.SupportedRules[idx].DefaultConfiguration,
                 userConfigs[idx]);
@@ -129,7 +139,7 @@ public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
         return configurations;
     }
 
-    private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
+    private TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPath, IReadOnlyList<TRule> ruleIds, Func<string, TRule, TConfig> configurationProvider)
     {
         TConfig[] configurations = new TConfig[ruleIds.Count];
         for (int i = 0; i < ruleIds.Count; i++)
@@ -140,6 +150,72 @@ private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPat
         return configurations;
     }
 
+
+    /// <summary>
+    /// Generates a new dictionary that contains the key-value pairs from the original dictionary if the key starts with 'keyFilter'.
+    /// If updateKey is set to 'true', the keys of the new dictionary will not include keyFilter.
+    /// </summary>
+    /// <param name="keyFilter"></param>
+    /// <param name="originalConfiguration"></param>
+    /// <param name="updateKey"></param>
+    /// <returns></returns>
+    private Dictionary<string, string> FilterDictionaryByKeys(string keyFilter, Dictionary<string, string> originalConfiguration, bool updateKey = false)
+    {
+        var filteredConfig = new Dictionary<string, string>();
+
+        foreach (var kv in originalConfiguration)
+        {
+            if (kv.Key.StartsWith(keyFilter, StringComparison.OrdinalIgnoreCase))
+            {
+                var newKey = kv.Key;
+                if (updateKey)
+                {
+                    newKey = kv.Key.Substring(keyFilter.Length);
+                }
+
+                filteredConfig[newKey] = kv.Value;
+            }
+        }
+
+        return filteredConfig;
+    }
+
+    /// <summary>
+    /// Fetches the .editorconfig data in form of Key-Value pair.
+    /// Resulted dictionary will contain only BuildCheck related rules.
+    /// </summary>
+    /// <param name="projectFullPath"></param>
+    /// <returns></returns>
+    /// <exception cref="BuildCheckConfigurationException"></exception>
+    private Dictionary<string, string> FetchEditorConfigRules(string projectFullPath)
+    {
+        var editorConfigRules = _editorConfigData.GetOrAdd(projectFullPath, (key) =>
+        {
+            Dictionary<string, string> config;
+            try
+            {
+                config = _editorConfigParser.Parse(projectFullPath);
+            }
+            catch (Exception exception)
+            {
+                throw new BuildCheckConfigurationException($"Parsing editorConfig data failed", exception, BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+
+            // clear the dictionary from the key-value pairs not BuildCheck related and
+            // store the data so there is no need to parse the .editorconfigs all over again
+            Dictionary<string, string> filteredData = FilterDictionaryByKeys($"{BuildCheck_ConfigurationKey}.", config);
+            return filteredData;
+        });
+        
+        return editorConfigRules;
+    }
+
+    internal Dictionary<string, string> GetConfiguration(string projectFullPath, string ruleId)
+    {
+        var config = FetchEditorConfigRules(projectFullPath);
+        return FilterDictionaryByKeys($"{BuildCheck_ConfigurationKey}.{ruleId}.", config, updateKey: true);
+    }
+
     /// <summary>
     /// Gets effective user specified (or default) configuration for the given analyzer rule.
     /// The configuration values CAN be null upon this operation.
@@ -150,14 +226,24 @@ private static TConfig[] FillConfiguration<TConfig, TRule>(string projectFullPat
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
     {
-        if (!_editorConfig.TryGetValue(ruleId, out BuildAnalyzerConfiguration? editorConfig))
+        var cacheKey = $"{ruleId}-{projectFullPath}";
+
+        var editorConfigValue = _buildAnalyzerConfiguration.GetOrAdd(cacheKey, (key) =>
         {
-            editorConfig = BuildAnalyzerConfiguration.Null;
-        }
+            BuildAnalyzerConfiguration? editorConfig = BuildAnalyzerConfiguration.Null;
+            var config = GetConfiguration(projectFullPath, ruleId);
+
+            if (config.Any())
+            {
+                editorConfig = BuildAnalyzerConfiguration.Create(config);
+            }
+
+            return editorConfig;
+        });
 
-        return editorConfig;
+        return editorConfigValue;
     }
 
     /// <summary>
@@ -167,10 +253,10 @@ public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFull
     /// <param name="projectFullPath"></param>
     /// <param name="analyzerRule"></param>
     /// <returns></returns>
-    public static BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
+    internal BuildAnalyzerConfigurationInternal GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
         => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
 
-    public static BuildAnalyzerConfigurationInternal MergeConfiguration(
+    internal BuildAnalyzerConfigurationInternal MergeConfiguration(
         string ruleId,
         BuildAnalyzerConfiguration defaultConfig,
         BuildAnalyzerConfiguration editorConfig)
@@ -180,13 +266,13 @@ public static BuildAnalyzerConfigurationInternal MergeConfiguration(
             isEnabled: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.IsEnabled),
             severity: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.Severity));
 
-    private static BuildAnalyzerConfigurationInternal GetMergedConfiguration(
+    private BuildAnalyzerConfigurationInternal GetMergedConfiguration(
         string projectFullPath,
         string ruleId,
         BuildAnalyzerConfiguration defaultConfig)
         => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
 
-    private static T GetConfigValue<T>(
+    private T GetConfigValue<T>(
         BuildAnalyzerConfiguration editorConfigValue,
         BuildAnalyzerConfiguration defaultValue,
         Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
index d200d48ee66..afd3645cf2e 100644
--- a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -15,17 +15,27 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 ///  that were attribute to a particular rule, but were not recognized by the infrastructure.
 /// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
 /// </summary>
-/// <param name="ruleId"></param>
-public class CustomConfigurationData(string ruleId)
+public sealed class CustomConfigurationData
 {
     public static CustomConfigurationData Null { get; } = new(string.Empty);
 
     public static bool NotNull(CustomConfigurationData data) => !Null.Equals(data);
 
+    public CustomConfigurationData(string ruleId)
+    {
+        RuleId = ruleId;
+    }
+
+    public CustomConfigurationData(string ruleId, Dictionary<string, string> properties)
+    {
+        RuleId = ruleId;
+        ConfigurationData = properties;
+    }
+
     /// <summary>
     /// Identifier of the rule that the configuration data is for.
     /// </summary>
-    public string RuleId { get; init; } = ruleId;
+    public string RuleId { get; init; }
 
     /// <summary>
     /// Key-value pairs of unstructured data from .editorconfig file.
@@ -50,15 +60,43 @@ public override bool Equals(object? obj)
             return true;
         }
 
-        if (obj.GetType() != this.GetType())
+        if (obj is not CustomConfigurationData)
         {
             return false;
         }
 
-        return Equals((CustomConfigurationData)obj);
-    }
+        var customConfigObj = (CustomConfigurationData) obj;
 
-    protected bool Equals(CustomConfigurationData other) => Equals(ConfigurationData, other.ConfigurationData);
+        if (customConfigObj.RuleId != RuleId)
+        {
+            return false;
+        }
 
-    public override int GetHashCode() => (ConfigurationData != null ? ConfigurationData.GetHashCode() : 0);
+        // validate keys and values
+        if (customConfigObj.ConfigurationData != null && ConfigurationData != null && ConfigurationData.Count == customConfigObj.ConfigurationData.Count)
+        {
+            foreach (var keyVal in customConfigObj.ConfigurationData)
+            {
+                if (!ConfigurationData.TryGetValue(keyVal.Key, out var value) || value != keyVal.Value)
+                {
+                    return false;
+                }
+            }
+        }
+        else if (customConfigObj.ConfigurationData == null && ConfigurationData == null)
+        {
+            return true;
+        }
+        else
+        {
+            return false;
+        }
+
+        return true;
+    }
+
+    public override int GetHashCode()
+    {
+        throw new NotImplementedException("CustomConfigurationData does not implement GetHashCode method");
+    }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
new file mode 100644
index 00000000000..d2f93664369
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -0,0 +1,184 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Code and logic is copied from the https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.cs
+// with slight changes like:
+//  1. Remove dependency from Source text.
+//  2. Remove support of globalconfig
+//  3. Remove the FilePath and receive only the text
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal partial class EditorConfigFile
+{
+    // Matches EditorConfig section header such as "[*.{js,py}]", see https://editorconfig.org for details
+    private const string s_sectionMatcherPattern = @"^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$";
+
+    // Matches EditorConfig property such as "indent_style = space", see https://editorconfig.org for details
+    private const string s_propertyMatcherPattern = @"^\s*([\w\.\-_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$";
+
+#if NETCOREAPP
+
+[GeneratedRegex(s_sectionMatcherPattern)]
+private static partial Regex GetSectionMatcherRegex();
+
+[GeneratedRegex(s_propertyMatcherPattern)]
+private static partial Regex GetPropertyMatcherRegex();
+
+#else
+    private static readonly Regex s_sectionMatcher = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
+
+    private static readonly Regex s_propertyMatcher = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
+
+    private static Regex GetSectionMatcherRegex() => s_sectionMatcher;
+
+    private static Regex GetPropertyMatcherRegex() => s_propertyMatcher;
+
+#endif
+
+    internal Section GlobalSection { get; }
+
+    internal ImmutableArray<Section> NamedSections { get; }
+
+    /// <summary>
+    /// Gets whether this editorconfig is a topmost editorconfig.
+    /// </summary>
+    internal bool IsRoot => GlobalSection.Properties.TryGetValue("root", out string? val) && val?.ToLower() == "true";
+
+    private EditorConfigFile(
+        Section globalSection,
+        ImmutableArray<Section> namedSections)
+    {
+        GlobalSection = globalSection;
+        NamedSections = namedSections;
+    }
+
+    /// <summary>
+    /// Parses an editor config file text located at the given path. No parsing
+    /// errors are reported. If any line contains a parse error, it is dropped.
+    /// </summary>
+    internal static EditorConfigFile Parse(string text)
+    {
+        Section? globalSection = null;
+        var namedSectionBuilder = ImmutableArray.CreateBuilder<Section>();
+
+        // N.B. The editorconfig documentation is quite loose on property interpretation.
+        // Specifically, it says:
+        //      Currently all properties and values are case-insensitive.
+        //      They are lowercased when parsed.
+        // To accommodate this, we use a lower case Unicode mapping when adding to the
+        // dictionary, but we also use a case-insensitive key comparer when doing lookups
+        var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>(StringComparer.OrdinalIgnoreCase);
+        string activeSectionName = "";
+        var lines = string.IsNullOrEmpty(text) ? Array.Empty<string>() : text.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
+
+        foreach(var line in lines)
+        {
+            if (string.IsNullOrWhiteSpace(line))
+            {
+                continue;
+            }
+
+            if (IsComment(line))
+            {
+                continue;
+            }
+
+            var sectionMatches = GetSectionMatcherRegex().Matches(line);
+            if (sectionMatches.Count > 0 && sectionMatches[0].Groups.Count > 0)
+            {
+                addNewSection();
+
+                var sectionName = sectionMatches[0].Groups[1].Value;
+                Debug.Assert(!string.IsNullOrEmpty(sectionName));
+
+                activeSectionName = sectionName;
+                activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>();
+                continue;
+            }
+
+            var propMatches = GetPropertyMatcherRegex().Matches(line);
+            if (propMatches.Count > 0 && propMatches[0].Groups.Count > 1)
+            {
+                var key = propMatches[0].Groups[1].Value.ToLower();
+                var value = propMatches[0].Groups[2].Value;
+
+                Debug.Assert(!string.IsNullOrEmpty(key));
+                Debug.Assert(key == key.Trim());
+                Debug.Assert(value == value?.Trim());
+
+                activeSectionProperties[key] = value ?? "";
+                continue;
+            }
+        }
+
+        // Add the last section
+        addNewSection();
+
+        return new EditorConfigFile(globalSection!, namedSectionBuilder.ToImmutable());
+
+        void addNewSection()
+        {
+            // Close out the previous section
+            var previousSection = new Section(activeSectionName, activeSectionProperties.ToImmutable());
+            if (activeSectionName == "")
+            {
+                // This is the global section
+                globalSection = previousSection;
+            }
+            else
+            {
+                namedSectionBuilder.Add(previousSection);
+            }
+        }
+    }
+
+    private static bool IsComment(string line)
+    {
+        foreach (char c in line)
+        {
+            if (!char.IsWhiteSpace(c))
+            {
+                return c == '#' || c == ';';
+            }
+        }
+
+        return false;
+    }
+
+    /// <summary>
+    /// Represents a named section of the editorconfig file, which consists of a name followed by a set
+    /// of key-value pairs.
+    /// </summary>
+    internal sealed class Section
+    {
+        public Section(string name, ImmutableDictionary<string, string> properties)
+        {
+            Name = name;
+            Properties = properties;
+        }
+
+        /// <summary>
+        /// For regular files, the name as present directly in the section specification of the editorconfig file. For sections in
+        /// global configs, this is the unescaped full file path.
+        /// </summary>
+        public string Name { get; }
+
+        /// <summary>
+        /// Keys and values for this section. All keys are lower-cased according to the
+        /// EditorConfig specification and keys are compared case-insensitively. 
+        /// </summary>
+        public ImmutableDictionary<string, string> Properties { get; }
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
new file mode 100644
index 00000000000..60df42cb36d
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
@@ -0,0 +1,614 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Copied from https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.SectionNameMatching.cs
+// with some changes to make it quicker to integrate into the MSBuild.
+// Changes:
+//  1. ArrayBuilder was replaced with List.
+//  2. Exceptions. Wrap in try/catch blocks for proper reporting
+
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal class EditorConfigGlobsMatcher
+{
+    internal readonly struct SectionNameMatcher
+    {
+        private readonly ImmutableArray<(int minValue, int maxValue)> _numberRangePairs;
+
+        internal Regex Regex { get; }
+
+        internal SectionNameMatcher(
+            Regex regex,
+            ImmutableArray<(int minValue, int maxValue)> numberRangePairs)
+        {
+            Debug.Assert(regex.GetGroupNumbers().Length - 1 == numberRangePairs.Length);
+            Regex = regex;
+            _numberRangePairs = numberRangePairs;
+        }
+
+        internal bool IsMatch(string s)
+        {
+            if (_numberRangePairs.IsEmpty)
+            {
+                return Regex.IsMatch(s);
+            }
+
+            var match = Regex.Match(s);
+            if (!match.Success)
+            {
+                return false;
+            }
+
+            Debug.Assert(match.Groups.Count - 1 == _numberRangePairs.Length);
+            for (int i = 0; i < _numberRangePairs.Length; i++)
+            {
+                var (minValue, maxValue) = _numberRangePairs[i];
+                // Index 0 is the whole regex
+                if (!int.TryParse(match.Groups[i + 1].Value, out int matchedNum) ||
+                    matchedNum < minValue ||
+                    matchedNum > maxValue)
+                {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    /// <summary>
+    /// Takes a <see cref="EditorConfigFile.Section.Name"/> and creates a matcher that
+    /// matches the given language. Returns null if the section name is
+    /// invalid.
+    /// </summary>
+    internal static SectionNameMatcher? TryCreateSectionNameMatcher(string sectionName)
+    {
+        // An editorconfig section name is a language for recognizing file paths
+        // defined by the following grammar:
+        //
+        // <path> ::= <path-list>
+        // <path-list> ::= <path-item> | <path-item> <path-list>
+        // <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+        // <char> ::= any unicode character
+        // <choice> ::= "{" <choice-list> "}"
+        // <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+        // <range> ::= "{" <integer> ".." <integer> "}"
+        // <integer> ::= "-" <digit-list> | <digit-list>
+        // <digit-list> ::= <digit> | <digit> <digit-list>
+        // <digit> ::= 0-9
+
+        var sb = new StringBuilder();
+        sb.Append('^');
+
+        // EditorConfig matching depends on the whether or not there are
+        // directory separators and where they are located in the section
+        // name. Specifically, the editorconfig core parser says:
+        // https://github.com/editorconfig/editorconfig-core-c/blob/5d3996811e962a717a7d7fdd0a941192382241a7/src/lib/editorconfig.c#L231
+        //
+        //     Pattern would be:
+        //     /dir/of/editorconfig/file[double_star]/[section] if section does not contain '/',
+        //     /dir/of/editorconfig/file[section] if section starts with a '/', or
+        //     /dir/of/editorconfig/file/[section] if section contains '/' but does not start with '/'.
+
+        if (!sectionName.Contains("/"))
+        {
+            sb.Append(".*/");
+        }
+        else if (sectionName[0] != '/')
+        {
+            sb.Append('/');
+        }
+
+        var lexer = new SectionNameLexer(sectionName);
+        var numberRangePairs = new List<(int minValue, int maxValue)>();
+        if (!TryCompilePathList(ref lexer, sb, parsingChoice: false, numberRangePairs))
+        {
+            numberRangePairs.Clear();
+            return null;
+        }
+        sb.Append('$');
+
+
+        var imArray = ImmutableArray.CreateBuilder<(int, int)>(numberRangePairs is null ? 0 : numberRangePairs.Count);
+        if (numberRangePairs?.Count > 0)
+        {
+            imArray.AddRange(numberRangePairs);
+        }
+
+        return new SectionNameMatcher(
+            new Regex(sb.ToString(), RegexOptions.Compiled),
+            imArray.ToImmutableArray());
+    }
+
+    internal static string UnescapeSectionName(string sectionName)
+    {
+        var sb = new StringBuilder();
+        SectionNameLexer lexer = new SectionNameLexer(sectionName);
+        while (!lexer.IsDone)
+        {
+            var tokenKind = lexer.Lex();
+            if (tokenKind == TokenKind.SimpleCharacter)
+            {
+                sb.Append(lexer.EatCurrentCharacter());
+            }
+            else
+            {
+                // We only call this on strings that were already passed through IsAbsoluteEditorConfigPath, so
+                // we shouldn't have any other token kinds here.
+                throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+        return sb.ToString();
+    }
+
+    internal static bool IsAbsoluteEditorConfigPath(string sectionName)
+    {
+        // NOTE: editorconfig paths must use '/' as a directory separator character on all OS.
+
+        // on all unix systems this is thus a simple test: does the path start with '/'
+        // and contain no special chars?
+
+        // on windows, a path can be either drive rooted or not (e.g. start with 'c:' or just '')
+        // in addition to being absolute or relative.
+        // for example c:myfile.cs is a relative path, but rooted on drive c:
+        // /myfile2.cs is an absolute path but rooted to the current drive.
+
+        // in addition there are UNC paths and volume guids (see https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats)
+        // but these start with \\ (and thus '/' in editor config terminology)
+
+        // in this implementation we choose to ignore the drive root for the purposes of
+        // determining validity. On windows c:/file.cs and /file.cs are both assumed to be
+        // valid absolute paths, even though the second one is technically relative to
+        // the current drive of the compiler working directory. 
+
+        // Note that this check has no impact on config correctness. Files on windows
+        // will still be compared using their full path (including drive root) so it's
+        // not possible to target the wrong file. It's just possible that the user won't
+        // receive a warning that this section is ignored on windows in this edge case.
+
+        SectionNameLexer nameLexer = new SectionNameLexer(sectionName);
+        bool sawStartChar = false;
+        int logicalIndex = 0;
+        while (!nameLexer.IsDone)
+        {
+            if (nameLexer.Lex() != TokenKind.SimpleCharacter)
+            {
+                return false;
+            }
+            var simpleChar = nameLexer.EatCurrentCharacter();
+
+            // check the path starts with '/'
+            if (logicalIndex == 0)
+            {
+                if (simpleChar == '/')
+                {
+                    sawStartChar = true;
+                }
+                else if (Path.DirectorySeparatorChar == '/')
+                {
+                    return false;
+                }
+            }
+            // on windows we get a second chance to find the start char
+            else if (!sawStartChar && Path.DirectorySeparatorChar == '\\')
+            {
+                if (logicalIndex == 1 && simpleChar != ':')
+                {
+                    return false;
+                }
+                else if (logicalIndex == 2)
+                {
+                    if (simpleChar != '/')
+                    {
+                        return false;
+                    }
+                    else
+                    {
+                        sawStartChar = true;
+                    }
+                }
+            }
+            logicalIndex++;
+        }
+        return sawStartChar;
+    }
+
+
+    /// <summary>
+    /// <![CDATA[
+    /// <path-list> ::= <path-item> | <path-item> <path-list>
+    /// <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+    /// <char> ::= any unicode character
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompilePathList(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        bool parsingChoice,
+        List<(int minValue, int maxValue)> numberRangePairs)
+    {
+        while (!lexer.IsDone)
+        {
+            var tokenKind = lexer.Lex();
+            switch (tokenKind)
+            {
+                case TokenKind.BadToken:
+                    // Parsing failure
+                    return false;
+                case TokenKind.SimpleCharacter:
+                    // Matches just this character
+                    sb.Append(Regex.Escape(lexer.EatCurrentCharacter().ToString()));
+                    break;
+                case TokenKind.Question:
+                    // '?' matches any single character
+                    sb.Append('.');
+                    break;
+                case TokenKind.Star:
+                    // Matches any string of characters except directory separator
+                    // Directory separator is defined in editorconfig spec as '/'
+                    sb.Append("[^/]*");
+                    break;
+                case TokenKind.StarStar:
+                    // Matches any string of characters
+                    sb.Append(".*");
+                    break;
+                case TokenKind.OpenCurly:
+                    // Back up token stream. The following helpers all expect a '{'
+                    lexer.Position--;
+                    // This is ambiguous between {num..num} and {item1,item2}
+                    // We need to look ahead to disambiguate. Looking for {num..num}
+                    // is easier because it can't be recursive.
+                    (string numStart, string numEnd)? rangeOpt = TryParseNumberRange(ref lexer);
+                    if (rangeOpt is null)
+                    {
+                        // Not a number range. Try a choice expression
+                        if (!TryCompileChoice(ref lexer, sb, numberRangePairs))
+                        {
+                            return false;
+                        }
+                        // Keep looping. There may be more after the '}'.
+                        break;
+                    }
+                    else
+                    {
+                        (string numStart, string numEnd) = rangeOpt.GetValueOrDefault();
+                        if (int.TryParse(numStart, out var intStart) && int.TryParse(numEnd, out var intEnd))
+                        {
+                            var pair = intStart < intEnd ? (intStart, intEnd) : (intEnd, intStart);
+                            numberRangePairs.Add(pair);
+                            // Group allowing any digit sequence. The validity will be checked outside of the regex
+                            sb.Append("(-?[0-9]+)");
+                            // Keep looping
+                            break;
+                        }
+                        return false;
+                    }
+                case TokenKind.CloseCurly:
+                    // Either the end of a choice, or a failed parse
+                    return parsingChoice;
+                case TokenKind.Comma:
+                    // The end of a choice section, or a failed parse
+                    return parsingChoice;
+                case TokenKind.OpenBracket:
+                    sb.Append('[');
+                    if (!TryCompileCharacterClass(ref lexer, sb))
+                    {
+                        return false;
+                    }
+                    break;
+                default:
+                    throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+        // If we're parsing a choice we should not exit without a closing '}'
+        return !parsingChoice;
+    }
+
+    /// <summary>
+    /// Compile a globbing character class of the form [...]. Returns true if
+    /// the character class was successfully compiled. False if there was a syntax
+    /// error. The starting character is expected to be directly after the '['.
+    /// </summary>
+    private static bool TryCompileCharacterClass(ref SectionNameLexer lexer, StringBuilder sb)
+    {
+        // [...] should match any of the characters in the brackets, with special
+        // behavior for four characters: '!' immediately after the opening bracket
+        // implies the negation of the character class, '-' implies matching
+        // between the locale-dependent range of the previous and next characters,
+        // '\' escapes the following character, and ']' ends the range
+        if (!lexer.IsDone && lexer.CurrentCharacter == '!')
+        {
+            sb.Append('^');
+            lexer.Position++;
+        }
+        while (!lexer.IsDone)
+        {
+            var currentChar = lexer.EatCurrentCharacter();
+            switch (currentChar)
+            {
+                case '-':
+                    // '-' means the same thing in regex as it does in the glob, so
+                    // put it in verbatim
+                    sb.Append(currentChar);
+                    break;
+
+                case '\\':
+                    // Escape the next char
+                    if (lexer.IsDone)
+                    {
+                        return false;
+                    }
+                    sb.Append('\\');
+                    sb.Append(lexer.EatCurrentCharacter());
+                    break;
+
+                case ']':
+                    sb.Append(currentChar);
+                    return true;
+
+                default:
+                    sb.Append(Regex.Escape(currentChar.ToString()));
+                    break;
+            }
+        }
+        // Stream ended without a closing bracket
+        return false;
+    }
+
+    /// <summary>
+    /// Parses choice defined by the following grammar:
+    /// <![CDATA[
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompileChoice(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        List<(int, int)> numberRangePairs)
+    {
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
+            return false;
+        }
+
+        // Start a non-capturing group for the choice
+        sb.Append("(?:");
+
+        // We start immediately after a '{'
+        // Try to compile the nested <path-list>
+        while (TryCompilePathList(ref lexer, sb, parsingChoice: true, numberRangePairs))
+        {
+            // If we've successfully compiled a <path-list> the last token should
+            // have been a ',' or a '}'
+            char lastChar = lexer[lexer.Position - 1];
+            if (lastChar == ',')
+            {
+                // Another option
+                sb.Append('|');
+            }
+            else if (lastChar == '}')
+            {
+                // Close out the capture group
+                sb.Append(')');
+                return true;
+            }
+            else
+            {
+                throw new BuildCheckConfigurationException($"UnexpectedValue: {lastChar}", BuildCheckConfigurationErrorScope.EditorConfigParser);
+            }
+        }
+
+        // Propagate failure
+        return false;
+    }
+
+    /// <summary>
+    /// Parses range defined by the following grammar.
+    /// <![CDATA[
+    /// <range> ::= "{" <integer> ".." <integer> "}"
+    /// <integer> ::= "-" <digit-list> | <digit-list>
+    /// <digit-list> ::= <digit> | <digit> <digit-list>
+    /// <digit> ::= 0-9
+    /// ]]>
+    /// </summary>
+    private static (string numStart, string numEnd)? TryParseNumberRange(ref SectionNameLexer lexer)
+    {
+        var saved = lexer.Position;
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
+            lexer.Position = saved;
+            return null;
+        }
+
+        var numStart = lexer.TryLexNumber();
+        if (numStart is null)
+        {
+            // Not a number
+            lexer.Position = saved;
+            return null;
+        }
+
+        // The next two characters must be ".."
+        if (!lexer.TryEatCurrentCharacter(out char c) || c != '.' ||
+            !lexer.TryEatCurrentCharacter(out c) || c != '.')
+        {
+            lexer.Position = saved;
+            return null;
+        }
+
+        // Now another number
+        var numEnd = lexer.TryLexNumber();
+        if (numEnd is null || lexer.IsDone || lexer.Lex() != TokenKind.CloseCurly)
+        {
+            // Not a number or no '}'
+            lexer.Position = saved;
+            return null;
+        }
+
+        return (numStart, numEnd);
+    }
+
+    private struct SectionNameLexer
+    {
+        private readonly string _sectionName;
+
+        internal int Position { get; set; }
+
+        internal SectionNameLexer(string sectionName)
+        {
+            _sectionName = sectionName;
+            Position = 0;
+        }
+
+        internal bool IsDone => Position >= _sectionName.Length;
+
+        internal TokenKind Lex()
+        {
+            int lexemeStart = Position;
+            switch (_sectionName[Position])
+            {
+                case '*':
+                    {
+                        int nextPos = Position + 1;
+                        if (nextPos < _sectionName.Length &&
+                            _sectionName[nextPos] == '*')
+                        {
+                            Position += 2;
+                            return TokenKind.StarStar;
+                        }
+                        else
+                        {
+                            Position++;
+                            return TokenKind.Star;
+                        }
+                    }
+
+                case '?':
+                    Position++;
+                    return TokenKind.Question;
+
+                case '{':
+                    Position++;
+                    return TokenKind.OpenCurly;
+
+                case ',':
+                    Position++;
+                    return TokenKind.Comma;
+
+                case '}':
+                    Position++;
+                    return TokenKind.CloseCurly;
+
+                case '[':
+                    Position++;
+                    return TokenKind.OpenBracket;
+
+                case '\\':
+                    {
+                        // Backslash escapes the next character
+                        Position++;
+                        if (IsDone)
+                        {
+                            return TokenKind.BadToken;
+                        }
+
+                        return TokenKind.SimpleCharacter;
+                    }
+
+                default:
+                    // Don't increment position, since caller needs to fetch the character
+                    return TokenKind.SimpleCharacter;
+            }
+        }
+
+        internal char CurrentCharacter => _sectionName[Position];
+
+        /// <summary>
+        /// Call after getting <see cref="TokenKind.SimpleCharacter" /> from <see cref="Lex()" />
+        /// </summary>
+        internal char EatCurrentCharacter() => _sectionName[Position++];
+
+        /// <summary>
+        /// Returns false if there are no more characters in the lex stream.
+        /// Otherwise, produces the next character in the stream and returns true.
+        /// </summary>
+        internal bool TryEatCurrentCharacter(out char nextChar)
+        {
+            if (IsDone)
+            {
+                nextChar = default;
+                return false;
+            }
+            else
+            {
+                nextChar = EatCurrentCharacter();
+                return true;
+            }
+        }
+
+        internal char this[int position] => _sectionName[position];
+
+        /// <summary>
+        /// Returns the string representation of a decimal integer, or null if
+        /// the current lexeme is not an integer.
+        /// </summary>
+        internal string? TryLexNumber()
+        {
+            bool start = true;
+            var sb = new StringBuilder();
+
+            while (!IsDone)
+            {
+                char currentChar = CurrentCharacter;
+                if (start && currentChar == '-')
+                {
+                    Position++;
+                    sb.Append('-');
+                }
+                else if (char.IsDigit(currentChar))
+                {
+                    Position++;
+                    sb.Append(currentChar);
+                }
+                else
+                {
+                    break;
+                }
+                start = false;
+            }
+
+            var str = sb.ToString();
+            return str.Length == 0 || str == "-"
+                ? null
+                : str;
+        }
+    }
+
+    private enum TokenKind
+    {
+        BadToken,
+        SimpleCharacter,
+        Star,
+        StarStar,
+        Question,
+        OpenCurly,
+        CloseCurly,
+        Comma,
+        DoubleDot,
+        OpenBracket,
+    }
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
new file mode 100644
index 00000000000..76baa1f1e66
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -0,0 +1,104 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Drawing.Design;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Shared;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+
+internal sealed class EditorConfigParser
+{
+    private const string EditorconfigFile = ".editorconfig";
+
+    /// <summary>
+    /// Cache layer of the parsed editor configs the key is the path to the .editorconfig file.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, EditorConfigFile> _editorConfigFileCache = new ConcurrentDictionary<string, EditorConfigFile>(StringComparer.InvariantCultureIgnoreCase);
+
+    internal Dictionary<string, string> Parse(string filePath)
+    {
+        var editorConfigs = DiscoverEditorConfigFiles(filePath);
+        return MergeEditorConfigFiles(editorConfigs, filePath);
+    }
+
+    /// <summary>
+    /// Fetches the list of EditorconfigFile ordered from the nearest to the filePath.
+    /// </summary>
+    /// <param name="filePath"></param>
+    internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
+    {
+        var editorConfigDataFromFilesList = new List<EditorConfigFile>();
+
+        var directoryOfTheProject = Path.GetDirectoryName(filePath);
+        // The method will look for the file in parent directory if not found in current until found or the directory is root. 
+        var editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);
+
+        while (editorConfigFilePath != string.Empty)
+        {
+            var editorConfig = _editorConfigFileCache.GetOrAdd(editorConfigFilePath, (key) =>
+            {
+                using (FileStream stream = new FileStream(editorConfigFilePath, FileMode.Open, System.IO.FileAccess.Read, FileShare.Read))
+                {
+                    using StreamReader sr = new StreamReader(editorConfigFilePath);
+                    var editorConfigfileContent = sr.ReadToEnd();
+                    return EditorConfigFile.Parse(editorConfigfileContent);
+                }
+            });
+
+            editorConfigDataFromFilesList.Add(editorConfig);
+
+            if (editorConfig.IsRoot)
+            {
+                break;
+            }
+            else
+            {
+                // search in upper directory
+                editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, Path.GetDirectoryName(Path.GetDirectoryName(editorConfigFilePath)));
+            }
+        }
+
+        return editorConfigDataFromFilesList;
+    }
+
+    /// <summary>
+    /// Retrieves the config dictionary from the sections that matched the filePath. 
+    /// </summary>
+    /// <param name="editorConfigFiles"></param>
+    /// <param name="filePath"></param>
+    internal Dictionary<string, string> MergeEditorConfigFiles(List<EditorConfigFile> editorConfigFiles, string filePath)
+    {
+        var resultingDictionary = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
+
+        for (int i = editorConfigFiles.Count - 1; i >= 0; i--)
+        {
+            foreach (var section in editorConfigFiles[i].NamedSections)
+            {
+                SectionNameMatcher? sectionNameMatcher = TryCreateSectionNameMatcher(section.Name);
+                if (sectionNameMatcher != null)
+                {
+                    if (sectionNameMatcher.Value.IsMatch(NormalizeWithForwardSlash(filePath)))
+                    {
+                        foreach (var property in section.Properties)
+                        {
+                            resultingDictionary[property.Key] = property.Value;
+                        }
+                    }
+                }
+            }
+        }
+        
+        return resultingDictionary;
+    }
+
+    internal static string NormalizeWithForwardSlash(string p) => Path.DirectorySeparatorChar == '/' ? p : p.Replace(Path.DirectorySeparatorChar, '/');
+}
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
new file mode 100644
index 00000000000..e19b61c2c40
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
@@ -0,0 +1,98 @@
+﻿# EditorConfigParser
+
+Logic of parsing and matching copied from Roslyn implementation.
+To track the request on sharing the code: https://github.com/dotnet/roslyn/issues/72324
+
+
+In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. 
+
+Configuration divided into two categories: 
+- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope
+- Custom configuration, any other config specified by user for this particular rule
+
+### Example
+For the file/folder structure: 
+```
+├── folder1/
+│   └── .editorconfig
+│   └── folder2/
+        ├── folder3/
+        │   └── .editorconfig
+        │   └── test.proj
+        └── .editorconfig
+```
+
+we want to fetch configuration for the project: /full/path/folder1/folder2/folder3/test.proj 
+
+Infra related and custom configuration flows have one common logic: Fetching the configs from editorconfig
+
+```
+while(editorConfig is not root && parent directory exists){
+        collect, parse editorconfigs 
+}
+
+list<editorConfig>{
+    folder1/folder2/folder3/.editorconfig
+    folder1/folder2/.editorconfig
+    folder1/.editorconfig
+}
+```
+Reverse the order and collect all matching section key-value pairs into new dictionary
+Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)
+
+The implementation differs depending on category: 
+ - Infra related config: Merges the configuration retrieved from configuration module with default values (respecting the specified configs in editorconfig) 
+ - Custom configuration: Remove all infra related keys from dictionary
+
+Four levels of cache introduced: 
+- When retrieving and parsing the editor config -> Parsed results are saved into dictionary: editorconfigPath = ParsedEditorConfig
+- When retrieving and merging the editor config data for project -> Parsed and merged results are saved into dictionary: projectFilePath = MargedData of ParsedEditorConfig
+- When retrieving Infra related config: ruleId-projectPath = BuildConfigInstance
+- CustomConfigurationData: In order to verify that the config data is the same between projects
+
+Usage examples (API)
+
+```
+var editorConfigParser = new EditorConfigParser();
+editorConfigParser.Parse("path/to/the/file")
+```
+
+The snippet above will return all applied key-value Dictionary<string, string> pairs collected from .editorconfig files
+
+Currently EditorConfigParser is used by [ConfigurationProvider](https://github.com/dotnet/msbuild/blob/e0dfb8d1ce5fc1de5153e65ea04c66a6dcac6279/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs#L129).
+
+#### Cache lifetime
+The lifetime of the cached configuration is defined by the usage of the instance of ConfigurationProvider. The instance of the ConfigurationProvider is created per BuildCheckManager.
+Lifecycle of BuildCheckManager could be found [here](https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#handling-the-distributed-model)
+
+
+#### Custom configuration data
+CustomConfigurationData is propogated to the BuildCheck Analyzer instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
+during the initialization of the [BuildAnalyzer](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildAnalyzer.cs#L36).
+
+
+#### Example of consuming the CustomConfigurationData
+The `Initialize` method of BuildCheck Analyzer:
+```C#
+public override void Initialize(ConfigurationContext configurationContext)
+{
+    Console.WriteLine(configurationContext.CustomConfigurationData.Count);
+    for (int i = 0; i < configurationContext.CustomConfigurationData.Count; i++)
+    {
+        var customConfigPerRule = configurationContext.CustomConfigurationData[i]; 
+        Console.WriteLine(customConfigPerRule.RuleId); 
+
+        if (customConfigPerRule.ConfigurationData is not null) // null when the configuration was not provided from editorconfig
+        {
+            foreach (var kv in customConfigPerRule.ConfigurationData)
+            {
+                Console.WriteLine($"{kv.Key}------{kv.Value}");
+            }
+        }
+        else
+        {
+            Console.WriteLine($"The data is null for index: {i}");
+        }
+    }
+}
+```
diff --git a/src/Build/BuildCheck/Utilities/Constants.cs b/src/Build/BuildCheck/Utilities/Constants.cs
index 8ba5eaf65f6..50a3d1bc63c 100644
--- a/src/Build/BuildCheck/Utilities/Constants.cs
+++ b/src/Build/BuildCheck/Utilities/Constants.cs
@@ -7,13 +7,12 @@
 using System.Text;
 using System.Threading.Tasks;
 
-namespace Microsoft.Build.Experimental.BuildCheck.Utilities
+namespace Microsoft.Build.Experimental.BuildCheck.Utilities;
+
+/// <summary>
+/// Constants to be shared within BuildCheck infrastructure
+/// </summary>
+internal static class BuildCheckConstants
 {
-    /// <summary>
-    /// Constants to be shared within BuildCheck infrastructure
-    /// </summary>
-    internal static class BuildCheckConstants
-    {
-        internal const string infraStatPrefix = "infrastructureStat_";
-    }
+    internal const string infraStatPrefix = "infrastructureStat_";
 }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 3e958274425..b294cce23ea 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -167,6 +167,10 @@
     <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManager.cs" />
     <Compile Include="BuildCheck\Infrastructure\NullBuildCheckManagerProvider.cs" />
     <Compile Include="BuildCheck\Infrastructure\TracingReporter.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigFile.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigGlobsMatcher.cs" />
+    <Compile Include="BuildCheck\Infrastructure\EditorConfig\EditorConfigParser.cs" />
+    <Compile Include="BuildCheck\Infrastructure\BuildCheckConfigurationErrorScope.cs" />
     <Compile Include="BuildCheck\OM\BuildCheckDataContext.cs" />
     <Compile Include="BuildCheck\API\BuildAnalyzer.cs" />
     <Compile Include="BuildCheck\API\BuildAnalyzerConfiguration.cs" />
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
index a3f8b019439..7bd57f8014b 100644
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
@@ -1,11 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Xunit;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
new file mode 100644
index 00000000000..edfdfaf4589
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
@@ -0,0 +1,113 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildAnalyzerConfiguration_Test
+{
+    [Fact]
+    public void CreateWithNull_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(null);
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Fact]
+    public void CreateWithEmpty_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", BuildAnalyzerResultSeverity.Error)]
+    [InlineData("info", BuildAnalyzerResultSeverity.Info)]
+    [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
+    [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
+    public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity" , parameter },
+        };
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("true", true)]
+    [InlineData("TRUE", true)]
+    [InlineData("false", false)]
+    [InlineData("FALSE", false)]
+    public void CreateBuildAnalyzerConfiguration_IsEnabled(string parameter, bool? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "isenabled" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.IsEnabled.ShouldBe(expected);
+
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("ProjectOnly", EvaluationAnalysisScope.ProjectOnly)]
+    [InlineData("ProjectWithImportsFromCurrentWorkTree", EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree)]
+    [InlineData("ProjectWithImportsWithoutSdks", EvaluationAnalysisScope.ProjectWithImportsWithoutSdks)]
+    [InlineData("ProjectWithAllImports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    [InlineData("projectwithallimports", EvaluationAnalysisScope.ProjectWithAllImports)]
+    public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string parameter, EvaluationAnalysisScope? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "evaluationanalysisscope" , parameter },
+        };
+
+        var buildConfig = BuildAnalyzerConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.EvaluationAnalysisScope.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.Severity.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("evaluationanalysisscope", "incorrec-value")]
+    [InlineData("isenabled", "incorrec-value")]
+    [InlineData("severity", "incorrec-value")]
+    public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { key , value },
+        };
+
+        var exception = Should.Throw<BuildCheckConfigurationException>(() => {
+            BuildAnalyzerConfiguration.Create(config);
+        });
+        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
new file mode 100644
index 00000000000..d559e1724b1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -0,0 +1,221 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class ConfigurationProvider_Tests
+{
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsEmptyConfig()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // empty
+        configs.ShouldBe(new Dictionary<string, string>());
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var configs = configurationProvider.GetConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        configs.Keys.Count.ShouldBe(2);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+
+        configs["property2"].ShouldBe("value2");
+        configs["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationData()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        any_other_key1=any_other_value1
+        any_other_key2=any_other_value2
+        any_other_key3=any_other_value3
+        any_other_key3=any_other_value3
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var customConfiguration = configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+        var configs = customConfiguration.ConfigurationData;
+
+        configs!.Keys.Count().ShouldBe(3);
+
+        configs.ContainsKey("property1").ShouldBeTrue();
+        configs.ContainsKey("property2").ShouldBeTrue();
+        configs.ContainsKey("isenabled2").ShouldBeTrue();
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.Severity=Error
+        build_check.rule_id.EvaluationAnalysisScope=ProjectOnly
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        var buildConfig = configurationProvider.GetUserConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        buildConfig.ShouldNotBeNull();
+
+        buildConfig.IsEnabled?.ShouldBeTrue();
+        buildConfig.Severity?.ShouldBe(BuildAnalyzerResultSeverity.Error);
+        buildConfig.EvaluationAnalysisScope?.ShouldBe(EvaluationAnalysisScope.ProjectOnly);
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentValues()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value2
+        build_check.rule_id.property2=value3
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=tru1
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_NotValid_DifferentKeys()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled2=true
+        build_check.rule_id.isEnabled3=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should not fail => configurations are the same
+        Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+
+    [Fact]
+    public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+
+        [test123.csproj]
+        build_check.rule_id.property1=value1
+        build_check.rule_id.property2=value2
+        build_check.rule_id.isEnabled=true
+        build_check.rule_id.isEnabled2=true
+        """);
+
+        var configurationProvider = new ConfigurationProvider();
+        configurationProvider.GetCustomConfiguration(Path.Combine(workFolder1.Path, "test.csproj"), "rule_id");
+
+        // should fail, because the configs are the different
+        Should.NotThrow(() =>
+        {
+            configurationProvider.CheckCustomConfigurationDataValidity(Path.Combine(workFolder1.Path, "test123.csproj"), "rule_id");
+        });
+    }
+}
diff --git a/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
new file mode 100644
index 00000000000..e8ff337e1a8
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CustomConfigurationData_Tests.cs
@@ -0,0 +1,140 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CustomConfigurationData_Tests
+{
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_NullInstance()
+    {
+        var customConfigurationData1 = CustomConfigurationData.Null;
+        var customConfigurationData2 = CustomConfigurationData.Null;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_SameInstance()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = customConfigurationData1;
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_DifferentObjectType()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new object();
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_DifferentInstanceSameValues()
+    {
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId");
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataSame()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferent()
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId");
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentKeys()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeFalse_CustomConfigDataDifferentValues()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key1", "val2" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeFalse();
+    }
+
+    [Fact]
+    public void TestCustomConfigurationData_Equals_ShouldBeTrue_CustomConfigDataKeysOrderDiffers()
+    {
+        var config1 = new Dictionary<string, string>()
+        {
+            { "key1", "val1" },
+            { "key2", "val2" }
+        };
+
+        var config2 = new Dictionary<string, string>()
+        {
+            { "key2", "val2" },
+            { "key1", "val1" }
+        };
+
+        var customConfigurationData1 = new CustomConfigurationData("testRuleId", config1);
+        var customConfigurationData2 = new CustomConfigurationData("testRuleId", config2);
+
+        customConfigurationData1.Equals(customConfigurationData2).ShouldBeTrue();
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
new file mode 100644
index 00000000000..17bd60abbd1
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfigParser_Tests.cs
@@ -0,0 +1,119 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfigParser_Tests
+{
+    [Fact]
+    public void NoSectionConfigured_ResultsEmptyResultConfig()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file");
+        mergedResult.Keys.Count.ShouldBe(0);
+    }
+
+    [Fact]
+    public void ProperOrderOfconfiguration_ClosestToTheFileShouldBeApplied()
+    {
+        var configs = new List<EditorConfigFile>(){
+            EditorConfigFile.Parse(""""
+                    [*]
+                    property1=value1
+""""),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value2
+                """"),
+            EditorConfigFile.Parse(""""
+                [*]
+                property1=value3
+                """"),
+        };
+
+        var parser = new EditorConfigParser();
+        var mergedResult = parser.MergeEditorConfigFiles(configs, "/some/path/to/file.proj");
+        mergedResult.Keys.Count.ShouldBe(1);
+        mergedResult["property1"].ShouldBe("value1");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootTrue()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        root=true
+
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=should_not_be_respected_and_parsed
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj") ).ToList();
+        // should be one because root=true so we do not need to go further
+        listOfEditorConfigFile.Count.ShouldBe(1);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeTrue();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+        listOfEditorConfigFile[0].NamedSections[0].Properties["test_key"].ShouldBe("test_value_updated");
+    }
+
+    [Fact]
+    public void EditorconfigFileDiscovery_RootFalse()
+    {
+        using TestEnvironment testEnvironment = TestEnvironment.Create();
+
+        TransientTestFolder workFolder1 = testEnvironment.CreateFolder(createFolder: true);
+        TransientTestFolder workFolder2 = testEnvironment.CreateFolder(Path.Combine(workFolder1.Path, "subfolder"), createFolder: true);
+
+        TransientTestFile config1 = testEnvironment.CreateFile(workFolder2, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=test_value_updated
+        """);
+
+        TransientTestFile config2 = testEnvironment.CreateFile(workFolder1, ".editorconfig",
+        """
+        [*.csproj]
+        test_key=will_be_there
+        """);
+
+        var parser = new EditorConfigParser();
+        var listOfEditorConfigFile = parser.DiscoverEditorConfigFiles(Path.Combine(workFolder1.Path, "subfolder", "projectfile.proj")).ToList();
+
+        listOfEditorConfigFile.Count.ShouldBe(2);
+        listOfEditorConfigFile[0].IsRoot.ShouldBeFalse();
+        listOfEditorConfigFile[0].NamedSections[0].Name.ShouldBe("*.csproj");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
new file mode 100644
index 00000000000..1b1b0c5aaa4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -0,0 +1,1078 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
+using Xunit;
+using static Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+#nullable disable
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EditorConfig_Tests
+{
+
+    #region AssertEqualityComparer<T>
+    private sealed class AssertEqualityComparer<T> : IEqualityComparer<T>
+    {
+        public static readonly IEqualityComparer<T> Instance = new AssertEqualityComparer<T>();
+
+        private static bool CanBeNull()
+        {
+            var type = typeof(T);
+            return !type.GetTypeInfo().IsValueType ||
+                (type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
+        }
+
+        public static bool IsNull(T @object)
+        {
+            if (!CanBeNull())
+            {
+                return false;
+            }
+
+            return object.Equals(@object, default(T));
+        }
+
+        public static bool Equals(T left, T right)
+        {
+            return Instance.Equals(left, right);
+        }
+
+        bool IEqualityComparer<T>.Equals(T x, T y)
+        {
+            if (CanBeNull())
+            {
+                if (object.Equals(x, default(T)))
+                {
+                    return object.Equals(y, default(T));
+                }
+
+                if (object.Equals(y, default(T)))
+                {
+                    return false;
+                }
+            }
+
+            if (x.GetType() != y.GetType())
+            {
+                return false;
+            }
+
+            if (x is IEquatable<T> equatable)
+            {
+                return equatable.Equals(y);
+            }
+
+            if (x is IComparable<T> comparableT)
+            {
+                return comparableT.CompareTo(y) == 0;
+            }
+
+            if (x is IComparable comparable)
+            {
+                return comparable.CompareTo(y) == 0;
+            }
+
+            var enumerableX = x as IEnumerable;
+            var enumerableY = y as IEnumerable;
+
+            if (enumerableX != null && enumerableY != null)
+            {
+                var enumeratorX = enumerableX.GetEnumerator();
+                var enumeratorY = enumerableY.GetEnumerator();
+
+                while (true)
+                {
+                    bool hasNextX = enumeratorX.MoveNext();
+                    bool hasNextY = enumeratorY.MoveNext();
+
+                    if (!hasNextX || !hasNextY)
+                    {
+                        return hasNextX == hasNextY;
+                    }
+
+                    if (!Equals(enumeratorX.Current, enumeratorY.Current))
+                    {
+                        return false;
+                    }
+                }
+            }
+
+            return object.Equals(x, y);
+        }
+
+        int IEqualityComparer<T>.GetHashCode(T obj)
+        {
+            throw new NotImplementedException();
+        }
+    }
+
+    #endregion
+
+    // Section Matchin Test cases: https://github.com/dotnet/roslyn/blob/ba163e712b01358a217065eec8a4a82f94a7efd5/src/Compilers/Core/CodeAnalysisTest/Analyzers/AnalyzerConfigTests.cs#L337
+    #region Section Matching Tests
+    [Fact]
+    public void SimpleNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc").Value;
+        Assert.Equal("^.*/abc$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/aabc"));
+        Assert.False(matcher.IsMatch("/ abc"));
+        Assert.False(matcher.IsMatch("/cabc"));
+    }
+
+    [Fact]
+    public void StarOnlyMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*").Value;
+        Assert.Equal("^.*/[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/123"));
+        Assert.True(matcher.IsMatch("/abc/123"));
+    }
+
+    [Fact]
+    public void StarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.cs").Value;
+        Assert.Equal("^.*/[^/]*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/123.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+        // Only '/' is defined as a directory separator, so the caller
+        // is responsible for converting any other machine directory
+        // separators to '/' before matching
+        Assert.True(matcher.IsMatch("/dir\\subpath.cs"));
+
+        Assert.False(matcher.IsMatch("/abc.vb"));
+    }
+
+    [Fact]
+    public void StarStarNameMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("**.cs").Value;
+        Assert.Equal("^.*/.*\\.cs$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/dir/subpath.cs"));
+    }
+
+    [Fact]
+    public void EscapeDot()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("...").Value;
+        Assert.Equal("^.*/\\.\\.\\.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/..."));
+        Assert.True(matcher.IsMatch("/subdir/..."));
+        Assert.False(matcher.IsMatch("/aaa"));
+        Assert.False(matcher.IsMatch("/???"));
+        Assert.False(matcher.IsMatch("/abc"));
+    }
+
+    [Fact]
+    public void EndBackslashMatch()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc\\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void QuestionMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab?def").Value;
+        Assert.Equal("^.*/ab.def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcdef"));
+        Assert.True(matcher.IsMatch("/ab?def"));
+        Assert.True(matcher.IsMatch("/abzdef"));
+        Assert.True(matcher.IsMatch("/ab/def"));
+        Assert.True(matcher.IsMatch("/ab\\def"));
+    }
+
+    [Fact]
+    public void LiteralBackslash()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab\\\\c").Value;
+        Assert.Equal("^.*/ab\\\\c$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab\\c"));
+        Assert.False(matcher.IsMatch("/ab/c"));
+        Assert.False(matcher.IsMatch("/ab\\\\c"));
+    }
+
+    [Fact]
+    public void LiteralStars()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\***\\*\\**").Value;
+        Assert.Equal("^.*/\\*.*\\*\\*[^/]*$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/*ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/ab/cd**efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd*efg*"));
+        Assert.False(matcher.IsMatch("/*ab/cd**ef/gh"));
+    }
+
+    [Fact]
+    public void LiteralQuestions()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("\\??\\?*\\??").Value;
+        Assert.Equal("^.*/\\?.\\?[^/]*\\?.$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/?a?cde?f"));
+        Assert.True(matcher.IsMatch("/???????f"));
+        Assert.False(matcher.IsMatch("/aaaaaaaa"));
+        Assert.False(matcher.IsMatch("/aa?cde?f"));
+        Assert.False(matcher.IsMatch("/?a?cdexf"));
+        Assert.False(matcher.IsMatch("/?axcde?f"));
+    }
+
+    [Fact]
+    public void LiteralBraces()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\{\\}def").Value;
+        Assert.Equal(@"^.*/abc\{}def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc{}def"));
+        Assert.True(matcher.IsMatch("/subdir/abc{}def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc}{def"));
+    }
+
+    [Fact]
+    public void LiteralComma()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("abc\\,def").Value;
+        Assert.Equal("^.*/abc,def$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc,def"));
+        Assert.True(matcher.IsMatch("/subdir/abc,def"));
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/abc\\,def"));
+        Assert.False(matcher.IsMatch("/abc`def"));
+    }
+
+    [Fact]
+    public void SimpleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("*.{cs,vb,fs}").Value;
+        Assert.Equal("^.*/[^/]*\\.(?:cs|vb|fs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.vb"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.cs"));
+        Assert.True(matcher.IsMatch("/subdir/abc.vb"));
+        Assert.True(matcher.IsMatch("/subdir/abc.fs"));
+
+        Assert.False(matcher.IsMatch("/abcxcs"));
+        Assert.False(matcher.IsMatch("/abcxvb"));
+        Assert.False(matcher.IsMatch("/abcxfs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcb"));
+        Assert.False(matcher.IsMatch("/subdir/abcxcs"));
+    }
+
+    [Fact]
+    public void OneChoiceHasSlashes()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs,subdir/test.vb}").Value;
+        // This is an interesting case that may be counterintuitive.  A reasonable understanding
+        // of the section matching could interpret the choice as generating multiple identical
+        // sections, so [{a, b, c}] would be equivalent to [a] ... [b] ... [c] with all of the
+        // same properties in each section. This is somewhat true, but the rules of how the matching
+        // prefixes are constructed violate this assumption because they are defined as whether or
+        // not a section contains a slash, not whether any of the choices contain a slash. So while
+        // [*.cs] usually translates into '**/*.cs' because it contains no slashes, the slashes in
+        // the second choice make this into '/*.cs', effectively matching only files in the root
+        // directory of the match, instead of all subdirectories.
+        Assert.Equal("^/(?:[^/]*\\.cs|subdir/test\\.vb)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+
+        Assert.False(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("/subdir/subdir/test.vb"));
+        Assert.False(matcher.IsMatch("/test.vb"));
+    }
+
+    [Fact]
+    public void EmptyChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{}").Value;
+        Assert.Equal("^.*/(?:)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/"));
+        Assert.True(matcher.IsMatch("/subdir/"));
+        Assert.False(matcher.IsMatch("/."));
+        Assert.False(matcher.IsMatch("/anything"));
+    }
+
+    [Fact]
+    public void SingleChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{*.cs}").Value;
+        Assert.Equal("^.*/(?:[^/]*\\.cs)$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.False(matcher.IsMatch("test.vb"));
+        Assert.False(matcher.IsMatch("testxcs"));
+    }
+
+    [Fact]
+    public void UnmatchedBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("{{{{}}");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CommaOutsideBraces()
+    {
+        SectionNameMatcher? matcher = TryCreateSectionNameMatcher("abc,def");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void RecursiveChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("{test{.cs,.vb},other.{a{bb,cc}}}").Value;
+        Assert.Equal("^.*/(?:test(?:\\.cs|\\.vb)|other\\.(?:a(?:bb|cc)))$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/test.cs"));
+        Assert.True(matcher.IsMatch("/test.vb"));
+        Assert.True(matcher.IsMatch("/subdir/test.cs"));
+        Assert.True(matcher.IsMatch("/subdir/test.vb"));
+        Assert.True(matcher.IsMatch("/other.abb"));
+        Assert.True(matcher.IsMatch("/other.acc"));
+
+        Assert.False(matcher.IsMatch("/test.fs"));
+        Assert.False(matcher.IsMatch("/other.bbb"));
+        Assert.False(matcher.IsMatch("/other.ccc"));
+        Assert.False(matcher.IsMatch("/subdir/other.bbb"));
+        Assert.False(matcher.IsMatch("/subdir/other.ccc"));
+    }
+
+    [Fact]
+    public void DashChoice()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{-}cd{-,}ef").Value;
+        Assert.Equal("^.*/ab(?:-)cd(?:-|)ef$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ab-cd-ef"));
+        Assert.True(matcher.IsMatch("/ab-cdef"));
+
+        Assert.False(matcher.IsMatch("/abcdef"));
+        Assert.False(matcher.IsMatch("/ab--cd-ef"));
+        Assert.False(matcher.IsMatch("/ab--cd--ef"));
+    }
+
+    [Fact]
+    public void MiddleMatch()
+    {
+        SectionNameMatcher matcher = TryCreateSectionNameMatcher("ab{cs,vb,fs}cd").Value;
+        Assert.Equal("^.*/ab(?:cs|vb|fs)cd$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abcscd"));
+        Assert.True(matcher.IsMatch("/abvbcd"));
+        Assert.True(matcher.IsMatch("/abfscd"));
+
+        Assert.False(matcher.IsMatch("/abcs"));
+        Assert.False(matcher.IsMatch("/abcd"));
+        Assert.False(matcher.IsMatch("/vbcd"));
+    }
+
+    private static IEnumerable<(string, string)> RangeAndInverse(string s1, string s2)
+    {
+        yield return (s1, s2);
+        yield return (s2, s1);
+    }
+
+    [Fact]
+    public void NumberMatch()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("0", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/000005"));
+            Assert.False(matcher.IsMatch("/-1"));
+            Assert.False(matcher.IsMatch("/-00000001"));
+            Assert.False(matcher.IsMatch("/11"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegativeRange()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "0"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.False(matcher.IsMatch("/1"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void NumberMatchNegToPos()
+    {
+        foreach (var (i1, i2) in RangeAndInverse("-10", "10"))
+        {
+            var matcher = TryCreateSectionNameMatcher($"{{{i1}..{i2}}}").Value;
+
+            Assert.True(matcher.IsMatch("/0"));
+            Assert.True(matcher.IsMatch("/-5"));
+            Assert.True(matcher.IsMatch("/5"));
+            Assert.True(matcher.IsMatch("/-10"));
+            Assert.True(matcher.IsMatch("/10"));
+            Assert.False(matcher.IsMatch("/-11"));
+            Assert.False(matcher.IsMatch("/11"));
+            Assert.False(matcher.IsMatch("/--0"));
+        }
+    }
+
+    [Fact]
+    public void MultipleNumberRanges()
+    {
+        foreach (var matchString in new[] { "a{-10..0}b{0..10}", "a{0..-10}b{10..0}" })
+        {
+            var matcher = TryCreateSectionNameMatcher(matchString).Value;
+
+            Assert.True(matcher.IsMatch("/a0b0"));
+            Assert.True(matcher.IsMatch("/a-5b0"));
+            Assert.True(matcher.IsMatch("/a-5b5"));
+            Assert.True(matcher.IsMatch("/a-5b10"));
+            Assert.True(matcher.IsMatch("/a-10b10"));
+            Assert.True(matcher.IsMatch("/a-10b0"));
+            Assert.True(matcher.IsMatch("/a-0b0"));
+            Assert.True(matcher.IsMatch("/a-0b-0"));
+
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-11b10"));
+            Assert.False(matcher.IsMatch("/a-10b11"));
+        }
+    }
+
+    [Fact]
+    public void BadNumberRanges()
+    {
+        var matcherOpt = TryCreateSectionNameMatcher("{0..");
+
+        Assert.Null(matcherOpt);
+
+        var matcher = TryCreateSectionNameMatcher("{0..}").Value;
+
+        Assert.True(matcher.IsMatch("/0.."));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0."));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        matcher = TryCreateSectionNameMatcher("{0..A}").Value;
+        Assert.True(matcher.IsMatch("/0..A"));
+        Assert.False(matcher.IsMatch("/0"));
+        Assert.False(matcher.IsMatch("/0abc"));
+
+        // The reference implementation uses atoi here so we can presume
+        // numbers out of range of Int32 are not well supported
+        matcherOpt = TryCreateSectionNameMatcher($"{{0..{UInt32.MaxValue}}}");
+
+        Assert.Null(matcherOpt);
+    }
+
+    [Fact]
+    public void CharacterClassSimple()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+    }
+
+    [Fact]
+    public void CharacterClassNegative()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[!cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[^cf]s$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/abc.cs"));
+        Assert.False(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.vs"));
+        Assert.True(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassCaret()
+    {
+        var matcher = TryCreateSectionNameMatcher("*.[^cf]s").Value;
+        Assert.Equal(@"^.*/[^/]*\.[\^cf]s$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/abc.cs"));
+        Assert.True(matcher.IsMatch("/abc.fs"));
+        Assert.True(matcher.IsMatch("/abc.^s"));
+        Assert.False(matcher.IsMatch("/abc.vs"));
+        Assert.False(matcher.IsMatch("/abc.xs"));
+        Assert.False(matcher.IsMatch("/abc.vxs"));
+    }
+
+    [Fact]
+    public void CharacterClassRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[0-9]x").Value;
+        Assert.Equal("^.*/[0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassNegativeRange()
+    {
+        var matcher = TryCreateSectionNameMatcher("[!0-9]x").Value;
+        Assert.Equal("^.*/[^0-9]x$", matcher.Regex.ToString());
+
+        Assert.False(matcher.IsMatch("/0x"));
+        Assert.False(matcher.IsMatch("/1x"));
+        Assert.False(matcher.IsMatch("/9x"));
+        Assert.True(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/00x"));
+    }
+
+    [Fact]
+    public void CharacterClassRangeAndChoice()
+    {
+        var matcher = TryCreateSectionNameMatcher("[ab0-9]x").Value;
+        Assert.Equal("^.*/[ab0-9]x$", matcher.Regex.ToString());
+
+        Assert.True(matcher.IsMatch("/ax"));
+        Assert.True(matcher.IsMatch("/bx"));
+        Assert.True(matcher.IsMatch("/0x"));
+        Assert.True(matcher.IsMatch("/1x"));
+        Assert.True(matcher.IsMatch("/9x"));
+        Assert.False(matcher.IsMatch("/yx"));
+        Assert.False(matcher.IsMatch("/0ax"));
+    }
+
+    [Fact]
+    public void CharacterClassOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher("[");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapedOpenEnded()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\]");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassEscapeAtEnd()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[\");
+        Assert.Null(matcher);
+    }
+
+    [Fact]
+    public void CharacterClassOpenBracketInside()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[[a]bc").Value;
+
+        Assert.True(matcher.IsMatch("/abc"));
+        Assert.True(matcher.IsMatch("/[bc"));
+        Assert.False(matcher.IsMatch("/ab"));
+        Assert.False(matcher.IsMatch("/[b"));
+        Assert.False(matcher.IsMatch("/bc"));
+        Assert.False(matcher.IsMatch("/ac"));
+        Assert.False(matcher.IsMatch("/[c"));
+
+        Assert.Equal(@"^.*/[\[a]bc$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassStartingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[-ac]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[-ac]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndingDash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ac-]bd").Value;
+
+        Assert.True(matcher.IsMatch("/abd"));
+        Assert.True(matcher.IsMatch("/cbd"));
+        Assert.True(matcher.IsMatch("/-bd"));
+        Assert.False(matcher.IsMatch("/bbd"));
+        Assert.False(matcher.IsMatch("/-cd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+
+        Assert.Equal(@"^.*/[ac-]bd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEndBracketAfter()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab]]cd").Value;
+
+        Assert.True(matcher.IsMatch("/a]cd"));
+        Assert.True(matcher.IsMatch("/b]cd"));
+        Assert.False(matcher.IsMatch("/acd"));
+        Assert.False(matcher.IsMatch("/bcd"));
+        Assert.False(matcher.IsMatch("/acd"));
+
+        Assert.Equal(@"^.*/[ab]]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void CharacterClassEscapeBackslash()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"[ab\\]cd").Value;
+
+        Assert.True(matcher.IsMatch("/acd"));
+        Assert.True(matcher.IsMatch("/bcd"));
+        Assert.True(matcher.IsMatch("/\\cd"));
+        Assert.False(matcher.IsMatch("/dcd"));
+        Assert.False(matcher.IsMatch("/\\\\cd"));
+        Assert.False(matcher.IsMatch("/cd"));
+
+        Assert.Equal(@"^.*/[ab\\]cd$", matcher.Regex.ToString());
+    }
+
+    [Fact]
+    public void EscapeOpenBracket()
+    {
+        var matcher = TryCreateSectionNameMatcher(@"ab\[cd").Value;
+
+        Assert.True(matcher.IsMatch("/ab[cd"));
+        Assert.False(matcher.IsMatch("/ab[[cd"));
+        Assert.False(matcher.IsMatch("/abc"));
+        Assert.False(matcher.IsMatch("/abd"));
+
+        Assert.Equal(@"^.*/ab\[cd$", matcher.Regex.ToString());
+    }
+    #endregion
+
+    #region Parsing Tests
+
+    private static void SetEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null, string message = null)
+    {
+        var expectedSet = new HashSet<T>(expected, comparer);
+        var result = expected.Count() == actual.Count() && expectedSet.SetEquals(actual);
+        Assert.True(result, message);
+    }
+
+    private static void Equal<T>(
+        IEnumerable<T> expected,
+        IEnumerable<T> actual,
+        IEqualityComparer<T> comparer = null,
+        string message = null)
+    {
+        if (expected == null)
+        {
+            Assert.Null(actual);
+        }
+        else
+        {
+            Assert.NotNull(actual);
+        }
+
+        if (SequenceEqual(expected, actual, comparer))
+        {
+            return;
+        }
+
+        Assert.True(false, message);
+    }
+
+    private static bool SequenceEqual<T>(IEnumerable<T> expected, IEnumerable<T> actual, IEqualityComparer<T> comparer = null)
+    {
+        if (ReferenceEquals(expected, actual))
+        {
+            return true;
+        }
+
+        var enumerator1 = expected.GetEnumerator();
+        var enumerator2 = actual.GetEnumerator();
+
+        while (true)
+        {
+            var hasNext1 = enumerator1.MoveNext();
+            var hasNext2 = enumerator2.MoveNext();
+
+            if (hasNext1 != hasNext2)
+            {
+                return false;
+            }
+
+            if (!hasNext1)
+            {
+                break;
+            }
+
+            var value1 = enumerator1.Current;
+            var value2 = enumerator2.Current;
+
+            if (!(comparer != null ? comparer.Equals(value1, value2) : AssertEqualityComparer<T>.Equals(value1, value2)))
+            {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public static KeyValuePair<K, V> Create<K, V>(K key, V value)
+    {
+        return new KeyValuePair<K, V>(key, value);
+    }
+
+    [Fact]
+    public void SimpleCase()
+    {
+        var config = EditorConfigFile.Parse("""
+root = true
+
+# Comment1
+# Comment2
+##################################
+
+my_global_prop = my_global_val
+
+[*.cs]
+my_prop = my_val
+""");
+        Assert.Equal("", config.GlobalSection.Name);
+        var properties = config.GlobalSection.Properties;
+
+        SetEqual(
+            new[] { Create("my_global_prop", "my_global_val") ,
+                    Create("root", "true") },
+            properties);
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("*.cs", namedSections[0].Name);
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            namedSections[0].Properties);
+        
+        Assert.True(config.IsRoot);
+    }
+
+    
+    [Fact]
+    // [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void ConfigWithEscapedValues()
+    {
+        var config = EditorConfigFile.Parse(@"is_global = true
+
+[c:/\{f\*i\?le1\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[c:/f\,ile\#2.cs]
+build_metadata.Compile.ToRetrieve = def456
+
+[c:/f\;i\!le\[3\].cs]
+build_metadata.Compile.ToRetrieve = ghi789
+");
+
+        var namedSections = config.NamedSections;
+        Assert.Equal("c:/\\{f\\*i\\?le1\\}.cs", namedSections[0].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "abc123") },
+            namedSections[0].Properties);
+
+        Assert.Equal("c:/f\\,ile\\#2.cs", namedSections[1].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "def456") },
+            namedSections[1].Properties);
+
+        Assert.Equal("c:/f\\;i\\!le\\[3\\].cs", namedSections[2].Name);
+        Equal(
+            new[] { Create("build_metadata.compile.toretrieve", "ghi789") },
+            namedSections[2].Properties);
+    }
+
+    /*
+    [Fact]
+    [WorkItem(52469, "https://github.com/dotnet/roslyn/issues/52469")]
+    public void CanGetSectionsWithSpecialCharacters()
+    {
+        var config = ParseConfigFile(@"is_global = true
+
+[/home/foo/src/\{releaseid\}.cs]
+build_metadata.Compile.ToRetrieve = abc123
+
+[/home/foo/src/Pages/\#foo/HomePage.cs]
+build_metadata.Compile.ToRetrieve = def456
+");
+
+        var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
+
+        var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
+        Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+
+        sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
+        Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+    }*/
+
+    [Fact]
+    public void MissingClosingBracket()
+    {
+        var config = EditorConfigFile.Parse(@"
+[*.cs
+my_prop = my_val");
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val") },
+            properties);
+
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void EmptySection()
+    {
+        var config = EditorConfigFile.Parse(@"
+[]
+my_prop = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_val") }, properties);
+        Assert.Equal(0, config.NamedSections.Length);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitivePropKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_PROP = my_VAL");
+        var properties = config.GlobalSection.Properties;
+
+        Assert.True(properties.TryGetValue("my_PrOp", out var val));
+        Assert.Equal("my_VAL", val);
+        Assert.Equal("my_prop", properties.Keys.Single());
+    }
+
+    // there is no reversed keys support for msbuild
+    /*[Fact]
+    public void NonReservedKeyPreservedCaseVal()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
+            config.GlobalSection.Properties);
+    }*/
+
+
+    [Fact]
+    public void DuplicateKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_prop = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void DuplicateKeysCasing()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop = my_val
+my_PROP = my_other_val");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(new[] { Create("my_prop", "my_other_val") }, properties);
+    }
+
+    
+    [Fact]
+    public void MissingKey()
+    {
+        var config = EditorConfigFile.Parse(@"
+= my_val1
+my_prop = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop", "my_val2") },
+            properties);
+    }
+
+    
+
+    [Fact]
+    public void MissingVal()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop1 =
+my_prop2 = my_val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop1", ""),
+                    Create("my_prop2", "my_val") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void SpacesInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my prop1 = my_val1
+my_prop2 = my val2");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void EndOfLineComments()
+    {
+        var config = EditorConfigFile.Parse(@"
+my_prop2 = my val2 # Comment");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_prop2", "my val2") },
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsStartKeys()
+    {
+        var config = EditorConfigFile.Parse(@"
+@!$abc = my_val1
+@!$\# = my_val2");
+
+        var properties = config.GlobalSection.Properties;
+        Assert.Equal(0, properties.Count);
+    }
+
+    
+    [Fact]
+    public void EqualsAndColon()
+    {
+        var config = EditorConfigFile.Parse(@"
+my:key1 = my_val
+my_key2 = my:val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my", "key1 = my_val"),
+                    Create("my_key2", "my:val")},
+            properties);
+    }
+    
+    [Fact]
+    public void SymbolsInProperties()
+    {
+        var config = EditorConfigFile.Parse(@"
+my@key1 = my_val
+my_key2 = my@val");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("my_key2", "my@val") },
+            properties);
+    }
+    
+    [Fact]
+    public void LongLines()
+    {
+        // This example is described in the Python ConfigParser as allowing
+        // line continuation via the RFC 822 specification, section 3.1.1
+        // LONG HEADER FIELDS. The VS parser does not accept this as a
+        // valid parse for an editorconfig file. We follow similarly.
+        var config = EditorConfigFile.Parse(@"
+long: this value continues
+   in the next line");
+
+        var properties = config.GlobalSection.Properties;
+        SetEqual(
+            new[] { Create("long", "this value continues") },
+            properties);
+    }
+
+    
+    [Fact]
+    public void CaseInsensitiveRoot()
+    {
+        var config = EditorConfigFile.Parse(@"
+RoOt = TruE");
+        Assert.True(config.IsRoot);
+    }
+
+
+    /*
+    Reserved values are not supported at the moment
+    [Fact]
+    public void ReservedValues()
+    {
+        int index = 0;
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
+        index = 0;
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+
+    /*
+    [Fact]
+    public void ReservedKeys()
+    {
+        var config = ParseConfigFile(string.Join(Environment.NewLine,
+            AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
+        AssertEx.SetEqual(
+            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
+            config.GlobalSection.Properties);
+    }
+    */
+    #endregion
+}
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 17c1d1764d9..a54a3a0e0f8 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -63,7 +63,6 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
 
         string contents2 = $"""
             <Project Sdk="Microsoft.NET.Sdk">
-                               
                 <PropertyGroup>
                 <OutputType>Exe</OutputType>
                 <TargetFramework>net8.0</TargetFramework>
@@ -89,27 +88,20 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool ana
         TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
         TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
 
-        // var cache = new SimpleProjectRootElementCache();
-        // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
-
-        TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
-            /*lang=json,strict*/
+        TransientTestFile config = _env.CreateFile(workFolder, ".editorconfig",
             """
-            {
-                "BC0101": {
-                    "IsEnabled": true,
-                    "Severity": "Error"
-                },
-                "COND0543": {
-                    "IsEnabled": false,
-                    "Severity": "Error",
-                    "EvaluationAnalysisScope": "AnalyzedProjectOnly",
-                    "CustomSwitch": "QWERTY"
-                },
-                "BLA": {
-                    "IsEnabled": false
-                }
-            }
+            root=true
+
+            [*.csproj]
+            build_check.BC0101.IsEnabled=true
+            build_check.BC0101.Severity=warning
+
+            build_check.COND0543.IsEnabled=false
+            build_check.COND0543.Severity=Error
+            build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+            build_check.COND0543.CustomSwitch=QWERTY
+
+            build_check.BLA.IsEnabled=false
             """);
 
         // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
index 05d1266d2ac..7734c19f311 100644
--- a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -1,12 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.UnitTests;
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 3a67481a23e..0eacfd24c73 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -1458,7 +1458,7 @@ internal static string GetDirectoryNameOfFileAbove(string startingDirectory, str
             while (lookInDirectory != null);
 
             // When we didn't find the location, then return an empty string
-            return String.Empty;
+            return string.Empty;
         }
 
         /// <summary>
