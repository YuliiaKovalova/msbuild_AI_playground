diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index ed79f9d09d6..94718bf0c8f 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -1128,8 +1128,8 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
             // to the entry rather than a series of them.
             lock (issuingEntry.GlobalLock)
             {
-                var existingResultsToReport = new List<BuildResult>();
-                var unresolvedConfigurationsAdded = new HashSet<int>();
+                List<BuildResult> existingResultsToReport = null;
+                HashSet<int> unresolvedConfigurationsAdded = new HashSet<int>();
 
                 foreach (FullyQualifiedBuildRequest request in newRequests)
                 {
@@ -1232,6 +1232,7 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
 
                             // Can't report the result directly here, because that could cause the request to go from
                             // Waiting to Ready.
+                            existingResultsToReport ??= new List<BuildResult>();
                             existingResultsToReport.Add(response.Results);
                         }
                         else
@@ -1243,9 +1244,12 @@ private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBu
                 }
 
                 // If we have any results we had to report, do so now.
-                foreach (BuildResult existingResult in existingResultsToReport)
+                if (existingResultsToReport is not null)
                 {
-                    issuingEntry.ReportResult(existingResult);
+                    foreach (BuildResult existingResult in existingResultsToReport)
+                    {
+                        issuingEntry.ReportResult(existingResult);
+                    }
                 }
 
                 // Issue any configuration requests we may still need.
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index e34dd90c5b1..65304fb66d2 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -178,7 +178,7 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
                     if (buildDataFlagsSatisfied)
                     {
                         // Check for targets explicitly specified.
-                        bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, response.ExplicitTargetsToBuild, skippedResultsDoNotCauseCacheMiss);
+                        bool explicitTargetsSatisfied = CheckResults(allResults, request.Targets, checkTargetsMissingResults: true, skippedResultsDoNotCauseCacheMiss);
 
                         if (explicitTargetsSatisfied)
                         {
@@ -186,7 +186,7 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
                             response.Type = ResultsCacheResponseType.Satisfied;
 
                             // Check for the initial targets.  If we don't know what the initial targets are, we assume they are not satisfied.
-                            if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, null, skippedResultsDoNotCauseCacheMiss))
+                            if (configInitialTargets == null || !CheckResults(allResults, configInitialTargets, checkTargetsMissingResults: false, skippedResultsDoNotCauseCacheMiss))
                             {
                                 response.Type = ResultsCacheResponseType.NotSatisfied;
                             }
@@ -196,7 +196,7 @@ public ResultsCacheResponse SatisfyRequest(BuildRequest request, List<string> co
                             {
                                 // Check for the default target, if necessary.  If we don't know what the default targets are, we
                                 // assume they are not satisfied.
-                                if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, null, skippedResultsDoNotCauseCacheMiss))
+                                if (configDefaultTargets == null || !CheckResults(allResults, configDefaultTargets, checkTargetsMissingResults: false, skippedResultsDoNotCauseCacheMiss))
                                 {
                                     response.Type = ResultsCacheResponseType.NotSatisfied;
                                 }
@@ -308,20 +308,21 @@ internal static IBuildComponent CreateComponent(BuildComponentType componentType
         /// </summary>
         /// <param name="result">The result to examine</param>
         /// <param name="targets">The targets to search for</param>
-        /// <param name="targetsMissingResults">An optional list to be populated with missing targets</param>
+        /// <param name="checkTargetsMissingResults">If missing targets will be checked for.</param>
         /// <param name="skippedResultsAreOK">If true, a status of "skipped" counts as having valid results
         /// for that target.  Otherwise, a skipped target is treated as equivalent to a missing target.</param>
         /// <returns>False if there were missing results, true otherwise.</returns>
-        private static bool CheckResults(BuildResult result, List<string> targets, HashSet<string> targetsMissingResults, bool skippedResultsAreOK)
+        private static bool CheckResults(BuildResult result, List<string> targets, bool checkTargetsMissingResults, bool skippedResultsAreOK)
         {
             bool returnValue = true;
+            bool missingTargetFound = false;
             foreach (string target in targets)
             {
                 if (!result.HasResultsForTarget(target) || (result[target].ResultCode == TargetResultCode.Skipped && !skippedResultsAreOK))
                 {
-                    if (targetsMissingResults != null)
+                    if (checkTargetsMissingResults)
                     {
-                        targetsMissingResults.Add(target);
+                        missingTargetFound = true;
                         returnValue = false;
                     }
                     else
@@ -333,7 +334,7 @@ private static bool CheckResults(BuildResult result, List<string> targets, HashS
                 {
                     // If the result was a failure and we have not seen any skipped targets up to this point, then we conclude we do
                     // have results for this request, and they indicate failure.
-                    if (result[target].ResultCode == TargetResultCode.Failure && (targetsMissingResults == null || targetsMissingResults.Count == 0))
+                    if (result[target].ResultCode == TargetResultCode.Failure && (!checkTargetsMissingResults || !missingTargetFound))
                     {
                         return true;
                     }
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs b/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
index 0b9971a8b99..03e123f9141 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
@@ -41,11 +41,6 @@ internal struct ResultsCacheResponse
         /// </summary>
         public BuildResult Results;
 
-        /// <summary>
-        /// The subset of explicit targets which must be built because there are no results for them in the cache.
-        /// </summary>
-        public HashSet<string> ExplicitTargetsToBuild;
-
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -54,7 +49,6 @@ public ResultsCacheResponse(ResultsCacheResponseType type)
         {
             Type = type;
             Results = null;
-            ExplicitTargetsToBuild = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index 40b58682006..8962679602e 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -259,7 +259,7 @@ private static Dictionary<string, ICollection<ProjectItemInstance>> GetItemLists
                             if (items != null)
                             {
                                 // Loop through all the items in the BuildItemGroup.
-                                foreach (ProjectItemInstance item in items)
+                                foreach (ProjectItemInstance item in items.GetStructEnumerable())
                                 {
                                     ProjectErrorUtilities.VerifyThrowInvalidProject(
                                         item.HasMetadata(consumedMetadataReference.MetadataName),
@@ -319,7 +319,7 @@ private static List<ItemBucket> BucketConsumedItems(
 
                 if (items != null)
                 {
-                    foreach (ProjectItemInstance item in items)
+                    foreach (ProjectItemInstance item in items.GetStructEnumerable())
                     {
                         // Get this item's values for all the metadata consumed by the batchable object.
                         Dictionary<string, string> itemMetadataValues = GetItemMetadataValues(item, consumedMetadataReferences, elementLocation);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 2a9cc0e26b0..a48a5cd5c7b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -479,10 +479,12 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             {
                 foreach (var item in items)
                 {
-                    var metadataToRemove = item.MetadataNames.Where(name => !keepMetadata.Contains(name));
-                    foreach (var metadataName in metadataToRemove)
+                    foreach (var metadataName in item.MetadataNames)
                     {
-                        item.RemoveMetadata(metadataName);
+                        if (!keepMetadata.Contains(metadataName))
+                        {
+                            item.RemoveMetadata(metadataName);
+                        }
                     }
                 }
             }
@@ -490,10 +492,12 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
             {
                 foreach (var item in items)
                 {
-                    var metadataToRemove = item.MetadataNames.Where(name => removeMetadata.Contains(name));
-                    foreach (var metadataName in metadataToRemove)
+                    foreach (var metadataName in item.MetadataNames)
                     {
-                        item.RemoveMetadata(metadataName);
+                        if (removeMetadata.Contains(metadataName))
+                        {
+                            item.RemoveMetadata(metadataName);
+                        }
                     }
                 }
             }
@@ -510,7 +514,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems(
         /// <returns>A list of matching items</returns>
         private HashSet<string> EvaluateExcludePaths(IReadOnlyList<string> excludes, ElementLocation excludeLocation)
         {
-            HashSet<string> excludesUnescapedForComparison = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+            HashSet<string> excludesUnescapedForComparison = new HashSet<string>(excludes.Count, StringComparer.OrdinalIgnoreCase);
             foreach (string excludeSplit in excludes)
             {
                 string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(
@@ -588,7 +592,7 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification(
             // filename in the remove list.
             List<ProjectItemInstance> itemsRemoved = new List<ProjectItemInstance>();
 
-            foreach (ProjectItemInstance item in items)
+            foreach (ProjectItemInstance item in items.GetStructEnumerable())
             {
                 // Even if the case for the excluded files is different, they
                 // will still get excluded, as expected.  However, if the excluded path
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index e0bcc5eff38..484dcb00639 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -480,8 +480,14 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> adds = scope.Adds[itemType];
                     if (adds.Count != 0)
                     {
-                        allAdds ??= new List<ProjectItemInstance>(adds.Count);
-                        allAdds.AddRange(adds);
+                        if (allAdds == null)
+                        {
+                            allAdds = new List<ProjectItemInstance>(adds);
+                        }
+                        else
+                        {
+                            allAdds.AddRange(adds);
+                        }
                     }
                 }
 
@@ -491,8 +497,14 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> removes = scope.Removes[itemType];
                     if (removes.Count != 0)
                     {
-                        allRemoves ??= new List<ProjectItemInstance>(removes.Count);
-                        allRemoves.AddRange(removes);
+                        if (allRemoves == null)
+                        {
+                            allRemoves = new List<ProjectItemInstance>(removes);
+                        }
+                        else
+                        {
+                            allRemoves.AddRange(removes);
+                        }
                     }
                 }
 
@@ -696,7 +708,7 @@ internal void AddNewItem(ProjectItemInstance item)
         /// </summary>
         internal void RemoveItems(IEnumerable<ProjectItemInstance> items)
         {
-            foreach (ProjectItemInstance item in items)
+            foreach (ProjectItemInstance item in items.GetStructEnumerable())
             {
                 RemoveItem(item);
             }
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 4bffd2f0cf4..0521017cb0c 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -699,7 +699,7 @@ private void ScheduleUnassignedRequests(List<ScheduleResponse> responses)
 
             // Resume any work available which has already been assigned to specific nodes.
             ResumeRequiredWork(responses);
-            HashSet<int> idleNodes = new HashSet<int>();
+            HashSet<int> idleNodes = new HashSet<int>(_availableNodes.Count);
             foreach (int availableNodeId in _availableNodes.Keys)
             {
                 if (!_schedulingData.IsNodeWorking(availableNodeId))
@@ -992,7 +992,8 @@ private void AssignUnscheduledRequestsToInProcNode(List<ScheduleResponse> respon
         {
             if (idleNodes.Contains(InProcNodeId))
             {
-                List<SchedulableRequest> unscheduledRequests = new List<SchedulableRequest>(_schedulingData.UnscheduledRequestsWhichCanBeScheduled);
+                List<SchedulableRequest> unscheduledRequests = new List<SchedulableRequest>(_schedulingData.UnscheduledRequestsCount);
+                unscheduledRequests.AddRange(_schedulingData.UnscheduledRequestsWhichCanBeScheduled);
                 foreach (SchedulableRequest request in unscheduledRequests)
                 {
                     if (CanScheduleRequestToNode(request, InProcNodeId) && shouldBeScheduled(request))
@@ -1250,7 +1251,7 @@ private void AssignUnscheduledRequestsWithMaxWaitingRequests2(List<ScheduleRespo
         private void AssignUnscheduledRequestsFIFO(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
             // Assign requests on a first-come/first-serve basis
-            foreach (int nodeId in idleNodes)
+            foreach (SchedulableRequest unscheduledRequest in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)
             {
                 // Don't overload the system.
                 if (AtSchedulingLimit())
@@ -1259,7 +1260,7 @@ private void AssignUnscheduledRequestsFIFO(List<ScheduleResponse> responses, Has
                     return;
                 }
 
-                foreach (SchedulableRequest unscheduledRequest in _schedulingData.UnscheduledRequestsWhichCanBeScheduled)
+                foreach (int nodeId in idleNodes)
                 {
                     if (CanScheduleRequestToNode(unscheduledRequest, nodeId))
                     {
@@ -1972,21 +1973,13 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
                 bool logComment = ((isolateProjects == ProjectIsolationMode.True || isolateProjects == ProjectIsolationMode.MessageUponIsolationViolation) && request.SkipStaticGraphIsolationConstraints);
                 if (logComment)
                 {
-                    // retrieving the configs is not quite free, so avoid computing them eagerly
-                    var configs = GetConfigurations();
-
-                    emitNonErrorLogs = ls => ls.LogComment(
-                            NewBuildEventContext(),
-                            MessageImportance.Normal,
-                            "SkippedConstraintsOnRequest",
-                            configs.ParentConfig.ProjectFullPath,
-                            configs.RequestConfig.ProjectFullPath);
+                    emitNonErrorLogs = GetLoggingServiceAction(configCache, request, _schedulingData);
                 }
 
                 return true;
             }
 
-            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) = GetConfigurations();
+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) = GetConfigurations(configCache, request, _schedulingData);
 
             // allow self references (project calling the msbuild task on itself, potentially with different global properties)
             if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))
@@ -2014,7 +2007,7 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
 
             return false;
 
-            BuildEventContext NewBuildEventContext()
+            static BuildEventContext NewBuildEventContext(BuildRequest request)
             {
                 return new BuildEventContext(
                     request.SubmissionId,
@@ -2025,13 +2018,33 @@ BuildEventContext NewBuildEventContext()
                     BuildEventContext.InvalidTaskId);
             }
 
-            (BuildRequestConfiguration RequestConfig, BuildRequestConfiguration ParentConfig) GetConfigurations()
+            static (BuildRequestConfiguration RequestConfig, BuildRequestConfiguration ParentConfig) GetConfigurations(IConfigCache configCache, BuildRequest request, SchedulingData schedulingData)
             {
                 BuildRequestConfiguration buildRequestConfiguration = configCache[request.ConfigurationId];
 
                 // Need the parent request. It might be blocked or executing; check both.
-                SchedulableRequest parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)
-                    ?? _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);
+                SchedulableRequest parentRequest = null;
+
+                foreach (var r in schedulingData.BlockedRequests)
+                {
+                    if (r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)
+                    {
+                        parentRequest = r;
+                        break;
+                    }
+                }
+
+                if (parentRequest is null)
+                {
+                    foreach (var r in schedulingData.ExecutingRequests)
+                    {
+                        if (r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)
+                        {
+                            parentRequest = r;
+                            break;
+                        }
+                    }
+                }
 
                 ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));
                 ErrorUtilities.VerifyThrow(
@@ -2044,7 +2057,7 @@ BuildEventContext NewBuildEventContext()
 
             string ConcatenateGlobalProperties(BuildRequestConfiguration configuration)
             {
-                return string.Join("; ", configuration.GlobalProperties.Select<ProjectPropertyInstance, string>(p => $"{p.Name}={p.EvaluatedValue}"));
+                return string.Join("; ", configuration.GlobalProperties.Select<ProjectPropertyInstance, string>(static p => $"{p.Name}={p.EvaluatedValue}"));
             }
 
             bool SkipNonexistentTargetsIfExistentTargetsHaveResults(BuildRequest buildRequest)
@@ -2080,6 +2093,20 @@ bool SkipNonexistentTargetsIfExistentTargetsHaveResults(BuildRequest buildReques
                 // to skip nonexistent targets.
                 return true;
             }
+            static Action<ILoggingService> GetLoggingServiceAction(IConfigCache configCache, BuildRequest request, SchedulingData schedulingData)
+            {
+                Action<ILoggingService> emitNonErrorLogs;
+                // retrieving the configs is not quite free, so avoid computing them eagerly
+                var configs = GetConfigurations(configCache, request, schedulingData);
+
+                emitNonErrorLogs = ls => ls.LogComment(
+                        NewBuildEventContext(request),
+                        MessageImportance.Normal,
+                        "SkippedConstraintsOnRequest",
+                        configs.ParentConfig.ProjectFullPath,
+                        configs.RequestConfig.ProjectFullPath);
+                return emitNonErrorLogs;
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 252bf62ab14..43f4bd3d282 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -53,7 +53,7 @@ internal class SdkResolverService : ISdkResolverService
         /// <summary>
         /// Stores the list of manifests of general SDK resolvers which could be loaded.
         /// </summary>
-        private IList<SdkResolverManifest> _generalResolversManifestsRegistry;
+        private List<SdkResolverManifest> _generalResolversManifestsRegistry;
 
         /// <summary>
         /// Stores an <see cref="SdkResolverLoader"/> which can load registered SDK resolvers.
@@ -225,7 +225,7 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
             resolvers = GetResolvers(
                 _generalResolversManifestsRegistry,
                 loggingContext,
-                sdkReferenceLocation).ToList();
+                sdkReferenceLocation);
 
             if (TryResolveSdkUsingSpecifiedResolvers(
                 resolvers,
@@ -258,22 +258,20 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
             return new SdkResult(sdk, null, null);
         }
 
-        private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)
+        private List<SdkResolver> GetResolvers(List<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation)
         {
             // Create a sorted by priority list of resolvers. Load them if needed.
             List<SdkResolver> resolvers = new List<SdkResolver>();
             foreach (var resolverManifest in resolversManifests)
             {
-                if (!_manifestToResolvers.TryGetValue(resolverManifest, out IReadOnlyList<SdkResolver> newResolvers))
+                IReadOnlyList<SdkResolver> newResolvers;
+                lock (_lockObject)
                 {
-                    lock (_lockObject)
+                    if (!_manifestToResolvers.TryGetValue(resolverManifest, out newResolvers))
                     {
-                        if (!_manifestToResolvers.TryGetValue(resolverManifest, out newResolvers))
-                        {
-                            // Loading of the needed resolvers.
-                            newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, sdkReferenceLocation);
-                            _manifestToResolvers[resolverManifest] = newResolvers;
-                        }
+                        // Loading of the needed resolvers.
+                        newResolvers = _sdkResolverLoader.LoadResolversFromManifest(resolverManifest, sdkReferenceLocation);
+                        _manifestToResolvers[resolverManifest] = newResolvers;
                     }
                 }
 
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 3bca761aab7..9fe9b3c8510 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -299,7 +299,11 @@ public bool IsTraversal
             {
                 if (!_isTraversalProject.HasValue)
                 {
-                    if (String.Equals(Path.GetFileName(ProjectFullPath), "dirs.proj", StringComparison.OrdinalIgnoreCase))
+#if NET471_OR_GREATER
+                    if (MemoryExtensions.Equals(Microsoft.IO.Path.GetFileName(ProjectFullPath.AsSpan()), "dirs.proj".AsSpan(), StringComparison.OrdinalIgnoreCase))
+#else
+                    if (MemoryExtensions.Equals(Path.GetFileName(ProjectFullPath.AsSpan()), "dirs.proj", StringComparison.OrdinalIgnoreCase))
+#endif
                     {
                         // dirs.proj are assumed to be traversals
                         _isTraversalProject = true;
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 537998947d3..1333e8b8240 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Framework;
+using System.Diagnostics.CodeAnalysis;
 
 namespace Microsoft.Build.Execution
 {
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 1a2ba345658..6b074c2b918 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -15,6 +15,7 @@
 using System.Threading;
 
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
@@ -1223,15 +1224,18 @@ private void EnsureParameterInitialized(TaskPropertyInfo parameter, Lookup looku
 
             string taskAndParameterName = _taskName + "_" + parameter.Name;
             string key = "DisableLogTaskParameter_" + taskAndParameterName;
-            string metadataKey = "DisableLogTaskParameterItemMetadata_" + taskAndParameterName;
 
             if (string.Equals(lookup.GetProperty(key)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
             {
                 parameter.Log = false;
             }
-            else if (string.Equals(lookup.GetProperty(metadataKey)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
+            else
             {
-                parameter.LogItemMetadata = false;
+                string metadataKey = "DisableLogTaskParameterItemMetadata_" + taskAndParameterName;
+                if (string.Equals(lookup.GetProperty(metadataKey)?.EvaluatedValue, "true", StringComparison.OrdinalIgnoreCase))
+                {
+                    parameter.LogItemMetadata = false;
+                }
             }
         }
 
@@ -1416,9 +1420,26 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
 
                                     static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary customMetadata)
                                     {
-                                        foreach (DictionaryEntry de in customMetadata)
+                                        if (customMetadata is CopyOnWriteDictionary<string> copyOnWriteDictionary)
+                                        {
+                                            foreach (KeyValuePair<string, string> kvp in copyOnWriteDictionary)
+                                            {
+                                                yield return new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.Escape(kvp.Value));
+                                            }
+                                        }
+                                        else if (customMetadata is Dictionary<string, string> dictionary)
+                                        {
+                                            foreach (KeyValuePair<string, string> kvp in dictionary)
+                                            {
+                                                yield return new KeyValuePair<string, string>(kvp.Key, EscapingUtilities.Escape(kvp.Value));
+                                            }
+                                        }
+                                        else
                                         {
-                                            yield return new KeyValuePair<string, string>((string)de.Key, EscapingUtilities.Escape((string)de.Value));
+                                            foreach (DictionaryEntry de in customMetadata)
+                                            {
+                                                yield return new KeyValuePair<string, string>((string)de.Key, EscapingUtilities.Escape((string)de.Value));
+                                            }
                                         }
                                     }
                                 }
diff --git a/src/Build/Collections/CopyOnReadEnumerable.cs b/src/Build/Collections/CopyOnReadEnumerable.cs
index 06956f83617..faa73d3624b 100644
--- a/src/Build/Collections/CopyOnReadEnumerable.cs
+++ b/src/Build/Collections/CopyOnReadEnumerable.cs
@@ -72,6 +72,10 @@ public IEnumerator<TResult> GetEnumerator()
 #endif
                 list = new List<TResult>(count);
             }
+            else if (_backingEnumerable is IReadOnlyCollection<TSource> readOnlyCollection)
+            {
+                list = new List<TResult>(readOnlyCollection.Count);
+            }
             else
             {
                 list = new List<TResult>();
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 44e7fe20555..f1333844174 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -137,12 +137,18 @@ public void Clear()
         /// Gets an enumerator over all the properties in the collection
         /// Enumeration is in undefined order
         /// </summary>
-        public IEnumerator<T> GetEnumerator() => _backing.Values.GetEnumerator();
+        public ImmutableDictionary<string, T>.Enumerator GetEnumerator() => _backing.GetEnumerator();
+
+        /// <summary>
+        /// Gets an enumerator over all the properties in the collection
+        /// Enumeration is in undefined order
+        /// </summary>
+        IEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this);
 
         /// <summary>
         /// Get an enumerator over entries
         /// </summary>
-        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
+        IEnumerator IEnumerable.GetEnumerator() => new Enumerator(this);
 
         #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
 
@@ -347,9 +353,24 @@ public void Set(T projectProperty)
         /// <param name="other">An enumerator over the properties to add.</param>
         public void ImportProperties(IEnumerable<T> other)
         {
-            _backing = _backing.SetItems(Items());
+            if (other is CopyOnWritePropertyDictionary<T> copyOnWriteDictionary)
+            {
+                _backing = _backing.SetItems(DictionaryItems(copyOnWriteDictionary));
+            }
+            else
+            {
+                _backing = _backing.SetItems(Items(other));
+            }
 
-            IEnumerable<KeyValuePair<string, T>> Items()
+            static IEnumerable<KeyValuePair<string, T>> DictionaryItems(CopyOnWritePropertyDictionary<T> copyOnWriteDictionary)
+            {
+                foreach (KeyValuePair<string, T> kvp in copyOnWriteDictionary)
+                {
+                    yield return new(kvp.Value.Key, kvp.Value);
+                }
+            }
+
+            static IEnumerable<KeyValuePair<string, T>> Items(IEnumerable<T> other)
             {
                 foreach (T property in other)
                 {
@@ -366,5 +387,36 @@ public ICopyOnWritePropertyDictionary<T> DeepClone()
         {
             return new CopyOnWritePropertyDictionary<T>(this);
         }
+
+        public struct Enumerator : IEnumerator<T>
+        {
+            private ImmutableDictionary<string, T>.Enumerator _dictionaryEnumerator;
+            public Enumerator(CopyOnWritePropertyDictionary<T> dictionary)
+            {
+                _dictionaryEnumerator = dictionary._backing.GetEnumerator();
+            }
+
+            public T Current { get; private set; }
+
+            readonly object IEnumerator.Current => Current;
+
+            public void Dispose() => _dictionaryEnumerator.Dispose();
+
+            public readonly Enumerator GetEnumerator() => this;
+
+            public bool MoveNext()
+            {
+                if (_dictionaryEnumerator.MoveNext())
+                {
+                    Current = _dictionaryEnumerator.Current.Value;
+
+                    return true;
+                }
+
+                return false;
+            }
+
+            public void Reset() => _dictionaryEnumerator.Reset();
+        }
     }
 }
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index 128ef852825..e64a1db5638 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Collections
     /// </remarks>
     /// <typeparam name="T">Item class type to store</typeparam>
     [DebuggerDisplay("#Item types={ItemTypes.Count} #Items={Count}")]
-    internal sealed class ItemDictionary<T> : IItemDictionary<T>
+    internal sealed class ItemDictionary<T> : IItemDictionary<T>, IReadOnlyCollection<T>
         where T : class, IKeyed, IItem
     {
         /// <summary>
@@ -322,7 +322,7 @@ public void ImportItemsOfType(string itemType, IEnumerable<T> items)
                     _itemLists[itemType] = list;
                 }
 
-                foreach (T item in items)
+                foreach (T item in items.GetStructEnumerable())
                 {
 #if DEBUG
                     // Debug only: hot code path
@@ -340,7 +340,7 @@ public void ImportItemsOfType(string itemType, IEnumerable<T> items)
         /// <param name="other">An enumerator over the items to remove.</param>
         public void RemoveItems(IEnumerable<T> other)
         {
-            foreach (T item in other)
+            foreach (T item in other.GetStructEnumerable())
             {
                 Remove(item);
             }
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index c105e12083b..f3128f2c181 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -542,19 +542,34 @@ internal void Enumerate(Action<string, string> keyValueCallback)
 
         internal IEnumerable<TResult> Filter<TResult>(Func<T, bool> filter, Func<T, TResult> selector)
         {
-            List<TResult> result = new();
             lock (_properties)
             {
-                foreach (T property in (ICollection<T>)_properties)
+                ICollection<T> propertiesCollection = (ICollection<T>)_properties;
+                List<TResult> result = new(propertiesCollection.Count);
+                if (_properties is RetrievableValuedEntryHashSet<T> hashSet)
                 {
-                    if (filter(property))
+                    foreach (T property in hashSet)
                     {
-                        result.Add(selector(property));
+                        if (filter(property))
+                        {
+                            result.Add(selector(property));
+                        }
                     }
                 }
-            }
+                else
+                {
+                    foreach (T property in propertiesCollection)
+                    {
+                        if (filter(property))
+                        {
+                            result.Add(selector(property));
+                        }
+                    }
+                }
+                
 
-            return result;
+                return result;
+            }
         }
     }
 }
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index d2386dc8028..fd582923032 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -841,7 +841,9 @@ public bool Remove(T item)
                 return false;
             }
 
-            public IEnumerator<T> GetEnumerator() => new Enumerator(_initial, _forwards);
+            public Enumerator GetEnumerator() => new Enumerator(_initial, _forwards);
+
+            IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
 
             IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
@@ -931,13 +933,18 @@ internal ProjectElementSiblingEnumerable(ProjectElement initial, bool forwards =
             /// <summary>
             /// Get enumerator
             /// </summary>
-            public readonly IEnumerator<ProjectElement> GetEnumerator() => _enumerator;
+            public readonly Enumerator GetEnumerator() => _enumerator;
 
             /// <summary>
             /// Get non generic enumerator
             /// </summary>
             IEnumerator IEnumerable.GetEnumerator() => _enumerator;
 
+            /// <summary>
+            /// Get enumerator
+            /// </summary>
+            IEnumerator<ProjectElement> IEnumerable<ProjectElement>.GetEnumerator() => _enumerator;
+
             /// <summary>
             /// Enumerator over a series of sibling ProjectElement objects
             /// </summary>
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index ac58b5a67a2..9656ec7c5bf 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
@@ -273,9 +274,6 @@ private void FlushFirstValueIfNeeded()
         /// Enabled by ExpanderOptions.Truncate.
         /// </summary>
         private const int ItemLimitPerExpansion = 3;
-        private static readonly char[] s_singleQuoteChar = { '\'' };
-        private static readonly char[] s_backtickChar = { '`' };
-        private static readonly char[] s_doubleQuoteChar = { '"' };
 
         /// <summary>
         /// Those characters which indicate that an expression may contain expandable
@@ -783,38 +781,43 @@ private static void AddArgument(List<string> arguments, SpanBasedStringBuilder a
             // we reached the end of an argument, add the builder's final result
             // to our arguments.
             argumentBuilder.Trim();
-            string argValue = argumentBuilder.ToString();
 
-            // We support passing of null through the argument constant value null
-            if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
+            if (argumentBuilder.Length > 0)
             {
-                arguments.Add(null);
-            }
-            else
-            {
-                if (argValue.Length > 0)
+                char firstChar = argumentBuilder[0];
+                char lastChar = argumentBuilder[argumentBuilder.Length - 1];
+                if (firstChar == '\'' && lastChar == '\'')
                 {
-                    if (argValue[0] == '\'' && argValue[argValue.Length - 1] == '\'')
-                    {
-                        arguments.Add(argValue.Trim(s_singleQuoteChar));
-                    }
-                    else if (argValue[0] == '`' && argValue[argValue.Length - 1] == '`')
-                    {
-                        arguments.Add(argValue.Trim(s_backtickChar));
-                    }
-                    else if (argValue[0] == '"' && argValue[argValue.Length - 1] == '"')
+                    argumentBuilder.Trim('\'');
+                    arguments.Add(argumentBuilder.ToString());
+                }
+                else if (firstChar == '`' && lastChar == '`')
+                {
+                    argumentBuilder.Trim('`');
+                    arguments.Add(argumentBuilder.ToString());
+                }
+                else if (firstChar == '"' && lastChar == '"')
+                {
+                    argumentBuilder.Trim('"');
+                    arguments.Add(argumentBuilder.ToString());
+                }
+                else
+                {
+                    string argValue = argumentBuilder.ToString();
+                    // We support passing of null through the argument constant value null
+                    if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
                     {
-                        arguments.Add(argValue.Trim(s_doubleQuoteChar));
+                        arguments.Add(null);
                     }
                     else
                     {
                         arguments.Add(argValue);
                     }
                 }
-                else
-                {
-                    arguments.Add(argValue);
-                }
+            }
+            else
+            {
+                arguments.Add(string.Empty);
             }
         }
 
@@ -970,10 +973,13 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         using SpanBasedStringBuilder finalResultBuilder = Strings.GetSpanBasedStringBuilder();
 
                         int start = 0;
-                        MetadataMatchEvaluator matchEvaluator = new MetadataMatchEvaluator(metadata, options, elementLocation, loggingContext);
+                        MetadataMatchEvaluator matchMetadataEvaluator = null;
+                        MatchEvaluator matchEvaluator = null;
 
-                        if (itemVectorExpressions != null)
+                        if (itemVectorExpressions != null && itemVectorExpressions.Count > 0)
                         {
+                            matchMetadataEvaluator ??= new MetadataMatchEvaluator(metadata, options, elementLocation, loggingContext);
+                            matchEvaluator ??= new MatchEvaluator(matchMetadataEvaluator.ExpandSingleMetadata);
                             // Move over the expression, skipping those that have been recognized as an item vector expression
                             // Anything other than an item vector expression we want to expand bare metadata in.
                             for (int n = 0; n < itemVectorExpressions.Count; n++)
@@ -983,7 +989,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                                 // Extract the part of the expression that appears before the item vector expression
                                 // e.g. the ABC in ABC@(foo->'%(FullPath)')
                                 string subExpressionToReplaceIn = expression.Substring(start, itemVectorExpressions[n].Index - start);
-                                string replacementResult = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(subExpressionToReplaceIn, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata));
+                                string replacementResult = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(subExpressionToReplaceIn, matchEvaluator);
 
                                 // Append the metadata replacement
                                 finalResultBuilder.Append(replacementResult);
@@ -991,7 +997,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                                 // Expand any metadata that appears in the item vector expression's separator
                                 if (itemVectorExpressions[n].Separator != null)
                                 {
-                                    vectorExpression = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(itemVectorExpressions[n].Value, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata), -1, itemVectorExpressions[n].SeparatorStart);
+                                    vectorExpression = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(itemVectorExpressions[n].Value, matchEvaluator, -1, itemVectorExpressions[n].SeparatorStart);
                                 }
 
                                 // Append the item vector expression as is
@@ -1007,8 +1013,10 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         // then we need to metadata replace and then append that
                         if (start < expression.Length)
                         {
+                            matchMetadataEvaluator ??= new MetadataMatchEvaluator(metadata, options, elementLocation, loggingContext);
+                            matchEvaluator ??= new MatchEvaluator(matchMetadataEvaluator.ExpandSingleMetadata);
                             string subExpressionToReplaceIn = expression.Substring(start);
-                            string replacementResult = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(subExpressionToReplaceIn, new MatchEvaluator(matchEvaluator.ExpandSingleMetadata));
+                            string replacementResult = RegularExpressions.NonTransformItemMetadataPattern.Value.Replace(subExpressionToReplaceIn, matchEvaluator);
 
                             finalResultBuilder.Append(replacementResult);
                         }
@@ -1108,7 +1116,12 @@ _metadata is IItemTypeDefinition itemMetadata &&
 
                         if (IsTruncationEnabled(_options) && metadataValue.Length > CharacterLimitPerExpansion)
                         {
-                            metadataValue = metadataValue.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                            Span<char> trimmedMetadataSpan = stackalloc char[CharacterLimitPerExpansion];
+                            metadataValue.AsSpan().Slice(0, CharacterLimitPerExpansion - 3).CopyTo(trimmedMetadataSpan);
+                            trimmedMetadataSpan[trimmedMetadataSpan.Length - 3] = '.';
+                            trimmedMetadataSpan[trimmedMetadataSpan.Length - 2] = '.';
+                            trimmedMetadataSpan[trimmedMetadataSpan.Length - 1] = '.';
+                            metadataValue = trimmedMetadataSpan.ToString();
                         }
                     }
 
@@ -2034,7 +2047,7 @@ internal static bool ExpandExpressionCapture<S>(
                 if (!isTransformExpression)
                 {
                     // No transform: expression is like @(Compile), so include the item spec without a transform base item
-                    foreach (S item in itemsOfType)
+                    foreach (S item in itemsOfType.GetStructEnumerable())
                     {
                         if ((item.EvaluatedIncludeEscaped.Length > 0) && (options & ExpanderOptions.BreakOnNotEmpty) != 0)
                         {
@@ -2426,7 +2439,7 @@ internal static IEnumerable<KeyValuePair<string, S>> Exists(Expander<P, I> expan
                             ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidItemFunctionExpression", functionName, item.Key, e.Message);
                         }
 
-                        if (File.Exists(rootedPath) || Directory.Exists(rootedPath))
+                        if (NativeMethods.FileOrDirectoryExists(rootedPath))
                         {
                             yield return item;
                         }
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index fd102dff143..3c6209e0cb4 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -68,7 +69,7 @@ internal static ItemsAndMetadataPair GetReferencedItemNamesAndMetadata(IEnumerab
         {
             ItemsAndMetadataPair pair = new ItemsAndMetadataPair(null, null);
 
-            foreach (string expression in expressions)
+            foreach (string expression in expressions.GetStructEnumerable())
             {
                 GetReferencedItemNamesAndMetadata(expression, 0, expression.Length, ref pair, ShredderOptions.All);
             }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index ce19ec7872f..8ff656c8c30 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -603,7 +603,7 @@ internal static void SetMetadata(IEnumerable<KeyValuePair<string, string>> metad
             IEnumerable<ProjectMetadataInstance> projectMetadataInstances = metadataList.Select(metadatum => new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
             metadata.ImportProperties(projectMetadataInstances);
 
-            foreach (ProjectItemInstance item in items)
+            foreach (ProjectItemInstance item in items.GetStructEnumerable())
             {
                 item._taskItem.SetMetadata(metadata); // Potential copy on write
             }
@@ -1104,11 +1104,36 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager(ICopyOn
 
             private IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
             {
-                foreach (var projectMetadataInstance in list.Values)
+                if (list is CopyOnWritePropertyDictionary<ProjectMetadataInstance> copyOnWritePropertyDictionary)
                 {
-                    if (projectMetadataInstance != null)
+                    return EnumerateCopyOnWritePropertyDictionary(copyOnWritePropertyDictionary);
+                }
+                else
+                {
+                    return EnumerateDictionary(list);
+                }
+
+                static IEnumerable<KeyValuePair<string, string>> EnumerateCopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<ProjectMetadataInstance> copyOnWritePropertyDictionary)
+                {
+                    foreach (var kvp in copyOnWritePropertyDictionary)
                     {
-                        yield return new KeyValuePair<string, string>(projectMetadataInstance.Name, projectMetadataInstance.EvaluatedValue);
+                        var projectMetadataInstance = kvp.Value;
+                        if (projectMetadataInstance != null)
+                        {
+                            yield return new KeyValuePair<string, string>(projectMetadataInstance.Name, projectMetadataInstance.EvaluatedValue);
+                        }
+                    }
+                }
+
+                static IEnumerable<KeyValuePair<string, string>> EnumerateDictionary(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> list)
+                {
+                    foreach (var kvp in (IDictionary<string, ProjectMetadataInstance>)list)
+                    {
+                        var projectMetadataInstance = kvp.Value;
+                        if (projectMetadataInstance != null)
+                        {
+                            yield return new KeyValuePair<string, string>(projectMetadataInstance.Name, projectMetadataInstance.EvaluatedValue);
+                        }
                     }
                 }
             }
@@ -1442,9 +1467,7 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                 {
                     // The destination implements IMetadataContainer so we can use the ImportMetadata bulk-set operation.
                     IEnumerable<ProjectMetadataInstance> metadataEnumerable = MetadataCollection;
-                    IEnumerable<KeyValuePair<string, string>> metadataToImport = metadataEnumerable
-                        .Where(metadatum => string.IsNullOrEmpty(destinationItem.GetMetadata(metadatum.Name)))
-                        .Select(metadatum => new KeyValuePair<string, string>(metadatum.Name, GetMetadataEscaped(metadatum.Name)));
+                    IEnumerable<KeyValuePair<string, string>> metadataToImport = GetMetadataToImportEnumerable(destinationItem, metadataEnumerable);
 
 #if FEATURE_APPDOMAIN
                     if (RemotingServices.IsTransparentProxy(destinationItem))
@@ -1479,6 +1502,10 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                         destinationItem.SetMetadata("OriginalItemSpec", _includeEscaped);
                     }
                 }
+
+                IEnumerable<KeyValuePair<string, string>> GetMetadataToImportEnumerable(ITaskItem destinationItem, IEnumerable<ProjectMetadataInstance> metadataEnumerable) => metadataEnumerable
+                                        .Where(metadatum => string.IsNullOrEmpty(destinationItem.GetMetadata(metadatum.Name)))
+                                        .Select(metadatum => new KeyValuePair<string, string>(metadatum.Name, GetMetadataEscaped(metadatum.Name)));
             }
 
             /// <summary>
@@ -1491,10 +1518,21 @@ public IDictionary CloneCustomMetadata()
                 var metadata = MetadataCollection;
                 Dictionary<string, string> clonedMetadata = new Dictionary<string, string>(metadata.Count, MSBuildNameIgnoreCaseComparer.Default);
 
-                foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadata)
+                if (metadata is CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataDictionary)
+                {
+                    foreach (KeyValuePair<string, ProjectMetadataInstance> metadatum in metadataDictionary)
+                    {
+                        clonedMetadata[metadatum.Value.Name] = metadatum.Value.EvaluatedValue;
+                    }
+                }
+                else
                 {
-                    clonedMetadata[metadatum.Name] = metadatum.EvaluatedValue;
+                    foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)metadata)
+                    {
+                        clonedMetadata[metadatum.Name] = metadatum.EvaluatedValue;
+                    }
                 }
+                
 
                 return clonedMetadata;
             }
@@ -1763,12 +1801,20 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                     {
                         int count = temp.Count;
                         translator.Writer.Write(count);
-                        foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)temp)
+
+                        if (temp is CopyOnWritePropertyDictionary<ProjectMetadataInstance> copyOnWriteDictionary)
                         {
-                            int key = interner.Intern(metadatum.Name);
-                            int value = interner.Intern(metadatum.EvaluatedValueEscaped);
-                            translator.Writer.Write(key);
-                            translator.Writer.Write(value);
+                            foreach (KeyValuePair<string, ProjectMetadataInstance> metadatum in copyOnWriteDictionary)
+                            {
+                                TranslateMetadata(translator, interner, metadatum.Value);
+                            }
+                        }
+                        else
+                        {
+                            foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)temp)
+                            {
+                                TranslateMetadata(translator, interner, metadatum);
+                            }
                         }
                     }
                 }
@@ -1781,13 +1827,7 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                         int count = translator.Reader.ReadInt32();
                         if (count > 0)
                         {
-                            IEnumerable<ProjectMetadataInstance> metaData =
-                                Enumerable.Range(0, count).Select(_ =>
-                                {
-                                    int key = translator.Reader.ReadInt32();
-                                    int value = translator.Reader.ReadInt32();
-                                    return new ProjectMetadataInstance(interner.GetString(key), interner.GetString(value), allowItemSpecModifiers: true);
-                                });
+                            IEnumerable<ProjectMetadataInstance> metaData = GetMetadataEnumerable(translator, interner, count);
                             _directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                             _directMetadata.ImportProperties(metaData);
                         }
@@ -1797,6 +1837,24 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                         }
                     }
                 }
+
+                static IEnumerable<ProjectMetadataInstance> GetMetadataEnumerable(ITranslator translator, LookasideStringInterner interner, int count)
+                {
+                    for (int i = 0; i < count; ++i)
+                    {
+                        int key = translator.Reader.ReadInt32();
+                        int value = translator.Reader.ReadInt32();
+                        yield return new ProjectMetadataInstance(interner.GetString(key), interner.GetString(value), allowItemSpecModifiers: true);
+                    }
+                }
+
+                static void TranslateMetadata(ITranslator translator, LookasideStringInterner interner, ProjectMetadataInstance metadatum)
+                {
+                    int key = interner.Intern(metadatum.Name);
+                    int value = interner.Intern(metadatum.EvaluatedValueEscaped);
+                    translator.Writer.Write(key);
+                    translator.Writer.Write(value);
+                }
             }
 
             /// <summary>
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 24471d364ba..3a5e182e365 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -81,6 +81,9 @@
     <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
       <Link>IConstrainedEqualityComparer.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\IEnumerableExtensions.cs">
+      <Link>IEnumerableExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\PropertyParser.cs</Link>
     </Compile>
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index a4859ae234a..9799a134080 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -701,6 +701,16 @@ public static void EnumerateItems(IEnumerable items, Action<DictionaryEntry> cal
                     }
                 });
             }
+            else if (items is IEnumerable<DictionaryEntry> dictionaryEntryEnumerable)
+            {
+                foreach (DictionaryEntry dictionaryEntry in dictionaryEntryEnumerable)
+                {
+                    if (dictionaryEntry.Key is string key && key.Length > 0)
+                    {
+                        callback(new DictionaryEntry(key, dictionaryEntry.Value));
+                    }
+                }
+            }
             else
             {
                 foreach (var item in items)
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index 41a5914dad6..d82637116b0 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -299,7 +299,11 @@ public void Translate(ref HashSet<string> set)
                 }
 
                 int count = _reader.ReadInt32();
+#if NET472_OR_GREATER || NET9_0_OR_GREATER
+                set = new HashSet<string>(count);
+#else
                 set = new HashSet<string>();
+#endif
 
                 for (int i = 0; i < count; i++)
                 {
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Shared/CopyOnWriteDictionary.cs
index b48401b964f..28797141eba 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Shared/CopyOnWriteDictionary.cs
@@ -294,13 +294,26 @@ public bool Remove(KeyValuePair<string, V> item)
             return initial != _backing; // whether the removal occured
         }
 
+#if NET472_OR_GREATER || NETCOREAPP
         /// <summary>
         /// Implementation of generic IEnumerable.GetEnumerator()
         /// </summary>
+        public ImmutableDictionary<string, V>.Enumerator GetEnumerator()
+        {
+            return _backing.GetEnumerator();
+        }
+
+        IEnumerator<KeyValuePair<string, V>> IEnumerable<KeyValuePair<string, V>>.GetEnumerator()
+        {
+            ImmutableDictionary<string, V>.Enumerator enumerator = _backing.GetEnumerator();
+            return _backing.GetEnumerator();
+        }
+#else
         public IEnumerator<KeyValuePair<string, V>> GetEnumerator()
         {
             return _backing.GetEnumerator();
         }
+#endif
 
         /// <summary>
         /// Implementation of IEnumerable.GetEnumerator()
diff --git a/src/Shared/IEnumerableExtensions.cs b/src/Shared/IEnumerableExtensions.cs
new file mode 100644
index 00000000000..f0d55d6bfc3
--- /dev/null
+++ b/src/Shared/IEnumerableExtensions.cs
@@ -0,0 +1,237 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable enable
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+
+namespace Microsoft.Build.Collections
+{
+    /// <summary>
+    /// A set of extension methods for working with immutable dictionaries.
+    /// </summary>
+    internal static class IEnumerableExtensions
+    {
+        /// <summary>
+        /// Avoids allocating an enumerator when enumerating an <see cref="IEnumerable{T}"/> in many cases.
+        /// </summary>
+        /// <remarks>
+        /// <para>
+        /// The <see langword="foreach"/> statement enumerates types that implement <see cref="IEnumerable{T}"/>,
+        /// but will also enumerate any type that has the required methods. Several collection types take advantage of this
+        /// to avoid allocating an enumerator on the heap when used with <see langword="foreach"/> by returning a
+        /// <see langword="struct"/> enumerator. This is in contrast to the interface-based enumerator
+        /// <see cref="IEnumerator{T}"/> which will always be allocated on the heap.
+        /// </para>
+        /// <para>
+        /// This extension method attempts to create a non-allocating struct enumerator to enumerate
+        /// <paramref name="collection"/>. It checks the concrete type of the collection and provides a
+        /// non-allocating path in several cases.
+        /// </para>
+        /// <para>
+        /// Types that can be enumerated without allocation are:
+        /// </para>
+        /// <list type="bullet">
+        ///     <item><description><see cref="IList{T}"/> (and by extension <see cref="List{T}"/> and other popular implementations)</description></item>
+        ///     <item><description><see cref="LinkedList{T}"/></description></item>
+        ///     <item><description><see cref="ImmutableHashSet{T}"/></description></item>
+        ///     <item><description><see cref="ImmutableList{T}"/></description></item>
+        ///     <item><description><see cref="ICollection{T}"/> or <see cref="IReadOnlyCollection{T}"/> having zero count</description></item>
+        /// </list>
+        /// <para>
+        /// If <paramref name="collection"/> is not one of the supported types, the returned enumerator falls back to the
+        /// interface-based enumerator, which will heap allocate. Benchmarking shows the overhead in such cases is low enough
+        /// to be within the measurement error.
+        /// </para>
+        /// </remarks>
+        /// <example>
+        /// <code>
+        /// <![CDATA[IEnumerable<string> collection = ...;
+        ///
+        /// foreach (string item in collection.GetStructEnumerable())
+        /// {
+        ///     // ...
+        /// }]]>
+        /// </code>
+        /// </example>
+        /// <typeparam name="T">The item type that is enumerated.</typeparam>
+        /// <param name="collection">The collections that will be enumerated.</param>
+        /// <returns>The enumerator for the collection.</returns>
+        public static Enumerable<T> GetStructEnumerable<T>(this IEnumerable<T> collection)
+        {
+            if (collection is null)
+            {
+                throw new ArgumentNullException(nameof(collection));
+            }
+
+            return Enumerable<T>.Create(collection);
+        }
+
+        /// <summary>
+        /// Provides a struct-based enumerator for use with <see cref="IEnumerable{T}"/>.
+        /// Do not use this type directly. Use <see cref="GetStructEnumerable{T}"/> instead.
+        /// </summary>
+        /// <typeparam name="T">The item type that is enumerated.</typeparam>
+        public readonly ref struct Enumerable<T>
+        {
+            private readonly IEnumerable<T> collection;
+
+            private Enumerable(IEnumerable<T> collection) => this.collection = collection;
+
+            /// <summary>
+            /// Constructs an <see cref="Enumerable{T}"/> that can be enumerated.
+            /// </summary>
+            /// <param name="collection">The collections that will be enumerated.</param>
+            /// <returns><see cref="Enumerable{T}"/>.</returns>
+            public static Enumerable<T> Create(IEnumerable<T> collection)
+            {
+                return new Enumerable<T>(collection);
+            }
+
+            /// <summary>
+            /// Gets the Enumerator.
+            /// </summary>
+            /// <returns><see cref="Enumerator"/>.</returns>
+            public Enumerator GetEnumerator() => new(this.collection);
+
+            /// <summary>
+            /// A struct-based enumerator for use with <see cref="IEnumerable{T}"/>.
+            /// Do not use this type directly. Use <see cref="GetStructEnumerable{T}"/> instead.
+            /// </summary>
+            public struct Enumerator : IDisposable
+            {
+                private readonly Type enumeratorType;
+                private readonly IEnumerator<T>? fallbackEnumerator;
+                private readonly IList<T>? iList;
+                private int listIndex;
+
+                private LinkedList<T>.Enumerator concreteLinkedListEnumerator;
+                private ImmutableHashSet<T>.Enumerator concreteImmutableHashSetEnumerator;
+                private ImmutableList<T>.Enumerator concreteImmutableListEnumerator;
+                private HashSet<T>.Enumerator concreteHashSetEnumerator;
+
+                /// <summary>
+                /// Initializes a new instance of the <see cref="Enumerator"/> struct.
+                /// </summary>
+                /// <param name="collection">The collection that will be enumerated.</param>
+                internal Enumerator(IEnumerable<T> collection)
+                {
+                    this.concreteLinkedListEnumerator = default;
+                    this.concreteImmutableHashSetEnumerator = default;
+                    this.concreteImmutableListEnumerator = default;
+                    this.concreteHashSetEnumerator = default;
+                    this.fallbackEnumerator = null;
+                    this.iList = null;
+                    this.listIndex = -1;
+
+                    switch (collection)
+                    {
+                        case ICollection<T> sizedCollection when sizedCollection.Count == 0:
+                        case IReadOnlyCollection<T> readOnlyCollection when readOnlyCollection.Count == 0:
+                            // The collection is empty, just return false from MoveNext.
+                            this.enumeratorType = Type.Empty;
+                            break;
+                        case LinkedList<T> concreteLinkedList:
+                            this.enumeratorType = Type.LinkedList;
+                            this.concreteLinkedListEnumerator = concreteLinkedList.GetEnumerator();
+                            break;
+                        case ImmutableHashSet<T> concreteImmutableHashSet:
+                            this.enumeratorType = Type.ImmutableHashSet;
+                            this.concreteImmutableHashSetEnumerator = concreteImmutableHashSet.GetEnumerator();
+                            break;
+                        case ImmutableList<T> concreteImmutableList:
+                            this.enumeratorType = Type.ImmutableList;
+                            this.concreteImmutableListEnumerator = concreteImmutableList.GetEnumerator();
+                            break;
+                        case HashSet<T> concreteHashSet:
+                            this.enumeratorType = Type.HashSet;
+                            this.concreteHashSetEnumerator = concreteHashSet.GetEnumerator();
+                            break;
+                        case IList<T> list:
+                            this.enumeratorType = Type.IList;
+                            this.iList = list;
+                            break;
+                        default:
+                            this.enumeratorType = Type.Fallback;
+                            this.fallbackEnumerator = collection.GetEnumerator();
+                            break;
+                    }
+                }
+
+                private enum Type : byte
+                {
+                    Empty,
+                    IList,
+                    LinkedList,
+                    ImmutableHashSet,
+                    ImmutableList,
+                    HashSet,
+                    Fallback,
+                }
+
+                /// <summary>
+                /// Gets the element in the <see cref="IEnumerable{T}"/> at the current position of the enumerator.
+                /// </summary>
+                public T Current =>
+                    this.enumeratorType switch
+                    {
+                        Type.IList => (uint)this.listIndex < this.iList!.Count ? this.iList![this.listIndex] : default!,
+                        Type.LinkedList => this.concreteLinkedListEnumerator.Current,
+                        Type.ImmutableHashSet => this.concreteImmutableHashSetEnumerator.Current,
+                        Type.ImmutableList => this.concreteImmutableListEnumerator.Current,
+                        Type.HashSet => this.concreteHashSetEnumerator.Current,
+                        Type.Fallback => this.fallbackEnumerator!.Current,
+                        _ => default!,
+                    };
+
+                /// <summary>
+                /// Advances the enumerator to the next element of the <see cref="IEnumerable{T}"/>.
+                /// </summary>
+                /// <returns><see langword="true"/> if the enumerator was successfully advanced to the next element; <see langword="false"/> if
+                /// the enumerator has passed the end of the <see cref="IEnumerable{T}"/>.</returns>
+                public bool MoveNext() =>
+                    this.enumeratorType switch
+                    {
+                        Type.IList => ++this.listIndex < this.iList!.Count,
+                        Type.LinkedList => this.concreteLinkedListEnumerator.MoveNext(),
+                        Type.ImmutableHashSet => this.concreteImmutableHashSetEnumerator.MoveNext(),
+                        Type.ImmutableList => this.concreteImmutableListEnumerator.MoveNext(),
+                        Type.HashSet => this.concreteHashSetEnumerator.MoveNext(),
+                        Type.Fallback => this.fallbackEnumerator!.MoveNext(),
+                        _ => false,
+                    };
+
+                /// <summary>
+                /// Disposes the underlying enumerator.
+                /// </summary>
+                public void Dispose()
+                {
+                    switch (this.enumeratorType)
+                    {
+                        case Type.LinkedList:
+                            this.concreteLinkedListEnumerator.Dispose();
+                            break;
+
+                        case Type.ImmutableHashSet:
+                            this.concreteImmutableHashSetEnumerator.Dispose();
+                            break;
+
+                        case Type.ImmutableList:
+                            this.concreteImmutableListEnumerator.Dispose();
+                            break;
+
+                        case Type.HashSet:
+                            this.concreteHashSetEnumerator.Dispose();
+                            break;
+
+                        case Type.Fallback:
+                            this.fallbackEnumerator!.Dispose();
+                            break;
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/src/StringTools/SpanBasedStringBuilder.cs b/src/StringTools/SpanBasedStringBuilder.cs
index 01c9c70c18c..c969d00cb38 100644
--- a/src/StringTools/SpanBasedStringBuilder.cs
+++ b/src/StringTools/SpanBasedStringBuilder.cs
@@ -77,6 +77,33 @@ public bool MoveNext()
             }
         }
 
+        public char this[int index]
+        {
+            get
+            {
+                if ((uint)index >= (uint)Length)
+                {
+                    throw new IndexOutOfRangeException(nameof(index));
+                }
+
+                int currentIndex = index;
+                for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)
+                {
+                    ReadOnlySpan<char> span = _spans[spanIdx].Span;
+                    if (currentIndex < span.Length)
+                    {
+                        return span[currentIndex];
+                    }
+                    else
+                    {
+                        currentIndex -= span.Length;
+                    }
+                }
+
+                throw new IndexOutOfRangeException(nameof(index));
+            }
+        }
+
         /// <summary>
         /// Spans making up the rope.
         /// </summary>
@@ -226,6 +253,31 @@ public void TrimStart()
             }
         }
 
+        /// <summary>
+        /// Removes leading white-space characters from the string.
+        /// </summary>
+        public void TrimStart(char c)
+        {
+            for (int spanIdx = 0; spanIdx < _spans.Count; spanIdx++)
+            {
+                ReadOnlySpan<char> span = _spans[spanIdx].Span;
+                int i = 0;
+                while (i < span.Length && span[i] == c)
+                {
+                    i++;
+                }
+                if (i > 0)
+                {
+                    _spans[spanIdx] = _spans[spanIdx].Slice(i);
+                    Length -= i;
+                }
+                if (!_spans[spanIdx].IsEmpty)
+                {
+                    return;
+                }
+            }
+        }
+
         /// <summary>
         /// Removes trailing white-space characters from the string.
         /// </summary>
@@ -251,6 +303,31 @@ public void TrimEnd()
             }
         }
 
+        /// <summary>
+        /// Removes trailing characters from the string.
+        /// </summary>
+        public void TrimEnd(char c)
+        {
+            for (int spanIdx = _spans.Count - 1; spanIdx >= 0; spanIdx--)
+            {
+                ReadOnlySpan<char> span = _spans[spanIdx].Span;
+                int i = span.Length - 1;
+                while (i >= 0 && span[i] == c)
+                {
+                    i--;
+                }
+                if (i + 1 < span.Length)
+                {
+                    _spans[spanIdx] = _spans[spanIdx].Slice(0, i + 1);
+                    Length -= span.Length - (i + 1);
+                }
+                if (!_spans[spanIdx].IsEmpty)
+                {
+                    return;
+                }
+            }
+        }
+
         /// <summary>
         /// Removes leading and trailing white-space characters from the string.
         /// </summary>
@@ -260,6 +337,15 @@ public void Trim()
             TrimEnd();
         }
 
+        /// <summary>
+        /// Removes leading and trailing characters from the string.
+        /// </summary>
+        public void Trim(char c)
+        {
+            TrimStart(c);
+            TrimEnd(c);
+        }
+
         /// <summary>
         /// Clears this instance making it represent an empty string.
         /// </summary>
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index cb7031ecb55..2776459ea22 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -456,9 +456,7 @@ private AssemblyNameExtension GetAssemblyName(string path)
             // then we can short-circuit the File IO involved with GetAssemblyName()
             if (redistList != null)
             {
-                string extension = Path.GetExtension(path);
-
-                if (string.Equals(extension, ".dll", StringComparison.OrdinalIgnoreCase))
+                if (!string.IsNullOrEmpty(path) && path.EndsWith(".dll", StringComparison.OrdinalIgnoreCase))
                 {
                     IEnumerable<AssemblyEntry> assemblyNames = redistList.FindAssemblyNameFromSimpleName(
                             Path.GetFileNameWithoutExtension(path));
