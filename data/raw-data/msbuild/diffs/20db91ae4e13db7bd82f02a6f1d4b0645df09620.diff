diff --git a/src/Analyzers.UnitTests/EndToEndTests.cs b/src/Analyzers.UnitTests/EndToEndTests.cs
index 7a573b23b3f..a09a9c83924 100644
--- a/src/Analyzers.UnitTests/EndToEndTests.cs
+++ b/src/Analyzers.UnitTests/EndToEndTests.cs
@@ -80,36 +80,26 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode)
                     <Target Name="Hello">
                     <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
                     </Target>
-                                   
                 </Project>
                 """;
             TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
             TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
             TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
+            TransientTestFile config = _env.CreateFile(workFolder, ".editorconfig",
+            """
+            root=true
 
-            // var cache = new SimpleProjectRootElementCache();
-            // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
+            [*.csproj]
+            msbuild_analyzer.BC0101.IsEnabled=false
+            msbuild_analyzer.BC0101.severity=warning
 
+            msbuild_analyzer.COND0543.IsEnabled=false
+            msbuild_analyzer.COND0543.severity=Error
+            msbuild_analyzer.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+            msbuild_analyzer.COND0543.CustomSwitch=QWERTY
 
-            TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
-                /*lang=json,strict*/
-                """
-                {
-                    "BC0101": {
-                        "IsEnabled": true,
-                        "Severity": "Error"
-                    },
-                    "COND0543": {
-                        "IsEnabled": false,
-                        "Severity": "Error",
-                        "EvaluationAnalysisScope": "AnalyzedProjectOnly",
-                        "CustomSwitch": "QWERTY"
-                    },
-                    "BLA": {
-                        "IsEnabled": false
-                    }
-                }
-                """);
+            msbuild_analyzer.BLA.IsEnabled=false
+            """);
 
             // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
             // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
@@ -123,7 +113,7 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode)
             _env.Output.WriteLine(output);
             success.ShouldBeTrue();
             // The conflicting outputs warning appears
-            output.ShouldContain("BC0101");
+            output.ShouldContain("warning : BC0101");
         }
     }
 }
diff --git a/src/Build/BuildCop/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCop/API/BuildAnalyzerConfiguration.cs
index 19ab210e097..e5927374c2f 100644
--- a/src/Build/BuildCop/API/BuildAnalyzerConfiguration.cs
+++ b/src/Build/BuildCop/API/BuildAnalyzerConfiguration.cs
@@ -1,6 +1,9 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Collections.Generic;
+using System;
+
 namespace Microsoft.Build.Experimental.BuildCop;
 
 /// <summary>
@@ -42,4 +45,37 @@ public class BuildAnalyzerConfiguration
     /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
     /// </summary>
     public bool? IsEnabled { get; internal init; }
+
+    public static BuildAnalyzerConfiguration Create(Dictionary<string, string> configDictionary)
+    {
+        return new()
+        {
+            EvaluationAnalysisScope = TryExtractValue("EvaluationAnalysisScope", configDictionary, out EvaluationAnalysisScope evaluationAnalysisScope) ? evaluationAnalysisScope : null,
+            Severity = TryExtractValue("severity", configDictionary, out BuildAnalyzerResultSeverity severity) ? severity : null,
+            IsEnabled = TryExtractValue("IsEnabled", configDictionary, out bool test) ? test : null,
+        };
+    }
+
+    private static bool TryExtractValue<T>(string key, Dictionary<string, string> config, out T value) where T : struct
+    {
+        value = default;
+        if (!config.ContainsKey(key))
+        {
+            return false;
+        }
+
+        if (typeof(T) == typeof(bool))
+        {
+            if (bool.TryParse(config[key], out bool boolValue))
+            {
+                value = (T)(object)boolValue;
+                return true;
+            }
+        }
+        else if(typeof(T).IsEnum)
+        {
+            return Enum.TryParse(config[key], true, out value);
+        }
+        return false;
+    }
 }
diff --git a/src/Build/BuildCop/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCop/Analyzers/SharedOutputPathAnalyzer.cs
index 59eb865169b..ba6b6700a1b 100644
--- a/src/Build/BuildCop/Analyzers/SharedOutputPathAnalyzer.cs
+++ b/src/Build/BuildCop/Analyzers/SharedOutputPathAnalyzer.cs
@@ -19,7 +19,7 @@ internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
     public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0101", "ConflictingOutputPath",
         "Two projects should not share their OutputPath nor IntermediateOutputPath locations", "Configuration",
         "Projects {0} and {1} have conflicting output paths: {2}.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Info, IsEnabled = true });
 
     public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
 
diff --git a/src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs
index 48db5678d98..8a61b2c42c7 100644
--- a/src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCop/Infrastructure/ConfigurationProvider.cs
@@ -11,6 +11,7 @@
 using System.Text.Json;
 using Microsoft.Build.Experimental.BuildCop;
 using System.Configuration;
+using Microsoft.Build.BuildCop.Infrastructure.EditorConfig;
 
 namespace Microsoft.Build.BuildCop.Infrastructure;
 
@@ -19,56 +20,10 @@ namespace Microsoft.Build.BuildCop.Infrastructure;
 //  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)
 internal static class ConfigurationProvider
 {
+    private static IEditorConfigParser s_editorConfigParser = new EditorConfigParser();
     // TODO: This module should have a mechanism for removing unneeded configurations
     //  (disabled rules and analyzers that need to run in different node)
-    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();
-
-    // This is just a testing implementation for quicker unblock of testing.
-    // Real implementation will use .editorconfig file.
-    // Sample json:
-    /////*lang=json,strict*/
-    ////"""
-    ////    {
-    ////        "ABC123": {
-    ////            "IsEnabled": true,
-    ////            "Severity": "Info"
-    ////        },
-    ////        "COND0543": {
-    ////            "IsEnabled": false,
-    ////            "Severity": "Error",
-    ////    		"EvaluationAnalysisScope": "AnalyzedProjectOnly",
-    ////    		"CustomSwitch": "QWERTY"
-    ////        },
-    ////        "BLA": {
-    ////            "IsEnabled": false
-    ////        }
-    ////    }
-    ////    """
-    //
-    // Plus there will need to be a mechanism of distinguishing different configs in different folders
-    //  - e.g. - what to do if we analyze two projects (not sharing output path) and they have different .editorconfig files?
-    private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration()
-    {
-        const string configFileName = "editorconfig.json";
-        string configPath = configFileName;
-
-        if (!File.Exists(configPath))
-        {
-            // TODO: pass the current project path
-            var dir = Environment.CurrentDirectory;
-            configPath = Path.Combine(dir, configFileName);
-
-            if (!File.Exists(configPath))
-            {
-                return new Dictionary<string, BuildAnalyzerConfiguration>();
-            }
-        }
-
-        var json = File.ReadAllText(configPath);
-        var DeserializationOptions = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() } };
-        return JsonSerializer.Deserialize<Dictionary<string, BuildAnalyzerConfiguration>>(json, DeserializationOptions) ??
-               new Dictionary<string, BuildAnalyzerConfiguration>();
-    }
+    private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = new Dictionary<string, BuildAnalyzerConfiguration>();
 
     /// <summary>
     /// Gets the user specified unrecognized configuration for the given analyzer rule.
@@ -120,7 +75,7 @@ public static BuildAnalyzerConfigurationInternal[] GetMergedConfigurations(
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
-            configurations[idx] = ConfigurationProvider.MergeConfiguration(
+            configurations[idx] = MergeConfiguration(
                 analyzer.SupportedRules[idx].Id,
                 analyzer.SupportedRules[idx].DefaultConfiguration,
                 userConfigs[idx]);
@@ -157,6 +112,23 @@ public static BuildAnalyzerConfiguration GetUserConfiguration(string projectFull
             editorConfig = BuildAnalyzerConfiguration.Null;
         }
 
+        var config = s_editorConfigParser.Parse(projectFullPath);
+        var keyTosearch = $"msbuild_analyzer.{ruleId}.";
+        var dictionaryConfig = new Dictionary<string, string>();
+
+        foreach (var kv in config)
+        {
+            if (kv.Key.StartsWith(keyTosearch, StringComparison.OrdinalIgnoreCase))
+            {
+                dictionaryConfig[kv.Key.Replace(keyTosearch.ToLower(), "")] = kv.Value;
+            }
+        }
+
+        if (dictionaryConfig.Any())
+        {
+            return BuildAnalyzerConfiguration.Create(dictionaryConfig);
+        }
+
         return editorConfig;
     }
 
diff --git a/src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigFile.cs
new file mode 100644
index 00000000000..043969129fb
--- /dev/null
+++ b/src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -0,0 +1,201 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Code and logic is copied from the https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.cs
+// with slight changes like:
+//  1. Remove dependency from Source text.
+//  2. Remove support of globalconfig
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BuildCop.Infrastructure.EditorConfig
+{
+    internal partial class EditorConfigFile
+    {
+        // Matches EditorConfig section header such as "[*.{js,py}]", see https://editorconfig.org for details
+        private const string s_sectionMatcherPattern = @"^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$";
+
+        // Matches EditorConfig property such as "indent_style = space", see https://editorconfig.org for details
+        private const string s_propertyMatcherPattern = @"^\s*([\w\.\-_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$";
+
+#if NETCOREAPP
+
+    [GeneratedRegex(s_sectionMatcherPattern)]
+    private static partial Regex GetSectionMatcherRegex();
+
+    [GeneratedRegex(s_propertyMatcherPattern)]
+    private static partial Regex GetPropertyMatcherRegex();
+
+#else
+        private static readonly Regex s_sectionMatcher = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
+
+        private static readonly Regex s_propertyMatcher = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
+
+        private static Regex GetSectionMatcherRegex() => s_sectionMatcher;
+
+        private static Regex GetPropertyMatcherRegex() => s_propertyMatcher;
+
+#endif
+
+        internal Section GlobalSection { get; }
+
+        /// <summary>
+        /// The path passed to <see cref="Parse(string, string)"/> during construction.
+        /// </summary>
+        internal string PathToFile { get; }
+
+        internal ImmutableArray<Section> NamedSections { get; }
+
+        /// <summary>
+        /// Gets whether this editorconfig is a topmost editorconfig.
+        /// </summary>
+        internal bool IsRoot => GlobalSection.Properties.TryGetValue("root", out string? val) && val == "true";
+
+        private EditorConfigFile(
+            Section globalSection,
+            ImmutableArray<Section> namedSections,
+            string pathToFile)
+        {
+            GlobalSection = globalSection;
+            NamedSections = namedSections;
+            PathToFile = pathToFile;
+        }
+
+        /// <summary>
+        /// Parses an editor config file text located at the given path. No parsing
+        /// errors are reported. If any line contains a parse error, it is dropped.
+        /// </summary>
+        internal static EditorConfigFile Parse(string pathToFile)
+        {
+            if (pathToFile is null || !Path.IsPathRooted(pathToFile) || string.IsNullOrEmpty(Path.GetFileName(pathToFile)) || !File.Exists(pathToFile))
+            {
+                throw new ArgumentException("Must be an absolute path to an editorconfig file", nameof(pathToFile));
+            }
+
+            Section? globalSection = null;
+            var namedSectionBuilder = ImmutableArray.CreateBuilder<Section>();
+
+            // N.B. The editorconfig documentation is quite loose on property interpretation.
+            // Specifically, it says:
+            //      Currently all properties and values are case-insensitive.
+            //      They are lowercased when parsed.
+            // To accommodate this, we use a lower case Unicode mapping when adding to the
+            // dictionary, but we also use a case-insensitive key comparer when doing lookups
+            var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>();
+            string activeSectionName = "";
+
+            using (StreamReader sr = new StreamReader(pathToFile))
+            {
+                while (sr.Peek() >= 0)
+                {
+                    string line = sr.ReadLine();
+
+                    if (string.IsNullOrWhiteSpace(line))
+                    {
+                        continue;
+                    }
+
+                    if (IsComment(line))
+                    {
+                        continue;
+                    }
+
+                    var sectionMatches = GetSectionMatcherRegex().Matches(line);
+                    if (sectionMatches.Count > 0 && sectionMatches[0].Groups.Count > 0)
+                    {
+                        addNewSection();
+
+                        var sectionName = sectionMatches[0].Groups[1].Value;
+                        Debug.Assert(!string.IsNullOrEmpty(sectionName));
+
+                        activeSectionName = sectionName;
+                        activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>();
+                        continue;
+                    }
+
+                    var propMatches = GetPropertyMatcherRegex().Matches(line);
+                    if (propMatches.Count > 0 && propMatches[0].Groups.Count > 1)
+                    {
+                        var key = propMatches[0].Groups[1].Value.ToLower();
+                        var value = propMatches[0].Groups[2].Value.ToLower();
+
+                        Debug.Assert(!string.IsNullOrEmpty(key));
+                        Debug.Assert(key == key.Trim());
+                        Debug.Assert(value == value?.Trim());
+
+                        activeSectionProperties[key] = value ?? "";
+                        continue;
+                    }
+                }
+            }
+
+            // Add the last section
+            addNewSection();
+
+            return new EditorConfigFile(globalSection!, namedSectionBuilder.ToImmutable(), pathToFile);
+
+            void addNewSection()
+            {
+                // Close out the previous section
+                var previousSection = new Section(activeSectionName, activeSectionProperties.ToImmutable());
+                if (activeSectionName == "")
+                {
+                    // This is the global section
+                    globalSection = previousSection;
+                }
+                else
+                {
+                    namedSectionBuilder.Add(previousSection);
+                }
+            }
+        }
+
+        private static bool IsComment(string line)
+        {
+            foreach (char c in line)
+            {
+                if (!char.IsWhiteSpace(c))
+                {
+                    return c == '#' || c == ';';
+                }
+            }
+
+            return false;
+        }
+
+        /// <summary>
+        /// Represents a named section of the editorconfig file, which consists of a name followed by a set
+        /// of key-value pairs.
+        /// </summary>
+        internal sealed class Section
+        {
+            public Section(string name, ImmutableDictionary<string, string> properties)
+            {
+                Name = name;
+                Properties = properties;
+            }
+
+            /// <summary>
+            /// For regular files, the name as present directly in the section specification of the editorconfig file. For sections in
+            /// global configs, this is the unescaped full file path.
+            /// </summary>
+            public string Name { get; }
+
+            /// <summary>
+            /// Keys and values for this section. All keys are lower-cased according to the
+            /// EditorConfig specification and keys are compared case-insensitively. Otherwise,
+            /// the values are the literal values present in the source.
+            /// </summary>
+            public ImmutableDictionary<string, string> Properties { get; }
+        }
+    }
+}
diff --git a/src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs b/src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
new file mode 100644
index 00000000000..267d3fbd904
--- /dev/null
+++ b/src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
@@ -0,0 +1,615 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Note:
+// Copied from https://github.com/dotnet/roslyn/blob/06d3f153ed6af6f2b78028a1e1e6ecc55c8ff101/src/Compilers/Core/Portable/CommandLine/AnalyzerConfig.SectionNameMatching.cs
+// with some changes to make it quicker to integrate into the MSBuild.
+// Changes:
+//  1. ArrayBuilder was replaced with List.
+//  2. Exceptions. TODO: Wrap in try/catch blocks for proper reporting
+
+
+using System;
+using System.Collections.Generic;
+using System.Collections.Immutable;
+using System.Diagnostics;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Text.RegularExpressions;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BuildCop.Infrastructure.EditorConfig
+{
+    internal class EditorConfigGlobsMatcher
+    {
+        internal readonly struct SectionNameMatcher
+        {
+            private readonly ImmutableArray<(int minValue, int maxValue)> _numberRangePairs;
+            // public for testing
+            public Regex Regex { get; }
+
+            public SectionNameMatcher(
+                Regex regex,
+                ImmutableArray<(int minValue, int maxValue)> numberRangePairs)
+            {
+                Debug.Assert(regex.GetGroupNumbers().Length - 1 == numberRangePairs.Length);
+                Regex = regex;
+                _numberRangePairs = numberRangePairs;
+            }
+
+            internal bool IsMatch(string s)
+            {
+                if (_numberRangePairs.IsEmpty)
+                {
+                    return Regex.IsMatch(s);
+                }
+
+                var match = Regex.Match(s);
+                if (!match.Success)
+                {
+                    return false;
+                }
+
+                Debug.Assert(match.Groups.Count - 1 == _numberRangePairs.Length);
+                for (int i = 0; i < _numberRangePairs.Length; i++)
+                {
+                    var (minValue, maxValue) = _numberRangePairs[i];
+                    // Index 0 is the whole regex
+                    if (!int.TryParse(match.Groups[i + 1].Value, out int matchedNum) ||
+                        matchedNum < minValue ||
+                        matchedNum > maxValue)
+                    {
+                        return false;
+                    }
+                }
+                return true;
+            }
+        }
+
+        /// <summary>
+        /// Takes a <see cref="Section.Name"/> and creates a matcher that
+        /// matches the given language. Returns null if the section name is
+        /// invalid.
+        /// </summary>
+        internal static SectionNameMatcher? TryCreateSectionNameMatcher(string sectionName)
+        {
+            // An editorconfig section name is a language for recognizing file paths
+            // defined by the following grammar:
+            //
+            // <path> ::= <path-list>
+            // <path-list> ::= <path-item> | <path-item> <path-list>
+            // <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+            // <char> ::= any unicode character
+            // <choice> ::= "{" <choice-list> "}"
+            // <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+            // <range> ::= "{" <integer> ".." <integer> "}"
+            // <integer> ::= "-" <digit-list> | <digit-list>
+            // <digit-list> ::= <digit> | <digit> <digit-list>
+            // <digit> ::= 0-9
+
+            var sb = new StringBuilder();
+            sb.Append('^');
+
+            // EditorConfig matching depends on the whether or not there are
+            // directory separators and where they are located in the section
+            // name. Specifically, the editorconfig core parser says:
+            // https://github.com/editorconfig/editorconfig-core-c/blob/5d3996811e962a717a7d7fdd0a941192382241a7/src/lib/editorconfig.c#L231
+            //
+            //     Pattern would be:
+            //     /dir/of/editorconfig/file[double_star]/[section] if section does not contain '/',
+            //     /dir/of/editorconfig/file[section] if section starts with a '/', or
+            //     /dir/of/editorconfig/file/[section] if section contains '/' but does not start with '/'.
+
+            if (!sectionName.Contains("/"))
+            {
+                sb.Append(".*/");
+            }
+            else if (sectionName[0] != '/')
+            {
+                sb.Append('/');
+            }
+
+            var lexer = new SectionNameLexer(sectionName);
+            var numberRangePairs = new List<(int minValue, int maxValue)>();
+            if (!TryCompilePathList(ref lexer, sb, parsingChoice: false, numberRangePairs))
+            {
+                numberRangePairs.Clear();
+                return null;
+            }
+            sb.Append('$');
+
+
+            var imArray = ImmutableArray.CreateBuilder<(int, int)>(numberRangePairs is null ? 0 : numberRangePairs.Count);
+            if (numberRangePairs?.Count > 0)
+            {
+                imArray.AddRange(numberRangePairs);
+            }
+
+            return new SectionNameMatcher(
+                new Regex(sb.ToString(), RegexOptions.Compiled),
+                imArray.ToImmutableArray());
+        }
+
+        internal static string UnescapeSectionName(string sectionName)
+        {
+            var sb = new StringBuilder();
+            SectionNameLexer lexer = new SectionNameLexer(sectionName);
+            while (!lexer.IsDone)
+            {
+                var tokenKind = lexer.Lex();
+                if (tokenKind == TokenKind.SimpleCharacter)
+                {
+                    sb.Append(lexer.EatCurrentCharacter());
+                }
+                else
+                {
+                    // We only call this on strings that were already passed through IsAbsoluteEditorConfigPath, so
+                    // we shouldn't have any other token kinds here.
+                    throw new Exception("my new exception");
+                }
+            }
+            return sb.ToString();
+        }
+
+        internal static bool IsAbsoluteEditorConfigPath(string sectionName)
+        {
+            // NOTE: editorconfig paths must use '/' as a directory separator character on all OS.
+
+            // on all unix systems this is thus a simple test: does the path start with '/'
+            // and contain no special chars?
+
+            // on windows, a path can be either drive rooted or not (e.g. start with 'c:' or just '')
+            // in addition to being absolute or relative.
+            // for example c:myfile.cs is a relative path, but rooted on drive c:
+            // /myfile2.cs is an absolute path but rooted to the current drive.
+
+            // in addition there are UNC paths and volume guids (see https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats)
+            // but these start with \\ (and thus '/' in editor config terminology)
+
+            // in this implementation we choose to ignore the drive root for the purposes of
+            // determining validity. On windows c:/file.cs and /file.cs are both assumed to be
+            // valid absolute paths, even though the second one is technically relative to
+            // the current drive of the compiler working directory. 
+
+            // Note that this check has no impact on config correctness. Files on windows
+            // will still be compared using their full path (including drive root) so it's
+            // not possible to target the wrong file. It's just possible that the user won't
+            // receive a warning that this section is ignored on windows in this edge case.
+
+            SectionNameLexer nameLexer = new SectionNameLexer(sectionName);
+            bool sawStartChar = false;
+            int logicalIndex = 0;
+            while (!nameLexer.IsDone)
+            {
+                if (nameLexer.Lex() != TokenKind.SimpleCharacter)
+                {
+                    return false;
+                }
+                var simpleChar = nameLexer.EatCurrentCharacter();
+
+                // check the path starts with '/'
+                if (logicalIndex == 0)
+                {
+                    if (simpleChar == '/')
+                    {
+                        sawStartChar = true;
+                    }
+                    else if (Path.DirectorySeparatorChar == '/')
+                    {
+                        return false;
+                    }
+                }
+                // on windows we get a second chance to find the start char
+                else if (!sawStartChar && Path.DirectorySeparatorChar == '\\')
+                {
+                    if (logicalIndex == 1 && simpleChar != ':')
+                    {
+                        return false;
+                    }
+                    else if (logicalIndex == 2)
+                    {
+                        if (simpleChar != '/')
+                        {
+                            return false;
+                        }
+                        else
+                        {
+                            sawStartChar = true;
+                        }
+                    }
+                }
+                logicalIndex++;
+            }
+            return sawStartChar;
+        }
+
+
+        /// <summary>
+        /// <![CDATA[
+        /// <path-list> ::= <path-item> | <path-item> <path-list>
+        /// <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+        /// <char> ::= any unicode character
+        /// <choice> ::= "{" <choice-list> "}"
+        /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+        /// ]]>
+        /// </summary>
+        private static bool TryCompilePathList(
+            ref SectionNameLexer lexer,
+            StringBuilder sb,
+            bool parsingChoice,
+            List<(int minValue, int maxValue)> numberRangePairs)
+        {
+            while (!lexer.IsDone)
+            {
+                var tokenKind = lexer.Lex();
+                switch (tokenKind)
+                {
+                    case TokenKind.BadToken:
+                        // Parsing failure
+                        return false;
+                    case TokenKind.SimpleCharacter:
+                        // Matches just this character
+                        sb.Append(Regex.Escape(lexer.EatCurrentCharacter().ToString()));
+                        break;
+                    case TokenKind.Question:
+                        // '?' matches any single character
+                        sb.Append('.');
+                        break;
+                    case TokenKind.Star:
+                        // Matches any string of characters except directory separator
+                        // Directory separator is defined in editorconfig spec as '/'
+                        sb.Append("[^/]*");
+                        break;
+                    case TokenKind.StarStar:
+                        // Matches any string of characters
+                        sb.Append(".*");
+                        break;
+                    case TokenKind.OpenCurly:
+                        // Back up token stream. The following helpers all expect a '{'
+                        lexer.Position--;
+                        // This is ambiguous between {num..num} and {item1,item2}
+                        // We need to look ahead to disambiguate. Looking for {num..num}
+                        // is easier because it can't be recursive.
+                        (string numStart, string numEnd)? rangeOpt = TryParseNumberRange(ref lexer);
+                        if (rangeOpt is null)
+                        {
+                            // Not a number range. Try a choice expression
+                            if (!TryCompileChoice(ref lexer, sb, numberRangePairs))
+                            {
+                                return false;
+                            }
+                            // Keep looping. There may be more after the '}'.
+                            break;
+                        }
+                        else
+                        {
+                            (string numStart, string numEnd) = rangeOpt.GetValueOrDefault();
+                            if (int.TryParse(numStart, out var intStart) && int.TryParse(numEnd, out var intEnd))
+                            {
+                                var pair = intStart < intEnd ? (intStart, intEnd) : (intEnd, intStart);
+                                numberRangePairs.Add(pair);
+                                // Group allowing any digit sequence. The validity will be checked outside of the regex
+                                sb.Append("(-?[0-9]+)");
+                                // Keep looping
+                                break;
+                            }
+                            return false;
+                        }
+                    case TokenKind.CloseCurly:
+                        // Either the end of a choice, or a failed parse
+                        return parsingChoice;
+                    case TokenKind.Comma:
+                        // The end of a choice section, or a failed parse
+                        return parsingChoice;
+                    case TokenKind.OpenBracket:
+                        sb.Append('[');
+                        if (!TryCompileCharacterClass(ref lexer, sb))
+                        {
+                            return false;
+                        }
+                        break;
+                    default:
+                        throw new Exception("Exception from Matcher");
+                }
+            }
+            // If we're parsing a choice we should not exit without a closing '}'
+            return !parsingChoice;
+        }
+
+        /// <summary>
+        /// Compile a globbing character class of the form [...]. Returns true if
+        /// the character class was successfully compiled. False if there was a syntax
+        /// error. The starting character is expected to be directly after the '['.
+        /// </summary>
+        private static bool TryCompileCharacterClass(ref SectionNameLexer lexer, StringBuilder sb)
+        {
+            // [...] should match any of the characters in the brackets, with special
+            // behavior for four characters: '!' immediately after the opening bracket
+            // implies the negation of the character class, '-' implies matching
+            // between the locale-dependent range of the previous and next characters,
+            // '\' escapes the following character, and ']' ends the range
+            if (!lexer.IsDone && lexer.CurrentCharacter == '!')
+            {
+                sb.Append('^');
+                lexer.Position++;
+            }
+            while (!lexer.IsDone)
+            {
+                var currentChar = lexer.EatCurrentCharacter();
+                switch (currentChar)
+                {
+                    case '-':
+                        // '-' means the same thing in regex as it does in the glob, so
+                        // put it in verbatim
+                        sb.Append(currentChar);
+                        break;
+
+                    case '\\':
+                        // Escape the next char
+                        if (lexer.IsDone)
+                        {
+                            return false;
+                        }
+                        sb.Append('\\');
+                        sb.Append(lexer.EatCurrentCharacter());
+                        break;
+
+                    case ']':
+                        sb.Append(currentChar);
+                        return true;
+
+                    default:
+                        sb.Append(Regex.Escape(currentChar.ToString()));
+                        break;
+                }
+            }
+            // Stream ended without a closing bracket
+            return false;
+        }
+
+        /// <summary>
+        /// Parses choice defined by the following grammar:
+        /// <![CDATA[
+        /// <choice> ::= "{" <choice-list> "}"
+        /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+        /// ]]>
+        /// </summary>
+        private static bool TryCompileChoice(
+            ref SectionNameLexer lexer,
+            StringBuilder sb,
+            List<(int, int)> numberRangePairs)
+        {
+            if (lexer.Lex() != TokenKind.OpenCurly)
+            {
+                return false;
+            }
+
+            // Start a non-capturing group for the choice
+            sb.Append("(?:");
+
+            // We start immediately after a '{'
+            // Try to compile the nested <path-list>
+            while (TryCompilePathList(ref lexer, sb, parsingChoice: true, numberRangePairs))
+            {
+                // If we've successfully compiled a <path-list> the last token should
+                // have been a ',' or a '}'
+                char lastChar = lexer[lexer.Position - 1];
+                if (lastChar == ',')
+                {
+                    // Another option
+                    sb.Append('|');
+                }
+                else if (lastChar == '}')
+                {
+                    // Close out the capture group
+                    sb.Append(')');
+                    return true;
+                }
+                else
+                {
+                    throw new Exception("Exception another one");
+                }
+            }
+
+            // Propagate failure
+            return false;
+        }
+
+        /// <summary>
+        /// Parses range defined by the following grammar.
+        /// <![CDATA[
+        /// <range> ::= "{" <integer> ".." <integer> "}"
+        /// <integer> ::= "-" <digit-list> | <digit-list>
+        /// <digit-list> ::= <digit> | <digit> <digit-list>
+        /// <digit> ::= 0-9
+        /// ]]>
+        /// </summary>
+        private static (string numStart, string numEnd)? TryParseNumberRange(ref SectionNameLexer lexer)
+        {
+            var saved = lexer.Position;
+            if (lexer.Lex() != TokenKind.OpenCurly)
+            {
+                lexer.Position = saved;
+                return null;
+            }
+
+            var numStart = lexer.TryLexNumber();
+            if (numStart is null)
+            {
+                // Not a number
+                lexer.Position = saved;
+                return null;
+            }
+
+            // The next two characters must be ".."
+            if (!lexer.TryEatCurrentCharacter(out char c) || c != '.' ||
+                !lexer.TryEatCurrentCharacter(out c) || c != '.')
+            {
+                lexer.Position = saved;
+                return null;
+            }
+
+            // Now another number
+            var numEnd = lexer.TryLexNumber();
+            if (numEnd is null || lexer.IsDone || lexer.Lex() != TokenKind.CloseCurly)
+            {
+                // Not a number or no '}'
+                lexer.Position = saved;
+                return null;
+            }
+
+            return (numStart, numEnd);
+        }
+
+        private struct SectionNameLexer
+        {
+            private readonly string _sectionName;
+
+            public int Position { get; set; }
+
+            public SectionNameLexer(string sectionName)
+            {
+                _sectionName = sectionName;
+                Position = 0;
+            }
+
+            public bool IsDone => Position >= _sectionName.Length;
+
+            public TokenKind Lex()
+            {
+                int lexemeStart = Position;
+                switch (_sectionName[Position])
+                {
+                    case '*':
+                        {
+                            int nextPos = Position + 1;
+                            if (nextPos < _sectionName.Length &&
+                                _sectionName[nextPos] == '*')
+                            {
+                                Position += 2;
+                                return TokenKind.StarStar;
+                            }
+                            else
+                            {
+                                Position++;
+                                return TokenKind.Star;
+                            }
+                        }
+
+                    case '?':
+                        Position++;
+                        return TokenKind.Question;
+
+                    case '{':
+                        Position++;
+                        return TokenKind.OpenCurly;
+
+                    case ',':
+                        Position++;
+                        return TokenKind.Comma;
+
+                    case '}':
+                        Position++;
+                        return TokenKind.CloseCurly;
+
+                    case '[':
+                        Position++;
+                        return TokenKind.OpenBracket;
+
+                    case '\\':
+                        {
+                            // Backslash escapes the next character
+                            Position++;
+                            if (IsDone)
+                            {
+                                return TokenKind.BadToken;
+                            }
+
+                            return TokenKind.SimpleCharacter;
+                        }
+
+                    default:
+                        // Don't increment position, since caller needs to fetch the character
+                        return TokenKind.SimpleCharacter;
+                }
+            }
+
+            public char CurrentCharacter => _sectionName[Position];
+
+            /// <summary>
+            /// Call after getting <see cref="TokenKind.SimpleCharacter" /> from <see cref="Lex()" />
+            /// </summary>
+            public char EatCurrentCharacter() => _sectionName[Position++];
+
+            /// <summary>
+            /// Returns false if there are no more characters in the lex stream.
+            /// Otherwise, produces the next character in the stream and returns true.
+            /// </summary>
+            public bool TryEatCurrentCharacter(out char nextChar)
+            {
+                if (IsDone)
+                {
+                    nextChar = default;
+                    return false;
+                }
+                else
+                {
+                    nextChar = EatCurrentCharacter();
+                    return true;
+                }
+            }
+
+            public char this[int position] => _sectionName[position];
+
+            /// <summary>
+            /// Returns the string representation of a decimal integer, or null if
+            /// the current lexeme is not an integer.
+            /// </summary>
+            public string? TryLexNumber()
+            {
+                bool start = true;
+                var sb = new StringBuilder();
+
+                while (!IsDone)
+                {
+                    char currentChar = CurrentCharacter;
+                    if (start && currentChar == '-')
+                    {
+                        Position++;
+                        sb.Append('-');
+                    }
+                    else if (char.IsDigit(currentChar))
+                    {
+                        Position++;
+                        sb.Append(currentChar);
+                    }
+                    else
+                    {
+                        break;
+                    }
+                    start = false;
+                }
+
+                var str = sb.ToString();
+                return str.Length == 0 || str == "-"
+                    ? null
+                    : str;
+            }
+        }
+
+        private enum TokenKind
+        {
+            BadToken,
+            SimpleCharacter,
+            Star,
+            StarStar,
+            Question,
+            OpenCurly,
+            CloseCurly,
+            Comma,
+            DoubleDot,
+            OpenBracket,
+        }
+    }
+}
diff --git a/src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigParser.cs
new file mode 100644
index 00000000000..8e1c77fb82b
--- /dev/null
+++ b/src/Build/BuildCop/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -0,0 +1,86 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Drawing.Design;
+using System.IO;
+using System.Linq;
+using System.Reflection.Metadata.Ecma335;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Shared;
+using static Microsoft.Build.BuildCop.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
+
+namespace Microsoft.Build.BuildCop.Infrastructure.EditorConfig
+{
+    public class EditorConfigParser : IEditorConfigParser
+    {
+        private const string EditorconfigFile = ".editorconfig";
+        private Dictionary<string, Dictionary<string, string>> filePathConfigCache;
+
+        internal EditorConfigParser()
+        {
+            filePathConfigCache = new Dictionary<string, Dictionary<string, string>>();
+        }
+
+        public Dictionary<string, string> Parse(string filePath)
+        {
+            if (filePathConfigCache.ContainsKey(filePath))
+            {
+                return filePathConfigCache[filePath];
+            }
+
+            var editorConfigDataFromFilesList = new List<EditorConfigFile>();
+            var directoryOfTheProject = Path.GetDirectoryName(filePath);
+            var editorConfigFile = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);
+
+            while (editorConfigFile != string.Empty)
+            {
+                var editorConfigData = EditorConfigFile.Parse(editorConfigFile);
+                editorConfigDataFromFilesList.Add(editorConfigData);
+
+                if (editorConfigData.IsRoot)
+                {
+                    break;
+                }
+                else
+                {
+                    editorConfigFile = FileUtilities.GetPathOfFileAbove(EditorconfigFile, Path.GetDirectoryName(Path.GetDirectoryName(editorConfigFile)));
+                }
+            }
+
+            var resultingDictionary = new Dictionary<string, string>();
+
+            if (editorConfigDataFromFilesList.Any())
+            {
+                editorConfigDataFromFilesList.Reverse();
+                
+                foreach (var configData in editorConfigDataFromFilesList)
+                {
+                    foreach (var section in configData.NamedSections)
+                    {
+                        SectionNameMatcher? sectionNameMatcher = TryCreateSectionNameMatcher(section.Name);
+                        if (sectionNameMatcher != null)
+                        {
+                            if (sectionNameMatcher.Value.IsMatch(NormalizeWithForwardSlash(filePath)))
+                            {
+                                foreach (var property in section.Properties)
+                                {
+                                    resultingDictionary[property.Key] = property.Value;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            filePathConfigCache[filePath] = resultingDictionary;
+            return resultingDictionary;
+        }
+
+        private string NormalizeWithForwardSlash(string p) => Path.DirectorySeparatorChar == '/' ? p : p.Replace(Path.DirectorySeparatorChar, '/');
+    }
+
+}
diff --git a/src/Build/BuildCop/Infrastructure/EditorConfig/IEditorConfigParser.cs b/src/Build/BuildCop/Infrastructure/EditorConfig/IEditorConfigParser.cs
new file mode 100644
index 00000000000..c0c3c510897
--- /dev/null
+++ b/src/Build/BuildCop/Infrastructure/EditorConfig/IEditorConfigParser.cs
@@ -0,0 +1,16 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.BuildCop.Infrastructure.EditorConfig
+{
+    public interface IEditorConfigParser
+    {
+        Dictionary<string, string> Parse(string filePath);
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 024368af5f9..79128da19aa 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -176,6 +176,10 @@
     <Compile Include="BuildCop\Infrastructure\BuildCopManagerProvider.cs" />
     <Compile Include="BuildCop\Infrastructure\ConfigurationProvider.cs" />
     <Compile Include="BuildCop\Infrastructure\CustomConfigurationData.cs" />
+    <Compile Include="BuildCop\Infrastructure\EditorConfig\EditorConfigFile.cs" />
+    <Compile Include="BuildCop\Infrastructure\EditorConfig\EditorConfigGlobsMatcher.cs" />
+    <Compile Include="BuildCop\Infrastructure\EditorConfig\EditorConfigParser.cs" />
+    <Compile Include="BuildCop\Infrastructure\EditorConfig\IEditorConfigParser.cs" />
     <Compile Include="BuildCop\Infrastructure\IBuildCopContext.cs" />
     <Compile Include="BuildCop\Infrastructure\IBuildCopManager.cs" />
     <Compile Include="BuildCop\Logging\IBuildAnalysisLoggingContext.cs" />
