diff --git a/ref/net46/Microsoft.Build/Microsoft.Build.cs b/ref/net46/Microsoft.Build/Microsoft.Build.cs
index 625e783443e..2691ff79898 100644
--- a/ref/net46/Microsoft.Build/Microsoft.Build.cs
+++ b/ref/net46/Microsoft.Build/Microsoft.Build.cs
@@ -987,8 +987,10 @@ public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstanc
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) { }
+        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
         public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
+        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
         public string ExplicitlySpecifiedToolsVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Execution.BuildRequestDataFlags Flags { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance> GlobalProperties { get { throw null; } }
@@ -996,6 +998,7 @@ public BuildRequestData(string projectFullPath, System.Collections.Generic.IDict
         public string ProjectFullPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Execution.ProjectInstance ProjectInstance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.IEnumerable<string> PropertiesToTransfer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Execution.RequestedProjectState RequestedProjectState { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<string> TargetNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     [System.FlagsAttribute]
@@ -1005,6 +1008,7 @@ public enum BuildRequestDataFlags
         IgnoreExistingProjectState = 4,
         None = 0,
         ProvideProjectStateAfterBuild = 2,
+        ProvideSubsetOfStateAfterBuild = 32,
         ReplaceExistingProjectInstance = 1,
         SkipNonexistentTargets = 16,
     }
@@ -1121,6 +1125,7 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public Microsoft.Build.Execution.ProjectInstance DeepCopy(bool isImmutable) { throw null; }
         public bool EvaluateCondition(string condition) { throw null; }
         public string ExpandString(string unexpandedValue) { throw null; }
+        public Microsoft.Build.Execution.ProjectInstance FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> GetItems(string itemType) { throw null; }
@@ -1360,6 +1365,12 @@ internal ProjectTaskOutputPropertyInstance() { }
         public string TaskParameter { get { throw null; } }
         public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
     }
+    public partial class RequestedProjectState
+    {
+        public RequestedProjectState() { }
+        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ItemFilters { get { throw null; } set { } }
+        public System.Collections.Generic.List<string> PropertyFilters { get { throw null; } set { } }
+    }
     public partial class TargetResult : Microsoft.Build.Execution.ITargetResult
     {
         internal TargetResult() { }
diff --git a/ref/netstandard1.3/Microsoft.Build/Microsoft.Build.cs b/ref/netstandard1.3/Microsoft.Build/Microsoft.Build.cs
index 05b2147ce9b..d05f691a537 100644
--- a/ref/netstandard1.3/Microsoft.Build/Microsoft.Build.cs
+++ b/ref/netstandard1.3/Microsoft.Build/Microsoft.Build.cs
@@ -964,8 +964,10 @@ public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstanc
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
         public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) { }
+        public BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
         public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) { }
         public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) { }
+        public BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) { }
         public string ExplicitlySpecifiedToolsVersion { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Execution.BuildRequestDataFlags Flags { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance> GlobalProperties { get { throw null; } }
@@ -973,6 +975,7 @@ public BuildRequestData(string projectFullPath, System.Collections.Generic.IDict
         public string ProjectFullPath { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Execution.ProjectInstance ProjectInstance { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.IEnumerable<string> PropertiesToTransfer { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Execution.RequestedProjectState RequestedProjectState { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<string> TargetNames { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
     }
     [System.FlagsAttribute]
@@ -982,6 +985,7 @@ public enum BuildRequestDataFlags
         IgnoreExistingProjectState = 4,
         None = 0,
         ProvideProjectStateAfterBuild = 2,
+        ProvideSubsetOfStateAfterBuild = 32,
         ReplaceExistingProjectInstance = 1,
         SkipNonexistentTargets = 16,
     }
@@ -1098,6 +1102,7 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public Microsoft.Build.Execution.ProjectInstance DeepCopy(bool isImmutable) { throw null; }
         public bool EvaluateCondition(string condition) { throw null; }
         public string ExpandString(string unexpandedValue) { throw null; }
+        public Microsoft.Build.Execution.ProjectInstance FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> GetItems(string itemType) { throw null; }
@@ -1337,6 +1342,12 @@ internal ProjectTaskOutputPropertyInstance() { }
         public string TaskParameter { get { throw null; } }
         public override Microsoft.Build.Construction.ElementLocation TaskParameterLocation { get { throw null; } }
     }
+    public partial class RequestedProjectState
+    {
+        public RequestedProjectState() { }
+        public System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>> ItemFilters { get { throw null; } set { } }
+        public System.Collections.Generic.List<string> PropertyFilters { get { throw null; } set { } }
+    }
     public partial class TargetResult : Microsoft.Build.Execution.ITargetResult
     {
         internal TargetResult() { }
diff --git a/setup/MsBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/setup/MsBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index cbbd96a6398..c3de56bb5e5 100644
--- a/setup/MsBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/setup/MsBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -30,10 +30,8 @@
     <file src="$X86BinPath$/Microsoft.Build.Tasks.Core.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/System.Diagnostics.Process.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.IO.Compression.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Runtime.InteropServices.RuntimeInformation.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/System.Security.Cryptography.Algorithms.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin" />
 
     <file src="$X86BinPath$/Microsoft.Build.Core.xsd" target="v15.0/bin/MSBuild" />
@@ -74,10 +72,8 @@
     <file src="$X86BinPath$/Microsoft.Build.Tasks.Core.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin" />
-    <file src="$X86BinPath$/System.Diagnostics.Process.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.IO.Compression.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Runtime.InteropServices.RuntimeInformation.dll" target="v15.0/bin/amd64" />
-    <file src="$X86BinPath$/System.Security.Cryptography.Algorithms.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Threading.Tasks.Dataflow.dll" target="v15.0/bin/amd64" />
 
     <file src="$X86BinPath$/Microsoft.Build.Core.xsd" target="v15.0/bin/amd64/MSBuild" />
diff --git a/src/Build.OM.UnitTests/Construction/ProjectSdkImplicitImport_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectSdkImplicitImport_Tests.cs
index 9814abc899f..7d773a354b0 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectSdkImplicitImport_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectSdkImplicitImport_Tests.cs
@@ -6,11 +6,14 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Reflection;
 using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.OM.Construction
@@ -25,12 +28,23 @@ public class ProjectSdkImplicitImport_Tests : IDisposable
   {1}
 </Project>";
 
+        private const string ProjectTemplateSdkAsAttributeWithVersion = @"
+<Project Sdk=""{0}/{2}"">
+  {1}
+</Project>";
+
         private const string ProjectTemplateSdkAsElement = @"
 <Project>
   <Sdk Name=""{0}"" />
   {1}
 </Project>";
 
+        private const string ProjectTemplateSdkAsElementWithVersion = @"
+<Project>
+  <Sdk Name=""{0}"" Version=""{2}"" MinimumVersion=""{3}""/>
+  {1}
+</Project>";
+
         private const string ProjectTemplateSdkAsExplicitImport = @"
 <Project>
   <Import Project=""Sdk.props"" Sdk=""{0}"" />
@@ -38,6 +52,13 @@ public class ProjectSdkImplicitImport_Tests : IDisposable
   <Import Project=""Sdk.targets"" Sdk=""{0}"" />
 </Project>";
 
+        private const string ProjectTemplateSdkAsExplicitImportWithVersion = @"
+<Project>
+  <Import Project=""Sdk.props"" Sdk=""{0}"" Version=""{2}"" MinimumVersion=""{3}"" />
+  {1}
+  <Import Project=""Sdk.targets"" Sdk=""{0}"" Version=""{2}"" MinimumVersion=""{3}"" />
+</Project>";
+
         private const string SdkName = "MSBuildUnitTestSdk";
         private TestEnvironment _env;
         private readonly string _testSdkRoot;
@@ -381,6 +402,39 @@ public void ProjectWithEmptySdkNameInValidList()
             Assert.Equal("MSB4229", exception.ErrorCode);
         }
 
+        [Theory]
+        // MinimumVersion & Version not supported in SDK attribute at the same time
+        [InlineData(ProjectTemplateSdkAsAttributeWithVersion, "1.0.0", null)]
+        [InlineData(ProjectTemplateSdkAsAttributeWithVersion, "min=1.0.0", "1.0.0")]
+
+        [InlineData(ProjectTemplateSdkAsElementWithVersion, "1.0.0", "1.0.0")]
+        [InlineData(ProjectTemplateSdkAsExplicitImportWithVersion, "1.0.0", "1.0.0")]
+        public void SdkImportsSupportVersion(string projectFormatString, string sdkVersion, string minimumSdkVersion)
+        {
+            _env.SetEnvironmentVariable("MSBuildSDKsPath", _testSdkRoot);
+            string projectInnerContents = @"<PropertyGroup><UsedToTestIfImplicitImportsAreInTheCorrectLocation>null</UsedToTestIfImplicitImportsAreInTheCorrectLocation></PropertyGroup>";
+            File.WriteAllText(_sdkPropsPath, "<Project><PropertyGroup><InitialImportProperty>Hello</InitialImportProperty></PropertyGroup></Project>");
+            File.WriteAllText(_sdkTargetsPath, "<Project><PropertyGroup><FinalImportProperty>World</FinalImportProperty></PropertyGroup></Project>");
+
+            string content = string.Format(projectFormatString, SdkName, projectInnerContents, sdkVersion, minimumSdkVersion);
+
+            ProjectRootElement projectRootElement = ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
+            var project = new Project(projectRootElement);
+            project.Imports.Count.ShouldBe(2);
+            var importElement = project.Imports[0].ImportingElement;
+            var sdk = GetParsedSdk(importElement);
+
+            if (sdkVersion.StartsWith("min="))
+            {
+                // Ignore version when min= string is specified
+                sdkVersion = null;
+            }
+
+            sdk.Name.ShouldBe(SdkName);
+            sdk.Version.ShouldBe(sdkVersion);
+            sdk.MinimumVersion.ShouldBe(minimumSdkVersion);
+        }
+
         public void Dispose()
         {
             _env.Dispose();
@@ -398,5 +452,11 @@ private void VerifyPropertyFromImplicitImport(Project project, string propertyNa
 
             Assert.Equal(expectedValue, property.EvaluatedValue);
         }
+
+        private SdkReference GetParsedSdk(ProjectImportElement element)
+        {
+            PropertyInfo parsedSdkInfo = typeof(ProjectImportElement).GetProperty("ParsedSdkReference", BindingFlags.Instance | BindingFlags.NonPublic);
+            return (SdkReference)parsedSdkInfo.GetValue(element);
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 80f17420d96..1932db3bd7a 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -26,7 +26,7 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
-
+using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
 using static Microsoft.Build.UnitTests.ObjectModelHelpers;
@@ -340,6 +340,95 @@ public void RunOutOfProcBuild(Action<BuildParameters> buildParametersModifier)
             Assert.NotEqual(Process.GetCurrentProcess().Id, processId); // "Build is expected to be out-of-proc. In fact it was in-proc."
         }
 
+        [Fact]
+        public void RequestedResultsAreSatisfied()
+        {
+            const string contents = @"
+<Project xmlns='msbuildnamespace' ToolsVersion='msbuilddefaulttoolsversion'>
+<PropertyGroup>
+  <UnrequestedProperty>IsUnrequested</UnrequestedProperty>
+  <RequestedProperty>IsRequested</RequestedProperty>
+  <UpdatedProperty>Stale</UpdatedProperty>
+</PropertyGroup>
+<ItemGroup>
+  <AnItem Include='Item1' UnexpectedMetadatum='Unexpected' />
+  <AnItem Include='Item2'/>
+</ItemGroup>
+<Target Name='test' Returns='@(ItemWithMetadata)'>
+  <ItemGroup>
+    <AnItem Include='$([System.Diagnostics.Process]::GetCurrentProcess().Id)' />
+    <ItemWithMetadata Metadatum1='m1' Metadatum2='m2' Include='ItemFromTarget' />
+  </ItemGroup>
+  <PropertyGroup>
+    <NewProperty>FunValue</NewProperty>
+    <UpdatedProperty>Updated</UpdatedProperty>
+  </PropertyGroup>
+  <Message Text='[success]'/>
+</Target>
+
+<Target Name='other' Returns='@(ItemWithMetadata)' DependsOnTargets='test' />
+
+</Project>
+";
+
+            // Need to set this env variable to enable Process.GetCurrentProcess().Id in the project file.
+            _env.SetEnvironmentVariable("MSBUILDENABLEALLPROPERTYFUNCTIONS", "1");
+
+            Project project = CreateProject(CleanupFileContents(contents), MSBuildDefaultToolsVersion,
+                _projectCollection, false);
+
+            var requestedProjectState = new RequestedProjectState
+            {
+                ItemFilters = new Dictionary<string, List<string>>
+                {
+                    {"AnItem", null},
+                    {"ItemWithMetadata", new List<string> {"Metadatum1"}},
+                },
+                PropertyFilters = new List<string> {"NewProperty", "RequestedProperty"},
+            };
+
+            BuildRequestData data = new BuildRequestData(project.CreateProjectInstance(), new [] {"test", "other"},
+                _projectCollection.HostServices, BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild, null,
+                requestedProjectState);
+            BuildParameters customparameters = new BuildParameters
+            {
+                EnableNodeReuse = false,
+                Loggers = new ILogger[] {_logger},
+                DisableInProcNode = true,
+            };
+
+            BuildResult result = _buildManager.Build(customparameters, data);
+
+            result.OverallResult.ShouldBe(BuildResultCode.Success);
+
+            result.ProjectStateAfterBuild.ShouldNotBeNull();
+
+            result.ProjectStateAfterBuild.Properties.ShouldNotContain(p => p.Name == "UnrequestedProperty");
+
+            result.ProjectStateAfterBuild.Properties.ShouldContain(p => p.Name == "NewProperty");
+            result.ProjectStateAfterBuild.GetPropertyValue("NewProperty").ShouldBe("FunValue");
+
+            result.ProjectStateAfterBuild.Properties.ShouldContain(p => p.Name == "RequestedProperty");
+            result.ProjectStateAfterBuild.GetPropertyValue("RequestedProperty").ShouldBe("IsRequested");
+
+            result.ProjectStateAfterBuild.Items.Count.ShouldBe(4);
+
+            result.ProjectStateAfterBuild.GetItems("ItemWithMetadata").ShouldHaveSingleItem();
+            result.ProjectStateAfterBuild.GetItems("ItemWithMetadata").First().DirectMetadataCount.ShouldBe(1);
+            result.ProjectStateAfterBuild.GetItems("ItemWithMetadata").First().GetMetadataValue("Metadatum1")
+                .ShouldBe("m1");
+            result.ProjectStateAfterBuild.GetItems("ItemWithMetadata").First().GetMetadataValue("Metadatum2")
+                .ShouldBeNullOrEmpty();
+
+            result.ProjectStateAfterBuild.GetItems("AnItem").Count.ShouldBe(3);
+            result.ProjectStateAfterBuild.GetItems("AnItem").ShouldContain(p => p.EvaluatedInclude == "Item2");
+
+            result.ProjectStateAfterBuild.GetItemsByItemTypeAndEvaluatedInclude("AnItem", "Item1")
+                .ShouldHaveSingleItem();
+            result.ProjectStateAfterBuild.GetItemsByItemTypeAndEvaluatedInclude("AnItem", "Item1").First()
+                .GetMetadataValue("UnexpectedMetadatum").ShouldBe("Unexpected");
+        }
+
         /// <summary>
         /// Make sure when we are doing an in-process build that even if the environment variable MSBUILDFORWARDPROPERTIESFROMCHILD is set that we still 
         /// get all of the initial properties.
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index 4a48395a04c..976d244ef7f 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -422,14 +422,18 @@ public void LogBuildFinished(bool success)
         {
         }
 
-        /// <summary>
-        /// Logs a project evaluation started event
-        /// </summary>
-        public BuildEventContext LogProjectEvaluationStarted(int nodeId, int submissionId, string projectFile)
+
+        /// <inheritdoc />
+        public BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId)
         {
             return new BuildEventContext(0, 0, 0, 0, 0, 0, 0);
         }
 
+        /// <inheritdoc />
+        public void LogProjectEvaluationStarted(BuildEventContext eventContext, string projectFile)
+        {
+        }
+
         /// <summary>
         /// Logs a project evaluation finished event
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
index 7e25fa8c93d..5f9c20258a2 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverLoader_Tests.cs
@@ -1,29 +1,39 @@
-﻿using Shouldly;
+﻿using System;
+using System.Collections.Generic;
+using Shouldly;
 using System.IO;
 using System.Linq;
-using System.Text;
+using System.Reflection;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
-using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
+using Exception = System.Exception;
+using SdkResolverBase = Microsoft.Build.Framework.SdkResolver;
+using SdkResolverContextBase = Microsoft.Build.Framework.SdkResolverContext;
+using SdkResultBase = Microsoft.Build.Framework.SdkResult;
+using SdkResultFactoryBase = Microsoft.Build.Framework.SdkResultFactory;
 
 namespace Microsoft.Build.Engine.UnitTests.BackEnd
 {
     public class SdkResolverLoader_Tests
     {
-        private readonly StringBuilder _log;
-        private readonly MockLoggingContext _loggingContext;
+        private readonly MockLogger _logger;
+        private readonly LoggingContext _loggingContext;
 
         public SdkResolverLoader_Tests()
         {
-            _log = new StringBuilder();
+            _logger = new MockLogger();
+            ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            loggingService.RegisterLogger(_logger);
 
-            var logger = new MockLoggingService(message => _log.AppendLine(message));
-            var bec = new BuildEventContext(0, 0, 0, 0, 0);
-
-            _loggingContext = new MockLoggingContext(logger, bec);
+            _loggingContext = new MockLoggingContext(
+                loggingService,
+                new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
         }
 
         [Fact]
@@ -34,6 +44,9 @@ public void AssertDefaultLoaderReturnsDefaultResolvers()
             var resolvers = loader.LoadResolvers(_loggingContext, new MockElementLocation("file"));
 
             resolvers.Select(i => i.GetType()).ShouldBe(new [] { typeof(DefaultSdkResolver) });
+
+            _logger.ErrorCount.ShouldBe(0);
+            _logger.WarningCount.ShouldBe(0);
         }
 
         [Fact]
@@ -70,5 +83,176 @@ public void VerifySdkResolverLoaderFileDiscoveryPattern()
                 FileUtilities.DeleteDirectoryNoThrow(root, true);
             }
         }
+
+        /// <summary>
+        /// Verifies that if an SDK resolver throws while creating an instance that a warning is logged.
+        /// </summary>
+        [Fact]
+        public void VerifyThrowsWhenResolverFailsToLoad()
+        {
+            SdkResolverLoader sdkResolverLoader = new MockSdkResolverLoader
+            {
+                LoadResolverAssemblyFunc = (resolverPath, loggingContext, location) => typeof(SdkResolverLoader_Tests).GetTypeInfo().Assembly,
+                FindPotentialSdkResolversFunc = rootFolder => new List<string>
+                {
+                    "myresolver.dll"
+                },
+                GetResolverTypesFunc = assembly => new[] { typeof(MockSdkResolverThatDoesNotLoad) }
+            };
+
+            InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
+            {
+                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+            });
+
+            exception.Message.ShouldBe($"The SDK resolver type \"{nameof(MockSdkResolverThatDoesNotLoad)}\" failed to load. A8BB8B3131D3475D881ACD3AF8D75BD6");
+
+            Exception innerException = exception.InnerException.ShouldBeOfType<Exception>();
+
+            innerException.Message.ShouldBe(MockSdkResolverThatDoesNotLoad.ExpectedMessage);
+
+            _logger.WarningCount.ShouldBe(0);
+            _logger.ErrorCount.ShouldBe(0);
+        }
+
+        /// <summary>
+        /// Verifies that when we attempt to create an instance of a resolver with no public constructor that a warning
+        /// is logged with the appropriate message.
+        /// </summary>
+        [Fact]
+        public void VerifyThrowsWhenResolverHasNoPublicConstructor()
+        {
+            SdkResolverLoader sdkResolverLoader = new MockSdkResolverLoader
+            {
+                LoadResolverAssemblyFunc = (resolverPath, loggingContext, location) => typeof(SdkResolverLoader_Tests).GetTypeInfo().Assembly,
+                FindPotentialSdkResolversFunc = rootFolder => new List<string>
+                {
+                    "myresolver.dll"
+                },
+                GetResolverTypesFunc = assembly => new[] { typeof(MockSdkResolverNoPublicConstructor) }
+            };
+
+            InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
+            {
+                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+            });
+
+            exception.Message.ShouldBe($"The SDK resolver type \"{nameof(MockSdkResolverNoPublicConstructor)}\" failed to load. No parameterless constructor defined for this object.");
+
+            exception.InnerException.ShouldBeOfType<MissingMethodException>();
+
+            _logger.WarningCount.ShouldBe(0);
+            _logger.ErrorCount.ShouldBe(0);
+        }
+
+        /// <summary>
+        /// Verifies that when a resolver assembly cannot be loaded, that a warning is logged and other resolvers are still loaded.
+        /// </summary>
+        [Fact]
+        public void VerifyWarningLoggedWhenResolverAssemblyCannotBeLoaded()
+        {
+            const string assemblyPath = @"C:\foo\bar\myresolver.dll";
+            const string expectedMessage = "91BF077D4E9646819DE7AB2CBA2637B6";
+
+            SdkResolverLoader sdkResolverLoader = new MockSdkResolverLoader
+            {
+                LoadResolverAssemblyFunc = (resolverPath, loggingContext, location) =>
+                {
+                    throw new Exception(expectedMessage);
+                },
+                FindPotentialSdkResolversFunc = rootFolder => new List<string>
+                {
+                    assemblyPath,
+                }
+            };
+
+            InvalidProjectFileException exception = Should.Throw<InvalidProjectFileException>(() =>
+            {
+                sdkResolverLoader.LoadResolvers(_loggingContext, ElementLocation.EmptyLocation);
+            });
+
+            exception.Message.ShouldBe($"The SDK resolver assembly \"{assemblyPath}\" could not be loaded. {expectedMessage}");
+
+            Exception innerException = exception.InnerException.ShouldBeOfType<Exception>();
+
+            innerException.Message.ShouldBe(expectedMessage);
+
+            _logger.WarningCount.ShouldBe(0);
+            _logger.ErrorCount.ShouldBe(0);
+        }
+
+        private class MockSdkResolverThatDoesNotLoad : SdkResolverBase
+        {
+            public const string ExpectedMessage = "A8BB8B3131D3475D881ACD3AF8D75BD6";
+
+            public MockSdkResolverThatDoesNotLoad()
+            {
+                throw new Exception(ExpectedMessage);
+            }
+
+            public override string Name => nameof(MockSdkResolverThatDoesNotLoad);
+
+            public override int Priority => 0;
+
+            public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                throw new NotImplementedException();
+            }
+        }
+
+        private class MockSdkResolverNoPublicConstructor : SdkResolverBase
+        {
+            private MockSdkResolverNoPublicConstructor()
+            {
+            }
+
+            public override string Name => nameof(MockSdkResolverNoPublicConstructor);
+
+            public override int Priority => 0;
+
+            public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverContextBase resolverContext, SdkResultFactoryBase factory)
+            {
+                throw new NotImplementedException();
+            }
+        }
+
+        private class MockSdkResolverLoader : SdkResolverLoader
+        {
+            public Func<string, LoggingContext, ElementLocation, Assembly> LoadResolverAssemblyFunc { get; set; }
+
+            public Func<string, IList<string>> FindPotentialSdkResolversFunc { get; set; }
+
+            public Func<Assembly, IEnumerable<Type>> GetResolverTypesFunc { get; set; }
+
+            protected override Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location)
+            {
+                if (LoadResolverAssemblyFunc != null)
+                {
+                    return LoadResolverAssemblyFunc(resolverPath, loggingContext, location);
+                }
+
+                return base.LoadResolverAssembly(resolverPath, loggingContext, location);
+            }
+
+            protected override IEnumerable<Type> GetResolverTypes(Assembly assembly)
+            {
+                if (GetResolverTypesFunc != null)
+                {
+                    return GetResolverTypesFunc(assembly);
+                }
+
+                return base.GetResolverTypes(assembly);
+            }
+
+            internal override IList<string> FindPotentialSdkResolvers(string rootFolder)
+            {
+                if (FindPotentialSdkResolversFunc != null)
+                {
+                    return FindPotentialSdkResolversFunc(rootFolder);
+                }
+
+                return base.FindPotentialSdkResolvers(rootFolder);
+            }
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index b079c65dc14..65f6bc56821 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -3,11 +3,9 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests;
-using Microsoft.Build.UnitTests.BackEnd;
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
 using Shouldly;
 using Xunit;
 using SdkResolverContextBase = Microsoft.Build.Framework.SdkResolverContext;
@@ -18,17 +16,18 @@ namespace Microsoft.Build.Engine.UnitTests.BackEnd
 {
     public class SdkResolverService_Tests
     {
-        private readonly StringBuilder _log;
-        private readonly MockLoggingContext _loggingContext;
+        private readonly MockLogger _logger;
+        private readonly LoggingContext _loggingContext;
 
         public SdkResolverService_Tests()
         {
-            _log = new StringBuilder();
+            _logger = new MockLogger();
+            ILoggingService loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+            loggingService.RegisterLogger(_logger);
 
-            MockLoggingService logger = new MockLoggingService(message => _log.AppendLine(message));
-            BuildEventContext bec = new BuildEventContext(0, 0, 0, 0, 0);
-
-            _loggingContext = new MockLoggingContext(logger, bec);
+            _loggingContext = new MockLoggingContext(
+                loggingService,
+                new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0, 0));
         }
 
         [Fact]
@@ -40,13 +39,12 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
 
             string result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath");
 
-            string logResult = _log.ToString();
-            Assert.Null(result);
-            Assert.Contains("MockSdkResolver1 running", logResult);
-            Assert.Contains("MockSdkResolver2 running", logResult);
-            Assert.Contains("ERROR1", logResult);
-            Assert.Contains("ERROR2", logResult);
-            Assert.Contains("WARNING2", logResult);
+            result.ShouldBeNull();
+
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver2 running");
+            _logger.Errors.Select(i => i.Message).ShouldBe(new [] { "ERROR1", "ERROR2" });
+            _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING2" });
         }
 
         [Fact]
@@ -58,8 +56,8 @@ public void AssertErrorLoggedWhenResolverThrows()
 
             string result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath");
 
-            Assert.Equal("resolverpath1", result);
-            Assert.Contains("EXMESSAGE", _log.ToString());
+            result.ShouldBe("resolverpath1");
+            _logger.Warnings.Select(i => i.Message).ShouldBe(new [] { "The SDK resolver \"MockSdkResolverThrows\" failed to run. EXMESSAGE" });
         }
 
         [Fact]
@@ -72,7 +70,7 @@ public void AssertFirstResolverCanResolve()
             string result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath");
 
             Assert.Equal("resolverpath1", result);
-            Assert.Contains("MockSdkResolver1 running", _log.ToString().Trim());
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
         }
 
         [Fact]
@@ -86,16 +84,15 @@ public void AssertFirstResolverErrorsSupressedWhenResolved()
 
             string result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath");
 
-            string logResult = _log.ToString();
-            Assert.Equal("resolverpath2", result);
+            result.ShouldBe("resolverpath2");
 
             // Both resolvers should run, and no ERROR string.
-            Assert.Contains("MockSdkResolver1 running", logResult);
-            Assert.Contains("MockSdkResolver2 running", logResult);
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
+            _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver2 running");
 
             // Resolver2 gives a warning on success or failure.
-            Assert.Contains("WARNING2", logResult);
-            Assert.DoesNotContain("ERROR", logResult);
+            _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING2" });
+            _logger.ErrorCount.ShouldBe(0);
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
index de3972975e8..7f39ad5a8bd 100644
--- a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
@@ -6,11 +6,13 @@
 //-----------------------------------------------------------------------
 
 using System;
+using System.Collections.Generic;
+using System.Diagnostics;
 using System.IO;
-using System.Linq;
 using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.Evaluation
@@ -38,7 +40,10 @@ public void Dispose()
             GC.Collect();
         }
 
-        private static void AssertLoggingEvents(Action<Project, MockLogger> loggingTest)
+        private static void AssertLoggingEvents(
+            Action<Project, MockLogger> loggingTest = null,
+            MockLogger firstEvaluationLogger = null,
+            Func<Project, MockLogger> reevaluationLoggerFactory = null)
         {
             var projectImportContents =
                 @"<Project>
@@ -76,18 +81,28 @@ private static void AssertLoggingEvents(Action<Project, MockLogger> loggingTest)
 
                 projectContents = string.Format(projectContents, importFile);
 
-
                 var projectFile = env.CreateFile().Path;
                 File.WriteAllText(projectFile, projectContents);
 
-                var logger = new MockLogger();
-                collection.RegisterLogger(logger);
+                firstEvaluationLogger = firstEvaluationLogger ?? new MockLogger();
+                collection.RegisterLogger(firstEvaluationLogger);
 
                 var project = new Project(projectFile, null, null, collection);
 
-                Assert.NotEmpty(logger.AllBuildEvents);
+                firstEvaluationLogger.AllBuildEvents.ShouldNotBeEmpty();
+
+                if (reevaluationLoggerFactory != null)
+                {
+                    var reevaluationLogger = reevaluationLoggerFactory.Invoke(project);
+                    collection.RegisterLogger(reevaluationLogger);
+
+                    project.SetProperty("aProperty", "Value");
+                    project.ReevaluateIfNecessary();
+
+                    reevaluationLogger.AllBuildEvents.ShouldNotBeEmpty();
+                }
 
-                loggingTest.Invoke(project, logger);
+                loggingTest?.Invoke(project, firstEvaluationLogger);
             }
         }
 
@@ -95,29 +110,67 @@ private static void AssertLoggingEvents(Action<Project, MockLogger> loggingTest)
         public void AllEvaluationEventsShouldHaveAnEvaluationId()
         {
             AssertLoggingEvents(
-                (project, mockLogger) =>
+                (project, firstEvaluationLogger) =>
                 {
                     var evaluationId = project.LastEvaluationId;
+                    evaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);
 
-                    Assert.NotEqual(BuildEventContext.InvalidEvaluationId, evaluationId);
+                    foreach (var buildEvent in firstEvaluationLogger.AllBuildEvents)
+                    {
+                        buildEvent.BuildEventContext.EvaluationId.ShouldBe(evaluationId);
+                    }
+                });
+        }
 
-                    foreach (var buildEvent in mockLogger.AllBuildEvents)
+        [Fact]
+        public void GivenOneProjectThereShouldBeOneStartedAndOneEndedEvent()
+        {
+            AssertLoggingEvents(
+                (project, firstEvaluationLogger) =>
+                {
+                    var allBuildEvents = firstEvaluationLogger.AllBuildEvents;
+
+                    allBuildEvents.Count.ShouldBeGreaterThan(2);
+
+                    for (var i = 0; i < allBuildEvents.Count; i++)
                     {
-                        Assert.Equal(evaluationId, buildEvent.BuildEventContext.EvaluationId);
+                        var buildEvent = allBuildEvents[i];
+
+                        if (i == 0)
+                        {
+                            buildEvent.Message.ShouldStartWith("Evaluation started");
+                        }
+                        else if (i == allBuildEvents.Count - 1)
+                        {
+                            buildEvent.Message.ShouldStartWith("Evaluation finished");
+                        }
+                        else
+                        {
+                            buildEvent.Message.ShouldNotStartWith("Evaluation started");
+                            buildEvent.Message.ShouldNotStartWith("Evaluation finished");
+                        }
                     }
                 });
         }
 
         [Fact]
-        public void FirstAndLastEvaluationEventsShouldBeStartedAndEnded()
+        public void ProjectShouldHaveValidEvaluationIdDuringEvaluation()
         {
             AssertLoggingEvents(
-                (project, mockLogger) =>
+                null,
+                null,
+                project => new MockLogger
                 {
-                    Assert.True(mockLogger.AllBuildEvents.Count >= 2);
+                    AdditionalHandlers = new List<Action<object, BuildEventArgs>>
+                    {
+                        (sender, args) =>
+                        {
+                            var eventEvaluationId = args.BuildEventContext.EvaluationId;
 
-                    Assert.StartsWith("Evaluation started", mockLogger.AllBuildEvents.First().Message);
-                    Assert.StartsWith("Evaluation finished", mockLogger.AllBuildEvents.Last().Message);
+                            eventEvaluationId.ShouldNotBe(BuildEventContext.InvalidEvaluationId);
+                            project.LastEvaluationId.ShouldBe(eventEvaluationId);
+                        }
+                    }
                 });
         }
     }
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index c30daf0e763..fb85f1e1982 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3585,18 +3585,49 @@ public void PropertyFunctionStringPadLeft2()
             TestPropertyFunction("$(prop.PadLeft(2, '0'))", "prop", "x", "0x");
         }
 
+        [Fact]
+        public void PropertyFunctionStringPadRight1()
+        {
+            TestPropertyFunction("$(prop.PadRight(2))", "prop", "x", "x ");
+        }
+
+        [Fact]
+        public void PropertyFunctionStringPadRight2()
+        {
+            TestPropertyFunction("$(prop.PadRight(2, '0'))", "prop", "x", "x0");
+        }
+
         [Fact]
         public void PropertyFunctionStringTrimEndCharArray()
         {
             TestPropertyFunction("$(prop.TrimEnd('.0123456789'))", "prop", "net461", "net");
         }
 
+        [Fact]
+        public void PropertyFunctionStringTrimStart()
+        {
+            TestPropertyFunction("$(X.TrimStart('vV'))", "X", "v40", "40");
+        }
+
+        [Fact]
+        public void PropertyFunctionStringTrimStartNoQuotes()
+        {
+            TestPropertyFunction("$(X.TrimStart(vV))", "X", "v40", "40");
+        }
+
         [Fact]
         public void PropertyFunctionStringTrimEnd1()
         {
             TestPropertyFunction("$(prop.TrimEnd('a'))", "prop", "netaa", "net");
         }
 
+        // https://github.com/Microsoft/msbuild/issues/2882
+        [Fact]
+        public void PropertyFunctionMathMaxOverflow()
+        {
+            TestPropertyFunction("$([System.Math]::Max($(X), 0))", "X", "-2010", "0");
+        }
+
         [Fact]
         public void PropertyFunctionStringTrimEnd2()
         {
@@ -3606,6 +3637,60 @@ public void PropertyFunctionStringTrimEnd2()
             });
         }
 
+        [Fact]
+        public void PropertyFunctionMathMin()
+        {
+            TestPropertyFunction("$([System.Math]::Min($(X), 20))", "X", "30", "20");
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildAdd()
+        {
+            TestPropertyFunction("$([MSBuild]::Add($(X), 5))", "X", "7", "12");
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildSubtract()
+        {
+            TestPropertyFunction("$([MSBuild]::Subtract($(X), 20100000))", "X", "20100042", "42");
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildMultiply()
+        {
+            TestPropertyFunction("$([MSBuild]::Multiply($(X), 8800))", "X", "2", "17600");
+        }
+
+        [Fact]
+        public void PropertyFunctionMSBuildDivide()
+        {
+            TestPropertyFunction("$([MSBuild]::Divide($(X), 10000))", "X", "65536", "6.5536");
+        }
+
+        [Fact]
+        public void PropertyFunctionConvertToString()
+        {
+            TestPropertyFunction("$([System.Convert]::ToString(`.`))", "_", "_", ".");
+        }
+
+        [Fact]
+        public void PropertyFunctionConvertToInt32()
+        {
+            TestPropertyFunction("$([System.Convert]::ToInt32(42))", "_", "_", "42");
+        }
+
+        [Fact]
+        public void PropertyFunctionToCharArray()
+        {
+            TestPropertyFunction("$([System.Convert]::ToString(`.`).ToCharArray())", "_", "_", ".");
+        }
+
+        [Fact]
+        public void PropertyFunctionStringArrayGetValue()
+        {
+            TestPropertyFunction("$(X.Split($([System.Convert]::ToString(`.`).ToCharArray())).GetValue($([System.Convert]::ToInt32(0))))", "X", "ab.cd", "ab");
+        }
+
         private void TestPropertyFunction(string expression, string propertyName, string propertyValue, string expected)
         {
             var properties = new PropertyDictionary<ProjectPropertyInstance>();
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index f2c86d59c06..dbacd91aa65 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -863,7 +863,8 @@ internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThread
                     submission.BuildRequestData.HostServices,
                     BuildEventContext.Invalid,
                     null,
-                    submission.BuildRequestData.Flags);
+                    submission.BuildRequestData.Flags,
+                    submission.BuildRequestData.RequestedProjectState);
 
                 if (_shuttingDown)
                 {
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index 556f1fd8e28..7e338884cea 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -33,7 +33,7 @@ public enum BuildRequestDataFlags
         ReplaceExistingProjectInstance = 1 << 0,
 
         /// <summary>
-        /// When this flag is present, <see cref="BuildResult"/> issued in response to this request will
+        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
         /// include <see cref="BuildResult.ProjectStateAfterBuild"/>.
         /// </summary>
         ProvideProjectStateAfterBuild = 1 << 1,
@@ -68,7 +68,14 @@ public enum BuildRequestDataFlags
         /// are not defined in the Project to build. This only applies to this build request (if another target calls
         /// the "missing target" at any other point this will still result in an error).
         /// </summary>
-        SkipNonexistentTargets = 1 << 4
+        SkipNonexistentTargets = 1 << 4,
+
+        /// <summary>
+        /// When this flag is present, the <see cref="BuildResult"/> issued in response to this request will
+        /// include a <see cref="BuildResult.ProjectStateAfterBuild"/> that includes ONLY the
+        /// explicitly-requested properties, items, and metadata.
+        /// </summary>
+        ProvideSubsetOfStateAfterBuild = 1 << 5,
     }
 
     /// <summary>
@@ -138,6 +145,24 @@ public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild
             }
         }
 
+        /// <summary>
+        /// Constructs a BuildRequestData for build requests based on project instances.
+        /// </summary>
+        /// <param name="projectInstance">The instance to build.</param>
+        /// <param name="targetsToBuild">The targets to build.</param>
+        /// <param name="hostServices">The host services to use, if any.  May be null.</param>
+        /// <param name="flags">Flags controlling this build request.</param>
+        /// <param name="propertiesToTransfer">The list of properties whose values should be transferred from the project to any out-of-proc node.</param>
+        /// <param name="requestedProjectState">A <see cref="Execution.RequestedProjectState"/> describing properties, items, and metadata that should be returned. Requires setting <see cref="BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/>.</param>
+        public BuildRequestData(ProjectInstance projectInstance, string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, IEnumerable<string> propertiesToTransfer, RequestedProjectState requestedProjectState)
+            : this(projectInstance, targetsToBuild, hostServices, flags, propertiesToTransfer)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(requestedProjectState, nameof(requestedProjectState));
+
+            this.RequestedProjectState = requestedProjectState;
+        }
+
+
         /// <summary>
         /// Constructs a BuildRequestData for build requests based on project files.
         /// </summary>
@@ -151,6 +176,26 @@ public BuildRequestData(string projectFullPath, IDictionary<string, string> glob
         {
         }
 
+        /// <summary>
+        /// Constructs a BuildRequestData for build requests based on project files.
+        /// </summary>
+        /// <param name="projectFullPath">The full path to the project file.</param>
+        /// <param name="globalProperties">The global properties which should be used during evaluation of the project.  Cannot be null.</param>
+        /// <param name="toolsVersion">The tools version to use for the build.  May be null.</param>
+        /// <param name="targetsToBuild">The targets to build.</param>
+        /// <param name="hostServices">The host services to use.  May be null.</param>
+        /// <param name="flags">The <see cref="BuildRequestDataFlags"/> to use.</param>
+        /// <param name="requestedProjectState">A <see cref="Execution.RequestedProjectState"/> describing properties, items, and metadata that should be returned. Requires setting <see cref="BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/>.</param>
+        public BuildRequestData(string projectFullPath, IDictionary<string, string> globalProperties,
+            string toolsVersion, string[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags,
+            RequestedProjectState requestedProjectState)
+            : this(projectFullPath, globalProperties, toolsVersion, targetsToBuild, hostServices, flags)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(requestedProjectState, nameof(requestedProjectState));
+
+            this.RequestedProjectState = requestedProjectState;
+        }
+
         /// <summary>
         /// Constructs a BuildRequestData for build requests based on project files.
         /// </summary>
@@ -268,6 +313,16 @@ public IEnumerable<string> PropertiesToTransfer
             private set;
         }
 
+        /// <summary>
+        /// Returns the properties, items, and metadata that will be returned
+        /// by this build.
+        /// </summary>
+        public RequestedProjectState RequestedProjectState
+        {
+            get;
+            private set;
+        }
+
         /// <summary>
         /// Whether the tools version used originated from an explicit specification,
         /// for example from an MSBuild task or /tv switch.
diff --git a/src/Build/BackEnd/BuildManager/RequestedProjectState.cs b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
new file mode 100644
index 00000000000..94c1b248cd8
--- /dev/null
+++ b/src/Build/BackEnd/BuildManager/RequestedProjectState.cs
@@ -0,0 +1,57 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Execution
+{
+    /// <summary>
+    /// Interface defining properties, items, and metadata of interest for a <see cref="BuildRequestData"/>.
+    /// </summary>
+    public class RequestedProjectState : INodePacketTranslatable
+    {
+        private List<string> _propertyFilters;
+        private IDictionary<string, List<string>> _itemFilters;
+
+        /// <summary>
+        /// Properties of interest.
+        /// </summary>
+        public List<string> PropertyFilters
+        {
+            get { return _propertyFilters; }
+            set { _propertyFilters = value; }
+        }
+
+        /// <summary>
+        /// Items and metadata of interest.
+        /// </summary>
+        public IDictionary<string, List<string>> ItemFilters
+        {
+            get { return _itemFilters; }
+            set { _itemFilters = value; }
+        }
+
+        void INodePacketTranslatable.Translate(INodePacketTranslator translator)
+        {
+            translator.Translate(ref _propertyFilters);
+            translator.TranslateDictionary(ref _itemFilters, TranslateString, TranslateMetadataForItem, CreateItemMetadataDictionary);
+        }
+
+        private IDictionary<string, List<string>> CreateItemMetadataDictionary(int capacity)
+        {
+            return new Dictionary<string, List<string>>(capacity, StringComparer.OrdinalIgnoreCase);
+        }
+
+        private void TranslateMetadataForItem(ref List<string> list, INodePacketTranslator translator)
+        {
+            translator.Translate(ref list);
+        }
+
+        private void TranslateString(ref string s, INodePacketTranslator translator)
+        {
+            translator.Translate(ref s);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index 3e5faf80761..4c8b74e2522 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -19,12 +19,17 @@ internal class EvaluationLoggingContext : LoggingContext
         public EvaluationLoggingContext(ILoggingService loggingService, BuildEventContext buildEventContext, string projectFile) :
             base(
                 loggingService,
-                loggingService.LogProjectEvaluationStarted(buildEventContext.NodeId, buildEventContext.SubmissionId, projectFile))
+                loggingService.CreateEvaluationBuildEventContext(buildEventContext.NodeId, buildEventContext.SubmissionId))
         {
             _projectFile = projectFile;
             IsValid = true;
         }
 
+        public void LogProjectEvaluationStarted()
+        {
+            LoggingService.LogProjectEvaluationStarted(BuildEventContext, _projectFile);
+        }
+
         /// <summary>
         /// Log that the project has finished
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index ff50384b209..0cf3002bfaf 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -7,6 +7,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -367,14 +368,21 @@ ISet<string> WarningsAsMessages
         /// <param name="success">Did the build succeed or not</param>
         void LogBuildFinished(bool success);
 
+        /// <summary>
+        /// Create an evaluation context, by generating a new evaluation id.
+        /// </summary>
+        /// <param name="nodeId">The node id</param>
+        /// <param name="submissionId">The submission id</param>
+        /// <returns></returns>
+        BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId);
+
         /// <summary>
         /// Logs that a project evaluation has started
         /// </summary>
-        /// <param name="nodeId">The id of the node which is evaluating this project.</param>
-        /// <param name="submissionId">The id of the submission.</param>
-        /// <param name="projectFile">Project file to build</param>
+        /// <param name="eventContext">The event context to use for logging</param>
+        /// <param name="projectFile">Project file being built</param>
         /// <returns>The evaluation event context for the project.</returns>
-        BuildEventContext LogProjectEvaluationStarted(int nodeId, int submissionId, string projectFile);
+        void LogProjectEvaluationStarted(BuildEventContext eventContext, string projectFile);
 
         /// <summary>
         /// Logs that a project evaluation has finished
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 9d21fb94466..5038a8d1b2a 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -13,6 +13,7 @@
 using System.Text;
 using System.Threading;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -494,19 +495,17 @@ public void LogBuildFinished(bool success)
             }
         }
 
-        /// <summary>
-        /// Logs that a project evaluation has started
-        /// </summary>
-        /// <param name="nodeId">The id of the node which is evaluating this project.</param>
-        /// <param name="submissionId">The id of the submission.</param>
-        /// <param name="projectFile">Project file to build</param>
-        /// <returns>The evaluation event context for the project.</returns>
-        public BuildEventContext LogProjectEvaluationStarted(int nodeId, int submissionId, string projectFile)
+        /// <inheritdoc />
+        public BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId)
+        {
+            return new BuildEventContext(submissionId, nodeId, NextEvaluationId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+        }
+
+        /// <inheritdoc />
+        public void LogProjectEvaluationStarted(BuildEventContext projectEvaluationEventContext, string projectFile)
         {
             lock (_lockObject)
             {
-                BuildEventContext projectEvaluationEventContext = new BuildEventContext(submissionId, nodeId, NextEvaluationId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-
                 ProjectEvaluationStartedEventArgs evaluationEvent =
                     new ProjectEvaluationStartedEventArgs(ResourceUtilities.GetResourceString("EvaluationStarted"),
                         projectFile)
@@ -516,8 +515,6 @@ public BuildEventContext LogProjectEvaluationStarted(int nodeId, int submissionI
                     };
 
                 ProcessLoggingEvent(evaluationEvent);
-
-                return projectEvaluationEventContext;
             }
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index e35ae2a8397..15db63ca85b 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -196,11 +196,18 @@ public async Task<BuildResult> BuildTargets(ProjectLoggingContext loggingContext
                 resultsToReport.ProjectStateAfterBuild = _projectInstance;
             }
 
+            if (_requestEntry.Request.RequestedProjectState != null)
+            {
+                resultsToReport.ProjectStateAfterBuild =
+                    _projectInstance.FilteredCopy(_requestEntry.Request.RequestedProjectState);
+            }
+
             configuration.IsCacheable = previousCacheableStatus;
 
             return resultsToReport;
         }
 
+
         #region IBuildComponent Members
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 7d2a305f6c8..619ba7501f0 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -10,12 +10,15 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
     internal class SdkResolverLoader
     {
+#if !FEATURE_ASSEMBLY_LOADFROM
+        private readonly CoreClrAssemblyLoader _loader = new CoreClrAssemblyLoader();
+#endif
+
         internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
             ElementLocation location)
         {
@@ -30,29 +33,10 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
                 return resolvers;
             }
 
-#if !FEATURE_ASSEMBLY_LOADFROM
-            var loader = new CoreClrAssemblyLoader();
-#endif
-
             foreach (var potentialResolver in potentialResolvers)
-                try
-                {
-#if FEATURE_ASSEMBLY_LOADFROM
-                    var assembly = Assembly.LoadFrom(potentialResolver);
-#else
-                    loader.AddDependencyLocation(Path.GetDirectoryName(potentialResolver));
-                    Assembly assembly = loader.LoadFromPath(potentialResolver);
-#endif
-
-                    resolvers.AddRange(assembly.ExportedTypes
-                        .Select(type => new {type, info = type.GetTypeInfo()})
-                        .Where(t => t.info.IsClass && t.info.IsPublic && !t.info.IsAbstract && typeof(SdkResolver).IsAssignableFrom(t.type))
-                        .Select(t => (SdkResolver) Activator.CreateInstance(t.type)));
-                }
-                catch (Exception e)
-                {
-                    loggingContext.LogWarning(null, new BuildEventFileInfo(location), "CouldNotLoadSdkResolver", e.Message);
-                }
+            {
+                LoadResolvers(potentialResolver, loggingContext, location, resolvers);
+            }
 
             return resolvers.OrderBy(t => t.Priority).ToList();
         }
@@ -73,5 +57,58 @@ internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder)
                 .Where(FileUtilities.FileExistsNoThrow)
                 .ToList();
         }
+
+        protected virtual IEnumerable<Type> GetResolverTypes(Assembly assembly)
+        {
+            return assembly.ExportedTypes
+                .Select(type => new {type, info = type.GetTypeInfo()})
+                .Where(t => t.info.IsClass && t.info.IsPublic && !t.info.IsAbstract && typeof(SdkResolver).IsAssignableFrom(t.type))
+                .Select(t => t.type);
+        }
+
+        protected virtual Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location)
+        {
+#if FEATURE_ASSEMBLY_LOADFROM
+            return Assembly.LoadFrom(resolverPath);
+#else
+            _loader.AddDependencyLocation(Path.GetDirectoryName(resolverPath));
+            return _loader.LoadFromPath(resolverPath);
+#endif
+        }
+
+        protected virtual void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List<SdkResolver> resolvers)
+        {
+            Assembly assembly;
+            try
+            {
+                assembly = LoadResolverAssembly(resolverPath, loggingContext, location);
+            }
+            catch (Exception e)
+            {
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, "CouldNotLoadSdkResolverAssembly", resolverPath, e.Message);
+
+                return;
+            }
+
+            foreach (Type type in GetResolverTypes(assembly))
+            {
+                try
+                {
+                    resolvers.Add((SdkResolver)Activator.CreateInstance(type));
+                }
+                catch (TargetInvocationException e)
+                {
+                    // .NET wraps the original exception inside of a TargetInvocationException which masks the original message
+                    // Attempt to get the inner exception in this case, but fall back to the top exception message
+                    string message = e.InnerException?.Message ?? e.Message;
+
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e.InnerException ?? e, "CouldNotLoadSdkResolver", type.Name, message);
+                }
+                catch (Exception e)
+                {
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(location), e, "CouldNotLoadSdkResolver", type.Name, e.Message);
+                }
+            }
+        }
     }
 }
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 587aabdb74b..c4c4222b345 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -88,6 +88,11 @@ internal class BuildRequest : INodePacket
         /// </summary>
         private BuildRequestDataFlags _buildRequestDataFlags;
 
+        /// <summary>
+        /// Filter describing properties, items, and metadata of interest for this request.
+        /// </summary>
+        private RequestedProjectState _requestedProjectState;
+
         /// <summary>
         /// If set, skip targets that are not defined in the projects to be built.
         /// </summary>
@@ -111,6 +116,7 @@ public BuildRequest()
         /// <param name="parentBuildEventContext">The build event context of the parent project.</param>
         /// <param name="parentRequest">The parent build request, if any.</param>
         /// <param name="buildRequestDataFlags">Additional flags for the request.</param>
+        /// <param name="requestedProjectState">Filter for desired build results.</param>
         public BuildRequest(
             int submissionId,
             int nodeRequestId,
@@ -119,7 +125,8 @@ public BuildRequest(
             HostServices hostServices,
             BuildEventContext parentBuildEventContext,
             BuildRequest parentRequest,
-            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None)
+            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
+            RequestedProjectState requestedProjectState = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
             ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, "parentBuildEventContext");
@@ -142,6 +149,7 @@ public BuildRequest(
 
             _nodeRequestId = nodeRequestId;
             _buildRequestDataFlags = buildRequestDataFlags;
+            _requestedProjectState = requestedProjectState;
         }
 
         /// <summary>
@@ -281,6 +289,16 @@ public BuildRequestDataFlags BuildRequestDataFlags
             set { _buildRequestDataFlags = value; }
         }
 
+        /// <summary>
+        /// Filter describing properties, items, and metadata of interest for this request.
+        /// </summary>
+        public RequestedProjectState RequestedProjectState
+        {
+            get { return _requestedProjectState; }
+            set { _requestedProjectState = value; }
+        }
+
+
         /// <summary>
         /// The route for host-aware tasks back to the host
         /// </summary>
@@ -338,6 +356,7 @@ public void Translate(INodePacketTranslator translator)
             translator.Translate(ref _buildEventContext);
             translator.TranslateEnum(ref _buildRequestDataFlags, (int)_buildRequestDataFlags);
             translator.Translate(ref _skipNonexistentTargets);
+            translator.Translate(ref _requestedProjectState);
 
             // UNDONE: (Compat) Serialize the host object.
         }
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 318b4cd6011..d18b1160ab5 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -110,10 +110,11 @@ public class BuildResult : INodePacket, IBuildResults
 
         /// <summary>
         /// <see cref="ProjectInstance"/> state after the build. This is only provided if <see cref="BuildRequest.BuildRequestDataFlags"/>
-        /// includes <see cref="BuildRequestDataFlags.ProvideProjectStateAfterBuild"/> for the build request which this object is a result of, 
-        /// and will be <c>null</c> otherwise.  In general, where available, it may be a non buildable-dummy object, and should only
+        /// includes <see cref="BuildRequestDataFlags.ProvideProjectStateAfterBuild"/> or
+        /// <see cref="BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild"/> for the build request which this object is a result of,
+        /// and will be <c>null</c> otherwise. Where available, it may be a non buildable-dummy object, and should only
         /// be used to retrieve <see cref="ProjectInstance.Properties"/>, <see cref="ProjectInstance.GlobalProperties"/> and
-        /// <see cref="ProjectInstance.Items"/> from it. Any other operation is not guaranteed to be supported.
+        /// <see cref="ProjectInstance.Items"/> from it. No other operation is guaranteed to be supported.
         /// </summary>
         private ProjectInstance _projectStateAfterBuild;
 
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 159d4f57ee2..ae2919518fd 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -803,6 +803,9 @@ private IDictionary<string, object> Evaluate(ILoggingService loggingService, Bui
 
                 _evaluationLoggingContext = new EvaluationLoggingContext(loggingService, buildEventContext, projectFile);
                 _data.EvaluationId = _evaluationLoggingContext.BuildEventContext.EvaluationId;
+
+                _evaluationLoggingContext.LogProjectEvaluationStarted();
+
                 ErrorUtilities.VerifyThrow(_data.EvaluationId != BuildEventContext.InvalidEvaluationId, "Evaluation should produce an evaluation ID");
 
 #if MSBUILDENABLEVSPROFILING
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 8f93eeb63ab..1b1a16af42c 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -3347,6 +3347,30 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             return true;
                         }
                     }
+                    else if (string.Equals(_methodMethodName, "PadRight", StringComparison.OrdinalIgnoreCase))
+                    {
+                        int totalWidth;
+                        string paddingChar;
+                        if (TryGetArg(args, out totalWidth))
+                        {
+                            returnVal = text.PadRight(totalWidth);
+                            return true;
+                        }
+                        else if (TryGetArgs(args, out totalWidth, out paddingChar) && paddingChar.Length == 1)
+                        {
+                            returnVal = text.PadRight(totalWidth, paddingChar[0]);
+                            return true;
+                        }
+                    }
+                    else if (string.Equals(_methodMethodName, "TrimStart", StringComparison.OrdinalIgnoreCase))
+                    {
+                        string trimChars;
+                        if (TryGetArg(args, out trimChars) && trimChars.Length > 0)
+                        {
+                            returnVal = text.TrimStart(trimChars.ToCharArray());
+                            return true;
+                        }
+                    }
                     else if (string.Equals(_methodMethodName, "TrimEnd", StringComparison.OrdinalIgnoreCase))
                     {
                         string trimChars;
@@ -3379,6 +3403,69 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         }
                     }
                 }
+                else if (objectInstance == null)
+                {
+                    if (_receiverType == typeof(Math))
+                    {
+                        if (string.Equals(_methodMethodName, "Max", StringComparison.OrdinalIgnoreCase))
+                        {
+                            double arg0, arg1;
+                            if (TryGetArgs(args, out arg0, out arg1))
+                            {
+                                returnVal = Math.Max(arg0, arg1);
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, "Min", StringComparison.OrdinalIgnoreCase))
+                        {
+                            double arg0, arg1;
+                            if (TryGetArgs(args, out arg0, out arg1))
+                            {
+                                returnVal = Math.Min(arg0, arg1);
+                                return true;
+                            }
+                        }
+                    }
+                    else if (_receiverType == typeof(IntrinsicFunctions))
+                    {
+                        if (string.Equals(_methodMethodName, "Add", StringComparison.OrdinalIgnoreCase))
+                        {
+                            double arg0, arg1;
+                            if (TryGetArgs(args, out arg0, out arg1))
+                            {
+                                returnVal = arg0 + arg1;
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, "Subtract", StringComparison.OrdinalIgnoreCase))
+                        {
+                            double arg0, arg1;
+                            if (TryGetArgs(args, out arg0, out arg1))
+                            {
+                                returnVal = arg0 - arg1;
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, "Multiply", StringComparison.OrdinalIgnoreCase))
+                        {
+                            double arg0, arg1;
+                            if (TryGetArgs(args, out arg0, out arg1))
+                            {
+                                returnVal = arg0 * arg1;
+                                return true;
+                            }
+                        }
+                        else if (string.Equals(_methodMethodName, "Divide", StringComparison.OrdinalIgnoreCase))
+                        {
+                            double arg0, arg1;
+                            if (TryGetArgs(args, out arg0, out arg1))
+                            {
+                                returnVal = arg0 / arg1;
+                                return true;
+                            }
+                        }
+                    }
+                }
 
                 returnVal = null;
                 return false;
@@ -3437,6 +3524,29 @@ private static bool TryGetArgs(object[] args, out int arg0, out int arg1)
                 return false;
             }
 
+            private static bool TryGetArgs(object[] args, out double arg0, out double arg1)
+            {
+                arg0 = 0;
+                arg1 = 0;
+
+                if (args.Length != 2)
+                {
+                    return false;
+                }
+
+                var value0 = args[0] as string;
+                var value1 = args[1] as string;
+                if (value0 != null &&
+                    value1 != null &&
+                    double.TryParse(value0, out arg0) &&
+                    double.TryParse(value1, out arg1))
+                {
+                    return true;
+                }
+
+                return false;
+            }
+
             private static bool TryGetArgs(object[] args, out int arg0, out string arg1)
             {
                 arg0 = 0;
@@ -3858,6 +3968,12 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                 {
                     return null;
                 }
+                catch (OverflowException)
+                {
+                    // https://github.com/Microsoft/msbuild/issues/2882
+                    // test: PropertyFunctionMathMaxOverflow
+                    return null;
+                }
 
                 return coercedArguments;
             }
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 35a757f29c9..49a48b517d0 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -48,7 +48,7 @@ internal class ProjectParser
         /// <summary>
         /// Valid attributes on import element
         /// </summary>
-        private readonly static string[] s_validAttributesOnImport = new string[] { XMakeAttributes.condition, XMakeAttributes.label, XMakeAttributes.project, XMakeAttributes.sdk };
+        private readonly static string[] s_validAttributesOnImport = new string[] { XMakeAttributes.condition, XMakeAttributes.label, XMakeAttributes.project, XMakeAttributes.sdk, XMakeAttributes.sdkVersion, XMakeAttributes.sdkMinimumVersion };
 
         /// <summary>
         /// Valid attributes on usingtask element
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index ef14cd2ca55..91ad6090e0e 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -474,8 +474,11 @@ private ProjectInstance(ProjectInstance that)
         /// Deep clone of this object.
         /// Useful for compiling a single file; or for keeping resolved assembly references between builds.
         /// </summary>
-        private ProjectInstance(ProjectInstance that, bool isImmutable)
+        private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProjectState filter = null)
         {
+            ErrorUtilities.VerifyThrow(filter == null || isImmutable,
+                "The result of a filtered ProjectInstance clone must be immutable.");
+
             _directory = that._directory;
             _projectFileLocation = that._projectFileLocation;
             _hostServices = that._hostServices;
@@ -484,50 +487,146 @@ private ProjectInstance(ProjectInstance that, bool isImmutable)
 
             TranslateEntireState = that.TranslateEntireState;
 
-            _properties = new PropertyDictionary<ProjectPropertyInstance>(that._properties.Count);
-
-            foreach (ProjectPropertyInstance property in that.Properties)
+            if (filter == null)
             {
-                _properties.Set(property.DeepClone(_isImmutable));
-            }
+                _properties = new PropertyDictionary<ProjectPropertyInstance>(that._properties.Count);
 
-            _items = new ItemDictionary<ProjectItemInstance>(that._items.ItemTypes.Count);
+                foreach (ProjectPropertyInstance property in that.Properties)
+                {
+                    _properties.Set(property.DeepClone(_isImmutable));
+                }
 
-            foreach (ProjectItemInstance item in that.Items)
-            {
-                _items.Add(item.DeepClone(this));
-            }
+                _items = new ItemDictionary<ProjectItemInstance>(that._items.ItemTypes.Count);
 
-            _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(that._globalProperties.Count);
+                foreach (ProjectItemInstance item in that.Items)
+                {
+                    _items.Add(item.DeepClone(this));
+                }
 
-            foreach (ProjectPropertyInstance globalProperty in that.GlobalPropertiesDictionary)
-            {
-                _globalProperties.Set(globalProperty.DeepClone(_isImmutable));
-            }
+                _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(that._globalProperties.Count);
 
-            _environmentVariableProperties = new PropertyDictionary<ProjectPropertyInstance>(that._environmentVariableProperties.Count);
+                foreach (ProjectPropertyInstance globalProperty in that.GlobalPropertiesDictionary)
+                {
+                    _globalProperties.Set(globalProperty.DeepClone(_isImmutable));
+                }
 
-            foreach (ProjectPropertyInstance environmentProperty in that._environmentVariableProperties)
-            {
-                _environmentVariableProperties.Set(environmentProperty.DeepClone(_isImmutable));
+                _environmentVariableProperties =
+                    new PropertyDictionary<ProjectPropertyInstance>(that._environmentVariableProperties.Count);
+
+                foreach (ProjectPropertyInstance environmentProperty in that._environmentVariableProperties)
+                {
+                    _environmentVariableProperties.Set(environmentProperty.DeepClone(_isImmutable));
+                }
+
+                this.DefaultTargets = new List<string>(that.DefaultTargets);
+                this.InitialTargets = new List<string>(that.InitialTargets);
+                ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
+                    ProjectItemDefinitionInstance>) this).BeforeTargets = CreateCloneDictionary(
+                    ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
+                        ProjectItemDefinitionInstance>) that).BeforeTargets, StringComparer.OrdinalIgnoreCase);
+                ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
+                    ProjectItemDefinitionInstance>) this).AfterTargets = CreateCloneDictionary(
+                    ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance,
+                        ProjectItemDefinitionInstance>) that).AfterTargets, StringComparer.OrdinalIgnoreCase);
+                this.TaskRegistry =
+                    that.TaskRegistry; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
+
+                // These are immutable so we don't need to clone them:
+                this.Toolset = that.Toolset;
+                this.SubToolsetVersion = that.SubToolsetVersion;
+                _targets = that._targets;
+                _itemDefinitions = that._itemDefinitions;
+                _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
+
+                this.EvaluatedItemElements = that.EvaluatedItemElements;
+
+                this.ProjectRootElementCache = that.ProjectRootElementCache;
             }
+            else
+            {
+                if (filter.PropertyFilters != null)
+                {
+                    // If PropertyFilters is defined, filter all types of property to contain
+                    // only those explicitly specified.
+
+                    // Reserve space assuming all specified properties exist.
+                    _properties = new PropertyDictionary<ProjectPropertyInstance>(filter.PropertyFilters.Count);
+                    _globalProperties = new PropertyDictionary<ProjectPropertyInstance>(filter.PropertyFilters.Count);
+                    _environmentVariableProperties =
+                        new PropertyDictionary<ProjectPropertyInstance>(filter.PropertyFilters.Count);
+
+                    // Filter each type of property.
+                    foreach (var desiredProperty in filter.PropertyFilters)
+                    {
+                        var regularProperty = that.GetProperty(desiredProperty);
+                        if (regularProperty != null)
+                        {
+                            _properties.Set(regularProperty.DeepClone(isImmutable: true));
+                        }
 
-            this.DefaultTargets = new List<string>(that.DefaultTargets);
-            this.InitialTargets = new List<string>(that.InitialTargets);
-            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).BeforeTargets = CreateCloneDictionary(((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)that).BeforeTargets, StringComparer.OrdinalIgnoreCase);
-            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).AfterTargets = CreateCloneDictionary(((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)that).AfterTargets, StringComparer.OrdinalIgnoreCase);
-            this.TaskRegistry = that.TaskRegistry; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
+                        var globalProperty = that.GetProperty(desiredProperty);
+                        if (globalProperty != null)
+                        {
+                            _globalProperties.Set(globalProperty.DeepClone(isImmutable: true));
+                        }
 
-            // These are immutable so we don't need to clone them:
-            this.Toolset = that.Toolset;
-            this.SubToolsetVersion = that.SubToolsetVersion;
-            _targets = that._targets;
-            _itemDefinitions = that._itemDefinitions;
-            _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
+                        var environmentProperty = that.GetProperty(desiredProperty);
+                        if (environmentProperty != null)
+                        {
+                            _environmentVariableProperties.Set(environmentProperty.DeepClone(isImmutable: true));
+                        }
+                    }
+                }
 
-            this.EvaluatedItemElements = that.EvaluatedItemElements;
+                if (filter.ItemFilters != null)
+                {
+                    // If ItemFilters is defined, filter items down to the list
+                    // specified, optionally also filtering metadata.
+
+                    // Temporarily allow editing items to remove metadata that
+                    // wasn't explicitly asked for.
+                    _isImmutable = false;
+
+                    _items = new ItemDictionary<ProjectItemInstance>(that.Items.Count);
 
-            this.ProjectRootElementCache = that.ProjectRootElementCache;
+                    foreach (var itemFilter in filter.ItemFilters)
+                    {
+                        foreach (var actualItem in that.GetItems(itemFilter.Key))
+                        {
+                            var filteredItem = actualItem.DeepClone(this);
+
+                            if (itemFilter.Value == null)
+                            {
+                                // No specified list of metadata names, so include all metadata.
+                                // The returned list of items is still filtered by item name.
+                            }
+                            else
+                            {
+                                // Include only the explicitly-asked-for metadata by removing
+                                // any extant metadata.
+                                // UNDONE: This could be achieved at lower GC cost by applying
+                                // the metadata filter at DeepClone time above.
+                                foreach (var metadataName in filteredItem.MetadataNames)
+                                {
+                                    if (!itemFilter.Value.Contains(metadataName, StringComparer.OrdinalIgnoreCase))
+                                    {
+                                        filteredItem.RemoveMetadata(metadataName);
+                                    }
+                                }
+                            }
+
+                            _items.Add(filteredItem);
+                        }
+                    }
+
+                    // Restore immutability after editing newly cloned items.
+                    _isImmutable = isImmutable;
+
+                    // A filtered result is not useful for building anyway; ensure that
+                    // it has minimal IPC wire cost.
+                    _translateEntireState = false;
+                }
+            }
         }
 
         /// <summary>
@@ -1477,6 +1576,21 @@ public ProjectInstance DeepCopy()
             return DeepCopy(_isImmutable);
         }
 
+        /// <summary>
+        /// Create an independent clone of this object, keeping ONLY the explicitly
+        /// requested project state.
+        /// </summary>
+        /// <remarks>
+        /// Useful for reducing the wire cost of IPC for out-of-proc nodes used during
+        /// design-time builds that only need to populate a known set of data.
+        /// </remarks>
+        /// <param name="filter">Project state that should be returned.</param>
+        /// <returns></returns>
+        public ProjectInstance FilteredCopy(RequestedProjectState filter)
+        {
+            return new ProjectInstance(this, true, filter);
+        }
+
         /// <summary>
         /// Create an independent, deep clone of this object and everything in it, with
         /// specified mutability.
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 5622e32cab8..eb2ee26dc72 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -193,6 +193,7 @@
     <Compile Include="BackEnd\BuildManager\BuildParameters.cs" />
     <Compile Include="BackEnd\BuildManager\BuildSubmission.cs" />
     <Compile Include="BackEnd\BuildManager\LegacyThreadingData.cs" />
+    <Compile Include="BackEnd\BuildManager\RequestedProjectState.cs" />
     <Compile Include="BackEnd\Components\BuildComponentFactoryCollection.cs" />
     <Compile Include="BackEnd\Components\Caching\IRegisteredTaskObjectCache.cs" />
     <Compile Include="..\Shared\RegisteredTaskObjectCacheBase.cs" />
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 408c28c8917..be765b967b1 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1200,9 +1200,13 @@
     <comment>{StrBegin="MSB4236: "}</comment>
   </data>
   <data name="CouldNotLoadSdkResolver" UESanitized="false" Visibility="Public">
-    <value>MSB4237: An SDK resolver was found but could not be loaded. {0}</value>
+    <value>MSB4237: The SDK resolver type "{0}" failed to load. {1}</value>
     <comment>{StrBegin="MSB4237: "}</comment>
   </data>
+  <data name="CouldNotLoadSdkResolverAssembly" UESanitized="false" Visibility="Public">
+    <value>MSB4244: The SDK resolver assembly "{0}" could not be loaded. {1}</value>
+    <comment>{StrBegin="MSB4244: "}</comment>
+  </data>
   <data name="CouldNotRunSdkResolver" UESanitized="false" Visibility="Public">
     <value>MSB4242: The SDK resolver "{0}" failed to run. {1}</value>
     <comment>{StrBegin="MSB4242: "}</comment>
@@ -1676,7 +1680,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
         MSB4128 is being used in FileLogger.cs (can't be added here yet as strings are currently frozen)
         MSB4129 is used by Shared\XmlUtilities.cs (can't be added here yet as strings are currently frozen)
 
-        Next message code should be MSB4244.
+        Next message code should be MSB4245.
               
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/MSBuild.sln b/src/MSBuild.sln
index 11ac992ab85..82fc63f51e7 100644
--- a/src/MSBuild.sln
+++ b/src/MSBuild.sln
@@ -73,6 +73,8 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "XmlFileLogger", "..\Samples
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NuGet.MSBuildSdkResolver", "NuGetSdkResolver\NuGet.MSBuildSdkResolver.csproj", "{C7988833-3EF2-43F4-A170-34E8CCCB1320}"
 EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NuGet.MSBuildSdkResolver.UnitTests", "NuGetSdkResolver.UnitTests\NuGet.MSBuildSdkResolver.UnitTests.csproj", "{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -855,6 +857,48 @@ Global
 		{C7988833-3EF2-43F4-A170-34E8CCCB1320}.Release-NetCore|x64.Build.0 = Release-NetCore|x64
 		{C7988833-3EF2-43F4-A170-34E8CCCB1320}.Release-NetCore|x86.ActiveCfg = Release-NetCore|x86
 		{C7988833-3EF2-43F4-A170-34E8CCCB1320}.Release-NetCore|x86.Build.0 = Release-NetCore|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug|x64.ActiveCfg = Debug|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug|x64.Build.0 = Debug|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug|x86.ActiveCfg = Debug|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug|x86.Build.0 = Debug|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-MONO|x86.ActiveCfg = Debug-MONO|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-MONO|x86.Build.0 = Debug-MONO|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-NetCore|Any CPU.ActiveCfg = Debug-NetCore|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-NetCore|Any CPU.Build.0 = Debug-NetCore|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-NetCore|x64.ActiveCfg = Debug-NetCore|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-NetCore|x64.Build.0 = Debug-NetCore|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-NetCore|x86.ActiveCfg = Debug-NetCore|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Debug-NetCore|x86.Build.0 = Debug-NetCore|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Port-Progress|Any CPU.ActiveCfg = Port-Progress|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Port-Progress|Any CPU.Build.0 = Port-Progress|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Port-Progress|x64.ActiveCfg = Port-Progress|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Port-Progress|x64.Build.0 = Port-Progress|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Port-Progress|x86.ActiveCfg = Port-Progress|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Port-Progress|x86.Build.0 = Port-Progress|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release|Any CPU.Build.0 = Release|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release|x64.ActiveCfg = Release|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release|x64.Build.0 = Release|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release|x86.ActiveCfg = Release|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release|x86.Build.0 = Release|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-MONO|x86.ActiveCfg = Release-MONO|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-MONO|x86.Build.0 = Release-MONO|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-NetCore|Any CPU.ActiveCfg = Release-NetCore|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-NetCore|Any CPU.Build.0 = Release-NetCore|Any CPU
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-NetCore|x64.ActiveCfg = Release-NetCore|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-NetCore|x64.Build.0 = Release-NetCore|x64
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-NetCore|x86.ActiveCfg = Release-NetCore|x86
+		{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}.Release-NetCore|x86.Build.0 = Release-NetCore|x86
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/src/NuGetSdkResolver.UnitTests/GlobalJsonReader_Tests.cs b/src/NuGetSdkResolver.UnitTests/GlobalJsonReader_Tests.cs
new file mode 100644
index 00000000000..db3a22b2112
--- /dev/null
+++ b/src/NuGetSdkResolver.UnitTests/GlobalJsonReader_Tests.cs
@@ -0,0 +1,102 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Engine.UnitTests;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Xunit;
+
+namespace NuGet.MSBuildSdkResolver.UnitTests
+{
+    public class GlobalJsonReader_Tests
+    {
+        public static string WriteGlobalJson(string directory, Dictionary<string, string> sdkVersions, string additionalcontent = "")
+        {
+            string path = Path.Combine(directory, GlobalJsonReader.GlobalJsonFileName);
+
+            using (StreamWriter writer = File.CreateText(path))
+            {
+                writer.WriteLine("{");
+                if (sdkVersions != null)
+                {
+                    writer.WriteLine("    \"msbuild-sdks\": {");
+                    writer.WriteLine(String.Join($",{Environment.NewLine}        ", sdkVersions.Select(i => $"\"{i.Key}\": \"{i.Value}\"")));
+                    writer.WriteLine("    }");
+                }
+
+                if (!String.IsNullOrWhiteSpace(additionalcontent))
+                {
+                    writer.Write(additionalcontent);
+                }
+
+                writer.WriteLine("}");
+            }
+
+            return path;
+        }
+
+        [Fact]
+        public void EmptyGlobalJson()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder();
+
+                File.WriteAllText(Path.Combine(folder.FolderPath, GlobalJsonReader.GlobalJsonFileName), " { } ");
+
+                MockSdkResolverContext context = new MockSdkResolverContext(Path.Combine(folder.FolderPath, "foo.proj"));
+
+                GlobalJsonReader.GetMSBuildSdkVersions(context).ShouldBeNull();
+            }
+        }
+
+        [Fact]
+        public void InvalidJsonLogsMessage()
+        {
+            Dictionary<string, string> expectedVersions = new Dictionary<string, string>
+            {
+                {"foo", "1.0.0"},
+                {"bar", "2.0.0"}
+            };
+
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestProjectWithFiles projectWithFiles = testEnvironment.CreateTestProjectWithFiles("");
+
+                string globalJsonPath = WriteGlobalJson(projectWithFiles.TestRoot, expectedVersions, additionalcontent: ", abc");
+
+                MockSdkResolverContext context = new MockSdkResolverContext(projectWithFiles.ProjectFile);
+
+                GlobalJsonReader.GetMSBuildSdkVersions(context).ShouldBeNull();
+
+                context.MockSdkLogger.LoggedMessages
+                    .ShouldHaveSingleItem()
+                    .Key
+                    .ShouldBe($"Failed to parse \"{globalJsonPath}\". Invalid JavaScript property identifier character: }}. Path \'msbuild-sdks\', line 6, position 5.");
+            }
+        }
+
+        [Fact]
+        public void SdkVersionsAreSuccessfullyLoaded()
+        {
+            Dictionary<string, string> expectedVersions = new Dictionary<string, string>
+            {
+                {"foo", "1.0.0"},
+                {"bar", "2.0.0"}
+            };
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestProjectWithFiles projectWithFiles = testEnvironment.CreateTestProjectWithFiles("", relativePathFromRootToProject: @"a\b\c");
+
+                WriteGlobalJson(projectWithFiles.TestRoot, expectedVersions);
+
+                MockSdkResolverContext context = new MockSdkResolverContext(projectWithFiles.ProjectFile);
+
+                GlobalJsonReader.GetMSBuildSdkVersions(context).ShouldBe(expectedVersions);
+            }
+        }
+    }
+}
diff --git a/src/NuGetSdkResolver.UnitTests/MockSdkLogger.cs b/src/NuGetSdkResolver.UnitTests/MockSdkLogger.cs
new file mode 100644
index 00000000000..4698a9ffb38
--- /dev/null
+++ b/src/NuGetSdkResolver.UnitTests/MockSdkLogger.cs
@@ -0,0 +1,34 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using System.Collections.Generic;
+using SdkLoggerBase = Microsoft.Build.Framework.SdkLogger;
+
+namespace NuGet.MSBuildSdkResolver.UnitTests
+{
+    /// <summary>
+    /// A mock implementation of <see cref="SdkLoggerBase"/> that stores logged messages.
+    /// </summary>
+    public class MockSdkLogger : SdkLoggerBase
+    {
+        /// <summary>
+        /// Stores the list of messages that have been logged.
+        /// </summary>
+        private readonly List<KeyValuePair<string, MessageImportance>> _messages = new List<KeyValuePair<string, MessageImportance>>();
+
+        /// <summary>
+        /// Gets a list of messages that have been logged.
+        /// </summary>
+        public IReadOnlyCollection<KeyValuePair<string, MessageImportance>> LoggedMessages
+        {
+            get { return _messages; }
+        }
+
+        /// <inheritdoc cref="LogMessage"/>
+        public override void LogMessage(string message, MessageImportance messageImportance = MessageImportance.Low)
+        {
+            _messages.Add(new KeyValuePair<string, MessageImportance>(message, messageImportance));
+        }
+    }
+}
diff --git a/src/NuGetSdkResolver.UnitTests/MockSdkResolverContext.cs b/src/NuGetSdkResolver.UnitTests/MockSdkResolverContext.cs
new file mode 100644
index 00000000000..b1472f6c77c
--- /dev/null
+++ b/src/NuGetSdkResolver.UnitTests/MockSdkResolverContext.cs
@@ -0,0 +1,29 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using SdkResolverContextBase = Microsoft.Build.Framework.SdkResolverContext;
+
+namespace NuGet.MSBuildSdkResolver.UnitTests
+{
+    /// <summary>
+    /// A mock implementation of <see cref="SdkResolverContextBase"/> that uses a <see cref="MockSdkLogger"/>.
+    /// </summary>
+    public sealed class MockSdkResolverContext : SdkResolverContextBase
+    {
+        /// <summary>
+        /// Initializes a new instance of the MockSdkResolverContext class.
+        /// </summary>
+        /// <param name="projectPath">The path to the project.</param>
+        public MockSdkResolverContext(string projectPath)
+        {
+            Logger = MockSdkLogger;
+
+            ProjectFilePath = projectPath;
+        }
+
+        /// <summary>
+        /// Gets the <see cref="MockSdkLogger"/> being used by the context.
+        /// </summary>
+        public MockSdkLogger MockSdkLogger { get; } = new MockSdkLogger();
+    }
+}
diff --git a/src/NuGetSdkResolver.UnitTests/NuGet.MSBuildSdkResolver.UnitTests.csproj b/src/NuGetSdkResolver.UnitTests/NuGet.MSBuildSdkResolver.UnitTests.csproj
new file mode 100644
index 00000000000..3bbb2aed77d
--- /dev/null
+++ b/src/NuGetSdkResolver.UnitTests/NuGet.MSBuildSdkResolver.UnitTests.csproj
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup Condition="'$(Configuration)' == 'Debug-NetCore' or '$(Configuration)' == 'Release-NetCore'">
+    <TargetFrameworkVersion Condition="'$(TargetFrameworkVersion)' == ''">v1.5</TargetFrameworkVersion>
+  </PropertyGroup>
+  <Import Project="..\dir.props" />
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProjectGuid>{7FD51C62-1D6A-4DF5-9E70-E4D23CA3048C}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <RootNamespace>NuGet.MSBuildSdkResolver.UnitTests</RootNamespace>
+    <AssemblyName>NuGet.MSBuildSdkResolver.UnitTests</AssemblyName>
+    <IsTestProject>true</IsTestProject>
+  </PropertyGroup>
+  <!-- Default configurations to help VS understand the configurations -->
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' " />
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' " />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug-MONO|AnyCPU'" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release-MONO|AnyCPU'" />
+  <ItemGroup Condition="'$(NetCoreBuild)' != 'true'">
+    <Reference Include="$(CompilerToolsDir)\Microsoft.Build.Tasks.CodeAnalysis.dll">
+      <Name>Microsoft.Build.Tasks.CodeAnalysis</Name>
+    </Reference>
+    <Reference Include="System" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj">
+      <Project>{828566EE-6F6A-4EF4-98B0-513F7DF9C628}</Project>
+      <Name>Microsoft.Build.Utilities</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\Build\Microsoft.Build.csproj">
+      <Project>{16CD7635-7CF4-4C62-A77B-CF87D0F09A58}</Project>
+      <Name>Microsoft.Build</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj">
+      <Project>{571F09DB-A81A-4444-945C-6F7B530054CD}</Project>
+      <Name>Microsoft.Build.Framework</Name>
+    </ProjectReference>
+    <ProjectReference Include="..\NuGetSdkResolver\NuGet.MSBuildSdkResolver.csproj">
+      <Project>{C7988833-3EF2-43F4-A170-34E8CCCB1320}</Project>
+      <Name>NuGet.MSBuildSdkResolver</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="GlobalJsonReader_Tests.cs" />
+    <Compile Include="MockSdkLogger.cs" />
+    <Compile Include="MockSdkResolverContext.cs" />
+    <Compile Include="NuGetSdkLogger_Tests.cs" />
+    <Compile Include="NuGetSdkResolver_Tests.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="..\Shared\FxCopExclusions\Microsoft.Build.Shared.Suppressions.cs">
+      <Link>Shared\Microsoft.Build.Shared.Suppressions.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\UnitTests\MockLogger.cs">
+      <Link>Shared\MockLogger.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\UnitTests\ObjectModelHelpers.cs">
+      <Link>Shared\ObjectModelHelpers.cs</Link>
+    </Compile>
+    <Compile Include="..\Shared\UnitTests\TestEnvironment.cs">
+      <Link>Shared\TestEnvironment.cs</Link>
+    </Compile>
+  </ItemGroup>
+  <ItemGroup>
+    <AppDesigner Include="Properties\" />
+    <EmbeddedResource Include="*.resx">
+      <SubType>Designer</SubType>
+    </EmbeddedResource>
+    <None Include="..\Shared\UnitTests\App.config">
+      <Link>App.config</Link>
+      <SubType>Designer</SubType>
+    </None>
+    <None Include="project.json" />
+    <Service Include="{82A7F48D-3B50-4B1E-B82E-3ADA8210C358}" />
+  </ItemGroup>
+  <ItemGroup>
+    <Folder Include="Properties\" />
+  </ItemGroup>
+  <Import Project="..\dir.targets" />
+</Project>
\ No newline at end of file
diff --git a/src/NuGetSdkResolver.UnitTests/NuGetSdkLogger_Tests.cs b/src/NuGetSdkResolver.UnitTests/NuGetSdkLogger_Tests.cs
new file mode 100644
index 00000000000..5807bf65bab
--- /dev/null
+++ b/src/NuGetSdkResolver.UnitTests/NuGetSdkLogger_Tests.cs
@@ -0,0 +1,180 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Framework;
+using NuGet.Common;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using Xunit;
+
+namespace NuGet.MSBuildSdkResolver.UnitTests
+{
+    /// <summary>
+    /// Tests for LazyFormattedEventArgs
+    /// </summary>
+    public class NuGetSdkLogger_Tests
+    {
+        [Fact]
+        public void LogDebugMapsToMessage()
+        {
+            const string expectedMessage = "F4E2857F8B6F4ADC8D9B727DDBEE769B";
+
+            VerifyLog(sdkLogger => sdkLogger.LogDebug(expectedMessage), expectedMessage, MessageImportance.Low, isWarning: false, isError: false);
+        }
+
+        [Fact]
+        public void LogErrorMapsToError()
+        {
+            const string expectedMessage = "FC168C5B9E9C4FC199974BE664F5D723";
+
+            VerifyLog(sdkLogger => sdkLogger.LogError(expectedMessage), expectedMessage, expectedMessageImportance: null, isWarning: false, isError: true);
+        }
+
+        [Fact]
+        public void LogInformationMapsToMessage()
+        {
+            const string expectedMessage = "67170559A4EC47FE88FCC3E8B68E3522";
+
+            VerifyLog(sdkLogger => sdkLogger.LogInformation(expectedMessage), expectedMessage, MessageImportance.Low, isWarning: false, isError: false);
+        }
+
+        [Fact]
+        public void LogInformationSummaryMapsToMessage()
+        {
+            const string expectedMessage = "EA9F5D816A0342E38A4A87DB955ABC33";
+
+            VerifyLog(sdkLogger => sdkLogger.LogInformationSummary(expectedMessage), expectedMessage, MessageImportance.Low, isWarning: false, isError: false);
+        }
+
+        [Theory]
+        [InlineData(LogLevel.Debug, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Information, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Minimal, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Verbose, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Error, null, false, true)]
+        [InlineData(LogLevel.Warning, null, true, false)]
+        [InlineData(999, null, false, false)]
+        public void LogLevelMapsToMessageWarningOrError(LogLevel logLevel, MessageImportance? expectedMessageImportance = null, bool isWarning = false, bool isError = false)
+        {
+            const string expectedMessage = "BE0F702B91714CED9AAE850CE1798430";
+
+            VerifyLog(sdkLogger => sdkLogger.Log(logLevel, expectedMessage), expectedMessage, expectedMessageImportance, isWarning, isError);
+        }
+
+        [Theory]
+        [InlineData(LogLevel.Debug, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Information, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Minimal, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Verbose, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Error, null, false, true)]
+        [InlineData(LogLevel.Warning, null, true, false)]
+        [InlineData(999, null, false, false)]
+        public void LogLevelMapsToMessageWarningOrErrorAsync(LogLevel logLevel, MessageImportance? expectedMessageImportance = null, bool isWarning = false, bool isError = false)
+        {
+            const string expectedMessage = "BE0F702B91714CED9AAE850CE1798430";
+
+            VerifyLog(async sdkLogger => await sdkLogger.LogAsync(logLevel, expectedMessage).ConfigureAwait(false), expectedMessage, expectedMessageImportance, isWarning, isError);
+        }
+
+        [Theory]
+        [InlineData(LogLevel.Debug, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Information, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Minimal, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Verbose, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Error, null, false, true)]
+        [InlineData(LogLevel.Warning, null, true, false)]
+        [InlineData(999, null, false, false)]
+        public void LogMessageMapsToMessageWarningOrError(LogLevel logLevel, MessageImportance? expectedMessageImportance = null, bool isWarning = false, bool isError = false)
+        {
+            const string expectedMessage = "B8F887DBCA4A4748824E9ED3CAC484A0";
+
+            ILogMessage logMessage = new LogMessage(logLevel, expectedMessage);
+
+            VerifyLog(sdkLogger => sdkLogger.Log(logMessage), expectedMessage, expectedMessageImportance, isWarning, isError);
+        }
+
+        [Theory]
+        [InlineData(LogLevel.Debug, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Information, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Minimal, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Verbose, MessageImportance.Low, false, false)]
+        [InlineData(LogLevel.Error, null, false, true)]
+        [InlineData(LogLevel.Warning, null, true, false)]
+        [InlineData(999, null, false, false)]
+        public void LogMessageMapsToMessageWarningOrErrorAsync(LogLevel logLevel, MessageImportance? expectedMessageImportance = null, bool isWarning = false, bool isError = false)
+        {
+            const string expectedMessage = "5022EC7B7A694D41BFF1A6ED973297A4";
+
+            ILogMessage logMessage = new LogMessage(logLevel, expectedMessage);
+
+            VerifyLog(async sdkLogger => await sdkLogger.LogAsync(logMessage).ConfigureAwait(false), expectedMessage, expectedMessageImportance, isWarning, isError);
+        }
+
+        [Fact]
+        public void LogMinimalSummaryMapsToMessage()
+        {
+            const string expectedMessage = "D6412F6087CE41C4803AD940E26E221B";
+
+            VerifyLog(sdkLogger => sdkLogger.LogMinimal(expectedMessage), expectedMessage, MessageImportance.Low, isWarning: false, isError: false);
+        }
+
+        [Fact]
+        public void LogVerboseMapsToMessage()
+        {
+            const string expectedMessage = "815F49653DB74CD6BD2B66201BB3BCA8";
+
+            VerifyLog(sdkLogger => sdkLogger.LogVerbose(expectedMessage), expectedMessage, MessageImportance.Low, isWarning: false, isError: false);
+        }
+
+        [Fact]
+        public void LogWarningMapsToWarning()
+        {
+            const string expectedMessage = "787607F4D1B141F898CCB432B5CB8CDE";
+
+            VerifyLog(sdkLogger => sdkLogger.LogWarning(expectedMessage), expectedMessage, expectedMessageImportance: null, isWarning: true, isError: false);
+        }
+
+        private void VerifyLog(Action<NuGetSdkLogger> action, string expectedMessage, MessageImportance? expectedMessageImportance, bool isWarning, bool isError)
+        {
+            MockSdkLogger mockLogger = new MockSdkLogger();
+
+            List<string> errors = new List<string>();
+            List<string> warnings = new List<string>();
+
+            NuGetSdkLogger sdkLogger = new NuGetSdkLogger(mockLogger, warnings, errors);
+
+            action(sdkLogger);
+
+            if (expectedMessageImportance.HasValue)
+            {
+                KeyValuePair<string, MessageImportance> item = mockLogger.LoggedMessages.ShouldHaveSingleItem();
+
+                item.Key.ShouldBe(expectedMessage);
+                item.Value.ShouldBe(expectedMessageImportance.Value);
+            }
+            else
+            {
+                mockLogger.LoggedMessages.ShouldBeEmpty();
+            }
+
+            if (isWarning)
+            {
+                warnings.ShouldHaveSingleItem().ShouldBe(expectedMessage);
+            }
+            else
+            {
+                warnings.ShouldBeEmpty();
+            }
+
+            if (isError)
+            {
+                errors.ShouldHaveSingleItem().ShouldBe(expectedMessage);
+            }
+            else
+            {
+                errors.ShouldBeEmpty();
+            }
+        }
+    }
+}
diff --git a/src/NuGetSdkResolver.UnitTests/NuGetSdkResolver_Tests.cs b/src/NuGetSdkResolver.UnitTests/NuGetSdkResolver_Tests.cs
new file mode 100644
index 00000000000..944ae7a7e28
--- /dev/null
+++ b/src/NuGetSdkResolver.UnitTests/NuGetSdkResolver_Tests.cs
@@ -0,0 +1,126 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Engine.UnitTests;
+using NuGet.Versioning;
+using Shouldly;
+using System.Collections.Generic;
+using Xunit;
+
+using SdkResolverContextBase = Microsoft.Build.Framework.SdkResolverContext;
+
+namespace NuGet.MSBuildSdkResolver.UnitTests
+{
+    public class NuGetSdkResolver_Tests
+    {
+        [Fact]
+        public void TryGetNuGetVersionForSdkGetsVersionFromGlobalJson()
+        {
+            Dictionary<string, string> expectedVersions = new Dictionary<string, string>
+            {
+                {"foo", "5.11.77"},
+                {"bar", "2.0.0"}
+            };
+
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestProjectWithFiles projectWithFiles = testEnvironment.CreateTestProjectWithFiles("", relativePathFromRootToProject: @"a\b\c");
+
+                GlobalJsonReader_Tests.WriteGlobalJson(projectWithFiles.TestRoot, expectedVersions);
+
+                MockSdkResolverContext context = new MockSdkResolverContext(projectWithFiles.ProjectFile);
+
+                VerifyTryGetNuGetVersionForSdk(
+                    version: null,
+                    expectedVersion: NuGetVersion.Parse(expectedVersions["foo"]),
+                    context: context);
+            }
+        }
+
+        [Fact]
+        public void TryGetNuGetVersionForSdkGetsVersionFromState()
+        {
+            MockSdkResolverContext context = new MockSdkResolverContext("foo.proj")
+            {
+                State = new Dictionary<string, string>
+                {
+                    {"foo", "1.2.3"}
+                }
+            };
+
+            VerifyTryGetNuGetVersionForSdk(
+                version: null,
+                expectedVersion: NuGetVersion.Parse("1.2.3"),
+                context: context);
+        }
+
+        [Fact]
+        public void TryGetNuGetVersionForSdkInvalidVersion()
+        {
+            VerifyTryGetNuGetVersionForSdk(
+                version: "abc",
+                expectedVersion: null);
+        }
+
+        [Fact]
+        public void TryGetNuGetVersionForSdkInvalidVersionInGlobalJson()
+        {
+            MockSdkResolverContext context = new MockSdkResolverContext("foo.proj")
+            {
+                State = new Dictionary<string, string>
+                {
+                    {"foo", "abc"}
+                }
+            };
+
+            VerifyTryGetNuGetVersionForSdk(
+                version: "abc",
+                expectedVersion: null,
+                context: context);
+        }
+
+        [Fact]
+        public void TryGetNuGetVersionForSdkSucceeds()
+        {
+            VerifyTryGetNuGetVersionForSdk(
+                version: "3.2.1",
+                expectedVersion: NuGetVersion.Parse("3.2.1"));
+        }
+
+        [Fact]
+        public void TryGetNuGetVersionNoVersionSpecified()
+        {
+            MockSdkResolverContext context = new MockSdkResolverContext("foo.proj")
+            {
+                State = new Dictionary<string, string>()
+            };
+
+            VerifyTryGetNuGetVersionForSdk(
+                version: null,
+                expectedVersion: null,
+                context: context);
+        }
+
+        private void VerifyTryGetNuGetVersionForSdk(string version, NuGetVersion expectedVersion, SdkResolverContextBase context = null)
+        {
+            object parsedVersion;
+
+            bool result = NuGetSdkResolver.TryGetNuGetVersionForSdk("foo", version, context, out parsedVersion);
+
+            if (expectedVersion != null)
+            {
+                result.ShouldBeTrue();
+
+                parsedVersion.ShouldNotBeNull();
+
+                parsedVersion.ShouldBe(expectedVersion);
+            }
+            else
+            {
+                result.ShouldBeFalse();
+
+                parsedVersion.ShouldBeNull();
+            }
+        }
+    }
+}
diff --git a/src/NuGetSdkResolver.UnitTests/project.json b/src/NuGetSdkResolver.UnitTests/project.json
new file mode 100644
index 00000000000..896af307eb7
--- /dev/null
+++ b/src/NuGetSdkResolver.UnitTests/project.json
@@ -0,0 +1,23 @@
+﻿{
+  "dependencies": {
+    "NuGet.Commands": "4.6.0-rtm-4822",
+    "NuGet.Protocol": "4.6.0-rtm-4822",
+    "Shouldly": "3.0.0-beta0003",
+    "xunit": "2.1.0"
+  },
+  "frameworks": {
+    "net46": {
+      "dependencies": {
+       "System.Runtime.InteropServices.RuntimeInformation": "4.3.0"
+      }
+    },
+    "netstandard1.5": {
+      "dependencies": {
+        "NETStandard.Library": "1.6.0",
+        "System.Collections.NonGeneric": "4.0.1",
+        "System.Xml.XmlDocument": "4.0.1"
+      },
+      "imports": [ "portable-net451+win81" ]
+    }
+  }
+}
diff --git a/src/NuGetSdkResolver/NuGet.MSBuildSdkResolver.csproj b/src/NuGetSdkResolver/NuGet.MSBuildSdkResolver.csproj
index f38c9fa4125..abdacc3c8e3 100644
--- a/src/NuGetSdkResolver/NuGet.MSBuildSdkResolver.csproj
+++ b/src/NuGetSdkResolver/NuGet.MSBuildSdkResolver.csproj
@@ -64,6 +64,9 @@
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>Shared\FileUtilities.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\TempFileUtilities.cs">
+      <Link>Shared\TempFileUtilities.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>Shared\FileUtilitiesRegex.cs</Link>
     </Compile>
diff --git a/src/NuGetSdkResolver/Properties/AssemblyInfo.cs b/src/NuGetSdkResolver/Properties/AssemblyInfo.cs
index 7273fd2aeea..317c4a40474 100644
--- a/src/NuGetSdkResolver/Properties/AssemblyInfo.cs
+++ b/src/NuGetSdkResolver/Properties/AssemblyInfo.cs
@@ -7,6 +7,8 @@
 
 using System;
 using System.Reflection;
+using System.Runtime.CompilerServices;
+
 #if (LOCALIZED_BUILD)
 using System.Resources;
 #endif
@@ -34,3 +36,5 @@
 [assembly: AssemblyCompany("Microsoft Corporation")]
 [assembly: AssemblyProduct("Microsoft® Build Tools®")]
 [assembly: AssemblyCopyright("© Microsoft Corporation. All rights reserved.")]
+
+[assembly: InternalsVisibleTo("NuGet.MSBuildSdkResolver.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/NuGetSdkResolver/project.json b/src/NuGetSdkResolver/project.json
index 16728884960..49aef9daa42 100644
--- a/src/NuGetSdkResolver/project.json
+++ b/src/NuGetSdkResolver/project.json
@@ -1,7 +1,7 @@
 ﻿{
   "dependencies": {
-    "NuGet.Commands": "4.5.0",
-    "NuGet.Protocol": "4.5.0"
+      "NuGet.Commands": "4.6.0-rtm-4822",
+      "NuGet.Protocol": "4.6.0-rtm-4822"
   },
   "frameworks": {
     "net46": {
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index 9fa3474a38c..0fac1343344 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -185,8 +185,7 @@ public string Parameters
          */
         public void Initialize(IEventSource eventSource)
         {
-            eventSource.AnyEventRaised +=
-                    new AnyEventHandler(LoggerEventHandler);
+            eventSource.AnyEventRaised += LoggerEventHandler;
         }
 
         /// <summary>
@@ -219,6 +218,8 @@ public MockLogger(ITestOutputHelper testOutputHelper)
             _testOutputHelper = testOutputHelper;
         }
 
+        public List<Action<object, BuildEventArgs>> AdditionalHandlers { get; set; } = new List<Action<object, BuildEventArgs>>();
+
         /*
          * Method:  LoggerEventHandler
          *
@@ -229,6 +230,11 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
         {
             AllBuildEvents.Add(eventArgs);
 
+            foreach (var handler in AdditionalHandlers)
+            {
+                handler(sender, eventArgs);
+            }
+
             if (eventArgs is BuildWarningEventArgs)
             {
                 BuildWarningEventArgs w = (BuildWarningEventArgs) eventArgs;
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 99d3052cd76..e99fef78e7d 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -324,6 +324,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <PropertyGroup>
     <GenerateBindingRedirectsOutputType Condition="'$(OutputType)'=='exe' or '$(OutputType)'=='winexe'">true</GenerateBindingRedirectsOutputType>
+    <!-- It would be a breaking change to automatically turn on binding redirects for existing projects, so turn them on only when opting into a new framework. -->
+    <AutoGenerateBindingRedirects Condition="'$(AutoGenerateBindingRedirects)' == '' and '$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetFrameworkVersion.TrimStart(vV))' >= '4.7.2'">true</AutoGenerateBindingRedirects>
   </PropertyGroup>
   <PropertyGroup Condition="'$(AutoUnifyAssemblyReferences)' == ''">
     <AutoUnifyAssemblyReferences>true</AutoUnifyAssemblyReferences>
@@ -1895,8 +1897,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
         <TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
         <TargetFrameworkIdentifier>$(TargetFrameworkIdentifier)</TargetFrameworkIdentifier>
-        <TargetFrameworkVersion>$(TargetFrameworkVersion)</TargetFrameworkVersion>
-        <TargetFrameworkVersion Condition="$(TargetFrameworkVersion.StartsWith('v'))">$(TargetFrameworkVersion.Substring(1))</TargetFrameworkVersion>
+        <TargetFrameworkVersion>$(TargetFrameworkVersion.TrimStart('vV'))</TargetFrameworkVersion>
         <ReferenceAssembly Condition="'$(ProduceReferenceAssembly)' == 'true'">$(TargetRefPath)</ReferenceAssembly>
         <CopyUpToDateMarker>@(CopyUpToDateMarker)</CopyUpToDateMarker>
       </TargetPathWithTargetPlatformMoniker>
diff --git a/src/dirs.proj b/src/dirs.proj
index 39ec811590f..822e56dc418 100644
--- a/src/dirs.proj
+++ b/src/dirs.proj
@@ -21,6 +21,7 @@
     <Project Include="Build.OM.UnitTests\Microsoft.Build.Engine.OM.UnitTests.csproj" />
     <Project Include="UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
     <Project Include="NuGetSdkResolver\NuGet.MSBuildSdkResolver.csproj" />
+    <Project Include="NuGetSdkResolver.UnitTests\NuGet.MSBuildSdkResolver.UnitTests.csproj" />
   </ItemGroup>
 
   <Import Project="dir.targets" />
diff --git a/targets/DeployDependencies.proj b/targets/DeployDependencies.proj
index eacc18154a3..c6a18881554 100644
--- a/targets/DeployDependencies.proj
+++ b/targets/DeployDependencies.proj
@@ -27,20 +27,19 @@
   -->
   <Target Name="CopyNuGetTargets">
     <ItemGroup Condition="'$(NetCoreBuild)' != 'true'">
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.build.tasks\$(NuGetVersion)\lib\net45\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.build.tasks\$(NuGetVersion)\lib\net46\**\*.*" />
       <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.build.tasks\$(NuGetVersion)\runtimes\any\native\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.commands\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.common\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.configuration\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.dependencyresolver.core\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.frameworks\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.librarymodel\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.packaging\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.packaging.core\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.projectmodel\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.protocol\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.versioning\$(NuGetVersion)\lib\net45\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuspec.referencegenerator\$(NuGetVersion)\lib\net45\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.commands\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.common\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.configuration\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.dependencyresolver.core\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.frameworks\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.librarymodel\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.packaging\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.packaging.core\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.projectmodel\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.protocol\$(NuGetVersion)\lib\net46\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.versioning\$(NuGetVersion)\lib\net46\**\*.*" />
       <NuGetCommonExtensions Include="$(ProjectDir)packages\Newtonsoft.Json\9.0.1\lib\net45\**\*.*" />
     </ItemGroup>
     <ItemGroup Condition="'$(NetCoreBuild)' == 'true'">
@@ -56,8 +55,7 @@
       <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.packaging.core\$(NuGetVersion)\lib\netstandard1.3\**\*.*" />
       <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.projectmodel\$(NuGetVersion)\lib\netstandard1.3\**\*.*" />
       <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.protocol\$(NuGetVersion)\lib\netstandard1.3\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.versioning\$(NuGetVersion)\lib\netstandard1.0\**\*.*" />
-      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuspec.referencegenerator\$(NuGetVersion)\lib\netstandard1.3\**\*.*" />
+      <NuGetCommonExtensions Include="$(ProjectDir)packages\nuget.versioning\$(NuGetVersion)\lib\netstandard1.3\**\*.*" />
       <NuGetCommonExtensions Include="$(ProjectDir)packages\Newtonsoft.Json\9.0.1\lib\netstandard1.0\**\*.*" />
     </ItemGroup>
 
